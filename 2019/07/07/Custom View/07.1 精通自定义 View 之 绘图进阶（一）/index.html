<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>07.1 精通自定义 View 之 绘图进阶（一） | King</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">07.1 精通自定义 View 之 绘图进阶（一）</h1><a id="logo" href="/.">King</a><p class="description">xianxiaotao</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">07.1 精通自定义 View 之 绘图进阶（一）</h1><div class="post-meta">Jul 7, 2019<span> | </span><span class="category"><a href="/categories/Custom-View/">Custom View</a></span></div><div class="post-content"><meta name="referrer" content="no-referrer">

<h2 id="7-1-贝济埃曲线"><a href="#7-1-贝济埃曲线" class="headerlink" title="7.1 贝济埃曲线"></a>7.1 贝济埃曲线</h2><h4 id="7-1-1-概述"><a href="#7-1-1-概述" class="headerlink" title="7.1.1 概述"></a>7.1.1 概述</h4><p>在 Path 的系列函数中，除了一些基本的设置和绘图用法外，还有一个强大的工具——贝济埃曲线。它能将利用 moveTo、lineTo 连接的生硬路径变得平滑，也能够实现很多炫酷的效果，比如水波纹等。</p>
<h6 id="1-贝赛尔曲线来源"><a href="#1-贝赛尔曲线来源" class="headerlink" title="1. 贝赛尔曲线来源"></a>1. 贝赛尔曲线来源</h6><p>贝塞尔曲线于 1962 年，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由 Paul de Casteljau 于 1959 年运用 de Casteljau 算法开发，以稳定数值的方法求出贝塞尔曲线。</p>
<p>在数学的数值分析领域中，贝赛尔曲线（Bézier 曲线）是电脑图形学中相当重要的参数曲线。更高维度的广泛化贝塞尔曲线就称作贝塞尔曲面，其中贝塞尔三角是一种特殊的实例。</p>
<h6 id="2-贝济埃曲线公式"><a href="#2-贝济埃曲线公式" class="headerlink" title="2. 贝济埃曲线公式"></a>2. 贝济埃曲线公式</h6><p><strong>1）一阶贝济埃曲线</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-d7535084366336a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-88a1d9f33c56d0d5?imageMogr2/auto-orient/strip" alt=""></p>
<p>P0 为起点、P1 为终点，t 表示当前时间，B(t) 表示公式的结果值。<br>注意，曲线的意义就是公式结果 B(t) 随时间的变化，其取值所形成的轨迹。在动画中，黑色点表示在当前时间 t 下公式 B(t) 的取值。而红色的那条线就不在各个时间点下不同取值的 B(t) 所形成的轨迹。</p>
<p>总而言之：对于一阶贝济埃曲线，大家可以理解为在起始点和终点形成的这条直线上，匀速移动的点。</p>
<p><strong>2）二阶贝济埃曲线</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-d0fab250e052d246?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-723ce7c1ee1e0016?imageMogr2/auto-orient/strip" alt=""></p>
<p>在这里 P0 是起始点，P2 是终点，P1 是控制点。<br>假设将时间定在 t=0.25 的时刻，此时的状态如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-b43003ea2bdfb507?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>首先，P0 点和 P1 点形成了一条贝济埃曲线，还记得我们上面对一阶贝济埃曲线的总结么：就是一个点在这条直线上做匀速运动；所以 P0-P1 这条直线上的移动的点就是 Q0。</p>
<p>同样，P1、P2 形成了一条一阶贝济埃曲线，在这条一阶贝济埃曲线上，它们的随时间移动的点是 Q1。</p>
<p>最后，动态点 Q0 和 Q1 又形成了一条一阶贝济埃曲线，在它们这条一阶贝济埃曲线动态移动的点是 B。而 B 的移动轨迹就是这个二阶贝济埃曲线的最终形态。从上面的讲解大家也可以知道，之所以叫它二阶贝济埃曲线是因为，B 的移动轨迹是建立在两个一阶贝济埃曲线的中间点 Q0、Q1 的基础上的。</p>
<p>在理解了二阶贝赛尔曲线的形成原理以后，我们就不难理解三阶贝赛尔曲线了。</p>
<p><strong>3）三阶贝济埃曲线</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-044ad9428fcbbc29?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-2c38ba6a9c8950a3?imageMogr2/auto-orient/strip" alt=""></p>
<p>同样，我们取其中一点来讲解轨迹的形成原理，当 t=0.25 时,此时状态如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-f67fcc49e576bc40?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>同样，P0 是起始点，P3 是终点；P1 是第一个控制点，P2 是第二个控制点。</p>
<p>首先，这里有三条一阶贝济埃曲线，分别是 P0-P1、P1-P2、P2-P3，他们随时间变化的点分别为 Q0、Q1、Q2。然后是由 Q0、Q1、Q2 这三个点，再次连接，形成了两条一阶贝济埃曲线，分别是Q0-Q1、Q1-Q2，他们随时间变化的点为 R0、R1。</p>
<p>同样，R0 和 R1 同样可以连接形成一条一阶贝济埃曲线，在 R0-R1 这条贝赛尔曲线上随时间移动的点是 B，而 B 的移动轨迹就是这个三阶贝济埃曲线的最终形状。</p>
<p>从上面的解析大家可以看出，所谓几阶贝济埃曲线，全部是由一条条一阶贝济埃曲线搭起来的。在上图中，形成一阶贝济埃曲线的直线是灰色的，形成二阶贝济埃曲线线是绿色的，形成三阶贝济埃曲线的线是蓝色的。</p>
<p>在理解了上面的二阶和三阶贝济埃曲线以后，我们再来看几个贝济埃曲线的动态图。</p>
<p><strong>4）四阶贝济埃曲线</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-91e7647f793fd876?imageMogr2/auto-orient/strip" alt=""></p>
<p><strong>5）五阶贝济埃曲线</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-e28ef335e39c174f?imageMogr2/auto-orient/strip" alt=""></p>
<p>######3. 贝济埃曲线与 PhotoShop 钢笔工具<br>在专业绘图工具 Photoshop 中，有一个钢笔工具，它使用的路径弯曲效果就是二阶贝济埃曲线，下面利用 Photoshop 的钢笔工具来得出二阶贝济埃曲线的相关控制点。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-003dae5d4ff785c8?imageMogr2/auto-orient/strip" alt=""></p>
<p>我们拿最终成形的图形来看一下为什么钢笔工具是二阶贝济埃曲线：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-cb15295694db8eff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>右图演示的假设某一点 t=0.25 时，动态点 B 的位置图。<br>同样，这里 P0 是起始点，P2 是终点，P1 是控制点。<br>P0-P1、P1-P2 形成了第一层的一阶贝济埃曲线。它们随时间的动态点分别是 Q0、Q1；动态点 Q0、Q1 又形成了第二层的一阶贝济埃曲线，它们的动态点是 B。而 B 的轨迹跟钢笔工具的形状是完全一样的，所以说钢笔工具的拉伸效果使用的是二阶贝济埃曲线。</p>
<p>这里需要注意的是，我们在使用钢笔工具时，拖动的是 P5 点。其实二阶贝济埃曲线的控制点是其对面的 P1 点，钢笔工具这样设计是当然是因为操作起来比较方便。</p>
<h4 id="7-1-2-贝济埃曲线之-quadTo"><a href="#7-1-2-贝济埃曲线之-quadTo" class="headerlink" title="7.1.2 贝济埃曲线之 quadTo"></a>7.1.2 贝济埃曲线之 quadTo</h4><p>在 Path 类中有四个方法与贝济埃曲线相关，分别是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 二阶济埃尔</div><div class="line">public void quadTo(float x1, float y1, float x2, float y2)</div><div class="line">public void rQuadTo(float dx1, float dy1, float dx2, float dy2)</div><div class="line">// 三阶济埃尔</div><div class="line">public void cubicTo(float x1, float y1, float x2, float y2,float x3, float y3)</div><div class="line">public void rCubicTo(float x1, float y1, float x2, float y2,float x3, float y3)</div></pre></td></tr></table></figure></p>
<p>在这四个函数中 quadTo、rQuadTo 是二阶贝济埃曲线，cubicTo、rCubicTo 是三阶贝济埃曲线；我们这篇文章以二阶贝济埃曲线的 quadTo、rQuadTo 为主，三阶贝济埃曲线 cubicTo、rCubicTo 用的使用方法与二阶贝济埃曲线类似，用处也比较少，这篇就不再细讲了。</p>
<h6 id="1-quadTo-使用原理"><a href="#1-quadTo-使用原理" class="headerlink" title="1. quadTo 使用原理"></a>1. quadTo 使用原理</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void quadTo(float x1, float y1, float x2, float y2)</div></pre></td></tr></table></figure>
<p>参数中 (x1,y1) 是控制点坐标，(x2,y2) 是终点坐标。<br>大家可能会有一个疑问：有控制点和终点坐标，那起始点是多少呢？<br>整条线的起始点是通过 Path.moveTo(x,y) 来指定的，而如果我们连续调用 quadTo()，前一个 quadTo() 的终点，就是下一个 quadTo() 函数的起点；如果初始没有调用 Path.moveTo(x,y) 来指定起始点，则默认以控件左上角(0,0)为起始点。大家可能还是有点迷糊，下面我们就举个例子来看看，我们利用 quadTo() 来画下面的这条波浪线：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-8c334c61c48848cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>下面分析一下，在这条路径轨迹中，控制点分别在哪个位置，如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-e37060659bbc933e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>我们先看 P0-P2 这条轨迹，P0 是起点，假设位置坐标是 (100,300)，P2 是终点，假充位置坐标是 (300,300)；在以 P0 为起始点，P2 为终点这条二阶贝济埃曲线上，P1 是控制点，很明显 P1 大概在 P0、P2 中间的位置，所以它的 X 坐标应该是 200，关于 Y 坐标，我们无法确定，但很明显的是 P1 在 P0、P2 点的上方，也就是它的 Y 值比它们的小，所以根据钢笔工具上面的位置，我们让 P1 的比 P0、P2 的小 100，所以 P1的坐标是 (200，200)。</p>
<p>同理，不难求出在 P2-P4 这条二阶贝济埃曲线上，它们的控制点 P3 的坐标位置应该是 (400,400)。</p>
<p>所以我们就可以自定义一个控件，并重写它的 onDraw() 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setStrokeWidth(4);</div><div class="line">        mPaint.setColor(Color.GRAY);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setAntiAlias(true);</div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        mPath.moveTo(100, 300);</div><div class="line">        mPath.quadTo(200, 200, 300, 300);</div><div class="line">        mPath.quadTo(400, 400, 500, 300);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过这个例子希望大家知道两点：</p>
<ul>
<li>整条线的起始点是通过 Path.moveTo(x,y) 来指定的，如果初始没有调用 Path.moveTo(x,y) 来指定起始点，则默认以控件左上角 (0,0) 为起始点。</li>
<li>如果我们连续调用 quadTo()，前一个 quadTo() 的终点，就是下一个 quadTo() 函数的起点。</li>
</ul>
<h6 id="2-示例：手指轨迹"><a href="#2-示例：手指轨迹" class="headerlink" title="2. 示例：手指轨迹"></a>2. 示例：手指轨迹</h6><p>要实现手指轨迹其实是非常简单的，我们只需要在自定义中拦截 OnTouchEvent，然后根据手指的移动轨迹来绘制 Path 即可。最简单的方法就是直接使用 Path.lineTo() 就能实现把各个点连接起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(4);</div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        switch (event.getAction())&#123;</div><div class="line">            case MotionEvent.ACTION_DOWN:</div><div class="line">                mPath.moveTo(event.getX(), event.getY());</div><div class="line">                return true;</div><div class="line">            case MotionEvent.ACTION_MOVE:</div><div class="line">                mPath.lineTo(event.getX(), event.getY());</div><div class="line">                invalidate();</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然实现了画出手指的移动轨迹，但我们仔细来看看画出来的图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-d6cd12f5a2fbbdd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>我们把轨迹放大，明显看出，在两个点连接处有明显的转折，而且在轨迹顶部位置横纵坐标变化比较快的位置，看起来跟图片这大后的马赛克一样；利用 Path 绘图，是不可能出现马赛克的，因为除了 Bitmap 以外的任何 canvas 绘图全部都是矢量图，也就是利用数学公式来作出来的图，无论放在多大屏幕上，都不可能会出现马赛克。这里利用 Path 绘图，在轨迹顶部之所以看起来像是马赛克是因为这个轨迹是由各个不同点之间连线写出来的，而之间并没有平滑过渡，所以当坐标变化比较剧烈时，线与线之间的转折就显得特别明显了。</p>
<p>所以要想优化这种效果，就得实现线与线之间的平滑过渡，很显然，二阶贝济埃曲线就是干这个事的。下面我们就利用我们新学的 Path.quadTo 函数来重新实现下移动轨迹效果。</p>
<h6 id="3-优化：使用-Path-quadTo-函数实现手势过渡"><a href="#3-优化：使用-Path-quadTo-函数实现手势过渡" class="headerlink" title="3. 优化：使用 Path.quadTo() 函数实现手势过渡"></a>3. 优化：使用 Path.quadTo() 函数实现手势过渡</h6><p>使用 Path.lineTo() 的最大问题就是线段转折处不够平滑。Path.quadTo() 可以实现平滑过渡，但使用 Path.quadTo() 的最大问题是，如何找到起始点和结束点。</p>
<p>下图中，有用绿点表示的三个点，连成的两条直线，很明显他们转折处是有明显折痕的</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-88af940cfd85bb19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>下面我们在 PhotoShop 中利用钢笔工具，看如何才能实现这两条线之间的转折。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-65b3cc5c9634eb46?imageMogr2/auto-orient/strip" alt=""></p>
<p>最终的贝济埃曲线连接如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-b26dea192018dcc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>从这两个线段中可以看出，我们使用 Path.lineTo() 的时候，是直接把手指触点 A、B、C 给连起来。而钢笔工具要实现这三个点间的流畅过渡，就只能将这两个线段的中间点做为起始点和结束点，而将手指的倒数第二个触点 B 做为控制点。</p>
<p>大家可能会觉得，那这样，在结束的时候，A 到 P0 和 P1 到 C1 的这段距离岂不是没画进去？是的，如果 Path 最终没有 close 的话，这两段距离是被抛弃掉的。因为手指间滑动时，每两个点间的距离很小，所以 P1 到 C 之间的距离可以忽略不计。</p>
<p>下面我们就利用这种方法在photoshop中求证，在连接多个线段时，是否能行？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-c8dbebc11cee4204.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在这个图形中，有很多点连成了弯弯曲曲的线段，我们利用上面我们讲的，将两个线段的中间做为二阶贝济埃曲线的起始点和终点，把上一个手指的位置做为控制点，来看看是否真的能组成平滑的连线<br>整个连接过程如动画所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-c2167deb01b0a691?imageMogr2/auto-orient/strip" alt=""></p>
<p>在最终的路径中看来，各个点间的连线是非常平滑的。从这里也可以看出，在为了实现平滑效果，我们只能把开头的线段一半和结束的线段的一半抛弃掉。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-a218b1d8f0dce88d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line">    private float mPreX, mPreY;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(4);</div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        switch (event.getAction())&#123;</div><div class="line">            case MotionEvent.ACTION_DOWN:</div><div class="line">                mPath.moveTo(event.getX(), event.getY());</div><div class="line">                mPreX = event.getX();</div><div class="line">                mPreY = event.getY();</div><div class="line">                return true;</div><div class="line">            case MotionEvent.ACTION_MOVE:</div><div class="line">                float endX = (mPreX + event.getX()) / 2;</div><div class="line">                float endY = (mPreY + event.getY()) / 2;</div><div class="line">                mPath.quadTo(mPreX, mPreY, endX, endY);</div><div class="line">                mPreX = event.getX();</div><div class="line">                mPreY = event.getY();</div><div class="line">                invalidate();</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="7-1-3-贝济埃曲线之-rQuadTo"><a href="#7-1-3-贝济埃曲线之-rQuadTo" class="headerlink" title="7.1.3 贝济埃曲线之 rQuadTo"></a>7.1.3 贝济埃曲线之 rQuadTo</h4><h6 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void rQuadTo(float dx1, float dy1, float dx2, float dy2)</div></pre></td></tr></table></figure>
<ul>
<li>dx1：控制点 X 坐标，表示相对上一个终点 X 坐标的位移坐标，可为负值，正值表示相加，负值表示相减。</li>
<li>dy1：控制点 Y 坐标，表示相对上一个终点 Y 坐标的位移坐标。同样可为负值，正值表示相加，负值表示相减。</li>
<li>dx2：终点 X 坐标，同样是一个相对坐标，相对上一个终点 X 坐标的位移值，可为负值，正值表示相加，负值表示相减。</li>
<li>dy2：终点 Y 坐标，同样是一个相对，相对上一个终点 Y 坐标的位移值。可为负值，正值表示相加，负值表示相减。</li>
</ul>
<p>这四个参数都是传递的都是相对值，相对上一个终点的位移值。</p>
<p>比如，我们上一个终点坐标是 (300,400) 那么利用，rQuadTo(100,-100,200,100) 得到的控制点坐标是 (300+100, 400-100) 即 (500,300)；同样，得到的终点坐标是 (300+200, 400+100)，即 (500,500)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 利用 quadTo 定义一个绝对坐标：</div><div class="line">path.moveTo(300,400);</div><div class="line">path.quadTo(500,300,500,500);</div><div class="line"></div><div class="line">// 与利用 rQuadTo 定义相对坐标是等价的：</div><div class="line">path.moveTo(300,400);</div><div class="line">path.rQuadTo(100,-100,200,100)</div></pre></td></tr></table></figure></p>
<h6 id="2-使用-rQuadTo-函数实现波浪线"><a href="#2-使用-rQuadTo-函数实现波浪线" class="headerlink" title="2. 使用 rQuadTo() 函数实现波浪线"></a>2. 使用 rQuadTo() 函数实现波浪线</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mPath.moveTo(100, 300);</div><div class="line">/*</div><div class="line">mPath.quadTo(200, 200, 300, 300);</div><div class="line">mPath.quadTo(400, 400, 500, 300);</div><div class="line">*/</div><div class="line">// 替换成</div><div class="line">mPath.rQuadTo(100, -100, 200, 0);</div><div class="line">mPath.rQuadTo(100, 100, 200, 0);</div><div class="line">canvas.drawPath(mPath, mPaint);</div></pre></td></tr></table></figure>
<p>第一句：path.rQuadTo(100,-100,200,0); 是建立在 (100,300) 这个点基础上来计算相对坐标的，所以：<br>控制点X坐标 = 上一个终点X坐标+控制点X位移 = 100+100=200；<br>控制点Y坐标 = 上一个终点Y坐标+控制点Y位移 = 300-100=200；<br>终点X坐标 = 上一个终点X坐标+终点X位移 = 100+200=300；<br>终点Y坐标 = 上一个终点Y坐标+终点Y位移 = 300+0=300;<br>所以这句与 path.quadTo(200,200,300,300); 对等的。</p>
<p>第二句：path.rQuadTo(100,100,200,0); 是建立在它的前一个终点即 (300,300) 的基础上来计算相对坐标的，所以：<br>控制点X坐标 = 上一个终点X坐标+控制点X位移 = 300+100=200；<br>控制点Y坐标 = 上一个终点Y坐标+控制点Y位移 = 300+100=200；<br>终点X坐标 = 上一个终点X坐标+终点X位移 = 300+200=500；<br>终点Y坐标 = 上一个终点Y坐标+终点Y位移 = 300+0=300;<br>所以这句与 path.quadTo(400,400,500,300); 对等的。</p>
<p>最终效果也是一样的。</p>
<p>通过这个例子，只想让大家明白一点：rQuadTo(float dx1, float dy1, float dx2, float dy2) 中的位移坐标，都是以上一个终点位置为基准来做偏移的。</p>
<h4 id="7-1-4-示例：波浪效果"><a href="#7-1-4-示例：波浪效果" class="headerlink" title="7.1.4 示例：波浪效果"></a>7.1.4 示例：波浪效果</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-500be19b0bdb1bd8.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>我们将 mPath 的起始位置向左移一个波长，然后利用 for 循环画出当前屏幕中可能容得下的所有波。然后画一个波的左右两个半波：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 画的是一个波长中的前半个波</div><div class="line">mPath.rQuadTo(halfWaveLen/2, -100, halfWaveLen, 0); </div><div class="line">// 画的是一个波长中的后半个波</div><div class="line">mPath.rQuadTo(halfWaveLen/2, 100, halfWaveLen, 0);</div></pre></td></tr></table></figure></p>
<p>大家在这里可以看到，屏幕左右都多画了一个波长的图形。这是为了波形移动做准备的。</p>
<p>让波纹动起来其实挺简单，利用调用在 path.moveTo 的时候，将起始点向右移动即可实现移动，而且只要我们移动一个波长的长度，波纹就会重合，就可以实现无限循环了。</p>
<p>完整的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line">    private int mItemWaveLength = 1000;</div><div class="line">    private int dx;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPath = new Path();</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setStyle(Paint.Style.FILL_AND_STROKE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        mPath.reset();</div><div class="line">        int originY = 300;</div><div class="line">        int halfWaveLen = mItemWaveLength/2;</div><div class="line">        mPath.moveTo(-mItemWaveLength+dx,originY);</div><div class="line">        for (int i = -mItemWaveLength; i&lt;=getWidth()+mItemWaveLength; i+=mItemWaveLength)&#123;</div><div class="line">            mPath.rQuadTo(halfWaveLen/2f,-100,halfWaveLen,0);</div><div class="line">            mPath.rQuadTo(halfWaveLen/2f,100,halfWaveLen,0);</div><div class="line">        &#125;</div><div class="line">        mPath.lineTo(getWidth(),getHeight());</div><div class="line">        mPath.lineTo(0,getHeight());</div><div class="line">        mPath.close();</div><div class="line"></div><div class="line">        canvas.drawPath(mPath,mPaint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void startAnim()&#123;</div><div class="line">        ValueAnimator animator = ValueAnimator.ofInt(0,mItemWaveLength);</div><div class="line">        animator.setDuration(2000);</div><div class="line">        animator.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">        animator.setInterpolator(new LinearInterpolator());</div><div class="line">        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">                dx = (int)animation.getAnimatedValue();</div><div class="line">                postInvalidate();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        animator.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用 TestView<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        TestView view = findViewById(R.id.view);</div><div class="line">        view.startAnim();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</div><div class="tags"><a href="/tags/Custom-View/">Custom View</a></div><div class="post-nav"><a class="pre" href="/2019/07/07/Custom View/07.2 精通自定义 View 之 绘图进阶（二）/">07.2 精通自定义 View 之 绘图进阶（二）</a><a class="next" href="/2019/07/06/Custom View/06.3 精通自定义 View 之 Paint 基本使用（三）/">06.3 精通自定义 View 之 Paint 基本使用（三）</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ANDROID/">ANDROID</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Custom-View/">Custom View</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DESIGN-PATTERN/">DESIGN PATTERN</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">King.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>