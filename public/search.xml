<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ANDROID 博客总目录]]></title>
    <url>%2F9999%2F01%2F01%2F0%20ANDROID%20%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[ANDROID 博客总目录JAVA、DESIGN PATTERN、ANDROID、CUSTOM VIEW … 2 DESIGN PATTERN 1 JAVA01 Java File02 Java FileUtils03 Java IO Stream04 Java IOUtils05 Java Thread06 Java Generic07 Java Annotation08 Java Relfect09 Java RelfectUtils10 反射一：基本类周边信息获取11 反射二：泛型相关周边信息获取12 反射三：类内部信息获取13 Java Socket14 Java Socket 聊天室原理15 Java Socket 如何演化成 TomcatJAVA 8 InterfaceJAVA 8 LambdaJAVA 8 LocalDateJAVA | 使用克隆防止破坏封装性JAVA | equals 的正确姿势JAVA | 多线程断点下载]]></content>
      <categories>
        <category>CATALOG</category>
      </categories>
      <tags>
        <tag>CATALOG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[精通 Android 自定义 View 目录]]></title>
    <url>%2F2200%2F01%2F01%2FCustom%20View%2F00%20Android%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[本篇从自定义控件的动画、绘图、视图三方面入手，分别讲解与自定义控件相关的各种知识，给大家系统的梳理相关知识。不仅适合 Android 初、中级水平从业者，也适合高水平从业者查漏补缺使用。 内容摘自启舰所著的书籍《Android 自定义控件开发入门与实践》。 第1章 绘图基础1.1 基本图形绘制1.1.1 概述1.1.2 画笔的基本设置1.1.3 Canvas使用基础1.1.4 Rect与RectF1.1.5 Color 1.2 路径1.2.1 概述1.2.2 直线路径1.2.3 弧线路径1.2.4 addXXX系列函数1.2.5 填充模式1.2.6 重置路径1.2.7 示例:蜘蛛网状图 1.3 文字1.3.1 Paint设置1.3.2 Canvas绘制文本1.3.3 设置字体样式 1.4 Region1.4.1 构造Region1.4.2 枚举区域——RegionIterator类1.4.3 区域相交1.4.4 其他函数 1.5 Canvas(画布)1.5.1 Canvas变换1.5.2 画布的保存与恢复1.5.3 示例一:圆形头像1.5.4 示例二:裁剪动画 1.6 控件的使用方法1.6.1 控件概述1.6.2 通过XML引入控件1.6.3 动态添加控件 第2章 视图动画2.1 视图动画标签2.1.1 概述2.1.2 scale 标签2.1.3 Animation 继承属性2.1.4 alpha 标签2.1.5 rotate 标签2.1.6 translate 标签2.1.7 set 标签 2.2 视图动画的代码实现2.2.1 概述2.2.2 ScaleAnimation2.2.3 AlphaAnimation2.2.4 RotateAnimation2.2.5 TranslateAnimation2.2.6 AnimationSet2.2.7 Animation 2.3 插值器初探2.3.1 AccelerateDecelerateInterpolator2.3.2 AccelerateInterpolator2.3.3 DecelerateInterpolator2.3.4 LinearInterpolator2.3.5 BounceInterpolator2.3.6 AnticipateInterpolator2.3.7 OvershootInterpolator2.3.8 AnticipateOvershootInterpolator2.3.9 CycleInterpolator 2.4 动画示例2.4.1 镜头由远及近效果2.4.2 加载框效果2.4.3 扫描动画 2.5 逐帧动画2.5.1 XML 实现2.5.2 代码实现 第3章 属性动画3.1 ValueAnimator 的基本使用3.1.1 概述3.1.2 ValueAnimator 的简单使用3.1.3 常用函数3.1.4 示例：弹跳加载中效果 3.2 自定义插值器与 Evaluator3.2.1 自定义插值器3.2.2 Evaluator 3.3 ValueAnimator 进阶——ofObject3.3.1 概述3.3.2 示例：抛物动画 3.4 ObjectAnimator3.4.1 概述3.4.2 ObjectAnimator 动画原理3.4.3 自定义 ObjectAnimator 属性3.4.4 何时需要实现对应的 get 函数3.4.5 常用函数 3.5 组合动画——AnimatorSet3.5.1 playSequentially() 与 playTogether() 函数3.5.2 AnimatorSet.Builder3.5.3 AnimatorSet 监听器3.5.4 常用函数3.5.5 示例：路径动画 3.6 Animator 动画的 XML 实现3.6.1 animator 标签3.6.2 objectAnimator 标签3.6.3 set 标签 第4章 属性动画进阶4.1 PropertyValuesHolder 与 Keyframe4.1.1 PropertyValuesHolder4.1.2 Keyframe4.1.3 PropertyValuesHolder 其他函数4.1.4 示例：电话响铃效果 4.2 ViewPropertyAnimator4.2.1 概述4.2.2 常用函数 4.3 为 ViewGroup 内的组件添加动画4.3.1 animateLayoutChanges 属性4.3.2 LayoutTransition4.3.3 其他函数 4.4 开源动画库 NineOldAndroids4.4.1 NineOldAndroids 中的 ViewPropertyAnimator4.4.2 NineOldAndroids 中的 ViewHelper 第5章 动画进阶5.1 利用 PathMeasure 实现路径动画5.1.1 初始化5.1.2 简单函数使用5.1.3 getSegment() 函数5.1.4 getPosTan() 函数5.1.5 getMatrix() 函数5.1.6 示例：支付宝支付成功动画 5.2 SVG 动画5.2.1 概述5.2.2 vector 标签与图像显示5.2.3 动态 Vector5.2.4 示例：输入搜索动画 第6章 Paint 基本使用6.1 硬件加速6.1.1 概述6.1.2 软件绘制与硬件加速的区别6.1.3 禁用 GPU 硬件加速的方法 6.2 文字6.2.1 概述6.2.2 绘图四格线与 FontMetrics6.2.3 常用函数6.2.4 示例：定点写字 6.3 Paint 常用函数6.3.1 基本设置函数6.3.2 字体相关函数 第7章 绘图进阶7.1 贝济埃曲线7.1.1 概述7.1.2 贝济埃曲线之 quadTo7.1.3 贝济埃曲线之 rQuadTo7.1.4 示例：波浪效果 7.2 setShadowLayer 与阴影效果7.2.1 构造函数7.2.2 清除阴影7.2.3 示例：给文字添加阴影 7.3 BlurMaskFilter 发光效果和图片阴影7.3.1 概述7.3.2 给图片添加纯色阴影7.3.3 封装控件 7.4 Shader 与 BitmapShader7.4.1 Shader 概述7.4.2 BitmapShader 的基本用法7.4.3 示例一：望远镜效果7.4.4 示例二：生成不规则头像 7.5 Shader 之 LinearGradient7.5.1 概述7.5.2 示例：闪光文字效果 7.6 Shader 之 RadialGradient7.6.1 双色渐变7.6.2 多色渐变7.6.3 TileMode 填充模式 第8章 混合模式8.1 混合模式之 AvoidXfermode8.1.1 混合模式概述8.1.2 AvoidXfermode8.1.3 AvoidXfermode 绘制原理8.1.4 AvoidXfermode 之 Mode.AVOID 8.2 混合模式之 PorterDuffXfermode8.2.1 PorterDuffXfermode 概述8.2.2 颜色叠加相关模式 8.3 PorterDuffXfermode 之源图像模式8.3.1 Mode.SRC8.3.2 Mode.SRC_IN8.3.3 Mode.SRC_OUT8.3.4 Mode.SRC_OVER8.3.5 Mode.SRC_ATOP 8.4 目标图像模式与其他模式8.4.1 目标图像模式8.4.2 其他模式——Mode.CLEAR8.4.3 模式总结 第9章 Canvas 与图层9.1 获取 Canvas 对象的方法9.1.1 方法一：重写 onDraw()、dispatchDraw() 函数9.1.2 方法二：使用 Bitmap 创建9.1.3 方法三：调用 SurfaceHolder.lockCanvas() 函数 9.2 图层与画布9.2.1 saveLayer() 函数9.2.2 画布与图层9.2.3 saveLayer() &amp; saveLayerAlpha() 9.3 Flag 的具体含义 已过时9.4 恢复画布9.4.1 restoreToCount(int count)9.4.2 restore() &amp; restoreToCount(int count) 的关系 第10章 Android 画布10.1 ShapeDrawable10.1.1 shape 标签与 GradientDrawable10.1.2 ShapDrawable 的构造函数10.1.3 常用函数10.1.4 自定义 Drawable10.1.5 Drawable 与 Bitmap 对比 10.2 Bitmap10.2.1 概述10.2.2 创建 Bitmap 方法一：BitmapFactory10.2.3 BitmapFactory.Options10.2.4 创建 Bitmap 方法二：Bitmap 静态方法10.2.5 常用函数10.2.6 常见问题 10.3 SurfaceView10.3.1 概述10.3.2 基本用法10.3.3 双缓冲技术 第11章 Matrix 与坐标变换11.1 矩阵运算11.1.1 矩阵的加法与减法11.1.2 矩阵与数的乘法11.1.3 矩阵与矩阵的乘法 11.2 ColorMatrix 色彩变换11.2.1 色彩变换矩阵11.2.2 色彩的几种运算方式11.2.3 ColorMatrix 函数11.2.4 ColorMatrix 相乘 第12章 封装控件12.1 自定义属性与自定义 Style12.1.1 示例12.1.2 在 XML 中使用自定义的属性12.1.3 在代码中获取自定义属性的值12.1.4 declare-styleable 标签其他属性的用法 12.2 测量与布局12.2.1 ViewGroup 绘制流程12.2.2 onMeasure() 函数与 MeasureSpec12.2.3 onLayout() 函数12.2.4 获取子控件 margin 值的方法 12.3 实现 FlowLayout 容器12.3.1 XML 布局12.3.2 提取 margin 值与重写 onMeasure() 函数12.3.3 完整代码 第13章 控件高级属性13.1 GestureDetector 手势检测13.1.1 概述13.1.2 GestureDetector.OnGestureListener13.1.3 GestureDetector.OnDoubleTapListener13.1.4 GestureDetector.SimpleOnGestureListener13.1.5 onFling() 函数的应用 13.2 Window 与 WindowManager13.2.1 Window 与 WindowManager 的关系13.2.2 示例：腾讯手机管家悬浮窗的小火箭效果]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[X001 圆角圆形 ImageView]]></title>
    <url>%2F2019%2F09%2F01%2FCustom%20View%2FX001%20%E5%9C%86%E8%A7%92%E5%9C%86%E5%BD%A2%20ImageView%2F</url>
    <content type="text"><![CDATA[鉴于 Android 提供的 ImageView 控件已经非常完善，不仅处理好了各种缩放问题，而且有着很好的兼容性，还实现了显示图片等一系列的任务，我们只要在它的基础上添加一个显示圆角圆形的功能即可。 一、属性配置首先创建一个 res/values/attrs.xml 文件：12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;RoundImageView&quot;&gt; &lt;attr name=&quot;type&quot; format=&quot;enum&quot;&gt; &lt;enum name=&quot;circle&quot; value=&quot;1&quot;/&gt; &lt;enum name=&quot;round&quot; value=&quot;2&quot;/&gt; &lt;/attr&gt; &lt;attr name=&quot;radius&quot; format=&quot;dimension&quot;/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 二、代码实现1. 思路 定义一个 Java 类 RoundImageView，继承自 ImageView，重写其构造方法，获取配置属性进行初始化。 重写 onMeasure 方法，当模式为圆形的时候使其控件的宽高一致。 重写 onDraw 方法，增加两种模式处理逻辑。 2. 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148package com.xxt.xtest;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Bitmap;import android.graphics.BitmapShader;import android.graphics.Canvas;import android.graphics.Matrix;import android.graphics.Paint;import android.graphics.RectF;import android.graphics.Shader;import android.graphics.drawable.Drawable;import android.os.Build;import android.util.AttributeSet;import android.util.TypedValue;import androidx.appcompat.widget.AppCompatImageView;public class RoundImageView extends AppCompatImageView &#123; private static final int MODE_NONE = 0; // 普通模式，默认 private static final int MODE_CIRCLE = 1; // 圆形模式 private static final int MODE_ROUND = 2; // 圆角矩形模式 private int currMode = MODE_NONE; private int currRound = dp2px(10); // 圆角半径 private Paint mPaint; private RectF mRectF = null; private Drawable mPreDrawable = null; public RoundImageView(Context context) &#123; super(context); initViews(); &#125; public RoundImageView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public RoundImageView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); obtainStyledAttrs(context, attrs, defStyleAttr); initViews(); &#125; private void obtainStyledAttrs(Context context, AttributeSet attrs, int defStyleAttr) &#123; TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.RoundImageView, defStyleAttr, 0); currMode = a.getInt(R.styleable.RoundImageView_type, MODE_NONE); currRound = a.getDimensionPixelSize(R.styleable.RoundImageView_radius, currRound); a.recycle(); &#125; private void initViews() &#123; mPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG); mRectF = new RectF(); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); if (currMode == MODE_CIRCLE) &#123; int result = Math.min(getMeasuredWidth(), getMeasuredHeight()); setMeasuredDimension(result, result); &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; Drawable drawable = getDrawable(); Matrix drawMatrix = getImageMatrix(); if (drawable == null) &#123; return; // couldn&apos;t resolve the URI &#125; if (drawable.getIntrinsicWidth() == 0 || drawable.getIntrinsicHeight() == 0) &#123; return; // nothing to draw (empty bounds) &#125; if (drawMatrix == null &amp;&amp; getPaddingTop() == 0 &amp;&amp; getPaddingLeft() == 0) &#123; drawable.draw(canvas); &#125; else &#123; final int saveCount = canvas.getSaveCount(); canvas.save(); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123; if (getCropToPadding()) &#123; final int scrollX = getScrollX(); final int scrollY = getScrollY(); canvas.clipRect(scrollX + getPaddingLeft(), scrollY + getPaddingTop(), scrollX + getRight() - getLeft() - getPaddingRight(), scrollY + getBottom() - getTop() - getPaddingBottom()); &#125; &#125; canvas.translate(getPaddingLeft(), getPaddingTop()); // 当为圆形模式的时候 if (currMode == MODE_CIRCLE) &#123; setBitmapShader(drawable); canvas.drawCircle(getWidth() / 2f, getHeight() / 2f, getWidth() / 2f, mPaint); &#125; // 当为圆角模式的时候 else if (currMode == MODE_ROUND) &#123; setBitmapShader(drawable); mRectF.set(getPaddingLeft(), getPaddingTop(), getWidth() - getPaddingRight(), getHeight() - getPaddingBottom()); canvas.drawRoundRect(mRectF, currRound, currRound, mPaint); &#125; else &#123; if (drawMatrix != null) &#123; canvas.concat(drawMatrix); &#125; drawable.draw(canvas); &#125; canvas.restoreToCount(saveCount); &#125; &#125; private void setBitmapShader(Drawable drawable) &#123; // 防止多次重 new 对象 if (drawable != null &amp;&amp; drawable != mPreDrawable) &#123; Bitmap bitmap = drawable2Bitmap(drawable); mPaint.setShader(new BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)); mPreDrawable = drawable; &#125; &#125; /** * drawable 转换成 bitmap */ private Bitmap drawable2Bitmap(Drawable drawable) &#123; if (drawable == null) &#123; return null; &#125; Bitmap bitmap = Bitmap.createBitmap(getWidth(), getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); // 根据传递的 scaleType 获取 matrix 对象，设置给 bitmap Matrix matrix = getImageMatrix(); if (matrix != null) &#123; canvas.concat(matrix); &#125; drawable.draw(canvas); return bitmap; &#125; private int dp2px(float value) &#123; return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, value, getResources().getDisplayMetrics()); &#125;&#125; 在 onDraw 方法中，以下代码是我们添加的逻辑，其余代码为 ImageView 源代码。12345678910111213141516Drawable drawable = getDrawable();Matrix drawMatrix = getImageMatrix();...// 当为圆形模式的时候if (currMode == MODE_CIRCLE) &#123; setBitmapShader(drawable); canvas.drawCircle(getWidth() / 2f, getHeight() / 2f, getWidth() / 2f, mPaint);&#125;// 当为圆角模式的时候else if (currMode == MODE_ROUND) &#123; setBitmapShader(drawable); mRectF.set(getPaddingLeft(), getPaddingTop(), getWidth() - getPaddingRight(), getHeight() - getPaddingBottom()); canvas.drawRoundRect(mRectF, currRound, currRound, mPaint);&#125; 3. 在布局文件中使用效果如首图所示。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;com.xxt.xtest.RoundImageView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:layout_margin=&quot;20dp&quot; android:src=&quot;@drawable/meinv&quot;/&gt; &lt;com.xxt.xtest.RoundImageView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:layout_margin=&quot;20dp&quot; android:src=&quot;@drawable/meinv&quot; android:scaleType=&quot;fitXY&quot; /&gt; &lt;com.xxt.xtest.RoundImageView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:layout_margin=&quot;20dp&quot; android:src=&quot;@drawable/meinv&quot; android:scaleType=&quot;centerCrop&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;com.xxt.xtest.RoundImageView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:layout_margin=&quot;20dp&quot; android:src=&quot;@drawable/meinv&quot; app:type=&quot;round&quot;/&gt; &lt;com.xxt.xtest.RoundImageView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:layout_margin=&quot;20dp&quot; android:src=&quot;@drawable/meinv&quot; android:scaleType=&quot;fitXY&quot; app:type=&quot;round&quot;/&gt; &lt;com.xxt.xtest.RoundImageView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:layout_margin=&quot;20dp&quot; android:src=&quot;@drawable/meinv&quot; android:scaleType=&quot;centerCrop&quot; app:type=&quot;round&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;com.xxt.xtest.RoundImageView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:layout_margin=&quot;20dp&quot; android:src=&quot;@drawable/meinv&quot; app:type=&quot;circle&quot;/&gt; &lt;com.xxt.xtest.RoundImageView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:layout_margin=&quot;20dp&quot; android:src=&quot;@drawable/meinv&quot; android:scaleType=&quot;fitXY&quot; app:type=&quot;circle&quot;/&gt; &lt;com.xxt.xtest.RoundImageView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:layout_margin=&quot;20dp&quot; android:src=&quot;@drawable/meinv&quot; android:scaleType=&quot;centerCrop&quot; app:type=&quot;circle&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; android:layout_marginTop=&quot;10dp&quot;&gt; &lt;com.xxt.xtest.RoundImageView android:layout_margin=&quot;10dp&quot; android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; android:src=&quot;@color/colorAccent&quot; /&gt; &lt;com.xxt.xtest.RoundImageView android:layout_margin=&quot;10dp&quot; android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; android:src=&quot;@color/colorAccent&quot; app:type=&quot;round&quot; /&gt; &lt;com.xxt.xtest.RoundImageView android:layout_margin=&quot;10dp&quot; android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; android:src=&quot;@color/colorAccent&quot; app:type=&quot;circle&quot; /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23 设计模式——桥接模式]]></title>
    <url>%2F2019%2F08%2F29%2FPATTERN%2F23%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 桥接（Bridge）模式：将抽象部分与实现部分分离，使它们都可以独立的变化。 在现实生活中，某些类具有两个或多个维度的变化，如图形既可按形状分，又可按颜色分。如何设计类似于 Photoshop 这样的软件，能画不同形状和不同颜色的图形呢？如果用继承方式，m 种形状和 n 种颜色的图形就有 m×n 种，不但对应的子类很多，而且扩展困难。 当然，这样的例子还有很多，如不同颜色和字体的文字、不同品牌和功率的汽车、不同性别和职业的男女、支持不同平台和不同文件格式的媒体播放器等。如果用桥接模式就能很好地解决这些问题。 当一个类存在两个独立变化的纬度，且这两个纬度都需要进行扩展，我们可以使用桥接模式。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 优点 由于抽象与实现分离，所以扩展能力强； 其实现细节对客户透明。 缺点由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。 使用场景 一个类存在两个或以上的独立维度的变化，且这些维度都需要进行拓展。 不希望使用继承或因为多层次继承导致类的个数急剧增加时。 如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，可以通过桥接模式使他们在抽象层建立一个关联关系。 结构与实现 可以将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。 模式包含以下主要角色。 Abstraction（抽象部分）：定义抽象类，并包含一个对实现化对象的引用。 RefinedAbstraction（扩展抽象部分）：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。 Implementor（实现部分）：定义实现化角色的接口，供扩展抽象化角色调用。 ConcreteImplementor（实现部分的具体实现）：给出实现化角色接口的具体实现。 其结构图如下图所示。 Abstraction 和 Implementor 就是两个独立纬度变化的类，Implementor 相对于 Abstraction 是一个聚合的关系，也就是 Abstraction 可能拥有多个 Implementor，模板代码如下：1234567891011121314151617181920212223242526272829303132333435public class BridgeTest &#123; public static void main(String[] args) &#123; Implementor implementor = new ConcreteImplementor(); Abstraction abs = new RefinedAbstraction(implementor); abs.operation(); &#125;&#125;// 实现化角色interface Implementor &#123; void operationImpl();&#125;// 具体实现化角色class ConcreteImplementor implements Implementor &#123; public void operationImpl() &#123; System.out.println(&quot;具体实现化(Concrete Implementor)角色被访问&quot; ); &#125;&#125;// 抽象化角色abstract class Abstraction &#123; protected Implementor implementor; protected Abstraction(Implementor implementor) &#123; this.implementor = implementor; &#125; public abstract void operation();&#125;// 扩展抽象化角色class RefinedAbstraction extends Abstraction &#123; protected RefinedAbstraction(Implementor implementor) &#123; super(implementor); &#125; public void operation() &#123; System.out.println(&quot;扩展抽象化(Refined Abstraction)角色被访问&quot; ); implementor.operationImpl(); &#125;&#125; 示例 去咖啡馆喝咖啡一般分为 4 种，大杯加糖，大杯不加糖，小杯加糖和小杯不加糖。对于大杯和小杯，加糖和不加糖其实是两个相对独立纬度的变化。面先定一个咖啡类：123456789101112public abstract class Coffee &#123; protected CoffeeAdditives impl; public Coffee(CoffeeAdditives impl) &#123; this.impl = impl; &#125; /** * 咖啡具体是什么样的由子类决定 */ public abstract void makeCoffee();&#125; CoffeeAdditives 是一种桥接的方式，咖啡分为大杯和小杯，下面继续看看大杯咖啡和小杯咖啡的定义：1234567891011121314151617181920212223public class LargeCoffee extends Coffee&#123; public LargeCoffee(CoffeeAdditives impl) &#123; super(impl); &#125; @Override public void makeCoffee() &#123; System.out.println(&quot;大杯的&quot;+impl.addSomething()+&quot;咖啡&quot;); &#125;&#125;public class SmallCoffee extends Coffee &#123; public SmallCoffee(CoffeeAdditives impl) &#123; super(impl); &#125; @Override public void makeCoffee() &#123; System.out.println(&quot;小杯的&quot;+impl.addSomething()+&quot;咖啡&quot;); &#125;&#125; 至于加糖不加糖我们通过 CoffeeAdditives 这种桥接方式定义：12345678910111213141516171819public abstract class CoffeeAdditives &#123; public abstract String addSomething();&#125;public class Ordinary extends CoffeeAdditives &#123; @Override public String addSomething() &#123; return &quot;原味&quot;; &#125;&#125;public class Sugar extends CoffeeAdditives &#123; @Override public String addSomething() &#123; return &quot;加糖&quot;; &#125;&#125; 最终调用：123456789101112131415161718192021public class Test &#123; public static void main(String[] args)&#123; // 原汁原味 Ordinary ordinary = new Ordinary(); // 准备糖类 Sugar sugar = new Sugar(); // 大杯咖啡 原味 LargeCoffee largeCoffeeOrdinary = new LargeCoffee(ordinary); largeCoffeeOrdinary.makeCoffee(); // 小杯咖啡 原味 SmallCoffee smallCoffeeOrdinary = new SmallCoffee(ordinary); smallCoffeeOrdinary.makeCoffee(); // 大杯咖啡 加糖 LargeCoffee largeCoffeeSugar = new LargeCoffee(sugar); largeCoffeeSugar.makeCoffee(); // 小杯咖啡 加糖 SmallCoffee smallCoffeeSugar = new SmallCoffee(sugar); smallCoffeeSugar.makeCoffee(); &#125;&#125; 如果此时咖啡馆为了满足更多人的习惯，推出中杯的咖啡怎么办呢？对于本例来说，这种需求的变化其实就是 Coffee 类的变化，定义中杯扩展类 MiddleCoffee 类即可。12345678910public class MiddleCoffee extends Coffee &#123; public MiddleCoffee(CoffeeAdditives impl) &#123; super(impl); &#125; @Override public void makeCoffee() &#123; System.out.println(&quot;中杯的&quot;+impl.addSomething()+&quot;咖啡&quot;); &#125;&#125; 同样地，为了增加咖啡类口味的种类，我们也可以让 CoffeeAdditives 类变化起来，增加更多的子类表示，诸如加奶、加蜂蜜等。 ANDROID 源码中的实现 比较典型的是 Window 与 WindowManager 之间的关系，它们就用到了桥接这种模式。它们的关系如下图所示： 在 framework 中 Window 和 PhoneWindow 构成窗口的抽象部分，其中 Window 类为该抽象部分的抽象接口，PhoneWindow 为抽象部分具体的实现及扩展。而 WindowManager 则为实现部分的基类，WindowManagerImpl 为实现部分具体的逻辑实现，其使用 WindowManagerGlobal 通过 IWindowManager 接口与 WindowManagerService 进行交互（简称 WMS），并由 WMS 完成具体的窗口管理工作. 如下是 Window 与 WindowManager 桥梁搭建的主要代码：12345678910111213141516171819public abstract class Window &#123; // 代码省略... public void setWindowManager(WindowManager wm, IBinder appToken, String appName) &#123; setWindowManager(wm, appToken, appName, false); &#125; public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) &#123; mAppToken = appToken; mAppName = appName; mHardwareAccelerated = hardwareAccelerated || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false); if (wm == null) &#123; wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); &#125; mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); &#125; // 代码省略...&#125;]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[22 设计模式——外观模式]]></title>
    <url>%2F2019%2F08%2F28%2FPATTERN%2F22%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 外观（Facade）模式：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。外观模式提供一个高层次的接口，使得子系统更易于使用。 在开发过程中的运用频率非常高，尤其是在现阶段各种第三方 SDK 充斥在我们的周边，而这些 SDK 很大概率会使用外观模式。通过一个外观类使得整个系统的接口只有一个统一的高层接口，这样能够降低用户的使用成本，也对用户屏蔽了很多实现细节。当然，在我们的开发过程中，外观模式也是我们封装 API 的常用手段，例如网络模块、ImageLoader模块等。 优点外观模式是“迪米特法则”的典型应用，主要优点如下： 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。 缺点 不能很好地限制客户使用子系统类。 增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。 使用场景 为一个复杂的子系统提供一个简单接口，对外隐藏子系统的具体实现、隔离变化。 使用外观模式可以将一个子系统和使用它的客户端以及其它的子系统分离开来，这就提高了子系统的独立性和可移植性。 在构建一个层次化结构的时候，可以使用外观模式定义每一个层次对外交互的接口。这样，层与层之间只需要通过外观进行通信，从而简化层与层之间的依赖关系。 结构与实现 模式包含以下主要角色。 Facade（外观角色）：对外的统一入口。 Sub System（子系统）：一般由多个子系统构成，负责具体功能的实现。 其结构图如下图所示。 代码如下：1234567891011121314151617181920212223242526272829303132333435public class FacadePattern &#123; public static void main(String[] args) &#123; Facade f = new Facade(); f.method(); &#125;&#125;// 外观角色class Facade &#123; private SubSystem01 obj1 = new SubSystem01(); private SubSystem02 obj2 = new SubSystem02(); private SubSystem03 obj3 = new SubSystem03(); public void method() &#123; obj1.method1(); obj2.method2(); obj3.method3(); &#125;&#125;// 子系统角色class SubSystem01 &#123; public void method1() &#123; System.out.println(&quot;子系统01的method1()被调用！&quot;); &#125;&#125;// 子系统角色class SubSystem02 &#123; public void method2() &#123; System.out.println(&quot;子系统02的method2()被调用！&quot;); &#125;&#125;// 子系统角色class SubSystem03 &#123; public void method3() &#123; System.out.println(&quot;子系统03的method3()被调用！&quot;); &#125;&#125; 示例 手机就是一个外观模式的例子，它集合了电话功能、短信功能、GPS、拍照等于一身，通过手机你就可以完成各种功能。如下图所示： 下面模拟手机的外观模式实现。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public interface Camera &#123; void open(); void takePic(); void close();&#125;public class SamsungCamera implements Camera &#123; @Override public void open() &#123; System.out.println(&quot;打开相机&quot;); &#125; @Override public void takePic() &#123; System.out.println(&quot;拍照&quot;); &#125; @Override public void close() &#123; System.out.println(&quot;关闭相机&quot;); &#125;&#125;public interface Phone &#123; // 打电话 void dail(); // 挂断 void hangup();&#125;public class PhoneImpl implements Phone&#123; @Override public void dail() &#123; System.out.println(&quot;打电话&quot;); &#125; @Override public void hangup() &#123; System.out.println(&quot;挂断&quot;); &#125;&#125;// 外观类public class MobilePhone &#123; private Phone mPhone = new PhoneImpl(); private Camera mCamera = new SamsungCamera(); public void dail()&#123; mPhone.dail(); &#125; public void videoChat()&#123; System.out.println(&quot;--&gt;视频聊天接通中&quot;); mCamera.open(); mPhone.dail(); &#125; public void hangup()&#123; mPhone.hangup(); &#125; public void takePic()&#123; mCamera.open(); mCamera.takePic(); &#125; public void closeCamera()&#123; mCamera.close(); &#125;&#125; 测试代码：123456789public class Test &#123; public static void main(String[] args)&#123; MobilePhone nexus6 = new MobilePhone(); // 拍照 nexus6.videoChat(); // 拍照 nexus6.takePic(); &#125;&#125; ANDROID 源码中的实现 在用 Android 开发过程中，Context 是最重要的一个类型。Context 只是一个抽象类，它的真正实现在 ContextImpl 类中，ContextImpl 就是今天我们要分析的外观类。 在应用启动时，首先会 fork 一个子进程，并且调用 ActivityThread 的 main 方法启动该进程。ActivityThread 又会构建 Application 对象，然后和 Activity、ContextImpl 关联起来，最后会调用 Activity 的 onCreate、onStart、onResume 函数使 Activity 运行起来，此时应用的用户界面就呈现在我们面前。 main 函数会间接地调用 ActivityThread 中的 handleLaunchActivity 函数启动默认的 Activity。handleLaunchActivity 方法如下：123456789101112131415161718192021222324252627282930@Overridepublic Activity handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent) &#123; ... // 创建并且加载 Activity，调用它的 onCreate final Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); reportSizeConfigurations(r); if (!r.activity.mFinished &amp;&amp; pendingActions != null) &#123; pendingActions.setOldState(r.state); pendingActions.setRestoreInstanceState(true); pendingActions.setCallOnPostCreate(true); &#125; &#125; else &#123; // If there was an error, for any reason, tell the activity manager to stop us. try &#123; ActivityManager.getService() .finishActivity(r.token, Activity.RESULT_CANCELED, null, Activity.DONT_FINISH_TASK_WITH_ACTIVITY); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; return a;&#125; performLaunchActivity 方法如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ... // 构建 ContextImpl ContextImpl appContext = createBaseContextForActivity(r); Activity activity = null; try &#123; java.lang.ClassLoader cl = appContext.getClassLoader(); // 创建 Activity activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( &quot;Unable to instantiate activity &quot; + component + &quot;: &quot; + e.toString(), e); &#125; &#125; try &#123; // 创建 Application Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r); if (localLOGV) Slog.v( TAG, r + &quot;: app=&quot; + app + &quot;, appName=&quot; + app.getPackageName() + &quot;, pkg=&quot; + r.packageInfo.getPackageName() + &quot;, comp=&quot; + r.intent.getComponent().toShortString() + &quot;, dir=&quot; + r.packageInfo.getAppDir()); if (activity != null) &#123; // 获取 Activity 的 title CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (r.overrideConfig != null) &#123; config.updateFrom(r.overrideConfig); &#125; if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot; + r.activityInfo.name + &quot; with config &quot; + config); Window window = null; if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) &#123; window = r.mPendingRemoveWindow; r.mPendingRemoveWindow = null; r.mPendingRemoveWindowManager = null; &#125; appContext.setOuterContext(activity); // Activity 与 Context、Application 关联起来 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; checkAndBlockForNetworkAccess(); activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; // 回调 Activity 的 onCreate 方法 mInstrumentation.callActivityOnCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onCreate()&quot;); &#125; r.activity = activity; &#125; r.setState(ON_CREATE); mActivities.put(r.token, r); &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( &quot;Unable to start activity &quot; + component + &quot;: &quot; + e.toString(), e); &#125; &#125; return activity;&#125; 在 handleLaunchActivity 中会调用 perfromLaunchActivity 执行 Applicaton、ContextImpl、Activity 的创建工作，并且通过 Activity 的 attach 将这 3 者关联起来。 Activity 是 Context 的子类，因此，Activity 就具有了 Context 定义的所有方法。但 Activity 并不实现具体的功能，它只是继承了 Context 的接口，并且将相关的操作交给 ContextImpl。ContextImpl 存储在 Activity 的上两层父类 ContextWrapper 中，变量名为 mBase，具体代码如下：12345678910111213141516171819202122232425262728293031323334public class ContextThemeWrapper extends ContextWrapper &#123; ... @Override protected void attachBaseContext(Context newBase) &#123; super.attachBaseContext(newBase); &#125; ...&#125;public class ContextWrapper extends Context &#123; Context mBase; public ContextWrapper(Context base) &#123; mBase = base; &#125; /** * Set the base context for this ContextWrapper. All calls will then be * delegated to the base context. Throws * IllegalStateException if a base context has already been set. * * @param base The new base context for this wrapper. */ protected void attachBaseContext(Context base) &#123; if (mBase != null) &#123; throw new IllegalStateException(&quot;Base context already set&quot;); &#125; mBase = base; &#125; ...&#125; 在 ActivityThread 类的 perfromLaunchActivity 函数中会调用 Activity 的 attach 方法将 ContextImpl 等对象关联到 Activity 中，这个 ContextImpl 最终会被 ContentWrapper 类的 mBase 字段引用。Activity 的 attach 如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback) &#123; // 调用自身的 attachBaseContext attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this, window, activityConfigCallback); mWindow.setWindowControllerCallback(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123; mWindow.setSoftInputMode(info.softInputMode); &#125; if (info.uiOptions != 0) &#123; mWindow.setUiOptions(info.uiOptions); &#125; mUiThread = Thread.currentThread(); mMainThread = aThread; mInstrumentation = instr; mToken = token; mIdent = ident; mApplication = application; mIntent = intent; mReferrer = referrer; mComponent = intent.getComponent(); mActivityInfo = info; mTitle = title; mParent = parent; mEmbeddedID = id; mLastNonConfigurationInstances = lastNonConfigurationInstances; if (voiceInteractor != null) &#123; if (lastNonConfigurationInstances != null) &#123; mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor; &#125; else &#123; mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this, Looper.myLooper()); &#125; &#125; mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) &#123; mWindow.setContainer(mParent.getWindow()); &#125; mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config; mWindow.setColorMode(info.colorMode); setAutofillCompatibilityEnabled(application.isAutofillCompatibilityEnabled()); enableAutofillCompatibilityIfNeeded();&#125; attach 主要就是一些赋值操作。在 attach 中，调用了 attachBaseContext 函数。attachBaseContext 调用了父类 ContextWrapper 类，它就是简单地将 Context 参数传递给 mBase 字段。此时，我们的 Activity 内部就持有了 ContextImpl 的引用。 Activity 的 attachBaseContext：12345678@Overrideprotected void attachBaseContext(Context newBase) &#123; // 调用了 ContextThemeWrapper 的 attachBaseContext super.attachBaseContext(newBase); if (newBase != null) &#123; newBase.setAutofillClient(this); &#125;&#125; Activity 在开发过程中部分充当了代理的角色，例如，当我们通过 Activity 对象调用 sendBroadcast、getResource 等函数时，实际上 Activity 只是代理了 ContextImpl 的操作，也就是内部都调用了 mBase 对象的相应方法来处理，这些方法被封装在 Activity 的父类 ContextWrapper 中。12345678910111213141516171819public class ContextWrapper extends Context &#123; Context mBase; ... @Override public void sendBroadcast(Intent intent) &#123; mBase.sendBroadcast(intent); &#125; ... @Override public Resources getResources() &#123; return mBase.getResources(); &#125; @Override public PackageManager getPackageManager() &#123; return mBase.getPackageManager(); &#125; ...&#125; ContextImpl 的实现如下：1234567891011121314151617181920212223242526272829303132333435363738class ContextImpl extends Context &#123; ... @Override public void sendBroadcast(Intent intent) &#123; warnIfCallingFromSystemProcess(); String resolvedType = intent.resolveTypeIfNeeded(getContentResolver()); try &#123; intent.prepareToLeaveProcess(this); ActivityManager.getService().broadcastIntent( mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; ... @Override public Resources getResources() &#123; return mResources; &#125; @Override public PackageManager getPackageManager() &#123; if (mPackageManager != null) &#123; return mPackageManager; &#125; IPackageManager pm = ActivityThread.getPackageManager(); if (pm != null) &#123; // Doesn&apos;t matter if we make more than one instance. return (mPackageManager = new ApplicationPackageManager(this, pm)); &#125; return null; &#125; ...&#125; ContextImpl 内部封装了很多不同子系统的操作，例如，Activity 的跳转、发送广播、启动服务、设置壁纸等，这些工作并不是在 ContextImpl 中实现，而是转交给了具体的子系统进行处理。通过 Context 这个抽象类定义了一组接口，ContextImpl 实现 Context 定义的接口，使得用户可以通过 Context 这个接口统一与 Android 系统进行交互，这样用户通常情况下就不需要对每个子系统进行了解，例如启动 Activity 时用户不需要手动调用 mMainThread.getInstrumentation().execStartActivity 启动 Activity。用户与系统服务的交互都通过 Context 的高层接口。这样对用户屏蔽了具体实现的细节，降低了使用成本。]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[21 设计模式——享元模式]]></title>
    <url>%2F2019%2F08%2F27%2FPATTERN%2F21%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 享元（Flyweight）模式：使用共享对象可有效地支持大量的细粒度的对象。 享元模式是对象池的一种实现，代表轻量级的意思。用来尽可能减少内存使用量，它适合用于大量重复对象的场景，来缓存可共享的对象，达到对象共享，避免创建过多对象的效果，这样一来就可以提升性能，避免内存移除等。 享元模式中存在以下两种状态： 内部状态，即不会随着环境的改变而改变的可共享部分； 外部状态，指随环境改变而改变的不可以共享的部分。 享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。 优点相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。 缺点 为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。 读取享元模式的外部状态会使得运行时间稍微变长。 使用场景 系统存在大量相似或相同的对象。 需要缓冲池时。 细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。 结构与实现 模式包含以下主要角色。 Flyweight（抽象享元角色）：接口或抽象类，可以同时定义出对象的外部状态和内部状态的接口或实现。 ConcreteFlyweight（具体享元角色）：实现抽象享元角色中定义的业务。 UnsharedConcreteFlyweight（不可共享的享元角色）：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。该对象一般不会出现在享元工厂中。 FlyweightFactory（享元工厂）：管理对象池和创建享元对象。 其结构图如下图所示。 享元模式的实现代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243// 非享元角色class UnsharedConcreteFlyweight &#123; private String info; UnsharedConcreteFlyweight(String info) &#123; this.info = info; &#125; public String getInfo() &#123; return info; &#125; public void setInfo(String info) &#123; this.info = info; &#125;&#125;// 抽象享元角色interface Flyweight &#123; void operation(UnsharedConcreteFlyweight state);&#125;// 具体享元角色class ConcreteFlyweight implements Flyweight &#123; private String key; ConcreteFlyweight(String key) &#123; this.key = key; System.out.println(&quot;具体享元&quot;+key+&quot;被创建！&quot;); &#125; public void operation(UnsharedConcreteFlyweight outState) &#123; System.out.print(&quot;具体享元&quot;+key+&quot;被调用，&quot;); System.out.println(&quot;非享元信息是:&quot;+outState.getInfo()); &#125;&#125;// 享元工厂角色class FlyweightFactory &#123; private HashMap&lt;String, Flyweight&gt; flyweights = new HashMap&lt;&gt;(); public Flyweight getFlyweight(String key) &#123; Flyweight flyweight = (Flyweight)flyweights.get(key); if(flyweight != null) &#123; System.out.println(&quot;具体享元&quot;+key+&quot;已经存在，被成功获取！&quot;); &#125; else &#123; flyweight = new ConcreteFlyweight(key); flyweights.put(key, flyweight); &#125; return flyweight; &#125;&#125; 测试代码：1234567891011FlyweightFactory factory = new FlyweightFactory();Flyweight f01 = factory.getFlyweight(&quot;a&quot;);Flyweight f02 = factory.getFlyweight(&quot;a&quot;);Flyweight f03 = factory.getFlyweight(&quot;a&quot;);Flyweight f11 = factory.getFlyweight(&quot;b&quot;);Flyweight f12 = factory.getFlyweight(&quot;b&quot;); f01.operation(new UnsharedConcreteFlyweight(&quot;第1次调用a。&quot;));f02.operation(new UnsharedConcreteFlyweight(&quot;第2次调用a。&quot;));f03.operation(new UnsharedConcreteFlyweight(&quot;第3次调用a。&quot;));f11.operation(new UnsharedConcreteFlyweight(&quot;第1次调用b。&quot;));f12.operation(new UnsharedConcreteFlyweight(&quot;第2次调用b。&quot;)); 程序运行结果如下：12345678910具体享元a被创建！具体享元a已经存在，被成功获取！具体享元a已经存在，被成功获取！具体享元b被创建！具体享元b已经存在，被成功获取！具体享元a被调用，非享元信息是:第1次调用a。具体享元a被调用，非享元信息是:第2次调用a。具体享元a被调用，非享元信息是:第3次调用a。具体享元b被调用，非享元信息是:第1次调用b。具体享元b被调用，非享元信息是:第2次调用b。 示例 这个是一个买车票的例子，客户端通过输入起始地和目的地到服务器，服务器返回车票价格信息，一次请求总会产生一个车票价格信息对象，如果是成千上万的用户不停的请求势必会使得服务器产生大量的重复对象，为了避免不必要的内存开销，可以使用享元模式来优化这种情况。123456789101112131415161718192021222324252627282930313233343536373839// 定义车票接口和展示车票信息的函数public interface Ticket &#123; void showTicketInfo(String bunk);&#125;// 火车票实现类public class TrainTicket implements Ticket &#123; public String from; // 始发地：内部状态 public String to; // 目的地：内部状态 public String bunk; // 铺位：外部状态 public int price; // 价格：外部状态 public TrainTicket(String from, String to) &#123; this.from = from; this.to = to; &#125; @Override public void showTicketInfo(String bunk) &#123; price = new Random().nextInt(300); System.out.println(&quot;购买 从 &quot;+from+&quot; 到 &quot;+to+&quot; 的 &quot;+bunk+&quot; 火车票&quot;+&quot;,价格 : &quot;+price); &#125;&#125;// public class TicketFactory &#123; static Map&lt;String,Ticket&gt; sTicketMap = new ConcurrentHashMap&lt;&gt;(); public static Ticket getTicket(String from, String to)&#123; String key = from + &quot;-&quot; + to; if (sTicketMap.containsKey(key))&#123; System.out.println(&quot;使用缓存 ==&gt; &quot;+key); return sTicketMap.get(key); &#125; else &#123; System.out.println(&quot;创建对象 ==&gt; &quot;+key); Ticket ticket = new TrainTicket(from,to); sTicketMap.put(key,ticket); return ticket; &#125; &#125;&#125; 这种方式把对象缓存到了sTicketMap， key为 “from + “-“ + to”，这样避免了重复的起始地和目的地产生重复对象的情况。 ANDROID 源码中的实现 Handler 消息机制中的 Message 消息池就是使用享元模式复用了 Message 对象。 使用 Message 时一般会用到 Message.obtain 来获取消息。如果使用 new Message() 会构造大量的 Message 对象。obtain 方法如下：1234567891011121314public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; // 清空 in-use 标记 m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message();&#125; sPoolSync 和 sPool 定义如下：1234567891011121314151617181920212223/** * * Defines a message containing a description and arbitrary data object that can be * sent to a &#123;@link Handler&#125;. This object contains two extra int fields and an * extra object field that allow you to not do allocations in many cases. * * &lt;p class=&quot;note&quot;&gt;While the constructor of Message is public, the best way to get * one of these is to call &#123;@link #obtain Message.obtain()&#125; or one of the * &#123;@link Handler#obtainMessage Handler.obtainMessage()&#125; methods, which will pull * them from a pool of recycled objects.&lt;/p&gt; */public final class Message implements Parcelable &#123; ... // sometimes we store linked lists of these things /*package*/ Message next; public static final Object sPoolSync = new Object(); private static Message sPool; private static int sPoolSize = 0; ...&#125; sPoolSync 是一个对象锁，用于在获取 Message 对象时进行同步锁。sPool 是一个静态的 Message 对象。next 是一个 Message 对象，指向下一个 Message。 可以看出，Message 消息池没有使用 map 这样的容器，而是使用的链表。 那么这些 Message 是什么时候放入链表中的呢？我们在 obtain 函数中只看到了从链表中获取，并且看到存储。如果消息池链表中没有可用对象的时候，obtain 中则是直接返回一个通过 new 创建的 Message 对象，而且并没有存储到链表中。 Message 类有一个 recycle 方法，它用来回收消息，并且把回收掉的消息添加到对象池链表中。recycle 方法如下：123456789101112public void recycle() &#123; // 判断消息是否还在使用 if (isInUse()) &#123; if (gCheckRecycle) &#123; throw new IllegalStateException(&quot;This message cannot be recycled because it &quot; + &quot;is still in use.&quot;); &#125; return; &#125; // 清空状态，并且将消息添加到消息池中 recycleUnchecked();&#125; recycleUnchecked 方法如下：12345678910111213141516171819202122232425void recycleUnchecked() &#123; // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. // 清空消息状态，设置该消息 in-use flag flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; // 回收消息到消息池中 synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125;&#125; recycle 会将一个 Message 回收到一个全局的池。如果消息在使用就抛出异常，否则调用 recycleUnchecked。 recycleUnchecked 先清空字段，然后回收消息，将 sPool 指向当前消息，同时 size 加一。 Message 通过在内部构建一个链表来维护一个被回收的 Message 对象的对象池，当用户调用 obtain 时会优先从池中取，如果池中没有可以复用的对象则创建这个新的 Message 对象。这些新创建的 Message 对象在被使用完之后会被回收到这个对象池中，当下次再调用 obtain 时，它们就会被复用。 因为 Android 应用是事件驱动的，因此，如果通过 new 创建 Message 会产生大量的重复的 Message 对象，导致内存占用率高、频繁 GC 等问题，通过享元模式创建一个大小为 50 的消息池，避免了上述问题。]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20 设计模式——装饰模式]]></title>
    <url>%2F2019%2F08%2F26%2FPATTERN%2F20%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 装饰（Decorator）模式：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。。 装饰模式也称为包装模式，结构型设计模式之一，其使用一种对客户端透明的方式来动态地扩展对象地功能，同时它也是继承关系的一种替代方案之一。 优点 采用装饰模式扩展对象的功能比采用继承方式更加灵活。 可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。 缺点装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。 使用场景需要透明且动态地扩展类的功能。 结构与实现 通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。下面来分析其基本结构和实现方法。 模式包含以下主要角色。 Component（抽象组件）：接口或者抽象类，被装饰的最原始的对象。具体组件与抽象装饰角色的父类。 ConcreteComponent（具体组件）：实现抽象组件的接口。 Decorator（抽象装饰角色）：一般是抽象类，抽象组件的子类，同时持有一个被装饰者的引用，用来调用被装饰者的方法;同时可以给被装饰者增加新的职责。 ConcreteDecorator（具体装饰类）：抽象装饰角色的具体实现。 其结构图如下图所示。 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class DecoratorPattern &#123; public static void main(String[] args) &#123; Component p = new ConcreteComponent(); p.operation(); System.out.println(&quot;---------------------------------&quot;); Component d = new ConcreteDecorator(p); d.operation(); &#125;&#125;// 抽象构件角色interface Component &#123; void operation();&#125;// 具体构件角色class ConcreteComponent implements Component &#123; public ConcreteComponent() &#123; System.out.println(&quot;创建具体构件角色&quot;); &#125; public void operation() &#123; System.out.println(&quot;调用具体构件角色的方法 operation()&quot;); &#125;&#125;// 抽象装饰角色abstract class Decorator implements Component &#123; private Component component; public Decorator(Component component) &#123; this.component = component; &#125; public void operation() &#123; component.operation(); &#125;&#125;// 具体装饰角色class ConcreteDecorator extends Decorator &#123; public ConcreteDecorator(Component component) &#123; super(component); &#125; public void operation() &#123; super.operation(); addedFunction(); &#125; public void addedFunction() &#123; System.out.println(&quot;为具体构件角色增加额外的功能 addedFunction()&quot;); &#125;&#125; 程序运行结果如下：12345创建具体构件角色调用具体构件角色的方法 operation()---------------------------------调用具体构件角色的方法 operation()为具体构件角色增加额外的功能 addedFunction() 示例 人总是要穿衣服，我们将人定义为一个抽象类，将其穿衣服的行为定义为一个抽象方法，代码如下：1234567891011public abstract class Person &#123; // Person 下有一个穿着的抽象方法 public abstract void dressed();&#125;public class Boy extends Person &#123; @Override public void dressed() &#123; System.out.println(&quot;穿了内衣内裤&quot;); &#125;&#125; PersonCloth 用来装饰 Person：123456789101112public abstract class PersonCloth extends Person &#123; protected Person mPerson; // 保持一个 Person 类的引用 public PersonCloth(Person person) &#123; mPerson = person; &#125; @Override public void dressed() &#123; mPerson.dressed(); &#125;&#125; 下面两个是继承 PersonCloth 的实际装饰类：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class CheapCloth extends PersonCloth &#123; public CheapCloth(Person person) &#123; super(person); &#125; public void dressShorts() &#123; System.out.println(&quot;穿条短裤&quot;); &#125; @Override public void dressed() &#123; super.dressed(); dressShorts() &#125;&#125;public class ExpensiveCloth extends PersonCloth &#123; public ExpensiveCloth(Person person) &#123; super(person); &#125; /** * 穿短袖 */ private void dressShirt() &#123; System.out.println(&quot;穿件短袖&quot;); &#125; /** * 穿皮衣 */ private void dressLeather() &#123; System.out.println(&quot;穿件皮衣&quot;); &#125; /** * 穿牛仔裤 */ private void dressJean() &#123; System.out.println(&quot;穿条牛仔裤&quot;); &#125; @Override public void dressed() &#123; super.dressed(); dressShirt(); dressLeather(); dressJean(); &#125;&#125; 测试代码：12345678910// 首先我们要有一个BoyPerson person = new Boy();// 穿上便宜的衣服CheapCloth cheapCloth = new CheapCloth(person);cheapCloth.dressed();// 穿上昂贵的衣服ExpensiveCloth expensiveCloth = new ExpensiveCloth(person);expensiveCloth.dressed(); ANDROID 源码中的实现 Context 类在 Android 中被称为“上帝对象”，它本质是一个抽象类，其在我们装饰者模式里相当于抽象组件，而在其内部定义了大量的抽象方法，比如我们经常会用到的 startActivity 方法。12345678public abstract class Context &#123; ... public abstract void startActivity(@RequiresPermission Intent intent); ... public abstract void startActivity(@RequiresPermission Intent intent, @Nullable Bundle options); ...&#125; 真正的实现是在 ContextImpl 中完成的，ContextImpl 继承自 Context 抽象类，并实现了 Context 中的抽象方法。1234567891011121314151617181920212223242526272829303132333435363738394041class ContextImpl extends Context &#123; ... @Override public void startActivity(Intent intent) &#123; warnIfCallingFromSystemProcess(); startActivity(intent, null); &#125; /** @hide */ @Override public void startActivityAsUser(Intent intent, UserHandle user) &#123; startActivityAsUser(intent, null, user); &#125; @Override public void startActivity(Intent intent, Bundle options) &#123; warnIfCallingFromSystemProcess(); // Calling start activity from outside an activity without FLAG_ACTIVITY_NEW_TASK is // generally not allowed, except if the caller specifies the task id the activity should // be launched in. A bug was existed between N and O-MR1 which allowed this to work. We // maintain this for backwards compatibility. final int targetSdkVersion = getApplicationInfo().targetSdkVersion; if ((intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NEW_TASK) == 0 &amp;&amp; (targetSdkVersion &lt; Build.VERSION_CODES.N || targetSdkVersion &gt;= Build.VERSION_CODES.P) &amp;&amp; (options == null || ActivityOptions.fromBundle(options).getLaunchTaskId() == -1)) &#123; throw new AndroidRuntimeException( &quot;Calling startActivity() from outside of an Activity &quot; + &quot; context requires the FLAG_ACTIVITY_NEW_TASK flag.&quot; + &quot; Is this really what you want?&quot;); &#125; mMainThread.getInstrumentation().execStartActivity( getOuterContext(), mMainThread.getApplicationThread(), null, (Activity) null, intent, -1, options); &#125;&#125; 这里 ContextImpl 就相当于组件具体实现类，那么谁来承担装饰者的身份呢？ Activity 从类层次上来说本质是一个 Context。Activity 并非直接继承于 Context，而是继承于 ContextThemeWrapper。12345678public class Activity extends ContextThemeWrapper implements LayoutInflater.Factory2, Window.Callback, KeyEvent.Callback, OnCreateContextMenuListener, ComponentCallbacks2, Window.OnWindowDismissedCallback, WindowControllerCallback, AutofillManager.AutofillClient &#123; ...&#125; 而这个 ContextThemeWrapper 又是继承于 ContextWrapper。1public class ContextThemeWrapper extends ContextWrapper &#123;&#125; 最终这个 ContextWrapper 才继承于 Context。 为什么类层次会这么复杂呢？其实这里就是一个典型的装饰模式，ContextWrapper 就是我们要找的装饰者，在 ContextWrapper 中有一个 Context 的引用。12345678910111213141516171819202122public class ContextWrapper extends Context &#123; Context mBase; public ContextWrapper(Context base) &#123; mBase = base; &#125; /** * Set the base context for this ContextWrapper. All calls will then be * delegated to the base context. Throws * IllegalStateException if a base context has already been set. * * @param base The new base context for this wrapper. */ protected void attachBaseContext(Context base) &#123; if (mBase != null) &#123; throw new IllegalStateException(&quot;Base context already set&quot;); &#125; mBase = base; &#125; ...&#125; ContextWrapper 类的 startActivity 方法如下：1234@Overridepublic void startActivity(Intent intent) &#123; mBase.startActivity(intent);&#125; 可以看出它调用了 ContextImpl 中对应的方法。 装饰模式应用的套路都是很相似的，对于具体方法的包装扩展则由 ContextWrapper 的具体子类完成，比如我们的 Activity、Service 和 Application。]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19 设计模式——适配器模式]]></title>
    <url>%2F2019%2F08%2F25%2FPATTERN%2F19%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 适配器（Adapter）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。 适配器模式在我们开发中使用率极高，从代码中随处可见的 Adapter 可以判断出来。从最早的 ListView、GridView 到现在最新的 RecyclerView 都需要使用 Adapter。说到底，适配器是将两个不兼容的类融合在一起，它有点像粘合剂，将不同的东西通过一种转换使得它们能够协作起来。 优点 更好的复用性。系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。 更好的扩展性。在实现适配器功能的时候，可以调用自己开发的工功能，从而自然地扩展系统的功能。 缺点 过多地使用适配器，会让系统非常零乱，不易整体把握。 使用场景 当想使用一个已经存在的类，但它的接口不符合需求时。 当想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作。 需要一个统一的输出接口，而输入端的类型不可预知。 结构与实现 类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；Java 不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。 对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。现在来介绍它们的基本结构。 模式包含以下主要角色。 Target：目标接口，当前系统业务所期待的接口，它可以是抽象类或接口。 Adaptee：适配者类，它是被访问和适配的现存组件库中的组件接口。 Adapter：适配器类，它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。 其结构图如下图所示。 类适配器模式的代码如下：123456789101112131415161718192021222324// 目标接口interface Target &#123; void request();&#125;// 适配者接口class Adaptee &#123; public void specificRequest() &#123; System.out.println(&quot;适配者中的业务代码被调用！&quot;); &#125;&#125;// 类适配器类class ClassAdapter extends Adaptee implements Target &#123; public void request() &#123; specificRequest(); &#125;&#125;// 客户端代码public class ClassAdapterTest &#123; public static void main(String[] args) &#123; System.out.println(&quot;类适配器模式测试：&quot;); Target target = new ClassAdapter(); target.request(); &#125;&#125; 对象适配器模式的代码如下：12345678910111213141516171819// 对象适配器类class ObjectAdapter implements Target &#123; private Adaptee adaptee; public ObjectAdapter(Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; public void request() &#123; adaptee.specificRequest(); &#125;&#125;// 客户端代码public class ObjectAdapterTest &#123; public static void main(String[] args) &#123; System.out.println(&quot;对象适配器模式测试：&quot;); Adaptee adaptee = new Adaptee(); Target target = new ObjectAdapter(adaptee); target.request(); &#125;&#125; 说明：对象适配器模式中的“目标接口”和“适配者类”的代码同类适配器模式一样，只要修改适配器类和客户端的代码即可。与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到 Adaptee 类，而是使用代理关系。 示例 用电源接口做例子，笔记本电脑的电源一般在 5V 电压，但是在我们生活中的电线电压一般是 220V。这个时候出现了不匹配的状况，在软件开发中称为接口不兼容，此时就需要适配器来进行一个接口转换。此时需要用一个 Adapter 层来进行接口转换。即：5V 电压就是 Target 接口，220V 电压就是 Adaptee 类，而将电压从 220V 转换到 5V 就是 Adapter。 类适配器模式。 1234567891011121314151617181920212223242526// Targetpublic interface FiveVolt &#123; int getVolt5();&#125;// Adapteepublic class Volt220 &#123; public int getVolt220()&#123; return 220; &#125;&#125;// Adapterpublic class VoltAdapter extends Volt220 implements FiveVolt &#123; @Override public int getVolt5() &#123; return 5; &#125;&#125;public class Test &#123; public static void main(String[] args)&#123; VoltAdapter adapter = new VoltAdapter(); System.out.println(&quot;输出电压 : &quot; + adapter.getVolt5()); &#125;&#125; 对象适配器模式。Target 和 Adaptee 同上，但 Adapter 类不继承 Adaptee 类，而是代理，这比类适配器方式更为灵活。 1234567891011121314151617181920212223public class VoltAdapter implements FiveVolt &#123; private Volt220 mVolt220; public VoltAdapter(Volt220 mVolt220) &#123; this.mVolt220 = mVolt220; &#125; public int getVolt220()&#123; return mVolt220.getVolt220(); &#125; @Override public int getVolt5() &#123; return 5; &#125;&#125;public class Test &#123; public static void main(String[] args)&#123; VoltAdapter adapter = new VoltAdapter(new Volt220()); System.out.println(&quot;输出电压 : &quot;+adapter.getVolt5()); &#125;&#125; ANDROID 源码中的实现 在开发过程中，ListView 的 Adapter 是我们最常见的类型之一。ListView 中并没有 Adapter 相关的成员变量，其实 Adapter 在 ListView 的父类 AbsListView 中，AbsListView 是一个列表控件的抽象。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public abstract class AbsListView extends AdapterView&lt;ListAdapter&gt; implements TextWatcher, ViewTreeObserver.OnGlobalLayoutListener, Filter.FilterListener, ViewTreeObserver.OnTouchModeChangeListener, RemoteViewsAdapter.RemoteAdapterConnectionCallback &#123; ... ListAdapter mAdapter; ... // 关联到 Window 时调用，获取调用 Adapter 中的 getCount 方法等 @Override protected void onAttachedToWindow() &#123; super.onAttachedToWindow(); final ViewTreeObserver treeObserver = getViewTreeObserver(); treeObserver.addOnTouchModeChangeListener(this); if (mTextFilterEnabled &amp;&amp; mPopup != null &amp;&amp; !mGlobalLayoutListenerAddedFilter) &#123; treeObserver.addOnGlobalLayoutListener(this); &#125; // 给适配器注册一个观察者 if (mAdapter != null &amp;&amp; mDataSetObserver == null) &#123; mDataSetObserver = new AdapterDataSetObserver(); mAdapter.registerDataSetObserver(mDataSetObserver); // Data may have changed while we were detached. Refresh. mDataChanged = true; mOldItemCount = mItemCount; // 获取 Item 的数量，调用的是 mAdapter 的 getCount 方法 mItemCount = mAdapter.getCount(); &#125; &#125; ... // 子类需要覆写 layoutChildren 函数来布局 child view，也就是 item view @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; super.onLayout(changed, l, t, r, b); mInLayout = true; final int childCount = getChildCount(); if (changed) &#123; for (int i = 0; i &lt; childCount; i++) &#123; getChildAt(i).forceLayout(); &#125; mRecycler.markChildrenDirty(); &#125; // 布局 Child View layoutChildren(); mOverscrollMax = (b - t) / OVERSCROLL_LIMIT_DIVISOR; // TODO: Move somewhere sane. This doesn&apos;t belong in onLayout(). if (mFastScroll != null) &#123; mFastScroll.onItemCountChanged(getChildCount(), mItemCount); &#125; mInLayout = false; &#125; ...&#125; ListView 实现了 layoutChildren 方法，代码如下：12345678910111213141516171819202122232425@Overrideprotected void layoutChildren() &#123; ... try &#123; super.layoutChildren(); invalidate(); ... // 根据布局模式来布局 item view switch (mLayoutMode) &#123; ... case LAYOUT_FORCE_TOP: case LAYOUT_FORCE_BOTTOM: case LAYOUT_SPECIFIC: case LAYOUT_SYNC: break; case LAYOUT_MOVE_SELECTION: default: ... &#125; ... &#125;&#125; ListView 覆写了 AbsListView 中的 layoutChildren 函数，在该函数中根据布局模式来布局 item view，例如，默认情况是从上到下开始布局，但是，也有从下到上开始布局的，例如 QQ 聊天窗口的气泡布局，最新的消息就会布局到窗口的最底部。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 从上往下填充 item viewprivate View fillDown(int pos, int nextTop) &#123; View selectedView = null; int end = (mBottom - mTop); if ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123; end -= mListPadding.bottom; &#125; while (nextTop &lt; end &amp;&amp; pos &lt; mItemCount) &#123; // is this the selected item? boolean selected = pos == mSelectedPosition; // 通过 makeAndAddView 获取 item view View child = makeAndAddView(pos, nextTop, true, mListPadding.left, selected); nextTop = child.getBottom() + mDividerHeight; if (selected) &#123; selectedView = child; &#125; pos++; &#125; setVisibleRangeHint(mFirstPosition, mFirstPosition + getChildCount() - 1); return selectedView;&#125;// 从下往上填充布局private View fillUp(int pos, int nextBottom) &#123; View selectedView = null; int end = 0; if ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123; end = mListPadding.top; &#125; while (nextBottom &gt; end &amp;&amp; pos &gt;= 0) &#123; // is this the selected item? boolean selected = pos == mSelectedPosition; // 通过 makeAndAddView 获取 item view View child = makeAndAddView(pos, nextBottom, false, mListPadding.left, selected); nextBottom = child.getTop() - mDividerHeight; if (selected) &#123; selectedView = child; &#125; pos--; &#125; mFirstPosition = pos + 1; setVisibleRangeHint(mFirstPosition, mFirstPosition + getChildCount() - 1); return selectedView;&#125; makeAndAddView 方法如下：123456789101112131415161718192021222324private View makeAndAddView(int position, int y, boolean flow, int childrenLeft, boolean selected) &#123; if (!mDataChanged) &#123; // Try to use an existing view for this position. final View activeView = mRecycler.getActiveView(position); if (activeView != null) &#123; // Found it. We&apos;re reusing an existing child, so it just needs // to be positioned like a scrap view. setupChild(activeView, position, y, flow, childrenLeft, selected, true); return activeView; &#125; &#125; // 获取一个 item view // Make a new view for this position, or convert an unused view if // possible. final View child = obtainView(position, mIsScrap); // 将 item view 设置到对应的地方 // This needs to be positioned and measured. setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]); return child;&#125; makeAndAddView 分为两个步骤，第一个是根据 position 获取一个 item view，然后将这个 view 布局到特定的位置。获取一个 item view 调用的是 obtainView 方法。这个方法在 AbsListView 中。12345678910111213141516171819202122232425262728293031323334353637383940414243444546View obtainView(int position, boolean[] outMetadata) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;obtainView&quot;); outMetadata[0] = false; // Check whether we have a transient state view. Attempt to re-bind the // data and discard the view if we fail. final View transientView = mRecycler.getTransientStateView(position); if (transientView != null) &#123; final LayoutParams params = (LayoutParams) transientView.getLayoutParams(); // If the view type hasn&apos;t changed, attempt to re-bind the data. if (params.viewType == mAdapter.getItemViewType(position)) &#123; final View updatedView = mAdapter.getView(position, transientView, this); // If we failed to re-bind the data, scrap the obtained view. if (updatedView != transientView) &#123; setItemViewLayoutParams(updatedView, position); mRecycler.addScrapView(updatedView, position); &#125; &#125; outMetadata[0] = true; // Finish the temporary detach started in addScrapView(). transientView.dispatchFinishTemporaryDetach(); return transientView; &#125; // 1. 从缓存的 item view 中获取，ListView 的复用机制就在这里 final View scrapView = mRecycler.getScrapView(position); // 2. 注意，这里将 scrapView 设置给了 Adapter 的 getView 函数 final View child = mAdapter.getView(position, scrapView, this); if (scrapView != null) &#123; if (child != scrapView) &#123; // Failed to re-bind the data, return scrap to the heap. mRecycler.addScrapView(scrapView, position); &#125; else if (child.isTemporarilyDetached()) &#123; outMetadata[0] = true; // Finish the temporary detach started in addScrapView(). child.dispatchFinishTemporaryDetach(); &#125; &#125; ... return child;&#125; obtainView 方法定义了列表控件的 item view 的复用逻辑，首先会从 RecyclerBin 中获取一个缓存的 View。如果有缓存则将这个缓存的 View 传递到 Adapter 的 getView 的第二个参数中，这也就是我们对 Adapter 的最常见的优化方式，即判断 getView 的 convertView 是否为空。如果为空则从 xml 中创建视图，否则使用缓存的 View。这样避免了每次都从 xml 加载布局的消耗，能够显著提升 ListView 的效率。 在 ListView 的适配器模式中，target 角色就是 View，Adapter 就是将 item view 输出为 view 抽象的角色，adaptee 就是需要被处理的 item view。通过增加 adapter 一层来将 item view 的操作抽象起来，listView 等集合视图通过 adapter 对象获得 item 的个数、数据、item view 等，从而达到适配各种数据、各种 item 视图的效果。]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18 设计模式——组合模式]]></title>
    <url>%2F2019%2F08%2F24%2FPATTERN%2F18%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 组合（Composite）模式：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。 组合模式也是结构模式之一，组合模式比较简单，它将一组相似的对象看作一个对象处理，并根据一个树状结构来组合对象，然后提供一个统一的方法去访问相应的对象，以此忽略掉对象与对象之间的差别。 优点 组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码。 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”。 缺点 设计较复杂，客户端需要花更多时间理清类之间的层次关系。 不容易限制容器中的构件。 不容易用继承的方法来增加构件的新功能。 使用场景 表示对象的部分-整体层次结构时。 从一个整体中能独立出部分模块或功能的场景。 结构与实现 模式包含以下主要角色。 Component：抽象根节点，为组合中的对象声明接口。 Composite：定义有子节点的那些枝干节点的行为，存储子节点，在 Component 接口中实现与子节点有关的操作。 Leaf：在组合中表示叶子节点对象。 Client：通过 Component 接口操作组合节点的对象。 其结构图如下图所示。 下面是它的模版代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public abstract class Component &#123; protected String name; public Component(String name) &#123; this.name = name; &#125; // 具体逻辑的方法由子类实现 public abstract void doSomething();&#125;public class Composite extends Component&#123; /** * 存储节点的容器 * @param name */ private List&lt;Component&gt; components = new ArrayList&lt;&gt;(); public Composite(String name) &#123; super(name); &#125; @Override public void doSomething() &#123; System.out.println(name); if (null != components)&#123; for (Component c : components)&#123; c.doSomething(); &#125; &#125; &#125; /** * 添加子节点 * @param child */ public void addChild(Component child)&#123; components.add(child); &#125; /** * 移除子节点 * @param child */ public void removeChild(Component child)&#123; components.remove(child); &#125; /** * 获取子节点 * @param index * @return */ public Component getChildren(int index)&#123; return components.get(index); &#125;&#125;public class Leaf extends Component&#123; public Leaf(String name) &#123; super(name); &#125; @Override public void doSomething() &#123; System.out.print(name); &#125;&#125; 客户端测试代码：12345678910111213141516171819202122232425public class Client &#123; public static void main(String[] args)&#123; // 构造一个根节点 Composite root = new Composite(&quot;Root&quot;); // 构造两个枝干节点 Composite branch1 = new Composite(&quot;Branch1&quot;); Composite branch2 = new Composite(&quot;Branch2&quot;); // 构造两个叶子节点 Leaf leaf1 = new Leaf(&quot;Leaf1&quot;); Leaf leaf2 = new Leaf(&quot;Leaf2&quot;); // 将叶子节点添加至枝干节点中 branch1.addChild(leaf1); branch2.addChild(leaf2); // 将枝干节点添加至根节点中 root.addChild(branch1); root.addChild(branch2); // 执行方法 root.doSomething(); &#125;&#125; 示例 下面我们以文件夹系统为例讲解一下组合模式的简单实现，整个文件夹系统如下所示： 首先声明一个抽象类，表示文件或文件夹：1234567891011121314151617181920212223242526272829303132333435363738394041424344public abstract class Dir &#123; /** * 声明一个List成员变量存储文件夹下的所有元素 */ protected List&lt;Dir&gt; dirs = new ArrayList&lt;&gt;(); private String name; //当前文件夹名 public Dir(String name) &#123; this.name = name; &#125; /** * 添加一个文件或文件夹 */ public abstract void addDir(Dir dir); /** * 移除一个文件或文件夹 */ public abstract void rmDir(Dir dir); /** * 清除文件夹下面的所有元素 */ public abstract void clear(); /** * 清空文件夹下的所有元素 */ public abstract void print(); /** * 获取文件夹下所有的文件或子文件夹 */ public abstract List&lt;Dir&gt; getFiles(); /** * 获取文件或文件夹名 */ public String getName() &#123; return name; &#125;&#125; 然后定义文件夹类和文件类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Folder extends Dir&#123; public Folder(String name) &#123; super(name); &#125; @Override public void addDir(Dir dir) &#123; dirs.add(dir); &#125; @Override public void rmDir(Dir dir) &#123; dirs.remove(dir); &#125; @Override public void clear() &#123; dirs.clear(); &#125; @Override public void print() &#123; System.out.print(getName()+&quot;(&quot;); Iterator&lt;Dir&gt; iter = dirs.iterator(); while (iter.hasNext())&#123; Dir dir = iter.next(); dir.print(); if (iter.hasNext())&#123; System.out.print(&quot;,&quot;); &#125; &#125; System.out.print(&quot;)&quot;); &#125; @Override public List&lt;Dir&gt; getFiles() &#123; return dirs; &#125;&#125;public class File extends Dir&#123; public File(String name) &#123; super(name); &#125; @Override public void addDir(Dir dir) &#123; throw new UnsupportedOperationException(&quot;文件对象不支持该操作&quot;); &#125; @Override public void rmDir(Dir dir) &#123; throw new UnsupportedOperationException(&quot;文件对象不支持该操作&quot;); &#125; @Override public void clear() &#123; throw new UnsupportedOperationException(&quot;文件对象不支持该操作&quot;); &#125; @Override public void print() &#123; System.out.print(getName()); &#125; @Override public List&lt;Dir&gt; getFiles() &#123; throw new UnsupportedOperationException(&quot;文件对象不支持该操作&quot;); &#125;&#125; 像这样将组合所使用的方法定义在抽象类的方式称为透明的组合模式，遵循了依赖倒置原则，但却违反了单一职责原则与接口隔离原则。 而前面模板代码中所描述的组合模式则称为安全地组合模式，这种模式客户端在使用的时候必须依赖具体的实现，这违反了依赖倒置原则，但遵循了单一职责原则与接口隔离原则。 测试代码：123456789101112131415161718192021222324252627282930313233public class Client &#123; public static void main(String[] args) &#123; // 构造一个目录对象表示 C 盘根目录 Dir diskC = new Folder(&quot;C&quot;); // C 盘根目录下有一个文件 ImbaMallLog.txt diskC.addDir(new File(&quot;ImbaMallLog.txt&quot;)); // C 盘目录下还有3个子目录 Windows,PrefLogs,Program File Dir dirWin = new Folder(&quot;Windows&quot;); // Windows 目录下有文件 explorer.exe dirWin.addDir(new File(&quot;explorer.exe&quot;)); diskC.addDir(dirWin); // PerfLogs 目录 Dir dirPer = new Folder(&quot;PerfLogs&quot;); // PerfLogs 目录下有文件 null.txt dirPer.addDir(new File(&quot;null.txt&quot;)); diskC.addDir(dirPer); // Program File 目录 Dir dirPro = new Folder(&quot;Program File&quot;); // Program File 目录下有文件 ftp.txt dirPro.addDir(new File(&quot;ftp.txt&quot;)); diskC.addDir(dirPro); // 打印出文件结构 diskC.print(); &#125;&#125; ANDROID 源码中的实现 Android 中的 View 和 ViewGroup 的嵌套组合是一个典型的组合模式实现，如下图所示。 在 Android 的这个视图层级中，容器一定是 ViewGroup，而且只有 ViewGroup 才能包含其他的 View，比如 LinearLayout 能包含 TextView、Button、CheckBox 等，但是反过来 TextView 是不能包含 LinearLayout 的，因为 TextView 直接继承于 View，其并非一个容器。12345678910111213141516171819202122public abstract class ViewGroup extends View implements ViewParent, ViewManager &#123; ... public void addView(View child) &#123; addView(child, -1); &#125; ... @Override public void removeView(View view) &#123; if (removeViewInternal(view)) &#123; requestLayout(); invalidate(true); &#125; &#125; ... public View getChildAt(int index) &#123; if (index &lt; 0 || index &gt;= mChildrenCount) &#123; return null; &#125; return mChildren[index]; &#125; ...&#125; ViewGroup 是继承于 View 类的，但为什么有容器的功能呢？123public abstract class ViewGroup extends View implements ViewParent, ViewManager &#123; ...&#125; 从继承的角度来说，ViewGroup 拥有 View 类所有的非私有方法。既然如此，两者的差别就在于 ViewGroup 所实现的 ViewParent 和 ViewManager 接口上，而事实也是如此。 ViewManager 定义了 addView、removeView 等对子视图操作的方法。12345public interface ViewManager &#123; public void addView(View view, ViewGroup.LayoutParams params); public void updateViewLayout(View view, ViewGroup.LayoutParams params); public void removeView(View view);&#125; 而 ViewParent 则定义了刷新容器的接口 requestLayout 和其他一些焦点事件的处理的接口。12345678910111213141516public interface ViewParent &#123; // 请求重新布局 public void requestLayout(); // 是否已经请求布局。这里需要注意，当我们调用 requestLayout 请求布局后， // 这一过程并非是立即执行的，Android 会将请求布局的操作以消息的形式发送 // 至主线程的 Handler 并由其分发处理。因此在调用 requestLayout 方法请 // 求布局到布局真正接收到重新布局的命令时需要一段时间间隔 public boolean isLayoutRequested(); ... // 获取当前 View 的 ViewParent public ViewParent getParent(); ...&#125; 其中有一些方法比较常见，比如 requestLayout 和 bringChildToFront 等。 ViewGroup 除了所实现的这两个接口与 View 不一样外，还有重要的一点就是 ViewGroup 是抽象类，将 View 的 onLayout 重置为抽象方法。容器子类必须实现 onLayout 来布局定位。 除此之外，在 View 中比较重要的两个测绘流程的方法 onMeasure 和 onDraw 在 ViewGroup 中都没有被重写，相对于 onMeasure 方法，在 ViewGroup 中增加了一些计算子 View 的方法，如 measureChildren、measureChildrenWithMargins 等；而对于 onDraw 方法，ViewGroup 定义了一个 dispatchDraw 方法来调用其每一个子 View 的 onDraw 方法，由此可见，ViewGroup 真的就象一个容器一样，其职责只是负责对子元素的操作而非具体的个体行为。]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[17 设计模式——代理模式]]></title>
    <url>%2F2019%2F08%2F23%2FPATTERN%2F17%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 代理（Proxy）模式：为其他对象提供一种代理以控制这个对象的访问。代理模式也叫委托模式，属于结构型模式。 在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。 在软件设计中，使用代理模式的例子也很多。例如，要访问的远程对象比较大（如视频或大图像等），其下载要花很多时间。还有因为安全原因需要屏蔽客户端直接访问真实对象，如某单位的内部数据库等。 优点 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用； 代理对象可以扩展目标对象的功能； 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度； 缺点 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢； 增加了系统的复杂度； 使用场景当无法或不想直接访问某个对象或访问某个对象存在困难时，可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口。 结构与实现 模式包含以下主要角色。 Subject（抽象主题类）：接口或者抽象类，声明真实主题与代理的共同接口方法。 RealSubject（真实主题类）：也叫做被代理类或被委托类，定义了代理所表示的真实对象，负责具体业务逻辑的执行，客户端可以通过代理类间接的调用真实主题类的方法。 Proxy（代理类）：也叫委托类，持有对真实主题类的引用，在其所实现的接口方法中调用真实主题类中相应的接口方法执行。 其结构图如下图所示。 代理模式的实现代码如下：12345678910111213141516171819202122232425262728293031323334353637public class ProxyTest &#123; public static void main(String[] args) &#123; Proxy proxy = new Proxy(); proxy.request(); &#125;&#125;// 抽象主题interface Subject &#123; void request();&#125;// 真实主题class RealSubject implements Subject &#123; public void request() &#123; System.out.println(&quot;访问真实主题方法...&quot;); &#125;&#125;// 代理class Proxy implements Subject &#123; private RealSubject realSubject; public void request() &#123; if (realSubject == null) &#123; realSubject = new RealSubject(); &#125; preRequest(); realSubject.request(); postRequest(); &#125; public void preRequest() &#123; System.out.println(&quot;访问真实主题之前的预处理。&quot;); &#125; public void postRequest() &#123; System.out.println(&quot;访问真实主题之后的后续处理。&quot;); &#125;&#125; 程序运行的结果如下：123访问真实主题之前的预处理。访问真实主题方法...访问真实主题之后的后续处理。 示例 小明被拖欠工资，想走法律程序，找律师去申述这一个过程，使用代理模式律师就是代理者，小明就是被代理者，下面看看这样一个过程，代码应该怎样去实现。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public interface ILawsuit &#123; // 提交申请 void submit(); // 进行举证 void burden(); // 开始维护 void defend(); // 诉讼完成 void finish();&#125;public class XiaoMin implements ILawsuit&#123; @Override public void submit() &#123; // 老板欠小民工资 小小民只好申请仲裁 System.out.println(&quot;老板拖欠工资，特此申请仲裁&quot;); &#125; @Override public void burden() &#123; // 小民证据充足，不怕告不赢 System.out.println(&quot;这是合同书和过去一年的银行工资流水&quot;); &#125; @Override public void defend() &#123; // 铁证如山，辩护也没什么好说的 System.out.println(&quot;证据确凿! 不需要再说什么了&quot;); &#125; @Override public void finish() &#123; // 结果也是肯定的,必赢 System.out.println(&quot;诉讼成功! 判决老板即日起七天内结算工资&quot;); &#125;&#125;public class Lawyer implements ILawsuit &#123; private ILawsuit mLawsuit; public Lawyer(ILawsuit lawsuit) &#123; this.mLawsuit = lawsuit; &#125; @Override public void submit() &#123; mLawsuit.submit(); &#125; @Override public void burden() &#123; mLawsuit.burden(); &#125; @Override public void defend() &#123; mLawsuit.defend(); &#125; @Override public void finish() &#123; mLawsuit.finish(); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; ILawsuit xiaomin = new XiaoMin(); // 构造代理律师 ILawsuit lawsuit = new Lawyer(xiaomin); // 律师提交诉讼申请 lawsuit.submit(); // 律师进行举证 lawsuit.burden(); // 律师代替小民进行辩护 lawsuit.defend(); // 完成诉讼 lawsuit.finish(); &#125;&#125; 从代码的角度来分，代理可以分为两种：一种是静态代理，另一种是动态代理。 静态代理就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。上面的例子实现就是静态代理。 动态代理类的源码是在程序运行期间根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。 下面我们实现动态代理，Java 提供了动态的代理接口 InvocationHandler，实现该接口需要重写 invoke() 方法：123456789101112131415public class DynamicProxy implements InvocationHandler &#123; private Object obj; // 被代理的类引用 public DynamicProxy(Object obj) &#123; this.obj = obj; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 调用被代理类对象的方法 Object result = method.invoke(obj,args); return result; &#125;&#125; 使用这个动态代理修改小明案例中的客户类：1234567891011121314151617181920public class Client &#123; public static void main(String[] args) &#123; // 构造一个小民 ILawsuit xiaomin = new XiaoMin(); // 构造一个动态代理 DynamicProxy proxy = new DynamicProxy(xiaomin); // 获取被代理类小民的 ClassLoader ClassLoader loader = xiaomin.getClass().getClassLoader(); // 动态构造一个代理者律师 ILawsuit lawyer = (ILawsuit) Proxy.newProxyInstance(loader, new Class[]&#123;ILawsuit.class&#125;, proxy); // 律师提交诉讼申请 lawyer.submit(); // 律师进行举证 lawyer.burden(); // 律师代替小民进行辩护 lawyer.defend(); // 完成诉讼 lawyer.finish(); &#125;&#125; 静态代理的缺点： 如果接口新增一个方法，除了所有实现类（真实主题类）需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。 代理对象只服务于一种类型的对象，如果要服务多类型的对象。必须要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。 动态代理的优点： 可以通过一个代理类完成全部的代理功能，接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。当接口方法数量较多时，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。 动态代理的应用使我们的类职责更加单一，复用性更强。 动态代理的缺点： 不能对类进行代理，只能对接口进行代理，如果我们的类没有实现任何接口，那么就不能使用这种方式进行动态代理。 根据适用范围，代理模式可以分为以下几种： 远程代理：为一个对象在不同的地址空间提供局部代表，这样系统可以将Server部分的事项隐藏。 虚拟代理：如果要创建一个资源消耗较大的对象，可以先用一个代理对象表示，在真正需要的时候才真正创建。 保护代理：用代理对象控制对一个对象的访问，给不同的用户提供不同的访问权限。 智能引用：在引用原始对象的时候附加额外操作，并对指向原始对象的引用增加引用计数。 ANDROID 源码中的实现 ANDROID 源码中多个地方都用到代理模式，比如 ActivityManagerProxy 这个代理类。其具体代理的是 ActivityManagerNative 的子类 ActivityManagerService。 ActivityManagerProxy 实现了 IActivityManager 接口，该接口定义了一些 Activity 相关的接口方法，其中有一些我们在应用开发中也时常接触到。IActivityManager 这个接口相当于代理模式中的抽象主题，那么真正的实现主题是 ActivityManagerNative 的子类 ActivityManagerService，这几个类大致的关系： ActivityManagerProxy 实际上代理的是 ActivityManagerService，但是 ActivityManagerProxy 和 ActivityManagerService 是分别运行在不同的进程里（ActivityManagerProxy 是运行在应用的进程，而 ActivityManagerService 是运行在系统进程），所以它们之间的这个代理过程是跨进程的，这里跨进程是用到 Android 的 Binder 机制完成。不过 ActivityManagerProxy 在实际逻辑处理中并未过多地被外部类使用，因为在 Android 中管理与维护 Activity 相关信息的类是另外一个叫做 ActivityManager 的类，ActivityManager 虽然说管理着 Activity 信息，但是实质上大多数逻辑由 ActivityManagerProxy 承担，这里以其中的 getAppTasks 方法为例，在 ActivityManager 中 getAppTasks 方法逻辑如下：1234567891011121314public List&lt;ActivityManager.AppTask&gt; getAppTasks() &#123; ArrayList&lt;AppTask&gt; tasks = new ArrayList&lt;AppTask&gt;(); List&lt;IBinder&gt; appTasks; try &#123; appTasks = getService().getAppTasks(mContext.getPackageName()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; int numAppTasks = appTasks.size(); for (int i = 0; i &lt; numAppTasks; i++) &#123; tasks.add(new AppTask(IAppTask.Stub.asInterface(appTasks.get(i)))); &#125; return tasks;&#125; getService() 其实返回的是一个 IActivityManager，那这个 IActivityManager 的实体类是什么呢？12345678910111213public static IActivityManager getService() &#123; return IActivityManagerSingleton.get();&#125;private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() &#123; @Override protected IActivityManager create() &#123; final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; &#125; &#125;; ServiceManager.getService() 返回的是一个系统级的 Service，这个 Service 实际上是 ActivityManagerService，这里也完成创建一个对 ActivityManagerService 的 Client 代理对象 ActivityManagerProxy 实例。ActivityManagerProxy 中的 getAppTasks 方法逻辑就很明确，将数据打包跨进程传递给 Server 端 ActivityManagerService 处理并返回结果。123456789101112131415161718192021public List&lt;IAppTask&gt; getAppTasks(String callingPackage) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeString(callingPackage); mRemote.transact(GET_APP_TASKS_TRANSACTION, data, reply, 0); reply.readException(); ArrayList&lt;IAppTask&gt; list = null; int N = reply.readInt(); if (N &gt;= 0) &#123; list = new ArrayList&lt;&gt;(); while (N &gt; 0) &#123; IAppTask task = IAppTask.Stub.asInterface(reply.readStrongBinder()); list.add(task); N--; &#125; &#125; data.recycle(); reply.recycle(); return list;&#125; 再来看看 ActivityManagerService 中的 getAppTasks：1234567891011121314151617181920212223242526272829303132333435@Overridepublic List&lt;IAppTask&gt; getAppTasks(String callingPackage) &#123; int callingUid = Binder.getCallingUid(); long ident = Binder.clearCallingIdentity(); synchronized(this) &#123; ArrayList&lt;IAppTask&gt; list = new ArrayList&lt;IAppTask&gt;(); try &#123; if (DEBUG_ALL) Slog.v(TAG, &quot;getAppTasks&quot;); final int N = mRecentTasks.size(); for (int i = 0; i &lt; N; i++) &#123; TaskRecord tr = mRecentTasks.get(i); // Skip tasks that do not match the caller. We don&apos;t need to verify // callingPackage, because we are also limiting to callingUid and know // that will limit to the correct security sandbox. if (tr.effectiveUid != callingUid) &#123; continue; &#125; Intent intent = tr.getBaseIntent(); if (intent == null || !callingPackage.equals(intent.getComponent().getPackageName())) &#123; continue; &#125; ActivityManager.RecentTaskInfo taskInfo = createRecentTaskInfoFromTaskRecord(tr); AppTaskImpl taskImpl = new AppTaskImpl(taskInfo.persistentId, callingUid); list.add(taskImpl); &#125; &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125; return list; &#125;&#125; Binder 跨进程通信机制 在 Android 中进程间通信我们通常使用到的是 binder 机制，binder 机制所使用到的四个基本模块是 Binder Client、Binder Server、ServerManager 和 Binder Driver。这四者之间的关系类似与网络访问，Binder Client 相当于我们的客户端 pc , Binder Server 相当于服务器，ServerManager 相当于 DNS 服务器，而 Binder Driver 则相当于一个路由器。其中 Binder Driver 实现在内核空间中，而其余的 3 者 Binder Client、Binder Server、ServerManager 实现在用户空间中。 Binder Client 与 Binder Server 之间的跨进程通信统一通过 Binder Driver 处理转发，对于 Binder Client 来说，其只需要知道自己要使用的 Binder 的名字以及该 Binder 实体在 ServerManager 中的 0 号引用即可，访问原理也比较简单，Binder Client 先是通过 0 号引用去访问 ServerManager 获取 Binder 的引用，得到引用后就可以像普通方法那样调用 Binder 实体方法。最后我们的 ServerManager 则用来管理 Binder Server，Binder Client 可以通过它来查询 Binder Server接口，刚才提到过 Binder Client 可以通过 ServerManager 来获取 Binder 的引用，这个 Binder 引用就是由 ServerManager 来转换的。 可以想象成 Binder Driver 就是一个管道，ServerManager 是一个注册表，所有的 Binder Client 和 Binder Server 都要在它那里注册，Binder Client 也通过 ServerManager 去查找对应的 Binder Server。最后，Binder Client 和 Binder Server 其实实现的接口是一样的，所以大家可以联想到 Binder 机制其实也是一种代理模式。 实战 Notification 适配。通过代理模式解决各个版本的 Notification 碎片化问题，为每种不同的 Notification 样式定义一个类，这里以正常的 64dp Height、256dp Height 和 headsUpContentView 为例，先定义一个抽象类表示通知。1234567891011121314151617181920public abstract class Notify &#123; protected Context context; protected NotificationManager nm; protected NotificationCompat.Builder builder; public Notify(Context context) &#123; this.context = context; nm = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE); builder = new NotificationCompat.Builder(context, &quot;default&quot;); PendingIntent intent = PendingIntent.getActivity(context, 0, new Intent(context, TestActivity.class), PendingIntent.FLAG_CANCEL_CURRENT); builder.setSmallIcon(R.drawable.taiji) .setContentIntent(intent); &#125; public abstract void send(); // 发送一条通知 public abstract void cancel(); // 取消一条通知&#125; Notify 声明两个成员变量处理与通知相关的逻辑，且让所有子类共有。两个抽象方法 send 和 cancel 均有具体的子类去实现。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class NotifyNormal extends Notify &#123; public NotifyNormal(Context context) &#123; super(context); &#125; @Override public void send() &#123; Notification n = builder.build(); n.contentView = new RemoteViews(context.getPackageName(), R.layout.notify_normal); nm.notify(0, n); &#125; @Override public void cancel() &#123; nm.cancel(0); &#125;&#125;public class NotifyBig extends Notify &#123; public NotifyBig(Context context) &#123; super(context); &#125; @Override public void send() &#123; Notification n = builder.build(); n.contentView = new RemoteViews(context.getPackageName(), R.layout.notify_normal); n.bigContentView = new RemoteViews(context.getPackageName(), R.layout.notify_big); nm.notify(0, n); &#125; @Override public void cancel() &#123; nm.cancel(0); &#125;&#125;public class NotifyHeadsUp extends Notify &#123; public NotifyHeadsUp(Context context) &#123; super(context); &#125; @Override public void send() &#123; Notification n = builder.build(); n.contentView = new RemoteViews(context.getPackageName(), R.layout.notify_normal); n.bigContentView = new RemoteViews(context.getPackageName(), R.layout.notify_big); n.headsUpContentView = new RemoteViews(context.getPackageName(), R.layout.notify_normal); nm.notify(0, n); &#125; @Override public void cancel() &#123; nm.cancel(0); &#125;&#125; 最后定义一个代理类来整合上面的几个类。12345678910111213141516171819202122232425public class NotifyProxy extends Notify &#123; private Notify notify; public NotifyProxy(Context context) &#123; super(context); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; notify = new NotifyHeadsUp(context); &#125; else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; notify = new NotifyBig(context); &#125; else &#123; notify = new NotifyNormal(context); &#125; &#125; @Override public void send() &#123; notify.send(); &#125; @Override public void cancel() &#123; notify.cancel(); &#125;&#125; 在 NotifyProxy 类中定义一个 Notify 类型的成员变量，在构造方法里根据 SDK 版本的不同去实例化不同的 Notify 子类，最终由该类的 send 和 cancel 方法去调用不同的逻辑实现，这样一来，我们的客户端也就是我们的 Activity 类中就很简单了，直接调用 NotifyProxy 中的方法即可。1new NotifyProxy(TestActivity.this).send();]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16 设计模式——中介者模式]]></title>
    <url>%2F2019%2F08%2F22%2FPATTERN%2F16%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 中介者（Mediator）模式：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。 在现实生活中，常常会出现好多对象之间存在复杂的交互关系，这种交互关系常常是“网状结构”，它要求每个对象都必须知道它需要交互的对象。例如，每个人必须记住他（她）所有朋友的电话；而且，朋友中如果有人的电话修改了，他（她）必须告诉其他所有的朋友修改，这叫作“牵一发而动全身”，非常复杂。 如果把这种“网状结构”改为“星形结构”的话，将大大降低它们之间的“耦合性”，这时只要找一个“中介者”就可以了。如前面所说的“每个人必须记住所有朋友电话”的问题，只要在网上建立一个每个朋友都可以访问的“通信录”就解决了。这样的例子还有很多，例如，你刚刚参力口工作想租房，可以找“房屋中介”；或者，自己刚刚到一个陌生城市找工作，可以找“人才交流中心”帮忙。 在软件的开发过程中，这样的例子也很多，例如，在 MVC 框架中，控制器（C）就是模型（M）和视图（V）的中介者；还有大家常用的 QQ 聊天程序的“中介者”是 QQ 服务器。所有这些，都可以采用“中介者模式”来实现，它将大大降低对象之间的耦合性，提高系统的灵活性。 优点 降低了对象之间的耦合性，使得对象易于独立地被复用。 将对象间的多对多关联转变为一对多的关联，提高系统的灵活性，使得系统易于维护和扩展。 缺点 当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。 使用场景当程序存在大量的类时，多个对象之间存在着依赖的关系，呈现出网状结构，那么程序的可读性和可维护性就变差了，并且修改一个类需要牵涉到其他类，不符合开闭原则。 因此我们可以引入中介者，将网状结构转化成星型结构，可以降低程序的复杂性，并且可以减少各个对象之间的耦合。 结构与实现 模式包含以下主要角色。 Mediator（抽象中介者角色）：抽象类或者接口，定义统一的接口，用于各同事角色之间的通信。 ConcreteMediator（具体中介者角色）：继承或者实现了抽象中介者，实现了父类定义的方法，协调各个具体同事进行通信。 Colleague（抽象同事角色）：抽象类或者接口，定义统一的接口，它只知道中介者而不知道其他同事对象。 ConcreteColleague（具体同事角色）：继承或者实现了抽象同事角色，每个具体同事类都知道自己本身的行为，其他的行为只能通过中介者去进行。 其结构图如下图所示。 中介者模式的实现代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class MediatorPattern &#123; public static void main(String[] args) &#123; Mediator md = new ConcreteMediator(); Colleague c1,c2; c1 = new ConcreteColleague1(); c2 = new ConcreteColleague2(); md.register(c1); md.register(c2); c1.send(); System.out.println(&quot;-------------&quot;); c2.send(); &#125;&#125;// 抽象中介者abstract class Mediator &#123; public abstract void register(Colleague colleague); public abstract void relay(Colleague cl); // 转发&#125;// 具体中介者class ConcreteMediator extends Mediator &#123; private List&lt;Colleague&gt; colleagues = new ArrayList&lt;&gt;(); public void register(Colleague colleague) &#123; if (!colleagues.contains(colleague)) &#123; colleagues.add(colleague); colleague.setMedium(this); &#125; &#125; public void relay(Colleague cl) &#123; for (Colleague ob : colleagues) &#123; if (!ob.equals(cl)) &#123; ob.receive(); &#125; &#125; &#125;&#125;// 抽象同事类abstract class Colleague &#123; protected Mediator mediator; public void setMedium(Mediator mediator) &#123; this.mediator = mediator; &#125; public abstract void receive(); public abstract void send();&#125;// 具体同事类class ConcreteColleague1 extends Colleague &#123; public void receive() &#123; System.out.println(&quot;具体同事类1收到请求。&quot;); &#125; public void send() &#123; System.out.println(&quot;具体同事类1发出请求。&quot;); mediator.relay(this); // 请中介者转发 &#125;&#125;// 具体同事类class ConcreteColleague2 extends Colleague &#123; public void receive() &#123; System.out.println(&quot;具体同事类2收到请求。&quot;); &#125; public void send() &#123; System.out.println(&quot;具体同事类2发出请求。&quot;); mediator.relay(this); //请中介者转发 &#125;&#125; 程序的运行结果如下：12345具体同事类1发出请求。具体同事类2收到请求。-------------具体同事类2发出请求。具体同事类1收到请求。 示例 我们的电脑组件异常之多，读取一个 CD 光盘需要使用 CPU 、光驱、声卡、显卡、内存等一系列组件。如果我们不使用设计模式，那我们每个组件都要保持其他组件的引用，这就会造成我们的类结构复杂难懂，变成一个网状结构。 解决方法：使用中介者模式可以使一系列组件只和我们的中介（主板）打交道，这就将网状结构变成星型结构。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127public abstract class Mediator &#123; /** * 同事对象改变时通知中介者的方法 * 同事对象改变时由中介者去通知其他同事。 * @param c Colleague */ public abstract void changed(Colleague c);&#125;//主板public class MainBoard extends Mediator &#123; private CDDevice cd; // 光驱设备 private CPU cpu; // CPU private SoundCard soundCard; // 声卡设备 private GraphicsCard graphicsCard; // 显卡设备 @Override public void changed(Colleague c) &#123; // 如果 CD 读取到数据 if (c == cd) &#123; handleCD((CDDevice) c); &#125; else if (c == cpu) &#123; handleCPU((CPU) c); &#125; &#125; private void handleCD(CDDevice c) &#123; cpu.setData(c.read()); &#125; private void handleCPU(CPU c) &#123; soundCard.videoPlay(c.getDataSound()); graphicsCard.videoPlay(c.getDataVideo()); &#125; public void setCpu(CPU cpu) &#123; this.cpu = cpu; &#125; public void setSoundCard(SoundCard soundCard) &#123; this.soundCard = soundCard; &#125; public void setgCard(GraphicsCard graphicsCard) &#123; this.graphicsCard = graphicsCard; &#125; public void setCd(CDDevice cd) &#123; this.cd = cd; &#125;&#125;public abstract class Colleague &#123; private Mediator mediator; public Colleague(Mediator mediator) &#123; this.mediator = mediator; &#125;&#125;public class CDDevice extends Colleague &#123; private String data; public CDDevice(Mediator mediator) &#123; super(mediator); &#125; public String read() &#123; return data; &#125; /** * 加载视频数据 * @return */ public void load() &#123; data = &quot;视频数据，音频数据&quot;; mediator.changed(this); &#125;&#125;public class CPU extends Colleague &#123; private String dataVideo, dataSound; // 视频和音频数据 public CPU(Mediator mediator) &#123; super(mediator); &#125; public String getDataVideo() &#123; return dataVideo; &#125; public String getDataSound() &#123; return dataSound; &#125; public void setData(String data) &#123; // 分割音、视频数据 String[] tmp = data.split(&quot;,&quot;); this.dataVideo = tmp[0]; this.dataSound = tmp[1]; // 告诉中介者自身状态改变 mediator.changed(this); &#125;&#125;public class GraphicsCard extends Colleague &#123; public GraphicsCard(Mediator mediator) &#123; super(mediator); &#125; public void videoPlay(String data)&#123; System.out.println(&quot;视频：&quot;+ data); &#125;&#125;public class SoundCard extends Colleague &#123; public SoundCard(Mediator mediator) &#123; super(mediator); &#125; public void videoPlay(String data)&#123; System.out.println(&quot;音频：&quot;+ data); &#125;&#125; 每个对象只需要关心自己的职责，自己事情处理完成后通知中介者，让中介者调节指导下一步操作。 客户端代码：1234567891011121314151617public class Client &#123; public static void main(String[] args) &#123; MainBoard mainBoard = new MainBoard(); CDDevice cd = new CDDevice(mainBoard); CPU cpu = new CPU(mainBoard); GCard gc = new GCard(mainBoard); SoundCard sc = new SoundCard(mainBoard); mainBoard.setCd(cd); mainBoard.setCpu(cpu); mainBoard.setgCard(gc); mainBoard.setSoundCard(sc); cd.load(); &#125;&#125; ANDROID 源码中的实现 ANDROID 中的锁屏功能就用到了中介者模式，KeyguardService（锁屏服务）通过 KeyguardViewMediator（锁屏中介者）来协调各种 Manager 的状态以达到锁屏的功能。这里各种 Manager 都充当了同事的角色。源码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 锁屏服务，同事角色public class KeyguardService extends Service &#123; // 锁屏中介者 private KeyguardViewMediator mKeyguardViewMediator; @Override public void onCreate() &#123; ((SystemUIApplication) getApplication()).startServicesIfNeeded(); // 初始化中介者 mKeyguardViewMediator = ((SystemUIApplication) getApplication()).getComponent(KeyguardViewMediator.class); &#125; private final IKeyguardService.Stub mBinder = new IKeyguardService.Stub() &#123; @Override // Binder interface public void addStateMonitorCallback(IKeyguardStateCallback callback) &#123; checkPermission(); // 调用中介者的接口 mKeyguardViewMediator.addStateMonitorCallback(callback); &#125; @Override // Binder interface public void verifyUnlock(IKeyguardExitCallback callback) &#123; checkPermission(); // 调用中介者的接口 mKeyguardViewMediator.verifyUnlock(callback); &#125; // 其他代码略 &#125;;&#125;// 锁屏中介者public class KeyguardViewMediator extends SystemUI &#123; // 各种 Manager，同事角色 private AlarmManager mAlarmManager; private AudioManager mAudioManager; private StatusBarManager mStatusBarManager; private PowerManager mPM; private IWindowManager mWM; private TrustManager mTrustManager; private SearchManager mSearchManager; private PowerManager.WakeLock mShowKeyguardWakeLock; private StatusBarKeyguardViewManager mStatusBarKeyguardViewManager; //其他代码略 // 通过 AudioManager 去播放声音 private void playSound(int soundId) &#123; if (soundId == 0) return; final ContentResolver cr = mContext.getContentResolver(); if (Settings.System.getInt(cr, Settings.System.LOCKSCREEN_SOUNDS_ENABLED, 1) == 1) &#123; mLockSounds.stop(mLockSoundStreamId); // Init mAudioManager if (mAudioManager == null) &#123; mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE); if (mAudioManager == null) return; mUiSoundsStreamType = mAudioManager.getUiSoundsStreamType(); &#125; // If the stream is muted, don&apos;t play the sound if (mAudioManager.isStreamMute(mUiSoundsStreamType)) return; mLockSoundStreamId = mLockSounds.play(soundId, mLockSoundVolume, mLockSoundVolume, 1/*priortiy*/, 0/*loop*/, 1.0f/*rate*/); &#125; &#125;&#125; KeyguardViewMediator 中通过 playSound 方法能够协调 AudioManager 去控制声音的播放等等，其他 Manager 同理。 实战 登录界面运用中介者模式，如下图所示。 一个简单的登录界面，包含两个文本框、两个复选框、两个按钮。只有 6 个元素，但要实现如下逻辑：1）当用户名没有输入时，除了账户文本输入框、取消按钮外均不可用；当有用户名输入时，记住账号也可用。2）当密码文本框有输入时，自动登录、确定按钮皆可用，否则皆不可用。3）勾选自动登录，那么记住账号会被同时勾选。4）清空密码，取消自动登录选中状态并且不可用；清空账号则取消两个复选框的状态并且都不可用。5）…… 这是一个多 UI 控件交互的情景，此时很适合让 Activity 来充当一个中介者并在其中处理相关逻辑。具体代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133public class LoginActivity extends BaseActivity &#123; private EditText etAccount, etPassword; private CheckBox cbRemember, cbAuto; private Button btnEnsure, btnCancel; private String strAccount, strPassword; // 账户、密码 private boolean isRemember, isAuto; // 是否记住账号、自动登录 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_test); initViews(); &#125; private void initViews() &#123; etAccount = findViewById(R.id.login_account_et); etPassword = findViewById(R.id.login_password_et); cbRemember = findViewById(R.id.login_remember_cb); cbAuto = findViewById(R.id.login_auto_cb); btnEnsure = findViewById(R.id.login_ensure_btn); btnCancel = findViewById(R.id.login_cancel_btn); // 账户 etAccount.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123;&#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; // 回传数据 strAccount = s.toString(); // 通知 Activity 状态改变 change(); &#125; @Override public void afterTextChanged(Editable s) &#123;&#125; &#125;); // 密码 etPassword.setEnabled(false); etPassword.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123;&#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; // 回传数据 strPassword = s.toString(); // 通知 Activity 状态改变 change(); &#125; @Override public void afterTextChanged(Editable s) &#123;&#125; &#125;); // 记住账户 cbRemember.setEnabled(false); cbRemember.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; // 回传数据 isRemember = isChecked; // 通知 Activity 状态改变 change(); &#125; &#125;); // 自动登录 cbAuto.setEnabled(false); cbAuto.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; // 回传数据 isAuto = isChecked; isRemember = isAuto || isRemember; // 通知 Activity 状态改变 change(); &#125; &#125;); // 确定按钮 btnEnsure.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(LoginActivity.this, &quot;登录成功&quot;, Toast.LENGTH_LONG).show(); &#125; &#125;); // 取消按钮 btnCancel.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(LoginActivity.this, &quot;取消登录&quot;, Toast.LENGTH_LONG).show(); &#125; &#125;); &#125; /** * 各控件状态改变后协调各控件状态显示 */ private void change() &#123; if (TextUtils.isEmpty(strAccount)) &#123; etPassword.setEnabled(false); cbRemember.setEnabled(false); cbAuto.setEnabled(false); btnEnsure.setEnabled(false); btnCancel.setEnabled(true); isRemember = false; isAuto = false; &#125; else if (!TextUtils.isEmpty(strAccount) &amp;&amp; TextUtils.isEmpty(strPassword)) &#123; etPassword.setEnabled(true); cbRemember.setEnabled(true); cbAuto.setEnabled(false); btnEnsure.setEnabled(false); btnCancel.setEnabled(true); isAuto = false; &#125; else if (!TextUtils.isEmpty(strAccount) &amp;&amp; !TextUtils.isEmpty(strPassword)) &#123; etPassword.setEnabled(true); cbRemember.setEnabled(true); cbAuto.setEnabled(true); btnEnsure.setEnabled(true); btnCancel.setEnabled(true); &#125; cbRemember.setChecked(isRemember); cbAuto.setChecked(isAuto); &#125;&#125;]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15 设计模式——访问者模式]]></title>
    <url>%2F2019%2F08%2F21%2FPATTERN%2F15%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 访问者（Visitor）模式：封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。 访问者模式是一种将数据操作与数据结构分离的设计模式，它是 23 种设计模式中最复杂的一个，但是它的使用频率并不高，正如《设计模式》的作者 GOF 对访问者模式的描述：大多数情况下，并不需要使用访问者模式，但是当你一旦需要使用它时，那你就是真的需要它了。 访问者模式的基本想法是，软件系统中拥有一个由许多对象构成的、比较稳定的对象结构，这些对象的类都拥有一个 accept 方法用来接受访问者对象的访问。访问者是一个接口，它拥有一个 visit 方法，这个方法对访问到的对象结构中不同类型的元素做出不同的处理。在对象结构的每一次访问过程中，我们遍历整个对象结构，对每一个元素都实施 accept 方法，在每一个元素的 accept 方法中会调用访问者的 visit 方法，从而使访问者得以处理对象结构的每一个元素，我们可以针对对象结构设计不同的访问者类来完成不同的操作，达到区别对待的效果。 优点 各角色职责分离，符合单一职责原则。 具有优秀的扩展性。 使得数据结构和作用于结构上的操作解耦，使得操作集合可以独立变化。 灵活性。 缺点 具体元素对访问者公布细节，违反了迪米特原则。 违反了依赖倒置原则，为了达到“区别对待”而依赖了具体类，没有依赖抽象。 使用场景 对象结构比较稳定，但经常需要在此对象结构上定义新的操作。 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。 结构与实现 模式包含以下主要角色。 Visitor（抽象访问者）：接口或者抽象类，为每一个元素（Element）声明一个访问的方法。 ConcreteVisitor（具体访问者）：实现抽象访问者中的方法，即对每一个元素都有其具体的访问行为。 Element（抽象元素）：接口或者抽象类，定义一个accept方法，能够接受访问者（Visitor）的访问。 ConcreteElementA、ConcreteElementB（具体元素）：实现抽象元素中的accept方法，通常是调用访问者提供的访问该元素的方法。 Object Structure（对象结构）：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。 Client（客户端类）：即要使用访问者模式的地方。 其结构图如下图所示。 访问者模式的实现代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class VisitorPattern &#123; public static void main(String[] args) &#123; ObjectStructure os = new ObjectStructure(); os.add(new ConcreteElementA()); os.add(new ConcreteElementB()); Visitor visitor = new ConcreteVisitorA(); os.accept(visitor); System.out.println(&quot;------------------------&quot;); visitor = new ConcreteVisitorB(); os.accept(visitor); &#125;&#125;// 抽象访问者interface Visitor &#123; void visit(ConcreteElementA element); void visit(ConcreteElementB element);&#125;// 具体访问者 A 类class ConcreteVisitorA implements Visitor &#123; public void visit(ConcreteElementA element) &#123; System.out.println(&quot;具体访问者A访问--&gt;&quot;+element.operationA()); &#125; public void visit(ConcreteElementB element) &#123; System.out.println(&quot;具体访问者A访问--&gt;&quot;+element.operationB()); &#125;&#125;// 具体访问者 B 类class ConcreteVisitorB implements Visitor &#123; public void visit(ConcreteElementA element) &#123; System.out.println(&quot;具体访问者B访问--&gt;&quot;+element.operationA()); &#125; public void visit(ConcreteElementB element) &#123; System.out.println(&quot;具体访问者B访问--&gt;&quot;+element.operationB()); &#125;&#125;// 抽象元素类interface Element &#123; void accept(Visitor visitor);&#125;// 具体元素 A 类class ConcreteElementA implements Element &#123; public void accept(Visitor visitor) &#123; visitor.visit(this); &#125; public String operationA() &#123; return &quot;具体元素A的操作。&quot;; &#125;&#125;// 具体元素 B 类class ConcreteElementB implements Element &#123; public void accept(Visitor visitor) &#123; visitor.visit(this); &#125; public String operationB() &#123; return &quot;具体元素B的操作。&quot;; &#125;&#125;// 对象结构角色class ObjectStructure &#123; private List&lt;Element&gt; list = new ArrayList&lt;Element&gt;(); public void accept(Visitor visitor) &#123; Iterator&lt;Element&gt; i= list.iterator(); while (i.hasNext()) &#123; ((Element) i.next()).accept(visitor); &#125; &#125; public void add(Element element) &#123; list.add(element); &#125; public void remove(Element element) &#123; list.remove(element); &#125;&#125; 程序的运行结果如下：12345具体访问者A访问--&gt;具体元素A的操作。具体访问者A访问--&gt;具体元素B的操作。------------------------具体访问者B访问--&gt;具体元素A的操作。具体访问者B访问--&gt;具体元素B的操作。 示例 利用“访问者（Visitor）模式”模拟艺术公司与造币公司的功能。 分析：艺术公司利用“铜”可以设计出铜像，利用“纸”可以画出图画；造币公司利用“铜”可以印出铜币，利用“纸”可以印出纸币。对“铜”和“纸”这两种元素，两个公司的处理方法不同，所以该实例用访问者模式来实现比较适合。 首先，定义一个公司（Company）接口，它是抽象访问者，提供了两个根据纸（Paper）或铜（Cuprum）这两种元素创建作品的方法；再定义艺术公司（ArtCompany）类和造币公司（Mint）类，它们是具体访问者，实现了父接口的方法；然后，定义一个材料（Material）接口，它是抽象元素，提供了 accept（Company visitor）方法来接受访问者（Company）对象访问；再定义纸（Paper）类和铜（Cuprum）类，它们是具体元素类，实现了父接口中的方法；最后，定义一个材料集（SetMaterial）类，它是对象结构角色，拥有保存所有元素的容器 List，并提供让访问者对象遍历容器中的所有元素的 accept（Company visitor）方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 抽象访问者：公司interface Company &#123; String create(Paper element); String create(Cuprum element);&#125;// 具体访问者：艺术公司class ArtCompany implements Company &#123; public String create(Paper element) &#123; return &quot;讲学图&quot;; &#125; public String create(Cuprum element) &#123; return &quot;朱熹铜像&quot;; &#125;&#125;// 具体访问者：造币公司class Mint implements Company &#123; public String create(Paper element) &#123; return &quot;纸币&quot;; &#125; public String create(Cuprum element) &#123; return &quot;铜币&quot;; &#125;&#125;// 抽象元素：材料interface Material &#123; String accept(Company visitor);&#125;// 具体元素：纸class Paper implements Material &#123; public String accept(Company visitor) &#123; return (visitor.create(this)); &#125;&#125;// 具体元素：铜class Cuprum implements Material &#123; public String accept(Company visitor) &#123; return (visitor.create(this)); &#125;&#125;// 对象结构角色:材料集class SetMaterial &#123; private List&lt;Material&gt; list = new ArrayList&lt;&gt;(); public String accept(Company visitor) &#123; Iterator&lt;Material&gt; iterator = list.iterator(); StringBuilder sb = new StringBuilder(); String temp; while(iterator.hasNext()) &#123; temp = iterator.next().accept(visitor); sb.append(temp).append(&quot; &quot;); &#125; return sb.toString(); // 返回某公司的作品集 &#125; public void add(Material element) &#123; list.add(element); &#125; public void remove(Material element) &#123; list.remove(element); &#125;&#125; ANDROID 源码中的实现 Android 的编译时注解是一种访问者模式。编译时注解的核心原理依赖 APT （Annotation Processing Tools）实现。 编译时注解解析的基本原理是，在某些代码元素上（如类型、函数、字段等）添加注解，在编译时编译器会检查 AbstractProcessor 的子类，并且调用该类型的 process 函数，然后将添加了注解的所有元素都传递到 process 函数中，使得开发人员可以在编译期进行相应的处理。 编写注解处理器的核心是 AnnotationProcessorFactory 和 AnnotationProcessor 两个接口，后者表示的是注解处理器，而前者则是为某些注解类型创建注解处理器的工厂。 对于编译器来说，代码中的元素结构是基本不变的，例如，组成代码的基本元素由包、类、函数、字段、类型参数、变量。JDK 中为这些元素定义了一个基类，也就是 Element 类，它有如下几个子类： PackageElement 包元素，包含了某个包下的信息，可以获取到包名等； TypeElement：类型元素，如某个字段属于某种类型； ExecutableElement：可执行元素，代表了函数类型的元素； VariableElement：变量元素； TypeParameterElement：类型参数元素。 因为注解可以指定作用在哪些元素上，因此，通过上述的抽象来对应这些元素，例如下面这个注解，指定的是只能作用于方法上面，并且这个注解只能保留在 class 文件中（编译时注解）：12345@Target(ElementType. METHOD)@Retention(RetentionPolicy.CLASS)public @interface Test &#123; String value();&#125; 该注解因为只能作用于函数类型，因此，它对应的元素类型就是 ExecutableElement，当我们想通过 APT 处理这个注解时就可以获取目标对象上的 Test 注解，并将所有这些元素转换为 ExecutableElement 元素，以便获取到它们对应的信息。 我们看看元素基类的实现，完整的路径为 javax.lang.model.element.Element。12345678910111213public interface Element extends AnnotatedConstruct &#123; TypeMirror asType(); // 获取元素类型 ElementKind getKind(); // 获取元素修饰符，如 public、static、final 等 Set&lt;Modifier&gt; getModifiers(); // 代码省略 List&lt;? extends Element&gt; getEnclosedElements(); // 接受访问者的访问 &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p);&#125; 可以看到 Element 定义了一个代码元素的一些通用接口，其中很显眼的就是 accept 函数，这个函数接收一个 ElementVisitor 和类型为 P 的参数，ElementVisitor 就是访问者类型，而 P 则用于传递一些额外的参数给 visitor。这是一个典型的访问者模式。 ElementVisitor 定义如下：12345678910111213141516171819// 元素访问者public interface ElementVisitor&lt;R, P&gt; &#123; // 访问元素 R visit(Element var1, P var2); R visit(Element var1); // 访问包元素 R visitPackage(PackageElement var1, P var2); // 访问类型元素 R visitType(TypeElement var1, P var2); // 访问变量元素 R visitVariable(VariableElement var1, P var2); // 访问可执行元素 R visitExecutable(ExecutableElement var1, P var2); // 访问参数元素 R visitTypeParameter(TypeParameterElement var1, P var2); // 访问位置元素，为后续扩展预留的接口 R visitUnknown(Element var1, P var2);&#125; 当 Visitor 对元素结构进行访问时，就可以针对不同的类型进行不同的处理。例如 SimpleElementVisitor6 就是其中一个访问者，它基本上没做什么操作，直接返回了元素的默认值。123456789101112131415161718192021222324252627282930313233343536@SupportedSourceVersion(SourceVersion.RELEASE_6)public class SimpleElementVisitor6&lt;R, P&gt; extends AbstractElementVisitor6&lt;R, P&gt; &#123; protected final R DEFAULT_VALUE; protected SimpleElementVisitor6() &#123; this.DEFAULT_VALUE = null; &#125; protected SimpleElementVisitor6(R var1) &#123; this.DEFAULT_VALUE = var1; &#125; protected R defaultAction(Element var1, P var2) &#123; return this.DEFAULT_VALUE; &#125; public R visitPackage(PackageElement var1, P var2) &#123; return this.defaultAction(var1, var2); &#125; public R visitType(TypeElement var1, P var2) &#123; return this.defaultAction(var1, var2); &#125; public R visitVariable(VariableElement var1, P var2) &#123; return var1.getKind() != ElementKind.RESOURCE_VARIABLE ? this.defaultAction(var1, var2) : this.visitUnknown(var1, var2); &#125; public R visitExecutable(ExecutableElement var1, P var2) &#123; return this.defaultAction(var1, var2); &#125; public R visitTypeParameter(TypeParameterElement var1, P var2) &#123; return this.defaultAction(var1, var2); &#125;&#125; 另一个提取元素类型的访问者是 ElementKindVisitor6：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@SupportedSourceVersion(SourceVersion.RELEASE_6)public class ElementKindVisitor6&lt;R, P&gt; extends SimpleElementVisitor6&lt;R, P&gt; &#123; protected ElementKindVisitor6() &#123; super((Object)null); &#125; protected ElementKindVisitor6(R var1) &#123; super(var1); &#125; public R visitPackage(PackageElement var1, P var2) &#123; assert var1.getKind() == ElementKind.PACKAGE : &quot;Bad kind on PackageElement&quot;; return this.defaultAction(var1, var2); &#125; // 访问类型元素，比如类、注解、枚举、接口 public R visitType(TypeElement var1, P var2) &#123; ElementKind var3 = var1.getKind(); switch(var3) &#123; case ANNOTATION_TYPE: return this.visitTypeAsAnnotationType(var1, var2); case CLASS: return this.visitTypeAsClass(var1, var2); case ENUM: return this.visitTypeAsEnum(var1, var2); case INTERFACE: return this.visitTypeAsInterface(var1, var2); default: throw new AssertionError(&quot;Bad kind &quot; + var3 + &quot; for TypeElement&quot; + var1); &#125; &#125; public R visitTypeAsAnnotationType(TypeElement var1, P var2) &#123; return this.defaultAction(var1, var2); &#125; public R visitTypeAsClass(TypeElement var1, P var2) &#123; return this.defaultAction(var1, var2); &#125; public R visitTypeAsEnum(TypeElement var1, P var2) &#123; return this.defaultAction(var1, var2); &#125; public R visitTypeAsInterface(TypeElement var1, P var2) &#123; return this.defaultAction(var1, var2); &#125; ...&#125; ElementKindVisitor6 对于不同的类型进行不同的处理，提取各个元素的类型信息，例如，上述代码中对于 Type 类型的元素将分别进行处理，如类、枚举、接口、注解等。 首先，编译器将代码抽象成一个代码元素的树，然后再编译时对整棵树进行遍历访问，每个元素都有一个 accept 函数接受访问者的访问，每个访问者中都有对应的 visit 函数，例如，visitType 函数就是对类型元素的访问，在每个 visit 函数中对不同的类型进行不同的处理，这样就达到了差异处理的效果，同时将数据结构和数据操作分离，使得每个类型的职责单一，易于升级维护。JDK 还特意预留了 visitUnknown 接口来应对 Java 语言后续发展可能添加元素类型的问题，灵活地将访问者模式的缺点优化。]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[14 设计模式——模板方法模式]]></title>
    <url>%2F2019%2F08%2F20%2FPATTERN%2F14%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 模板方法（Template Method）模式：定义一个操作中的算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 在面向对象开发过程中，通常会遇到这样的一个问题，我们知道一个算法所需的关键步骤，并确定了这些步骤的执行顺序，但是某些步骤的具体实现是未知的，或者说某些步骤的实现是会随着环境的变化而改变的。 例如，执行程序的流程大致如下：1）检查代码的正确性；2）链接相关的类库；3）编译相关代码；4）执行程序。 对于不同的程序设计语言，上述 4 个步骤都是不一样的，但是它们的执行流程都是固定的，这类问题的解决方案就是模板方法模式。 优点 它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。 它在父类中提取了公共的部分代码，便于代码复用。 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。 缺点 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。 使用场景 多个子类有公有的方法，并且逻辑基本相同是。 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能由各个子类实现。 重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为。 结构与实现 模板方法模式需要注意抽象类与具体子类之间的协作。它用到了虚函数的多态性技术以及“不用调用我，让我来调用你”的反向控制技术。现在来介绍它们的基本结构。 模式包含以下主要角色。 AbstractClass：抽象类，定义了一整套算法框架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。 基本方法：是整个算法中的一个步骤，包含以下几种类型。 抽象方法：在抽象类中申明，由具体子类实现。 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。 ConcreteClass：具体实现类，根据需要去实现抽象类中的方法。 其结构图如下图所示。 代码如下：123456789101112131415161718192021222324252627282930public class TemplateMethodPattern &#123; public static void main(String[] args) &#123; AbstractClass tm = new ConcreteClass(); tm.TemplateMethod(); &#125;&#125;// 抽象类abstract class AbstractClass &#123; // 模板方法，不允许覆写 public final void TemplateMethod() &#123; SpecificMethod(); abstractMethod1(); abstractMethod2(); &#125; // 具体方法 public void SpecificMethod() &#123; System.out.println(&quot;抽象类中的具体方法被调用...&quot;); &#125; public abstract void abstractMethod1(); // 抽象方法1 public abstract void abstractMethod2(); // 抽象方法2&#125;// 具体子类class ConcreteClass extends AbstractClass &#123; public void abstractMethod1() &#123; System.out.println(&quot;抽象方法1的实现被调用...&quot;); &#125; public void abstractMethod2() &#123; System.out.println(&quot;抽象方法2的实现被调用...&quot;); &#125;&#125; 示例 以送快递为例，快递员送快递基本就是一套固定的流程：收到快递 &gt;&gt; 准备派送 &gt;&gt; 联系收货人 &gt;&gt; 确定结果。 定义算法框架，这里是快递员派送快递的步骤：123456789101112131415161718192021222324252627282930313233343536// 抽象快递员类public abstract class Postman &#123; // 派送流程 // 这里申明为final，不希望子类覆盖这个方法，防止更改流程的执行顺序 public final void post() &#123; prepare(); // 准备派送 call(); // 联系收货人 if (isSign()) &#123; // 是否签收 sign(); // 签收 &#125; else &#123; refuse(); //拒签 &#125; &#125; // 准备操作，固定流程，父类实现 protected void prepare() &#123; System.out.println(&quot;快递已达到，准备派送&quot;); &#125; // 联系收货人，联系人不一样，所以为抽象方法，子类实现 protected abstract void call(); // 是否签收,这个是钩子方法，用来控制流程的走向 protected boolean isSign() &#123; return true; &#125; // 签收，这个是固定流程，父类实现 protected void sign() &#123; System.out.println(&quot;客户已签收，上报系统&quot;); &#125; // 拒签，空实现，这个也是钩子方法，子类可以跟进实际来决定是否去实现这个方法 protected void refuse() &#123; &#125;&#125; 根据需要去实现抽象类中的方法，下面以派送给两个不同的人为例，其中一个签收，另一个拒收：1234567891011121314151617181920212223242526272829// 派送给 A 先生public class PostA extends Postman &#123; // 联系收货，实现父类的抽象方法 @Override protected void call() &#123; System.out.println(&quot;联系A先生并送到门口&quot;); &#125;&#125;// 派送给 B 先生public class PostB extends Postman &#123; // 联系收货，实现父类的抽象方法 @Override protected void call() &#123; System.out.println(&quot;联系B先生并送到门口&quot;); &#125; // 是否签收，覆盖父类的钩子方法，控制流程的走向 @Override protected boolean isSign() &#123; return false; &#125; // 拒签，覆盖父类的钩子方法 @Override protected void refuse() &#123; System.out.println(&quot;拒绝签收：商品不符&quot;); &#125;&#125; 客户端测试：12345678public void test()&#123; System.out.println(&quot;----派送A----&quot;); Postman postA=new PostA(); postA.post(); System.out.println(&quot;----派送B----&quot;); Postman postB=new PostB(); postB.post();&#125; 输出结果：12345678----派送A----快递已达到，准备派送联系A先生并送到门口客户已签收，上报系统----派送B----快递已达到，准备派送联系B先生并送到门口拒绝签收：商品不符 ANDROID 源码中的实现 在 ANDROID 中，使用模板方法模式的示例有很多。例如：Activity 的生命周期函数、View 的 draw 方法 和 AsyncTask 类。 AsyncTask 的整个执行过程其实是一个框架，具体的实现都需要子类来完成，而且它执行的算法框架是固定的，调用 execute 后会依次执行 onPreExecute、doInBackground、onPostExecute，当然也可以通过 onProgressUpdate 来更新进度。 AsyncTask 的 execute 方法如下：12345678910111213141516171819202122232425262728@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125;@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this;&#125; 可以看到 execute 方法是一个 final 方法，它调用了 executeOnExecutor 方法。如果不是 Pending 状态会抛出依次，这也解释了为什么 AsyncTask 只能被执行一次，因为 AsyncTask 的 Running 和 Finished 状态都会抛出异常，因此每次使用 AsyncTask 时都需要重新创建一个对象。 继续往下看，在 executeOnExecutor 方法中首先执行了 onPreExecute 方法，因为 AsyncTask 的要求是需要在 UI 线程中调用 execute 方法。因此，onPreExecute 方法也在 UI 线程中执行，然后将 params 参数传递给 mWorker 对象的 mParams 字段，并且执行了 exec.execute(mFuture) 方法。而 mWorker 和 mFuture 这两个字段都是在构造函数中初始化。12345678910111213141516171819202122232425262728293031public AsyncTask(@Nullable Looper callbackLooper) &#123; // 构建一个 Worker 对象 mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); // 调用 doInBackground result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; postResult(result); &#125; return result; &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; // 代码省略 &#125; &#125;;&#125; mWorker 的 call 方法会调用 doInBackground，并且在 finally 方法里面将 result 通过 postResult 方法传递出去。 mFuture 包装了 mWorker 对象，在这个 mFuture 对象的 run 函数中又会调用 mWorker 对象的 call 方法，在 call 方法中调用了 doInBackground 函数。因为 mFuture 提交给了线程池来执行，所以使得 doInBackground 执行在非 UI 线程。得到 doInBackground 的结果后，通过 postResult 传递结果给 UI 线程。 postResult 方法如下：1234567private Result postResult(Result result) &#123; @SuppressWarnings(&quot;unchecked&quot;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; postResult 方法把一个消息（MESSAGE_POST_RESULT）发送给 Handler 执行。Handler 是 InternalHandler 类型。当 InternalHandler 接到 MESSAGE_POST_RESULT 类型的消息时，就会调用 result.mTask.finish() 方法。12345678910111213141516171819202122232425262728293031private static class InternalHandler extends Handler &#123; public InternalHandler(Looper looper) &#123; super(looper); &#125; @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result // 调用了 AsyncTask 的 finish 方法 result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125; private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; // 结果通过 onPostExecute 回调给用户 onPostExecute(result); &#125; mStatus = Status.FINISHED; // 修改状态 &#125;&#125; AsyncTask 的 finish 方法又调用了 onPostExecute ，这个时候执行过程就完成了。 总之，execute 方法内部封装了 onPreExecute、doInBackground、onPostExecute 这个逻辑流程，用户可以根据自己的需求再覆写这几个方法，使得用户可以很方便地使用异步任务来完成耗时地操作以及更新UI，这其实就是通过线程池来执行耗时地任务，得到结果之后，通过 Handler 将结果传递到 UI 线程来执行。]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13 设计模式——迭代器模式]]></title>
    <url>%2F2019%2F08%2F19%2FPATTERN%2F13%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 迭代器（Iterator）模式：提供一种方法顺序访问一个容器对象中的各个元素，而又不需暴露该对象的内部细节。 在程序设计中，经常要访问一个聚合对象中的各个元素，如数据结构中的链表遍历，通常的做法是将链表的创建和遍历都放在同一个类中，但这种方式不利于程序的扩展，如果要更换遍历方法就必须修改程序源代码，这违背了 “开闭原则”。 既然将遍历方法封装在聚合类中不可取，那么聚合类中不提供遍历方法，将遍历方法由用户自己实现是否可行呢？答案是同样不可取，因为这种方式会存在两个缺点：暴露了聚合类的内部表示，使其数据不安全；增加了客户的负担。 迭代器模式能较好地克服以上缺点，它在客户访问类与聚合类之间插入一个迭代器，这分离了聚合对象与其遍历行为，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则”，如 Java 中的 Collection、List、Set、Map 等都包含了迭代器。 优点 访问一个聚合对象的内容而无须暴露它的内部表示。 遍历任务交由迭代器完成，这简化了聚合类。 它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。 增加新的聚合类和迭代器类都很方便，无须修改原有代码。 封装性良好，为遍历不同的聚合结构提供一个统一的接口。 缺点 增加了类的个数，这在一定程度上增加了系统的复杂性。 使用场景 遍历一个容器对象时。 结构与实现 迭代器模式是通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现的，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明地访问聚合的内部数据。现在我们来分析其基本结构与实现方法。 模式包含以下主要角色。 Iterator（迭代器接口）：负责定义、访问和遍历元素的接口。 ConcreteIterator（具体迭代器类）：实现迭代器接口。 Aggregate（容器接口）：定义容器的基本功能以及提供创建迭代器的接口。 ConcreteAggregate（具体容器类）：实现容器接口中的功能。 Client（客户端类）：即要使用迭代器模式的地方。 其结构图如下图所示： 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class IteratorPattern &#123; public static void main(String[] args) &#123; Aggregate&lt;String&gt; aggregate = new ConcreteAggregate&lt;&gt;(); aggregate.add(&quot;中山大学&quot;); aggregate.add(&quot;华南理工&quot;); aggregate.add(&quot;韶关学院&quot;); System.out.print(&quot;聚合的内容有：&quot;); Iterator&lt;String&gt; it = aggregate.getIterator(); while (it.hasNext()) &#123; System.out.print(it.next() + &quot;\t&quot;); &#125; System.out.println(&quot;\nFirst：&quot; + it.first()); &#125;&#125;// 抽象聚合interface Aggregate&lt;T&gt; &#123; void add(T obj); void remove(T obj); Iterator&lt;T&gt; iterator(); &#125;// 具体聚合，具体容器class ConcreteAggregate&lt;T&gt; implements Aggregate&lt;T&gt; &#123; private List&lt;T&gt; list = new ArrayList&lt;T&gt;(); public void add(T obj) &#123; list.add(obj); &#125; public void remove(T obj) &#123; list.remove(obj); &#125; public Iterator&lt;T&gt; getIterator() &#123; return(new ConcreteIterator&lt;T&gt;(list)); &#125; &#125;// 抽象迭代器interface Iterator&lt;T&gt; &#123; T first(); T next(); boolean hasNext();&#125;// 具体迭代器class ConcreteIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123; private List&lt;T&gt; list; private int index = -1; public ConcreteIterator(List&lt;T&gt; list) &#123; this.list = list; &#125; public boolean hasNext() &#123; return index &lt; list.size() - 1; &#125; public T first() &#123; index = 0; return list.get(index); &#125; public T next() &#123; T obj = null; if (this.hasNext()) &#123; obj = list.get(++index); &#125; return obj; &#125; &#125; 示例 用迭代器模式编写一个浏览婺源旅游风景图的程序。 分析：婺源的名胜古迹较多，要设计一个查看相关景点图片和简介的程序，用“迭代器模式”设计比较合适。 首先，设计一个婺源景点（WyViewSpot）类来保存每张图片的名称与简介；再设计一个景点集（ViewSpotSet）接口，它是抽象聚合类，提供了增加和删除婺源景点的方法，以及获取迭代器的方法。 然后，定义一个婺源景点集（WyViewSpotSet）类，它是具体聚合类，用 ArrayList 来保存所有景点信息，并实现父类中的抽象方法；再定义婺源景点的抽象迭代器（ViewSpotltemtor）接口，其中包含了查看景点信息的相关方法。 最后，定义婺源景点的具体迭代器（WyViewSpotlterator）类，它实现了父类的抽象方法。 程序代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 婺源景点类class WyViewSpot &#123; private String name; private String introduce; WyViewSpot(String name, String Introduce) &#123; this.name = name; this.introduce = introduce; &#125; public String getName() &#123; return name; &#125; public String getIntroduce() &#123; return introduce; &#125;&#125;// 抽象聚合：婺源景点集接口interface ViewSpotSet &#123; void add(WyViewSpot obj); void remove(WyViewSpot obj); ViewSpotIterator iterator();&#125;// 具体聚合：婺源景点集class WyViewSpotSet implements ViewSpotSet &#123; private List&lt;WyViewSpot&gt; list = new ArrayList&lt;&gt;(); public void add(WyViewSpot obj) &#123; list.add(obj); &#125; public void remove(WyViewSpot obj) &#123; list.remove(obj); &#125; public ViewSpotIterator iterator() &#123; return(new WyViewSpotIterator(list)); &#125;&#125;// 抽象迭代器：婺源景点迭代器接口interface ViewSpotIterator &#123; boolean hasNext(); WyViewSpot next();&#125;// 具体迭代器：婺源景点迭代器class WyViewSpotIterator implements ViewSpotIterator &#123; private List&lt;WyViewSpot&gt; list; private int index = -1; public WyViewSpotIterator(List&lt;WyViewSpot&gt; list) &#123; this.list = list; &#125; public boolean hasNext() &#123; return index &lt; list.size() - 1; &#125; public WyViewSpot next() &#123; return list.get(++index); &#125;&#125; 由于聚合与迭代器的关系非常密切，所以大多数语言在实现聚合类时都提供了迭代器类，因此大数情况下使用语言中已有的聚合类的迭代器就已经够了。 ANDROID 源码中的实现 ANDROID 中典型的迭代器模式例子是数据库查询使用 Cursor，当我们使用 SQLiteDatabase 的 query 方法查询数据时，会返回一个 Cursor 游标对象，该游标对象实质就是一个具体的迭代器，我们可以使用它遍历数据库查询所得到的结果集。 首先定义一个 SQLiteOpenHelper：1234567891011121314151617public class DBHelper extends SQLiteOpenHelper &#123; public DBHelper(Context context) &#123; super(context, &quot;DB_AIGE&quot;, null, 1); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL(&quot;CREATE TABLE table_aige (_id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, sex TEXT)&quot;); db.execSQL(&quot;INSERT INTO table_aige (name, sex) values (&apos;Aige&apos;, &apos;man&apos;)&quot;); db.execSQL(&quot;INSERT INTO table_aige (name, sex) values (&apos;SMBrother&apos;, &apos;man&apos;)&quot;); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125;&#125; 构造 ContentProvider：123456789101112131415161718192021222324252627282930313233343536373839public class DataProvider extends ContentProvider &#123; private DBHelper dbHelper; @Override public boolean onCreate() &#123; dbHelper = new DBHelper(getContext()); return true; &#125; @Nullable @Override public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) &#123; SQLiteDatabase db = dbHelper.getReadableDatabase(); return db.query(&quot;table_aige&quot;, projection, null, null, null, null, null); &#125; @Nullable @Override public String getType(@NonNull Uri uri) &#123; return null; &#125; @Nullable @Override public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) &#123; return null; &#125; @Override public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) &#123; return 0; &#125; @Override public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) &#123; return 0; &#125;&#125; 在 Activity 使用 ContentProvider：123456789101112131415161718192021222324public class IteratorActivity extends ListActivity &#123; private static final Uri URI = Uri.parse(&quot;content://com.android.androidsamples.dataprovider/table_aige&quot;); private static final String[] PROJECTION = new String[]&#123;&quot;name&quot;, &quot;sex&quot;&#125;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Cursor cursor = getContentResolver().query(URI, PROJECTION, null, null, null); List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;&gt;(); cursor.moveToFirst(); do &#123; Map&lt;String, String&gt; item = new HashMap&lt;&gt;(); item.put(&quot;name&quot;, cursor.getString(0)); item.put(&quot;sex&quot;, cursor.getString(1)); list.add(item); &#125; while (cursor.moveToNext()); cursor.close(); setListAdapter(new SimpleAdapter(this, list, android.R.layout.simple_list_item_2, new String[]&#123;&quot;name&quot;, &quot;sex&quot;&#125;, new int[]&#123;android.R.id.text1, android.R.id.text2&#125;)); &#125;&#125; 注册组件：123&lt;activity android:name=&quot;.iterator.IteratorActivity&quot; /&gt;&lt;provider android:authorities=&quot;com.android.androidsamples.dataprovider&quot; android:name=&quot;.iterator.DataProvider&quot;/&gt;]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12 设计模式——备忘录模式]]></title>
    <url>%2F2019%2F08%2F18%2FPATTERN%2F12%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 备忘录（Memento）模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将该对象恢复到先前保存的状态。 其实很多应用软件都使用了该模式，如 Word、记事本、Photoshop、Eclipse 等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 IE 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。 备忘录模式能记录一个对象的内部状态，当用户后悔时能撤销当前操作，使数据恢复到它原先的状态。 优点 提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。 实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。 简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。 缺点 资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。 使用场景 需要保存一个对象在某一时刻的状态或部分状态。 如果用一个接口来让其他对象得到这些状态，将会暴露对象的实现细节并破坏对象的封装性，一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态。 结构与实现 模式包含以下主要角色。 Originator（发起人角色）：负责创建一个备忘录（Memoto），能够记录内部状态，以及恢复原来记录的状态。并且能够决定哪些状态是需要备忘的。 Memoto（备忘录角色）：将发起人（Originator）对象的内部状态存储起来；并且可以防止发起人（Originator）之外的对象访问备忘录（Memoto）。 Caretaker（负责人角色）：负责保存备忘录（Memoto），不能对备忘录（Memoto）的内容进行操作和访问，只能将备忘录传递给其他对象。 其结构图如下图所示。 备忘录模式的实现代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class MementoPattern &#123; public static void main(String[] args) &#123; Originator originator = new Originator(); Caretaker caretaker = new Caretaker(); originator.setState(&quot;S0&quot;); System.out.println(&quot;初始状态:&quot; + originator.getState()); caretaker.setMemento(originator.createMemento()); // 保存状态 originator.setState(&quot;S1&quot;); System.out.println(&quot;新的状态:&quot; + originator.getState()); originator.restoreMemento(caretaker.getMemento()); // 恢复状态 System.out.println(&quot;恢复状态:&quot; + originator.getState()); &#125;&#125;// 备忘录class Memento &#123; private String state; public Memento(String state) &#123; this.state=state; &#125; public void setState(String state) &#123; this.state=state; &#125; public String getState() &#123; return state; &#125;&#125;// 发起人class Originator &#123; private String state; public void setState(String state) &#123; this.state=state; &#125; public String getState() &#123; return state; &#125; public Memento createMemento() &#123; return new Memento(state); &#125; public void restoreMemento(Memento m) &#123; this.setState(m.getState()); &#125; &#125;// 管理者class Caretaker &#123; private Memento memento; public void setMemento(Memento m) &#123; memento=m; &#125; public Memento getMemento() &#123; return memento; &#125;&#125; 示例 以游戏存档为例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Originator * 这里则是游戏类，游戏类提供存档和读档的功能 */public class Game &#123; private int mLevel = 1; // 等级 private int mCoin = 0; // 金币数量 @Override public String toString() &#123; return &quot;game&#123;&quot; + &quot;mLevel=&quot; + mLevel + &quot;, mCoin=&quot; + mCoin + &apos;&#125;&apos;; &#125; public void play() &#123; System.out.println(&quot;升级了&quot;); mLevel++; System.out.println(&quot;当前等级为:&quot; + mLevel); System.out.println(&quot;获得金币:32&quot;); mCoin += 32; System.out.println(&quot;当前金币数量为:&quot; + mCoin); &#125; public void exit() &#123; System.out.println(&quot;退出游戏&quot;); System.out.println(&quot;退出游戏时的属性 : &quot; + toString()); &#125; // 创建备忘录,即游戏存档 public Memento createMemento() &#123; Memento memento = new Memento(); memento.level = mLevel; memento.coin = mCoin; return memento; &#125; public void setMemento(Memento memento) &#123; mLevel = memento.level; mCoin = memento.coin; System.out.println(&quot;读取存档信息:&quot; + toString()); &#125;&#125;/** * Memento * 负责将游戏类的内部状态存储起来 */public class Memento &#123; public int level; // 等级 public int coin; // 金币数量&#125;/** * Caretaker * 备忘录管理类 */public class Caretaker &#123; private Memento mMemento; public void setMemento(Memento memento) &#123; mMemento = memento; &#125; public Memento getMemento() &#123; return mMemento; &#125;&#125; 客户端测试：12345678910111213141516public void test() &#123; System.out.println(&quot;首次进入游戏&quot;); Game game = new Game(); game.play(); Memento memento = game.createMemento(); // 创建存档 Caretaker caretaker = new Caretaker(); caretaker.setMemento(memento); // 保存存档 game.exit(); System.out.println(&quot;-------------&quot;); System.out.println(&quot;二次进入游戏&quot;); Game secondGame = new Game(); secondGame.setMemento(caretaker.getMemento()); // 读取存档 secondGame.play(); secondGame.exit();&#125; 输出结果：12345678910111213141516首次进入游戏升级了当前等级为:2获得金币:32当前金币数量为:32退出游戏退出游戏时的属性 : game&#123;mLevel=2, mCoin=32&#125;-------------二次进入游戏读取存档信息:game&#123;mLevel=2, mCoin=32&#125;升级了当前等级为:3获得金币:32当前金币数量为:64退出游戏退出游戏时的属性 : game&#123;mLevel=3, mCoin=64&#125; ANDROID 源码中的实现 状态保存是 ANDROID 中备忘录模式的典型使用，主要对应 Activity的两个回调方法 onSaveInstanceState() 和 onRestoreInstanceState()。 onSaveInstanceState 方法的代码如下：12345678910111213141516171819protected void onSaveInstanceState(Bundle outState) &#123; // 存储当前窗口的视图树的状态 outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState()); outState.putInt(LAST_AUTOFILL_ID, mLastAutofillId); // 存储 fragment 的状态 Parcelable p = mFragments.saveAllState(); if (p != null) &#123; outState.putParcelable(FRAGMENTS_TAG, p); &#125; // 存储自动填充的字段 if (mAutoFillResetNeeded) &#123; outState.putBoolean(AUTOFILL_RESET_NEEDED, true); getAutofillManager().onSaveInstanceState(outState); &#125; // 如果用户还设置了 Activity 的 ActivityLifecycleCallbacks， // 那么调用这些 ActivityLifecycleCallbacks 的 onSaveInstanceState 进行存储状态 getApplication().dispatchActivitySaveInstanceState(this, outState);&#125; 上述 onSaveInstanceState 函数中，主要分为如下 3 步：1）存储窗口的视图树的状态；2）存储 Fragment 的状态3）调用 ActivityLifecycleCallbacks 的 onSaveInstanceState 函数进行状态存储。 我们先看第一步，在这一步将 Window 对象中的视图树中欧冠各个 View 状态存储到 Bundle 中。这样一来，当用户重新进入到该 Activity 时，用户 UI 的结构、状态才会被重新恢复，以此来保证用户界面的一致性。Window 类的具体实现类是 PhoneWindow，其中 saveHierarchyState 方法如下：12345678910111213141516171819202122232425262728293031323334353637@Overridepublic Bundle saveHierarchyState() &#123; Bundle outState = new Bundle(); if (mContentParent == null) &#123; return outState; &#125; // 通过 SparseArray 类来存储，这相当于一个 key 为整型的 map SparseArray&lt;Parcelable&gt; states = new SparseArray&lt;Parcelable&gt;(); // 调用 mContentParent 的 saveHierarchyState 方法，这个 mContentParent 就是调用 Activity 的 // setContentView 函数设置的内容视图，它是内容视图的根节点，在这里存储整棵视图树的结构。 mContentParent.saveHierarchyState(states); // 将视图树结构放到 outState 中 outState.putSparseParcelableArray(VIEWS_TAG, states); // 保存当前界面中获取了焦点的 View // Save the focused view ID. final View focusedView = mContentParent.findFocus(); if (focusedView != null &amp;&amp; focusedView.getId() != View.NO_ID) &#123; // 持有焦点的 View 必须要设置 id，否则重新进入该界面时不会恢复它的焦点状态 outState.putInt(FOCUSED_ID_TAG, focusedView.getId()); &#125; // 存储整个面板的状态 // save the panels SparseArray&lt;Parcelable&gt; panelStates = new SparseArray&lt;Parcelable&gt;(); savePanelState(panelStates); if (panelStates.size() &gt; 0) &#123; outState.putSparseParcelableArray(PANELS_TAG, panelStates); &#125; // 存储 ActionBar 的状态 if (mDecorContentParent != null) &#123; SparseArray&lt;Parcelable&gt; actionBarStates = new SparseArray&lt;Parcelable&gt;(); mDecorContentParent.saveToolbarHierarchyState(actionBarStates); outState.putSparseParcelableArray(ACTION_BAR_TAG, actionBarStates); &#125; return outState;&#125; 在 saveHierarchyState 中，主要时存储了与当前 UI、ActionBar 相关的 View 状态，这里用 mContentParent 来分析。这个 mContentParent 就是我们通过 Activity 的 setContentView 函数设置的内容视图，它是整个内容视图的根节点，存储它层级结构中的 View 状态也就存储了用户界面的状态。mContentParent 是一个 ViewGroup 对象，但是，saveHierarchyState 并不是在 ViewGroup 中，而是在 ViewGroup 的父类 View。 View 的 saveHierarchyState 方法如下：123456789101112131415161718192021222324252627public void saveHierarchyState(SparseArray&lt;Parcelable&gt; container) &#123; dispatchSaveInstanceState(container);&#125;protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) &#123; // 注意：如果 View 没有设置 id，那么这个 View 的状态将不会被存储。 if (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == 0) &#123; mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED; // 调用 onSaveInstanceState 获取自身的状态 Parcelable state = onSaveInstanceState(); if ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == 0) &#123; throw new IllegalStateException( &quot;Derived class did not call super.onSaveInstanceState()&quot;); &#125; if (state != null) &#123; // 将自身状态放到 container 中，key 为 id、value 为自身状态。 container.put(mID, state); &#125; &#125;&#125;// View 类默认存储的状态为空protected Parcelable onSaveInstanceState() &#123; mPrivateFlags |= PFLAG_SAVE_STATE_CALLED; ... return BaseSavedState.EMPTY_STATE;&#125; 在 View 类中的 saveHierarchyState 函数调用了 dispatchSaveInstanceState 函数来存储自身的状态，而 ViewGroup 则覆写了 dispatchSaveInstanceState 函数来存储自身以及子视图的状态，函数如下：123456789101112@Overrideprotected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) &#123; super.dispatchSaveInstanceState(container); final int count = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; count; i++) &#123; View c = children[i]; if ((c.mViewFlags &amp; PARENT_SAVE_DISABLED_MASK) != PARENT_SAVE_DISABLED) &#123; c.dispatchSaveInstanceState(container); &#125; &#125;&#125; dispatchSaveInstanceState 会首先调用 super 的方法存储自身的状态，然后调用每个子视图的 dispatchSaveInstanceState。 注意：如果 View 没有设置 id，那么这个 View 的状态将不会被存储。设置了这个 id 也要保证在一个 Activity 的布局中必须是唯一的，否则会出现状态覆盖的情况。 这些被存储的状态通过 onSaveInstanceState 函数得到，但在 View 类中我们看到返回的是一个空状态。这就意味着，当我们需要存储 View 状态是，需要覆写 onSaveInstanceState 方法，将要存储的数据放到 Parcelable 对象中，并且将它返回。我们看看 TextView 的实现。123456789101112131415161718192021222324252627282930313233343536@Overridepublic Parcelable onSaveInstanceState() &#123; Parcelable superState = super.onSaveInstanceState(); // 代码省略 // 存储 TextView 的 start、end 以及文本内容 if (freezesText || hasSelection) &#123; SavedState ss = new SavedState(superState); if (freezesText) &#123; if (mText instanceof Spanned) &#123; final Spannable sp = new SpannableStringBuilder(mText); if (mEditor != null) &#123; removeMisspelledSpans(sp); sp.removeSpan(mEditor.mSuggestionRangeSpan); &#125; ss.text = sp; &#125; else &#123; ss.text = mText.toString(); &#125; &#125; if (hasSelection) &#123; // XXX Should also save the current scroll position! ss.selStart = start; ss.selEnd = end; &#125; // 代码省略 return superState; &#125;&#125; 存储完 Window 的视图树状态后，会存储每个 Fragment 的状态，调用它们的 onSaveInstanceState 方法。最后调用 ActivityLifecycleCallbacks 的 onSaveInstanceState。 P 版本（Android 9）之前，onSaveInstanceState 会在 onStop 之前调用。P 版本（Android 9）之后，onSaveInstanceState 会在 onStop 之后调用。ActivityThread 的 performStopActivity 会调用 callActivityOnStop。callActivityOnStop 代码如下：12345678910111213141516171819202122232425262728private void callActivityOnStop(ActivityClientRecord r, boolean saveState, String reason) &#123; // Before P onSaveInstanceState was called before onStop, starting with P it&apos;s // called after. Before Honeycomb state was always saved before onPause. final boolean shouldSaveState = saveState &amp;&amp; !r.activity.mFinished &amp;&amp; r.state == null &amp;&amp; !r.isPreHoneycomb(); final boolean isPreP = r.isPreP(); if (shouldSaveState &amp;&amp; isPreP) &#123; callActivityOnSaveInstanceState(r); &#125; try &#123; r.activity.performStop(false /*preserveWindow*/, reason); &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(r.activity, e)) &#123; throw new RuntimeException( &quot;Unable to stop activity &quot; + r.intent.getComponent().toShortString() + &quot;: &quot; + e.toString(), e); &#125; &#125; r.setState(ON_STOP); if (shouldSaveState &amp;&amp; !isPreP) &#123; callActivityOnSaveInstanceState(r); &#125;&#125; callActivityOnSaveInstanceState 方法会将状态信息存储到 ActivityClientRecord 对象的 state 字段中。1234567891011private void callActivityOnSaveInstanceState(ActivityClientRecord r) &#123; r.state = new Bundle(); r.state.setAllowFds(false); if (r.isPersistable()) &#123; r.persistentState = new PersistableBundle(); mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state); &#125;&#125; 在 ActivityThread 类的 performLaunchActivity 方法会回调 onCreate，将 ActivityClientRecord 对象的 state 字段传递给 onCreate。12345678910private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ... if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ... return activity;&#125; 在 ActivityThread 类的 handleStartActivity 方法中会调用 callActivityOnRestoreInstanceState 恢复 InstanceState。1234567891011121314151617@Overridepublic void handleStartActivity(ActivityClientRecord r, PendingTransactionActions pendingActions) &#123; ... // Restore instance state if (pendingActions.shouldRestoreInstanceState()) &#123; if (r.isPersistable()) &#123; if (r.state != null || r.persistentState != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); &#125; &#125; else if (r.state != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); &#125; &#125; ...&#125; 总结： Bundle 对应备忘录：Android 的状态，包括视图树状态和 Fragment 状态以及生命周期状态都是通过 Bundle 这个数据结构存储键值对的 Parcel 对象保存的，特别注意一点，对于同一个 Activity的视图放到一个 Bundle 中用 SparceArray（类似 HashMap 不过空间使用效率更高，内部查找二分法，而且键只能是整数）来存储。键：ViewId。值：对应的 Parcel 对象，所以 ViewId 不能重复，不然会覆盖。 Activity 对应备忘录管理类。严格来说应该是 Activity 中的内部属性。mActivities 实际是一个 ActivityClientRecord 集合，每个 Activity 的信息对应一个 ActivityClientRecord，相应的键是 Token。ActivityClientRecord 的 Bundle 类型的 State 对应 Bundle（备忘录）。 View 和 Fragment 等都对应 Originator 类，他们都需要伴随 Activity 的生命周期函数 onSaveInstanceState() 和 OnRestoreInstanceState() 通过 Bundle 这种数据结构完成自己状态的管理。 实战 简化版记事本：保存、撤销、重做。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class NoteEditText extends AppCompatEditText &#123; public NoteEditText(Context context) &#123; super(context); &#125; public NoteEditText(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public NoteEditText(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; // 创建备忘录对象，即存储编辑器的指定数据 public Memo createMemo() &#123; Memo memo = new Memo(); memo.text = getText().toString(); memo.cursor = getSelectionStart(); return memo; &#125; // 从备忘录中恢复数据，设置光标位置 public void restore(Memo memo) &#123; setText(memo.text); setSelection(memo.cursor); &#125;&#125;public class Memo &#123; public String text; public int cursor;&#125;// 负责管理 Memo 对象public class NoteCaretaker &#123; // 最大存储数量 private static final int MAX = 30; // 存储 30 条记录 private List&lt;Memo&gt; mMemos = new ArrayList&lt;&gt;(MAX); private int mIndex = 0; /** * 保存备忘录到记录列表中 * @param memo Memo */ public void saveMemo(Memo memo) &#123; if (mMemos.size() &gt; MAX) &#123; mMemos.remove(0); &#125; mMemos.add(memo); mIndex = mMemos.size() - 1; &#125; // 获取上一个存档信息，相当于撤销功能 public Memo getPrevMemo() &#123; mIndex = mIndex &gt; 0 ? --mIndex : mIndex; return mMemos.get(mIndex); &#125; // 获取下一个存档信息，相当于重做功能 public Memo getNextMemo() &#123; mIndex = mIndex &lt; mMemos.size() - 1 ? ++mIndex : mIndex; return mMemos.get(mIndex); &#125;&#125; 在 TestActivity 的代码如下所示：1234567891011121314151617181920212223242526272829303132333435363738394041424344public class TestActivity extends BaseActivity &#123; private NoteEditText mNoteEditText; private TextView mSaveBtn; private ImageView mUndoBtn; private ImageView mRedoBtn; private NoteCaretaker mCaretaker = new NoteCaretaker(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_test); initViews(); &#125; private void initViews() &#123; mNoteEditText = findViewById(R.id.et_note); mSaveBtn = findViewById(R.id.btn_save); mUndoBtn = findViewById(R.id.btn_undo); mRedoBtn = findViewById(R.id.btn_redo); mSaveBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mCaretaker.saveMemo(mNoteEditText.createMemo()); &#125; &#125;); mUndoBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mNoteEditText.restore(mCaretaker.getPrevMemo()); &#125; &#125;); mRedoBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mNoteEditText.restore(mCaretaker.getNextMemo()); &#125; &#125;); &#125;&#125; 附 res/layout/test.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;com.xxt.xtest.demo.NoteEditText android:id=&quot;@+id/et_note&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:gravity=&quot;left&quot; android:hint=&quot;写点嘛~&quot;/&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:paddingLeft=&quot;50dp&quot; android:paddingRight=&quot;50dp&quot; android:paddingBottom=&quot;10dp&quot;&gt; &lt;ImageView android:id=&quot;@+id/btn_undo&quot; android:layout_width=&quot;30dp&quot; android:layout_height=&quot;30dp&quot; android:layout_alignParentLeft=&quot;true&quot; android:layout_alignParentStart=&quot;true&quot; android:src=&quot;@drawable/undo&quot;/&gt; &lt;TextView android:id=&quot;@+id/btn_save&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:text=&quot;保存&quot; android:textSize=&quot;20sp&quot; android:textColor=&quot;#000&quot;/&gt; &lt;ImageView android:id=&quot;@+id/btn_redo&quot; android:layout_width=&quot;30dp&quot; android:layout_height=&quot;30dp&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_alignParentEnd=&quot;true&quot; android:src=&quot;@drawable/redo&quot;/&gt; &lt;/RelativeLayout&gt;&lt;/LinearLayout&gt;]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11 设计模式——观察者模式]]></title>
    <url>%2F2019%2F08%2F17%2FPATTERN%2F11%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 观察者（Observer）模式：定义对象间的一种一个对多的依赖关系，当一个对象的状态发送改变时，所以依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布—订阅模式、模型—视图模式，它是对象行为型模式。 观察者模式是一个使用率非常高的模式，它最常用的地方是 GUI 系统、订阅——发布系统。因为这个模式的一个重要作用就是解耦，将被观察者和观察者解耦，使得它们之间的依赖性更小，甚至做到毫无依赖。 优点 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。 目标与观察者之间建立了一套触发机制。 缺点 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。 使用场景 关联行为场景。需要注意的是，关联行为是可拆分的，而不是“组合”关系。 事件多级触发场景。 跨系统的信息交换场景，如消息队列、事件总线的处理机制。 使用例子 常见的发布—订阅模式。 ListView 的 Adapter 的 notifyDataSetChanged 更新方法。 BroadcastReceiver。 开源库 EventBus。 RxJava。 结构与实现 观察者模式包含以下主要角色。 抽象主题（Subject）：也就是被观察（Observable）的角色。它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。 具体主题（ConcreteSubject）：也就是具体被观察者（ConcreteObservable）。它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。 抽象观察者（Observer）：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。 具体观察者（ConcreteObserver）：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。 其结构图如下图所示。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class ObserverPattern &#123; public static void main(String[] args) &#123; Subject subject = new ConcreteSubject(); Observer observer1 = new ConcreteObserver1(); Observer observer2 = new ConcreteObserver2(); subject.add(observer1); subject.add(observer2); subject.notifyObserver(); &#125;&#125;// 抽象目标，被观察者abstract class Subject &#123; // 观察者集合 protected List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;(); // 增加观察者方法 public void add(Observer observer) &#123; observers.add(observer); &#125; // 删除观察者方法 public void remove(Observer observer) &#123; observers.remove(observer); &#125; public abstract void notifyObserver(); // 通知观察者方法&#125;// 具体目标，具体被观察者class ConcreteSubject extends Subject &#123; public void notifyObserver() &#123; System.out.println(&quot;具体目标发生改变...&quot;); System.out.println(&quot;--------------&quot;); for(Object obs:observers) &#123; // 通知所有观察者 ((Observer)obs).response(); &#125; &#125; &#125;// 抽象观察者interface Observer &#123; void response(); // 反应&#125;// 具体观察者 1class ConcreteObserver1 implements Observer &#123; public void response() &#123; System.out.println(&quot;具体观察者1作出反应！&quot;); &#125;&#125;// 具体观察者1class ConcreteObserver2 implements Observer &#123; public void response() &#123; System.out.println(&quot;具体观察者2作出反应！&quot;); &#125;&#125; 我们也可以利用 JDK 中 Observable 类和 Observer 接口实现。观察者实现 Observer 接口，被观察者继承 Observable 类。被观察者通过 Observable 类的 addObserver 方法添加观察者。其代码形式如下：12345678910111213141516171819202122232425262728293031323334353637383940// 具体观察者public class MyObserver implements Observer &#123; private String mName; public MyObserver(String name) &#123; mName = name; &#125; @Override public void update(Observable o, Object arg) &#123; System.out.println(mName + &quot;--&gt;&quot; + &quot;update: &quot; + arg); &#125;&#125;// 具体被观察者public class MyObservable extends Observable &#123; public void sendChangeMsg(String content) &#123; // 方法继承自 Observable，标示状态或是内容发生改变 setChanged(); // 方法继承自 Observable，通知所有观察者，最后会调用每个 Observer 的 update 方法 notifyObservers(content); &#125;&#125;// 测试public class ObserverPatternTest &#123; @Test public void test1() throws Exception &#123; MyObservable myObservable = new MyObservable(); MyObserver myObserver1 = new MyObserver(&quot;observer-1&quot;); MyObserver myObserver2 = new MyObserver(&quot;observer-2&quot;); myObservable.addObserver(myObserver1); myObservable.addObserver(myObserver2); // 发布消息 myObservable.sendChangeMsg(&quot;发布更新啦&quot;); &#125;&#125; 被观察者通过 setChanged() 方法标示改变，通过 notifyObservers 方法通知所有观察者。notifyObservers 方法会遍历所有的观察者 Observer，并调用它们的 update 方法。notifyObservers 方法中的参数就是最后传到观察者 update 方法的参数 Object arg。 示例 利用观察者模式设计一个程序，分析“人民币汇率”的升值或贬值对进口公司的进口产品成本或出口公司的出口产品收入以及公司的利润率的影响。 分析：当“人民币汇率”升值时，进口公司的进口产品成本降低且利润率提升，出口公司的出口产品收入降低且利润率降低；当“人民币汇率”贬值时，进口公司的进口产品成本提升且利润率降低，出口公司的出口产品收入提升且利润率提升。 这里的汇率（Rate）类是抽象目标类，它包含了保存观察者（Company）的 List 和增加/删除观察者的方法，以及有关汇率改变的抽象方法 change(int number)；而人民币汇率（RMBRate）类是具体目标， 它实现了父类的 change(int number) 方法，即当人民币汇率发生改变时通过相关公司；公司（Company）类是抽象观察者，它定义了一个有关汇率反应的抽象方法 response(int number)；进口公司（ImportCompany）类和出口公司（ExportCompany）类是具体观察者类，它们实现了父类的 response(int number) 方法，即当它们接收到汇率发生改变的通知时作为相应的反应。下图所示是其结构图。 程序代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class RMBRateTest &#123; public static void main(String[] args) &#123; Rate rate = new RMBRate(); Company watcher1 = new ImportCompany(); Company watcher2 = new ExportCompany(); rate.add(watcher1); rate.add(watcher2); rate.change(10); rate.change(-9); &#125;&#125;// 抽象目标：汇率abstract class Rate &#123; protected List&lt;Company&gt; companies = new ArrayList&lt;Company&gt;(); // 增加观察者方法 public void add(Company company) &#123; companies.add(company); &#125; // 删除观察者方法 public void remove(Company company) &#123; companies.remove(company); &#125; public abstract void change(int number);&#125;// 具体目标：人民币汇率class RMBRate extends Rate &#123; public void change(int number) &#123; for(Company observer : companies) &#123; ((Company) observer).response(number); &#125; &#125;&#125;// 抽象观察者：公司interface Company &#123; void response(int number);&#125;// 具体观察者1：进口公司 class ImportCompany implements Company &#123; public void response(int number) &#123; if (number&gt;0) &#123; System.out.println(&quot;人民币汇率升值&quot;+number+&quot;个基点，降低了进口产品成本，提升了进口公司利润率。&quot;); &#125; else if (number&lt;0) &#123; System.out.println(&quot;人民币汇率贬值&quot;+(-number)+&quot;个基点，提升了进口产品成本，降低了进口公司利润率。&quot;); &#125; &#125; &#125; // 具体观察者2：出口公司class ExportCompany implements Company &#123; public void response(int number) &#123; if (number&gt;0) &#123; System.out.println(&quot;人民币汇率升值&quot;+number+&quot;个基点，降低了出口产品收入，降低了出口公司的销售利润率。&quot;); &#125; else if(number&lt;0) &#123; System.out.println(&quot;人民币汇率贬值&quot;+(-number)+&quot;个基点，提升了出口产品收入，提升了出口公司的销售利润率。&quot;); &#125; &#125; &#125; 程序运行结果如下：1234人民币汇率升值10个基点，降低了进口产品成本，提升了进口公司利润率。人民币汇率升值10个基点，降低了出口产品收入，降低了出口公司的销售利润率。人民币汇率贬值9个基点，提升了进口产品成本，降低了进口公司利润率。人民币汇率贬值9个基点，提升了出口产品收入，提升了出口公司的销售利润率。 ANDROID 源码中的实现 ListView 是 ANDROID 中最重要的控件之一，而 ListView 最重要的一个功能就是 Adapter。当我们往 ListView 添加数据后，都会调用 Adapter 的 notifyDataSetChanged() 方法，通知界面刷新。这是一个典型的观察者模式案例。我们追踪 notifyDataSetChanged() 这个方法，它定义在 BaseAdapter 中，具体代码如下。123456789101112131415161718192021public abstract class BaseAdapter implements ListAdapter, SpinnerAdapter &#123; // 数据集（被观察者） private final DataSetObservable mDataSetObservable = new DataSetObservable(); // 代码省略 public void registerDataSetObserver(DataSetObserver observer) &#123; mDataSetObservable.registerObserver(observer); &#125; public void unregisterDataSetObserver(DataSetObserver observer) &#123; mDataSetObservable.unregisterObserver(observer); &#125; /** * 当数据集变化时，通知所有观察者 */ public void notifyDataSetChanged() &#123; mDataSetObservable.notifyChanged(); &#125;&#125; 追踪 mDataSetObservable.notifyChanged() 函数。1234567891011121314/** * 数据集被观察者 */public class DataSetObservable extends Observable&lt;DataSetObserver&gt; &#123; // 调用每个观察者的 onChange 函数来通知它们被观察者发生了变化 public void notifyChanged() &#123; synchronized (mObservers) &#123; for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123; mObservers.get(i).onChanged(); &#125; &#125; &#125; // 代码省略&#125; 而这些观察者是 ListView 通过 setAdapter 方法产生的。1234567891011121314151617181920212223242526272829@Overridepublic void setAdapter(ListAdapter adapter) &#123; // 如果已经有了一个 Adapter，那么先注销该 Adapter 对应的观察者 if (mAdapter != null &amp;&amp; mDataSetObserver != null) &#123; mAdapter.unregisterDataSetObserver(mDataSetObserver); &#125; // 代码省略 super.setAdapter(adapter); if (mAdapter != null) &#123; mAreAllItemsSelectable = mAdapter.areAllItemsEnabled(); mOldItemCount = mItemCount; // 获取数据的数量 mItemCount = mAdapter.getCount(); checkFocus(); // 注意这里：创建一个数据集观察者 mDataSetObserver = new AdapterDataSetObserver(); // 将这个观察者注册到 Adapter 中，实际上是注册到 DataSetObservable 中 mAdapter.registerDataSetObserver(mDataSetObserver); // 代码省略 &#125; else &#123; // 代码省略 &#125; requestLayout();&#125; 观察者 AdapterDataSetObserver 定义在 ListView 的父类 AbsListView 中，具体代码如下。12345678910111213141516171819202122232425public abstract class AbsListView extends AdapterView&lt;ListAdapter&gt; implements TextWatcher, ViewTreeObserver.OnGlobalLayoutListener, Filter.FilterListener, ViewTreeObserver.OnTouchModeChangeListener, RemoteViewsAdapter.RemoteAdapterConnectionCallback &#123; // 代码省略 class AdapterDataSetObserver extends AdapterView&lt;ListAdapter&gt;.AdapterDataSetObserver &#123; @Override public void onChanged() &#123; super.onChanged(); if (mFastScroll != null) &#123; mFastScroll.onSectionsChanged(); &#125; &#125; @Override public void onInvalidated() &#123; super.onInvalidated(); if (mFastScroll != null) &#123; mFastScroll.onSectionsChanged(); &#125; &#125; &#125;&#125; 通过 super.onChanged() 继续跟踪。1234567891011121314151617181920212223242526272829303132333435public abstract class AdapterView&lt;T extends Adapter&gt; extends ViewGroup &#123; // 代码省略 class AdapterDataSetObserver extends DataSetObserver &#123; private Parcelable mInstanceState = null; @Override public void onChanged() &#123; mDataChanged = true; mOldItemCount = mItemCount; mItemCount = getAdapter().getCount(); // Detect the case where a cursor that was previously invalidated has // been repopulated with new data. if (AdapterView.this.getAdapter().hasStableIds() &amp;&amp; mInstanceState != null &amp;&amp; mOldItemCount == 0 &amp;&amp; mItemCount &gt; 0) &#123; AdapterView.this.onRestoreInstanceState(mInstanceState); mInstanceState = null; &#125; else &#123; rememberSyncState(); &#125; checkFocus(); // 重新布局 ListView、GridView 等 AdapterView 组件 requestLayout(); &#125; // 代码省略 public void clearSavedState() &#123; mInstanceState = null; &#125; &#125;&#125; 到这里我们就知道了，当 ListView 的数据发生变化时，调用 Adapter 的 notifyDataSetChanged 函数，这个函数又会调用 DataSetObservable 的 notifyChanged 函数，这个函数会调用所有观察者（AdapterDataSetObserver）的 onChanged 方法，在 onChanged 函数中又会调用 ListView 重新布局的函数使得 ListView 刷新界面。这就是一个观察者模式！ 实战 利用观察者模式设计一个学校铃声的事件处理程序。 分析：在本实例中，学校的“铃”是事件源和目标，“老师”和“学生”是事件监听器和具体观察者，“铃声”是事件类。学生和老师来到学校的教学区，都会注意学校的铃，这叫事件绑定；当上课时间或下课时间到，会触发铃发声，这时会生成“铃声”事件；学生和老师听到铃声会开始上课或下课，这叫事件处理。这个实例非常适合用观察者模式实现，下图给出了学校铃声的事件模型。 现在用“观察者模式”来实现该事件处理模型。首先，定义一个铃声事件（RingEvent）类，它记录了铃声的类型（上课铃声/下课铃声）；再定义一个学校的铃（BellEventSource）类，它是事件源，是观察者目标类，该类里面包含了监听器容器 listener，可以绑定监听者（学生或老师），并且有产生铃声事件和通知所有监听者的方法；然后，定义一声事件监听者（BellEventListener）类，它是抽象观察者，它包含了铃声事件处理方法 heardBell(RingEvent e)；最后，定义老师类（TeachEventListener）和学生类（StuEventListener），它们是事件监听器，是具体观察者，听到铃声会去上课或下课。下图给出了学校铃声事件处理程序的结构。 程序代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class BellEventTest &#123; public static void main(String[] args) &#123; BellEventSource bell = new BellEventSource(); // 铃（事件源） bell.addPersonListener(new TeachEventListener()); // 注册监听器（老师） bell.addPersonListener(new StudentEventListener()); // 注册监听器（学生） bell.ring(true); // 打上课铃声 System.out.println(&quot;------------&quot;); bell.ring(false); // 打下课铃声 &#125;&#125;// 铃声事件类：用于封装事件源及一些与事件相关的参数class RingEvent extends EventObject &#123; private static final long serialVersionUID = 1L; private boolean sound; // true 表示上课铃声，false 表示下课铃声 public RingEvent(Object source,boolean sound) &#123; super(source); this.sound=sound; &#125; public void setSound(boolean sound) &#123; this.sound=sound; &#125; public boolean getSound() &#123; return this.sound; &#125;&#125;// 目标类：事件源，铃class BellEventSource &#123; private List&lt;BellEventListener&gt; listener; // 监听器容器 public BellEventSource() &#123; listener = new ArrayList&lt;BellEventListener&gt;(); &#125; // 给事件源绑定监听器 public void addPersonListener(BellEventListener ren) &#123; listener.add(ren); &#125; // 事件触发器：敲钟，当铃声 sound 的值发生变化时，触发事件。 public void ring(boolean sound) &#123; String type = sound? &quot;上课铃&quot; : &quot;下课铃&quot;; System.out.println(type+&quot;响！&quot;); RingEvent event = new RingEvent(this, sound); notifies(event); // 通知注册在该事件源上的所有监听器 &#125; // 当事件发生时,通知绑定在该事件源上的所有监听器做出反应（调用事件处理方法） protected void notifies(RingEvent e) &#123; BellEventListener person; Iterator&lt;BellEventListener&gt; iterator = listener.iterator(); while(iterator.hasNext()) &#123; person = iterator.next(); person.heardBell(e); &#125; &#125;&#125;// 抽象观察者类：铃声事件监听器interface BellEventListener extends EventListener &#123; // 事件处理方法，听到铃声 void heardBell(RingEvent e);&#125;//具体观察者类：老师事件监听器class TeachEventListener implements BellEventListener &#123; public void heardBell(RingEvent e) &#123; if (e.getSound()) &#123; System.out.println(&quot;老师上课了...&quot;); &#125; else &#123; System.out.println(&quot;老师下课了...&quot;); &#125; &#125;&#125;// 具体观察者类：学生事件监听器class StudentEventListener implements BellEventListener &#123; public void heardBell(RingEvent e) &#123; if (e.getSound()) &#123; System.out.println(&quot;同学们，上课了...&quot;); &#125; else &#123; System.out.println(&quot;同学们，下课了...&quot;); &#125; &#125;&#125; 程序运行结果如下：1234567上课铃响！老师上课了...同学们，上课了...------------下课铃响！老师下课了...同学们，下课了...]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10 设计模式——命令模式]]></title>
    <url>%2F2019%2F08%2F16%2FPATTERN%2F10%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 命令（Command）模式：将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。 在软件开发系统中，常常出现“方法的请求者”与“方法的实现者”之间存在紧密的耦合关系。这不利于软件功能的扩展与维护。例如，想对行为进行“撤销、重做、记录”等处理都很不方便，因此“如何将方法的请求者与方法的实现者解耦？”变得很重要，命令模式能很好地解决这个问题。 在现实生活中，这样的例子也很多，例如，电视机遥控器（命令发送者）通过按钮（具体命令）来遥控电视机（命令接收者），还有计算机键盘上的“功能键”等。 使用场景对于大多数请求——响应模式的功能，比较适合使用命令模式。 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。 系统需要在不同的时间指定请求、将请求排队（如：线程池+工作队列）和执行请求。 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作（比如系统挂掉之后重启做一些恢复操作，还有数据库的事务等）。 系统需要将一组操作组合在一起，即支持宏命令。 优点 降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。 增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。 可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。 方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。 缺点可能产生大量具体命令类。因为计对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。 结构与实现 命令模式包含以下主要角色。 抽象命令类（Command）：声明执行命令的接口，拥有执行命令的抽象方法 execute()。 具体命令角色（Concrete Command）：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。 实现者/接收者（Receiver）：执行命令功能的相关操作，是具体命令对象业务的真正实现者。 调用者/请求者（Invoker）：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。 其结构图如下图所示。 命令模式的代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class CommandPattern &#123; public static void main(String[] args) &#123; Receiver receiver = new Receiver(); Command cmd = new ConcreteCommand(receiver); Invoker invoker = new Invoker(cmd); invoker.call(); &#125;&#125;// 调用者class Invoker &#123; private Command command; public Invoker(Command command) &#123; this.command=command; &#125; public void setCommand(Command command) &#123; this.command=command; &#125; public void call() &#123; // 调用具体命令对象的相关方法，执行具体命令 command.execute(); &#125;&#125;// 抽象命令interface Command &#123; void execute();&#125;// 具体命令class ConcreteCommand implements Command &#123; private Receiver receiver; ConcreteCommand(Receiver receiver) &#123; this.receiver = receiver; &#125; public void execute() &#123; receiver.action(); &#125;&#125;// 接收者class Receiver &#123; // 真正执行具体命令逻辑的方法 public void action() &#123; System.out.println(&quot;接收者执行具体操作&quot;); &#125;&#125; 示例 用命令模式实现客户去餐馆吃早餐的实例。 分析：客户去餐馆可选择的早餐有肠粉、河粉和馄饨等，客户可向服务员选择以上早餐中的若干种，服务员将客户的请求交给相关的厨师去做。这里的点早餐相当于“命令”，服务员相当于“调用者”，厨师相当于“接收者”，所以用命令模式实现比较合适。 首先，定义一个早餐类（Breakfast），它是抽象命令类，有抽象方法 cooking()，说明要做什么；再定义其子类肠粉类（ChangFen）、馄饨类（HunTun）和河粉类（HeFen），它们是具体命令类，实现早餐类的 cooking() 方法，但它们不会具体做，而是交给具体的厨师去做；具体厨师类有肠粉厨师（ChangFenChef）、馄蚀厨师（HunTunChef）和河粉厨师（HeFenChef），他们是命令的接收者，所以把每个厨师类定义为 JFrame 的子类；最后，定义服务员类（Waiter），它接收客户的做菜请求，并发出做菜的命令。客户类是通过服务员类来点菜的，下图所示是其结构图。 程序代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129public class CookingCommand &#123; public static void main(String[] args) &#123; Breakfast food1 = new ChangFen(); Breakfast food2 = new HunTun(); Breakfast food3 = new HeFen(); Waiter waiter = new Waiter(); waiter.setChangFen(food1);//设置肠粉菜单 waiter.setHunTun(food2); //设置河粉菜单 waiter.setHeFen(food3); //设置馄饨菜单 waiter.chooseChangFen(); //选择肠粉 waiter.chooseHeFen(); //选择河粉 waiter.chooseHunTun(); //选择馄饨 &#125;&#125;// 调用者：服务员class Waiter &#123; private Breakfast changFen, hunTun, heFen; public void setChangFen(Breakfast f) &#123; changFen = f; &#125; public void setHunTun(Breakfast f) &#123; hunTun=f; &#125; public void setHeFen(Breakfast f) &#123; heFen=f; &#125; public void chooseChangFen() &#123; changFen.cooking(); &#125; public void chooseHunTun() &#123; hunTun.cooking(); &#125; public void chooseHeFen() &#123; heFen.cooking(); &#125;&#125;// 抽象命令：早餐interface Breakfast &#123; void cooking();&#125;// 具体命令：肠粉class ChangFen implements Breakfast &#123; private ChangFenChef receiver; ChangFen() &#123; receiver = new ChangFenChef(); &#125; public void cooking() &#123; receiver.cooking(); &#125;&#125;// 具体命令：馄饨class HunTun implements Breakfast &#123; private HunTunChef receiver; HunTun() &#123; receiver=new HunTunChef(); &#125; public void cooking() &#123; receiver.cooking(); &#125;&#125;// 具体命令：河粉class HeFen implements Breakfast &#123; private HeFenChef receiver; HeFen() &#123; receiver=new HeFenChef(); &#125; public void cooking() &#123; receiver.cooking(); &#125;&#125;// 接收者：肠粉厨师class ChangFenChef extends JFrame &#123; private static final long serialVersionUID = 1L; JLabel l = new JLabel(); ChangFenChef() &#123; super(&quot;煮肠粉&quot;); l.setIcon(new ImageIcon(&quot;src/command/ChangFen.jpg&quot;)); this.add(l); this.setLocation(30, 30); this.pack(); this.setResizable(false); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; public void cooking() &#123; this.setVisible(true); &#125;&#125;// 接收者：馄饨厨师class HunTunChef extends JFrame &#123; private static final long serialVersionUID=1L; JLabel l = new JLabel(); HunTunChef() &#123; super(&quot;煮馄饨&quot;); l.setIcon(new ImageIcon(&quot;src/command/HunTun.jpg&quot;)); this.add(l); this.setLocation(350, 50); this.pack(); this.setResizable(false); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; public void cooking() &#123; this.setVisible(true); &#125;&#125;// 接收者：河粉厨师class HeFenChef extends JFrame &#123; private static final long serialVersionUID=1L; JLabel l = new JLabel(); HeFenChef() &#123; super(&quot;煮河粉&quot;); l.setIcon(new ImageIcon(&quot;src/command/HeFen.jpg&quot;)); this.add(l); this.setLocation(200, 280); this.pack(); this.setResizable(false); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; public void cooking() &#123; this.setVisible(true); &#125;&#125; 实战 命令模式在 GUI 上应用广泛，比如手写签名功能，需要提供撤销或重做等功能。 首先声明一个抽象接口 IBrush，用它定义不同笔触需要实现的方法。 1234567891011121314151617181920212223public interface IBrush &#123; /** * 触点接触时 * @param path 路径对象 * @param x 当前位置的 x 坐标 * @param y 当前位置的 y 坐标 */ void down(Path path, float x, float y); /** * 触点移动时 * @param path 路径对象 * @param x 当前位置的 x 坐标 * @param y 当前位置的 y 坐标 */ void move(Path path, float x, float y); /** * 触点离开时 * @param path 路径对象 * @param x 当前位置的 x 坐标 * @param y 当前位置的 y 坐标 */ void up(Path path, float x, float y);&#125; 为了简便起见，这里只定义两种类型的笔触，一种为普通的线条，另一种为由圆点组成的线条轨迹。 1234567891011121314151617181920212223242526272829303132// 普通笔触public class NormalBrush implements IBrush &#123; @Override public void down(Path path, float x, float y) &#123; path.moveTo(x, y); &#125; @Override public void move(Path path, float x, float y) &#123; path.lineTo(x, y); &#125; @Override public void up(Path path, float x, float y) &#123; &#125;&#125;// 圆形笔触public class CircleBrush implements IBrush &#123; @Override public void down(Path path, float x, float y) &#123; &#125; @Override public void move(Path path, float x, float y) &#123; path.addCircle(x, y, 10, Path.Direction.CCW); &#125; @Override public void up(Path path, float x, float y) &#123; &#125;&#125; 对于每一次路径的绘制，都可以有两个命令，一个是绘制命令，另一个是撤销命令，我们将其封装为一个命令接口。注意，这里结合命令模式去构思。 1234567891011public interface IDraw &#123; /** * 绘制命令 * @param canvas 画布对象 */ void draw(Canvas canvas); /** * 撤销命令 */ void undo();&#125; 这里只有一种绘制路径方法，即一个具体命令。 12345678910111213public class DrawPath implements IDraw &#123; public Path path; // 需要绘制的路径 public Paint paint; // 绘制画笔 @Override public void draw(Canvas canvas) &#123; canvas.drawPath(path, paint); &#125; @Override public void undo() &#123; &#125;&#125; 需要一个请求者角色（Invoker）来对命令做进一步封装。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class DrawInvoker &#123; // 绘制列表 private List&lt;DrawPath&gt; drawList = Collections.synchronizedList(new ArrayList&lt;DrawPath&gt;()); // 重做列表 private List&lt;DrawPath&gt; redoList = Collections.synchronizedList(new ArrayList&lt;DrawPath&gt;()); /** * 增加一个命令 * @param command DrawPath */ public void add(DrawPath command) &#123; redoList.clear(); drawList.add(command); &#125; /** * 撤销上一步命令 */ public void undo() &#123; if (drawList.size() &gt; 0) &#123; int index = drawList.size() - 1; DrawPath undo = drawList.get(index); drawList.remove(index); undo.undo(); redoList.add(undo); &#125; &#125; /** * 重做上一步撤销的命令 */ public void redo() &#123; if (redoList.size() &gt; 0) &#123; int index = redoList.size() - 1; DrawPath redoCommand = redoList.get(index); redoList.remove(index); drawList.add(redoCommand); &#125; &#125; /** * 执行命令 */ public void execute(Canvas canvas) &#123; if (drawList != null) &#123; for (DrawPath tmp : drawList) &#123; tmp.draw(canvas); &#125; &#125; &#125; /** * 是否可以重做 */ public boolean canRedo() &#123; return redoList.size() &gt; 0; &#125; /** * 是否可以撤销 */ public boolean canUndo() &#123; return drawList.size() &gt; 0; &#125;&#125; 需要一个具体的接收者，这里承担重任的是一个 SurfaceView 对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public class DrawCanvas extends SurfaceView implements SurfaceHolder.Callback &#123; // 标识是否可以绘制、绘制线程是否可以运行 public boolean isDrawing, isRunning; private Bitmap mBitmap; // 绘制到的位图对象 private DrawInvoker mInvoker; // 绘制命令请求对象 private DrawThread mThread; // 绘制线程 public DrawCanvas(Context context, AttributeSet attrs) &#123; super(context, attrs); mInvoker = new DrawInvoker(); mThread = new DrawThread(); getHolder().addCallback(this); &#125; @Override public void surfaceCreated(SurfaceHolder holder) &#123; isRunning = true; mThread.start(); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; mBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.RGB_565); &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; boolean retry = true; isRunning = false; while (retry) &#123; try &#123; mThread.join(); retry = false; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 增加一条绘制路径 * @param path DrawPath */ public void add(DrawPath path) &#123; mInvoker.add(path); &#125; /** * 撤销上一步的绘制 */ public void undo() &#123; isDrawing = true; mInvoker.undo(); &#125; /** * 重做上一步撤销的绘制 */ public void redo() &#123; isDrawing = true; mInvoker.redo(); &#125; /** * 是否可以重做 */ public boolean canRedo() &#123; return mInvoker.canRedo(); &#125; /** * 是否可以撤销 */ public boolean canUndo() &#123; return mInvoker.canUndo(); &#125; private class DrawThread extends Thread &#123; @Override public void run() &#123; Canvas canvas = null; while (isRunning) &#123; if (isDrawing) &#123; try &#123; canvas = getHolder().lockCanvas(); if (mBitmap == null) &#123; mBitmap = Bitmap.createBitmap(1, 1, Bitmap.Config.ARGB_8888); &#125; Canvas c = new Canvas(mBitmap); c.drawColor(0, PorterDuff.Mode.CLEAR); canvas.drawColor(0, PorterDuff.Mode.CLEAR); mInvoker.execute(c); canvas.drawBitmap(mBitmap, 0, 0, null); &#125; finally &#123; getHolder().unlockCanvasAndPost(canvas); &#125; isDrawing = false; &#125; &#125; &#125; &#125;&#125; 最后在 Activity 中整合各个功能模块。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.xxt.xtest;import android.graphics.Paint;import android.graphics.Path;import android.os.Bundle;import android.view.MotionEvent;import android.view.View;import android.widget.Button;import com.xxt.xtest.demo.CircleBrush;import com.xxt.xtest.demo.DrawCanvas;import com.xxt.xtest.demo.DrawPath;import com.xxt.xtest.demo.IBrush;import com.xxt.xtest.demo.NormalBrush;public class TestActivity extends BaseActivity &#123; private DrawCanvas mCanvas; // 绘制画布 private DrawPath mPath; // 路径绘制命令 private Paint mPaint; // 画笔对象 private IBrush mBrush; // 笔触对象 private Button btnRedo, btnUndo; // 重做、撤销按钮 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_test); mPaint = new Paint(); mPaint.setColor(0xFFFFFFFF); mPaint.setStrokeWidth(3); mBrush = new NormalBrush(); mCanvas = findViewById(R.id.draw_canvas); mCanvas.setOnTouchListener(new DrawTouchListener()); btnRedo = findViewById(R.id.redo_btn); btnRedo.setEnabled(false); btnUndo = findViewById(R.id.undo_btn); btnUndo.setEnabled(false); &#125; public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.red_btn: mPaint = new Paint(); mPaint.setStrokeWidth(3); mPaint.setColor(0xFFFF0000); break; case R.id.green_btn: mPaint = new Paint(); mPaint.setStrokeWidth(3); mPaint.setColor(0xFF00FF00); break; case R.id.blue_btn: mPaint = new Paint(); mPaint.setStrokeWidth(3); mPaint.setColor(0xFF0000FF); break; case R.id.normal_brush_btn: mBrush = new NormalBrush(); break; case R.id.circle_brush_btn: mBrush = new CircleBrush(); break; case R.id.undo_btn: mCanvas.undo(); if (!mCanvas.canUndo()) &#123; btnUndo.setEnabled(false); &#125; btnRedo.setEnabled(true); break; case R.id.redo_btn: mCanvas.redo(); if (!mCanvas.canRedo()) &#123; btnRedo.setEnabled(false); &#125; btnUndo.setEnabled(true); break; &#125; &#125; private class DrawTouchListener implements View.OnTouchListener &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; if (MotionEvent.ACTION_DOWN == event.getAction()) &#123; mPath = new DrawPath(); mPath.paint = mPaint; mPath.path = new Path(); mBrush.down(mPath.path, event.getX(), event.getY()); &#125; else if (MotionEvent.ACTION_MOVE == event.getAction()) &#123; mBrush.move(mPath.path, event.getX(), event.getY()); &#125; else if (MotionEvent.ACTION_UP == event.getAction()) &#123; mBrush.up(mPath.path, event.getX(), event.getY()); mCanvas.add(mPath); mCanvas.isDrawing = true; btnUndo.setEnabled(true); btnRedo.setEnabled(false); &#125; return true; &#125; &#125;&#125; res/layout/act_test.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;com.xxt.xtest.demo.DrawCanvas android:id=&quot;@+id/draw_canvas&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot;/&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:id=&quot;@+id/red_btn&quot; android:layout_width=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;onClick&quot; android:textColor=&quot;#FF0000&quot; android:text=&quot;红色&quot; /&gt; &lt;Button android:id=&quot;@+id/green_btn&quot; android:layout_width=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;onClick&quot; android:textColor=&quot;#00FF00&quot; android:text=&quot;绿色&quot; /&gt; &lt;Button android:id=&quot;@+id/blue_btn&quot; android:layout_width=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;onClick&quot; android:textColor=&quot;#0000FF&quot; android:text=&quot;蓝色&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:id=&quot;@+id/normal_brush_btn&quot; android:layout_width=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;onClick&quot; android:text=&quot;普通笔刷&quot; /&gt; &lt;Button android:id=&quot;@+id/circle_brush_btn&quot; android:layout_width=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;onClick&quot; android:text=&quot;圆形笔刷&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:id=&quot;@+id/undo_btn&quot; android:layout_width=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;onClick&quot; android:text=&quot;撤销&quot; /&gt; &lt;Button android:id=&quot;@+id/redo_btn&quot; android:layout_width=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;onClick&quot; android:text=&quot;重做&quot; /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 效果图如下]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[09 设计模式——解释器模式]]></title>
    <url>%2F2019%2F08%2F15%2FPATTERN%2F09%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考链接：设计模式 | 解释器模式及典型应用解释器模式（详解版） 介绍 解释器（Interpreter）模式：给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。 使用场景在软件开发中，会遇到有些问题多次重复出现，而且有一定的相似性和规律性。如果将它们归纳成一种简单的语言，那么这些问题实例将是该语言的一些句子，这样就可以用“编译原理”中的解释器模式来实现了。 虽然使用解释器模式的实例不是很多，但对于满足以上特点，且对运行效率要求不是很高的应用实例，如果用解释器模式来实现，其效果是非常好的。比如正则表达式、XML文档解释等领域。 优点 扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。 容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。 缺点 执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。 会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。 可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。 模式的结构与实现 文法、句子、语法树解释器模式常用于对简单语言的编译或分析实例中，为了掌握好它的结构与实现，必须先了解编译原理中的“文法、句子、语法树”等相关概念。 文法文法是用于描述语言的语法结构的形式规则。没有规矩不成方圆，例如，有些人认为完美爱情的准则是“相互吸引、感情专一、任何一方都没有恋爱经历”，虽然最后一条准则较苛刻，但任何事情都要有规则，语言也一样，不管它是机器语言还是自然语言，都有它自己的文法规则。例如，中文中的“句子”的文法如下。123456〈主语〉::=〈代词〉|〈名词〉〈谓语〉::=〈动词〉〈宾语〉::=〈代词〉|〈名词〉〈代词〉你|我|他〈名词〉7大学生I筱霞I英语〈动词〉::=是|学习 这里的符号“::=”表示“定义为”的意思，用“〈”和“〉”括住的是非终结符，没有括住的是终结符。 句子句子是语言的基本单位，是语言集中的一个元素，它由终结符构成，能由“文法”推导出。例如，上述文法可以推出“我是大学生”，所以它是句子。 语法树语法树是句子结构的一种树型表示，它代表了句子的推导结果，它有利于理解句子语法结构的层次。下图所示是“我是大学生”的语法树。 模式的结构解释器模式包含以下主要角色。 抽象表达式（Abstract Expression）：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。 终结符表达式（Terminal Expression）：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。 非终结符表达式（Nonterminal Expression）：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。 环境（Context）：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。 客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。 模式的实现解释器模式实现的关键是定义文法规则、设计终结符类与非终结符类、画出结构图，必要时构建语法树，其代码结构如下：1234567891011121314151617181920212223242526272829// 抽象表达式类interface AbstractExpression &#123; public Object interpret(String info); // 解释方法&#125;// 终结符表达式类class TerminalExpression implements AbstractExpression &#123; public Object interpret(String info) &#123; // 对终结符表达式的处理 &#125;&#125;// 非终结符表达式类class NonterminalExpression implements AbstractExpression &#123; private AbstractExpression exp1; private AbstractExpression exp2; public Object interpret(String info) &#123; // 非对终结符表达式的处理 &#125;&#125;// 环境类class Context &#123; private AbstractExpression exp; public Context() &#123; // 数据初始化 &#125; public void operation(String info) &#123; // 调用相关表达式类的解释方法 &#125;&#125; 示例 需求：比如算数表达式 m + n + p。代表数字的m、n、p三个字符看成终结符号，+ 看做非终结符号。 1、抽象的算术运算解释器，为所有解释器共性的提取。12345678public abstract class ArithmeticExpression &#123; /** * 抽象的解析方法 * 具体的解析逻辑由具体的子类实现 * @return 解析得到具体的值 */ public abstract int interpret();&#125; 2、数字解释器，仅仅为了解释数字123456789101112public class NumExpression extends ArithmeticExpression &#123; private int num; public NumExpression(int num) &#123; this.num = num; &#125; @Override public int interpret() &#123; return num; &#125;&#125; 3、运算符号抽象解释器，为所有运算符号解释器共性的提取123456789public abstract class OperatorExpression extends ArithmeticExpression &#123; // 声明两个成员变量存储运算符号两边的数字解释器 protected ArithmeticExpression exp1, exp2; public OperatorExpression(ArithmeticExpression exp1, ArithmeticExpression exp2) &#123; this.exp1 = exp1; this.exp2 = exp2; &#125;&#125; 4、加法运算抽象解释器12345678910public class AdditionExpression extends OperatorExpression &#123; public AdditionExpression(ArithmeticExpression exp1, ArithmeticExpression exp2) &#123; super(exp1, exp2); &#125; @Override public int interpret() &#123; return exp1.interpret() + exp2.interpret(); &#125;&#125; 5、处理与解释相关的一些业务12345678910111213141516171819202122232425262728293031323334public class Calculator &#123; // 声明一个 Stack 栈存储并操作所有相关的解释器 private Stack&lt;ArithmeticExpression&gt; mExpStack = new Stack&lt;&gt;(); public Calculator(String expression) &#123; // 声明两个 TerminalExpression 类型的临时变量，存储运算符左右两边的数字解释器 ArithmeticExpression exp1, exp2; String[] elements = expression.split(&quot; &quot;); // 循环遍历表达式元素数组 for (int i = 0; i &lt; elements.length; i++) &#123; // 判断运算符号 switch (elements[i].charAt(0)) &#123; case &apos;+&apos;: // 如果是加号 // 将栈中的解释器弹出作为运算符号右边的解释器 exp1 = mExpStack.pop(); // 同时将运算符号数组下标下一个元素构造为一个数字解释器 exp2 = new NumExpression(Integer.valueOf(elements[++i])); // 通过尚明两个数字解释器构造加法运算解释器 mExpStack.push(new AdditionExpression(exp1, exp2)); break; default: // 如果是数字 // 直接构造数字解释器并压入栈 mExpStack.push(new NumExpression(Integer.valueOf(elements[i]))); break; &#125; &#125; &#125; public int calculate() &#123; return mExpStack.pop().interpret(); &#125;&#125; 6、客户类123456public class Client &#123; public static void main(String[] args) &#123; Calculator calculator = new Calculator(&quot;1 + 2 + 3 + 10&quot;); System.out.println(calculator.calculate()); &#125;&#125; 此时只是定义了加法运算，如果需要增加减法运算，则可以在 Calculator 中增加以下分支。12345case &apos;-&apos;: //如果是减号 exp1 = mExpStack.pop(); exp2 = new NumExpression(Integer.valueOf(elements[++i])); mExpStack.push(new SubtractionExpression(exp1, exp2)); break; 此时，在 Client 中就可以开始使用了。123456public class Client &#123; public static void main(String[] args) &#123; Calculator calculator = new Calculator(&quot;1 - 2 - 3 + 10&quot;); System.out.println(calculator.calculate()); &#125;&#125; ANDROID 源码中的实现 AndroidManifest.xml 配置文件的读取。源代码追踪关键词：PackageParser 类的 parseSplitApk()、parseSplitApplication() 方法。 实战 用解释器模式设计一个“韶粵通”公交车卡的读卡器程序。 说明：假如“韶粵通”公交车读卡器可以判断乘客的身份，如果是“韶关”或者“广州”的“老人” “妇女”“儿童”就可以免费乘车，其他人员乘车一次扣 2 元。 分析：本实例用“解释器模式”设计比较适合，首先设计其文法规则如下。123&lt;expression&gt; ::= &lt;city&gt;的&lt;person&gt;&lt;city&gt; ::= 韶关|广州&lt;person&gt; ::= 老人|妇女|儿童 然后，根据文法规则按以下步骤设计公交车卡的读卡器程序的类图。 程序代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*文法规则 &lt;expression&gt; ::= &lt;city&gt;的&lt;person&gt; &lt;city&gt; ::= 韶关|广州 &lt;person&gt; ::= 老人|妇女|儿童*/public class InterpreterPatternDemo &#123; public static void main(String[] args) &#123; Context bus = new Context(); bus.freeRide(&quot;韶关的老人&quot;); bus.freeRide(&quot;韶关的年轻人&quot;); bus.freeRide(&quot;广州的妇女&quot;); bus.freeRide(&quot;广州的儿童&quot;); bus.freeRide(&quot;山东的儿童&quot;); &#125;&#125;// 抽象表达式类interface Expression &#123; public boolean interpret(String info);&#125;// 终结符表达式类class TerminalExpression implements Expression &#123; private Set&lt;String&gt; set = new HashSet&lt;String&gt;(); public TerminalExpression(String[] data) &#123; for(int i=0; i&lt;data.length; i++) set.add(data[i]); &#125; public boolean interpret(String info) &#123; if (set.contains(info)) &#123; return true; &#125; return false; &#125;&#125;// 非终结符表达式类class AndExpression implements Expression &#123; private Expression city; private Expression person; public AndExpression(Expression city,Expression person) &#123; this.city=city; this.person=person; &#125; public boolean interpret(String info) &#123; String s[] = info.split(&quot;的&quot;); return city.interpret(s[0]) &amp;&amp; person.interpret(s[1]); &#125;&#125;// 环境类class Context &#123; private String[] cities = &#123;&quot;韶关&quot;,&quot;广州&quot;&#125;; private String[] persons = &#123;&quot;老人&quot;,&quot;妇女&quot;,&quot;儿童&quot;&#125;; private Expression cityPerson; public Context() &#123; Expression city = new TerminalExpression(cities); Expression person = new TerminalExpression(persons); cityPerson = new AndExpression(city,person); &#125; public void freeRide(String info) &#123; boolean ok = cityPerson.interpret(info); if (ok) System.out.println(&quot;您是&quot;+info+&quot;，您本次乘车免费！&quot;); else System.out.println(info+&quot;，您不是免费人员，本次乘车扣费2元！&quot;); &#125;&#125; 程序运行结果如下：12345您是韶关的老人，您本次乘车免费！韶关的年轻人，您不是免费人员，本次乘车扣费2元！您是广州的妇女，您本次乘车免费！您是广州的儿童，您本次乘车免费！山东的儿童，您不是免费人员，本次乘车扣费2元！ 数学公式解析器在项目开发中，如果要对数据表达式进行分析与计算，无须再用解释器模式进行设计了，Java 提供了以下强大的数学公式解析器：Expression4J、MESP(Math Expression String Parser) 和 Jep 等，它们可以解释一些复杂的文法，功能强大，使用简单。1234567891011121314public class JepDemo &#123; public static void main(String[] args) throws JepException &#123; Jep jep = new Jep(); // 定义要计算的数据表达式 String 存款利息 = &quot;本金*利率*时间&quot;; // 给相关变量赋值 jep.addVariable(&quot;本金&quot;,10000); jep.addVariable(&quot;利率&quot;,0.038); jep.addVariable(&quot;时间&quot;,2); jep.parse(存款利息); // 解析表达式 Object accrual=jep.evaluate(); // 计算 System.out.println(&quot;存款利息：&quot; + accrual); &#125;&#125; 程序运行结果如下：1存款利息：760.0]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[08 设计模式——责任链模式]]></title>
    <url>%2F2019%2F08%2F14%2FPATTERN%2F08%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 责任链模式：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连城一条链，并沿着这条链传递该请求，直到有对象处理它为止。 它是行为型设计模式之一。我们将多个节点首尾相连构成的模型称为链，而每个节点都可以拆开再连接。因此，链式结构具有很好的灵活性。将这样一种结构应用于编程领域，将每一个节点看作是一个对象，每一个对象拥有不同的处理逻辑，将一个请求从链式的首端发出，沿着链的路径依次传递给每一个节点对象，直至有对象处理这个请求为止。我们将这样的一种模式称为责任链模式。 使用场景多个对象可以处理同一请求，但具体由哪个对象处理则在运行时动态决定。在请求处理者不明确的情况下向多个对象中的一个提交一个请求。需要动态指定一组对象处理请求。 优缺点优点：对请求者和处理者关系解耦，提高代码的灵活性。缺点：如果处理者太多，那么遍历必定会影响性能。 UML 关系图简化版 UML 类图 根据类图我们可以得出如下简化版的通用模板代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445// 抽象处理者abstract class Handler &#123; protected Handler successor; // 下一个节点的处理者 /** * 请求处理 * @param condition 请求条件 */ public abstract void handleRequest(String condition);&#125;// 具体的处理者 1class ConcreteHandler1 extends Handler &#123; @Override public void handleRequest(String condition) &#123; if (&quot;ConcreteHandler1&quot;.equals(condition)) &#123; System.out.println(&quot;ConcreteHandler1 handled&quot;); &#125; else &#123; successor.handleRequest(condition); &#125; &#125;&#125;// 具体的处理者 2class ConcreteHandler2 extends Handler &#123; @Override public void handleRequest(String condition) &#123; if (&quot;ConcreteHandler2&quot;.equals(condition)) &#123; System.out.println(&quot;ConcreteHandler2 handled&quot;); &#125; else &#123; successor.handleRequest(condition); &#125; &#125;&#125;// 客户类public class Client &#123; public static void main(String[] args) &#123; ConcreteHandler1 handler1 = new ConcreteHandler1(); ConcreteHandler2 handler2 = new ConcreteHandler2(); handler1.successor = handler2; handler2.successor = handler1; handler1.handleRequest(&quot;ConcreteHandler2&quot;); &#125;&#125; 角色介绍： Handler：抽象处理者角色，声明一个请求处理的方法，并在其中保持一个对下一个处理节点 Handler 对象的引用。 ConcreteHandler：具体处理者角色，对请求进行处理，如果不能处理则将该请求转发给下一个节点上的处理对象。 完整版 UML 类图上面的请求形式为固定的字符串，处理规则为该字符串是否与之匹配。然而在大多数情况下，责任链中的请求和对应的处理规则是不尽相同的，在这种情况下可以将请求进行封装，同时对请求的处理规则也进行封装作为一个独立的对象。类图如下： 对应模板代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// 抽象处理者abstract class AbstractHandler &#123; protected AbstractHandler nextHandler; // 下一个节点上的处理者对象 /** * 处理请求 * @param request 请求对象 */ public final void handleRequest(AbstractRequest request) &#123; if (getHandlerLevel() == request.getRequestLevel()) &#123; // 一致则由该处理对象处理 handle(request); &#125; else &#123; // 否则将该请求转发给下一个节点上的请求对象 if (nextHandler != null) &#123; nextHandler.handleRequest(request); &#125; else &#123; System.out.println(&quot;All of handler can not handle the request&quot;); &#125; &#125; &#125; protected abstract int getHandlerLevel(); // 每个处理者对象的具体处理方式 protected abstract void handle(AbstractRequest request);&#125;// 抽象请求者abstract class AbstractRequest &#123; private Object obj; // 处理对象 public AbstractRequest(Object obj) &#123; this.obj = obj; &#125; public Object getContent() &#123; return obj; &#125; // 获取请求级别 public abstract int getRequestLevel();&#125;// 具体处理者class Handler1 extends AbstractHandler &#123; @Override protected int getHandlerLevel() &#123; return 1; &#125; @Override protected void handle(AbstractRequest request) &#123; System.out.println(&quot;Handler1 handle request: &quot; + request.getRequestLevel()); &#125;&#125;class Handler2 extends AbstractHandler &#123; @Override protected int getHandlerLevel() &#123; return 2; &#125; @Override protected void handle(AbstractRequest request) &#123; System.out.println(&quot;Handler2 handle request: &quot; + request.getRequestLevel()); &#125;&#125;class Handler3 extends AbstractHandler &#123; @Override protected int getHandlerLevel() &#123; return 3; &#125; @Override protected void handle(AbstractRequest request) &#123; System.out.println(&quot;Handler3 handle request: &quot; + request.getRequestLevel()); &#125;&#125;// 具体请求者class ConcreteRequest1 extends AbstractRequest &#123; public ConcreteRequest1(Object obj) &#123; super(obj); &#125; @Override public int getRequestLevel() &#123; return 1; &#125;&#125;class ConcreteRequest2 extends AbstractRequest &#123; public ConcreteRequest2(Object obj) &#123; super(obj); &#125; @Override public int getRequestLevel() &#123; return 2; &#125;&#125;class ConcreteRequest3 extends AbstractRequest &#123; public ConcreteRequest3(Object obj) &#123; super(obj); &#125; @Override public int getRequestLevel() &#123; return 3; &#125;&#125; 下面是客户类：1234567891011121314151617181920public class Client &#123; public static void main(String[] args) &#123; // 构造 3 个处理者对象 AbstractHandler handler1 = new Handler1(); AbstractHandler handler2 = new Handler2(); AbstractHandler handler3 = new Handler3(); // 设置当前处理者对象的下一个节点的处理者对象 handler1.nextHandler = handler2; handler2.nextHandler = handler3; // 构造 3 个请求者对象 AbstractRequest request1 = new ConcreteRequest1(&quot;Request1&quot;); AbstractRequest request2 = new ConcreteRequest2(&quot;Request2&quot;); AbstractRequest request3 = new ConcreteRequest3(&quot;Request3&quot;); // 总是从链式的首端发起请求 handler1.handleRequest(request1); handler1.handleRequest(request2); // 不从链式的首端发起请求 handler2.handleRequest(request3); &#125;&#125; 对于责任链中的一个处理者对象，其只有两个行为：一是处理请求，而是将请求转发给下一个节点。不允许某个处理者对象在处理了请求后又将请求转发给上一个节点的情况。对于一条责任链来说，一个请求最终只有两种情况：一是被某个处理对象所处理，另一个是所有对象均未对其处理。前一种情况称之为纯的责任链，后一种情况称之为不纯的责任链。 示例 小先向组长报销 5 万元费用，组长一看是笔不小的数目，他没有权限审批，于是组长拿着票据去找部门主管；主管的权限内只能批五千以下的费用，于是主管又跑去找经理；经理权限也不够直接奔向老板的办公室。使用责任链模式的代码如下所示：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 抽象领导者abstract class Leader &#123; protected Leader nextHandler; // 上一级领导处理者 /** * 处理报账请求 * @param money 能批复的报账额度 */ public final void handleRequest(int money) &#123; if (money &lt;= limit()) &#123; handle(money); &#125; else &#123; if (nextHandler != null) &#123; nextHandler.handleRequest(money); &#125; &#125; &#125; // 自身能批复的额度权限 protected abstract int limit(); // 处理报账行为 protected abstract void handle(int money);&#125;// 各个具体的领导者class GroupLeader extends Leader &#123; @Override protected int limit() &#123; return 1000; &#125; @Override protected void handle(int money) &#123; System.out.println(&quot;组长批复报销&quot; + money + &quot;元&quot;); &#125;&#125;class Director extends Leader &#123; @Override protected int limit() &#123; return 5000; &#125; @Override protected void handle(int money) &#123; System.out.println(&quot;主管批复报销&quot; + money + &quot;元&quot;); &#125;&#125;class Manager extends Leader &#123; @Override protected int limit() &#123; return 10000; &#125; @Override protected void handle(int money) &#123; System.out.println(&quot;经理批复报销&quot; + money + &quot;元&quot;); &#125;&#125;class Boss extends Leader &#123; @Override protected int limit() &#123; return Integer.MAX_VALUE; &#125; @Override protected void handle(int money) &#123; System.out.println(&quot;老板批复报销&quot; + money + &quot;元&quot;); &#125;&#125;// 客户类public class Client &#123; public static void main(String[] args) &#123; // 构造各个领导对象 GroupLeader groupLeader = new GroupLeader(); Director director = new Director(); Manager manager = new Manager(); Boss boss = new Boss(); // 设置上一级领导处理对象 groupLeader.nextHandler = director; director.nextHandler = manager; manager.nextHandler = boss; // 发起报账请求 groupLeader.handleRequest(50000); &#125;&#125; 责任链模式的灵活之处在于请求的发起可以从责任链的任何一个节点处开始，同时也可以改变责任链内部传递的规则。比如，直接越过组长找主管报账，或者直接将经理设置为组长的上一级节点。 ANDROID 源码中的责任链模式实现 责任链模式在 ANDROID 源码中比较类似的实现莫过于对事件的分发处理，每当用户解除屏幕时，ANDROID 都会将对应的事件包装成一个事件对象从 ViewTree 的顶部自上而下地分发传递。而 ViewGroup 中执行事件派发的方法是 dispatchTouchEvent，在该方法中其对事件进行了统一的分发。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(ev, 1); &#125; // 对于辅助功能的事件处理 if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123; ev.setTargetAccessibilityFocus(false); &#125; boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // 处理原始的 DOWN 事件 if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // 这里主要是在新事件开始时处理完上一个事件 cancelAndClearTouchTargets(ev); resetTouchState(); &#125; // 检查事件拦截 final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // 恢复事件防止其改变 &#125; else &#123; intercepted = false; &#125; &#125; else &#123; intercepted = true; &#125; // 如果事件被拦截了，则进行正常的事件分发 if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false); &#125; // 检查事件是否取消 final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // 如果有必要的话，为 DOWN 事件检查所有的目标对象 final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; // 如果事件未被取消且未被拦截 if (!canceled &amp;&amp; !intercepted) &#123; // 如果有辅助功能的参与，则直接将事件投递到对应的 View // 否则将事件分发给所有的子 View View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; // 如果事件为起始事件 if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; // 如果 newTouchTarget 为空且子元素不为 0 if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // 自上而下去寻找一个可以接收该事件的子 View final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; // 遍历子元素 for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; // 如果子元素无法接收 PointerEvent 或这个事件点压根就没有 // 落在子元素的边界范围内，那么就跳出该次循环继续遍历 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; // 找到 Event 该由哪个子元素持有 newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); // 投递事件执行触摸操作 // 如果子元素还是一个 ViewGroup，则递归调用重复此过程 // 如果子元素是一个 View，那么会调用 View 的 dispatchTouchEvent， // 并最终有 onTouchEvent 处理 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // 子 View 在其边界范围内接收该事件 mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear(); &#125; // 如果没有发现子元素可以持有该次事件 if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; if (mFirstTouchTarget == null) &#123; // 重点：dispatchTransformedTouchEvent handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; // 重点：dispatchTransformedTouchEvent if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; ... &#125; ... return handled;&#125; 这里我们主要看看 dispatchTransformedTouchEvent 方法是如何调度子元素 dispatchTouchEvent 方法的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; final int oldAction = event.getAction(); // 如果事件被取消 if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); // 如果没有子元素，则会调用父类的 dispatchTouchEvent。这里的父类终会为 View 类 if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; // 如果有子元素则传递 cancel 事件 handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; // 计算即将被传递的点的数量 final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits; // 如果没有相应的点，那么就丢弃该事件 if (newPointerIdBits == 0) &#123; return false; &#125; // 声明临时变量保存坐标转换后的 MotionEvent final MotionEvent transformedEvent; if (newPointerIdBits == oldPointerIdBits) &#123; // 如果子元素为空或者有一个单位矩阵 if (child == null || child.hasIdentityMatrix()) &#123; if (child == null) &#123; // 为空则调用父类 dispatchTouchEvent handled = super.dispatchTouchEvent(event); &#125; else &#123; // 否则尝试获取 xy 方向上的偏移量（如果通过 scrollTo 或 scrollBy // 对子视图进行滚动的话） final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; // 将 MotionEvent 进行坐标变换 event.offsetLocation(offsetX, offsetY); // 再将变换后的 MotionEvent 传递给子元素 handled = child.dispatchTouchEvent(event); // 复位 MotionEvent 以便以后再次使用 event.offsetLocation(-offsetX, -offsetY); &#125; // 如果通过以上的逻辑判断，当前事件被持有则可以直接返回 return handled; &#125; transformedEvent = MotionEvent.obtain(event); &#125; else &#123; transformedEvent = event.split(newPointerIdBits); &#125; // Perform any necessary transformations and dispatch. if (child == null) &#123; handled = super.dispatchTouchEvent(transformedEvent); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) &#123; transformedEvent.transform(child.getInverseMatrix()); &#125; handled = child.dispatchTouchEvent(transformedEvent); &#125; // Done. transformedEvent.recycle(); return handled;&#125; ViewGroup 事件投递的递归调用就类似于一条责任链，一旦其寻找到责任者，那么将由责任者持有并消费掉该次事件，具体地体现在View 的 onTouchEvent 方法中返回值的设置，如果 onTouchEvent 返回 false，那么意味着当前 View 不会是该次事件的责任人，将不会持有；如果为 true 则相反，此时 View 会持有该事件并不再向外传递。 责任链模式实战 ANDROID 中的 BroastCast 分为两种，一种是普通广播，另一种是有序广播。普通广播是异步的，发出时可以被所有的接收者收到。而有序广播是根据优先级依次传播的，直到有接收者将其终止或者所有接收者都不终止它。有序广播的这一特性与我们的责任链模式很相近，我们可以轻松地实现一种全局的责任链事件处理。]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07 设计模式——状态模式]]></title>
    <url>%2F2019%2F08%2F13%2FPATTERN%2F07%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 状态模式：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。 状态模式中的行为是由状态来决定的，不同的状态下有不同的行为。状态模式和策略模式的结构几乎完全一样，但它们的目的、本质却完全不一样。状态模式的行为是平行的、不可替换的，策略模式的行为是彼此独立、可相互替换的。用一句话来表述，状态模式把对象的行为包装在不同状态对象里，每一个状态对象都有一个共同的抽象状态基类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。 使用场景 一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为。 代码中包含大量与对象状态有关的条件语句，例如，一个操作中含有庞大的多分支语句（if-else 或 switch-case），且这些分支依赖于该对象的状态。 状态模式将每一个条件分支放入一个独立的类中，这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化，这样通过多态来去除过多的、重复的 if-else 等分支语句。 UML 关系图 上图中的角色介绍： Context：环境类，定义客户端感兴趣的接口，维护一个 State 子类的实例，这个实例定义了对象当前状态。 State：抽象状态类或状态接口，定义一个或一组接口，表示该状态下的行为。 ConcreteStateA、ConcreteStateB：具体状态类，每个具体状态类实现抽象状态类中定义的接口，从而达到不同状态下的不同行为。 示例 以电视遥控器为例来演示一下状态模式的实现。我们先将电视的状态简单分为开机状态和关机状态，在开机状态下可以通过遥控器进行频道切换、调整音量等操作，但是，此时重复按开机键是无效的；而在关机状态下，频道切换、调整音量、关机都是无效的操作，只有按开机按钮时会生效。 未使用状态模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 电视遥控器,含有 开机,关机,下一个频道,上一个频道,调高音量,调低音量public class TVController &#123; // 开机状态 private final static int POWER_ON = 1; // 关机状态 private final static int POWER_OFF = 2; private int state = POWER_OFF; public void powerOn() &#123; if (state == POWER_OFF) &#123; System.out.println(&quot;开机啦&quot;); &#125; state = POWER_ON; &#125; public void powerOff() &#123; if (state == POWER_ON) &#123; System.out.println(&quot;关机啦&quot;); &#125; state = POWER_OFF; &#125; public void nextChannel() &#123; if (state == POWER_ON) &#123; System.out.println(&quot;下一个频道&quot;); &#125; else &#123; System.out.println(&quot;两个红灯提示没有开机&quot;); &#125; &#125; public void prevChannel() &#123; if (state == POWER_ON) &#123; System.out.println(&quot;上一个频道&quot;); &#125; else &#123; System.out.println(&quot;两个红灯提示没有开机&quot;); &#125; &#125; public void turnUp() &#123; if (state == POWER_ON) &#123; System.out.println(&quot;调高音量&quot;); &#125; else &#123; System.out.println(&quot;两个红灯提示没有开机&quot;); &#125; &#125; public void turnDown() &#123; if (state == POWER_ON) &#123; System.out.println(&quot;调低音量&quot;); &#125; else &#123; System.out.println(&quot;两个红灯提示没有开机&quot;); &#125; &#125;&#125; 可以看到，在 TVController 类中，通过 state 字段存储了电视的状态，并且在各个操作中根据状态来判断是否该执行。这就导致了在每个功能中都需要使用 if-else，代码重复、相对较为混乱，这是在只有两个状态和几个简单功能函数的情况下，那么当状态变成 5 个、功能函数变为 10 个呢？每个函数中都要用 if-else 进行判断，而这些代码都充斥在一个类中，这些重复的代码无法被提取出来，这使得这个类变得越来越难以维护。 使用状态模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// 电视状态接口，定义电视操作的函数public interface TvState &#123; public void nextChannel(); public void prevChannel(); public void turnUp(); public void turnDown();&#125;// 关机状态，此时只有开机功能是有效的public class PowerOffStatus implements TvState&#123; @Override public void nextChannel() &#123; &#125; @Override public void prevChannel() &#123; &#125; @Override public void turnUp() &#123; &#125; @Override public void turnDown() &#123; &#125;&#125;// 开机状态，此时再出发开机功能不能做任何操作public class PowerOnState implements TvState &#123; @Override public void nextChannel() &#123; System.out.println(&quot;下一个频道&quot;); &#125; @Override public void prevChannel() &#123; System.out.println(&quot;上一个频道&quot;); &#125; @Override public void turnUp() &#123; System.out.println(&quot;声音调大&quot;); &#125; @Override public void turnDown() &#123; System.out.println(&quot;声音调小&quot;); &#125;&#125;// 电源操作接口public interface PowerController &#123; public void powerOn(); public void powerOff();&#125;// 电视遥控器，类似于经典状态模式中的 Contextpublic class TvController implements PowerController &#123; TvState tvState; public void setTvState(TvState tvState) &#123; this.tvState = tvState; &#125; @Override public void powerOn() &#123; setTvState(new PowerOnState()); System.out.println(&quot;开机啦&quot;); &#125; @Override public void powerOff() &#123; setTvState(new PowerOffStatus()); System.out.println(&quot;关机啦&quot;); &#125; public void nextChannel()&#123; tvState.nextChannel(); &#125; public void prevChannel()&#123; tvState.prevChannel(); &#125; public void turnUp()&#123; tvState.turnUp(); &#125; public void turnDown()&#123; tvState.turnDown(); &#125;&#125; 客户端调用代码12345678910111213public static void main(String[] args) &#123; TvController tvController = new TvController(); // 设置开机状态 tvController.powerOn(); // 下一个频道 tvController.nextChannel(); // 调高音量 tvController.turnUp(); // 设置关机状态 tvController.powerOff(); // 调低音量，此时不会生效 tvController.turnDown();&#125; 输出结果：1234开机啦下一个频道声音调大关机啦 状态模式实战 在开发过程中，我们用到状态模式最常见的地方应该是用户登录系统。在用户已登录和未登录的情况下，对于同一事件的处理行为是不一样的。例如，在新浪微博中，用户在未登录的情况下点击转发或评论按钮，此时会先让用户登录，然后再执行操作；如果是已登录的情况下，那么用户可以直接进行操作。 首先抽象出状态类，定义两个操作接口：转发和评论。12345678910public interface UserState &#123; /** * 转发 */ public void forward(Context context); /** * 评论 */ public void comment(Context context);&#125; 然后实现两个状态子类：已登录状态类、未登录状态类。1234567891011121314151617181920212223242526272829// 已登录状态public class LoggedState implements UserState &#123; @Override public void forward(Context context) &#123; Toast.makeText(context, &quot;转发成功&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void comment(Context context) &#123; Toast.makeText(context, &quot;评论成功&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125;// 未登录状态public class LogoutState implements UserState &#123; @Override public void forward(Context context) &#123; gotoLoginActivity(context); &#125; @Override public void comment(Context context) &#123; gotoLoginActivity(context); &#125; private void gotoLoginActivity(Context context) &#123; Intent intent = new Intent(context, LoginActivity.class) startActivity(context); &#125;&#125; 最后实现 Context 角色，即用户的操作对象和状态管理对象。1234567891011121314151617181920212223public class LoginContext &#123; // 用户状态，默认为未登录状态 private UserState userState = new LogoutState(); // 单例 private static LoginContext loginContext = new LoginContext(); private LoginContext() &#123;&#125; public LoginContext getLoginContext() &#123; return loginContext; &#125; public void setUserState(UserState userState) &#123; this.userState = userState; &#125; public void forward(Context context) &#123; userState.forward(context); &#125; public void comment(Context context) &#123; userState.comment(context); &#125;&#125; 客户端调用样例：12345678// 转发微博LoginContext.getLoginContext().forward(MainActivity.this)// 分享微博LoginContext.getLoginContext().comment(MainActivity.this)// 登录成功后修改为已登录状态LoginContext.getLoginContext().setUserState(new LoggedState())// 注销登录，修改为未登录状态LoginContext.getLoginContext().setUserState(new LogoutState());]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06 设计模式——策略模式]]></title>
    <url>%2F2019%2F08%2F12%2FPATTERN%2F06%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 策略模式：策略模式定义了一系列算法，并将每一个算法封装起来，而且使它们可以相互替换。策略模式让算法独立于使用它的客户端而独立变化。 在软件开发中常常遇到这样的情况：实现某一功能可以有多种算法或者策略，我们根据实际情况选择不同的算法或者策略来完成该功能。例如，排序算法，可以使用插入排序、归并排序、冒泡排序等。 针对这种情况，一种常规的方法是将多种算法写到一个类中。例如，需要提供多种排序算法，可以将这些算法写到一个类中，每一个方法对应一个具体的排序算法；当然，也可以将这些排序算法封装在一个统一的方法中，通过 if…else… 或者 case 等条件判断语句来选择具体的算法。这两种实现方法我们都可以称为硬编码。然而，当很多算法集中在一个类中时，这个类就会变得臃肿，维护成本会变高，在维护时也更容易引发错误。如果我们需要增加一种新的排序算法，需要修改封装算法类的源代码。这就明显违反了开闭原则和单一职责原则。 如果将这些算法或者策略抽象出来，提供一个统一的接口，不同的算法或者策略有不同的实现类，这样在程序客户端就可以通过注入不同的实现对象来实现算法或者策略的动态替换，这种模式的可扩展性、可维护性也就更高，也就是我们要说的策略模式。 优点 结构清晰明了、使用简单直观； 耦合度相对而言较低，扩展方便； 操作封装也更为彻底，数据更为安全。 缺点 随着策略的增加，子类也会变得繁多。 使用场景 针对同一类型问题的多种处理方式，仅仅是具体行为有差别时。 需要安全地封装多种同一类型的操作时。 出现同一抽象类有多个子类，而又需要使用 if-else 或者 switch-case 来选择具体子类时。 UML 关系图 上图中的角色介绍： Context：用来操作策略的上下文环境； Strategy：策略的抽象； ConcreteStrategyA、ConcreteStrategyB：具体的策略实现。 示例 下面我们以计算不同交通工具的车费来简单看看策略模式的实现。 常规实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class PriceCalculator &#123; // 公交车类型 private static final int BUS = 1; // 地铁类型 private static final int SUBWAY = 2; public int calculatePrice(int km, int type) &#123; if (type == BUS) &#123; return busPrice(km); &#125; else if (type == SUBWAY) &#123; return subwayPrice(km); &#125; return 0; &#125; /** * 十公里之内一元，超过十公里之后每加一元钱可以乘 5 公里 * @param km 公里数 * @return 公交车车费 */ private int busPrice(int km) &#123; // 超过十公里的总距离 int extraTotal = km - 10; // 超过的距离是 5 公里的倍数 int extraFactor = extraTotal / 5; // 超过的距离对 5 公里取余 int fraction = extraTotal % 5; // 价格计算 int price = 1 + extraFactor * 1 ; return fraction &gt; 0 ? ++price : price; &#125; /** * 6 公里（含）内 3 元；6 ~ 12 公里（含）4 元； * 12 ~ 22 公里（含）5元；22 ~ 32 公里（含）6元； * @param km 公里数 * @return 地铁车费 */ private int subwayPrice(int km) &#123; if (km &lt;= 6) &#123; return 3; &#125; else if (km &lt;= 12) &#123; return 4; &#125; else if (km &lt;= 22) &#123; return 5; &#125; else if (km &lt;= 32) &#123; return 6; &#125; // 其他距离简化为 7 元 return 7; &#125;&#125; PriceCalculator 类很明显地问题就是并不是单一职责，首先他承担了计算公交车和地铁乘坐价格的职责；另一个问题就是通过 if-else 的形式来判断使用哪种计算形式。当我们增加一种出行方式时，如出租车，那么我们就需要在 PriceCalculator 中增加一个方法来计算出租车出行的价格，并且再 calculatePrice(int km, int type) 函数中增加一个判断，代码添加后大致如下。123456789101112131415161718192021222324252627282930public class PriceCalculator &#123; // 公交车类型 private static final int BUS = 1; // 地铁类型 private static final int SUBWAY = 2; // 出租车类型 private static final int TEXI = 3; public int calculatePrice(int km, int type) &#123; if (type == BUS) &#123; return busPrice(km); &#125; else if (type == SUBWAY) &#123; return subwayPrice(km); &#125; else if (type == TEXI) &#123; return taxiPrice(km); &#125; return 0; &#125; /** * 简单计算为每公里 2 元钱 * @param km 公里数 * @return 出租车费 */ private int taxiPrice(int km) &#123; return km * 2; &#125; // 其他代码&#125; 此时代码已经比较混乱，各种 if-else 缠绕其中。当价格的计算方法变化时，需要直接修改这个类中的代码，那么很可能有一段代码是其他几个计算方法所共同使用的，这就容易引入错误。另外，在增加出行方式时，需要手动修改，添加 if-else。这类代码必然是难以应对变化的，难以维护的。下面我们对上述示例用策略模式进行重构。 策略模式首先需要定义一个抽象的价格计算接口。12345678public interface CalculateStrategy &#123; /** * 按距离来计算价格 * @param km 公里数 * @return 价格 */ int calculatePrice(int km);&#125; 对于每一种出行方式我们都有一个独立的计算策略类，这些策略类都实现了 CalculateStrategy 接口。123456789101112131415161718192021222324252627282930313233343536373839404142434445// 公交车价格计算策略public class BusStrategy implements CalculateStrategy &#123; /** * 十公里之内一元，超过十公里之后每加一元钱可以乘 5 公里 * @param km 公里数 * @return 公交车车费 */ @Override public int calculatePrice(int km) &#123; // 超过十公里的总距离 int extraTotal = km - 10; // 超过的距离是 5 公里的倍数 int extraFactor = extraTotal / 5; // 超过的距离对 5 公里取余 int fraction = extraTotal % 5; // 价格计算 int price = 1 + extraFactor * 1 ; return fraction &gt; 0 ? ++price : price; &#125;&#125;// 地铁价格计算策略public class SubwayStrategy implements CalculateStrategy &#123; /** * 6 公里（含）内 3 元；6 ~ 12 公里（含）4 元； * 12 ~ 22 公里（含）5元；22 ~ 32 公里（含）6元； * @param km 公里数 * @return 地铁车费 */ @Override public int calculatePrice(int km) &#123; if (km &lt;= 6) &#123; return 3; &#125; else if (km &lt;= 12) &#123; return 4; &#125; else if (km &lt;= 22) &#123; return 5; &#125; else if (km &lt;= 32) &#123; return 6; &#125; // 其他距离简化为 7 元 return 7; &#125;&#125; 再创建一个扮演 Context 角色的类。1234567891011121314151617public class TrafficCalculator &#123; private CalculateStrategy mStrategy; public CalculateStrategy getStrategy() &#123; return mStrategy; &#125; public void setStrategy(CalculateStrategy strategy) &#123; this.mStrategy = strategy; &#125; public static void main(String[] args) &#123; TrafficCalculator calculator = new TrafficCalculator(); calculator.setStrategy(new BusStrategy()); calculator.calculatePrice(16); &#125;&#125; 这种方案在隐藏实现的同时，可扩展性变得很强。例如，当我们需要增加出租车的计算策略时，只需要添加一个出租车计算策略类，然后将该策略设置给 TrafficCalculator。1234567891011// 出租车价格计算策略public class TaxiStrategy implements CalculateStrategy &#123; /** * 简单计算为每公里 2 元钱 * @param km 公里数 * @return 出租车费 */ private int taxiPrice(int km) &#123; return km * 2; &#125;&#125; 讲策略注入到 TrafficCalculator 中。123TrafficCalculator calculator = new TrafficCalculator();calculator.setmStrategy(new TaxiStrategy());calculator.calculatePrice(16); 模式在 ANDROID 中的应用 ANDROID 中属性动画的时间差值器分为线性差值器、加速减速差值器等，这些差值器里面就用到了策略模式来隔离不同的动画速率计算算法。源码追踪关键方法依次为： View：boolean draw(Canvas canvas, ViewGroup parent, long drawingTime)private boolean applyLegacyAnimation(ViewGroup parent, long drawingTime, Animation a, boolean scalingRequired) Animation：public boolean getTransformation(long currentTime, Transformation outTransformation,float scale)public boolean getTransformation(long currentTime, Transformation outTransformation) Interpolator：float getInterpolation(float input) 插值器在属性动画中扮演了很重要的角色。它将动画的速率计算封装到一个抽象中，也就是 Interpolator 中，该接口只有一个 getInterpolation(float input) 方法，通过这个方法来修改动画的流逝时间比，依次达到动画的加速、减速等效果，结构如下图所示。 Interpolator 就是这个计算策略的抽象，LinearInterpolator、CycleInterpolator 等插值器就是具体的实现策略，通过注入不同的插值器实现不同的动态效果。 策略模式实战 在我们加载图片项目 ImageLoader 中，加载请求会被封装成一个 Request 对象添加到请求队列中，ImageLoader 会为每个请求分配一个序列号，越晚加入的请求序列号值越大，默认情况下 ImageLoader 会按照先后顺序加载图片。但是现实中，我们可能需要最后添加到队列的请求先被执行。例如，在滚动 ListView 时，最后一项肯定是最晚被加载的，此时它却显示在屏幕上的，而其它优先被加载的请求却不在屏幕显示范围。当需求是在屏幕上显示的 Item View 的图片优先被加载，我们就需要 ImageLoader 支持从请求队列的尾部开始加载。也就是，这里至少需要两种策略。 依照策略模式，代码实现如下所示。12345678910111213141516171819202122232425262728293031323334353637383940/** * 加载策略接口 */public interface LoadPolicy &#123; int compare(BitmapRequest request1, BitmapRequest request2);&#125;/** * 顺序加载策略 */public class SerialPolicy implements LoadPolicy &#123; @Override public int compare(BitmapRequest request1, BitmapRequest request2) &#123; return request1.serialNum - request2.serialNum; &#125;&#125;/** * 逆序加载策略 */public class SerialPolicy implements LoadPolicy &#123; @Override public int compare(BitmapRequest request1, BitmapRequest request2) &#123; return request2.serialNum - request1.serialNum; &#125;&#125;public class BitmapRequest implements Comparable&lt;BitmapRequest&gt; &#123; // 加载策略，默认顺序加载策略 private LoadPolicy mLoadPolicy = new SerialPolicy(); public void setLoadPolicy(LoadPolicy loadPolicy) &#123; this.mLoadPolicy = loadPolicy; &#125; @Override public int compareTo(BitmapRequest another) &#123; return mLoadPolicy.compare(this, another); &#125;&#125;]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05 设计模式——抽象工厂模式]]></title>
    <url>%2F2019%2F08%2F11%2FPATTERN%2F05%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 抽象工厂模式：为创建一组相关或者相互依赖的对象提供一个接口，而无需指定它们的具体类。 可以说是工厂方法模式的升级版，当需要创建的产品有多个产品线（产品族）时使用抽象工厂模式是比较好的选择。 优点 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。 缺点 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。 开闭原则的倾斜性1）增加产品族：对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。2）增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。 正因为抽象工厂模式存在“开闭原则”的倾斜性，它以一种倾斜的方式来满足“开闭原则”，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。 使用场景在以下情况下可以考虑使用抽象工厂模式： 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。 系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一制作水果蛋糕用的水果–草莓和芒果，草莓和芒果之间没有直接关系，但它们都是属于水果。 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。 UML关系图 抽象工厂模式中有如下角色： AbstractFactory：抽象工厂，它声明了用来创建不同产品的方法。 ConcreteFactory：具体工厂，实现抽象工厂中定义的创建产品的方法。 AbstractProduct：抽象产品，为每种产品声明业务方法。比如上图的AbstractProductA和 AbstractProductB。 ConcreteProduct：具体产品，定义具体工厂生产的具体产品，并实现抽象产品中定义的业务方法。 示例 联想和惠普生产的电脑分为了两个产品线，一个台式机，一个是笔记本。为了解决增加产品线的问题，我们用抽象工厂模式来进行实现。 抽象产品两个抽象产品类分别为 DesktopComputer 和 NotebookComputer ，用来定义两个产品线：台式机和笔记本。它们都定义了start方法，用来启动电脑。 1234567public abstract class DesktopComputer &#123; public abstract void start();&#125;public abstract class NotebookComputer &#123; public abstract void start();&#125; 具体产品具体产品为联想和惠普旗下的台式机和笔记本，如下所示。 1234567891011121314151617181920212223242526public class LenovoDesktopComputer extends DesktopComputer &#123; @Override public void start() &#123; System.out.println(&quot;联想台式电脑启动&quot;); &#125;&#125;public class HpDesktopComputer extends DesktopComputer &#123; @Override public void start() &#123; System.out.println(&quot;惠普台式电脑启动&quot;); &#125;&#125;public class LenovoNotebookComputer extends NotebookComputer &#123; @Override public void start() &#123; System.out.println(&quot;联想笔记本电脑启动&quot;); &#125;&#125;public class HpNotebookComputer extends NotebookComputer &#123; @Override public void start() &#123; System.out.println(&quot;惠普笔记本电脑启动&quot;); &#125;&#125; 抽象工厂定义了两个方法，分别用来生产台式电脑和笔记本电脑。 1234public abstract class ComputerFactory &#123; public abstract DesktopComputer createDesktopComputer(); public abstract NotebookComputer createNotebookComputer();&#125; 具体工厂联想工厂和惠普工厂用来生产台式机和笔记本这两个不同产品线的电脑。 12345678910111213141516171819202122public class LenovoFactory extends ComputerFactory &#123; @Override public DesktopComputer createDesktopComputer() &#123; return new LenovoDesktopComputer(); &#125; @Override public NotebookComputer createNotebookComputer() &#123; return new LenovoNotebookComputer(); &#125;&#125;public class HpFactory extends ComputerFactory &#123; @Override public DesktopComputer createDesktopComputer() &#123; return new HpDesktopComputer(); &#125; @Override public NotebookComputer createNotebookComputer() &#123; return new HpNotebookComputer(); &#125;&#125; 客户端调用：12345678910public class Client &#123; public static void main(String[]args) &#123; ComputerFactory lenocoFactory=new LenovoFactory(); lenocoFactory.createDesktopComputer().start(); lenocoFactory.createNotebookComputer().start(); ComputerFactory hpFactory=new HpFactory(); hpFactory.createDesktopComputer().start(); hpFactory.createNotebookComputer().start(); &#125;&#125; 模式在 ANDROID 中的应用 对于 ANDROID 来说，抽象工厂的一个更好的应用是在主题修改上。比如我们的应用中有两套主题，分别为亮色主题 LightTheme 和 暗色主题 DarkTheme。这两种主题我们可以通过一个抽象的类或接口来定义，而在对应主题下我们又有各类不同的 UI 元素，比如 Button、TextView、Dialog、ActionBar 等，这些 UI 元素都会分别对应不同的主题，这些 UI 元素我们也可以通过抽象的类或接口，抽象的主题、具体的主题、抽象的 UI 元素和具体的 UI 元素之间的关系就是抽象工厂模式最好的体现。 代码略…]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04 设计模式——工厂方法模式]]></title>
    <url>%2F2019%2F08%2F10%2FPATTERN%2F04%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪个类。 工厂方法模式（FACTORY METHOD）是一种常用的类创建型设计模式，此模式的核心精神是封装类中变化的部分，提取其中个性化善变的部分为独立类，通过依赖注入以达到解耦、复用和方便后期维护拓展的目的。在任何需要生成复杂对象的地方，都可以使用工厂方法模式。复杂对象适合使用工厂模式，用 new 就可以完成创建的对象无需使用工厂模式。 它的核心结构有四个角色，分别是抽象工厂；具体工厂；抽象产品；具体产品。 通用模式代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 抽象产品类public abstract class Product &#123; /** * 产品类的抽象方法，由具体的产品类去实现 */ public abstract void method();&#125;// 具体产品类 Apublic class ConcreteProductA extends Product &#123; @Override public void method() &#123; System.out.println(&quot;产品 A&quot;); &#125;&#125;// 具体产品类 Bpublic class ConcreteProductB extends Product &#123; @Override public void method() &#123; System.out.println(&quot;产品 B&quot;); &#125;&#125;// 抽象工厂类public abstract class Factory &#123; /** * 抽象工厂方法，具体由子类去实现 * @return 具体的产品类型 */ public abstract Product createProduct();&#125;// 具体工厂类public class ConcreteFactory extends Factory &#123; @Override public Product createProduct() &#123; return new ConcreteProductA(); &#125;&#125; 调用123Factory factory = new ConcreteFactory();Product p = factory.createProduct();p.method(); 这里我们得到的产品对象时 ConcreteProductA 的实例，如果想得到 ConcreteProductB 的实例，更改 ConcreteFactory 中的逻辑即可；或者是新建一个 Factory 的具体实现子类，专门生产 ConcreteProductB 的实例。当然，我们也可以利用反射的方式来简化操作。具体如下：123456789101112131415161718192021public abstract class Factory &#123; /** * @param clz 产品对象类型 * @return 具体的产品类型 */ public abstract &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; clz);&#125;public class ConcreteFactory extends Factory &#123; @Override public &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; clz) &#123; Product p = null; try &#123; p = (Product) Class.forName(clz.getName()).newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return (T) p; &#125;&#125; 调用：12345Factory factory = new ConcreteFactory();Product productA = factory.createProduct(ConcreteProductA.class);Product productB = factory.createProduct(ConcreteProductB.class);productA.method();productB.method(); 当我们的工厂只有一个的时候，可以简化掉抽象工厂类，并提供一个静态方法即可。12345public class Factory &#123; public static Product createProduct() &#123; return new ConcreteProductA(); &#125;&#125; 工厂方法模式是完全符合设计原则的，其降低了对象之间的耦合度。而且，工厂方法模式依赖于抽象的架构，其将实例化的任务交由子类去完成，有非常好的扩展性。 示例：数据持久化 ANDROID 中数据持久化为我们提供了 SharePreference、 SQLite 和普通的文件存储等方式。但是对数据的操作都是增删改查，可以把这些共同的操作抽象出来作为抽象产品类，然后每一种持久化方法作为具体产品。 抽象产品中定义操作的方法，即增删改查。123456789101112131415161718192021222324252627282930313233public abstract class AbstractIoHandler &#123; /** * 添加个人信息 * * @param id 身份证号码 * @param name 姓名 */ public abstract void add(String id, String name); /** * 根据ID删除一条信息 * * @param id 身份证 */ public abstract void remove(String id); /** * 更新个人信息 * * @param id 身份证 * @param name 姓名 */ public abstract void update(String id, String name); /** * 查询ID对应的信息 * * @param id 身份证 * @return 人名 */ public abstract String query(String id);&#125; 具体的产品，持久化的类型，比如利用文件来持久化。12345678910111213141516171819202122public class FileHandler extends AbstractIoHandler &#123; @Override public void add(String id, String name)&#123; //业务处理 &#125; @Override public void remove(String id) &#123; //业务处理 &#125; @Override public void update(String id, String name) &#123; //业务处理 &#125; @Override public String query(String id) &#123; return &quot;&quot;; &#125;&#125; 然后是我们的工厂方法，这里仍然采用反射的方式。12345678910111213141516171819public class IoFactory &#123; /** * 获取IoHandler * * @param clz AbstractIoHandler类型的类 * @return AbstractIoHandler对象 */ public static &lt;T extends AbstractIoHandler&gt; T getIoHandler(Class&lt;T&gt; clz) &#123; AbstractIoHandler handler = null; try &#123; handler = (AbstractIoHandler) Class.forName(clz.getName()).newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return (T) handler; &#125;&#125; 在需要进行数据持久化的地方调用工厂方法：12AbstractIoHandler ioHandler = IoFactory.getIoHandler(FileHandler.class);System.out.println(ioHandler.query(&quot;123456&quot;)); 这里的例子简化了很多，还有数据库 SQLite 以及 SharePreference 的持久化的类就没有写了。 ANDROID 源码中的工厂方法模式实现 在 ANDROID 中对工厂方法模式的应用有很多，例如下面的代码：1234567public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(new LinearLayout(this)); &#125;&#125; Activity 中的 onCreate 方法就相当于一个工厂方法。为什么呢？因为我们知道 LinearLayout 是一个 ViewGroup，而 ViewGroup 又继承于 View，简单地说就是，所有控件都是 View 的子类，上面的代码中，我们在 MainActivity 的 onCreate 方法中构造一个 View 对象，并设置为当前界面的 ContentView 返回给 framework 处理，如果现在又有一个 LoginActivity，这时我们又在其 onCreate 方法中通过 setContentView 方法设置另外不同的 View，这是不是就是一个工厂模式的结构呢？]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03 设计模式——原型模式]]></title>
    <url>%2F2019%2F08%2F09%2FPATTERN%2F03%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 原型模式：用原型实例指定创建对象的种类，并通过复制这些原型创建新的对象。 原型模式是一个创建型的模式。该模式应该有一个样板实例，用户从这个样板对象中复制出一个内部属性一致的对象，这个过程也就是我们俗称的“克隆”。被复制的实例就是我们所称的“原型”，这个原型是可定制的。原型模式多用于创建复杂的或者构造耗时的实例，因为这种情况下，复制一个已经存在的实例可使程序运行更高效。 使用场景1）类初始化需要消耗非常多的资源，这个资源包括数据、硬件资源等，通过原型复制避免这些消耗。2）通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，这时可以使用原型模式。3）一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式复制多个对象供调用者使用，即保护性拷贝。 需要注意的是，通过实现 Cloneable 接口的原型模式在调用 clone 函数构造实例时并不一定比通过 new 操作速度快，只有当通过 new 构造对象较为耗时或者成本高时，通过 clone 方法才能够获得效率上的提升。因此，在使用 Cloneable 接口时需要考虑构建对象的成本以及做一些效率上的测试。当然，实现原型模式不一定非要实现 Cloneable 接口，也有其他的实现方式，见后文。 UML 类图 Client：客户端用户。Prototype：抽象类或者接口，声明具备 clone 能力。ConcretePrototype：具体的原型类。 示例：文档拷贝 在这个例子中，首先创建了一个文档对象，即 WordDocument，这个文档中含有文字和图片。用户经过了长时间的编辑后，打算对该文档做进一步的编辑。但是，这个编辑后的文档是否会被采用还不确定。因此，为了安全起见，用户需要将当前文档拷贝一份，然后再在文档副本上进行修改。如此，这个原始文档就是我们上述所说的样板实例，也就是将要被“克隆”的对象，我们称为“原型”。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class WordDocument implements Cloneable &#123; // 文本 private String text; // 图片 private ArrayList&lt;String&gt; images = new ArrayList&lt;&gt;(); public WordDocument() &#123; System.out.println(&quot;---WordDocument 构造函数---&quot;); &#125; @Override protected WordDocument clone() &#123; try &#123; WordDocument document = (WordDocument) super.clone(); document.text = this.text; document.images = this.images; return document; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; public String getText() &#123; return text; &#125; public void setText(String text) &#123; this.text = text; &#125; public ArrayList&lt;String&gt; getImages() &#123; return images; &#125; public void addImage(String img) &#123; images.add(img); &#125; /** * 打印文档内容 */ public void showDocument() &#123; System.out.println(&quot;---Word content start---&quot;); System.out.println(&quot;Text : &quot; + text); System.out.println(&quot;images list : &quot;); for (String name : images) &#123; System.out.println(&quot;image name : &quot; + name); &#125; System.out.println(&quot;---Word content end---&quot;); &#125;&#125; 通过 WordDocument 类模拟了 Word 文档中的基本元素，即文字和图片。WordDocument 在该原型模式示例中扮演的角色为 ConcretePrototype，而 Cloneable 的角色则为 Prototype。WordDocument 中的 clone 方法用以实现对象克隆。注意，这个方法并不是 Cloneable 接口的，而是 Object 中的方法。Cloneable 也是一个标识接口，它表明这个类的对象是可拷贝的。如果没有实现 Cloneable 接口却调用了 clone() 函数将抛出异常。在这个示例中，我们通过实现 Cloneable 接口和覆写 clone 方法实现原型模式。 下面看看 Client 端的调用。123456789101112131415WordDocument originDoc = new WordDocument();originDoc.setText(&quot;这是一篇文档&quot;);originDoc.addImage(&quot;图片1&quot;);originDoc.addImage(&quot;图片2&quot;);originDoc.addImage(&quot;图片3&quot;);originDoc.showDocument();WordDocument doc2 = originDoc.clone();doc2.showDocument();doc2.setText(&quot;这是修改过的文档&quot;);doc2.addImage(&quot;图片4&quot;);doc2.showDocument();originDoc.showDocument(); 输出结果如下所示。12345678910111213141516171819202122232425262728293031---WordDocument 构造函数------Word content start---Text : 这是一篇文档images list : image name : 图片1image name : 图片2image name : 图片3---Word content end------Word content start---Text : 这是一篇文档images list : image name : 图片1image name : 图片2image name : 图片3---Word content end------Word content start---Text : 这是修改过的文档images list : image name : 图片1image name : 图片2image name : 图片3image name : 图片4---Word content end------Word content start---Text : 这是一篇文档images list : image name : 图片1image name : 图片2image name : 图片3image name : 图片4---Word content end--- 从上面可以看到，doc2 是通过 originDoc.clone() 创建的，并且 doc2 第一次输出的时候和 originDoc 输出是一样的，即 doc2 是 originDoc 的一份拷贝，它们的内容是一样的，而 doc2 修改了文本内容以后并不影响 originDoc 的文本内容，这就保证了 originDoc 的安全性。还需要注意的是，通过 clone 拷贝对象时并不会执行构造函数。 但是，originDoc 的图片列表内容（images）被更改了，这是为什么呢？因为上述示例只是一个浅拷贝。 浅拷贝和深拷贝 浅拷贝又叫影子拷贝，上面我们在拷贝文档时并没有把原文档中的字段都重新构造了一遍，而只是拷贝了引用，也就是副文档的字段引用原始文档的字段，这样的话修改副文档中的内容就会连原始文档也改掉了，这就是浅拷贝。 深拷贝就是在浅拷贝的基础上，对于引用类型的字段也要采用拷贝的形式，比如上面的 images，而像 String、int 这些基本数据类型则没关系 所以在运用原型模式时建议大家还是用深拷贝。下面我们把上面的浅拷贝改成深拷贝，clone 方法修改如下。123456789101112131415@Overrideprotected WordDocument clone() &#123; try &#123; WordDocument document = (WordDocument) super.clone(); document.text = this.text; // document.images = this.images; // 对 images 对象也调用 clone() 函数，进行深拷贝 document.images = (ArrayList&lt;String&gt;) this.images.clone(); return document; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125; ANDROID 源码中的原型模式 在 Android 中，Intent 可能是我们最早接触的几个类型之一，它用于跳转 Activity、启动服务、发布广播等功能，它是 Android 系统各组件之间的纽带，也是组件之间传递数据的载体，正式 Intent 的存在才使得 Android 各个组件之间的耦合性很低，Android 的组件才如此灵活。 下面以 Intent 来分析源码中的原型模式，首先看如下示例。123456Uri uri = Uri.parse(&quot;smsto:0800000123&quot;);Intent shareIntent = new Intent(Intent.ACTION_SENDTO, uri);shareIntent.putExtra(&quot;sms_body&quot;, &quot;The SMS text&quot;);// 克隆副本Intent intent = (Intent) shareIntent.clone();startActivity(intent); 通过 shareIntent.clone 方法拷贝了一个对象 Intent，然后执行 startActivity(intent)，随即就进入了短信页面，号码为 0800000123，文本内容为 The SMS text，即这些内容都与 shareIntent 一致。 我们看看 Intent 的 clone() 方法是如何实现的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Intent implements Parcelable, Cloneable &#123; @Override public Object clone() &#123; return new Intent(this); &#125; /** * Copy constructor. */ public Intent(Intent o) &#123; this(o, COPY_MODE_ALL); &#125; private Intent(Intent o, @CopyMode int copyMode) &#123; this.mAction = o.mAction; this.mData = o.mData; this.mType = o.mType; this.mPackage = o.mPackage; this.mComponent = o.mComponent; if (o.mCategories != null) &#123; this.mCategories = new ArraySet&lt;&gt;(o.mCategories); &#125; if (copyMode != COPY_MODE_FILTER) &#123; this.mFlags = o.mFlags; this.mContentUserHint = o.mContentUserHint; this.mLaunchToken = o.mLaunchToken; if (o.mSourceBounds != null) &#123; this.mSourceBounds = new Rect(o.mSourceBounds); &#125; if (o.mSelector != null) &#123; this.mSelector = new Intent(o.mSelector); &#125; if (copyMode != COPY_MODE_HISTORY) &#123; if (o.mExtras != null) &#123; this.mExtras = new Bundle(o.mExtras); &#125; if (o.mClipData != null) &#123; this.mClipData = new ClipData(o.mClipData); &#125; &#125; else &#123; if (o.mExtras != null &amp;&amp; !o.mExtras.maybeIsEmpty()) &#123; this.mExtras = Bundle.STRIPPED; &#125; &#125; &#125; &#125; // 代码省略&#125; clone 方法并没有调用 super.clone() 来实现对象拷贝，而是调用了 new Intent(this)。在上文中我们提到过，使用 clone 和 new 需要根据构造对象的成本来决定。如果对象的构造成本比较高或者构造较为麻烦，那么使用 clone() 函数效率较高，否则可以使用 new 的形式。 原型模式实战 在开发中，我们有时候会满足一些需求，就是有的对象的内容只允许客户端程序读取，而不允许修改，比如用户登录信息。我们通常会用 LoginSession 保存用户的登录信息，这些用户信息可能在 APP 的其他模块被用来做登录校验、用户个人信息显示等。但是，这些信息在客户端程序是不允许修改的。此时，就需要使用原型模式来进行保护性拷贝。表现形式如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 用户实体类public class User implements Cloneable &#123; private int age; private String name; private String phoneNum; private Address address; @Override protected Object clone() &#123; User user = null; try &#123; user = (User) super.clone(); // 深拷贝 user.address = (Address) this.address.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return user; &#125; // setter &amp; getter&#125;// 用户地址类public class Address implements Cloneable &#123; private String city; private String district; private String street; @Override protected Object clone() &#123; Address address = new Address(); address.city = this.city; address.district = this.district; address.street = this.street; return address; &#125; // setter &amp; getter&#125;// 登录接口public interface ILogin &#123; void login();&#125;// 登录实现public class LoginImpl implements ILogin &#123; @Override public void login() &#123; User loggedUser = new User(); // 获取用户信息 // ... // 成功登录后，将用户信息保存到 Session 中 LoginSession.getInstance().setLoggedUser(loggedUser); &#125;&#125;// 登录 Sessionpublic class LoginSession &#123; // 已登录用户信息 private User loggedUser; private LoginSession() &#123;&#125; private static class LoginSessionHolder &#123; private static final LoginSession sLoginSession = new LoginSession(); &#125; public static LoginSession getInstance() &#123; return LoginSessionHolder.sLoginSession; &#125; // 设置已登录的用户信息，不对外开放 void setLoggedUser(User user) &#123; loggedUser = user; &#125; public User getLoggedUser() &#123; if (null == loggedUser) return null; return (User)loggedUser.clone(); &#125;&#125; 这就使得在任何地方调用 getLoggedUser 函数获取到的用户对象都是一个拷贝对象，即使客户端代码一不小心修改了这个拷贝对象，也不会影响最初的已登录用户对象，对已登录用户信息的修改只能通过 setLoggedUser 这个方法，而只有与 LoginSession 在同一个包下的类才能访问这个包级私有方法。]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02 设计模式——建造者模式]]></title>
    <url>%2F2019%2F08%2F08%2FPATTERN%2F02%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 Builder 模式是一步一步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更精细地控制对象的构造流程。该模式是为了将构建复杂对象的过程和它的部件解耦，使得构建过程和部件的表示隔离开来。 因为一个负责对象有大量组成部分，如汽车有车轮、方向盘、发动机、车盘，还有各种小零件，如何将这些部件装配成一辆汽车，这个装配过程很漫长，也很复杂，对于这种情况，为了在构建过程中对外部隐藏实现细节，就可以使用 Builder 模式将部件和组装过程分离，使得构建过程和部件都可以自由扩展，两者之间的耦合也降到最低。 使用场景1）相同的方法，不同的执行顺序，产生不同的事件结果时。2）多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时。3）产品类非常复杂，或者产品类中的调用顺序不同产生了不同的作用，这个时候使用建造者模式非常合适。4）当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值时。 UML 类图 从上图可以看到，经典 Buider 模式中有四个角色： Product 产品类 —— 产品的抽象类； Builder —— 抽象 Builder 类，规范产品的组建，一般是由子类实现具体的组建过程； ConcreteBuilder —— 具体的 Builder 类； Director —— 统一组装过程。 示例 计算机的组装过程较为复杂，并且组装顺序是不固定的，为了易于理解，我们把计算机组装的过程简化为构建主机、设置操作系统、设置显示器 3 个部分，然后通过 Director 和具体的 Builder 来构建计算机对象。请看下面示例。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// 计算机抽象类，即 Product 角色public abstract class Computer &#123; protected String mBoard; protected String mDisplay; protected String mOS; protected Computer() &#123;&#125; public void setBoard(String board) &#123; this.mBoard = board; &#125; public void setDisplay(String display) &#123; this.mDisplay = display; &#125; public abstract void setOS(); @Override public String toString() &#123; return &quot;Computer [&quot; + &quot;mBoard=&apos;&quot; + mBoard + &apos;\&apos;&apos; + &quot;, mDisplay=&apos;&quot; + mDisplay + &apos;\&apos;&apos; + &quot;, mOS=&apos;&quot; + mOS + &apos;]&apos;; &#125;&#125;// 具体的 Computer 类，Macbookpublic class Macbook extends Computer &#123; protected Macbook() &#123;&#125; @Override public void setOS() &#123; mOS = &quot;Mac OS X 10.10&quot;; &#125;&#125;// 抽象 Builder 类public abstract class Builder &#123; public abstract void buildBoard(String board); public abstract void buildDisplay(String display); public abstract void buildOS(); public abstract Computer create();&#125;// 具体的 Builder 类，MacbookBuilderpublic class MacbookBuilder extends Builder &#123; private Computer mComputer = new Macbook(); @Override public void buildBoard(String board) &#123; mComputer.setBoard(board); &#125; @Override public void buildDisplay(String display) &#123; mComputer.setDisplay(display); &#125; @Override public void buildOS() &#123; mComputer.setOS(); &#125; @Override public Computer create() &#123; return mComputer; &#125;&#125;// Director 类，负责构造 Computerpublic class Director &#123; Builder mBuilder = null; public Director(Builder builder) &#123; this.mBuilder = builder; &#125; public void construct(String board, String display) &#123; mBuilder.buildBoard(board); mBuilder.buildDisplay(display); mBuilder.buildOS(); &#125;&#125;// 测试代码public class Test &#123; public static void main(String[] args) &#123; Builder builder = new MacbookBuilder(); Director pcDirector = new Director(builder); pcDirector.construct(&quot;英特尔主板&quot;, &quot;Retina 显示器&quot;); System.out.println(&quot;Computer Info : &quot; + builder.create().toString()); &#125;&#125; 输出结果： Computer Info : Computer [mBoard=英特尔主板, mDisplay=Retina 显示器, mOS=Mac OS X 10.10] 上述示例中，通过具体的 MacbookBuilder 来构建 Macbook 对象，而 Director 封装了构建复杂产品对象的过程，对外隐藏构建细节。Builder 与 Director 一起将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的对象。 值得注意的是，在现实开发过程当中，Director 角色经常会被省略。而直接使用一个 Builder 来进行对象的组装，这个 Builder 通常为链式调用，它的关键点是每个 setter 方法都返回自身，也就是 return this，这样就使得 setter 方法可以链式调用，代码大致如下。1new TestBuilder().setA(&quot;A&quot;).setB(&quot;B&quot;).create(); 通过这种形式不仅去除了 Director 角色，整个结构也更加简单，也能对 Product 对象的组装过程有更精细的控制。 ANDROID 源码中的 Builder 模式 在 ANDROID 源码中，最常用到的 Builder 模式就是 AlertDialog.Builder，使用该 Builder 来构建复杂的 AlertDialog 对象。在开发过程中，我们经常用到 AlertDialog，具体示例如下。1234567891011121314151617181920212223242526private void showDialog(final Context context) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setIcon(R.drawable.taiji) .setTitle(&quot;Title&quot;) .setMessage(&quot;Message&quot;) .setPositiveButton(&quot;Button1&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(context, &quot;Button1&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;) .setNeutralButton(&quot;Button2&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(context, &quot;Button2&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;) .setNegativeButton(&quot;Button3&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(context, &quot;Button3&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;) .create() .show();&#125; 显示结果如下图所示。 从类名就可以看出这就是一个 Builder 模式，通过 Builder 对象来组装 Dialog 的各个部分，如 title、buttons、message 等，将 Dialog 的构造和表示进行分离。下面看看 AlertDialog 的相关源码。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class AlertDialog extends AppCompatDialog implements DialogInterface &#123; // AlertController 接收 Builder 成员变量 p 中的各个参数 final AlertController mAlert; protected AlertDialog(@NonNull Context context, @StyleRes int themeResId) &#123; super(context, resolveDialogTheme(context, themeResId)); // 构造 AlertController mAlert = new AlertController(getContext(), this, getWindow()); &#125; @Override public void setTitle(CharSequence title) &#123; super.setTitle(title); mAlert.setTitle(title); &#125; public void setMessage(CharSequence message) &#123; mAlert.setMessage(message); &#125; // 代码省略 public static class Builder &#123; // 1、存储 AlertDialog 的各个参数，如 title、message、icon 等 private final AlertController.AlertParams P; private final int mTheme; public Builder(@NonNull Context context) &#123; this(context, resolveDialogTheme(context, 0)); &#125; public Builder(@NonNull Context context, @StyleRes int themeResId) &#123; P = new AlertController.AlertParams(new ContextThemeWrapper( context, resolveDialogTheme(context, themeResId))); mTheme = themeResId; &#125; // 代码省略 // 2、设置各种参数 public Builder setTitle(@Nullable CharSequence title) &#123; P.mTitle = title; return this; &#125; public Builder setMessage(@StringRes int messageId) &#123; P.mMessage = P.mContext.getText(messageId); return this; &#125; public Builder setView(View view) &#123; P.mView = view; P.mViewLayoutResId = 0; P.mViewSpacingSpecified = false; return this; &#125; // 3、构建 AlertDialog，传递参数 public AlertDialog create() &#123; // 4、调用 new AlertDialog 构造对象，并且将参数传递给个体 AlertDialog final AlertDialog dialog = new AlertDialog(P.mContext, mTheme); // 5、将 P 中的参数应用到 dialog 中的 mAlert 对象中 P.apply(dialog.mAlert); dialog.setCancelable(P.mCancelable); if (P.mCancelable) &#123; dialog.setCanceledOnTouchOutside(true); &#125; dialog.setOnCancelListener(P.mOnCancelListener); dialog.setOnDismissListener(P.mOnDismissListener); if (P.mOnKeyListener != null) &#123; dialog.setOnKeyListener(P.mOnKeyListener); &#125; return dialog; &#125; &#125;&#125; 上述代码中，Builder 类可以设置 AlertDialog 中的 title、message、button 等参数，这些参数都存储在类型为 AlertController.AlertParams 的成员变量 P 中，AlertController.AlertParams 中包含了与 AlertDialog 视图中对应的成员变量。在调用 Builder 类的 create 函数时会创建 AlertDialog，并且将 Builder 成员变量 P 中保存的参数应用到 AlertDialog 的 mAlert 对象中，即 P.apply(dialog.mAlert) 代码段。我们再看看 apply 函数的实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public void apply(AlertController dialog) &#123; if (mCustomTitleView != null) &#123; dialog.setCustomTitle(mCustomTitleView); &#125; else &#123; if (mTitle != null) &#123; dialog.setTitle(mTitle); &#125; if (mIcon != null) &#123; dialog.setIcon(mIcon); &#125; if (mIconId != 0) &#123; dialog.setIcon(mIconId); &#125; if (mIconAttrId != 0) &#123; dialog.setIcon(dialog.getIconAttributeResId(mIconAttrId)); &#125; &#125; if (mMessage != null) &#123; dialog.setMessage(mMessage); &#125; if (mPositiveButtonText != null || mPositiveButtonIcon != null) &#123; dialog.setButton(DialogInterface.BUTTON_POSITIVE, mPositiveButtonText, mPositiveButtonListener, null, mPositiveButtonIcon); &#125; if (mNegativeButtonText != null || mNegativeButtonIcon != null) &#123; dialog.setButton(DialogInterface.BUTTON_NEGATIVE, mNegativeButtonText, mNegativeButtonListener, null, mNegativeButtonIcon); &#125; if (mNeutralButtonText != null || mNeutralButtonIcon != null) &#123; dialog.setButton(DialogInterface.BUTTON_NEUTRAL, mNeutralButtonText, mNeutralButtonListener, null, mNeutralButtonIcon); &#125; // For a list, the client can either supply an array of items or an // adapter or a cursor if ((mItems != null) || (mCursor != null) || (mAdapter != null)) &#123; createListView(dialog); &#125; if (mView != null) &#123; if (mViewSpacingSpecified) &#123; dialog.setView(mView, mViewSpacingLeft, mViewSpacingTop, mViewSpacingRight, mViewSpacingBottom); &#125; else &#123; dialog.setView(mView); &#125; &#125; else if (mViewLayoutResId != 0) &#123; dialog.setView(mViewLayoutResId); &#125;&#125; 在 apply 函数中，只是将 AlertParams 参数设置到 AlertController 中，例如，将标题设置到 Dialog 对应的标题视图中，将 Message 设置到内容视图中等。当我们获取到 AlertDialog 对象后，通过 show 函数就可以显示这个对话框。而 show 函数最终调用的是 Dialog 类的 show 函数。1234567891011121314151617181920212223242526272829303132333435363738394041public class Dialog implements DialogInterface, Window.Callback, KeyEvent.Callback, OnCreateContextMenuListener, Window.OnWindowDismissedCallback &#123; // 代码省略 public void show() &#123; // 已经是显示状态，则return if (mShowing) &#123; if (mDecor != null) &#123; if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123; mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR); &#125; mDecor.setVisibility(View.VISIBLE); &#125; return; &#125; mCanceled = false; // 1、onCreate 调用 if (!mCreated) &#123; dispatchOnCreate(null); &#125; // 2、onStart onStart(); // 3、获取 DecorView mDecor = mWindow.getDecorView(); // 代码省略 // 4、获取布局参数 WindowManager.LayoutParams l = mWindow.getAttributes(); // 5、将 mDecor 添加到 WindowManager 中 mWindowManager.addView(mDecor, l); mShowing = true; // 发送一个显示 Dialog 的消息 sendShowMessage(); &#125;&#125; 在 show 函数中主要做了如下几个事情：1）通过 dispatchOnCreate 函数来调用 AlertDialog 的 onCreate 函数；2）然后调用 AlertDialog 的 onStart 函数；3）最后将 Dialog 的 DecorView 添加到 WindowManager 中。 这里的 AlertDialog.Builder 同时扮演了上文中提到的 Builder、ConcreteBuilder、Director 的角色，简化了 Builder 模式的设计。当模块比较稳定，不存在一些变化时，可以在经典模式实现的基础上做出一些精简，而不是照搬 GOF 上的经典实现，更不要生搬硬套，使程序失去架构之美。 Builder 模式实战 配置 ImageLoader 的参数：缓存、图片加载中显示的图片、加载失败后显示的图片、图片加载策略、线程数等。123456789101112131415public class ImageLoader &#123; // 图片加载配置对象 private ImageLoaderConfig mConfig; // 省略单例模式代码 // 初始化 ImageLoader public void init(ImageLoaderConfig config) &#123; mConfig = config; // 检测配置的合法性，内部会根据配置做一些初始化操作 checkConfig(); // 代码省略 &#125; // 代码省略&#125; 把配置的代码基本上都封装到了 ImageLoaderConfig 和 Builder 对象中。其代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class ImageLoaderConfig &#123; // 图片缓存配置 private BitmapCache bitmapCache = new MemoryCache(); // 加载图片时的 loading 和加载失败的图片配置对象 private DisplayConfig displayConfig = new DisplayConfig(); // 加载策略 private LoadPolicy loadPolicy = new SerialPolicy(); // 线程数量，默认为 CPU 数量 + 1 private int threadCount = Runtime.getRuntime().availableProcessors() + 1; private ImageLoaderConfig() &#123;&#125; /** * 配置类的 Builder */ public static class Builder &#123; BitmapCache bitmapCache = new MemoryCache(); DisplayConfig displayConfig = new DisplayConfig(); LoadPolicy loadPolicy = new SerialPolicy(); int threadCount = Runtime.getRuntime().availableProcessors() + 1; public Builder setThreadCount(int threadCount) &#123; this.threadCount = threadCount; return this; &#125; public Builder setCache(BitmapCache bitmapCache) &#123; this.bitmapCache = bitmapCache; return this; &#125; public Builder setLoadingPlaceholder(int resId) &#123; displayConfig.loadingResId = resId; return this; &#125; public Builder setNotFoundPlaceholder(int resId) &#123; displayConfig.failedResId = resId; return this; &#125; public Builder setLoadPolicy(LoadPolicy loadPolicy) &#123; if (loadPolicy != null) &#123; loadPolicy = loadPolicy; &#125; return this; &#125; void applyConfig(ImageLoaderConfig config) &#123; config.bitmapCache = this.bitmapCache; config.displayConfig = this.displayConfig; config.loadPolicy = this.loadPolicy; config.threadCount = this.threadCount; &#125; // 根据已经设置好的属性创建配置对象 public ImageLoaderConfig create() &#123; ImageLoaderConfig config = new ImageLoaderConfig(); applyConfig(config); return config; &#125; &#125;&#125; 通过将 ImageLoaderConfig 的构造函数、字段私有化，使得外部不能访问内部属性，用户唯一能够设置属性的地方就是通过 Builder 对象了，也就是说用户只能通过 Builder 对象构造 ImageLoaderConfig 对象，这就是构建和表示相分离。 用户的使用代码如下所示。123456789private void initImageLoader() &#123; ImageLoaderConfig config = new ImageLoaderConfig.Builder() .setLoadingPlaceholder(R.drawable.loading) .setNotFoundPlaceholder(R.drawable.not_found) .setCache(new DoubleCache(this)) .setThreadCount(4) .setLoadPolicy(new ReversePolicy()).create(); ImageLoader.getInstance().init(config);&#125;]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02 设计模式——单例模式]]></title>
    <url>%2F2019%2F08%2F07%2FPATTERN%2F01%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 单例模式：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 确保某个类有且只有一个对象的场景，避免产生多个对象消耗过多的资源，或者某种类型的对象只应该有且只有一个。例如，创建一个对象需要消耗的资源过多，如要访问 IO 和数据库等资源，这是就要考虑使用单例模式。 实现单例模式主要有如下几个关键点： 构造函数不对外开放，一般为 private； 通过一个静态方法或者枚举返回单例类对象； 确保单例类的对象有且只有一个，尤其是在多线程环境下； 确保单例类对象在反序列化时不会重新构建对象。 单例对象如果持有 Context，那么很容易引发内存泄漏，此时需要注意传递给单例对象的 Context 最好是 Application Context。 示例 饿汉式在一个应用中，应该只有一个 ImageLoader 实例，这个 ImageLoader 中又含有线程池、缓存系统、网络请求等，很消耗资源。因此，没有理由让它构造多个实例。1234567public class ImageLoader &#123; private static ImageLoader sInstance = new ImageLoader(); private ImageLoader() &#123;&#125; public static ImageLoader getInstance() &#123; return sInstance; &#125;&#125; 上述写法又被称为饿汉式单例模式，在声明静态对象时就已经初始化，符合前面三条关键点，但在反序列化的情况下它们会重新创建对象。 反序列化我们知道通过序列化可以将一个单例的实例对象写到磁盘，然后再读回来，从而有效地获得一个实例。即使构造函数是私有的，反序列化时依然可以通过特殊的途径去创建类的一个新的实例，相当于调用该类的构造函数。反序列化操作提供了一个很特别的钩子函数，类中具有一个私有的 readResolve() 函数，这个函数可以让开发人员控制对象的反序列化。例如，如果要杜绝上述示例中的单例对象在反序列化时重新生成对象，那么必须加入 readResolve 函数。1234567891011121314public class ImageLoader implements Serializable &#123; private static final long serialVersionUID = 0L; private static ImageLoader sInstance = new ImageLoader(); private ImageLoader() &#123;&#125; public static ImageLoader getInstance() &#123; return sInstance; &#125; private Object readResolve() throws ObjectStreamException &#123; return sInstance; &#125;&#125; 也就是在 readResolve 方法中将单例对象返回，而不是重新生成一个新的对象。而对于枚举类，并不存在这个问题，因为即使反序列化它也不会重新生成新的实例。另外有两点需要注意： 可序列化类中的字段类型不是 Java 的内置类型，那么该字段类型也需要实现 Serializable 接口； 如果调整了可序列化类的内部结构，例如新增、去除某个字段，但没有修改 serialVersionUID，那么会引发 java.io.InvalidClassException 异常或者导致某个属性为 0 或者 null。此时最好的方案是我们直接将 serialVersionUID 设置为 0L，这样即使修改了类的内部结构，我们反序列化不会抛出该异常，只是那些新修改的字段会为 0 或者 null。 其他方式 懒汉式懒汉模式是声明一个静态变量，并且在用户第一次调用 getInstance 时进行初始化，而上述的恶汉模式是在声明静态对象时就已经初始化。实现如下：1234567891011public class ImageLoader &#123; private static ImageLoader sInstance; private ImageLoader() &#123;&#125; public static ImageLoader getInstance() &#123; if (sInstance == null) &#123; sInstance = new ImageLoader(); &#125; return sInstance; &#125;&#125; 这种模式不能保证在多线程环境下确保单例类的对象有且只有一个，所以我们会添加 synchronized 关键字进行同步。但若是将 synchronized 添加到 getInstance 函数上，会出现每次调用该方法都进行同步的情况，造成不必要的同步开销。代码如下所示：12345678910public class ImageLoader &#123; private static ImageLoader sInstance; private ImageLoader() &#123;&#125; public static synchronized ImageLoader getInstance() &#123; if (sInstance == null) &#123; sInstance = new ImageLoader(); &#125; return sInstance; &#125; 上述方式不建议使用，但在它的基础上添加双重检查锁定机制（Double Check Lock，DCL）进行优化。123456789101112131415public class ImageLoader &#123; private static ImageLoader sInstance; private ImageLoader() &#123;&#125; public static ImageLoader getInstance() &#123; if (sInstance == null) &#123; synchronized (ImageLoader.class) &#123; if (sInstance == null) &#123; sInstance = new ImageLoader(); &#125; &#125; &#125; return sInstance; &#125;&#125; 这样一来，DCL 解决了资源消耗、多余同步、线程安全等问题，似乎很完美，但笔者也不推荐这种写法。它还是会在某种情况下出现失效的问题，这个问题被称为双重检查锁定失效，在《Java 并发编程实践》一书的最后谈到了这个问题，并指出这种“优化”是丑陋的，不赞成使用。 静态内部类单例模式代码如下：1234567891011public class ImageLoader &#123; private ImageLoader() &#123;&#125; public static ImageLoader getInstance() &#123; return ImageLoaderHolder.sInstance; &#125; // 静态内部类 private static class ImageLoaderHolder &#123; private static final ImageLoader sInstance = new ImageLoader(); &#125;&#125; 当第一次加载 ImageLoader 类时并不会初始化 sInstance，只有在第一次调用 ImageLoader 的 getInstance 方法时才会导致 sInstance 被初始化。因此，第一次调用 getInstance 方法会导致虚拟机加载 ImageLoaderHolder 类，这种方式不仅能确保线程安全，也能够保证单例对象的唯一性，同时也延迟了单例的实例化，所以这是推荐使用的单例模式实现方式。如果有反序列化的情况下，要加入 readResolve 方法，具体代码参考饿汉式反序列章节。 枚举单例前面讲解的单例模式实现方式不是稍显麻烦就是会在某些情况下出现问题，还有没有更简单的实现方式呢？我们看看下面的实现。123456public enum SingletonEnum &#123; INSTANCE; public void doSomething() &#123; System.out.println(&quot;do sth.&quot;); &#125;&#125; 写法简单，而且保证线程安全、序列化与反序列化安全、反射安全。奈何 ANDROID 官网不建议使用 Enums，占用内存多（Enums often require more than twice as much memory as static constants.）。关于 Enum 的使用博客。 使用容器实现单例模式具体代码如下：123456789101112131415public class SingletonManager &#123; private static Map&lt;String, Object&gt; objMap = new HashMap&lt;&gt;(); private SingletonManager() &#123;&#125; public static void registerService(String key, Object instance) &#123; if (!objMap.containsKey(key)) &#123; objMap.put(key, instance); &#125; &#125; public static Object getService(String key) &#123; return objMap.get(key); &#125;&#125; 在程序的初始，将多种单例类型注入到一个统一的管理类中，在使用时根据 key 获取对象对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合。 ANDROID 源码中的单例模式 在 ANDROID 系统中，我们经常会通过 Context 获取系统级别的服务，如 WindowsManagerService、ActivityManagerService 等，更常用的是一个 LayoutInflater 的类。这些服务会在合适的时候以单例的形式注册在系统中，在我们需要的时候就通过 Context 的 getSystemService(String name) 获取。我们以 LayoutInflater 为例来说明，平时我们使用 LayoutInflater 较为常见的地方是在 ListView 的 getView 方法中。1234567891011@Overridepublic void getView(int position, View convertView, ViewGroup parent) &#123; View itemView = null; if (convertView == null) &#123; itemView = LayoutInflater.from(mContext).inflate(mLayoutId, null); ... &#125; else &#123; ... &#125; ...&#125; 通常我们使用 LayoutInflater.from(Context) 来获取 LayoutInflater 服务，下面看看 LayoutInflater.from(Context) 的实现。12345678public static LayoutInflater from(Context context) &#123; LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService( Context.LAYOUT_INFLATER_SERVICE); if (LayoutInflater == null) &#123; throw new AssertionError(&quot;LayoutInflater not found.&quot;); &#125; return LayoutInflater;&#125; 可以看到 from(Context) 函数内部调用的是 Context 类的 getSystemService(String key) 方法，我们跟踪到 Context 类看到，该类是抽象类。123public abstract class Context &#123; ...&#125; getView 中使用的 Context 对象的具体实现类是什么呢？其实在 Application、Activity、Service 中都会存在一个 Context 对象，即 Context 的总个数为 Activity 个数 + Service 个数 + 1。而 ListView 通常都是显示在 Activity 中，那么我们就以 Activity 中的 Context 来分析。 我们知道，一个 Activity 的入口是 ActivityThread 的 main 函数，在 main 函数中创建一个新的 ActivityThread 对象，并且启动消息循环（UI 线程），创建新的 Activity、新的 Context 对象，然后将该 Context 对象传递给 Activity。下面我们看看 ActivityThread 源代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void main(String[] args) &#123; // 代码省略 Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); // 主线程消息循环 Looper.prepareMainLooper(); // 创建 ActivityThread 对象 ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; Looper.loop();&#125;private void attach(boolean system, long startSeq) &#123; sCurrentActivityThread = this; mSystemThread = system; // 不是系统应用 if (!system) &#123; ViewRootImpl.addFirstDrawHandler(new Runnable() &#123; @Override public void run() &#123; ensureJitEnabled(); &#125; &#125;); android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;, UserHandle.myUserId()); RuntimeInit.setApplicationObject(mAppThread.asBinder()); final IActivityManager mgr = ActivityManager.getService(); try &#123; // 关联 mAppThread mgr.attachApplication(mAppThread, startSeq); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; // 代码省略 &#125; // 代码省略&#125; 在 main 方法中，我们创建一个 ActivityThread 对象后，调用了其 attach 函数，并且参数为 false，即非系统应用，会通过 Binder 机制与 ActivityManagerService 通信，并且最终调用 handleLaunchActivity 函数，该函数的实现如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public Activity handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent) &#123; // 代码省略 final Activity a = performLaunchActivity(r, customIntent); // 代码省略&#125;private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; // 代码省略 // 1、获取 Context 对象 ContextImpl appContext = createBaseContextForActivity(r); Activity activity = null; try &#123; java.lang.ClassLoader cl = appContext.getClassLoader(); // 2、创建 Activity activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); // 代码省略 &#125; catch (Exception e) &#123; // 代码省略 &#125; try &#123; // 创建 Application Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) &#123; CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); // 3、将 appContext 等对象 attach 到 activity 中 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback); // 代码省略 // 4、调用 Activity 的 onCreate 方法 if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; // 代码省略 &#125; &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; // 代码省略 &#125; return activity;&#125;private ContextImpl createBaseContextForActivity(ActivityClientRecord r) &#123; // 5、创建 Context 对象，实现类是 ContextImpl ContextImpl appContext = ContextImpl.createActivityContext( this, r.packageInfo, r.activityInfo, r.token, displayId, r.overrideConfig); // 代码省略 return appContext;&#125; 通过上面 1~5 注释处的代码分析可以知道，Context 的实现类为 ContextImpl。继续跟踪 ContextImpl 类。1234567891011class ContextImpl extends Context &#123; // The system service cache for the system services that are cached per-ContextImpl. final Object[] mServiceCache = SystemServiceRegistry.createServiceCache(); @Override public Object getSystemService(String name) &#123; return SystemServiceRegistry.getSystemService(this, name); &#125; // 代码省略&#125; 继续跟踪 SystemServiceRegistry 类。123456789101112131415161718192021222324252627282930313233final class SystemServiceRegistry &#123; // 1、Service 容器 private static final HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS = new HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;(); // 2、注册服务器 private static &lt;T&gt; void registerService(String serviceName, Class&lt;T&gt; serviceClass, ServiceFetcher&lt;T&gt; serviceFetcher) &#123; SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName); SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher); &#125; // 静态语句块，第一次加载该类时执行（只执行一次，保证实例的唯一性） static &#123; // 代码省略 // 注册 LayoutInflater Service registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class, new CachedServiceFetcher&lt;LayoutInflater&gt;() &#123; @Override public LayoutInflater createService(ContextImpl ctx) &#123; return new PhoneLayoutInflater(ctx.getOuterContext()); &#125;&#125;); // 代码省略 &#125; // 根据 key 获取对应的服务 public static Object getSystemService(ContextImpl ctx, String name) &#123; ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null; &#125; // 代码省略&#125; 从 SystemServiceRegistry 类的部分代码中可以看到，在虚拟机第一次加载该类时会注册各种 ServiceFetcher，其中就包含了 LayoutInflater Service。将这些服务以键值对的形式储存在一个 HashMap 中，用户使用时只需要根据 key 来获取到对应的 ServiceFetcher，然后通过 ServiceFetcher 对象的 getService 函数来获取具体的服务对象。当第一次获取时，会调用 ServiceFetcher 的 createService 函数创建服务对象，然后将该对象缓存到一个列表中，下次再取时直接从缓存中获取，避免重复创建对象，从而达到单例的效果。这种模式就是前文描述的通过容器实现单例模式。系统核心服务以单例形式存在，减少了资源消耗。]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[00.6 ANDROID 面向对象的六大原则——迪米特原则]]></title>
    <url>%2F2019%2F08%2F06%2FPATTERN%2F00.6%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[第一篇：单一职责原则第二篇：开闭原则第三篇：里氏替换原则第四篇：依赖倒置原则第五篇：接口隔离原则第六篇：本文 迪米特原则 英文全称为 Law of Demeter，LOD，也称为最少知识原则，意思都是一个对象应该对其他对象有最少的了解。通俗的讲，一个类应该对自己需要耦合或调用的类知道得最少，类的内部如何实现与调用者或者依赖者没关系，调用者或者依赖者只需要知道它需要的方法即可，其他的可一概不用管。类与类之间的关系越密切，耦合越大，当一个类发生变化时，对另一个类的影响也越大。 迪米特原则还有一个英文解释是 Only talk to your immediate friends，翻译过来就是：只与直接的朋友通信。什么叫做直接的朋友？每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就成为了朋友关系，这种关系的类型有很多，如组合、聚合、依赖等。 下面我们就以租房为例来讲讲迪米特原则的应用。 举例：在北京租房 在北京租房绝大多数都是通过中介找房。我们设定的情况为：我只要求房间的面积和租金，其他的一概不管，中介将符合我们要求的房子提供给我就可以。下面我们看看这个示例。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 房间 */public class Room &#123; public float area; public float price; public Room(float area, float price) &#123; this.area = area; this.price = price; &#125; @Override public String toString() &#123; return &quot;Room&#123;&quot; + &quot;area=&quot; + area + &quot;, price=&quot; + price + &apos;&#125;&apos;; &#125;&#125;/** * 中介 */public class Mediator &#123; List&lt;Room&gt; mRooms = new ArrayList&lt;&gt;(); public Mediator() &#123; for (int i = 0; i &lt; 5; i++) &#123; mRooms.add(new Room(14 + i, (14 + i) * 150)); &#125; &#125; public List&lt;Room&gt; getAllRooms() &#123; return mRooms; &#125;&#125;/** * 租户 */public class Tenant &#123; public void rentRoom(float roomArea, float roomPrice, Mediator mediator) &#123; List&lt;Room&gt; rooms = mediator.getAllRooms(); for (Room room : rooms) &#123; if (isSuitable(roomArea, roomPrice, room)) &#123; System.out.println(&quot;租到房间啦！&quot; + room); break; &#125; &#125; &#125; private boolean isSuitable(float roomArea, float roomPrice, Room room) &#123; return room.area &gt;= roomArea &amp;&amp; room.price &lt;= roomPrice; &#125;&#125; 从上面的代码可以看到，Tenant 不仅依赖了 Mediator 类，还需要频繁地与 Room 类打交道。租户类的要求只是通过中介找到一间适合自己的房间罢了，如果把这些检测条件都放在 Tenant 类中，那么中介类的功能就被弱化，而且导致了 Tenant 与 Room 的耦合较高，因为 Tenant 必须知道许多关于 Room 的细节。当 Room 变化时 Tenant 也必须跟着变化。Tenant 又与 Mediator 耦合，这就出现了纠缠不清的关系。这个时候就需要我们分清谁才是我们真正的“朋友”，在我们所设定的情况下，显然是 Mediator。上述代码的结构下图所示。 既然是耦合太严重，那我们就只能解耦了。首先要明确的是，我们只和我们的朋友通信，这里就是指 Mediator 对象。必须将 Room 相关的操作从 Tenant 中移除，而这些操作案例应该属于 Mediator。我们进行如下重构。12345678910111213141516171819202122232425262728293031323334/** * 中介 */public class Mediator &#123; List&lt;Room&gt; mRooms = new ArrayList&lt;&gt;(); public Mediator() &#123; for (int i = 0; i &lt; 5; i++) &#123; mRooms.add(new Room(14 + i, (14 + i) * 150)); &#125; &#125; public Room rentOut(float area, float price) &#123; for (Room room : mRooms) &#123; if (isSuitable(area, price, room)) &#123; return room; &#125; &#125; return null; &#125; private boolean isSuitable(float roomArea, float roomPrice, Room room) &#123; return room.area &gt;= roomArea &amp;&amp; room.price &lt;= roomPrice; &#125;&#125;/** * 租户 */public class Tenant &#123; public void rentRoom(float roomArea, float roomPrice, Mediator mediator) &#123; mediator.rentOut(roomArea, roomPrice); &#125;&#125; 重构后的结构图如下所示。 只是将对于 Room 的判定操作移到了 Mediator 类中，这本应该是 Mediator 的职责，根据租户设定的条件查找符合要求的房子，并且将结果交给租户就可以了。租户并不需要知道太多关于 Room 的细节，比如与房东签合同，房东的房产证是不是真的，房内的设施坏了之后要找谁谁修等。当我们通过我们的“朋友”——中介租了房之后，所有的事情我们都通过与中介沟通就好了，房东、维修师傅等这些角色并不是我们直接的“朋友”。“只与直接的朋友通信”这简单的几个字就能够将我们从复杂的关系网中抽离出来，使程序耦合度更低、稳定性更好。 举例二：ImageCache 前面博客中的图片加载器项目，ImageCache 就是用户的直接朋友，而 SD 卡缓存内部使用了 FileOutputStream，这个 FileOutputStream 就不属于用户的直接朋友了。因此，用户完全不知道它的存在，用户只需要与 ImageCache 对象打交的即可。将图片存到 SD 卡中的代码如下。1234567891011121314151617181920212223// SD 卡缓存 DiskCache 类public class DiskCache implements ImageCache &#123; private static String CACHE_DIR = Environment.getExternalStorageDirectory() + &quot;/&quot;; public Bitmap get(String url) &#123; return BitmapFactory.decodeFile(CACHE_DIR + ImageUtil.urlToMd5(url)); &#125; public void put(String url, Bitmap bitmap) &#123; FileOutputStream fileOutputStream = null; try &#123; fileOutputStream = new FileOutputStream(CACHE_DIR + ImageUtil.urlToMd5(url)); bitmap.compress(Bitmap.CompressFormat.PNG, 100, fileOutputStream); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; CloseUtils.closeQuietly(fileOutputStream); &#125; &#125;&#125; 现在领导要求使用 jake wharton 的 DiskLruCache 来替换 FileOutputStream。代码如下：123456789101112131415161718public void put(String url, Bitmap bitmap) &#123; DiskLruCache.Editor editor = null; try &#123; editor = mDiskLruCache.edit(url); if (null != editor) &#123; OutputStream outputStream = editor.newOutputStream(0); if (writeBitmapToDisk(bitmap, outputStream)) &#123; // 写入 Disk 缓存 editor.commit(); &#125; else &#123; editor.abort(); &#125; CloseUtils.closeQuietly(outputStream); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; SD 卡缓存的具体实现虽然被替换了，但用户根本不会感知到。因为用户根本不知道 FileOutputStream 和 DiskLruCache 的存在，他们没有与 FileOutputStream 或 DiskLruCache 进行通信，他们只认识直接“朋友”——ImageCache，ImageCache 将一切细节隐藏在直接“朋友”的外衣之下，使得系统具有更低的耦合性和更好的可扩展性。]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[00.5 ANDROID 面向对象的六大原则——接口隔离原则]]></title>
    <url>%2F2019%2F08%2F05%2FPATTERN%2F00.5%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[第一篇：单一职责原则第二篇：开闭原则第三篇：里氏替换原则第四篇：依赖倒置原则第五篇：本文第六篇：迪米特原则 接口隔离原则 英文全称是 Interface Segregation Principles，ISP。其定义是：客户端不应该依赖它不需要的接口。另一种定义是：类间的依赖关系应该建立在最小的接口上。接口隔离原则将非常庞大、臃肿的接口拆分成更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。接口隔离原则的目的是系统解开耦合，从而容易重构、更改和重新部署。 说白了就是，让客户端依赖的接口尽可能地小。这样说可能还有点抽象，我们还是以一个示例来说明一下。在此之前我们来说一个场景，在 Java 6 及之前的 JDK 版本，有一个非常讨厌的问题，那就是在使用了 OutputStream 或者其他可关闭的对象之后，我们必须保证他们最终被关闭了，我们的 SD 卡缓存类中就有这样的代码。123456789101112131415161718public void put(String url, Bitmap bitmap) &#123; FileOutputStream fileOutputStream = null; try &#123; fileOutputStream = new FileOutputStream(CACHE_DIR + ImageUtil.urlToMd5(url)); bitmap.compress(Bitmap.CompressFormat.PNG, 100, fileOutputStream); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (fileOutputStream != null) &#123; try &#123; fileOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 我们看到的这段代码可读性非常差，各种 try…catch 嵌套都是些简单的代码，但是会严重影响代码的可读性，并且多层次的大括号很容易将代码写到错误的层级中。 在 Java 中有一个 Closeable 接口，该接口标识了一个可关闭的对象，它只有一个 close 方法。如下图所示： 我们要讲的 FileOutputStream 类就实现了这个接口。我们从上图可以看到，还有 100 多个类实现了 Closeable 这个接口。这意味着，在关闭这 100 多个类型的对象时，都需要写出像 put 方法中 finally 代码段那样的代码。这还了得，反正我是不能忍。既然都是实现了 Closeable 接口，那只要一个方法统一来关闭这些对象不就可以了么？于是写来来如下的工具类。1234567891011121314151617package com.xxt.xtest;import java.io.Closeable;public class CloseUtils &#123; private CloseUtils() &#123;&#125; public static void closeQuietly(Closeable closeable) &#123; if (null != closeable) &#123; try &#123; closeable.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 我们再看看把这段代码运用到上述的 put 方法中的效果如何。123456789101112public void put(String url, Bitmap bitmap) &#123; FileOutputStream fileOutputStream = null; try &#123; fileOutputStream = new FileOutputStream(CACHE_DIR + ImageUtil.urlToMd5(url)); bitmap.compress(Bitmap.CompressFormat.PNG, 100, fileOutputStream); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; CloseUtils.closeQuietly(fileOutputStream); &#125;&#125; 代码简洁了很多！而且这个 closeQuietly 方法可以运用到各类可关闭的对象中，保证了代码的重用性。CloseUtils 的 closeQuietly 方法的基本原理就是依赖于 Closeable 抽象而不是具体实现，并且建立在最小化依赖原则的基础上，它只需要知道这个对象是可关闭的，其他的一概不关心，也就是这里的接口隔离原则。 试想一下，如果在只是需要关闭一个对象时，它却暴露了其他的接口函数，如 OutputStream 的 write 方法，这就使得更多的细节暴露在客户端代码面前，不仅没有很好地隐藏实现，还增加了接口的使用难度。而通过 Closeable 接口将可关闭的对象抽象起来，这样只需要客户端依赖于 Closeable 就可以对客户端隐藏其他的接口信息，客户端代码只需要知道这个对象可关闭（只可调用 close 方法）即可。 之前博客中设计的 ImageLoader 持有的 ImageCache 就是接口隔离原则的运用。ImageLoader 只需要知道该缓存对象有存、取缓存图片的接口即可，其他的一概不管，这就使得缓存功能的具体实现对 ImageLoader 隐藏。这就是用最小化接口隔离了实现类的细节，也促使我们将庞大的接口拆分到更细粒度的接口当中，这使得我们的系统具有更低的耦合性、更高的灵活性。 举例：拆分接口 依据接口隔离原则，将下图中臃肿的接口 I 拆分为独立的几个接口。 类 A 依赖接口 I 中的方法1、方法2、方法3，类 PA 是对类 A 依赖的实现。类 B 依赖接口 I 中的方法1、方法4、方法5，类 PB 是对类 B 依赖的实现。对于类 PA 和类 PB 来说，虽然他们都存在着用不到的方法（也就是图中划红线的方法），但由于实现了接口 I，所以也必须要实现这些用不到的方法。用代码表示如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980interface I &#123; void method1(); void method2(); void method3(); void method4(); void method5();&#125;class A &#123; public void depend1(I i)&#123; i.method1(); &#125; public void depend2(I i)&#123; i.method2(); &#125; public void depend3(I i)&#123; i.method3(); &#125;&#125;class B &#123; public void depend1(I i)&#123; i.method1(); &#125; public void depend2(I i)&#123; i.method4(); &#125; public void depend3(I i)&#123; i.method5(); &#125;&#125;class PA implements I &#123; public void method1() &#123; System.out.println(&quot;类 PA 实现接口 I 的方法1&quot;); &#125; public void method2() &#123; System.out.println(&quot;类 PA 实现接口 I 的方法2&quot;); &#125; public void method3() &#123; System.out.println(&quot;类 PA 实现接口 I 的方法3&quot;); &#125; // 对于类 PA 来说，method4 和 method5 不是必需的，但是由于接口 I 中有这两个方法 // 所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现 public void method4() &#123;&#125; public void method5() &#123;&#125;&#125;class PB implements I &#123; public void method1() &#123; System.out.println(&quot;类 PB 实现接口 I 的方法1&quot;); &#125; // 对于类 PB 来说，method2 和 method3 不是必需的，但是由于接口 I 中有这两个方法 // 所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现 public void method2() &#123;&#125; public void method3() &#123;&#125; public void method4() &#123; System.out.println(&quot;类 PB 实现接口 I 的方法4&quot;); &#125; public void method5() &#123; System.out.println(&quot;类 PB 实现接口 I 的方法5&quot;); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; A a = new A(); a.depend1(new PA()); a.depend2(new PA()); a.depend3(new PA()); B b = new B(); b.depend1(new PB()); b.depend2(new PB()); b.depend3(new PB()); &#125;&#125; 可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口 I 进行拆分。在这里我们将原有的接口 I 拆分为三个接口，拆分后的设计如下图所示： 代码更改如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061interface I1 &#123; void method1();&#125;interface I2 &#123; void method2(); void method3();&#125;interface I3 &#123; void method4(); void method5();&#125;class A &#123; public void depend1(I1 i)&#123; i.method1(); &#125; public void depend2(I2 i)&#123; i.method2(); &#125; public void depend3(I2 i)&#123; i.method3(); &#125;&#125;class B &#123; public void depend1(I1 i)&#123; i.method1(); &#125; public void depend2(I3 i)&#123; i.method4(); &#125; public void depend3(I3 i)&#123; i.method5(); &#125;&#125;class PA implements I1, I2 &#123; public void method1() &#123; System.out.println(&quot;类 PA 实现接口 I1 的方法1&quot;); &#125; public void method2() &#123; System.out.println(&quot;类 PA 实现接口 I2 的方法2&quot;); &#125; public void method3() &#123; System.out.println(&quot;类 PA 实现接口 I2 的方法3&quot;); &#125;&#125;class PB implements I1, I3 &#123; public void method1() &#123; System.out.println(&quot;类 PB 实现接口 I1 的方法1&quot;); &#125; public void method4() &#123; System.out.println(&quot;类 PB 实现接口 I2 的方法4&quot;); &#125; public void method5() &#123; System.out.println(&quot;类 PB 实现接口 I2 的方法5&quot;); &#125;&#125; 接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为 3 个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。 说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。 采用接口隔离原则对接口进行约束时，要注意以下几点： 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化，所以一定要适度。 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[00.4 ANDROID 面向对象的六大原则——依赖倒置原则]]></title>
    <url>%2F2019%2F08%2F04%2FPATTERN%2F00.4%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[第一篇：单一职责原则第二篇：开闭原则第三篇：里氏替换原则第四篇：本文第五篇：接口隔离原则第六篇：迪米特原则 依赖倒置原则英文全称是 Dependence Inversion Principle，缩写 DIP。它指代了一种特定的解耦形式，使得高层次的模块不依赖于低层次模块的实现细节，即依赖模块被颠倒了。它包含了以下几个含义： 高层模块不应该依赖低层模块，两者都应该依赖其抽象； 抽象不应该依赖细节； 细节应该依赖抽象。 在 Java 语言中，抽象就是指接口或抽象类，两者都是不能直接被实例化的；细节就是实现类，实现接口或继承抽象类而产生的类就是细节，可以被直接实例化 (new)。高层模块就是调用端，底层模块就是具体实现类。依赖倒置原则在 Java 语言中的表现就是：模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。概括的说就是面向接口编程，或者说面向抽象编程，这里的抽象指的是接口或者抽象类。 如果类与类直接依赖于细节，那么它们直接就有直接的耦合，当具体实现变化时，意味着要同时修改依赖者的代码，这限制了系统的可扩展性。 在下面的代码中，ImageLoader 直接依赖于 MemoryCache，这个 MemoryCache 是一个具体实现，而不是一个抽象类或者接口。这导致了 ImageLoader 直接依赖了具体细节，当 MemoryCache 不能满足 ImageLoader 而需要被其他缓存实现替换时，此时就必须修改 ImageLoader 的代码。1234567891011121314151617181920public class ImageLoader &#123; // 内存缓存（直接依赖于细节） MemoryCache mMemoryCache = new MemoryCache(); // 加载图片到 ImageView 中 public void displayImage(String url, ImageView imageView) &#123; Bitmap bitmap = mMemoryCache.get(url); if (bitmap == null) &#123; downloadImage(url, imageView); &#125; else &#123; imageView.setImageBitmap(bitmap); &#125; &#125; public void setImageCache(MemoryCache cache) &#123; mMemoryCache = cache; &#125; ...&#125; 随着产品的升级，用户发现 MemoryCache 已经不能满足需求，用户需要的 ImageLoader 可以将图片同时缓存到内存和 SD 卡中，或者可以让用户自定义实现缓存。修改原有代码也不符合开闭原则。 正确的做法是依照依赖倒置原则依赖抽象，而不依赖具体实现。如下所示：1234567891011121314151617181920212223242526public interface ImageCache &#123; Bitmap get(String url); void put(String url, Bitmap bitmap);&#125;public class ImageLoader &#123; // 图片缓存类，依赖于抽象，并且有一个默认的实现 ImageCache mImageCache = new MemoryCache(); // 加载图片到 ImageView 中 public void displayImage(String url, ImageView imageView) &#123; Bitmap bitmap = mMemoryCache.get(url); if (bitmap == null) &#123; downloadImage(url, imageView); &#125; else &#123; imageView.setImageBitmap(bitmap); &#125; &#125; // 注入缓存实现 public void setImageCache(ImageCache cache) &#123; mImageCache = cache; &#125; ...&#125; 在这里，我们建立了 ImageCache 抽象，并且让 ImageLoader 依赖于抽象而不是具体细节。当需求发生变化时，我们只需要实现 ImageCache 类或者继承其他已有的 ImageCache 子类完成相应的缓存功能，然后将具体的实现注入到 ImageLoader 即可实现缓存功能的替换，这就保证了缓存系统的可扩展性，有了拥抱变化的能力，这就是依赖倒置原则。 举例：涛哥开奔驰 先不考虑依赖倒置原则，看一下如下的设计： 从上面的类图中可以看出，司机类和奔驰车类都属于细节，并没有实现或继承抽象，它们是对象级别的耦合。通过类图可以看出司机有一个 drive() 方法，用来开车，奔驰车有一个 run() 方法，用来表示车辆运行，并且奔驰车类依赖于司机类，用户模块表示高层模块，负责调用司机类和奔驰车类。 可用以下代码表示：1234567891011121314151617181920212223public class Driver &#123; // 司机的主要职责就是驾驶汽车 public void drive(Benz benz)&#123; benz.run(); &#125;&#125;public class Benz &#123; // 汽车肯定会跑 public void run() &#123; System.out.println(&quot;奔驰汽车开始运行...&quot;); &#125;&#125;// 高层模块public class Client &#123; public static void main(String[] args) &#123; Driver taoGe = new Driver(); Benz benz = new Benz(); // 司机开奔驰车 taoGe.drive(benz); &#125;&#125; 这样的设计乍一看好像也没有问题，涛哥只管开着他的奔驰车就好。但是假如有一天他不想开奔驰了，想换一辆宝马车玩玩怎么办呢？我们当然可以新建一个宝马车类，也给它弄一个 run() 方法，但问题是，这辆车有是有了，但是涛哥却不能开啊，因为司机类里面并没有宝马车的依赖。要想解决问题，只能修改代码。12345public class BMW &#123; public void run()&#123; System.out.println(&quot;宝马汽车开始运行...&quot;); &#125;&#125; 上面的设计没有使用依赖倒置原则，我们已经发现，模块与模块之间耦合度太高，生产力太低，只要需求一变就需要大面积重构，说明这样的设计是不合理。现在我们引入依赖倒置原则，重新设计的类图如下： 可用以下代码表示：123456789101112131415161718192021222324252627282930313233343536373839// 将司机模块抽象为一个接口public interface IDriver &#123; void drive(ICar car);&#125;public class Driver implements IDriver &#123; public void drive(ICar car)&#123; car.run(); &#125;&#125;// 将汽车模块抽象为一个接口：可以是奔驰汽车，也可以是宝马汽车public interface ICar &#123; void run();&#125;public class Benz implements ICar &#123; public void run()&#123; System.out.println(&quot;奔驰汽车开始运行...&quot;); &#125;&#125;public class BMW implements ICar &#123; public void run()&#123; System.out.println(&quot;宝马汽车开始运行...&quot;); &#125;&#125;// 高层模块public class Client &#123; public static void main(String[] args) &#123; IDriver taoGe = new Driver(); ICar benz = new Benz(); // 涛哥开奔驰 taoGe.drive(benz); // 涛哥开宝马 taoGe.drive(new BMW()); &#125;&#125; 如此设计，涛哥再也不怕有新车不能开的情况了。 依赖的三种方法 接口声明依赖对象： 在接口的方法中声明依赖对象，就如上面的例子。构造函数传递依赖对象：在类中通过构造函数声明依赖对象，按照依赖注入的说法，这种方式叫做构造函数注入。12345678910111213141516public interface IDriver &#123; void drive();&#125;public class Driver implements IDriver&#123; private ICar car; // 构造函数注入 public Driver(ICar car)&#123; this.car = car; &#125; public void drive(ICar car)&#123; this.car.run(); &#125;&#125; Setter 方法传递依赖对象：在抽象中设置 Setter 方法声明依赖对象。1234567891011121314151617public interface IDriver&#123; // 注入依赖 void setCar(ICar car); void drive();&#125;public class Driver implements IDriver &#123; private ICar car; public void setCar(ICar car)&#123; this.car = car; &#125; public void drive()&#123; this.car.run(); &#125;&#125; 深入理解 依赖倒置原则的本质就是通过抽象（抽象类或接口）使各个类或模块实现彼此独立，不互相影响，实现模块间的松耦合。在项目中使用这个规则需要以下原则： 每个类尽量都要有接口或抽象类，或者抽象类和接口都有。 变量的表面类型尽量是接口或者抽象类。 任何类都不应该从具体类派生。 尽量不要重写基类已经写好的方法（里式替换原则）。如果基类是一个抽象类，而这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会有一定的影响。 结合里式替换原则来使用： 结合里式替换原则和依赖倒置原则我们可以得出一个通俗的规则，接口负责定义 public 属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化。 总结：依赖倒置原则的核心就是面向抽象（抽象类或者接口）编程。]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[00.3 ANDROID 面向对象的六大原则——里氏替换原则]]></title>
    <url>%2F2019%2F08%2F03%2FPATTERN%2F00.3%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[第一篇：单一职责原则第二篇：开闭原则第三篇：本文第四篇：依赖倒置原则第五篇：接口隔离原则第六篇：迪米特原则 前一篇博文中的图片加载器项目，MemoryCache、DiskCache、DoubleCache 都可以替换 ImageCache 的工作，并且能够保证行为的正确性。ImageCache 建立了获取缓存图片、保存缓存图片的接口规范，MemoryCache 等根据接口规范实现了相应的功能，用户只需要在使用时指定具体的缓存对象就可以动态地替换 ImageLoader 中的缓存策略。这就使得 ImageLoader 的缓存系统具有了无限的可能性，也就是保证了可扩展性。 想象一种情况，当 ImageLoader 中的 setImageCache(ImageCache cache) 中的 cache 对象不能被子类所替换，那么用户如何设置不同的缓存对象，以及用户如何定义自己的缓存实现，通过前文中的 useDiskCache 方法吗？显然不是的，里氏替换原则就为这类问题提供了指导原则，也就是建立抽象，通过抽象建立规范，具体的实现在运行时替换掉抽象，保证系统的扩展性、灵活性。 开闭原则和里氏替换原则往往是生死相依、不离不弃的，通过里氏替换来达到对扩展开放，对修改关闭的效果。然而，这两个原则都同时强调了一个 OOP 的重要特性——抽象。因此，在开发过程中运用抽象是走向代码优化的重要一步。 定义 里氏替换原则（Liskov Substitution Principle，LSP）有两种定义：● If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为 S 的对象 o1，都有类型为 T 的对象 o2，使得以 T 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 S 是类型 T 的子类型。） ● Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。） 问题 里氏替换原则的核心原理是抽象，抽象又依赖于继承这个特性。继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。 继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。 问题描述：有一功能 P1，由类 A 完成。现需要将功能 P1 进行扩展，扩展后的功能为 P，其中 P 由原有功能 P1 与新功能 P2 组成。新功能 P 由类 A 的子类 B 来完成，则子类 B 在完成新功能 P2 的同时，有可能会导致原有功能 P1 发生故障。 解决方案：当使用继承时，遵循里氏替换原则。类 B 继承类 A 时，除添加新的方法完成新增功能 P2 外，尽量不要重写父类 A 的方法，也尽量不要重载父类 A 的方法。 举例说明：我们需要完成一个两数相减的功能 P1，由类 A 来负责。12345678910111213class A &#123; public int func1(int a, int b) &#123; return a - b; &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; A a = new A(); System.out.println(&quot;100-50=&quot; + a.func1(100, 50)); System.out.println(&quot;100-80=&quot; + a.func1(100, 80)); &#125;&#125; 运行结果：100-50=50100-80=20 后来，我们需要增加一个新的功能 P2：完成两数相加，然后再与100求和，由类 B 来负责。即类 B 需要完成两个功能： P1：两数相减。 P2：两数相加，然后再加100。 由于类 A 已经实现了第一个功能，所以类 B 继承类 A 后，只需要再完成第二个功能就可以了，代码如下：123456789101112131415161718class B extends A &#123; public int func1(int a, int b) &#123; return a + b; &#125; public int func2(int a, int b) &#123; return func1(a, b) + 100; &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; B b = new B(); System.out.println(&quot;100-50=&quot; + b.func1(100, 50)); System.out.println(&quot;100-80=&quot; + b.func1(100, 80)); System.out.println(&quot;100+20+100=&quot; + b.func2(100, 20)); &#125;&#125; 运行结果：100-50=150100-80=180100+20+100=220 我们发现原本运行正常的相减功能发生了错误。原因就是类 B 在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类 B 重写后的方法，造成原本运行正常的功能出现了错误。 在本例中，引用基类 A 完成的功能，换成子类 B 之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。 里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法； 子类中可以增加自己特有的方法； 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松； 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 应用 ANDROID 中的 Window 与 View 的关系，可以写成一个简单的示例，其 UML 图如下所示。 具体的代码实现：12345678910111213141516171819202122232425262728// 窗口类public class Window &#123; public void show(View child) &#123; child.draw(); &#125;&#125;// 建立视图抽象，测量视图的宽高为公用代码，绘制实现交给具体的子类public abstract class view &#123; public abstract void draw(); public void measure(int width, int height) &#123; // 测量视图大小 &#125;&#125;// 文本控件类的具体实现public class TextView extends View &#123; public void draw() &#123; // 绘制文本 &#125;&#125;// ImageView 的具体实现public class ImageView extends View &#123; public void draw() &#123; // 绘制图片 &#125;&#125; 上述示例中，Window 依赖于 View，而 View 定义了一个视图抽象，measure 是各个子类共享的方法，子类通过覆写 View 的 draw 方法实现具有各自特色的功能。在这里，这个功能就是绘制自身的内容。任何继承自 View 的子类都可以传递给 show 函数，就是所说的里氏替换。通过里氏替换，就可以自定义各式各样、千变万化的 View，然后传递给 Window，Window 负责组织 View，并将 View 显示到屏幕上。]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[00.2 ANDROID 面向对象的六大原则——开闭原则]]></title>
    <url>%2F2019%2F08%2F02%2FPATTERN%2F00.2%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[第一篇：单一职责原则第二篇：本文第三篇：里氏替换原则第四篇：依赖倒置原则第五篇：接口隔离原则第六篇：迪米特原则 请使用双缓存技术（内存、SD 卡）继续优化图片加载器？ 第一篇中已经实现了内存缓存类 ImageCache.java，我们还需要增加一个 SD 卡缓存类 DiskCache.java。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.xxt.xtest;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.Environment;import android.text.TextUtils;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class DiskCache &#123; // 图片缓存 SD 卡目录 private static String CACHE_DIR = Environment.getExternalStorageDirectory() + &quot;/&quot;; // 从 SD 卡缓存中获取图片 public Bitmap get(String url) &#123; return BitmapFactory.decodeFile(CACHE_DIR + urlToMd5(url)); &#125; // 将图片缓存到 SD 卡中 public void put(String url, Bitmap bitmap) &#123; FileOutputStream fileOutputStream = null; try &#123; fileOutputStream = new FileOutputStream(CACHE_DIR + urlToMd5(url)); bitmap.compress(Bitmap.CompressFormat.PNG, 100, fileOutputStream); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (fileOutputStream != null) &#123; try &#123; fileOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; private String urlToMd5(String url) &#123; if (TextUtils.isEmpty(url)) &#123; return &quot;&quot;; &#125; try &#123; MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;); byte[] bytes = md5.digest(url.getBytes(&quot;UTF-8&quot;)); StringBuilder hex = new StringBuilder(); for (byte b : bytes) &#123; hex.append(Integer.toHexString(b &amp; 0xff)); &#125; hex.append(&quot;.png&quot;); return hex.toString(); &#125; catch (NoSuchAlgorithmException e) &#123; throw new RuntimeException(&quot;NoSuchAlgorithmException&quot;, e); &#125; catch (UnsupportedEncodingException e) &#123; throw new RuntimeException(&quot;UnsupportedEncodingException&quot;, e); &#125; &#125;&#125; 然后修改 ImageLoader.java 源码进行测试，可使用：12345678public class ImageLoader &#123; // 图片缓存 // private ImageCache mImageCache = new ImageCache(); private DiskCache mImageCache = new DiskCache(); ...&#125; 接下来要实现的是：首先使用内存缓存，如果内存缓存没有图片再使用 SD 卡缓存，如果 SD 卡中也没有图片，最后才从网络上获取。 于是新建一个双缓存类 DoubleCache.java，源码如下：12345678910111213141516171819public class DoubleCache &#123; private ImageCache mMemoryCache = new ImageCache(); private DiskCache mDiskCache = new DiskCache(); public Bitmap get(String url) &#123; Bitmap bitmap = mMemoryCache.get(url); if (bitmap == null) &#123; bitmap = mDiskCache.get(url); &#125; return bitmap; &#125; public void put(String url, Bitmap bitmap) &#123; mMemoryCache.put(url, bitmap); mDiskCache.put(url, bitmap); &#125;&#125; 虽然双缓存技术很优秀，但是我们最好提供 API，让使用者可以灵活选择缓存方式：只选内存缓存、只选 SD 卡缓存或者选择双缓存方式。而不合格的程序员则会提供如下代码：123456789101112131415161718192021222324252627282930313233343536public class ImageLoader &#123; // 图片缓存 private ImageCache mImageCache = new ImageCache(); // SD 卡缓存 private DiskCache mDiskCache = new DiskCache(); // 双缓存 private DoubleCache mDoubleCache = new DoubleCache(); // true: 单独使用 SD 卡缓存; false: 单独使用内存缓存 private boolean isUseDiskCache = false; // true: 使用双缓存 private boolean isUseDoubleCache = false; public void displayImage(final String url, final ImageView imageView) &#123; Bitmap bmp = null; if (isUseDoubleCache) &#123; bmp = mDoubleCache.get(url); &#125; else if (isUseDiskCache) &#123; bmp = mDiskCache.get(url); &#125; else &#123; bmp = mImageCache.get(url); &#125; ... &#125; ... public void useDiskCache(boolean useDiskCache) &#123; isUseDiskCache = useDiskCache; &#125; public void useDoubleCache(boolean useDoubleCache) &#123; isUseDoubleCache = useDoubleCache; &#125;&#125; 上述代码中，要加入新的缓存实现时都需要修改 ImageLoader 类，然后通过一个布尔变量让用户选择使用哪种缓存。因此，就使得在 ImageLoader 中存在各种 if-else 判断语句，通过这些判断来确定使用哪种缓存。随着这些逻辑的引入，代码越来越复杂、脆弱。如果不小心写错了某个 if 条件，那就需要更多的时间来排除，整个 ImageLoader 类也会变得越来越臃肿。最重要的是，用户不能自己实现缓存注入到 ImageLoader 中，可扩展性差。 软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是对于修改是封闭的，这就是开放——关闭原则。 也就是说，当软件需要变化时，我们应该尽量通过扩展的方式实现变化，而不是通过修改已有的代码来实现。根据这一个原则，我们可以画出如下所示的 UML 图。 按照上图进行以下重构： 提取抽象接口，用来抽象图片缓存的功能。其声明如下：1234public interface ImageCache &#123; Bitmap get(String url); void put(String url, Bitmap bitmap);&#125; ImageCache 接口简单定义了获取、缓存图片两个函数，缓存的 key 是图片的 url，值是图片本身。内存缓存、SD 卡缓存、双缓存都实现了该接口，我们看看这几个缓存实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 内存缓存 MemoryCache 类public class MemoryCache implements ImageCache &#123; private LruCache&lt;String, Bitmap&gt; mImageCache; public MemoryCache() &#123; initImageCache(); &#125; private void initImageCache() &#123; int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); final int cacheSize = maxMemory / 4; mImageCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123; @Override protected int sizeOf(@NonNull String key, @NonNull Bitmap value) &#123; return ImageUtil.getBitmapSize(value) / 1024; &#125; &#125;; &#125; public void put(@NonNull String url, @NonNull Bitmap bitmap) &#123; mImageCache.put(url, bitmap); &#125; public Bitmap get(@NonNull String url) &#123; return mImageCache.get(url); &#125;&#125;// SD 卡缓存 DiskCache 类public class DiskCache implements ImageCache &#123; private static String CACHE_DIR = Environment.getExternalStorageDirectory() + &quot;/&quot;; public Bitmap get(String url) &#123; return BitmapFactory.decodeFile(CACHE_DIR + ImageUtil.urlToMd5(url)); &#125; public void put(String url, Bitmap bitmap) &#123; FileOutputStream fileOutputStream = null; try &#123; fileOutputStream = new FileOutputStream(CACHE_DIR + ImageUtil.urlToMd5(url)); bitmap.compress(Bitmap.CompressFormat.PNG, 100, fileOutputStream); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (fileOutputStream != null) &#123; try &#123; fileOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;// 双缓存 DoubleCache 类public class DoubleCache implements ImageCache &#123; private MemoryCache mMemoryCache = new MemoryCache(); private DiskCache mDiskCache = new DiskCache(); public Bitmap get(String url) &#123; Bitmap bitmap = mMemoryCache.get(url); if (bitmap == null) &#123; bitmap = mDiskCache.get(url); &#125; return bitmap; &#125; public void put(String url, Bitmap bitmap) &#123; mMemoryCache.put(url, bitmap); mDiskCache.put(url, bitmap); &#125;&#125; 然后重构 ImageLoader，如下所示：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ImageLoader &#123; // 图片缓存，默认内存缓存 private ImageCache mImageCache = new MemoryCache(); // 线程池，线程数量为 CPU 的数量 private ExecutorService mExecutorService = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors()); // UI Handler private Handler mUiHandler = new Handler(Looper.getMainLooper()); // 注入缓存实现 public void setImageCache(ImageCache cache) &#123; mImageCache = cache; &#125; public void displayImage(final String url, final ImageView imageView) &#123; Bitmap bitmap = mImageCache.get(url); if (bitmap != null) &#123; imageView.setImageBitmap(bitmap); return; &#125; // 内存中没有，去加载 submitLoadRequest(url, imageView); &#125; private void submitLoadRequest(final String url, final ImageView imageView) &#123; imageView.setTag(url); mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; Bitmap bitmap = ImageUtil.downloadImage(url); if (bitmap == null) return; if (url.equals(imageView.getTag())) &#123; updateImageView(imageView, bitmap); &#125; mImageCache.put(url, bitmap); &#125; &#125;); &#125; // 通知界面更新显示图片 private void updateImageView(final ImageView imageView, final Bitmap bitmap) &#123; mUiHandler.post(new Runnable() &#123; @Override public void run() &#123; imageView.setImageBitmap(bitmap); &#125; &#125;); &#125;&#125; 附工具类 ImageUtil.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class ImageUtil &#123; /** * 下载图片 * @param imageUrl 图片链接 * @return Bitmap */ public static Bitmap downloadImage(String imageUrl) &#123; if (TextUtils.isEmpty(imageUrl)) &#123; return null; &#125; Bitmap bitmap = null; try &#123; URL url = new URL(imageUrl); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); bitmap = BitmapFactory.decodeStream(conn.getInputStream()); conn.disconnect(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return bitmap; &#125; /** * 计算图片大小 * @param bitmap 图片 * @return int */ public static int getBitmapSize(Bitmap bitmap) &#123; if (bitmap == null) &#123; return 0; &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; return bitmap.getAllocationByteCount(); &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB_MR1) &#123; return bitmap.getByteCount(); &#125; return bitmap.getRowBytes() * bitmap.getHeight(); &#125; /** * 将图片 url 转换成字符串，用作文件名称 * @param url * @return */ public static String urlToMd5(String url) &#123; if (TextUtils.isEmpty(url)) &#123; return &quot;&quot;; &#125; try &#123; MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;); byte[] bytes = md5.digest(url.getBytes(&quot;UTF-8&quot;)); StringBuilder builder = new StringBuilder(); for (byte b : bytes) &#123; builder.append(Integer.toHexString(b &amp; 0xff)); &#125; builder.append(&quot;.png&quot;); return builder.toString(); &#125; catch (NoSuchAlgorithmException e) &#123; throw new RuntimeException(&quot;NoSuchAlgorithmException&quot;, e); &#125; catch (UnsupportedEncodingException e) &#123; throw new RuntimeException(&quot;UnsupportedEncodingException&quot;, e); &#125; &#125;&#125; 经过此次重构，没有了那么多的 if-else 语句，没有了各种各样的缓存实现对象、布尔变量，代码确实清晰简洁。用户可以通过setImageCache(ImageCache cache) 函数设置缓存实现，也就是通常说的依赖注入。具体如下所示：12345678910111213141516171819ImageLoader imageLoader = new ImageLoader();// 使用内存缓存imageLoader.setImageCache(new MemoryCache());// 使用 SD 卡缓存imageLoader.setImageCache(new DiskCache());// 使用双缓存imageLoader.setImageCache(new DoubleCache());// 使用自定义的图片缓存实现imageLoader.setImageCache(new ImageCache() &#123; @Override public Bitmap get(String url) &#123; return null; // 从缓存中获取图片 &#125; @Override public void put(String url, Bitmap bitmap) &#123; // 缓存图片 &#125;&#125;); 在上述代码中，通过 setImageCache(ImageCache cache) 方法注入不同的缓存实现，这样不仅能够使 ImageLoader 更简单、健壮，也使得 ImageLoader 的可扩展性、灵活性更高。MemoryCache、DiskCache、DoubleCache 缓存图片的具体实现完全不一样，但是，它们的一个特点是，都实现了 ImageCache 接口。当用户需要自定义实现缓存策略时，只需要新建一个实现 ImageCache 接口的类，然后构造该类的对象，并且通过 setImageCache 函数注入到 ImageLoader 中，这样 ImageLoader 就实现了千变万化的缓存策略，且扩展这些缓存策略并不会导致 ImageLoader 类的修改。 开闭原则指导我们，当软件需要变化时，应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。但是通过继承等方式添加新的实现，这会导致类型的膨胀以及历史遗留代码的冗余。在开发过程中需要自己结合具体情况进行考量。 开闭原则概述 软件实体应当对扩展开放，对修改关闭 (Software entities should be open for extension, but closed for modification)。 开闭原则是面向对象设计中“可复用设计”的基石，是设计模式最基本的法则。其他五大设计原则和 23 种设计模式都可以看做是开闭原则的实现方法和手段。 说的通俗一点就是，已经开发好的软件实体（如类、模块、函数），在升级迭代引入新功能时，不应该修改已有的代码，而是在已有代码的基础上，添加新代码来实现。]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[00.1 ANDROID 面向对象的六大原则——单一职责原则]]></title>
    <url>%2F2019%2F08%2F01%2FPATTERN%2F00.1%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[第一篇：本文第二篇：开闭原则第三篇：里氏替换原则第四篇：依赖倒置原则第五篇：接口隔离原则第六篇：迪米特原则 请实现一个简易的图片加载器（ImageLoader）？ 以下是一个新手实现的图片加载器源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.xxt.xtest;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.Handler;import android.os.Looper;import android.text.TextUtils;import android.util.LruCache;import android.widget.ImageView;import java.net.HttpURLConnection;import java.net.URL;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ImageLoader &#123; // 图片缓存 LruCache&lt;String, Bitmap&gt; mImageCache; // 线程池，线程数量为 CPU 的数量 ExecutorService mExecutorService = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors()); // UI Handler Handler mUiHandler = new Handler(Looper.getMainLooper()); public ImageLoader() &#123; initImageCache(); &#125; /** * 初始化内存缓存 */ private void initImageCache() &#123; // 计算可用的最大内存 final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); // 取四分之一的可用内存作为缓存 final int cacheSize = maxMemory / 4; mImageCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123; @Override protected int sizeOf(String key, Bitmap bitmap) &#123; return bitmap.getRowBytes() * bitmap.getHeight() / 1024; &#125; &#125;; &#125; /** * 加载指定 url 的图片并显示 */ public void displayImage(final String url, final ImageView imageView) &#123; // 先从内存中找 Bitmap bmp = mImageCache.get(url); if (bmp != null) &#123; imageView.setImageBitmap(bmp); return; &#125; // 内存中没有，去加载 imageView.setTag(url); mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; Bitmap bitmap = downloadImage(url); if (bitmap == null) return; if (url.equals(imageView.getTag())) &#123; updateImageView(imageView, bitmap); &#125; mImageCache.put(url, bitmap); &#125; &#125;); &#125; /** * 通知界面更新显示图片 * @param imageView ImageView * @param bitmap 位图 */ private void updateImageView(final ImageView imageView, final Bitmap bitmap) &#123; mUiHandler.post(new Runnable() &#123; @Override public void run() &#123; imageView.setImageBitmap(bitmap); &#125; &#125;); &#125; /** * 下载指定 url 的图片 * @param imageUrl 图片链接 * @return Bitmap */ private Bitmap downloadImage(String imageUrl) &#123; if (TextUtils.isEmpty(imageUrl)) return null; Bitmap bitmap = null; try &#123; URL url = new URL(imageUrl); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); bitmap = BitmapFactory.decodeStream(conn.getInputStream()); conn.disconnect(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return bitmap; &#125;&#125; 测试代码：12345// 动态申请权限requestRuntimePermission(new String[]&#123;&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&#125;, null);String url = &quot;https://upload-images.jianshu.io/upload_images/14186083-9bb468395ee3d048.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;;ImageView imageView = findViewById(R.id.image);new ImageLoader().displayImage(url, imageView); 上述代码虽然满足功能需求，但是所有的功能代码都写在一个类中，这样随着功能的增多，ImageLoader 类会越来越大，代码也越来越负责，图片加载系统就越来越脆弱…… 我们可以参照单一职责原则，把 ImageLoader 拆分一下，让各个功能独立出来： ImageCache：用于处理图片缓存。 ImageUtil：图片工具类，如获取图片大小、下载图片等。 改进后的源码：ImageLoader.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.xxt.xtest;import android.graphics.Bitmap;import android.os.Handler;import android.os.Looper;import android.widget.ImageView;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ImageLoader &#123; // 图片缓存 private ImageCache mImageCache = new ImageCache(); // 线程池，线程数量为 CPU 的数量 private ExecutorService mExecutorService = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors()); // UI Handler private Handler mUiHandler = new Handler(Looper.getMainLooper()); /** * 加载指定 url 的图片并显示 */ public void displayImage(final String url, final ImageView imageView) &#123; // 先从内存中找 Bitmap bmp = mImageCache.get(url); if (bmp != null) &#123; imageView.setImageBitmap(bmp); return; &#125; // 内存中没有，去加载 imageView.setTag(url); mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; Bitmap bitmap = ImageUtil.downloadImage(url); if (bitmap == null) return; if (url.equals(imageView.getTag())) &#123; updateImageView(imageView, bitmap); &#125; mImageCache.put(url, bitmap); &#125; &#125;); &#125; /** * 通知界面更新显示图片 * @param imageView ImageView * @param bitmap 位图 */ private void updateImageView(final ImageView imageView, final Bitmap bitmap) &#123; mUiHandler.post(new Runnable() &#123; @Override public void run() &#123; imageView.setImageBitmap(bitmap); &#125; &#125;); &#125;&#125; ImageCache.java12345678910111213141516171819202122232425262728293031323334353637package com.xxt.xtest;import android.graphics.Bitmap;import androidx.annotation.NonNull;import androidx.collection.LruCache;public class ImageCache &#123; // 图片缓存 private LruCache&lt;String, Bitmap&gt; mImageCache; public ImageCache() &#123; initImageCache(); &#125; private void initImageCache() &#123; // 计算可使用的最大内存 int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); // 取四分之一的可用内存作为缓存 final int cacheSize = maxMemory / 4; mImageCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123; @Override protected int sizeOf(@NonNull String key, @NonNull Bitmap value) &#123; return ImageUtil.getBitmapSize(value) / 1024; &#125; &#125;; &#125; public void put(@NonNull String url, @NonNull Bitmap bitmap) &#123; mImageCache.put(url, bitmap); &#125; public Bitmap get(@NonNull String url) &#123; return mImageCache.get(url); &#125;&#125; ImageUtil.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.xxt.xtest;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.Build;import android.text.TextUtils;import java.net.HttpURLConnection;import java.net.URL;public class ImageUtil &#123; /** * 下载图片 * @param imageUrl 图片链接 * @return Bitmap */ public static Bitmap downloadImage(String imageUrl) &#123; if (TextUtils.isEmpty(imageUrl)) &#123; return null; &#125; Bitmap bitmap = null; try &#123; URL url = new URL(imageUrl); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); bitmap = BitmapFactory.decodeStream(conn.getInputStream()); conn.disconnect(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return bitmap; &#125; /** * 计算图片大小 * @param bitmap 图片 * @return int */ public static int getBitmapSize(Bitmap bitmap) &#123; if (bitmap == null) &#123; return 0; &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; return bitmap.getAllocationByteCount(); &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB_MR1) &#123; return bitmap.getByteCount(); &#125; return bitmap.getRowBytes() * bitmap.getHeight(); &#125;&#125; 单一职责原则概述 应该有且仅有一个原因引起类的变更 (There should never be more than one reason for a class to change)。 单一职责原则为我们提供了一个编写程序的准则，要求我们在编写类，抽象类，接口时，要使其功能职责单一纯碎，将导致其变更的因素缩减到最少。 如果一个类承担的职责过多，就等于把这些职责耦合在一起。一个职责的变化可能会影响或损坏其他职责的功能。而且职责越多，这个类变化的几率就会越大，类的稳定性就会越低。 在软件开发中，经常会遇到一个功能类 T 负责两个不同的职责：职责 P1，职责 P2。现因需求变更需要更改职责 P1 来满足新的业务需求，当我们实现完成后，发现因更改职责 P1 竟导致原本能够正常运行的职责 P2 发生故障。而修复职责 P2 又不得不更改职责 P1 的逻辑，这便是因为功能类 T 的职责不够单一，职责 P1 与职责 P2 耦合在一起导致的。 附：动态权限申请代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.xxt.xtest;import android.content.pm.PackageManager;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import androidx.core.app.ActivityCompat;import androidx.core.content.ContextCompat;import java.util.ArrayList;import java.util.List;public class BaseActivity extends AppCompatActivity &#123; private PermissionListener mListener; /** * 权限申请 * @param permissions 待申请的权限集合 * @param listener 申请结果监听事件 */ protected void requestRuntimePermission(String[] permissions, PermissionListener listener)&#123; this.mListener = listener; // 用于存放为授权的权限 List&lt;String&gt; permissionList = new ArrayList&lt;&gt;(); // 遍历传递过来的权限集合 for (String permission : permissions) &#123; // 判断是否已经授权 if (ContextCompat.checkSelfPermission(this,permission) != PackageManager.PERMISSION_GRANTED)&#123; // 未授权，则加入待授权的权限集合中 permissionList.add(permission); &#125; &#125; // 判断集合，如果集合不为空，则需要去授权 if (!permissionList.isEmpty()) &#123; ActivityCompat.requestPermissions(this, permissionList.toArray(new String[permissionList.size()]), 1); &#125; // 为空，则已经全部授权 else &#123; if (listener != null) &#123; listener.onGranted(); &#125; &#125; &#125; /** * 权限申请结果 * @param requestCode 请求码 * @param permissions 所有的权限集合 * @param grantResults 授权结果集合 */ @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode == 1 &amp;&amp; grantResults.length &gt; 0) &#123; // 被用户拒绝的权限集合 List&lt;String&gt; deniedPermissions = new ArrayList&lt;&gt;(); // 用户通过的权限集合 List&lt;String&gt; grantedPermissions = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; grantResults.length; i++) &#123; // 获取授权结果，这是一个int类型的值 int grantResult = grantResults[i]; // 用户拒绝授权的权限 if (grantResult != PackageManager.PERMISSION_GRANTED)&#123; String permission = permissions[i]; deniedPermissions.add(permission); &#125; // 用户同意的权限 else &#123; String permission = permissions[i]; grantedPermissions.add(permission); &#125; &#125; // 用户拒绝权限为空 if (deniedPermissions.isEmpty()) &#123; if(mListener != null)&#123; mListener.onGranted(); &#125; &#125; // 不为空 else &#123; if(mListener != null)&#123; // 回调授权成功的接口 mListener.onDenied(deniedPermissions); // 回调授权失败的接口 mListener.onGranted(grantedPermissions); mListener.onDenied(); &#125; &#125; &#125; &#125;&#125; PermissionListener.java12345678910public interface PermissionListener &#123; // 授权成功 void onGranted(); // 授权部分 void onGranted(List&lt;String&gt; grantedPermission); // 拒绝授权 void onDenied(List&lt;String&gt; deniedPermission); // 授权失败 void onDenied();&#125;]]></content>
      <categories>
        <category>PATTERN</category>
      </categories>
      <tags>
        <tag>PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[T007 自定义控件 图文弹跳加载中效果]]></title>
    <url>%2F2019%2F07%2F20%2FCustom%20View%2FT007%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E5%9B%BE%E6%96%87%E5%BC%B9%E8%B7%B3%E5%8A%A0%E8%BD%BD%E4%B8%AD%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[要想实现上述效果，需要准备三张图： 然后让控件派生自 ImageView 类，这样才能方便地更改它的源文件内容。 想让图片上下跳动，可以利用 ValueAnimator 实时产生一个 0~200 的数值，然后让当前图片的位置实时向上移动 ValueAnimator 的动态值的高度即可。要让图片的位置实时向上移动，就需要先拿到初始状态下图片的位置。重写 onLayout(boolean changed, int left, int top, int right, int bottom) 函数，就可以拿到控件的初始高度 mTop，之后在每次 ValueAnimator 的动态值到来时，计算出当前控件的 top 位置，并将控件移动到这个位置就可以了。 即：自定义一个控件 LoadingImageView， 派生自 ImageView，然后重写 onLayout() 函数，拿到控件的初始 top 值。代码如下：12345678910111213141516171819202122232425262728293031323334public class LoadingImageView extends AppCompatImageView &#123; // 初始 top private int mTop; // 当前动画图片索引 private int mCurImgIndex = 0; // 动画图片总张数 private static int mImgCount = 3; public LoadingImageView(Context context) &#123; super(context); init(); &#125; public LoadingImageView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public LoadingImageView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; ... &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); mTop = top; &#125;&#125; 由于我们需要在刚展示图片时就开始动画，所以将动画的操作全部写在 init() 函数中。代码如下：12345678910111213141516private void init() &#123; ValueAnimator valueAnimator = ValueAnimator.ofInt(0, 200, 0); valueAnimator.setRepeatMode(ValueAnimator.RESTART); valueAnimator.setRepeatCount(ValueAnimator.INFINITE); valueAnimator.setDuration(1000); valueAnimator.setInterpolator(new AccelerateInterpolator()); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; Integer dx = (Integer) animation.getAnimatedValue(); setTop(mTop - dx); &#125; &#125;); ...&#125; 通过 (mTop - dx) 得到当前控件相对初始坐标上移 dx 距离后的最新坐标点，然后调用 setTop(int top) 函数将控件移动到当前位置。 接下来需要监听动画的开始和重复。当动画开始时，图片应该设置为 loading_text_1.png；在重复时，每重复一次应该更换一张图片。代码如下：123456789101112131415161718192021222324252627282930313233343536// 当前动画图片索引private int mCurImgIndex = 0;// 动画图片总张数private static int mImgCount = 3;private void init() &#123; ... valueAnimator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; setImageDrawable(getResources().getDrawable(R.drawable.loading_text_1)); &#125; @Override public void onAnimationEnd(Animator animation) &#123;&#125; @Override public void onAnimationCancel(Animator animation) &#123;&#125; @Override public void onAnimationRepeat(Animator animation) &#123; mCurImgIndex++; switch (mCurImgIndex % mImgCount) &#123; case 0: setImageDrawable(getResources().getDrawable(R.drawable.loading_text_1)); break; case 1: setImageDrawable(getResources().getDrawable(R.drawable.loading_text_2)); break; case 2: setImageDrawable(getResources().getDrawable(R.drawable.loading_text_3)); break; &#125; &#125; &#125;); valueAnimator.start();&#125; 在更改图片时，我们使用 mCurImgIndex 来累加当前重复的次数，通过与图片总张数 (mImgCount) 取余数，来决定这次重复使用的是哪张图片。 使用控件：123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;com.xxt.xtest.LoadingImageView android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; android:layout_margin=&quot;50dp&quot;/&gt;&lt;/LinearLayout&gt; LoadingImageView 的完整代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.xxt.xtest;import android.animation.Animator;import android.animation.ValueAnimator;import android.content.Context;import android.util.AttributeSet;import android.view.animation.AccelerateInterpolator;import androidx.appcompat.widget.AppCompatImageView;public class LoadingImageView extends AppCompatImageView &#123; private int mTop; // 当前动画图片索引 private int mCurImgIndex = 0; // 动画图片总张数 private static int mImgCount = 3; public LoadingImageView(Context context) &#123; super(context); init(); &#125; public LoadingImageView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public LoadingImageView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; ValueAnimator valueAnimator = ValueAnimator.ofInt(0, 200, 0); valueAnimator.setRepeatMode(ValueAnimator.RESTART); valueAnimator.setRepeatCount(ValueAnimator.INFINITE); valueAnimator.setDuration(1000); valueAnimator.setInterpolator(new AccelerateInterpolator()); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; Integer dx = (Integer) animation.getAnimatedValue(); setTop(mTop - dx); &#125; &#125;); valueAnimator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; setImageDrawable(getResources().getDrawable(R.drawable.loading_text_1)); &#125; @Override public void onAnimationEnd(Animator animation) &#123;&#125; @Override public void onAnimationCancel(Animator animation) &#123;&#125; @Override public void onAnimationRepeat(Animator animation) &#123; mCurImgIndex++; switch (mCurImgIndex % mImgCount) &#123; case 0: setImageDrawable(getResources().getDrawable(R.drawable.loading_text_1)); break; case 1: setImageDrawable(getResources().getDrawable(R.drawable.loading_text_2)); break; case 2: setImageDrawable(getResources().getDrawable(R.drawable.loading_text_3)); break; &#125; &#125; &#125;); valueAnimator.start(); &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); mTop = top; &#125;&#125;]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[T006 自定义控件 扫描雷达动画]]></title>
    <url>%2F2019%2F07%2F19%2FCustom%20View%2FT006%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E6%89%AB%E6%8F%8F%E9%9B%B7%E8%BE%BE%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[一、说明 表层是一张指针图，增加旋转动画，每旋转一周，增加一个波纹扩散动画效果。 波纹扩散动画效果是在底层的波纹图上实现缩放和透明度变化的组合动画。 使用容器来保存波纹扩散动画，便于复用。 二、完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179package com.xxt.xtest;import android.animation.Animator;import android.animation.AnimatorSet;import android.animation.ObjectAnimator;import android.animation.ValueAnimator;import android.content.Context;import android.util.AttributeSet;import android.view.Gravity;import android.view.LayoutInflater;import android.view.View;import android.view.animation.LinearInterpolator;import android.widget.FrameLayout;import android.widget.ImageView;import android.widget.TextView;import java.util.ArrayList;import java.util.List;public class ScanningView extends FrameLayout &#123; /** * 指针 */ private ImageView ivNeedle; /** * 波纹 */ private ImageView ivRipple; /** * 中间文字 */ private TextView tvTitle; /** * 装波纹的容器 */ private FrameLayout fl_move_circle; /** * 匀速插值器 */ private LinearInterpolator interpolator = new LinearInterpolator(); /** * 准备动画 */ private AnimatorSet prepareAnim; /** * 指针旋转动画 */ private ObjectAnimator needleRotateAnim; private List&lt;AnimatorSet&gt; animList = new ArrayList&lt;&gt;(); private int animCount = 3; private int index = 0; public ScanningView(Context context) &#123; super(context); initView(); &#125; public ScanningView(Context context, AttributeSet attrs) &#123; super(context, attrs); initView(); &#125; private void initView()&#123; View v = LayoutInflater.from(getContext()).inflate(R.layout.rotate_view,null); ivNeedle = v.findViewById(R.id.iv_btn); ivRipple = v.findViewById(R.id.iv_out_circle); tvTitle = v.findViewById(R.id.tv_title); fl_move_circle = v.findViewById(R.id.fl_move_circle); addView(v, LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT); initAnim(); prepareAnim.start(); &#125; /** * 初始化动画 * 准备动画 prepareAnim * 扫描动画 scanningAnim */ private void initAnim() &#123; initPrepareAnim(); initScanningAnim(); &#125; private void initPrepareAnim() &#123; // 开始循环的放大缩小波纹 ObjectAnimator outCircleAlpha = ObjectAnimator.ofFloat(ivRipple, &quot;alpha&quot;, 0.2f, 0.6f); outCircleAlpha.setDuration(1000); ObjectAnimator outCircleAnimX = ObjectAnimator.ofFloat(ivRipple, &quot;scaleX&quot;, 1f, 1.18f, 1f); outCircleAnimX.setDuration(2000); outCircleAnimX.setRepeatCount(ValueAnimator.INFINITE); outCircleAnimX.setInterpolator(interpolator); ObjectAnimator outCircleAnimY = ObjectAnimator.ofFloat(ivRipple, &quot;scaleY&quot;, 1f, 1.18f, 1f); outCircleAnimY.setDuration(2000); outCircleAnimY.setRepeatCount(ValueAnimator.INFINITE); outCircleAnimY.setInterpolator(interpolator); prepareAnim = new AnimatorSet(); prepareAnim.playTogether(outCircleAnimX, outCircleAnimY, outCircleAlpha); &#125; private void initScanningAnim() &#123; // 指针转动动画 needleRotateAnim = ObjectAnimator.ofFloat(ivNeedle, &quot;rotation&quot;, 0f, 360f); needleRotateAnim.setDuration(1800); needleRotateAnim.setInterpolator(interpolator); needleRotateAnim.setRepeatCount(ValueAnimator.INFINITE); needleRotateAnim.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; playRippleAnim(); &#125; @Override public void onAnimationEnd(Animator animation) &#123;&#125; @Override public void onAnimationCancel(Animator animation) &#123;&#125; @Override public void onAnimationRepeat(Animator animation) &#123; playRippleAnim(); &#125; &#125;); &#125; private void initRippleAnim() &#123; final ImageView imageView = new ImageView(getContext()); LayoutParams lp = new LayoutParams(dip2px(getContext(), 110), dip2px(getContext(), 110)); lp.gravity = Gravity.CENTER; imageView.setLayoutParams(lp); imageView.setImageResource(R.drawable.ripple); fl_move_circle.addView(imageView); ObjectAnimator outCircleAnimX = ObjectAnimator.ofFloat(imageView, &quot;scaleX&quot;, 1f, 5f); ObjectAnimator outCircleAnimY = ObjectAnimator.ofFloat(imageView, &quot;scaleY&quot;, 1f, 5f); ObjectAnimator alphaAnim = ObjectAnimator.ofFloat(imageView, &quot;alpha&quot;, 0.6f, 0); outCircleAnimX.setDuration(5000); outCircleAnimY.setDuration(5000); alphaAnim.setDuration(5000); final AnimatorSet animatorSet = new AnimatorSet(); animatorSet.playTogether(outCircleAnimX, outCircleAnimY, alphaAnim); animList.add(animatorSet); &#125; private void playRippleAnim() &#123; if (animList.size() &lt; animCount) &#123; initRippleAnim(); &#125; animList.get(index).start(); index++; if (index == animCount) index = 0; &#125; /** * 模拟开始 */ public void onceClick()&#123; // 取消掉循环的波纹 prepareAnim.cancel(); ivRipple.setVisibility(GONE); needleRotateAnim.start(); tvTitle.setText(&quot;扫描中&quot;); &#125; /** * 根据手机的分辨率从 dip 的单位 转成为 px(像素) */ public static int dip2px(Context context, float dpValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (dpValue * scale + 0.5f); &#125;&#125; 其布局文件 res/layout/scanning_view.xml 如下：12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:background=&quot;#69C8FA&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;FrameLayout android:id=&quot;@+id/fl_move_circle&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; &lt;ImageView android:id=&quot;@+id/iv_out_circle&quot; android:layout_width=&quot;110dp&quot; android:layout_height=&quot;110dp&quot; android:layout_gravity=&quot;center&quot; android:alpha=&quot;0.6&quot; android:src=&quot;@drawable/ripple&quot; /&gt; &lt;ImageView android:id=&quot;@+id/iv_btn&quot; android:layout_width=&quot;110dp&quot; android:layout_height=&quot;110dp&quot; android:layout_gravity=&quot;center&quot; android:src=&quot;@drawable/needle&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_title&quot; android:layout_width=&quot;wrap_content&quot; android:textColor=&quot;#ffffff&quot; android:layout_gravity=&quot;center&quot; android:text=&quot;点击扫描&quot; android:textSize=&quot;10sp&quot; android:layout_marginTop=&quot;13dp&quot; android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/FrameLayout&gt; 三、使用1234567891011121314151617181920212223242526272829public class DemoActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_demo); final ScanningView view = findViewById(R.id.scanning); view.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; view.onceClick(); &#125; &#125;); &#125;&#125;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;com.xxt.xtest.ScanningView android:id=&quot;@+id/scanning&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt;&lt;/LinearLayout&gt;]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[T005 自定义控件 可配置加载 ImageView]]></title>
    <url>%2F2019%2F07%2F18%2FCustom%20View%2FT005%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E5%8F%AF%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%20ImageView%2F</url>
    <content type="text"><![CDATA[原理很简单，使一张图围绕自己的中心点匀速旋转。完整代码如下：1234567891011121314151617181920212223242526272829303132333435363738package com.xxt.xtest;import android.content.Context;import android.util.AttributeSet;import android.view.animation.Animation;import android.view.animation.LinearInterpolator;import android.view.animation.RotateAnimation;import androidx.annotation.Nullable;import androidx.appcompat.widget.AppCompatImageView;public class LoadingImageView extends AppCompatImageView &#123; public LoadingImageView(Context context) &#123; super(context); init(); &#125; public LoadingImageView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public LoadingImageView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; RotateAnimation rotateAnim = new RotateAnimation(0, 360, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); rotateAnim.setRepeatCount(Animation.INFINITE); rotateAnim.setDuration(1000); rotateAnim.setInterpolator(new LinearInterpolator()); this.startAnimation(rotateAnim); &#125;&#125; 使用方式：1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;com.xxt.xtest.LoadingImageView android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; android:layout_margin=&quot;50dp&quot; android:src=&quot;@drawable/taiji&quot;/&gt;&lt;/LinearLayout&gt;]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[T004 自定义控件 由远及近 ImageView]]></title>
    <url>%2F2019%2F07%2F17%2FCustom%20View%2FT004%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E7%94%B1%E8%BF%9C%E5%8F%8A%E8%BF%91%20ImageView%2F</url>
    <content type="text"><![CDATA[参考知识点：ScaleAnimation、BounceInterpolator 借助 ScaleAnimation 实现由远及近效果，首先需要让动画从控件某点（触屏点）为中心开始缩放；其次需要在动画结束后，将控件固定在放大后的状态；并使用回弹插值器。 上述效果图完整代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.xxt.xtest;import android.content.Context;import android.util.AttributeSet;import android.view.MotionEvent;import android.view.animation.Animation;import android.view.animation.BounceInterpolator;import android.view.animation.ScaleAnimation;import androidx.annotation.Nullable;import androidx.appcompat.widget.AppCompatImageView;public class TouchImageView extends AppCompatImageView &#123; private boolean isPlay = false; public TouchImageView(Context context) &#123; super(context); &#125; public TouchImageView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public TouchImageView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; if (!isPlay) &#123; isPlay = true; float pivotXValue = (event.getX() - getLeft()) / getWidth(); float pivotYValue = (event.getY() - getTop()) / getHeight(); ScaleAnimation scaleAnim = new ScaleAnimation(1.0f, 3f, 1.0f, 3f, Animation.RELATIVE_TO_SELF, pivotXValue, Animation.RELATIVE_TO_SELF, pivotYValue); scaleAnim.setDuration(3000); scaleAnim.setFillAfter(true); scaleAnim.setInterpolator(new BounceInterpolator()); this.startAnimation(scaleAnim); &#125; else &#123; this.clearAnimation(); isPlay = false; &#125; return super.onTouchEvent(event); &#125;&#125; 之所以继承 ImageView，是为了复用其完善的图片显示功能。]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[T003 自定义控件 裁剪动画]]></title>
    <url>%2F2019%2F07%2F16%2FCustom%20View%2FT003%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E8%A3%81%E5%89%AA%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[参考知识点：01.5 精通自定义 View 之绘图基础——Canvas 一、原理这个动画的原理很简单，就是每次将裁剪区域变大，在裁剪区域内的图像就会显示出来，而裁剪区域之外的图像不会显示。而关键问题在于如何计算裁剪区域。 再来看一下动画截图，如下图所示。 从图示中可以看出，有两个裁剪区域。 裁剪区域一：从左向右，逐渐变大。假设宽度是 clipWidth，高度是 CLIP_HEIGHT，那么裁剪区域一所对应的 Rect 对象如下:1Rect(0, 0, clipWidth, CLIP_HEIGHT); 裁剪区域二：从右向左，同样逐渐变大，它的宽度、高度都与裁剪区域一相同。但它是从右向左变化的，假设图片的宽度是 width，那么裁剪区域二所对应的 Rect 对象如下:1Rect(width - clipWidth, CLIP_HEIGHT, width, 2* CLIP_HEIGHT); 二、示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class ClipRegionView extends View &#123; private Paint mPaint; private Bitmap mBitmap; private int clipWidth = 0; private int width; private int height; private static final int CLIP_HEIGHT = 50; private Path mPath; private RectF mRect; public ClipRegionView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; private void init() &#123; setLayerType(LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.meinv); width = mBitmap.getWidth(); height = mBitmap.getHeight(); mPath = new Path(); mRect = new RectF(); &#125; @Override protected void onSizeChanged(int w, int h, int oldW, int oldH) &#123; super.onSizeChanged(w, h, oldW, oldH); // 原图宽高超过控件自身宽高，进行缩放 if (width &gt; w || height &gt; h) &#123; float scaleW = w * 1f / width; float scaleH = h * 1f / height; float scale = Math.min(scaleW, scaleH); // 按比例重置参数 mBitmap = scaleBitmap(mBitmap, scale); width = (int) (width * scale); height = (int) (height * scale); &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; mPath.reset(); int i = 0; while (i * CLIP_HEIGHT &lt;= height) &#123; if (i % 2 == 0) &#123; mRect.set(0, i * CLIP_HEIGHT, clipWidth, (i+1) * CLIP_HEIGHT); &#125; else &#123; mRect.set(width - clipWidth, i * CLIP_HEIGHT, width, (i+1) * CLIP_HEIGHT); &#125; // 替换 Region.union 方法 mPath.addRect(mRect, Path.Direction.CCW); i++; &#125; // 因 canvas.clipRegion 方法过时，所以替换成 Path 相关 Api canvas.clipPath(mPath); canvas.drawBitmap(mBitmap, 0, 0, mPaint); if (clipWidth &gt; width) &#123; return; &#125; clipWidth += 5; invalidate(); &#125; /** * 按比例缩放图片 * * @param origin 原图 * @param ratio 比例 * @return 新的bitmap */ private Bitmap scaleBitmap(Bitmap origin, float ratio) &#123; if (origin == null) &#123; return null; &#125; int width = origin.getWidth(); int height = origin.getHeight(); Matrix matrix = new Matrix(); matrix.preScale(ratio, ratio); Bitmap newBM = Bitmap.createBitmap(origin, 0, 0, width, height, matrix, false); if (newBM.equals(origin)) &#123; return newBM; &#125; origin.recycle(); return newBM; &#125;&#125; 通过调用 invalidate() 函数的方式来重复触发 onDraw() 函数，然后在 onDraw() 函数中计算需要裁剪的画布。 在上述代码中，首先，由于 mPath 对象是每次都复用的，所以，在每次计算裁剪区域前, 都需要调用 mPath.reset() 函数将区域置空。 其次，根据计算裁剪区域的原理循环计算图片中每条间隔的裁剪区域并添加到 mPath 对象中。12345678910while (i * CLIP_HEIGHT &lt;= height) &#123; if (i % 2 == 0) &#123; mRect.set(0, i * CLIP_HEIGHT, clipWidth, (i+1) * CLIP_HEIGHT); &#125; else &#123; mRect.set(width - clipWidth, i * CLIP_HEIGHT, width, (i+1) * CLIP_HEIGHT); &#125; // 替换 Region.union 方法 mPath.addRect(mRect, Path.Direction.CCW); i++;&#125; 最后，将图片绘制在裁剪过的画布上，并渐变增大裁剪区域。123canvas.clipPath(mPath);canvas.drawBitmap(mBitmap, 0, 0, mPaint);clipWidth += 5; 需要注意的是，当裁剪区域超过图像大小时，表示当前图像已经完全被绘制出来，可以暂停当前的绘制，以免浪费 CPU 资源。 当图片宽高超过控件自身大小时，裁剪动画效果很差，因此对原图进行缩放并重置参数。其效果图如下所示：]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[T002 自定义控件 裁剪圆形和圆角头像]]></title>
    <url>%2F2019%2F07%2F15%2FCustom%20View%2FT002%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E8%A3%81%E5%89%AA%E5%9C%86%E5%BD%A2%E5%92%8C%E5%9C%86%E8%A7%92%E5%A4%B4%E5%83%8F%2F</url>
    <content type="text"><![CDATA[参考知识点：01.5 精通自定义 View 之绘图基础——Canvas 一、原理利用 clip 系列函数，通过与 Rect、Path、Region 取交、并、差等集合运算来获得最新的画布形状。此处只需要裁处圆形和圆角矩形，使用 Path 类构建即可，并用 clipPath 裁剪画布。1234567Path path = new Path();RectF rect = new RectF(50, 50, 240, 200);path.addRoundRect(rect, 10, 10, Path.Direction.CCW);// float[] radii = &#123;10,15,20,25,30,35,40,45&#125;;// path.addRoundRect(rect, radii, Path.Direction.CW);canvas.clipPath(path); 二、步骤1. 初始化1234567891011121314151617181920212223public class RoundImageView extends View &#123; private Paint mPaint; private Path mPath; private Bitmap mBmp; public RoundImageView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; private void init() &#123; // 禁用硬件加速 setLayerType(LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mPath = new Path(); mBmp = BitmapFactory.decodeResource(getResources(), R.drawable.meinv); int x = mBmp.getWidth() / 2; int y = mBmp.getHeight() / 2; int r = Math.min(x, y); mPath.addCircle(x, y, r, Path.Direction.CCW); &#125;&#125; 在使用 clip 系列函数时，要禁用硬件加速功能。然后利用 BitmapFactory.decodeResource() 函数从本地 res 文件夹中提取一个 Bitmap 文件。接着根据位图文件的大小，构造一条与图像大小相同的圆形路径。 2. 绘制圆形图像在绘图时，先将画布裁剪成圆形，再将位图画上去。123456789@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.save(); canvas.clipPath(mPath); canvas.drawBitmap(mBmp, 0, 0, mPaint); canvas.restore();&#125; 4. 绘制圆角图像12345678910111213141516171819202122232425262728293031323334353637383940public class RoundImageView extends View &#123; private Paint mPaint; private Path mPath; private Bitmap mBmp; private boolean isCircle = false; // true：圆形图像；false：圆角矩形 public RoundImageView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; private void init() &#123; // 禁用硬件加速 setLayerType(LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mPath = new Path(); mBmp = BitmapFactory.decodeResource(getResources(), R.drawable.head); if (isCircle) &#123; int x = mBmp.getWidth() / 2; int y = mBmp.getHeight() / 2; int r = Math.min(x, y); mPath.addCircle(x, y, r, Path.Direction.CCW); &#125; else &#123; RectF rectF = new RectF(); rectF.set(0, 0, mBmp.getWidth(), mBmp.getHeight()); mPath.addRoundRect(rectF, 20, 20, Path.Direction.CW); &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.save(); canvas.clipPath(mPath); canvas.drawBitmap(mBmp, 0, 0, mPaint); canvas.restore(); &#125;&#125; 三、优化对上述代码可以进行以下几个方面优化： 参数可配置：圆形与圆角矩形切换、圆角大小、图片资源等。 图片缩放至控件大小。 由于 Android 提供的 ImageView 已经处理好了各种缩放问题，我们可以在它的基础上添加一个显示圆角圆形的功能。详见博客：圆角圆形ImageView。]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[T001 自定义控件 蜘蛛网状图]]></title>
    <url>%2F2019%2F07%2F14%2FCustom%20View%2FT001%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E8%9C%98%E8%9B%9B%E7%BD%91%E7%8A%B6%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[参考知识点：01.2 精通自定义 View 之绘图基础——路径 从效果图中可以看出，我们要先画出一个网格，默认网格数和边角数都是 6。在代码中，为了简化逻辑，我们会将所有可变的内容，比如画笔颜色、网格数、边角数设为固定值。其实这些值都应该在初始化的时候通过对应的 set 函数设置到自定义控件内部，大家可以自行补充。 一、初始化不要在 onDraw() 函数中创建变量，所以必然会有一个初始化函数，用于在创建控件的时候初始化画笔等参数。12345678910111213141516171819202122232425262728293031323334353637383940public class SpiderView extends View &#123; private Paint mRadarPaint; // 蜘蛛网 private Paint mRadarLinePaint; // 蜘蛛网辐射的六根线 private Paint mValuePaint; // 数据 private int mRadarPaintColor = 0xFF0099CC; // 网格默认颜色 private Path mPath; public SpiderView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; /** * init view * Paint、Path */ private void init() &#123; mRadarPaint = generatePaint(mRadarPaintColor, Paint.Style.FILL); mRadarLinePaint = generatePaint(Color.WHITE, Paint.Style.STROKE); mValuePaint = generatePaint(0xAFFF0000, Paint.Style.FILL); mPath = new Path(); &#125; /** * 初始化画笔 * @param color 画笔颜色 * @param style 画笔样式 * @return Paint */ private Paint generatePaint(int color, Paint.Style style) &#123; Paint paint = new Paint(); paint.setColor(color); paint.setStyle(style); paint.setAntiAlias(true); return paint; &#125;&#125; 这里初始化了三个画笔，其中 mRadarPaint 是用来绘制蜘蛛网格的，类型设置为填充 (也可以设置为描边)；mRadarLinePaint 是用来绘制蜘蛛网格辐射的六根线，白色描边；而 mValuePaint 是用来绘制结果图的，所以设置成带透明的红色画笔，样式为填充。 二、获得布局中心在 onSizeChanged(int w, int h, int oldW, int oldH) 函数中，根据 View 的长、宽，获取整个布局的中心坐标，因为整个雷达都是从这个中心坐标开始绘制的。12345678910111213private float radius; // 网格最大半径private int centerX; // 中心 Xprivate int centerY; // 中心 Y@Overrideprotected void onSizeChanged(int w, int h, int oldW, int oldH) &#123; // 获得布局中心 centerX = w / 2; centerY = h / 2; radius = Math.min(w, h) / 2f * 0.8f; postInvalidate(); super.onSizeChanged(w, h, oldW, oldH);&#125; 我们知道，在控件大小发生变化时，都会通过 onSizeChanged() 函数通知我们当前控件的大小。所以，我们只需要重写 onSizeChanged() 函数，即可得知当前控件的最新大小。 为了不顶边，将蜘蛛网的半径设置为 Math.min(w, h) / 2f * 0.8f 。 然后依据绘图中心，分别绘制蜘蛛网格、网格中线、数据图，即可完成整个效果图的绘制。12345678910@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 绘制蜘蛛网格 drawPolygon(canvas); // 绘制中线 drawLines(canvas); // 画数据图 drawRegion(canvas);&#125; 三、绘制蜘蛛网格下面我们就要绘制蜘蛛网格了，效果如下图所示。 很显然，蜘蛛网格是利用 Path 的 moveTo() 和 lineTo() 函数一圈圈画出来的，我们需要计算出每个转折点的位置。比如，计算下图中所标记点的 x, y 坐标。 很明显，标记点在半径的 3/4 位置，而标记点与中心点的连线与 X 轴的夹角为 a，所以由图可得:12x = centX + 3/4 * radius * sina;y = centY + 3/4 * radius * cosa; 因为我们共画了 6 个角，所以每个角的度数应该是 360°/6 = 60°。依据上面的原理，列出画蜘蛛网格的代码如下:123456789101112131415161718192021222324private int count = 6; // 多边形，默认值为 6private double angle = 2 * Math.PI / count; // 角度，值为 2π / count，默认private int maxValue = 4; // 最大值private void drawPolygon(Canvas canvas) &#123; float r = radius / maxValue; // r是蜘蛛丝之间的间距 for (int i = 1; i &lt;= maxValue; i++) &#123; // 中心点不用绘制 float curR = r * i; // 当前半径 mPath.reset(); for (int j = 0; j &lt; count; j++) &#123; if (j == 0) &#123; mPath.moveTo(centerX + curR, centerY); &#125; else &#123; // 根据半径，计算出蜘蛛丝上每个点的坐标 float x = (float) (centerX + curR * Math.cos(angle * j)); float y = (float) (centerY + curR * Math.sin(angle * j)); mPath.lineTo(x, y); &#125; &#125; mPath.close(); // 闭合路径 mRadarPaint.setAlpha(getRadarPaintColor(i)); canvas.drawPath(mPath, mRadarPaint); &#125;&#125; 四、画网格中线在画完蜘蛛网格以后，我们需要画从网格中心到末端的直线，代码如下:12345678910private void drawLines(Canvas canvas) &#123; for (int i = 0; i &lt; count; i++) &#123; mPath.reset(); mPath.moveTo(centerX, centerY); float x = (float) (centerX + radius * Math.cos(angle * i)); float y = (float) (centerY + radius * Math.sin(angle * i)); mPath.lineTo(x, y); canvas.drawPath(mPath, mRadarLinePaint); &#125;&#125; 绘制原理与绘制蜘蛛网格是一样的，先找到各个末端点的坐标，然后画一条从中心点到末端点的连线即可。 五、画数据图绘制数据区域其实也很简单，首先要确定每个数据点的位置。当然，网格线中的每一层网格都应该对应一个数值，在这里为了方便起见，将网格的最大值设为 4，即每一层数值是按 1,2,3,4 分布的。1234567891011121314151617private int maxValue = 4; // 最大值private double[] data = &#123;2,3,1,3,4,3&#125;; // 数据private void drawRegion(Canvas canvas) &#123; mPath.reset(); for (int i = 0; i &lt; count; i++) &#123; double percent = data[i] / maxValue; float x = (float) (centerX + radius * Math.cos(angle * i) * percent); float y = (float) (centerY + radius * Math.sin(angle * i) * percent); if (i == 0) &#123; mPath.moveTo(x, centerY); &#125; else &#123; mPath.lineTo(x, y); &#125; &#125; canvas.drawPath(mPath, mValuePaint);&#125; 六、完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144package com.xxt.xtest;import android.content.Context;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.Path;import android.util.AttributeSet;import android.view.View;import androidx.annotation.Nullable;public class SpiderView extends View &#123; private Paint mRadarPaint; // 蜘蛛网 private Paint mRadarLinePaint; // 蜘蛛网辐射的六根线 private Paint mValuePaint; // 数据 private int mRadarPaintColor = 0xFF0099CC; // 网格默认颜色 private Path mPath; private float radius; // 网格最大半径 private int centerX; // 中心 X private int centerY; // 中心 Y private int count = 6; // 多边形，默认值为 6 private double angle = 2 * Math.PI / count; // 角度，值为 2π / count，默认 private int maxValue = 4; // 最大值 private double[] data = &#123;2,3,1,3,4,3&#125;; // 数据 public SpiderView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; /** * init view * Paint、Path */ private void init() &#123; mRadarPaint = generatePaint(mRadarPaintColor, Paint.Style.FILL); mRadarLinePaint = generatePaint(Color.WHITE, Paint.Style.STROKE); mValuePaint = generatePaint(0xAFFF0000, Paint.Style.FILL); mPath = new Path(); &#125; @Override protected void onSizeChanged(int w, int h, int oldW, int oldH) &#123; // 获得布局中心 centerX = w / 2; centerY = h / 2; radius = Math.min(w, h) / 2f * 0.8f; postInvalidate(); super.onSizeChanged(w, h, oldW, oldH); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 绘制蜘蛛网格 drawPolygon(canvas); // 绘制中线 drawLines(canvas); // 画数据图 drawRegion(canvas); &#125; private void drawPolygon(Canvas canvas) &#123; float r = radius / maxValue; // r是蜘蛛丝之间的间距 for (int i = 1; i &lt;= maxValue; i++) &#123; // 中心点不用绘制 float curR = r * i; // 当前半径 mPath.reset(); for (int j = 0; j &lt; count; j++) &#123; if (j == 0) &#123; mPath.moveTo(centerX + curR, centerY); &#125; else &#123; // 根据半径，计算出蜘蛛丝上每个点的坐标 float x = (float) (centerX + curR * Math.cos(angle * j)); float y = (float) (centerY + curR * Math.sin(angle * j)); mPath.lineTo(x, y); &#125; &#125; mPath.close(); // 闭合路径 mRadarPaint.setAlpha(getRadarPaintColor(i)); canvas.drawPath(mPath, mRadarPaint); &#125; &#125; private void drawLines(Canvas canvas) &#123; for (int i = 0; i &lt; count; i++) &#123; mPath.reset(); mPath.moveTo(centerX, centerY); float x = (float) (centerX + radius * Math.cos(angle * i)); float y = (float) (centerY + radius * Math.sin(angle * i)); mPath.lineTo(x, y); canvas.drawPath(mPath, mRadarLinePaint); &#125; &#125; private void drawRegion(Canvas canvas) &#123; mPath.reset(); for (int i = 0; i &lt; count; i++) &#123; double percent = data[i] / maxValue; float x = (float) (centerX + radius * Math.cos(angle * i) * percent); float y = (float) (centerY + radius * Math.sin(angle * i) * percent); if (i == 0) &#123; mPath.moveTo(x, centerY); &#125; else &#123; mPath.lineTo(x, y); &#125; &#125; canvas.drawPath(mPath, mValuePaint); &#125; /** * 初始化画笔 * @param color 画笔颜色 * @param style 画笔样式 * @return Paint */ private Paint generatePaint(int color, Paint.Style style) &#123; Paint paint = new Paint(); paint.setColor(color); paint.setStyle(style); paint.setAntiAlias(true); return paint; &#125; /** * 由内到外，增加透明度 * @param i 第几个网格，从中心点算起 * @return int alpha 值 */ private int getRadarPaintColor(int i) &#123; if (i &gt; count || i &lt; 1) &#123; return 0xFF; &#125; int alpha = Color.alpha(mRadarPaintColor); int colorStep = alpha / (maxValue - 1) - 10; alpha = alpha - colorStep * (i - 1); return alpha; &#125;&#125;]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13.2 精通自定义 View 之控件高级属性——Window 与 WindowManager]]></title>
    <url>%2F2019%2F07%2F13%2FCustom%20View%2F13.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94Window%20%E4%B8%8E%20WindowManager%2F</url>
    <content type="text"><![CDATA[Window 表示窗口，在某些特殊的时候，比如需要在桌面或者锁屏上显示一些类似悬浮窗的效果，就需要用到 Window。Android 中所有的视图都是通过 Window 来呈现的，不管是 Activity、Dialog 还是 Toast，它们的视图实际上都是附加在 Window 上的。而 WindowManager 则提供了对这些 Window 的统一管理功能。 13.2.1 Window 与 WindowManager 的联系为了分析 Window 的工作机制，我们需要了解如何使用 WindowManager 来添加一个 Window。123WindowManager manager = (WindowManager) getSystemService(Context.WINDOW_SERVICE);WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams(width, height, type, flags, format);manager.addView(btn, layoutParams); 上面的伪代码看起来非常简单，在构建 WindowManager.LayoutParams 时，其中的 type 和 flags 参数比较重要。 flags 参数有很多选项，用来控制 Window 的显示特性。我们来看几个常用的选项。1public static final int FLAG_NOT_FOCUSABLE = 0x00000008; 表示此 Window 不需要获取焦点，不接收各种输入时间，此标记会同时启用 FLAG_NOT_TOUCH_MODEL，最终事件会直接传递给下层具有焦点的 Window。1public static final int FLAG_NOT_TOUCH_MODEL = 0x00000020; 自己 Window 区域内的事件自己处理；自己 Window 区域外的事件传递给底层 Window 处理。一般这个选项会默认开启，否则其他 Window 无法接收事件。1public static final int FLAG_SHOW_WHEN_LOCKED = 0x00080000; 可以让此 Window 显示在锁屏上。 type 参数是 int 类型的，表示 Window 的类型。Window 有三种类型：应用 Window、子 Window 和系统 Window。应用 Window 对应着一个 Activity。子 Window 不能独立存在，它需要附属在特定的父 Window 中，比如 Dialog 就是一个子 Window。系统 Window 是需要声明权限才能创建的，比如 Toast 和系统状态栏都是系统 Window。 Window 是分层的，层级大的 Window 会覆盖在层级小的 Window 上面。 应用 Window 的层级范围：1 ~ 99。 子 Window 的层级范围：1000 ~ 1999。 系统 Window 的层级范围：2000 ~ 2999。 type 参数就对应这些数字。如果想让 Window 置于顶层，则采用较大的层级即可；如果是系统类型的 Window，则需要在 AndroidMenifest.xml 中配置如下权限声明，否则会报权限不足的错误。1&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt; WindowManager 提供的功能很简单，常用的只有三个方法，即添加 View、更新 View 和删除 View。这三个方法定义在 ViewManager 中，而 WindowManager 继承自 ViewManager。123456789@SystemService(Context.WINDOW_SERVICE)public interface WindowManager extends ViewManager &#123;&#125;public interface ViewManager &#123; public void addView(View view, ViewGroup.LayoutParams params); public void updateViewLayout(View view, ViewGroup.LayoutParams params); public void removeView(View view);&#125; 13.2.2 示例：悬浮窗 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class MainActivity extends AppCompatActivity implements View.OnTouchListener, View.OnClickListener &#123; private ImageView mImageView; private WindowManager.LayoutParams mLayoutParams; private WindowManager mWindowManager; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION); startActivityForResult(intent, 100); &#125; initView(); &#125; private void initView() &#123; findViewById(R.id.add_btn).setOnClickListener(this); findViewById(R.id.rmv_btn).setOnClickListener(this); mWindowManager = (WindowManager) getApplicationContext().getSystemService(Context.WINDOW_SERVICE); &#125; @Override public void onClick(View v) &#123; if (v.getId() == R.id.add_btn) &#123; mImageView = new ImageView(this); mImageView.setBackgroundResource(R.mipmap.ic_launcher_round); mLayoutParams = new WindowManager.LayoutParams( WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.WRAP_CONTENT, 2099, WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED, PixelFormat.TRANSPARENT ); mLayoutParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_ERROR; mLayoutParams.gravity = Gravity.TOP | Gravity.LEFT; mLayoutParams.x = 0; mLayoutParams.y = 300; mImageView.setOnTouchListener(this); mWindowManager.addView(mImageView, mLayoutParams); &#125; else if (v.getId() == R.id.rmv_btn) &#123; if (mWindowManager != null &amp;&amp; mImageView != null) &#123; mWindowManager.removeViewImmediate(mImageView); &#125; &#125; &#125; @Override public boolean onTouch(View v, MotionEvent event) &#123; int rawX = (int) event.getRawX(); int rawY = (int) event.getRawY(); if (event.getAction() == MotionEvent.ACTION_MOVE) &#123; mLayoutParams.x = rawX; mLayoutParams.y = rawY; mWindowManager.updateViewLayout(mImageView, mLayoutParams); &#125; return false; &#125; @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == 100) &#123; initView(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13.1 精通自定义 View 之控件高级属性——GestureDetector 手势检测]]></title>
    <url>%2F2019%2F07%2F13%2FCustom%20View%2F13.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94GestureDetector%20%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[13.1.1 概述GestureDetector，手势检测类，通过这个类可以识别很多手势。在识别出手势之后，具体的事物处理则交由程序员自己来实现。 此类提供了两个接口（OnGestureListener、OnDoubleTapListener）和一个外部类（SimpleOnGestureListener）。这个外部类其实是两个接口中所有函数的集成，它包含了这两个接口里所有必须实现的函数，而且都已经被重写，但所有函数体都是空的。该类是一个静态类，程序员可以在外部继承这个类，重写里面的手势处理函数。 13.1.2 GestureDetector.OnGestureListener 接口1. 基本讲解如果我们写一个类并继承自 OnGestureListener，则会提示有几个必须重写的函数。代码如下：123456789101112131415161718192021222324252627282930private class GestureListener implements GestureDetector.OnGestureListener &#123; @Override public boolean onDown(MotionEvent e) &#123; return false; &#125; @Override public void onShowPress(MotionEvent e) &#123; &#125; @Override public boolean onSingleTapUp(MotionEvent e) &#123; return false; &#125; @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123; return false; &#125; @Override public void onLongPress(MotionEvent e) &#123; &#125; @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123; return false; &#125;&#125; 这些函数在什么情况下才会被触发呢？ onDown(MotionEvent e)：用户按下屏幕就会触发该函数。 onShowPress(MotionEvent e)：如果按下的时间超过瞬间，而且在按下的时候没有松开或者是拖动的，该函数就会被触发。 onLongPress(MotionEvent e)：长按触摸屏，超过一定时长，就会触发这个函数。 触发顺序：1onDown —&gt; onShowPress —&gt; onLongPress onSingleTapUp(MotionEvent e)：一次单独的轻击抬起操作，也就是轻击一下屏幕，立刻抬起来，才会触发这个函数。当然，如果除 down 以外还有其他操作，就不再算是单独操作了，也就不会触发这个函数。 单击一下非常快的（不滑动）Touchup，触发顺序：1onDown —&gt; onSingleTapUp —&gt; onSingleTapConfirmed 单击一下稍微慢一点的（不滑动）Touchup，触发顺序：1onDown —&gt; onShowPress —&gt; onSingleTapUp —&gt; onSingleTapConfirmed onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY)：滑屏，用户按下触摸屏、快速移动后松开，由一个 MotionEvent ACTION_DOWN、多个 ACTION_MOVE、一个 ACTION_UP 触发。 onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY)：在屏幕上拖动事件。无论是用手拖动 View，还是以抛的动作滚动，都会多次触发这个函数，在 ACTION_MOVE 动作发生时就会触发该函数。 滑屏，即手指出动屏幕后，稍微滑动后立即松开，触发顺序为：1onDown —&gt; onScroll —&gt; onScroll —&gt; onScroll —&gt; ... —&gt; onFling 拖动，触发顺序为：1onDown —&gt; onScroll —&gt; onScroll —&gt; onFling 可见，无论是滑屏还是拖动，影响的只是中间 onScroll 被触发的数量而已，最终都会触发 onFling 事件。 2. 示例要使用 GestureDetector，有四步要走。1）创建 OnGestureListener() 监听函数。123456// 可以构造实例GestureDetector.OnGestureListener listener = new GestureDetector.OnGestureListener() &#123;&#125;;// 也可以构造类private class GestureListener implements GestureDetector.OnGestureListener &#123;&#125; 2）创建 GestureDetector 实例 mGestureDetector。构造函数有以下几个，根据需要选择即可。1234GestureDetector(OnGestureListener listener)GestureDetector(Context context, OnGestureListener listener)GestureDetector(Context context, OnGestureListener listener, Handler handler)GestureDetector(Context context, OnGestureListener listener, Handler handler, boolean unused) 3）在 onTouch(View v, MotionEvent event) 中进行拦截。123public boolean onTouch(View v, MotionEvent event) &#123; return mGestureDetector.onTouchEvent(event);&#125; 4）绑定控件。12TextView tv = findViewById(R.id.tv);tv.setOnTouchListener(this); 完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class MainActivity extends AppCompatActivity implements View.OnTouchListener &#123; private GestureDetector mGestureDetector; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); mGestureDetector = new GestureDetector(new GestureListener()); TextView tv = findViewById(R.id.tv); tv.setOnTouchListener(this); tv.setFocusable(true); tv.setClickable(true); tv.setLongClickable(true); &#125; @Override public boolean onTouch(View v, MotionEvent event) &#123; return mGestureDetector.onTouchEvent(event); &#125; private class GestureListener implements GestureDetector.OnGestureListener &#123; @Override public boolean onDown(MotionEvent e) &#123; Log.i(&quot;MyGesture&quot;, &quot;onDown&quot;); return false; &#125; @Override public void onShowPress(MotionEvent e) &#123; Log.i(&quot;MyGesture&quot;, &quot;onShowPress&quot;); &#125; @Override public boolean onSingleTapUp(MotionEvent e) &#123; Log.i(&quot;MyGesture&quot;, &quot;onSingleTapUp&quot;); return false; &#125; @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123; Log.i(&quot;MyGesture&quot;, &quot;onScroll&quot;); return false; &#125; @Override public void onLongPress(MotionEvent e) &#123; Log.i(&quot;MyGesture&quot;, &quot;onLongPress&quot;); &#125; @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123; Log.i(&quot;MyGesture&quot;, &quot;onFling&quot;); return false; &#125; &#125;&#125; 13.1.3 GestureDetector.OnDoubleTapListener 接口1. 构建有两种方式设置双击监听。方法一：新建一个类，同时派生自 OnGestureListener 和 OnDoubleTapListener。123private class GestureListener implements GestureDetector.OnGestureListener, GestureDetector.OnDoubleTapListener &#123;&#125; 方法二：使用 GestureDetector.setOnDoubleTapListener() 函数设置双击监听。12345678910// 构建 GestureDetector 实例mGestureDetector = new GestureDetector(new GestureListener());private class GestureListener implements GestureDetector.OnGestureListener &#123;&#125;// 设置双击监听mGestureDetector.setOnDoubleTapListener(new DoubleTapListener());private class DoubleTapListener implements GestureDetector.OnDoubleTapListener &#123;&#125; 无论方法一还是方法二，都需要派生自 GestureDetector.OnGestureListener。 2. 函数讲解先来看下 OnDoubleTapListener 接口必须重写的三个函数。1234567891011121314151617private class DoubleTapListener implements GestureDetector.OnDoubleTapListener &#123; @Override public boolean onSingleTapConfirmed(MotionEvent e) &#123; return false; &#125; @Override public boolean onDoubleTap(MotionEvent e) &#123; return false; &#125; @Override public boolean onDoubleTapEvent(MotionEvent e) &#123; return false; &#125;&#125; onSingleTapConfirmed(MotionEvent e)：单击事件，用来判定该次单击是 SingleTap，而不是 DoubleTap。如果连续单击两次，就是 DoubleTap 手势；如果只单击一次，系统等待一段时间后没有收到第二次单击，则判定该次单击为 SingleTap，而不是 DoubleTap，然后触发 SingleTapConfirm 事件。触发顺序是：onDown —&gt; onSingleTapUp —&gt; onSingleTapConfirmed。有这样一个函数 onSingleTapUp()，它和 onSingleTapConfirmed() 函数容易混淆。二者的区别是：对于 onSingleTapUp() 函数来说，只要手抬起就会被触发；而对于 onSingleTapConfirmed() 函数来说，如果双击，则该函数就不会被触发。 onDoubleTap(MotionEvent e)：双击事件。 onDoubleTapEvent(MotionEvent e)：双击间隔中发生的动作。指在触发 onDoubleTap 以后，在双击之间发生的其他动作，包含 down、up 和 move 事件。 在 13.1.2 节例子的基础上，添加双击监听，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class MainActivity extends AppCompatActivity implements View.OnTouchListener &#123; private GestureDetector mGestureDetector; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); mGestureDetector = new GestureDetector(new GestureListener()); mGestureDetector.setOnDoubleTapListener(new DoubleTapListener()); TextView tv = findViewById(R.id.tv); tv.setOnTouchListener(this); tv.setFocusable(true); tv.setClickable(true); tv.setLongClickable(true); &#125; @Override public boolean onTouch(View v, MotionEvent event) &#123; return mGestureDetector.onTouchEvent(event); &#125; private class GestureListener implements GestureDetector.OnGestureListener &#123; @Override public boolean onDown(MotionEvent e) &#123; Log.i(&quot;MyGesture&quot;, &quot;onDown&quot;); return false; &#125; @Override public void onShowPress(MotionEvent e) &#123; Log.i(&quot;MyGesture&quot;, &quot;onShowPress&quot;); &#125; @Override public boolean onSingleTapUp(MotionEvent e) &#123; Log.i(&quot;MyGesture&quot;, &quot;onSingleTapUp&quot;); return true; &#125; @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123; Log.i(&quot;MyGesture&quot;, &quot;onScroll&quot;); return true; &#125; @Override public void onLongPress(MotionEvent e) &#123; Log.i(&quot;MyGesture&quot;, &quot;onLongPress&quot;); &#125; @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123; Log.i(&quot;MyGesture&quot;, &quot;onFling&quot;); return true; &#125; &#125; private class DoubleTapListener implements GestureDetector.OnDoubleTapListener &#123; @Override public boolean onSingleTapConfirmed(MotionEvent e) &#123; Log.i(&quot;MyGesture&quot;, &quot;onSingleTapConfirmed&quot;); Toast.makeText(MainActivity.this, &quot;onSingleTapConfirmed&quot;, Toast.LENGTH_LONG).show(); return true; &#125; @Override public boolean onDoubleTap(MotionEvent e) &#123; Log.i(&quot;MyGesture&quot;, &quot;onDoubleTap&quot;); Toast.makeText(MainActivity.this, &quot;onDoubleTap&quot;, Toast.LENGTH_LONG).show(); return true; &#125; @Override public boolean onDoubleTapEvent(MotionEvent e) &#123; Log.i(&quot;MyGesture&quot;, &quot;onDoubleTapEvent:&quot; + e.getAction()); Toast.makeText(MainActivity.this, &quot;onDoubleTapEvent&quot;, Toast.LENGTH_LONG).show(); return true; &#125; &#125;&#125; 双击所对应的事件触发顺序如下图所示。 第二次单击时，先触发 onDoubleTap，再触发 onDown。 在触发 onDoubleTap 以后，就开始触发 onDoubleTapEvent。onDoubleTapEvent 后面的数字代表当前的事件，0 代表 ACTION_DOWN，1 代表 ACTION_UP，2 代表 ACTION_MOVE。 轻轻单击一下，对应的事件触发顺序如下： 13.1.4 GestureDetector.SimpleOnGestureListener 类SimpleOnGestureListener 类与 OnGestureListener 和 OnDoubleTapListener 接口的不同之处在于：1）这是一个类，在它的基础上新建类，要用 extends 派生，而不能用 implements 继承。2）OnGestureListener 和 OnDoubleTapListener 接口里的函数都是被强制重写的，即使用不到也要重写出来一个空函数；而在 SimpleOnGestureListener 类的实例或派生类中不必如此，可以根据情况，用到哪个函数就重写哪个函数，因为 SimpleOnGestureListener 类本身已经实现了这两个接口中的所有函数，只是里面全是空的而已。 下面利用 SimpleOnGestureListener 类来重新实现前面的几个效果，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class MainActivity extends AppCompatActivity implements View.OnTouchListener &#123; private GestureDetector mGestureDetector; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); mGestureDetector = new GestureDetector(new XSimpleGestureListener()); TextView tv = findViewById(R.id.tv); tv.setOnTouchListener(this); tv.setFocusable(true); tv.setClickable(true); tv.setLongClickable(true); &#125; @Override public boolean onTouch(View v, MotionEvent event) &#123; return mGestureDetector.onTouchEvent(event); &#125; private class XSimpleGestureListener extends GestureDetector.SimpleOnGestureListener &#123; /***** OnGestureListener 的函数 *****/ public boolean onDown(MotionEvent e) &#123; return false; &#125; public void onShowPress(MotionEvent e) &#123; &#125; public boolean onSingleTapUp(MotionEvent e) &#123; return false; &#125; public void onLongPress(MotionEvent e) &#123; &#125; public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123; return false; &#125; public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123; return false; &#125; /***** OnDoubleTapListener 的函数 *****/ public boolean onDoubleTap(MotionEvent e) &#123; return false; &#125; public boolean onDoubleTapEvent(MotionEvent e) &#123; return false; &#125; public boolean onSingleTapConfirmed(MotionEvent e) &#123; return false; &#125; &#125;&#125; 13.1.5 onFling() 函数的应用可以利用 onFling() 函数来识别当前用户是在左滑还是在右滑。先来看一下 onFling() 函数的参数。1boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) 参数： e1：第一个 ACTION_DOWN MotionEvent。 e2：最后一个 ACTION_DOWN MotionEvent。 velocityX：X 轴上的移动速度，单位为像素/秒。 velocityY：Y 轴上的移动速度，单位为像素/秒。 实现的功能：当用户向左滑动距离超过 100 像素，且滑动速度超过 100 像素/秒时，即判断为向左滑动；向右同理。核心代码如下：123456789101112131415161718192021private class XSimpleGestureListener extends GestureDetector.SimpleOnGestureListener &#123; final int FLING_MIN_DISTANCE = 100; final int FLING_MIN_VELOCITY = 100; ... public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123; // 向左滑 if (e1.getX() - e2.getX() &gt; FLING_MIN_DISTANCE &amp;&amp; Math.abs(velocityX) &gt; FLING_MIN_VELOCITY) &#123; Log.i(&quot;MyGesture&quot;, &quot;Fling left&quot;); &#125; // 向右滑 else if (e2.getX() - e1.getX() &gt; FLING_MIN_DISTANCE &amp;&amp; Math.abs(velocityX) &gt; FLING_MIN_VELOCITY) &#123; Log.i(&quot;MyGesture&quot;, &quot;Fling right&quot;); &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12.3 精通自定义 View 之封装控件——实现 FlowLayout 容器]]></title>
    <url>%2F2019%2F07%2F12%2FCustom%20View%2F12.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%20FlowLayout%20%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[12.3.1 XML 布局先定义一个 style 标签，这是为 FlowLayout 中的 TextView 定义的。12345678910&lt;resources&gt; ... &lt;style name=&quot;text_flag&quot;&gt; &lt;item name=&quot;android:layout_width&quot;&gt;wrap_content&lt;/item&gt; &lt;item name=&quot;android:layout_height&quot;&gt;wrap_content&lt;/item&gt; &lt;item name=&quot;android:layout_margin&quot;&gt;4dp&lt;/item&gt; &lt;item name=&quot;android:background&quot;&gt;@drawable/flag&lt;/item&gt; &lt;item name=&quot;android:textColor&quot;&gt;#FFFFFF&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; /res/drawable/flag.xml123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;solid android:color=&quot;@color/colorAccent&quot;/&gt; &lt;padding android:top=&quot;5dp&quot; android:bottom=&quot;5dp&quot; android:left=&quot;10dp&quot; android:right=&quot;10dp&quot;/&gt; &lt;corners android:radius=&quot;30dp&quot;/&gt;&lt;/shape&gt; act_main.xml 的布局代码：123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.xxt.xtest.FlowLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView style=&quot;@style/text_flag&quot; android:text=&quot;Welcome&quot;/&gt; &lt;TextView style=&quot;@style/text_flag&quot; android:text=&quot;IT 工程师&quot;/&gt; &lt;TextView style=&quot;@style/text_flag&quot; android:text=&quot;我真是可以的&quot;/&gt; &lt;TextView style=&quot;@style/text_flag&quot; android:text=&quot;你觉得呢&quot;/&gt; &lt;TextView style=&quot;@style/text_flag&quot; android:text=&quot;不要只知道挣钱&quot;/&gt; &lt;TextView style=&quot;@style/text_flag&quot; android:text=&quot;努力 ing&quot;/&gt; &lt;TextView style=&quot;@style/text_flag&quot; android:text=&quot;I thick i can&quot;/&gt; &lt;/com.xxt.xtest.FlowLayout&gt;&lt;/LinearLayout&gt; 12.3.2 提取 margin 值与重写 onMeasure() 函数1. 提取 margin 值12345678910111213141516171819public class FlowLayout extends ViewGroup &#123; ... @Override protected LayoutParams generateLayoutParams(LayoutParams p) &#123; return new MarginLayoutParams(p); &#125; @Override public LayoutParams generateLayoutParams(AttributeSet attrs) &#123; return new MarginLayoutParams(getContext(), attrs); &#125; @Override protected LayoutParams generateDefaultLayoutParams() &#123; return new MarginLayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT); &#125;&#125; 2. 重写 onMeasure() 函数要实现 FlowLayout，必然涉及下面几个问题。1）何时换行从效果图中可以看到，FlowLayout 的布局是一行行的，如果当期已经放不下一个控件了，就把这个控件移到下一行显示。所以需要一个变量来计算当前行已经占据的宽度，以判断剩下的空间是否还能容得下下一个控件。2）如何得到 FlowLayout 的宽度FlowLayout 的宽度是所有行宽度的最大值，所以我们要记录每一行所占据的宽度值，进而找到所有值中的最大值。3）如何得到 FlowLayout 的高度FlowLayout 的高度是每一行高度的总和，而每一行的高度则取该行中所有控件高度的最大值。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int measureWidth = MeasureSpec.getSize(widthMeasureSpec); int measureHeight = MeasureSpec.getSize(heightMeasureSpec); int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec); int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec); int lineWidth = 0; // 记录每一行的宽度 int lineHeight = 0; // 记录每一行的高度 int width = 0; // 记录整个 FlowLayout 的宽度 int height = 0; // 记录整个 FlowLayout 的高度 int count = getChildCount(); for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); measureChild(child, widthMeasureSpec, heightMeasureSpec); // 计算控件的宽高时，要加上上下左右的 margin 值 MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin; int childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin; if (lineWidth + childWidth &gt; measureWidth) &#123; // 需要换行 width = Math.max(lineWidth, childWidth); height += lineHeight; // 当前行放不下当前控件，而将此控件调到下一行 // 所以将此控件的高度和宽度初始化给 lineWidth、lineHeight lineWidth = childWidth; lineHeight = childHeight; &#125; else &#123; // 否则累加值 lineWidth，lineHeight 并取最大高度 lineWidth += childWidth; lineHeight = Math.max(lineHeight, childHeight); &#125; // 因为最后一行是不会超出 width 范围的，所以需要单独处理 if (i == count - 1) &#123; width = Math.max(width, lineWidth); height += lineHeight; &#125; &#125; setMeasuredDimension((measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth : width, (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight : height);&#125; 3. 重写 onLayout() 函数——布局所有子控件在 onLayout() 函数中需要一个个布局子控件。由于控件要后移和换行，所以我们要标记当前控件的 top 坐标和 left 坐标。然后计算每个控件的 top 坐标和 left 坐标，再调用 layout(int left, int top, int right, int bottom)。123456789101112131415161718192021222324252627282930313233@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int count = getChildCount(); int lineWidth = 0; // 累加当前行的行宽 int lineHeight = 0; // 当前行的行高 int top = 0, left = 0; // 当前控件的 top 坐标和 left 坐标 for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin; int childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin; if (childWidth + lineWidth &gt; getMeasuredWidth()) &#123; // 如果换行，则当前控件将放到下一行，从最左边开始，所以 left 就是 0； // 而 top 则需要加上上一行的行高，才是这个控件的 top 坐标 top += lineHeight; left = 0; lineHeight = childHeight; lineWidth = childWidth; &#125; else &#123; lineHeight = Math.max(lineHeight, childHeight); lineWidth += childWidth; &#125; // 计算 childView 的 left、top、right、bottom int lc = left + lp.leftMargin; int tc = top + lp.topMargin; int rc = lc + child.getMeasuredWidth(); int bc = tc + child.getMeasuredHeight(); child.layout(lc, tc, rc, bc); // 将 left 置为下一个子控件的起始点 left += childWidth; &#125;&#125; 12.3.3 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class FlowLayout extends ViewGroup &#123; public FlowLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int measureWidth = MeasureSpec.getSize(widthMeasureSpec); int measureHeight = MeasureSpec.getSize(heightMeasureSpec); int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec); int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec); int lineWidth = 0; // 记录每一行的宽度 int lineHeight = 0; // 记录每一行的高度 int width = 0; // 记录整个 FlowLayout 的宽度 int height = 0; // 记录整个 FlowLayout 的高度 int count = getChildCount(); for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); measureChild(child, widthMeasureSpec, heightMeasureSpec); // 计算控件的宽高时，要加上上下左右的 margin 值 MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin; int childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin; if (lineWidth + childWidth &gt; measureWidth) &#123; // 需要换行 width = Math.max(lineWidth, childWidth); height += lineHeight; // 当前行放不下当前控件，而将此控件调到下一行 // 所以将此控件的高度和宽度初始化给 lineWidth、lineHeight lineWidth = childWidth; lineHeight = childHeight; &#125; else &#123; // 否则累加值 lineWidth，lineHeight 并取最大高度 lineWidth += childWidth; lineHeight = Math.max(lineHeight, childHeight); &#125; // 因为最后一行是不会超出 width 范围的，所以需要单独处理 if (i == count - 1) &#123; width = Math.max(width, lineWidth); height += lineHeight; &#125; &#125; setMeasuredDimension((measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth : width, (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight : height); &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int count = getChildCount(); int lineWidth = 0; // 累加当前行的行宽 int lineHeight = 0; // 当前行的行高 int top = 0, left = 0; // 当前控件的 top 坐标和 left 坐标 for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin; int childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin; if (childWidth + lineWidth &gt; getMeasuredWidth()) &#123; // 如果换行，则当前控件将放到下一行，从最左边开始，所以 left 就是 0； // 而 top 则需要加上上一行的行高，才是这个控件的 top 坐标 top += lineHeight; left = 0; lineHeight = childHeight; lineWidth = childWidth; &#125; else &#123; lineHeight = Math.max(lineHeight, childHeight); lineWidth += childWidth; &#125; // 计算 childView 的 left、top、right、bottom int lc = left + lp.leftMargin; int tc = top + lp.topMargin; int rc = lc + child.getMeasuredWidth(); int bc = tc + child.getMeasuredHeight(); child.layout(lc, tc, rc, bc); // 将 left 置为下一个子控件的起始点 left += childWidth; &#125; &#125; @Override protected LayoutParams generateLayoutParams(LayoutParams p) &#123; return new MarginLayoutParams(p); &#125; @Override public LayoutParams generateLayoutParams(AttributeSet attrs) &#123; return new MarginLayoutParams(getContext(), attrs); &#125; @Override protected LayoutParams generateDefaultLayoutParams() &#123; return new MarginLayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT); &#125;&#125;]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12.2 精通自定义 View 之封装控件——测量和布局]]></title>
    <url>%2F2019%2F07%2F12%2FCustom%20View%2F12.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E6%B5%8B%E9%87%8F%E5%92%8C%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[12.2.1 ViewGroup 绘制流程View 和 ViewGroup 的绘制流程基本相同，只是在 ViewGroup 中不仅要绘制自己，还要绘制其中的子控件，而 View 只需要绘制自己就可以了。 绘制流程分为三步：测量、布局、绘制，分别对应 onMeasure()、onLayout()、onDraw() 函数。 onMeasure()：测量当前控件的大小，为正式布局提供建议（注意：只是建议，至于用不用，要看 onLayout() 函数）。 onLayout()：使用 layout() 函数对所有字控件进行布局。 onDraw()：根据布局的位置绘图。 12.2.2 onMeasure() 函数与 MeasureSpec布局绘画涉及两个过程：测量过程和布局过程。测量过程通过 measure() 函数来实现，是 View 树自顶向下的遍历，每个 View 在循环过程中将尺寸细节往下传递，当测量过程完成以后，所有的 View 都存储了自己的尺寸。布局过程则通过 layout() 函数来实现，也是自顶向下的，在这个过程中，每个父 View 负责通过计算好的尺寸放置它的子 View。 onMeasure() 函数是用来测量当前控件大小的，给 onLayout() 函数提供数值参考。需要特别注意的是，测量完成以后，要通过 setMeasuredDimension(int, int) 函数设置给系统。 1. onMeasure() 函数1protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) 参数 widthMeasureSpec 和 heightMeasureSpec 是父类传递给当前 View 的一个建议值，即想把当前 View 的尺寸设置为宽 widthMeasureSpec、高 heightMeasureSpec。 2. MeasureSpec 的组成widthMeasureSpec 和 heightMeasureSpec 转换为二进制数字表示，它们都是 32 位的，前 2 位代表模式（mode），后面 30 位代表数值（size）。 1）模式分类 模式 二进制值 含义 对应 XML UNSPECIFIED 00000000…00000000 父元素不对子元素的确切大小，子元素可以得到任意想要的大小 不常用 EXACTLY 01000000…00000000 父元素决定子元素的确切大小，子元素将被限定在给定的边界里而忽略它本身的大小 match_parent、具体数值 AT_MOST 10000000…00000000 子元素至多达到指定大小的值 wrap_content 2）模式提取使用 &amp; 位运算。12345678910111213private static final int MODE_SHIFT = 30;// 对应：11000000 00000000 00000000 00000000private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT;// 提取模式public static int getMode(int measureSpec) &#123; return (measureSpec &amp; MODE_MASK);&#125;// 提取数值public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK);&#125; 3）MeasureSpecAndroid 已经为我们提供了 MeasureSpec 类来实现模式和数值的提取。12MeasureSpec.getMode(int spec) // 获取模式MeasureSpec.getSize(int spec) // 获取数值 另外，模式的取值为：123MeasureSpec.UNSPECIFIEDMeasureSpec.EXACTLYMeasureSpec.AT_MOST 实际运用：1234567891011121314protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int measureWidth = MeasureSpec.getSize(widthMeasureSpec); int measureHeight = MeasureSpec.getSize(heightMeasureSpec); int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec); int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec); // 计算过程 ... setMeasuredDimension((measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth : width, (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight : height);&#125; 12.2.3 onLayout() 函数onLayout() 是实现所有子控件布局的函数。那关于它自己的布局怎么办呢？是在父控件中由它的父控件完成的。就这样一层一层地向上由各自的父控件完成对自己的布局，直到所有控件的顶层节点。在所有的控件的顶部有一个 ViewRoot，它才是所有控件的祖先节点。 ViewRoot 使用 setFrame(l, t, r, b) 函数中设置自己的位置，设置结束以后才会调用 onLayout(changed, l, t, r, b) 函数来设置内部所有子控件的位置。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MyLinLayout extends ViewGroup &#123; public MyLinLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int measureWidth = MeasureSpec.getSize(widthMeasureSpec); int measureHeight = MeasureSpec.getSize(heightMeasureSpec); int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec); int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec); int height = 0; int width = 0; int count = getChildCount(); for (int i = 0; i &lt; count; i++) &#123; // 测量子控件 View child = getChildAt(i); measureChild(child, widthMeasureSpec, heightMeasureSpec); // 获得子控件的宽高 int childWidth = child.getMeasuredWidth(); int childHeight = child.getMeasuredHeight(); // 得到最大宽度，并且累加高度 height += childHeight; width = Math.max(childWidth, width); &#125; setMeasuredDimension((measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth : width, (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight : height); &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int top = 0; int count = getChildCount(); for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); int childWidth = child.getMeasuredWidth(); int childHeight = child.getMeasuredHeight(); child.layout(0, top, childWidth, top + childHeight); top += childHeight; &#125; &#125;&#125; res/layout/act_main.xml12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;com.xxt.xtest.MyLinLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#FF00FF&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;first view&quot; android:background=&quot;#FF0000&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;second view&quot; android:background=&quot;#00FF00&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;third view&quot; android:background=&quot;#0000FF&quot;/&gt;&lt;/com.xxt.xtest.MyLinLayout&gt; 注意：getMeasuredWidth() 与 getWidth() 获得的值大部分时候是相同的，但含义却是根本不一样的。前者是在 measure() 过程结束后就可以获取到宽度值，而后者是要在 layout() 过程结束后才能获取到宽度值；前者的值是通过 setMeasuredDimension() 函数来进行设置的，而后者的值是通过 layout(left, top, right, bottom) 函数来进行设置的。 12.2.4 获取子控件 margin 值的方法1. 获取方法及示例在上面 MyLinLayout 例子的基础上，添加 layout_margin 参数。12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;com.xxt.xtest.MyLinLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#FF00FF&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:text=&quot;first view&quot; android:background=&quot;#FF0000&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;20dp&quot; android:text=&quot;second view&quot; android:background=&quot;#00FF00&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;30dp&quot; android:text=&quot;third view&quot; android:background=&quot;#0000FF&quot;/&gt;&lt;/com.xxt.xtest.MyLinLayout&gt; 重写 generateLayoutParams() 和 generateDefaultLayoutParams()，返回对应的 MarginLayoutParams() 函数的实例。1234567891011121314@Overrideprotected LayoutParams generateLayoutParams(LayoutParams p) &#123; return new MarginLayoutParams(p);&#125;@Overridepublic LayoutParams generateLayoutParams(AttributeSet attrs) &#123; return new MarginLayoutParams(getContext(), attrs);&#125;@Overrideprotected LayoutParams generateDefaultLayoutParams() &#123; return new MarginLayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);&#125; 重写 onMeasure() 和 onLayout() 函数，修正获取子控件的宽高逻辑。12345678for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); // 获得子控件的宽高 MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin; int childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin; ...&#125; 最终效果如下图所示。 完整代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class MyLinLayout extends ViewGroup &#123; public MyLinLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int measureWidth = MeasureSpec.getSize(widthMeasureSpec); int measureHeight = MeasureSpec.getSize(heightMeasureSpec); int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec); int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec); int height = 0; int width = 0; int count = getChildCount(); for (int i = 0; i &lt; count; i++) &#123; // 测量子控件 View child = getChildAt(i); measureChild(child, widthMeasureSpec, heightMeasureSpec); // 获得子控件的宽高 MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin; int childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin; // 得到最大宽度，并且累加高度 height += childHeight; width = Math.max(childWidth, width); &#125; setMeasuredDimension((measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth : width, (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight : height); &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int top = 0; int count = getChildCount(); for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); // 获得子控件的宽高 MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin; int childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin; child.layout(0, top, childWidth, top + childHeight); top += childHeight; &#125; &#125; @Override protected LayoutParams generateLayoutParams(LayoutParams p) &#123; return new MarginLayoutParams(p); &#125; @Override public LayoutParams generateLayoutParams(AttributeSet attrs) &#123; return new MarginLayoutParams(getContext(), attrs); &#125; @Override protected LayoutParams generateDefaultLayoutParams() &#123; return new MarginLayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT); &#125;&#125; 2. 原理在 container 中初始化子控件时，会调用 LayoutParams generateLayoutParams(LayoutParams p) 函数来为子控件生成对应的布局属性，但默认只生成 layout_width 和 layout_height 所对应的布局参数，即在正常情况下调用 generateLayoutParams() 函数生成的 LayoutParams 实例是不能获取到 margin 值的。所以，如我我们还需要与 margin 相关的参数，就只能重写 generateLayoutParams() 函数，返回派生自 LayoutParams 的子类 MarginLayoutParams，根据类的多态性，可以直接将其强转成 MarginLayoutParams 实例。为了安全起见，也可以利用 instanceof 来进行判断。]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12.1 精通自定义 View 之封装控件——自定义属性与自定义 Style]]></title>
    <url>%2F2019%2F07%2F12%2FCustom%20View%2F12.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%20Style%2F</url>
    <content type="text"><![CDATA[12.1.1 示例1. 自定义 Style 和属性1）自定义一个类 MyTextView12345678910111213public class MyTextView extends AppCompatTextView &#123; public MyTextView(Context context) &#123; super(context); &#125; public MyTextView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public MyTextView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125;&#125; 2）新建 res/values/attrs.xml 文件12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;MyTextView&quot;&gt; &lt;attr name=&quot;header&quot; format=&quot;reference&quot;/&gt; &lt;attr name=&quot;headerHeight&quot; format=&quot;dimension&quot;/&gt; &lt;attr name=&quot;headerVisibleHeight&quot; format=&quot;dimension&quot;/&gt; &lt;attr name=&quot;age&quot;&gt; &lt;flag name=&quot;child&quot; value=&quot;10&quot;/&gt; &lt;flag name=&quot;young&quot; value=&quot;18&quot;/&gt; &lt;flag name=&quot;old&quot; value=&quot;60&quot;/&gt; &lt;/attr&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; reference 指的是从 string.xml、drawable.xml、color.xml 等文件中引用过来的值。 flag 是自己定义的，类似于 android:gravity=”top”。 dimension 指的是从 dimensions.xml 文件中引用过来的值。注意，这里如果是 dp，就会进行像素转换。 注意：declare-styleable 的 name 值对应所定义的类名。自定义属性值可以组合使用。比如 表示既可以自定义 color 值 (比如 #ff00ff)，也可以利用 @color/xxx 来引用 colors.xml 中已有的值。 12.1.2 在 XML 中使用自定义的属性res/layout/act_main.xml12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:attrstest=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.xxt.xtest.MyTextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; attrstest:header=&quot;@drawable/head&quot; attrstest:headerHeight=&quot;300dp&quot; attrstest:headerVisibleHeight=&quot;100dp&quot; attrstest:age=&quot;young&quot;/&gt;&lt;/LinearLayout&gt; 下面代码是导入自定义的属性集，使 XML 能识别我们自定义的属性。attrstest 是自定义的，可随意定义为 xxx，对应的访问自定义控件的方式就是 xxx:headerHeight=”300dp”1xmlns:attrstest=&quot;http://schemas.android.com/apk/res-auto&quot; 12.1.3 在代码中获取自定义属性的值使用代码获取用户所定义的某个属性的值，主要使用 TypedArray 类，这个类提供了获取某个属性值的所有方法，如下所示。需要注意的是，在使用完以后必须调用 TypedArray 类的 recycle() 函数来释放资源。123456789typedArray.getInt(int index, float defValue)typedArray.getDimension(int index, float defValue)typedArray.getBoolean(int index, float defValue)typedArray.getColor(int index, float defValue)typedArray.getString(int index)typedArray.getDrawable(int index)typedArray.getResources()typedArray.recycle() 使用示例：1234567891011121314public class MyTextView extends AppCompatTextView &#123; public MyTextView(Context context, AttributeSet attrs) &#123; super(context, attrs); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MyTextView); float headerHeight = typedArray.getDimension(R.styleable.MyTextView_headerHeight, -1); int age = typedArray.getInt(R.styleable.MyTextView_age, -1); Drawable drawable = typedArray.getDrawable(R.styleable.MyTextView_header); typedArray.recycle(); String text = &quot;headerHeight:&quot; + headerHeight + &quot; age:&quot; + age; this.setText(text); &#125;&#125; 效果如下图所示。 12.1.4 declare-styleable 标签其他属性的用法1. reference：参考某一资源 ID属性定义：123&lt;declare-styleable name=&quot;名称&quot;&gt; &lt;attr name=&quot;background&quot; format=&quot;reference&quot;/&gt;&lt;/declare-styleable&gt; 属性使用：1234&lt;ImageView android:layout_width=&quot;42dip&quot; android:layout_height=&quot;42dip&quot; android:background=&quot;@drawable/图片 ID&quot;/&gt; 2. color：颜色值属性定义：123&lt;declare-styleable name=&quot;名称&quot;&gt; &lt;attr name=&quot;textColor&quot; format=&quot;color&quot;/&gt;&lt;/declare-styleable&gt; 属性使用：1234&lt;TextView android:layout_width=&quot;42dip&quot; android:layout_height=&quot;42dip&quot; android:textColor=&quot;#00FF00&quot;/&gt; 3. boolean：布尔值属性定义：123&lt;declare-styleable name=&quot;名称&quot;&gt; &lt;attr name=&quot;focusable&quot; format=&quot;boolean&quot;/&gt;&lt;/declare-styleable&gt; 属性使用：1234&lt;Button android:layout_width=&quot;42dip&quot; android:layout_height=&quot;42dip&quot; android:focusable=&quot;true&quot;/&gt; 4. dimension：尺寸值属性定义：123&lt;declare-styleable name=&quot;名称&quot;&gt; &lt;attr name=&quot;layout_width&quot; format=&quot;dimension&quot;/&gt;&lt;/declare-styleable&gt; 属性使用：123&lt;Button android:layout_width=&quot;42dip&quot; android:layout_height=&quot;42dip&quot;/&gt; 5. float：浮点值属性定义：1234&lt;declare-styleable name=&quot;AlphaAnimation&quot;&gt; &lt;attr name=&quot;fromAlpha&quot; format=&quot;float&quot;/&gt; &lt;attr name=&quot;toAlpha&quot; format=&quot;float&quot;/&gt;&lt;/declare-styleable&gt; 属性使用：123&lt;Alpha android:fromAlpha=&quot;1.0&quot; android:toAlpha=&quot;0.7&quot;/&gt; 6. integer：整型值属性定义：12345678&lt;declare-styleable name=&quot;AnimatedRotateDrawable&quot;&gt; &lt;attr name=&quot;visible&quot;/&gt; &lt;attr name=&quot;frameDuration&quot; format=&quot;integer&quot;/&gt; &lt;attr name=&quot;framesCount&quot; format=&quot;integer&quot;/&gt; &lt;attr name=&quot;pivotX&quot;/&gt; &lt;attr name=&quot;pivotY&quot;/&gt; &lt;attr name=&quot;drawable&quot;/&gt;&lt;/declare-styleable&gt; 属性使用：1234567&lt;animated-rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:drawable=&quot;@drawable/图片 ID&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:framesCount=&quot;12&quot; android:frameDuration=&quot;100&quot;/&gt; 7. string：字符串属性定义：123&lt;declare-styleable name=&quot;MapView&quot;&gt; &lt;attr name=&quot;apiKey&quot; format=&quot;string&quot;/&gt;&lt;/declare-styleable&gt; 属性使用：1234&lt;com.google.android.maps.MapView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:apiKey=&quot;FJA802hFS01jhFDA9oAFAoFJAFDA9oAFAo&quot;/&gt; 8. fraction：百分数属性定义：12345678&lt;declare-styleable name=&quot;RotateDrawable&quot;&gt; &lt;attr name=&quot;visible&quot;/&gt; &lt;attr name=&quot;fromDegrees&quot; format=&quot;float&quot;/&gt; &lt;attr name=&quot;toDegrees&quot; format=&quot;float&quot;/&gt; &lt;attr name=&quot;pivotX&quot; format=&quot;fraction&quot;/&gt; &lt;attr name=&quot;pivotY&quot; format=&quot;fraction&quot;/&gt; &lt;attr name=&quot;drawable&quot;/&gt;&lt;/declare-styleable&gt; 属性使用：12345678910&lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@anim/动画 ID&quot; android:fromDegrees=&quot;0&quot; android:toDegrees=&quot;360&quot; android:pivotX=&quot;200%&quot; android:pivotY=&quot;300%&quot; android:duration=&quot;5000&quot; android:repeatMode=&quot;restart&quot; android:repeatCount=&quot;infinite&quot;/&gt; 9. enum：枚举值属性定义：123456&lt;declare-styleable name=&quot;名称&quot;&gt; &lt;attr name=&quot;orientation&quot;&gt; &lt;enum name=&quot;horizontal&quot; value=&quot;0&quot;/&gt; &lt;enum name=&quot;vertical&quot; value=&quot;1&quot;/&gt; &lt;/attr&gt;&lt;/declare-styleable&gt; 属性使用：123456&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt;&lt;/LinearLayout&gt; 10. flag：位或运算属性定义：1234567891011121314&lt;declare-styleable name=&quot;名称&quot;&gt; &lt;attr name=&quot;windowSoftInputMode&quot;&gt; &lt;flag name=&quot;stateUnspecified&quot; value=&quot;0&quot;/&gt; &lt;flag name=&quot;stateUnchanged&quot; value=&quot;1&quot;/&gt; &lt;flag name=&quot;stateHidden&quot; value=&quot;2&quot;/&gt; &lt;flag name=&quot;stateAlwaysHidden&quot; value=&quot;3&quot;/&gt; &lt;flag name=&quot;stateVisible&quot; value=&quot;4&quot;/&gt; &lt;flag name=&quot;stateAlwaysVisible&quot; value=&quot;5&quot;/&gt; &lt;flag name=&quot;adjustUnspecified&quot; value=&quot;0x00&quot;/&gt; &lt;flag name=&quot;adjustResize&quot; value=&quot;0x10&quot;/&gt; &lt;flag name=&quot;adjustPan&quot; value=&quot;0x20&quot;/&gt; &lt;flag name=&quot;adjustNothing&quot; value=&quot;0x30&quot;/&gt; &lt;/attr&gt;&lt;/declare-styleable&gt; 属性使用：123456789&lt;Activity android:name=&quot;.StyleAndThemeActivity&quot; android:label=&quot;@string/app_name&quot; android:windowSoftInputMode=&quot;stateUnspecified | stateUnchanged | stateHidden&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt;&lt;/LinearLayout&gt; 特别注意：属性在定义时可以指定多种类型的值。 123&lt;declare-styleable name=&quot;名称&quot;&gt; &lt;attr name=&quot;background&quot; format=&quot;reference|color&quot;/&gt;&lt;/declare-styleable&gt;]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11.2 精通自定义 View 之 Matrix 与坐标变换——ColorMatrix 色彩变换]]></title>
    <url>%2F2019%2F07%2F11%2FCustom%20View%2F11.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94ColorMatrix%20%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[11.2.1 色彩变换矩阵对于色彩的存储，Bitmap 类使用一个 32 位的数值来保存，红、绿、蓝及透明度各占 8 位，每个色彩分量的取值范围是 0~255。透明度为 0 表示完全透明，为 255 时色彩完全可见。 1. 色彩信息的矩阵表示由于一个色彩信息包含 R、G、B、Alpha 信息,所以,我们必然要使用一个四阶色彩变 换矩阵来修改色彩的每一个分量值。$$ \left[ \begin{matrix} Red &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; Green &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; Blue &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; Alpha \end{matrix} \right]$$ 注意:对于色彩变换矩阵，这里的色彩顺序是 R、G、B、A，而不是 A、R、G、B。 如果想将色彩 (0,255,0,255) 更改为半透明，则可以使用下面的矩阵运算来表示： 上面使用四阶矩阵完全可以改变图片的 RGBA 值，但考虑一种情况：如果我们只想在原有的 R 色上增加一些分量呢? 这时，我们就得再多加一阶来表示平移变换。所，一个既包含线性变换又包含平移变换的组合变换称为仿射变换。使用四阶色彩变换矩阵来修改色彩，只能对色彩的每个分量值进行乘(除)运算。如果要对这些分量值进行加减法运算(平移变换)，则只能通过五阶矩阵来完成。 考虑下面这个变换：1）红色分量值更改为原来的 2 倍。2）绿色分量值增加 100。 这个变换使用四阶矩阵的乘法无法实现。所以，应该在四阶色彩变换矩阵上增加一个“哑元坐标”，来实现所列的矩阵运算。 在这个矩阵中，分量值用的是 100。 2. Android 中的色彩变换矩阵在 Android 中，色彩变换矩阵的表示形式也是五阶的。所以，在默认情况下，色彩变换矩阵的形式如下:$$ \left[ \begin{matrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0\end{matrix} \right]$$ Android 中的色彩变换矩阵是用 ColorMatrix 类来表示的。使用 ColorMatrix 类的方法如下:1234567ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0.5, 0,&#125;);mPaint.setColorFilter(new ColorMatrixColorFilter(colorMatrix)); 有关 setColorFilter() 函数的其他用法，将在本节末尾详细讲解。 3. 示例：彩色图片的蓝色通道输出下面以为 Bitmap 应用 ColorMatrix 类为例,代码如下：1234567891011121314151617181920212223242526272829303132333435public class TestView extends View &#123; private Paint mPaint = new Paint(); private Bitmap bitmap; // 位图 private Rect rect; private ColorMatrixColorFilter colorMatrixColorFilter; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint.setAntiAlias(true); // 获取位图 bitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.dog); rect = new Rect(); // 生成色彩变换矩阵 ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, &#125;); colorMatrixColorFilter = new ColorMatrixColorFilter(colorMatrix); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); rect.set(0, 0, 500, 500 * bitmap.getHeight() / bitmap.getWidth()); // 绘制原始位图 canvas.drawBitmap(bitmap, null, rect, mPaint); canvas.translate(510, 0); mPaint.setColorFilter(colorMatrixColorFilter); canvas.drawBitmap(bitmap, null, rect, mPaint); &#125;&#125; 这里分两次绘制了一个 Bitmap，先绘制了一个原始图像,然后利用 ColorMatrix 类生成了 一个仅包含蓝色的图像。用过 Photoshop 的读者应该很清楚,这跟 Photoshop 中蓝色通道的效 果是一致的。效果如下图所示。 11.2.2 色彩的几种运算方式1. 色彩的平移运算1）增加色彩饱和度色彩的平移运算实际上就是色彩的加法运算，其实就是在色彩变换矩阵的最后一列加上某个值，这样可以增加特定色彩的饱和度。 比如，同样是上面的图片，我们给它应用下面的色彩值。123456ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 1, 0, 0, 0, 0, 0, 1, 0, 0, 50, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0,&#125;); 在绿色值上添加增量 50，即增大绿色的饱和度。效果如下图所示。 同样，左侧是原图，右侧是增大绿色饱和度后的效果。大家要特别注意的是，由于图片是由一个个像素组成的，所以用每个像素所对应的色彩数组来乘以色彩变换矩阵，结果就是变换后的当前点的颜色值。在应用 ColorMatrix 类后，图片中每个像素的绿色值都增加了 50, 从小狗的脸上也可以看出来。 2）色彩反转/反相功能色彩平移除增加指定色彩的饱和度以外，另一个应用就是色彩反转，也就是 Photoshop 中的反相功能。色彩反转就是求出每个色彩的补值来作为目标图像的对应颜色值。示例代码如下：123456ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; -1, 0, 0, 0, 255, 0, -1, 0, 0, 255, 0, 0, -1, 0, 255, 0, 0, 0, 1, 0,&#125;); 2. 色彩的缩放运算1）调节亮度色彩的缩放运算其实就是色彩的乘法运算。将色彩变换矩阵对角线上分别代表 R、G、B、 A 的几个值分别乘以指定的值，就是所谓的缩放运算，如下图所示。 我们可以针对某个颜色值进行放大/缩小运算。但是当对 R、G、B、A 同时进行放大/缩小运算时，就是对亮度进行调节。 看下面将亮度增大 1.2 倍的代码：123456ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 1.2f, 0, 0, 0, 0, 0, 1.2f, 0, 0, 0, 0, 0, 1.2f, 0, 0, 0, 0, 0, 1, 0,&#125;); 2）通道输出由于在色彩变换矩阵中对角线上的数的取值范围为 0~1，所以，当取 0 时，这个色彩就完全不显示；当 R、G 都取 0，而独有 B 取 1 时,就只显示蓝色，所形成的图像也就是我们通常所说的蓝色通道。看一下几个通道输出的效果图，如下图所示。 123456789101112131415161718192021// 红色通道矩阵ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,&#125;);// 绿色通道矩阵ColorMatrix colorMatrix2 = new ColorMatrix(new float[]&#123; 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,&#125;);// 蓝色通道矩阵ColorMatrix colorMatrix3 = new ColorMatrix(new float[]&#123; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0,&#125;); 3. 色彩的旋转运算RGB 色是如何旋转的呢？首先用 R、G、B 三色建立立体坐标系，如下图所示。 所以，我们可以把一个色彩值看成三维空间里的一个点，色彩值的三个分量可以看成该点的坐标(三维坐标)。我们先不考虑在三个维度综合情况下是怎么旋转的，来看看将某个轴作为 Z 轴，在另外两个轴形成的平面上旋转的情况。下图分析了将蓝色轴作为 Z 轴，仅在红 — 绿平面上旋转 a 度的情况。 可以看到，在旋转后，原 R 在 R 轴上的分量变为原 Rxcosa，原 G 在 R 轴上也有了分量，但分量落在了负轴上，所以要减去这部分分量，最终的结果是最终的 R=原 R×cosa-原 G×sina。 下面来看一下几种旋转计算及结果矩阵(注意：这几张图只标记了原 X 轴色彩分量的旋转，没有把 Y 轴色彩分量的旋转标记出来)。 1）绕蓝色轴旋转 θ 度 对应的色彩变换矩阵如下：$$ \left[ \begin{matrix} cosθ &amp; sinθ &amp; 0 &amp; 0 &amp; 0\ -sinθ &amp; cosθ &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\end{matrix} \right]$$ 2）绕红色轴旋转 θ 度 对应的色彩变换矩阵如下：$$ \left[ \begin{matrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; cosθ &amp; sinθ &amp; 0 &amp; 0\ 0 &amp; -sinθ &amp; cosθ &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\end{matrix} \right]$$ 3）绕绿色轴旋转 θ 度 对应的色彩变换矩阵如下：$$ \left[ \begin{matrix} cosθ &amp; 0 &amp; -sinθ &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0\ sinθ &amp; 0 &amp; cosθ &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\end{matrix} \right]$$ 当围绕红色轴进行色彩旋转时，由于当前红色轴的色彩是不变的,而仅利用三角函数来动态变更绿色和蓝色的颜色值，这种改变就叫作色相调节。当围绕红色轴旋转时，是对图片进行红色色相的调节；当围绕蓝色轴旋转时，是对图片进行蓝色色相的调节；当围绕绿色轴旋转时，是对图片进行绿色色相的调节。 下面我们会再次讲到 ColorMatrix 的色彩旋转函数，这里先理解原理，代码和效果后面会给出。 4. 色彩的投射运算我们再回过头来看看色彩变换矩阵运算的公式，如下： 在上式中，把红色运算单独标记出来。在运算中，它们就是利用 G、B、A 的颜色值的分量来增加红色值的。 来看具体的运算： 注意：最终结果的 220=0.2×100+1×200，可见绿色分量在原有绿色分量的基础上增加了红色分量值的 0.2 倍。利用其他色彩分量的倍数来更改自己色彩分量的值，这种运算就叫作投射运算。 在对下图中阴影部分的值进行修改时，所使用的增加值来自其他色彩分量的信息。 应用一：黑白图片色彩投射的一个最简单的应用就是将彩色图片变为黑白图片。代码如下：123456ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 0.213f, 0.715f, 0.072f, 0, 0, 0.213f, 0.715f, 0.072f, 0, 0, 0.213f, 0.715f, 0.072f, 0, 0, 0, 0, 0, 1, 0,&#125;); 首先了解一下去色原理：只要把 R、G、B 三通道的色彩信息设置成一样，即 R=G=B，图像就变成了灰色。并且，为了保证图像亮度不变，同一个通道中的 R+G+B=1，如 0.213+0.715+0.072=1。 下面谈一下 0.213、0.715、0.072 这三个数字的由来。 按理说应该把 R、G、B 平分，都是 0.3333333。三个数字应该是根据色彩光波频率及色彩心理学计算出来的。 在作用于人眼的光线中，彩色光要明显强于无色光。如果对一张图像按 RGB 平分理论给图像去色，人眼就会明显感觉到图像变暗了(当然可能有心理上的原因，也有光波的科学依据)。另外，在彩色图像中能够识别的一些细节也可能会丢失。 所以 Google 最终给出的颜色值就是上面的三个数字：0.213、0.715、0.072。我们在给图像去色时保留了大量的 G 通道信息，使得图像不至于变暗或者绿色信息不至于丢失。 应用二：色彩反色利用色彩变换矩阵将两个颜色反转，这种操作就叫作色彩反色。比如，将红色和绿色反色(红绿反色)，代码如下：123456ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0,&#125;); 左侧为原图，右侧为红绿反色以后的效果图。 从色彩变换矩阵中可以看出，红绿反色的关键在于，第一行用绿色来代替红色，第二行用红色来代替绿色。类似的可以有红蓝反色、绿蓝反色等，对应矩阵难度不大，就不再细讲了。 应用三：照片变旧投射运算的另一个应用是照片变旧，其对应的矩阵如下：123456ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 1/2f, 1/2f, 1/2f, 0, 0, 1/3f, 1/3f, 1/3f, 0, 0, 1/4f, 1/4f, 1/4f, 0, 0, 0, 0, 0, 1, 0,&#125;); 11.2.3 ColorMatrix 函数上一小节讲述了利用色彩变换矩阵来进行的一些运算，但这些都是需要特定的色彩设计基础的。在 Android 中，ColorMatrix 自带一些函数，用来帮助我们完成调整饱和度、色彩旋转等操作。 1. 构造函数ColorMatrix 共有三个构造函数，如下：123ColorMatrix()ColorMatrix(float[] src)ColorMatrix(ColorMatrix src) 在这三个构造函数中，我们已经使用过第二个构造函数；至于第三个构造函数，就是利用另一个 ColorMatrix 实例来复制一个一样的 ColorMatrix 对象。 2. 设置和重置函数第一个构造函数 ColorMatrix() 需要与其他函数共用才行。123public void set(ColorMatrix src)public void set(float[] src)public void reset() 上面的函数是设置和重置函数，重置后，对应的数组如下：1234567/** * Set this colormatrix to identity: * [ 1 0 0 0 0 -redvector * 0 1 0 0 0 -greenvector * 0 0 1 0 0 -bluevector * 0 0 0 1 0 ] -alphavector */ 3. setSaturation() 函数——设置饱和度我们可以通过色彩的平移运算单独增强 R、G、B 其中一个分量的饱和度，但当我们需要整体增强色彩饱和度时，需要如何来做呢？ ColorMatrix 提供了一个函数来整体增强色彩饱和度，如下：12// 整体增强色彩饱和度，即同时增强 R、G、B 的色彩饱和度 public void setSaturation(float sat) 其中，参数 float sat 表示把当前色彩饱和度放大的倍数。当取值为 0 时，表示完全无色彩，即灰度图像(黑白图像)；当取值为 1 时，表示色彩不变动；;当取值大于 1 时，显示色彩过度饱和。 举个例子：滑块默认在 1 倍的位置，向左到底是 0，向右到底是 20(饱和度放大 20 倍)。 布局非常简单，下面是一张图片，上面是一个 SeekBar，核心处理代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MainActivity extends AppCompatActivity &#123; private SeekBar mSeekBar; private ImageView mImageView; private Bitmap mOriginBmp, mTempBmp; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); mImageView = findViewById(R.id.img); mSeekBar = findViewById(R.id.seek_bar); mOriginBmp = BitmapFactory.decodeResource(getResources(), R.drawable.meinv); mTempBmp = Bitmap.createBitmap(mOriginBmp.getWidth(), mOriginBmp.getHeight(), Bitmap.Config.ARGB_8888); mSeekBar.setMax(20); mSeekBar.setProgress(1); mSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123; @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123; Bitmap bitmap = handleColorMatrixBmp(progress); mImageView.setImageBitmap(bitmap); &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123;&#125; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123;&#125; &#125;); &#125; private Bitmap handleColorMatrixBmp(int progress)&#123; // 创建一个相同尺寸的可变的位图区，用于绘制调色后的图片 Canvas canvas = new Canvas(mTempBmp); // 得到画笔对象 Paint paint = new Paint(); ColorMatrix mSaturationMatrix = new ColorMatrix(); mSaturationMatrix.setSaturation(progress); // 设置色彩变换效果 paint.setColorFilter(new ColorMatrixColorFilter(mSaturationMatrix)); // 将色彩变换后的图片输出到新创建的位图区 canvas.drawBitmap(mOriginBmp, 0, 0, paint); // 返回新的位图,即调色处理后的图片 return mTempBmp; &#125;&#125; 布局：123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:background=&quot;#EEE&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;40dp&quot; android:gravity=&quot;center_vertical&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;饱和度&quot;/&gt; &lt;SeekBar android:id=&quot;@+id/seek_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;/LinearLayout&gt; &lt;ImageView android:id=&quot;@+id/img&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/meinv&quot;/&gt;&lt;/LinearLayout&gt; 4. setScale() 函数——色彩缩放1public void setScale(float rScale, float gScale, float bScale,float aScale) 这个函数共有 4 个参数，分别对应 R、G、B、A 颜色值的缩放倍数。比如，在小狗图片中,绿色占大部分，所以我们仅将绿色放大 1.3 倍。 1234567891011121314151617181920212223242526272829public class TestView extends View &#123; private Paint mPaint = new Paint(); private Bitmap bitmap; // 位图 private Rect rect; private ColorMatrixColorFilter colorMatrixColorFilter; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint.setAntiAlias(true); // 获取位图 bitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.dog); rect = new Rect(); // 生成色彩变换矩阵 ColorMatrix colorMatrix = new ColorMatrix(); colorMatrix.setScale(1,1.3f,1,1); colorMatrixColorFilter = new ColorMatrixColorFilter(colorMatrix); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); rect.set(0, 0, 500, 500 * bitmap.getHeight() / bitmap.getWidth()); // 绘制原始位图 canvas.drawBitmap(bitmap, null, rect, mPaint); canvas.translate(510, 0); mPaint.setColorFilter(colorMatrixColorFilter); canvas.drawBitmap(bitmap, null, rect, mPaint); &#125;&#125; 5. setRotate() 函数——色彩旋转上面在讲解色彩旋转运算时，列出了在色彩旋转时的效果和原理。由于涉及正、余弦函数的计算，而且这些公式推导起来具有一定的难度，所以 Android 已经封装好了色彩旋转的函数。1234567/** * 将旋转围绕某一个颜色轴进行 * axis=0 围绕红色轴旋转 * axis=1 围绕绿色轴旋转 * axis=2 围绕蓝色轴旋转 */public void setRotate(int axis, float degrees); int axis：表示围绕哪个轴旋转，取值为0、1、2。当取值为 0 时，表示围绕红色轴旋转；当取值为 1 时，表示围绕绿色轴旋转；当取值为 2 时，表示围绕蓝色轴旋转。 float degrees：表示旋转的度数。 同样利用上面色彩旋转的图像和滑动条的框架，来看一下当围绕某一个颜色轴旋转时色相变化的效果。 12345678910111213141516171819202122232425262728293031323334353637383940public class MainActivity extends AppCompatActivity &#123; private SeekBar mSeekBar; private ImageView mImageView; private Bitmap mOriginBmp, mTempBmp; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); mImageView = findViewById(R.id.img); mSeekBar = findViewById(R.id.seek_bar); mOriginBmp = BitmapFactory.decodeResource(getResources(), R.drawable.meinv); mTempBmp = Bitmap.createBitmap(mOriginBmp.getWidth(), mOriginBmp.getHeight(), Bitmap.Config.ARGB_8888); mSeekBar.setMax(360); mSeekBar.setProgress(180); mSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123; @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123; Bitmap bitmap = handleColorMatrixBmp(progress); mImageView.setImageBitmap(bitmap); &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123;&#125; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123;&#125; &#125;); &#125; private Bitmap handleColorMatrixBmp(int progress) &#123; Canvas canvas = new Canvas(mTempBmp); Paint paint = new Paint(); ColorMatrix colorMatrix = new ColorMatrix(); colorMatrix.setRotate(0,progress - 180); paint.setColorFilter(new ColorMatrixColorFilter(colorMatrix)); canvas.drawBitmap(mOriginBmp, 0, 0, paint); return mTempBmp; &#125;&#125; 将当前 progress 位置减去 180，即中间位置的数字。所以，中间位置的色彩旋转度数为 0，整个旋转度数的范围是 -180°~180°；360° 正好是正/余弦函数的一个最小正周期。 上面的效果针对的是红色色相。同理，可以得到围绕绿色轴旋转的效果图。 11.2.4 ColorMatrix 相乘矩阵相乘涉及三个函数。1public void setConcat(ColorMatrix matA, ColorMatrix matB) 这个函数接收两个 ColorMatrix 矩阵 matA 和 matB，乘法规则为 matA×matB，然后将结果作为当前 ColorMatrix 的值。1public void preConcat(ColorMatrix preMatrix) 假设当前矩阵为 A，那么 preConcat() 函数的含义就是将当前的矩阵 A 乘以 preMatrix。1public void postConcat(ColorMatrix postMatrix) postConcat() 函数的含义就是 postMatrix 乘以当前矩阵 A。 由于这部分内容基本用不到，有关这几个函数的具体应用这里就不再详细讲述，有兴趣的读者可以参考 Paint 之 ColorMatrix 与滤镜效果。]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11.1 精通自定义 View 之 Matrix 与坐标变换——矩阵运算]]></title>
    <url>%2F2019%2F07%2F11%2FCustom%20View%2F11.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[11.1.1 矩阵的加法和减法1. 运算规则$$设矩阵 A=\left[ \begin{matrix} a~11~ &amp; a~12~ &amp; \cdots &amp; a~1n~ \ a~21~ &amp; a~22~ &amp; \cdots &amp; a~2n~ \ \vdots &amp; \vdots &amp; &amp; \vdots \ a~n1~ &amp; a~n2~ &amp; \cdots &amp; a~nn~ \end{matrix} \right]$$ $$设矩阵 B=\left[ \begin{matrix} b~11~ &amp; b~12~ &amp; \cdots &amp; b~1n~ \ b~21~ &amp; b~22~ &amp; \cdots &amp; b~2n~ \ \vdots &amp; \vdots &amp; &amp; \vdots \ b~n1~ &amp; b~n2~ &amp; \cdots &amp; b~nn~ \end{matrix} \right]$$ $$则 A±B=\left[ \begin{matrix} a~11~ ± b~11~ &amp; a~12~ ± b~12~ &amp; \cdots &amp; a~1n ± ~b~1n~ \ a~21~ ± b~21~ &amp; a~22~ ± b~22~ &amp; \cdots &amp; a~2n ± ~b~2n~ \ \vdots &amp; \vdots &amp; &amp; \vdots \ a~n1~ ± b~n1~ &amp; a~n2~ ± b~n2~ &amp; \cdots &amp; a~nn ± ~b~nn~ \end{matrix} \right]$$ 简而言之，两个矩阵相加减，即它们相同位置的元素相加减。 注意：只有对于两个行数、列数分别相等的矩阵(同型矩阵)，加减法运算才有意义,即 加减法运算是可行的。 2. 运算性质满足交换律和结合律。交换律：A+B=B+A。结合律：(A+B)+C= A+(B+C)。 11.1.2 矩阵与数的乘法1. 运算规则数 λ 乘以矩阵 A，就是将数 λ 乘以矩阵 A 中的每一个元素，记为 λA 或 Aλ。特别地，称-A 为 A=(a~ij~)~m×s~ 的负矩阵。 2. 运算性质满足结合律和分配律。结合律：(λμ)A=λ(μA)；(λ+μ)A =λA+μA。分配律：λ (A+B)=λA+λB。 11.1.3 矩阵与矩阵的乘法1. 运算规则 矩阵乘法其实并不难，它的意思就是将第一个矩阵 A 的第一行与第二个矩阵 B 的第一列的数字分别相乘，得到的结果相加，最终的值作为结果矩阵的第(1,1)位置的值(第一行第一列)。 同样，A 矩阵的第一行与 B 矩阵的第二列的数字分别相乘，然后相加，最终的值作为结果矩阵第(1,2)位置的值(第一行第二列)。 再如，A 矩阵的第二行与 B 矩阵的第一列的数字分别相乘，然后相加，最终的值作为结果矩阵的第(2,1)位置的值(第二行第一列)。 这里主要说明两个问题： A 矩阵的列数必须与 B 矩阵的行数相同，才能相乘。因为我们需要把 A 矩阵一行中的各个数字与 B 矩阵一列中的各个数字分别相乘，所以 A 矩阵的列数与 B 矩阵的行数必须相同。 矩阵 A 乘以矩阵 B 和矩阵 B 乘以矩阵 A 的结果必然是不一样的。 2. 运算性质1）结合律：(AB)C=A(BC)。2）分配律：A(B±C)=AB±AC(左分配律)；(B±C)A=BA±CA(右分配律)。3）(λA)B=λ(AB)=A(λB)。]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10.3 精通自定义 View 之 Android 画布——SurfaceView]]></title>
    <url>%2F2019%2F07%2F10%2FCustom%20View%2F10.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94SurfaceView%2F</url>
    <content type="text"><![CDATA[10.3.1 概述Android 屏幕刷新的时间间隔是 16ms，如果 View 能够在 16ms 内完成所需执行的绘图操作，那么在视觉上，界面就是流畅的；否则就会出现卡顿。很多时候，在自定义 View 的日志中，经常会看到如下警告：1Skipped 60 frames! The application may be doing too much work on its main thread 之所以会出现这些警告，大部分是因为我们在绘制过程中不单单执行了绘图操作，也夹杂了很多逻辑处理，导致在指定的 16ms 内并没有完成绘制，出现界面卡顿和警告。为了解决这个问题，Android 引入了 SurfaceView。它在两个方面改进了 View 的绘图操作： 使用双缓冲技术。 自带画布，支持在子线程中更新画布内容。 所谓双缓冲技术，简单来讲，就是多加一块缓冲画布，当需要执行绘图操作时，现在缓冲画布上绘制，绘制好后直接将缓冲画布上的内容更新到主画布上。这样，在屏幕更新时，只需把换缓冲画布上的内容照样画过来就可以了，就不会存在逻辑处理时间的问题，也就解决了超时绘制的问题。具体详见 10.3.3。 虽然 SurfaceView 在处理耗时操作时很有用，但正是因为在新的线程中更新画面，所以不会阻塞主线程。但这也带来了另一个问题，就是事件同步。比如，你触摸了屏幕，SurfaceView 就会调用线程来处理，当线程过多时，一般就需要一个线程队列来保存触摸事件，这会稍稍复杂一点，因为涉及线程同步。 总之，View 和 SurfaceView 都有各自的应用场景： 当界面需要被动更新时，用 View 较好。比如，与手势交互的场景，因为画面的更新是依赖 onTouch 来完成的，所以可以直接使用 invalidate() 函数。在这种情况下，这一次 Touch 和下一次 Touch 间隔的时间比较长，不会产生影响。 当界面需要主动更新，用 SurfaceView 较好。比如一个人在一直跑动，这就需要一个单独的线程不停地重绘人的状态，避免阻塞主线程。显然 View 不合适，需要 SurfaceView 来控制。 当界面绘制需要频繁刷新，或者刷新是数据处理量比较大时，就应该用 SurfaceView 来实现，比如视频播放及 Camera。 10.3.2 SurfaceView 的基本用法1. 实现 View 功能SurfaceView 派生自 View，所以 SurfaceView 能使用 View 中的所有方法，但要注意，View 中的所有方法都是在主线程中执行。下面使用 SurfaceView 来实现捕捉用户手势轨迹的自定义控件。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class TestView extends SurfaceView &#123; private Path mPath; private Paint mPaint; public TestView(Context context) &#123; super(context); init(); &#125; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public TestView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init() &#123; // setWillNotDraw(false); mPaint = new Paint(); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(5); mPaint.setColor(Color.RED); mPath = new Path(); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; mPath.moveTo(x, y); Log.d(&quot;xian&quot;, &quot;ACTION_DOWN&quot;); return true; &#125; else if (event.getAction() == MotionEvent.ACTION_MOVE) &#123; mPath.lineTo(x, y); &#125; postInvalidate(); Log.d(&quot;xian&quot;, &quot;invalidate&quot;); return super.onTouchEvent(event); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawPath(mPath, mPaint); Log.d(&quot;xian&quot;, &quot;onDraw&quot;); &#125;&#125; 然而，效果却是不显示手势轨迹，而一直显示黑屏。查看日志，如下图所示。 从日志中可以看出，上述代码只调用了 postInavidate() 函数，而没有调用 onDraw() 函数。这是为什么呢？当你把 init() 函数中注释掉的一行代码打开以后，就会发现可以看到手势轨迹了。 setWillNotDraw(boolean willNotDraw) 这个函数存在于 View 类中，它主要用在 View 派生子类的初始化中，如果参数 willNotDraw 取 true，则表示当前控件没有绘制内容，当屏幕重绘的时候，这个控件不需要绘制，所以在重绘的时候也就不会调用这个类的 onDraw() 函数。相反，如果参数 willNotDraw 取 false，则表示当前控件在每次重绘时，都需要绘制该控件。可见，setWillNotDraw 其实是一种优化策略，它让控件显示地告诉系统，在重绘屏幕时，哪个控件需要重绘，哪个控件不需要重绘，这样就可以大大提高重绘效率。 一般而言，想 LinearLayout、RelativeLayout 等布局控件，它们的主要功能是布局其中的控件，它们本身是没有东西需要绘制的，所以它们在构造的时候都会显示设置 setWillNotDraw(true) 总结： 原本能够通过派生自 View 实现的控件，依然可以通过 SurfaceView 来实现，因为 SurfaceView 派生自 View。 当 SurfaceView 需要使用 View 的 onDraw() 函数来重绘控件时，需要在初始化的时候调用 setWillNotDraw(false)，否则 onDraw() 函数不会被调用。 View 中的所有方法都是在主线程中执行的，所以并不建议使用 SurfaceView 重写 View 的 onDraw() 函数来实现自定义控件，而要使用 SurfaceView 特有的双缓冲机制绘图。 2. 使用缓冲 Canvas 绘图通过以下方式来获取 SurfaceView 自带的画布。1234SurfaceHolder surfaceHolder = getHolder();Canvas canvas = surfaceHolder.lockCanvas();// TODO 绘图操作surfaceHolder.unlockCanvasAndPost(canvas); 前面说过线程同步问题，所以需要给获取的缓冲画布进行加锁，防止被其他线程更改；当绘图操作完成以后，将缓冲画布释放，并将所画内容更新到主线程的画布上，显示在屏幕上。使用缓冲画布来改造上面的示例代码。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class TestView extends SurfaceView &#123; private Path mPath; private Paint mPaint; public TestView(Context context) &#123; super(context); init(); &#125; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public TestView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init() &#123; mPaint = new Paint(); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(5); mPaint.setColor(Color.RED); mPath = new Path(); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; mPath.moveTo(x, y); return true; &#125; else if (event.getAction() == MotionEvent.ACTION_MOVE) &#123; mPath.lineTo(x, y); &#125; drawCanvas(); return super.onTouchEvent(event); &#125; private void drawCanvas() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; SurfaceHolder surfaceHolder = getHolder(); Canvas canvas = surfaceHolder.lockCanvas(); if (canvas != null) &#123; canvas.drawPath(mPath, mPaint); &#125; surfaceHolder.unlockCanvasAndPost(canvas); &#125; &#125;).start(); &#125;&#125; 注意，onTouchEvent() 函数是在主线程执行的，所以我们需要开启子线程更新画布。效果图如下。 3. 监听 Surface 生命周期与 SurfaceView 相关的有三个概念：Surface、SurfaceView、SurfaceHolder。这三个概念是典型的 MVC 模式 (Model-View-Controller)。Surface 是 Model，保存着缓冲画布和绘图内容相关的各种信息；SurfaceView 是 View，负责将 Surface 中存储的数据展示在 View 上；SurfaceHolder 是 Controller，使用它才能操作 Surface 中的数据。 生命周期监听函数：1234567891011121314151617SurfaceHolder surfaceHolder = getHolder();surfaceHolder.addCallback(new SurfaceHolder.Callback() &#123; @Override public void surfaceCreated(SurfaceHolder holder) &#123; // 当 Surface 对象被创建后，该函数就会被立即调用 &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; // 当 Surface 发生任何结构性的变化时（格式或者大小），该函数就会被立即调用 &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; // 当 Surface 对象将要被销毁时，该函数就会被立即调用 &#125;&#125;); 示例：动态背景效果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public class TestView extends SurfaceView &#123; private SurfaceHolder mHolder; private boolean flag = false; // 线程标示 private Bitmap mBgBitmap; // 背景图 private float mSurfaceWidth, mSurfaceHeight; // 屏幕宽高 private int mBitPosX; // 开始绘制的图片的 x 坐标 private Canvas mCanvas; private Thread mThread; // 背景移动状态 private enum State &#123; LEFT, RIGHT &#125; // 默认向左 private State state = State.LEFT; private final int BITMAP_STEP = 5; // 背景画布移动步伐 public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); mHolder = getHolder(); mHolder.addCallback(new SurfaceHolder.Callback() &#123; @Override public void surfaceCreated(SurfaceHolder holder) &#123; flag = true; startAnimation(); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; flag = false; &#125; &#125;); &#125; private void startAnimation() &#123; mSurfaceWidth = getWidth(); mSurfaceHeight = getHeight(); try &#123; // 按比例缩放图片，是高度充满屏幕 Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.qingmingshanghetu); float width = mSurfaceHeight / bitmap.getHeight() * bitmap.getWidth(); mBgBitmap = Bitmap.createScaledBitmap(bitmap, (int)width, (int)mSurfaceHeight, true); &#125; catch (OutOfMemoryError error) &#123; error.printStackTrace(); &#125; if (mBgBitmap == null) return; // 开始绘图 mThread = new Thread(new Runnable() &#123; @Override public void run() &#123; while (flag) &#123; mCanvas = mHolder.lockCanvas(); drawView(); mHolder.unlockCanvasAndPost(mCanvas); try &#123; Thread.sleep(16); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); mThread.start(); &#125; protected void drawView() &#123; if (mCanvas == null) return; // 清空屏幕 mCanvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR); // 从 mBitPosX 开始绘制屏幕背景 mCanvas.drawBitmap(mBgBitmap, mBitPosX, 0, null); // 图片滚动效果 switch (state) &#123; case LEFT: mBitPosX -= BITMAP_STEP; // 画布左移 break; case RIGHT: mBitPosX += BITMAP_STEP; // 画布右移 break; &#125; if (mBitPosX &lt;= -mSurfaceWidth / 2) &#123; state = State.RIGHT; &#125; if (mBitPosX &gt;= 0) &#123; state = State.LEFT; &#125; &#125;&#125; 10.3.3 SurfaceView 双缓冲技术1. 概述双缓冲技术需要两个图形缓冲区：前端缓冲区和后端缓冲区。前端缓冲区对应当前屏幕正在显示的内容，而后端缓冲区是接下来要渲染的图形缓冲区。通过 surfaceHolder.lockCanvas() 函数获得的缓冲区是后端缓冲区。当绘图完成以后，调用 surfaceHolder.unlockCanvasAndPost(mCanvas) 函数将后端缓冲区与前端缓冲区交换，后端缓冲区变成前端缓冲区，将内容显示在屏幕上；而原来的前端缓冲区则变成后端缓冲区，等待下一次的 surfaceHolder.lockCanvas() 函数调用返回给用户使用，如此反复。 正是由于两块画布交替用来绘图，在绘图完成以后相互交换位置，而且在绘图完成以后直接更新到屏幕上，所以才使得绘图效率大大提高。而这样做却造成了一个问题：两块画布上的内容肯定会存在不一致的情况，尤其是在多线程的情况下。比如，我们利用一个线程操作 A、B 两款画布，目前 A 画布是屏幕画布，所以，当线程要绘图是，获得的缓冲画布是 B。在更新以后，B 画布更新到屏幕上，A 画布与 B 画布交换位置。而这时，如果线程再次申请画布，则将获取到 A 画布。如果 A 画布与 B 画布上的内容不一样，那么，在 A 画布上继续作画肯定会与预想的不一样。 示例：每获取一次画布写一个数字，循环 10 次。12345678910111213141516171819202122232425262728293031323334353637public class TestView extends SurfaceView &#123; private Paint mPaint; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; private void init() &#123; mPaint = new Paint(); mPaint.setColor(Color.RED); mPaint.setTextSize(30); getHolder().addCallback(new SurfaceHolder.Callback() &#123; @Override public void surfaceCreated(SurfaceHolder holder) &#123; drawText(holder); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123;&#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123;&#125; &#125;); &#125; private void drawText(SurfaceHolder holder) &#123; for (int i = 0; i &lt; 10; i++) &#123; Canvas canvas = holder.lockCanvas(); if (canvas != null) &#123; canvas.drawText(i + &quot;&quot;, i * 30, 50, mPaint); &#125; holder.unlockCanvasAndPost(canvas); &#125; &#125;&#125; 效果如下图所示： 按照我们的逻辑，如果有两块缓冲画布，那么结果应该是 1 3 5 7 9。因为最后一个更新的数字必然是 9，而往前推，每次间隔使用画布，跟 9 在同一块画布上的必然是 1 3 5 7，其他数字都在另一块画布上。但结果为什么是 0 3 6 9 呢？这是因为这里有三块缓冲画布。 如果我们在绘图时使用单独的线程，而且每次绘图完成以后，让线程休眠一段时间，就可以明显地看到每次所绘制的数字了。1234567891011121314151617181920private void drawText(final SurfaceHolder holder) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; Canvas canvas = holder.lockCanvas(); if (canvas != null) &#123; canvas.drawText(i + &quot;&quot;, i * 100, 150, mPaint); &#125; holder.unlockCanvasAndPost(canvas); try &#123; Thread.sleep(600); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start();&#125; 效果如下图所示。 从效果图中可以看出每次获取到的画布上所绘制的内容，很明显，0、1、2 这三个数字是分别在三块空白的画布上绘制的，之后的每个数字都是依次在这三块画布上绘制的。 有关 Surface 中缓冲画布的数量，Google 给出的解释 是：Surface 中缓冲画布的数量是根据需求动态分配的。如果用户获取画布的频率较慢，那么将会分配两块缓冲画布；否则，将分配 3 的倍数缓冲画布，具体分配多少块，视情况而定。 2. 双缓冲技术局部更新原理SurfaceView 支持局部更新，可以通过 Canvas lockCanvas(Rect dirty) 函数指定获取画布的区域和大小。画布以外的地方会将现在屏幕上的内容复制过来，以保持与屏幕一致；而画布以内的区域则保持原画布内容。 lockCanvas()：用于获取整屏画布，屏幕内容不会被更新到画布上，画布保持原画布内容。 lockCanvas(Rect dirty)：用于获取指定区域的画布，画布以外的区域会保持与屏幕内容一致，画布以内的区域依然保持原画布内容。 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class TestView extends SurfaceView &#123; private Paint mPaint; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; private void init() &#123; mPaint = new Paint(); mPaint.setColor(Color.argb(0x1F, 0xFF, 0xFF, 0xFF)); mPaint.setTextSize(60); getHolder().addCallback(new SurfaceHolder.Callback() &#123; @Override public void surfaceCreated(SurfaceHolder holder) &#123; drawText(holder); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123;&#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123;&#125; &#125;); &#125; private void drawText(final SurfaceHolder holder) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; // 先进行清屏操作 while (true) &#123; Rect dirtyRect = new Rect(0, 0, 1, 1); Canvas canvas = holder.lockCanvas(dirtyRect); Rect canvasRect = canvas.getClipBounds(); if (getWidth() == canvasRect.width() &amp;&amp; getHeight() == canvasRect.height()) &#123; canvas.drawColor(Color.BLACK); holder.unlockCanvasAndPost(canvas); &#125; else &#123; holder.unlockCanvasAndPost(canvas); break; &#125; &#125; // 画图 for (int i = 0; i &lt; 10; i++) &#123; // 画大方 if (i == 0) &#123; Canvas canvas = holder.lockCanvas(new Rect(10, 10, 600, 600)); canvas.drawColor(Color.RED); holder.unlockCanvasAndPost(canvas); &#125; // 画中方 if (i == 1) &#123; Canvas canvas = holder.lockCanvas(new Rect(30, 30, 570, 570)); canvas.drawColor(Color.GREEN); holder.unlockCanvasAndPost(canvas); &#125; // 画小方 if (i == 2) &#123; Canvas canvas = holder.lockCanvas(new Rect(60, 60, 540, 540)); canvas.drawColor(Color.BLUE); holder.unlockCanvasAndPost(canvas); &#125; // 画圆形 if (i == 3) &#123; Canvas canvas = holder.lockCanvas(new Rect(200, 200, 400, 400)); mPaint.setColor(Color.argb(0x3F, 0xFF, 0xFF, 0xFF)); canvas.drawCircle(300, 300, 100, mPaint); holder.unlockCanvasAndPost(canvas); &#125; // 写数字 if (i == 4) &#123; Canvas canvas = holder.lockCanvas(new Rect(250, 250, 350, 350)); mPaint.setColor(Color.RED); canvas.drawText(i + &quot;&quot;, 300, 300, mPaint); holder.unlockCanvasAndPost(canvas); &#125; try &#123; Thread.sleep(800); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125;&#125; 分析过程略，得出以下几个结论： 缓冲画布的存取遵循 LRU（先进先出）策略。 画布以内的区域仍在原缓冲画布上叠加作画，画布以外的区域是从屏幕上直接复制过来的。 为了防止画布以内的缓冲画布本身的图像与所画内容产生冲突，在对画布以内的区域作画时，建议先清空画布。 3. 局部更新为何要先清屏因为这里有三块缓冲画布，有一块画布初始化地被显示在屏幕上，已经被默认填充为黑色，而另外两块画布都还没有被画过。虽然我们指定了获取画布的区域范围，但是系统认为，整块画布都是脏区域，都应该被画上，所以会返回屏幕大小的画布。只有将每块画布都划过以后，才会按照我们指定的区域来返回画布大小。 4. 双缓冲技术解决方案方案一：保存所有要绘制的内容，全屏重绘12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class TestView extends SurfaceView &#123; private Paint mPaint; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; private void init() &#123; mPaint = new Paint(); mPaint.setColor(Color.RED); mPaint.setTextSize(100); getHolder().addCallback(new SurfaceHolder.Callback() &#123; @Override public void surfaceCreated(SurfaceHolder holder) &#123; drawText(holder); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123;&#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123;&#125; &#125;); &#125; private List&lt;Integer&gt; mInts = new ArrayList&lt;&gt;(); private void drawText(final SurfaceHolder holder) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; Canvas canvas = holder.lockCanvas(); mInts.add(i); if (canvas != null) &#123; for (int num : mInts) &#123; canvas.drawText(num + &quot;&quot;, num * 100, 150, mPaint); &#125; &#125; try &#123; Thread.sleep(600); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; holder.unlockCanvasAndPost(canvas); &#125; &#125; &#125;).start(); &#125;&#125; 方案二：在内容不交叉时，可以采用增量绘制 1234567891011121314151617181920212223242526272829303132333435363738private void drawText(final SurfaceHolder holder) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; // 先进行清屏操作 while (true) &#123; Rect dirtyRect = new Rect(0, 0, 1, 1); Canvas canvas = holder.lockCanvas(dirtyRect); Rect canvasRect = canvas.getClipBounds(); if (getWidth() == canvasRect.width() &amp;&amp; getHeight() == canvasRect.height()) &#123; canvas.drawColor(Color.BLACK); holder.unlockCanvasAndPost(canvas); &#125; else &#123; holder.unlockCanvasAndPost(canvas); break; &#125; &#125; // 画图 for (int i = 0; i &lt; 10; i++) &#123; int itemWidth = 100; int itemHeight = 100; Rect rect = new Rect(i*itemWidth, 0, (i+1)*itemWidth-10, itemHeight); Canvas canvas = holder.lockCanvas(rect); if (canvas != null) &#123; canvas.drawColor(Color.GREEN); canvas.drawText(i + &quot;&quot;, i*itemWidth+10, itemHeight/2f, mPaint); &#125; holder.unlockCanvasAndPost(canvas); try &#123; Thread.sleep(600); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start();&#125; 局部更新清屏代码，在每次开始运行程序时，在获取第二缓冲画布时，依然是全屏画布。但是同样的代码，从任务列表恢复程序时，又运行正常。百思不得其解！！！]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10.2 精通自定义 View 之 Android 画布——Bitmap]]></title>
    <url>%2F2019%2F07%2F10%2FCustom%20View%2F10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap%2F</url>
    <content type="text"><![CDATA[10.2.1 概述1. Bitmap 在绘图中的使用Bitmap 在绘图中相关的使用主要有两种：转换为 BitmapDrawable 对象使用；当做画布使用。 1）转换为 BitmapDrawable 对象使用就是直接将 Bitmap 转换为 BitmapDrawable 对象，然后转换为 Drawable 使用。如下：1234Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.head);BitmapDrawable bitmapDrawable = new BitmapDrawable(bitmap);ImageView imageView = findViewById(R.id.image_view);imageView.setImageDrawable(bitmapDrawable); 2）当做画布使用在前面的章节中，已经不止一次地将 Bitmap 转换为画布。这里有两种使用方式。方式一：使用默认画布12345678class TestView extends View &#123; ... public void onDraw(Canvas canvas) &#123; ... RectF rect = new RectF(120, 10, 210, 100); canvas.drawRect(rect, paint); &#125;&#125; 此处的 Canvas 里保存的就是一个 Bitmap，我们调用 Canvas 的各种绘图函数，最终都是画在这个 Bitmap 上的，而这个 Bitmap 就是默认画布。 方式二：自建画布有时候我们需要在特定的 Bitmap 上作画，比如给照片加水印；或者我们只需要一块空白画布。在这些情况下，我们就需要自己来创建 Canvas 对象。123Bitmap bitmap = Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_8888);Canvas canvas = new Canvas(bitmap);canvas.drawColor(Color.BLACK); 在上面的代码中，我们先创建一个空白的 Bitmap，然后再利用这个 Bitmap 创建一个 Canvas 对象，那么，调用 Canvas 的任何绘图函数最终都将画在这个 Bitmap 上。最后，我们可以将这个 Bitmap 保存到本地，也可以画到 View 上。 2. Bitmap 格式我们都知道 Bitmap 是位图，也就是由一个个像素点组成的。所以，它肯定涉及两个问题：第一，如何存储每个像素点；第二，相关的像素点之间是否能够压缩，这也就涉及压缩算法的问题。 1）如何存储每个像素点一张位图所占用的内存 = 图片长度(px) x 图片宽度(px) x 一个像素点占用的字节数。在 Android 中，存储一个像素点所使用的字节数是用枚举类型 Bitmap.Config 中的各个参数来表示的，如下图所示。 其中，A 代表透明度；R 代表红色；G 代表绿色；B 代表蓝色。 ALPHA_8：表示 8 位 Alpha 位图，即 A = 8，表示只存储 Alpha 位，不存储颜色值。一个像素点占用 1 字节。它没有颜色，只有透明度。 ARGB_4444：表示 16 位 ARGB 位图，即 A、R、G、B 各占 4 位，一个像素点占 4 + 4 + 4 + 4 = 16 位，2 字节。 ARGB_8888：表示 32 位 ARGB 位图，即 A、R、G、B 各占 8 位，一个像素点占 8 + 8 + 8 + 8 = 32 位，4 字节。 RGBA_F16：表示 32 位 RGBA 位图，8 字节。 RGB_565：表示 16 位 RGB 位图，即 R 占 5 位，G 占 6 位，B 占 5 位，它没有透明度，一个像素点占 5 + 6 + 5 = 16 位，2 字节。 大家应该都知道，每个色值所占得位数越大，颜色越艳丽。为什么呢？ 假设表示透明度的 A 占 4 位，我们来算一下，4 位的透明度有多少种取值？很明显，每位要么是 0，要么是 1，所以共有 2^4^，也就是 16 种取值。假设透明度占 8 位呢？那么这个透明度就有 2^8^，也就是 256 种取值。表示颜色值的 R、G、B 所占位数与颜色取值数的计算方式是一样的。很明显，取值数越多，所能表示的颜色就越多，颜色就越艳丽。 以上 5 种格式各自表示了以何种状态存储 Bitmap。ALPHA_8 格式只存储透明度，而不存储颜色值，由于所表示的内容太过简单，所以我们一般不用；RGB_565 格式只存储颜色值，而不存储透明度，透明度全部是 FF，假如对图片没有透明度要求，相比 ARGB_8888 格式将节省一半的内存开销；其他三种格式都是既存储透明度又存储颜色值，但 ARGB_4444 格式的画质惨不忍睹，在 API 13 中已经被弃用了。RGBA_F16 格式是最占内存的，同时也是画质最高的。如果对画质没那么高的要求，一般用 ARGB_8888 格式。 下面我们来看一下如何计算 Bitmap 所占的内存大小。 在讲解 Bitmap 所占内存大小之前，我们先明确一个概念：内存中存储的 Bitmap 对象与文件中存储的 Bitmap 图片不是一个概念。文件中存储的 Bitmap 图片是经过我们在后面降到的压缩算法压缩过得；而内存中存储的 Bitmap 对象是通过 BitmapFactory 或者 Bitmap 的 Create 方法创建的，它保存在内存中，而且具有明确的宽和高。所以，很明显，内存中存储的一个 Bitmap 对象，它所占的内存大小 = Bitmap 的宽 x Bitmap 的高 x 每个像素所占内存大小。 很多读者一旦需要画布，就会创建一个全屏幕大小的 Bitmap 作为画布。我们现在就来算一下在一个分辨率是 1024 像素 x 768 像素的屏幕上，创建一个与屏幕同样大小的 Bitmap，到底需要多少内存？也就是说，这个屏幕长度上有 1024 个像素，宽度上有 768 个像素。我们假设每个像素使用 ARGB_8888 格式来存储，也就是一个像素占 32 位，那么要全屏显示这张图片所占的内存大小 = 1024 x 768 x 32B = 25 165 824B = 24MB。全屏显示一张图片要用 24MB。而且更恐怖的是，有些人还会循环创建。这也是在有些人自定义的控件中经常出现 OOM 的原因。所以，我们在创建画布时，应尽量根据需要的大小来创建。 2）Bitmap 压缩格式在 Android 中，压缩格式使用枚举类 Bitmap.CompressFormat 中的成员变量表示，如下图所示。 其实这个参数很简单，就是指定 Bitmap 是以 JPEG、PNG 还是 WEBP 格式来压缩的，每种格式对应一种压缩算法。有关各种压缩算法的具体效果，我们会在 10.2.5 节中具体讲解。 10.2.2 创建 Bitmap 方法之一：BitmapFactoryBitmapFactory 用于从各种资源、文件、数据流和字节数组中创建 Bitmap（位图）对象。BitmapFactory 类是一个工具类，提供了大量的函数，这些函数可用于从不同的数据源中解析、创建 Bitmap（位图）对象。12345678910111213141516public static Bitmap decodeResource(Resources res, int id)public static Bitmap decodeResource(Resources res, int id, Options opts)public static Bitmap decodeFile(String pathName)public static Bitmap decodeFile(String pathName, Options opts)public static Bitmap decodeByteArray(byte[] data, int offset, int length)public static Bitmap decodeByteArray(byte[] data, int offset, int length, Options opts)public static Bitmap decodeFileDescriptor(FileDescriptor fd)public static Bitmap decodeFileDescriptor(FileDescriptor fd, Rect outPadding, Options opts)public static Bitmap decodeStream(InputStream is)public static Bitmap decodeStream(InputStream is, Rect outPadding, Options opts)public static Bitmap decodeResourceStream(Resources res, TypedValue value, InputStream is, Rect pad, Options opts) 单从这些函数中就可以看出，BitmapFactory 的功能很强大，可以针对资源、文件、字节数组、FileDescriptor 和 InputStream 数据流解析出对应的 Bitmap 对象，如果解析不出来，则返回 null。而且每个函数都有两个实现，两个实现之间只差一个 Options opts 参数（详见 10.2.3 节中讲述）。 1. decodeResource(Resources res, int id)这个函数表示从资源中解码一张位图，主要以 R.drawable.xxx 形式从本地资源中加载。 Resources res：包含图像数据的资源对象，一般通过 Context.getResource() 函数获得。 int id：包含图像数据的资源 id。 示例代码：1234Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.head_icon);ImageView iv = findViewById(R.id.img);iv.setImageBitmap(bitmap); 2. decodeFile(String pathName)这个函数的主要作用是通过文件路径来加载图片。在实际中，一般在从相册中加载图片或者拍照使用，首先通过 intent 打开相册或摄像头，然后通过 onActivityResult() 函数获取图片 URI，再根据 URI 获取图片路径，最后根据路径解析出图片。其过程详见 拍照、相册及裁剪的终极实现系列。 String pathName：解码文件的全路径名。必须是全路径名。 使用示例：12345String fileName = &quot;/data/data/demo.jpg&quot;;Bitmap bmp = BitmapFactory.decodeFile(fileName);if (bmp == null) &#123; // TODO 文件不存在&#125; 3. decodeByteArray(byte[] data, int offset, int length)根据 Byte 数组来解析出 Bitmap。 byte[] data：压缩图像数据的字节数组。 int offset：图像数据偏移量，用于解码器定位从哪里开始解析。 int length：字节数，从偏移量开始，指定取多少字节进行解析。 伪代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849final ImageView iv = findViewById(R.id.img);// 1. 开启异步线程去获取网络图片new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; // 2. 将网络返回的 InputStream 转换成 byte[] byte[] data = getImage(path); int length = data.length; // 3. 解析 final Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, length); iv.post(new Runnable() &#123; @Override public void run() &#123; iv.setImageBitmap(bitmap); &#125; &#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;).start();public static byte[] getImage(String path) throws Exception &#123; URL url = new URL(path); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(&quot;GET&quot;); connection.setReadTimeout(6 * 1000); InputStream in = null; if (connection.getResponseCode() == 200) &#123; in = connection.getInputStream(); byte[] result = readStream(in); in.close(); return result; &#125; return null;&#125;public static byte[] readStream(InputStream in) throws Exception &#123; ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len = -1; while ((len = in.read(buffer)) != -1) &#123; outputStream.write(buffer, 0, len); &#125; outputStream.close(); in.close(); return outputStream.toByteArray();&#125; 因为 BitmapFactory.decodeByteArray() 函数所需的 data 字节数组并不是想象中的数组，而是把输入流转换成字节内存输出流的字节数组格式。如果不经过 OutputStream 转换，直接返回从 InputStream 中读取到的 byte 数组，那么 decodeByteArray() 函数将一直返回 null。 4. decodeFileDescriptor有两个构造函数，其参数： FileDescriptor fd：包含解码位图数据的文件路径 Rect outPadding：用于返回矩形的内边距。如果 Bitmap 没有被解析成功，则返回 (-1, -1, -1, -1)；如果不需要，则可以传入 null。这个参数一般不使用。 示例代码：123456String path = &quot;/data/data/demo.jpg&quot;;FileInputStream is = new FileInputStream(path);bmp = BitmapFactory.decodeFileDescriptor(is.getFD());if (bmp == null) &#123; // TODO 文件不存在&#125; 在 Android 老版本中，BitmapFactory.decodeFileDescriptor() 解析方法比使用 BitmapFactory.decodeFile(path) 更节省内存。对比源码发现，前者是直接调用 nativeDecodeFileDescriptor() 函数，它是 Android Native 里的函数，被封装在 SO 里；而追踪 decodeFile() 函数发现，在最终调用 nativeDecodeStream() 函数之前，最多可能会申请两次空间。在 API 28 中源码没有发现多处申请内存空间的问题。 5. decodeStream12public static Bitmap decodeStream(InputStream is)public static Bitmap decodeStream(InputStream is, Rect outPadding, Options opts) InputStream is：用于解码位图的原始输入流。 Rect outPadding：用于返回矩形的内边距。如果 Bitmap 没有被解析成功，则返回 (-1, -1, -1, -1)；如果不需要，则可以传入 null。这个参数一般不使用。 对前面 decodeByteArray 示例代码进行改造：1234567891011121314151617181920212223242526272829new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; InputStream inputStream = getImage(path); final Bitmap bitmap = BitmapFactory.decodeStream(inputStream); iv.post(new Runnable() &#123; @Override public void run() &#123; iv.setImageBitmap(bitmap); &#125; &#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;).start();public static InputStream getImage(String path) throws Exception &#123; URL url = new URL(path); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(&quot;GET&quot;); connection.setReadTimeout(6 * 1000); InputStream in = null; if (connection.getResponseCode() == 200) &#123; return connection.getInputStream(); &#125; return null;&#125; 10.2.3 BitmapFactory.Options这个参数的作用非常大，它可以设置 Bitmap 的采样率，通过改变图片的宽度、高度、缩放比例等，以减少图片的像素的目的。总的来说，通过设置这个值，可以更好地控制、显示、使用 Bitmap。在实际开发中可以灵活使用该值，以降低 OOM 的发生概率。 下面列出常用的部分成员变量。12345678910public boolean inJustDecodeBounds;public int inSampleSize;public int inDensity;public int inTargetDensity;public int inScreenDensity;public Bitmap.Config inPreferredConfig;public int outWidth;public int outHeight;public String outMimeType; 以 in 开头的代表的就是设置某某参数；以 out 开头的代表的就是获取某某参数。比如，inSampleSize 就是设置 Bitmap 的缩放比例，outWidth 就是获取 Bitmap 的高度。 1. inJustDecodeBounds 获取图片信息将这个字段设置为 true，则表示只解析图片信息，不获取图片，不分配内存。能获取的信息有图片的宽度、高度和图片的 MIME 类型。图片的宽度、高度通过 options.outWidth (图片的原始宽度) 和 options.outHeight (图片的原始高度) 返回；图片的 MIME 类型通过 options.outMimeType 返回。1234567BitmapFactory.Options options = new BitmapFactory.Options();options.inJustDecodeBounds = true;Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.head, options);Log.d(&quot;xian&quot;, &quot;bitmap: &quot; + bitmap);Log.d(&quot;xian&quot;, &quot;realWidth: &quot; + options.outWidth + &quot;, realHeight: &quot; + options.outHeight + &quot;, mimeType: &quot; + options.outMimeType); 从结果中看可以看出，返回的 Bitmap 是 null，而获取到的 width 和 height 都是有值的。这就证明了我们的结论：inJustDecodeBounds 只会解析 Bitmap 的宽/高参数，而不会解析 Bitmap，整个过程是不占内存的。 2. inSampleSize 压缩图片这个字段表示采样频率，简称采样率，是指每隔多少个样本采样一次作为结果。比如，将这个字段设置为 4，意思就是从原本图片的 4 个像素中取一个像素作为结果返回，其余的都丢弃，这样，结果图片的宽和高都为原来的 1/4。同样，如果将这个字段设置为 16，意思就是从每 16 个像素中取一个像素返回，同样，宽和高都为原来的 1/16。很明显，采样率越大，图片越小，同时图片越失真。 针对 inSampleSize 的值，官方建议取 2 的冥数，比如 1、2、4、8、16 等，否则会被系统向下取整并找到一个最接近的值。不能去小于 1 的值，否则系统将一直使用 1 来作为采样率。 所以，这个参数主要用来对图像进行压缩。那如何确定一张图片的采样率呢？那就是使得缩放后的图片尺寸尽量大于等于相应的 ImageView 大小。一般计算 inSampleSize 的步骤如下。 第一步，获取图片的原始宽高。通过将 Options 对象的 inJustDecodeBounds 属性设置为 true 后调用 decodeResource() 函数，可以实现不真正加载图片而只获取图片的尺寸信息。代码如下：1234BitmapFactory.Options options = new BitmapFactory.Options();options.inJustDecodeBounds = true;BitmapFactory.decodeResource(getResources(), resId, options);// 现在原始宽高存储在 Options 对象的 outWidth 和 outHeight 实例域中 第二步，根据原始宽高和目标宽高计算出 inSampleSize。代码如下：123456789101112// dstWidth 和 dstHeight 分为被目标 ImageView 的宽和高public static int calSampleSize(BitmapFactory.Options options, int dstWidht, int dstHeight) &#123; int rawWidth = options.outWidth; int rawHeight = options.outHeight; int inSampleSize = 1; if (rawWidth &gt; dstWidth || rawHeight &gt; dstHeight) &#123; float ratioWidth = (float) rawWidth / dstWidth; float ratioHeight = (float) rawHeight / dstHeight; inSampleSize = (int) Math.min(ratioWidth, ratioHeight); &#125; return inSampleSize;&#125; 第三步，根据采样率解析出压缩后的 Bitmap。代码如下：12345678BitmapFactory.Options options2 = new BitmapFactory.Options();options2.inSampleSize = sampleSize;try &#123; Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.scenery, options2); iv.setImageBitmap(bmp);&#125; catch (OutOfMemoryError err) &#123; // TODO OOM&#125; 3. 加载一个 Bitmap 文件究竟要占多少空间为了适配不同的屏幕，Android 系统预先准备了几个资源文件夹。 文件夹 drawable-ldpi drawable-mdpi drawable-hdpi drawable-xhdpi drawable-xxhdpi drawable-xxxhdpi density 1 1.5 2 3 3.5 4 densityDpi 160 240 320 480 560 640 density：表示 dpi 与 px 的换算比例。 densityDpi：表示在对应的分辨率下每英寸有多少个 dpi。 即：屏幕上 1 英寸长所对应的 px 数 = density × densityDpi。Android 系统在加载图片时会根据需要动态缩放图片所占的像素数，也就是会动态缩放图片的尺寸。 比如，有一张 640px × 800px 的图片存放在 xhdpi 文件夹下，这个文件夹所对应的屏幕分辨率是 480dpi，而当真实的屏幕分辨率是 720dpi 的时候，就需要放大此图，以适配这个屏幕，放大倍数就是 720 / 480 = 1.5。加载到内存时，Bitmap 对象的尺寸是 960px × 1200px。因为 Bitmap 默认使用 ARGB_8888格式来存储，也就是每个像素占 4 个字节，所以实际所占得内存字节数为 640px × 1.5 × 800px × 1.5 × 4 = 4608000。但是从 SD 卡加载同样的图片，就不会进行缩放，所占的内存为 640px × 800px × 4 = 2048000。 不同名称的资源文件夹是为了适配不同的屏幕分辨率的，当屏幕分辨率与文件所在资源文件夹对应的分辨率相同时，直接使用图片，不会对图片进行缩放。 当屏幕分辨率与图片所在文件夹所对应的分辨率不同时，会进行缩放，缩放比例是：屏幕分辨率 / 文件夹所对应的分辨率。 当从本地文件夹中加载图片时，不会对图片进行缩放。 4. inScaled、inDensity、inTargetDensity、inScreenDensity inScaled：在需要缩放时，是否对当前文件进行缩放。值为 false 表示不缩放；值为 true 或者不设置，则会根据文件夹分辨率和屏幕分辨率动态缩放。默认为 true。 inDensity：用于设置文件所在资源文件夹的屏幕分辨率。 inTargetDensity：表示真实显示的屏幕分辨率。 inScreenDensity：在源码中没有用到此参数，不表。 一张图片的缩放比例是通过屏幕真实的分辨率 / 所在资源文件夹所对应的分辨率得出来的，在这里，也就是缩放比例 scale = inTargetDensity / inDensity。这俩个参数的作用就是：可以通过手动设置文件所在资源文件夹的分辨率和真实显示的屏幕分辨率来指定图片的缩放比例。 5. inPreferredConfig这个参数用来设置像素的存储格式的。1options.inPreferredConfig = Bitmap.Config.RGB_565; 10.2.4 创建 Bitmap 方法之二：Bitmap 静态方法123456789101112static Bitmap createBitmap(int width, int height, Bitmap.Config config)static Bitmap createBitmap(int[] colors, int width, int height, Bitmap.Config config)static Bitmap createBitmap(int[] colors, int offset, int stride, int width, int height, Bitmap.Config config)static Bitmap createBitmap(Bitmap src)static Bitmap createBitmap(Bitmap src, int dstWidth, int dstHeight, boolean filter)static Bitmap createBitmap(Bitmap source, int x, int y, int width, int height)static Bitmap createBitmap(Bitmap source, int x, int y, int width, int height, Matrix m, boolean filter)// 在 API 17 中添加static Bitmap createBitmap(DisplayMetrics display, int width, int height, Bitmap.Config config)static Bitmap createBitmap(DisplayMetrics display, int[] colors, int width, int height, Bitmap.Config config)static Bitmap createBitmap(DisplayMetrics display, int[] colors, int offset, int stride, int width, int height, Bitmap.Config config) 1. static Bitmap createBitmap(int width, int height, Bitmap.Config config)这个函数可以创建一幅指定大小的空白图像。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class TestView extends View &#123; private Bitmap mDestBmp; private Paint mPaint; public TestView(Context context) &#123; super(context); init(); &#125; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public TestView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init() &#123; mPaint = new Paint(); int width = 500; int height = 300; mDestBmp = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(mDestBmp); Paint paint = new Paint(); LinearGradient linearGradient = new LinearGradient(width / 2f, 0, width / 2f, height, 0xffffffff, 0x00ffffff, Shader.TileMode.CLAMP); paint.setShader(linearGradient); canvas.drawRect(0, 0, width, height, paint); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawBitmap(mDestBmp, 0, 0, mPaint); mPaint.setColor(Color.RED); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(5); canvas.drawRect(0, 0, mDestBmp.getWidth(), mDestBmp.getHeight(), mPaint); &#125;&#125; 2. createBitmap(Bitmap source, int x, int y, int width, int height)这个函数主要用于裁剪图像，各参数的含义如下。 Bitmap source：用于裁剪的源图像。 int x, y：开始裁剪的位置点坐标。 int width, height：裁剪的宽度和高度。 12Bitmap src = BitmapFactory.decodeResource(getResources(), R.drawable.dog);Bitmap cuteBmp = Bitmap.createBitmap(src, src.getWidth() / 3, src.getHeight() / 3, src.getWidth() / 3, src.getHeight() / 3) 这里只是将图像裁剪成矩形。若想把图像裁剪成圆形或者椭圆形，不是使用 Bitmap 的自带方法，而需要用到 Xfermode 图像混合的知识，详见 8.3.2 节。 3. createBitmap(Bitmap source, int x, int y, int width, int height, Matrix m, boolean filter)这个函数相比上面的裁剪函数多了两个参数：Matrix m 和 boolean filter。它的作用也很明显，就是不仅能实现裁剪，还能给裁剪后的图像添加矩阵。 Matrix m：给裁剪后的图像添加矩阵。 boolean filter：对应 paint.setFilterBitmap(filter)，即是否给图像添加滤波效果。如果设置为 true，则能够减少图像中由于噪声引起的突兀的孤立像素点或像素块。 1234Matrix matrix = new Matrix();matrix.setScale(2, 1);Bitmap src = BitmapFactory.decodeResource(getResources(), R.drawable.dog);Bitmap cuteBmp = Bitmap.createBitmap(src, src.getWidth() / 3, src.getHeight() / 3, src.getWidth() / 3, src.getHeight() / 3, matrix, true) 将裁剪后的小狗宽度方向放大两倍。 4. createBitmap(Bitmap src, int dstWidth, int dstHeight, boolean filter)该函数用于缩放 Bitmap。各参数的含义如下。 Bitmap src：需要缩放的源图像。 int dstWidth, dstHeight：缩放后的目标宽高。 boolean filter：是否给图像添加滤波效果，对应 paint.setFilterBitmap(filter) 5. 建议在加载或创建 Bitmap 时，必须如下面代码所示，通过 try…catch 语句捕捉 OutOfMemoryError，以防出现 OOM 问题。123456try &#123; Bitmap src = BitmapFactory.decodeResource(getResources(), R.drawable.scenery); Bitmap bitmap = Bitmap.createScaledBitmap(src, 300, 200, true);&#125; catch (OutOfMemoryError error) &#123; error.printStackTrace();&#125; 10.2.5 常用函数1. copy(Config config, boolean isMutable)根据源图像创建一个副本，可以指定副本的像素存储格式。 Config config：像素在内存中的存储格式。取值为 ARGB_8888等。 boolean isMutable：新创建的 Bitmap 是否可以更改其中的像素。 我们可以使用下面的方法来判断当前的 Bitmap 是不是像素可更改的。1boolean isMutable(); 返回 true 表示像素可以更改的。如果像素是不可更改的，但仍要使用 setPixel() 等函数设置 Bitmap 中的像素值时，就会报错。通过 BitmapFactory 加载的 Bitmap 都是像素不可更改的，只有通过 Bitmap 中的几个函数创建的 Bitmap 才是像素可更改的。这些函数如下：123456copy(Bitmap.Config config, boolean isMutable)createBitmap(int width, int height, Bitmap.Config config)// 当指定的目标缩放宽高与源图像宽高一样时，就会返回源图像，如果源图像是像素不可更改的，那么返回的图像依然是不可更改的// 进行缩放过才会生成新的图像，而新生成的图像是像素可更改的。createScaledBitmap(Bitmap src, int dstWidth, int dstHeight, boolean filter)createBitmap(DisplayMetrics display, int width, int height, Bitmap.Config config) 对于像素不可更改的图像，是不能作为画布的，比如下面的代码就会报错：123Bitmap srcBmp = BitmapFactory.decodeResource(getResources(), R.drawable.dog);Canvas canvas = new Canvas(srcBmp);canvas.drawColor(Color.RED); 显然，srcBmp 是像素不可更改的，然而，当其作为 Canvas 以后，如果要向其中填充颜色，则必然会改变它的像素值，肯定为报错。 2. extractAlpha()这个函数的主要作用是从 Bitmap 中抽取出 Alpha 值，生成一幅只含有 Alpha 值的图像，像素存储格式是 ALPHA_8。它有两个构造函数。 1）Bitmap extractAlpha()示例：将图像的透明通道抽取出来，并染成天蓝色。 1234567891011Bitmap srcBmp = BitmapFactory.decodeResource(getResources(), R.drawable.cat_dog);Bitmap bitmap = Bitmap.createBitmap(srcBmp.getWidth(), srcBmp.getHeight(), Bitmap.Config.ARGB_8888);Canvas canvas = new Canvas(bitmap);Paint paint = new Paint();paint.setColor(Color.CYAN);canvas.drawBitmap(srcBmp.extractAlpha(), 0, 0, paint);ImageView iv = findViewById(R.id.img);iv.setImageBitmap(bitmap);srcBmp.recycle(); 2）Bitmap extractAlpha(Paint paint, int[] offsetXY) Paint paint：具有 MaskFilter 效果的 Paint 对象，一般使用 BlurMaskFilter 模糊效果。 int[] offsetXY：返回在添加 BlurMaskFilter 效果以后原点的偏移量。比如，我们使用一个半径为 6 的 BlurMaskFilter 效果，那么在源图像被模糊以后，图像的上下左右 4 条边都会多出 6px 的模糊效果。所以，要想完全显示这幅图像，就不应该从源图像左上角 (0, 0) 点开始绘制，而应从 (-6, -6) 点开始绘制，而 offsetXY 就是相对源图像的建议绘制起始位置，所以此时 offsetXY 的值就是 [-6, -6]。注意，offsetXY 只是建议的绘制起始位置，其取值并不一定与 BlurMaskFilter 的模糊半径一致。 利用这个模糊效果，可以实现发光效果，如下图所示。 1234567891011121314151617181920212223242526272829303132333435public class MainActivity extends AppCompatActivity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); try &#123; Bitmap srcBmp = BitmapFactory.decodeResource(getResources(), R.drawable.cat_dog); // 获取 Alpha Bitmap Paint alphaPaint = new Paint(); BlurMaskFilter blurMaskFilter = new BlurMaskFilter(20, BlurMaskFilter.Blur.NORMAL); alphaPaint.setMaskFilter(blurMaskFilter); int[] offsetXY = new int[2]; Bitmap alphaBmp = srcBmp.extractAlpha(alphaPaint, offsetXY); // 创建 Bitmap Bitmap bitmap = Bitmap.createBitmap(alphaBmp.getWidth(), alphaBmp.getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); Paint paint = new Paint(); paint.setColor(Color.CYAN); canvas.drawBitmap(alphaBmp, 0, 0, paint); // 绘制源图像 canvas.drawBitmap(srcBmp, -offsetXY[0], -offsetXY[1], null); // 设置图像并回收没用的资源 ImageView iv = findViewById(R.id.img); iv.setImageBitmap(bitmap); srcBmp.recycle(); &#125; catch (OutOfMemoryError error) &#123; error.printStackTrace(); &#125; &#125;&#125; 3）示例：单击描边效果 1234567891011121314151617181920212223242526272829303132333435363738394041public class TestView extends AppCompatImageView &#123; public TestView(Context context) &#123; super(context); &#125; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public TestView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); &#125; @Override protected void onFinishInflate() &#123; super.onFinishInflate(); Paint p = new Paint(); p.setColor(Color.CYAN); setStateDrawable(this, p); &#125; private void setStateDrawable(ImageView view, Paint paint) &#123; // 拿到源图像 BitmapDrawable bd = (BitmapDrawable) view.getDrawable(); Bitmap srcBmp = bd.getBitmap(); // 制作纯色背景 Bitmap bitmap = Bitmap.createBitmap(srcBmp.getWidth(), srcBmp.getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); canvas.drawBitmap(srcBmp.extractAlpha(), 0, 0, paint); // 添加动态 StateListDrawable sld = new StateListDrawable(); sld.addState(new int[]&#123;android.R.attr.state_pressed&#125;, new BitmapDrawable(bitmap)); // setBackgroundDrawable() 函数会移除原有的 padding 值。 // 如果需要 padding，则需要调用 setPadding() 函数。 view.setBackgroundDrawable(sld); &#125;&#125; 3. 分配空间获取12345678// API 19，获取 Bitmap 所分配的内存int getAllocationByteCount()// API 12，获取 Bitmap 所分配的内存int getByteCount()// API 1，获取每行所分配的内存大小。Bitmap 所占内存 = getRowBytes() × bitmap.getHeight()。int getRowBytes() 所以，一般计算 Bitmap 内存占用的函数会写成如下这样：123456789101112public int getBitmapSize(Bitmap bitmap) &#123; if (bitmap == null) &#123; return 0; &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; return bitmap.getAllocationByteCount(); &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB_MR1) &#123; return bitmap.getByteCount(); &#125; return bitmap.getRowBytes() * bitmap.getHeight();&#125; 4. recycle()、isRecycled()这是两个与图片回收有关的函数，其声明如下：12345// 强制回收 Bitmap 所占的内存public void recycle()// 判断当前 Bitmap 的内存是否被回收public final boolean isRecycled() 所以，如果要回收内存，则代码一般这样写：12345if (bitmap != null &amp;&amp; !bitmap.isRecycled()) &#123; bitmap.recycle(); bitmap = null; System.gc();&#125; 注意：使用内存已经被回收的 Bitmap 引起 Crash；在 API 10 及以前的版本中，必须强制调用 recycle() 函数来释放内存；从 API 11 开始，不再强制调用 recycle() 函数来释放内存。 5. setDensity()、getDensity()在 BitmapFactory 中，我们讲过几个 Density 值，如 inDensity、inTargetDensity，而这里 Bitmap 的 setDensity()、getDensity() 函数所对应的就是 inDensity。inDensity 用于表示该 Bitmap 适合的屏幕 dpi，当目标屏幕的 dpi (inTargetDensity) 不等于它时，将会缩放图像以适应目标机器。 6. setPixel()、getPixel()这两个函数用于针对 Bitmap 中某个位置的像素进行设置和获取。举个例子：将图片中的绿色通道增大 30，如下图所示。 完整代码如下：123456789101112131415161718192021222324252627282930313233public class MainActivity extends AppCompatActivity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); Bitmap srcBmp = BitmapFactory.decodeResource(getResources(), R.drawable.dog); ImageView iv1 = findViewById(R.id.img1); iv1.setImageBitmap(srcBmp); Bitmap desBmp = srcBmp.copy(Bitmap.Config.ARGB_8888, true); for (int h = 0; h &lt; srcBmp.getHeight(); h++) &#123; for (int w = 0; w &lt; srcBmp.getWidth(); w++) &#123; int originColor = srcBmp.getPixel(w, h); int alpha = Color.alpha(originColor); int red = Color.red(originColor); int green = Color.green(originColor); int blue = Color.blue(originColor); if (green &lt; 225) &#123; green += 30; &#125; desBmp.setPixel(w, h, Color.argb(alpha, red, green, blue)); &#125; &#125; ImageView iv2 = findViewById(R.id.img2); iv2.setImageBitmap(desBmp); &#125;&#125; 7. compress()1）概述用于压缩图像，它会将压缩过得 Bitmap 写入指定的输出流中。函数声明如下：1public boolean compress(CompressFormat format, int quality, OutputStream stream) CompressFormat format：压缩格式，取值有：CompressFormat.JPEG、CompressFormat.PNG、CompressFormat.WEBP (API 14)。 int quality：表示压缩后图像的画质，取值是 0~100。0 表示 以最低画质压缩，100 表示以最高画质压缩。对于 PNG 等无损格式的图片，会忽略此项设置。 OutputStream stream：这是输出值，Bitmap 在被压缩后，会以 OutputStream 的形式在这里输出。 返回值 boolean：当压缩成功后，返回 true；失败则返回 false。 2）压缩格式 CompressFormat.JPEG： 采用 JPEG 压缩算法，是一种有损压缩方式，即在压缩过程中会改变图像的原本质量。compress() 函数中的 quality 参数值越小，画质越差，对图片的原有质量损伤越大，但是得到的图片文件比较小。而且，JPEG 不支持 Alpha 透明度，当遇到透明度像素时，会以黑色背景填充。 CompressFormat.PNG：采用 PNG 压缩算法，是一种支持透明度的无损压缩格式。 CompressFormat.WEBP：WEBP 是一种同时提供了有损压缩与无损压缩的图片文件格式，派生自视频编码格式 VP8；从 Android 4.0（API 14）开始支持 WEBP，从 Android 4.2.1+（API 18）开始支持无损 WEBP 和带 Alpha 通道的 WEBP。从整体来讲，WEBP 格式是通过牺牲压缩时间来减小产出文件大小的。 3）压缩图像 123456789101112131415161718192021222324252627282930public class MainActivity extends AppCompatActivity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); ImageView iv1 = findViewById(R.id.img1); final ImageView iv2 = findViewById(R.id.img2); final Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.head); iv1.setImageBitmap(bmp); new Thread(new Runnable() &#123; @Override public void run() &#123; // 压缩图像后，显示 ByteArrayOutputStream bos = new ByteArrayOutputStream(); bmp.compress(Bitmap.CompressFormat.JPEG, 1, bos); byte[] bytes = bos.toByteArray(); final Bitmap bmp1 = BitmapFactory.decodeByteArray(bytes, 0, bytes.length); iv2.post(new Runnable() &#123; @Override public void run() &#123; iv2.setImageBitmap(bmp1); &#125; &#125;); &#125; &#125;).start(); &#125;&#125; 4）示例：保存压缩后的图像12345678910111213141516171819private void saveBitmap(Bitmap bitmap) &#123; File fileDir = Environment.getExternalStorageDirectory(); String path = fileDir.getAbsolutePath() + &quot;/xian.jpeg&quot;; File file = new File(path); if (file.exists()) &#123; file.delete(); &#125; try &#123; FileOutputStream outputStream = new FileOutputStream(file); bitmap.compress(Bitmap.CompressFormat.JPEG, 10, outputStream); outputStream.flush(); outputStream.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 10.2.6 常见问题1. 对 Bitmap 的画笔设置 ANTI_ALIAS_FLAG 属性，为什么无效简单来说，ANTI_ALIAS_FLAG 属性通过混合前景色与背景色来产生平滑的边缘。比如背景色是透明的，而前景色是红色的，ANTI_ALIAS_FLAG 属性通过将边缘处的像素由纯色逐步转换为透明来让边缘看起来是平滑的。 而当我们在 Bitmap 上重绘时，像素的颜色会越来越纯粹，从而导致边缘越来越粗糙。所以，可以有两种选择即可避免设置 ANTI_ALIAS_FLAG 属性无效的问题： 避免重绘。 在重绘前清空 Bitmap。 避免重绘的方法很简单，只需要保证让 Bitmap 只被绘制一次即可，比如将 Bitmap 绘制操作放在初始化的时候，而不要放在可能被多次调用的 onDraw()、onMeasure()、onLayout() 等函数中。 清空 Bitmap 可以参考如下：12345678910111213141516private Bitmap mBitmap;private Canvas mCanvas;private void init() &#123; mBitmap = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888); mCanvas = new Canvas(mBitmap);&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 清空 Bitmap mCanvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR); // ... mCanvas.drawXXX();&#125; 2. 如何生成水印其实原理很简单，新生成一个 Bitmap，先后将源 Bitmap 和水印 Bitmap 画上去即可。 ```public class MainActivity extends AppCompatActivity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.act_main); Bitmap srcBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.meinv); Bitmap waterBitmap = getWaterBitmap(); Bitmap bitmap = createWaterBitmap(srcBitmap, waterBitmap); ImageView imageView = findViewById(R.id.img); imageView.setImageBitmap(bitmap); } /** * 添加水印 * @param srcBitmap 源图 * @param waterBitmap 水印图 * @return 添加水印的图像 */ private Bitmap createWaterBitmap(Bitmap srcBitmap, Bitmap waterBitmap) { if (srcBitmap == null) { return null; } if (waterBitmap == null) { return srcBitmap; } int w = srcBitmap.getWidth(); int h = srcBitmap.getHeight(); int ww = waterBitmap.getWidth(); int wh = waterBitmap.getHeight(); // 创建空白图像，宽高等同 srcBitmap Bitmap newBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(newBitmap); // 画原图，从 (0, 0) 坐标开始 canvas.drawBitmap(srcBitmap, 0, 0, null); // 在原图的右下角画入水印 canvas.drawBitmap(waterBitmap, w - ww + 10, h - wh + 10, null); return newBitmap; } /** * 水印 * @return Bitmap */ private Bitmap getWaterBitmap() { return makeTextBitmap(&quot;先小涛&quot;, 200, Color.GRAY); } /** * 将字符串转化成 bitmap * @return Bitmap */ private Bitmap makeTextBitmap(String text, int size, int color) { Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG); paint.setTextSize(size); paint.setColor(color); paint.setTextAlign(Paint.Align.LEFT); Paint.FontMetricsInt fm = paint.getFontMetricsInt(); int width = (int) paint.measureText(text); int height = fm.descent - fm.ascent; Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); canvas.drawText(text, 0, fm.leading - fm.ascent, paint); canvas.save(); return bitmap; } }]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10.1 精通自定义 View 之 Android 画布——ShapeDrawable]]></title>
    <url>%2F2019%2F07%2F10%2FCustom%20View%2F10.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94ShapeDrawable%2F</url>
    <content type="text"><![CDATA[前面，我们提到了获取画布的几种方法。除了重写系统的 onDraw()、dispatchDraw() 函数，还可以通过以下方法获得画布： 通过 Bitmap 创建。 通过 SurfaceView 的 SurfaceHolder.lockCanvas() 函数获取。 另外，我们也提到过通过创建 Drawable 对象，然后将画好的 Drawable 对象画在画布上，也是创建 Bitmap 的一种方式。 Drawable 类有很多的派生类，如下图所示。 这些派生类都可以通过 Drawable 的 draw(Canvas canvas) 函数将其画到画布上。这里以最常用的 ShapeDrawable 为例来进行讲解。 shape 标签可以实现的效果与 ShapeDrawable 类似，但是 shape 标签所对应的 Java 类是 GradientDrawable，而不是 ShapeDrawable。使用如下代码会发生强转异常：1ShapeDrawable shapeDrawable = (ShapeDrawable) textView.getBackground(); 10.1.1 shape 标签与 GradientDrawable1. 是 ShapeDrawable 还是 GradientDrawable前面讲过，shape 标签所对应的类是 GradientDrawable 而不是 ShapeDrawable，但是 GradientDrawable 并不能完成 shape 标签的所有功能，因为 GradientDrawable 的构造函数如下如所示。 从构造函数中可以明显看出，GradientDrawable 所对应的是 gradient 标签的功能，并不能完成 shape 标签所能完成的构造矩形、椭圆等功能；而神奇的是，通过 ShapeDrawable 却可以完成 shape 标签的所有功能！至于造成这种问题的原因，此处不再深究，只需知道在代码中得到 shape 标签实例的时候要强转 GradientDrawable 就可以了。 2. 获取 shape 标签的实例实现这样一个功能：在单击按钮的时候，给原有的 shape 标签添加圆角。 新建 shape 文件：res/drawable/shape_solid.xml123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;solid android:color=&quot;#FF0000&quot;/&gt; &lt;stroke android:width=&quot;2dp&quot; android:color=&quot;#00FF00&quot; android:dashGap=&quot;5dp&quot; android:dashWidth=&quot;5dp&quot;/&gt;&lt;/shape&gt; 在布局中使用：res/layout/act_main.xml12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:id=&quot;@+id/add_shape_corner&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;添加圆角&quot;/&gt; &lt;TextView android:id=&quot;@+id/shape_tv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;shape 标签实例&quot; android:padding=&quot;10dp&quot; android:layout_margin=&quot;20dp&quot; android:background=&quot;@drawable/shape_solid&quot;/&gt;&lt;/LinearLayout&gt; 动作代码：src/…/MainActivity.java1234567891011121314151617public class MainActivity extends AppCompatActivity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); final TextView tv = findViewById(R.id.shape_tv); findViewById(R.id.add_shape_corner).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; GradientDrawable drawable = (GradientDrawable) tv.getBackground(); drawable.setCornerRadius(20); &#125; &#125;); &#125;&#125; 10.1.2 ShapeDrawable 的构造函数ShapeDrawable 有两个构造函数：123456// 一：无参构造函数，需配合 setShape()ShapeDrawable()setShape(Shape shape)// 二：常用ShapeDrawable(Shape shape) Shape 是个抽象基类，实际应用中需要 Shape 的派生类。Shape 类的派生类如下图所示。 每个派生类的具体含义如下。 RectShape：构造一个矩形 Shape。 ArcShape：构造一个扇形 Shape。 OvalShape：构造一个椭圆 Shape。 RoundRectShape：构造一个圆角矩形 Shape，可带有镂空矩形效果。 PathShape：构造一个可根据路径绘制的 Shape。 1. RectShape1234567891011121314151617181920212223242526272829303132public class TestView extends View &#123; private ShapeDrawable mDrawable; public TestView(Context context) &#123; super(context); init(); &#125; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public TestView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; setLayerType(LAYER_TYPE_SOFTWARE, null); mDrawable = new ShapeDrawable(new RectShape()); mDrawable.setBounds(new Rect(50, 50, 200, 100)); mDrawable.getPaint().setColor(Color.RED); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mDrawable.draw(canvas); &#125;&#125; 使用定义好的自定义控件：123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:background=&quot;#EEE&quot;&gt; &lt;com.xxt.xtest.TestView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;80dp&quot; android:layout_margin=&quot;50dp&quot; android:background=&quot;#FFFFFF&quot;/&gt;&lt;/LinearLayout&gt; 效果图如下所示。 为了方便显示，将整个控件设置为白色。而且为了确认 mDrawable.setBounds(new Rect(50, 50, 200, 100)); 中矩形位置是在当前控件中的位置，我们给 TestView 控件添加了 margin 值。 从效果图中可以看出： ShapeDrawable.setBounds() 函数所设置的矩形位置是指所在控件中的位置，而不是以屏幕左上角点为坐标的。 通过 mDrawable.getPaint() 函数得到 ShapeDrawable 自带的画笔，并对其进行操作，效果将直接显示在 ShapeDrawable 中。 2. OvalShapeOvalShape 是指根据 ShapeDrawable.setBounds() 函数所定义的位置矩形生成一个椭圆形状的 Shape。123456private void init() &#123; setLayerType(LAYER_TYPE_SOFTWARE, null); mDrawable = new ShapeDrawable(new OvalShape()); mDrawable.setBounds(new Rect(50, 50, 200, 100)); mDrawable.getPaint().setColor(Color.RED);&#125; 这里的矩形位置和大小与 RectShape 中的矩形位置和大小一样，只是把 RectShape 改成了 OvalShape，效果如下图所示。 3. ArcShapeArcShape 是在 OvalShape 所形成的椭圆的基础上，将其进行角度切割所形成的扇形。其中扇形开始的 0° 在椭圆的 X 轴正方向上。其只有一个构造函数。1public ArcShape(float startAngle, float sweepAngle) startAngle：指开始角度，扇形开始的 0° 在椭圆的 X 轴正方向上，即右中间位置。 sweepAngle：指扇形所扫过的角度。 同举一个例子：123456private void init() &#123; setLayerType(LAYER_TYPE_SOFTWARE, null); mDrawable = new ShapeDrawable(new ArcShape(0, 300)); mDrawable.setBounds(new Rect(50, 50, 200, 100)); mDrawable.getPaint().setColor(Color.RED);&#125; 效果如下图所示。 4. RoundRectShapeRoundRectShape 在字面意思上是指圆角矩形。其实，它不仅能实现圆角矩形，它的本意是实现镂空的圆角矩形。它所能实现的效果如下图所示。 左图带有圆角的矩形，右图为中间带有镂空矩形的圆角矩形，而且中间的镂空矩形也可以带有圆角。 其构造函数如下：1public RoundRectShape(float[] outerRadii, RectF inset, float[] innerRadii) float[] outerRadii：外围矩形的各个角的角度大小，需要填充 8 个数字，每两个数字一组，分别对应（左上角、右上角、右下角、左下角）4 个角的角度。每两个一组的数字构成一个椭圆，第一个数字代表椭圆的 X 轴半径，第二个数字代表椭圆的 Y 轴半径。如果不需要制定外围矩形的各个角的角度，则可以传入 null。 RectF inset：表示内部矩形与外部矩形各边的边距。RectF 的 4 个值分别对应 left、top、right、bottom 4 条边的边距。如果不需要内部矩形的镂空效果，则可以传入 null。 float[] innerRadii：表示内部矩形的各个角的角度大小，同样需要填充 8 个数字，其含义与 outerRadii 一样。如果不需要制定内部矩形的各个角的角度，则可以传入 null。 同样举一个例子：123456789private void init() &#123; setLayerType(LAYER_TYPE_SOFTWARE, null); float[] outerR = new float[] &#123; 12, 12, 12, 12, 0, 0, 0, 0 &#125;; RectF inset = new RectF(6, 6, 6, 6); float[] innerR = new float[] &#123; 50, 12, 0, 0, 12, 50, 0, 0 &#125;; mDrawable = new ShapeDrawable(new RoundRectShape(outerR, inset, innerR)); mDrawable.setBounds(new Rect(50, 50, 200, 100)); mDrawable.getPaint().setColor(Color.RED);&#125; 效果如下图所示。 5. PathShapePathShape 的含义是构造一个可根据路径绘制的 Shape。其构造函数如下：1public PathShape(Path path, float stdWidth, float stdHeight) path：表示所要画的路径。 stdWidth：表示标准宽度，即将整个 ShapeDrawable 的宽度分成多少份。Path 中的 moveTo(x, y)、lineTo(x2, y2) 这些函数中的数值在这里其实都是以每一份的位置来计算的。当 ShapeDrawable 动态变大、变小时，每一份都会变大变小，而根据这些份的数值画出来的 Path 图形就会动态缩放。 stdHight：表示标准高度，即将 ShapeDrawable 的高度分成多少份。 举例说明：123456789101112private void init() &#123; setLayerType(LAYER_TYPE_SOFTWARE, null); Path path = new Path(); path.moveTo(0, 0); path.lineTo(100, 0); path.lineTo(100, 100); path.lineTo(0, 100); path.close(); mDrawable = new ShapeDrawable(new PathShape(path, 100, 100)); mDrawable.setBounds(new Rect(0, 0, 250, 150)); mDrawable.getPaint().setColor(Color.RED);&#125; 效果如下图所示： 为了验证 PathShape 份的概念，将 ShapeDrawable 的高度和宽度都分成了100 份。现在把高度的份数改成 200，那么，同样的路径代码，画出来的效果应该是高度的一半。代码如下：123456789101112private void init() &#123; setLayerType(LAYER_TYPE_SOFTWARE, null); Path path = new Path(); path.moveTo(0, 0); path.lineTo(100, 0); path.lineTo(100, 100); path.lineTo(0, 100); path.close(); mDrawable = new ShapeDrawable(new PathShape(path, 100, 200)); mDrawable.setBounds(new Rect(0, 0, 250, 150)); mDrawable.getPaint().setColor(Color.RED);&#125; 效果如下图所示。 与 100 份的效果图对比，果然只占了一半。 6. 自定义 Shape各个 Shape 派生类只不过实现了 Shape 中的 draw 函数。现在自定义实现一个构造区域的 Shape，代码如下：1234567891011121314151617public class RegionShape extends Shape &#123; private Region mRegion; public RegionShape(Region region) &#123; assert(region != null); mRegion = region; &#125; @Override public void draw(Canvas canvas, Paint paint) &#123; RegionIterator iterator = new RegionIterator(mRegion); Rect rect = new Rect(); while (iterator.next(rect)) &#123; canvas.drawRect(rect, paint); &#125; &#125;&#125; 在 src/…/TestView.java 中使用 RegionShape：1234567891011121314151617181920212223242526272829303132333435363738public class TestView extends View &#123; private ShapeDrawable mDrawable; public TestView(Context context) &#123; super(context); init(); &#125; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public TestView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; setLayerType(LAYER_TYPE_SOFTWARE, null); Rect rect1 = new Rect(50, 0, 90, 150); Rect rect2 = new Rect(0, 50, 250, 100); Region region1 = new Region(rect1); Region region2 = new Region(rect2); region1.op(region2, Region.Op.XOR); mDrawable = new ShapeDrawable(new RegionShape(region1)); mDrawable.setBounds(new Rect(0, 0, 250, 150)); mDrawable.getPaint().setColor(Color.RED); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mDrawable.draw(canvas); &#125;&#125; 在 res/layout/act_main.xml 中使用 TestView：123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:background=&quot;#EEE&quot;&gt; &lt;com.xxt.xtest.TestView android:layout_width=&quot;250px&quot; android:layout_height=&quot;150px&quot; android:layout_margin=&quot;50dp&quot; android:background=&quot;#FFFFFF&quot;/&gt;&lt;/LinearLayout&gt; 效果如下图所示。 由于自定义 Shape 太过麻烦，一般不这么做。当我们需要使用 ShapeDrawable 无法完成的功能时，一般会通过自定义 Drawable 来实现。见 10.1.4 节。 10.1.3 常用函数1. setBounds()12setBounds(int left, int top, int right, int bottom)setBounds(Rect bounds) 它用来指定当前 ShapeDrawable 在当前控件中的显示位置。 2. getPaint()1）概述通过 ShapeDrawable.getPaint() 函数得到 ShapeDrawable 的 Paint 对象，并对其进行操作，效果就会立刻显示在 ShapeDrawable 上。这也意味着可以调用 Paint 中的所有函数；在自定义 Shape 时，可以调用 Canvas 的所有绘图方法。所以，ShapeDrawable 可以调用 Paint 和 Canvas 的所有方法，实现绘图的所有功能。 需要注意的地方：当 ShapeDrawable 的 Paint 调用 Shader 时，Shader 是从 ShapeDrawable 所在区域的左上角开始绘制的。 2）Paint.setShader()下面举一个例子来证明我们的观点：Shader 是从 ShapeDrawable 所在区域的左上角开始绘制的。123456789101112131415161718192021222324252627282930313233343536public class TestView extends View &#123; private ShapeDrawable mDrawable; public TestView(Context context) &#123; super(context); init(); &#125; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public TestView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; setLayerType(LAYER_TYPE_SOFTWARE, null); mDrawable = new ShapeDrawable(new RectShape()); mDrawable.setBounds(new Rect(100, 100, 500, 500)); BitmapFactory.Options options = new BitmapFactory.Options(); options.inSampleSize = 2; Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.head, options); BitmapShader bitmapShader = new BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); mDrawable.getPaint().setShader(bitmapShader); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mDrawable.draw(canvas); &#125;&#125; 从效果图中可以看出，头像是在 TestView 控件的 Rect(100, 100, 500, 500) 位置绘制的，并不是从 TestView 的左上角开始绘制的，也不是从屏幕左上角开始绘制的。 3. 其他函数123456789101112131415// 设置透明度setAlpha(int alpha)// 设置 ColorFilter，是 ShapeDrawable 自带的函数setColorFilter(ColorFilter colorFilter)// 设置默认高度。当 Drawable 以 setBackgroundDrawable 及 setImageDrawable // 方式使用时，会使用默认宽度和高度来计算当前 Drawable 的大小和位置。// 如果不设置，则默认的宽高都是 -1px。详情请参考 10.1.4 节。setIntrinsicHeight(int height)// 设置默认宽度setIntrinsicWidth(int width)// 设置边距setPadding(Rect padding) 4. 放大镜效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class TestView extends View &#123; private static final int RADIUS = 200; // 放大镜的半径 private static final int FACTOR = 3; // 放大倍数 private ShapeDrawable mDrawable; private Bitmap mBitmap; private final Matrix mMatrix = new Matrix(); public TestView(Context context) &#123; super(context); init(); &#125; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public TestView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; setLayerType(LAYER_TYPE_SOFTWARE, null); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; final int x = (int) event.getX(); final int y = (int) event.getY(); // 这个位置表示的是绘制 Shader 的起始位置 mMatrix.setTranslate(RADIUS - x * FACTOR, RADIUS - y * FACTOR); mDrawable.getPaint().getShader().setLocalMatrix(mMatrix); mDrawable.setBounds(x - RADIUS, y - RADIUS, x + RADIUS, y + RADIUS); invalidate(); return true; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mBitmap == null) &#123; Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.meinv); mBitmap = Bitmap.createScaledBitmap(bmp, getWidth(), getHeight(), false); Bitmap tempBmp = Bitmap.createScaledBitmap(mBitmap, mBitmap.getWidth() * FACTOR, mBitmap.getHeight() * FACTOR, true); BitmapShader shader = new BitmapShader(tempBmp, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); mDrawable = new ShapeDrawable(new OvalShape()); mDrawable.getPaint().setShader(shader); mDrawable.setBounds(0, 0, RADIUS * 2, RADIUS * 2); &#125; canvas.drawBitmap(mBitmap, 0, 0, null); mDrawable.draw(canvas); &#125;&#125; 说明： 1）onDraw() 函数部分之所以将初始化代码放在 onDraw() 函数中，是因为我们需要把图片缩放到控件大小。12Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.meinv);mBitmap = Bitmap.createScaledBitmap(bmp, getWidth(), getHeight(), false); Bitmap.createScaledBitmap() 函数根据源图像生成一个指定宽度和高度的 Bitmap，这里就是指根据 bmp 创建一幅与当前控件同宽同高的图像，也就是将源图像缩放到当前控件的大小。 而 getWidth()、getHeight() 函数只有在调用 onLayout() 函数以后，这两个函数才能取到值的。 接下来创建 ShapeDrawable。12mDrawable = new ShapeDrawable(new OvalShape());mDrawable.setBounds(0, 0, RADIUS * 2, RADIUS * 2); 这里创建一个椭圆形的 ShapeDrawable，而形成椭圆的矩形的宽高都是 RADIUS * 2，所以所形成的图形必然是一个圆形，且半径为 RADIUS。 最后是设置 BitmapShader 的过程。12345Bitmap tempBmp = Bitmap.createScaledBitmap(mBitmap, mBitmap.getWidth() * FACTOR, mBitmap.getHeight() * FACTOR, true);BitmapShader shader = new BitmapShader(tempBmp, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);mDrawable.getPaint().setShader(shader); 同样使用 Bitmap.createScaledBitmap() 函数创建一张放大 3 倍的图片。 2）onTouchEvent() 函数部分当手指有动作的时候，我们应当改变当前 ShapeDrawable 的显示位置。1mDrawable.setBounds(x - RADIUS, y - RADIUS, x + RADIUS, y + RADIUS); 即以当前手指位置为中心，画一个圆。 最关键的是 Shader 如何移动到我们要显示的位置。我们讲过，Shader 的开始显示位置在 ShapeDrawable 的左上角。所以，如果我们不移动 Shape，那么显示出来的永远是图片的左上角部分。那如何将 Shader 移动到图片的对应点呢？ 我们需要先找到当前手指位置放大 3 倍的图片上的对应点，然后以这个对应点为中心显示出半径为 RADIUS 的圆中的图形。 当前手指的位置是 (x, y)，那么放大 3 倍的图片上的对应点就是 (3x, 3y)。为了显示以放大 3 倍后的手指位置为中心的圆形区域，BitmapShader 需要向左和向上各移动多少呢？ 首先，Shader 是从 ShapeDrawable 的左上角开始平铺的。也就是说，在初始状态下，ShapeDrawable 区域左上角一直显示的是 BitmapShader 的左上角(0, 0) 位置。我们在这里需要把 BitmapShader 向左上移动一段距离，以使 BitmapShader 中原来的 (3x, 3y) 点在 ShapeDrawable 区域中心。 第一步：我们可以将整个 BitmapShader 向左上移动 3x, 3y 的距离。由于在移动时，向右和向下是正值，所以左上移动的距离是 (-3x, -3y)，而移动后的 BitmapShader 左上角显示的是 (3x, 3y) 处的图像。 第二步：我们需要将左上角点显示的 (3x, 3y) 处的图像显示在 ShapeDrawable 区域中心，所以需要将原本在左上角 (3x, 3y) 点在向右下移动一个半径的距离。所以总移动的距离为 (-3x+RADIUS, -3y + RADIUS)。 即：12mMatrix.setTranslate(RADIUS - x * FACTOR, RADIUS - y * FACTOR);mDrawable.getPaint().getShader().setLocalMatrix(mMatrix); 10.1.4 自定义 Drawable在 Drawable 的子类无法通过已有的函数完成指定的绘图功能时，一般会选择自定义 Drawable 来实现。本节将通过自定义 Drawable 来实现圆角功能。 1. 概述我们写一个类，继承自 Drawable，代码如下：123456789101112131415161718public class TestDrawable extends Drawable &#123; @Override public void draw(@NonNull Canvas canvas) &#123; &#125; @Override public void setAlpha(int alpha) &#123; &#125; @Override public void setColorFilter(@Nullable ColorFilter colorFilter) &#123; &#125; @Override public int getOpacity() &#123; return PixelFormat.TRANSLUCENT; &#125;&#125; 这 4 个函数时 Drawable 类里的虚函数，是必须实现的。 draw() 函数是我们将会用到的，与 View 类似，传入的参数是一个 Canvas 对象，我们只需要调用 Canvas 的一些地方，效果就会直接显示在 Drawable 上。 setAlpha() 和 setColorFilter() 函数是非常容易实现的。当外层调用 TestDrawable 的这两个函数时，我们只需将对应的参数传给 TestDrawable 的 Paint 即可。 getOpacity()：当外部需要知道我们自定义的 TestDrawable 的显示模式时会调用这个函数。它有 4 个取值：PixelFormat.UNKNOWN，TRANSLUCENT，TRANSPARENT，OPAQUE。其中，PixelFormat.TRANSLUCENT 表示当前 TestDrawable 的绘图是具有 Alpha 通道的，即使用 TestDrawable 后，其底部的图像仍有可能看到；PixelFormat.TRANSPARENT 表示当前 TestDrawable 是完全透明的，其中什么都没画，如果使用 TestDrawable，则将完全显示其底部图像；PixelFormat.OPAQUE 表示当前的 TestDrawable 是完全没有 Alpha 通道的，使用 TestDrawable 后，其底部的图像将被完全覆盖，而只显示 TestDrawable 本身的图像；PixelFormat.UNKNOWN 表示未知。一般而言，如果我们不知道该如何返回，则直接返回 PixelFormat.TRANSLUCENT 是最靠谱的做法。 2. 实现圆角 Drawable123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class TestDrawable extends Drawable &#123; private Paint mPaint; private Bitmap mBitmap; private BitmapShader mBitmapShader; private RectF mBound; public TestDrawable(Bitmap bitmap) &#123; mBitmap = bitmap; mPaint = new Paint(); mPaint.setAntiAlias(true); &#125; @Override public void draw(@NonNull Canvas canvas) &#123; canvas.drawRoundRect(mBound, 20, 20, mPaint); &#125; @Override public void setAlpha(int alpha) &#123; mPaint.setAlpha(alpha); &#125; @Override public void setColorFilter(@Nullable ColorFilter colorFilter) &#123; mPaint.setColorFilter(colorFilter); &#125; @Override public int getOpacity() &#123; // 是否具有透明度是由传入的 Bitmap 所决定的。 return PixelFormat.TRANSLUCENT; &#125; /** * 根据边界创建一个与 Drawable 相同大小的 Bitmap 作为 Drawable 的 Shader */ @Override public void setBounds(int left, int top, int right, int bottom) &#123; super.setBounds(left, top, right, bottom); mBitmapShader = new BitmapShader( Bitmap.createScaledBitmap(mBitmap, right - left, bottom - top, true), Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); mPaint.setShader(mBitmapShader); mBound = new RectF(left, top, right, bottom); &#125; /** * 设置 TestDrawable 的默认宽度 * @return int */ @Override public int getIntrinsicWidth() &#123; return mBitmap.getWidth(); &#125; /** * 设置 TestDrawable 的默认高度 * @return int */ @Override public int getIntrinsicHeight() &#123; return mBitmap.getHeight(); &#125;&#125; 3. Drawable 的使用方法一般有两种使用方法：一种是通过 ImageView 的 setImageDrawable(drawable) 函数将其设置为 ImageView 的源图片；另一种是通过 View 的 setBackgroundDrawable(drawable) 函数将其设置为背景。 1）setImageDrawable(drawable) 函数先在布局中定义一个 ImageView 标签1234567&lt;ImageView android:id=&quot;@+id/img&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;50dp&quot; android:layout_margin=&quot;10dp&quot; android:background=&quot;#FFFFFF&quot; android:scaleType=&quot;center&quot;/&gt; 在代码中使用12345678910111213public class MainActivity extends AppCompatActivity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.head); ImageView imageView = findViewById(R.id.img); TestDrawable drawable = new TestDrawable(bitmap); imageView.setImageDrawable(drawable); &#125;&#125; 效果如下图所示。 可以看到，我们虽然在 TestDrawable 的 setBounds() 函数中将 Bitmap 缩放为整个边界大小，但是并没有覆盖整个 Bitmap，这是为什么呢？ 在这里，我们使用 setImageDrawable(drawable) 函数来设置数据源，而源图片的显示大小是与 ImageView 的 scaleType 相关的。因为这里设置 scaleType=”center”，所以 ImageView 必然会居中缩放图片，然后将图片的显示位置通过 setBounds() 函数设置给 TestDrawable。下图展示了当前 Drawable 在不同的 scaleType 模式下的效果图。 布局如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:background=&quot;#EEE&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;ImageView android:id=&quot;@+id/img&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;50dp&quot; android:layout_margin=&quot;10dp&quot; android:background=&quot;#FFFFFF&quot; android:scaleType=&quot;fitStart&quot;/&gt; &lt;ImageView android:id=&quot;@+id/img2&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;50dp&quot; android:layout_margin=&quot;10dp&quot; android:background=&quot;#FFFFFF&quot; android:scaleType=&quot;fitCenter&quot;/&gt; &lt;ImageView android:id=&quot;@+id/img3&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;50dp&quot; android:layout_margin=&quot;10dp&quot; android:background=&quot;#FFFFFF&quot; android:scaleType=&quot;fitEnd&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;ImageView android:id=&quot;@+id/img4&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;50dp&quot; android:layout_margin=&quot;10dp&quot; android:background=&quot;#FFFFFF&quot; android:scaleType=&quot;centerInside&quot;/&gt; &lt;ImageView android:id=&quot;@+id/img5&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;50dp&quot; android:layout_margin=&quot;10dp&quot; android:background=&quot;#FFFFFF&quot; android:scaleType=&quot;centerCrop&quot;/&gt; &lt;ImageView android:id=&quot;@+id/img6&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;50dp&quot; android:layout_margin=&quot;10dp&quot; android:background=&quot;#FFFFFF&quot; android:scaleType=&quot;center&quot;/&gt; &lt;/LinearLayout&gt; &lt;ImageView android:id=&quot;@+id/img7&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;50dp&quot; android:layout_margin=&quot;10dp&quot; android:background=&quot;#FFFFFF&quot; android:scaleType=&quot;fitXY&quot;/&gt;&lt;/LinearLayout&gt; 2）setBackgroundDrawable(drawable) 函数布局：1234567&lt;TextView android:id=&quot;@+id/tv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;10dp&quot; android:text=&quot;欢迎光临先先生的 blog&quot; android:textColor=&quot;#FF0000&quot;/&gt; 代码：1234Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.head);TestDrawable drawable = new TestDrawable(bitmap);TextView tv = findViewById(R.id.tv);tv.setBackgroundDrawable(drawable); 效果： 从效果图中可以看出，宽度使用的是 TextView 的宽度，而高度则使用的是 TestDrawable 的默认高度。之所以会出现这样的效果，是因为在使用 setBackgroundDrawable() 函数设置自定义 Drawable 时，自定义 Drawable 的宽度和高度计算是将 View 的宽、高和自定义 Drawable 的宽、高进行对比，哪个值大就用哪个值作为控件的宽、高的。而这个最终值就会通过 setBounds() 函数传递给自定义 Drawable。 4. 自定义 Drawable 与自定义 View 的区别自定义 Drawable 的使用场景很明确，要么使用在可以设置 Drawable 的函数中（比如 setImageDrawable() 等），要么替代 Bitmap 用于 View 中（比如放大镜效果）。 而自定义 View 的功能十分强大，自定义 Drawable 和 Bitmap 无法完成的功能可以使用自定义 View 来完成。 10.1.5 Drawable 与 Bitmap 的对比1. 定义对比Bitmap 称作位图，一般位图的文件格式扩展名为 .bmp，当然编码器也有很多，如 RGB565、RGB8888。作为一种逐像素的显示对象，其执行效率高；但存储效率低。 Drawable 作为 Android 下通用的图形对象，它可以装载常用格式的图像，比如 GIF、PNG、JPG 和 BMP，还提供了一些高级的可视化对象，比如渐变、图形等。 也就是说，Bitmap 是 Drawable，而 Drawable 不一定是 Bitmap。 2. 指标对比 对比项 显示清晰度 占用内存 支持缩放 支持色相色差调整 支持旋转 支持透明色 绘制速度 支持像素操作 Bitmap 相同 大 是 是 是 是 慢 是 Drawable 相同 小 是 否 是 是 快 否 3. 绘图便利性对比Drawable 有很多派生类，通过这些派生类可以很容易地生成渐变、层叠等效果。单从这一方面而言，Drawable 比 Bitmap 有优势。 但如果仅仅用作空白画布来绘图，那么 Drawable 构造和使用起来则不如 Bitmap 方便。 4. 使用简易性对比Drawable 子类是自带画笔，调用 Paint 的函数很方便。但使用 Canvas 的函数并不方便，所以 Drawable 的子类一般只用来完成它固有的功能。如果想要使用 Drawable 绘图，则建议自定义 Drawable。 而如果想在 Bitmap 上作画，则一般使用类似如下的代码：1234Canvas canvas = new Canvas(bitmap);Paint paint = new Paint();paint.setColor(Color.RED);canvas.drawCircle(0, 0, 100, paint); 从代码中可以看到，如果 Bitmap 想要作为画布，则需要通过 Canvas canvas = new Canvas(bitmap); 来创建 Canvas 对象，而通过生成的 Canvas 对象，所绘制的内容是直接画在 Bitmap 上的。而且画笔也是可以随意定义的。 所以，就使用简易性而言，Bitmap 确实要比 Drawable 易用。 5. 使用方式对比Bitmap 主要靠在 View 中通过 Canvas.drawBitmap() 函数画出来；而 Drawable 不仅能在 View 中通过 Drawable.draw(Canvas canvas) 函数画出来，也可以通过 setImageBackground()、setBackgroundDrawable() 等设置 Drawable 资源的函数来设置。 总结： Bitmap 在占用内存和绘制速度上不如 Drawable 有优势。 Bitmap 绘图方便。 Drawable 有一些子类，可以方便地完成一些绘图功能。 那么，Drawable、Bitmap、自定义 View 在哪些情况下使用呢？ Bitmap 只在一种情况下使用，即在 View 中需要自己生成图像时，才会使用 Bitmap 绘图。绘图后的结果保存在这个 Bitmap 中，供自己定义 View 使用。比如根据源 Bitmap 生成它的倒影，在使用 Xfermode 来融合倒转的图片原图与渐变的图片时，就需要根据图片大小生成一张同样大小的渐变图片，这时必须使用 Bitmap。 当使用 Drawable 的子类完成一些固有功能时，优先选用 Drawable。 当需要使用 setImageDrawable()、setBackgroundDrawable() 等可以直接设置 Drawable 资源的函数时，只能选用 Drawable。 在自定义 View 中指定位置显示图形功能时，既可以使用 Drawable，也可以使用 Bitmap。 除 Drawable 和 Bitmap 以外的地方，都可以使用自定义 View 来实现。]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[09.4 精通自定义 View 之 Canvas 与图层——恢复画布]]></title>
    <url>%2F2019%2F07%2F09%2FCustom%20View%2F09.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E6%81%A2%E5%A4%8D%E7%94%BB%E5%B8%83%2F</url>
    <content type="text"><![CDATA[恢复画布有两个函数：restore() 和 restoreToCount(int count)。其中，restore() 函数的作用就是把回退栈中的最上层画布状态出栈，恢复画布状态。在 1.5.2 节中已经详细地说明了 restore() 函数的用法，这里就不再赘述了。 9.4.1 restoreToCount(int count)在 save()、saveLayer()、saveLayerAlpha() 函数保存画布后，都会返回一个 ID 值，这个 ID 值表示当前保存的画布信息的栈层索引（从 0 开始）。比如，保存在第三层，则返回 2。 而 restoreToCount() 函数的声明如下：1public void restoreToCount(int saveCount); 它表示一直退栈，一直把指定索引的画布信息退出来，之后的栈最上层的画布信息将作为最新的画布。比如，我们开始的栈已经有两层，然后调用如下代码：123int id = canvas.saveLayer(0, 0, etWidth(), getHeight(), mPaint, Canvas.ALL_SAVE_FLAG);canvas.restoreToCount(id); 调用 canvas.saveLayer() 函数后，新保存的画布放在了第三层，返回的 ID 的值是对应的索引，即 2。而 canvas.restoreToCount(id); 则表示一直退栈，直到把索引为 2 的栈层给退出去，留下来的栈顶层信息将作为最新的画布。 下面我们举个例子来看下。代码如下：1234567891011121314151617181920212223242526272829303132333435public class TestView extends View &#123; private Paint mPaint; private String TAG = &quot;XIAN&quot;; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int id1 = canvas.save(); canvas.clipRect(0, 0, 800, 800); canvas.drawColor(Color.RED); Log.d(TAG, &quot;count:&quot; + canvas.getSaveCount() + &quot; id1:&quot; + id1); int id2 = canvas.saveLayer(0, 0, getWidth(), getHeight(), mPaint, Canvas.ALL_SAVE_FLAG); canvas.clipRect(100, 100, 700, 700); canvas.drawColor(Color.GREEN); Log.d(TAG, &quot;count:&quot; + canvas.getSaveCount() + &quot; id2:&quot; + id2); int id3 = canvas.saveLayerAlpha(0, 0, getWidth(), getHeight(), 0xF0, Canvas.ALL_SAVE_FLAG); canvas.clipRect(200, 200, 600, 600); canvas.drawColor(Color.YELLOW); Log.d(TAG, &quot;count:&quot; + canvas.getSaveCount() + &quot; id3:&quot; + id3); int id4 = canvas.save(); canvas.clipRect(300, 300, 500, 500); canvas.drawColor(Color.BLUE); Log.d(TAG, &quot;count:&quot; + canvas.getSaveCount() + &quot; id4:&quot; + id4); &#125;&#125; 在 onDraw() 函数中，连续对 Canvas 进行裁剪，并且在裁剪后在当前画布上涂一层不同的颜色，然后把当前栈的层数和最高层的索引打印出来。 在整段代码的最后添加 canvas.restoreToCount(id3);，然后把整块画布涂成灰色。12345678910@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); ... canvas.restoreToCount(id3); canvas.drawColor(Color.GRAY); Log.d(TAG, &quot;count:&quot; + canvas.getSaveCount());&#125; 从代码中可以看出，在调用 canvas.restoreToCount(id3) 函数后，将恢复到生成 id3 之前的画布状态，即是 (100, 100, 700, 700)。 9.4.2 restore() 和 restoreToCount(int count) 的关系这两个函数针对的是同一个栈，所以完全可以通用。不同的是，restore() 函数默认将栈顶内容退出还原画布；而 restoreToCount(int count) 函数则是一直退栈，直到把指定索引的画布信息退出来，之后的栈最上层的画布信息将作为最新的画布。 结论： restore() 的含义是把回退栈中的最上层画布状态出栈，恢复画布状态。restoreToCount(int count) 的含义是一直退栈，直到把指定索引的画布信息退出来，将此之前的所有动作都恢复。 无论哪种 save 函数、哪个 FLAG，保存画布时使用的都是同一个栈。 restore() 与 restoreToCount(int count) 针对的都是同一个栈，所以完全可以通用。]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[09.3 精通自定义 View 之 Canvas 与图层——Flag 的具体含义]]></title>
    <url>%2F2019%2F07%2F09%2FCustom%20View%2F09.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94Flag%20%E7%9A%84%E5%85%B7%E4%BD%93%E5%90%AB%E4%B9%89%2F</url>
    <content type="text"><![CDATA[在 Canvas 中有如下几个 save 系列函数：123456public int save()public int save(int saveFlags)public int saveLayer(RectF bounds, Paint paint, int saveFlags)public int saveLayer(float left, float top, float right, float bottom,Paint paint, int saveFlags)public int saveLayerAlpha(RectF bounds, int alpha, int saveFlags)public int saveLayerAlpha(float left, float top, float right, float bottom,int alpha, int saveFlags) 可以看到，flag 参数在诸多函数中都有使用，这里我们先关注 save 的两个构造函数和 saveLayer 的两个构造函数。我们知道，二者的不同之处在于，saveLayer() 函数会新建一块画布，而 save() 函数则不会新建画布。它们都具有 Flag（标识），这些 Flag（标识）的含义和适用范围如下表所示。 Flag 含义 适用范围 ALL_SAVE_FLAG 保存所有的标识 save()、saveLayer() MATRIX_SAVE_FLAG 仅保存 Canvas 的 matrix 数组 save()、saveLayer() CLIP_SAVE_FLAG 仅保存 Canvas 的当前大小 save()、saveLayer() HAS_ALPHA_LAYER_SAVE_FLAG 标识新建的 bmp 具有透明度，在与上层画布结合时，透明位置显示上图图像,与 FULL_COLOR_LAYER_SAVE_FLAG 冲突，若同时指定，则以 HAS_ALPHA_LAYER_SAVE_FLAG 为主 saveLayer() FULL_COLOR_LAYER_SAVE_FLAG 标识新建的 bmp 颜色完全独立，在与上层画布结合时，先清空上层画布再覆盖上去 saveLayer() CLIP_TO_LAYER_SAVE_FLAG 在保存图层前先把当前画布根据 bounds 裁剪，与 CLIP_SAVE_FLAG 冲突，若同时指定，则以 CLIP_SAVE_FLAG为主 saveLayer() 从上面的表格中可以看到，ALL_SAVE_FLAG、MATRIX_SAVE_FLAG、CLIP_SAVE_FLAG 是 save()、saveLayer() 函数共用的。而另外三个 Flag 是 saveLayer() 函数专用的。 我们逐个解析下它们的不同之处。在讲解之前，先考虑一下：如果让我们保存一块画布的状态，以便恢复，则需要保存哪些内容呢？ 第一个是位置信息，第二个是大小信息，好像除此之外也没什么了。位置信息对应的是 MATRIX_SAVE_FLAG，大小信息对应的是 CLIP_SAVE_FLAG，这是 save() 和 saveLayer() 函数所共用的标识。而 saveLayer() 函数专用的三个标识用于指定 saveLayer() 函数新建的画布具有哪种特性，而不是保存画布的范畴。 注意：以上内容已过时，这些标志已在 API 28 中删除。带有 Flag 的构造函数在 API 26 被标为已过时，不建议使用。且新的不带 Flag 参数的构造函数默认指定标识为 ALL_SAVE_FLAG。详情请参见此处。]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[09.2 精通自定义 View 之 Canvas 与图层——图层与画布]]></title>
    <url>%2F2019%2F07%2F09%2FCustom%20View%2F09.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E5%9B%BE%E5%B1%82%E4%B8%8E%E7%94%BB%E5%B8%83%2F</url>
    <content type="text"><![CDATA[前面讲过 Canvas 的 save() 和 restore() 函数，除这两个函数以外，还有其他一些函数来保存和恢复画布状态。 9.2.1 saveLayer() 函数saveLayer 有两个构造函数，如下：123456/** * 保存指定矩形区域的canvas内容 */public int saveLayer(RectF bounds, Paint paint, int saveFlags)public int saveLayer(float left, float top, float right, float bottom, Paint paint, int saveFlags) 参数： RectF bounds：要保存的区域所对应的矩形对象。 int saveFlags：取值有 ALL_SAVE_FLAG、MATRIX_SAVE_FLAG、CLIP_SAVE_FLAG、HAS_ALPHA_LAYER_SAVE_FLAG、FULL_COLOR_LAYER_SAVE_FLAG、 和CLIP_TO_LAYER_SAVE_FLAG，其中 ALL_SAVE_FLAG 表示保存全部内容，这些标识的具体意义我们后面会具体讲。 第二个构造函数实际与第一个是一样的，只不过它是根据 4 个点来构造一个矩形。下面以 Xfermode 为例，来看看 saveLayer() 函数都做了什么。123456789101112131415161718192021222324252627282930313233343536373839404142434445public class TestView extends View &#123; private Paint mPaint; private Bitmap dstBmp; private Bitmap srcBmp; private int width = 400; private int height = 400; private PorterDuffXfermode mMode; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); dstBmp = makeBitmap(width, height, 0xFFFFCC44, &quot;oval&quot;); srcBmp = makeBitmap(width, height, 0xFF66AAFF, &quot;rect&quot;); mMode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN); &#125; private Bitmap makeBitmap(int w, int h, int color, String type) &#123; Bitmap bmp = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bmp); Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG); paint.setColor(color); if (&quot;oval&quot;.equals(type)) &#123; canvas.drawOval(new RectF(0, 0, w, h), paint); &#125; else &#123; canvas.drawRect(0, 0, w, h, paint); &#125; return bmp; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.GREEN); int layerId = canvas.saveLayer(0, 0, width * 2, height * 2, null, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(dstBmp, 0, 0, mPaint); mPaint.setXfermode(mMode); canvas.drawBitmap(srcBmp, width / 2f, height / 2f, mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125;&#125; 这段代码我们应该很熟悉，这是在讲解 setXfermode() 函数时的示例代码，但在调用 saveLayer() 函数前把整个屏幕画成了绿色，效果图如下。 那么问题来了，如果我们把 saveLayer() 函数去掉，则会怎样？代码如下：123456789@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.GREEN); canvas.drawBitmap(dstBmp, 0, 0, mPaint); mPaint.setXfermode(mMode); canvas.drawBitmap(srcBmp, width / 2f, height / 2f, mPaint); mPaint.setXfermode(null);&#125; 效果如下图所示。 可以看到，效果居然不一样。先来回顾下 Mode.SRC_IN 模式的效果：在处理源图像时，以显示源图像为主，在相交时利用目标图像的透明度来改变源图像的透明度和饱和度；当目标图像透明度为 0 时，源图像就完全不显示。 再回过来看结果，第一个结果是对的，因为除与圆相交以外的区域透明度都是 0，而第二个结果怎么变成了这样，源图像为什么全部都显示出来了？ 1. 调用 saveLayer() 函数时的绘图流程在调用 saveLayer() 函数时，会生成一个全新的画布（Bitmap），这块画布的大小就是我们指定的所要保存区域的大小。新生成的画布是全透明的，在调用 saveLayer() 函数后所有的绘图操作都是在这个画布上进行的。 我们讲过，在利用 Xfermode 画源图像时，会把之前画布上所有的内容都做为目标图像，而在调用 saveLayer() 函数新生成的画布上，只有 dstBmp 对应的圆形。所以，除与圆形相交之外的位置都是空白像素。 对于 Xfermode 而言，在绘图完成之后，会把调用 saveLayer() 函数所生成的透明画布覆盖在原来的画布上面，以形成最终的显示结果。 此时的 Xfermode 的合成过程如下图所示。 中间的透明画布就是调用 saveLayer() 函数自动生成的，最上方的透明图层是调用 drawBitmap() 函数生成的。我们知道，每次调用 canvas.drawXXX 系列函数，都会生成一个透明层来专门绘制这个图形，而每次生成的图层都会叠加到最近的画布上。因为我们在这里对源图像应用了 Xfermode 算法，所以在叠加到就近的调用 saveLayer() 函数生成的画布上时，会进行计算。在新建的画布上绘制完成以后，整体覆盖在原始画布上显示出来。 正是因为在使用 Xfermode 计算时，目标图像是绘制在新建的透明画布上的，所以除圆形以外的区域全部是透明像素，最终的显示结果是正确的。 2. 没有 saveLayer() 函数时的绘图流程在第二个示例中，唯一不同的就是把 saveLayer() 函数去掉了。 在去掉 saveLayer() 函数后，就不会新建画布了。当然，所有的绘图操作都会在原始画布上进行。 由于先把整块画布染成了绿色，再画上一个圆形，所有在应用 Xfermode 来画源图像的时候，在目标画布上是没有透明像素的。这也就不难解释结果为什么是这样的。 此时的 Xfermode 合成过程如下图所示。 由于没有调用 saveLayer() 函数，所以圆形是直接画在原始画布上的，而当矩形与其相交时，就是直接与原始画布上的所有图像做计算的。 结论：调用 saveLayer() 函数会创建一个全新的透明画布，大小与指定保存的区域大小一致，其后的绘图操作都放在这块画布上进行。在绘制结束后，会直接盖在原始画布上显示。 9.2.2 画布与图层上面讲到了画布（Bitmap）、图层（Layer）和 Canvas 的概念，下面具体讲解下它们之间的关系。 图层（Layer）：每一次调用 canvas.drawXXX 系列函数时，都会生成一个透明图层来专门来绘制这个图形，比如前面在绘制矩形时的透明图层就是这个概念。 画布（Bitmap）：每块画布都是一个 Bitmap，所有的图像都是画在 Bitmap上的。我们知道，每次调用 canvas.drawXXX 函数时，都会生成一个专用的透明图层来绘制这个图形，绘制完成以后，就覆盖在画布上。所以，如果我们连续调用 5 个 draw 函数，就会生成 5 个透明图层，画完之后依次覆盖在画布上显示。画布有两种：第一种是 View 的原始画布，是通过 onDraw(Canvas canvas) 函数传入的，参数中的 canvas 就对应的是 View 的原始画布，控件的背景就是画在这块画布上的；另一种是人造画布，通过 saveLayer()、new Canvas(bitmap) 等函数来人为地新建一块画布。尤其是saveLayer() 函数，一旦调用 saveLayer() 函数新建一块画布，以后的所有 draw 函数所画的图像都是画在这块画布上的，只有在调用 restore()、resoreToCount() 函数以后，才会返回到原始画布上进行绘制。 Canvas：Canvas 是画布的表现形式，我们所要绘制的任何东西都是利用 Canvas 来实现的。在代码中，Canvas 的生成方式只有一种——new Canvas(bitmap)，即只能通过 Bitmap 生成，无论是原始画布还是人造画布，所有的画布最后都是通过 Canvas 画到 Bitmap 上的。可以把 Canvas 理解成绘图工具，利用它所封装的绘图函数来绘图，而所要绘制的内容最后是画在 Bitmap 上的。所以，如果我们利用 Canvas.clipXXX 系列函数将画布进行裁剪，其实就是把它对应的 Bitmap 进行裁剪，与之对应的结果就是再利用 Canvas 绘图的区域会减小。 9.2.3 saveLayer() 和 saveLayerAlpha() 函数的用法1. saveLayer() 函数的用法123public int saveLayer(RectF bounds, Paint paint, int saveFlags)public int saveLayer(float left, float top, float right, float bottom, Paint paint, int saveFlags) 参数： RectF bounds：新建画布的尺寸。 Paint paint：画笔实例。 int saveFlags：新建画布的标识（详见 9.3 节）。 saveLayer() 函数会新建一块画布（Bitmap），后续的所有操作都是在这块画布上进行的。下面我们来看一下 saveLayer() 函数使用中的注意事项。 1）saveLayer() 函数后的所有动作都只对新建画布有小。123456789101112131415161718192021222324public class TestView extends View &#123; private Paint mPaint; private Bitmap mBitmap; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.RED); mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.dog); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawBitmap(mBitmap, 0, 0, mPaint); int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), mPaint, Canvas.ALL_SAVE_FLAG); canvas.skew(1.732f, 0); canvas.drawRect(0, 0, 100, 100, mPaint); canvas.restoreToCount(layerId); &#125;&#125; 在 onDraw() 函数中，我们先在 View 的原始画布上画上了小狗的图像，然后利用 saveLayer() 函数新建了一个图层，然后利用 canvas.skew() 函数将新建的图层水平斜切 45°，所以之后画的矩形(0,0,100,100) 就是斜切的。 而正是由于在新建画布后的各种操作都是针对新建画布进行的，所以不会对以前的画布产生影响。从效果图中也可以明显看出，将画布水平斜切 45° 也只影响了 saveLayer() 函数的新建画布，并没有对之前的原始画布产生影响。 2）通过 Rect 指定的矩形大小就是新建的画布大小。在 saveLayer() 函数的参数中，可以通过指定 Rect 对象或者指定 4 个点来指定一个矩形，这个矩形的大小就是新建画布的大小。我们举例来看一下：12345678910@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawBitmap(mBitmap, 0, 0, mPaint); int layerId = canvas.saveLayer(0, 0, 200, 200, mPaint, Canvas.ALL_SAVE_FLAG); canvas.drawColor(Color.GRAY); canvas.restoreToCount(layerId);&#125; 在绘图时，我们先把小狗图片绘制在原始画布上的，然后新建一个大小为 (0,0,200,200) 的透明画布，并将画布填充为灰色。由于画布大小只有 (0,0,200,200)，所以从效果图中可以看出，也只有这一小部分区域被填充为灰色。 有些读者可能会想，为了避免画布太小而出现问题，每次都新建一块屏幕大小的画布多好。这样虽然是不会出现问题，但屏幕大小的画布需要多少存储空间呢？按一个像素需要 8bit 存储空间算，分辨率为 1024 像素 x 768 像素的机器，所占用的存储空间就是1024 768 8=6.2MB。所以我们在使用 saveLayer() 函数新建画布时，一定要选择适当的大小，否则你的 APP 很可能 OOM。 注意：在前面示例中都是直接新建全屏画布的，这只是为了方便展示，在现实使用中一定要创建适当的画布大小。 2. saveLayerAlpha() 函数的用法123public int saveLayerAlpha(RectF bounds, int alpha, int saveFlags)public int saveLayerAlpha(float left, float top, float right, float bottom, int alpha, int saveFlags) 相比 saveLayer() 函数，多了一个 alpha 参数，用于指定新建画布的透明度，取值范围为 0~255，可以用十六进制的 0xAA 表示，取 0 时表示全透明。 这个函数的意义也是在调用的时候会新建一块画布，以后的各种绘图操作都作用在这个画布上，但这个画布是有透明度的，透明度就是通过 alpha 参数指定的。 将上述示例中的 saveLayer() 函数改为 saveLayerAlpha() 函数来重新作图。12345678910@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawBitmap(mBitmap, 0, 0, mPaint); int layerId = canvas.saveLayerAlpha(0, 0, 200, 200, 100, Canvas.ALL_SAVE_FLAG); canvas.drawColor(Color.WHITE); canvas.restoreToCount(layerId);&#125; 在调用 saveLayerAlpha() 函数时，将新建画布的透明度设置为 100%，然后将画布同样填充为白色。从效果图中可以看出，在新建图像与上层画布合成以后，是具有透明度的。]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[09.1 精通自定义 View 之 Canvas 与图层——获取 Canvas 对象的方法]]></title>
    <url>%2F2019%2F07%2F09%2FCustom%20View%2F09.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96%20Canvas%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[9.1.1 方法一：重写 onDraw()、dispatchDraw() 函数一般在自定义 View 时，我们都会重写 onDraw()、dispatchDraw() 函数。先来看一下 onDraw()、dispatchDraw() 函数的定义，如下：1234567protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas);&#125; protected void dispatchDraw(Canvas canvas) &#123; super.dispatchDraw(canvas);&#125; 可以看到，onDraw()、dispatchDraw() 函数在传入的参数中都有一个 Canvas 对象。这个 Canvas 对象是 View 中的 Canvas 对象，利用这个 Canvas 对象绘图，效果会直接反映在 View 中。 onDraw()、dispatchDraw() 函数的区别如下： onDraw() 函数用于绘制视图自身。 dispatchDraw() 函数用于绘制子视图。 无论是 View 还是 ViewGroup 对这连个函数的调用顺序都是 onDraw() —&gt; dispatchDraw()。 但在 ViewGroup 中，当它有背景的时候就会调用 onDraw() 函数，否则就会跳过 onDraw() 函数，直接调用 dispatchDraw() 函数。所以，如果要在 ViewGroup 中绘图，往往会重写 dispatchDraw() 函数。 在 View 中，onDraw() 和 dispatchDraw() 函数都会被调用的，所以我们无论把绘图代码放在 onDraw() 函数或者 dispatchDraw() 函数中都是可以得到效果的。但是，由于 dispatchDraw() 函数用于绘制子控件，所以，原则来上讲，在绘制 View 控件时，我们会重写 onDraw() 函数。 总结：在绘制 View 控件时，需要重写 onDraw() 函数；在绘制 ViewGroup 时，需要重写 dispatchDraw() 函数。 9.1.2 方法二：使用 Bitmap 创建1. 构建方法使用：1Canvas c = new Canvas(bitmap); 或12Canvas c = new Canvas();c.setBitmap(bitmap); 其中，bitmap 可以从图片中加载，也可以自行创建。1234// 方法一：新建一个空白 bitmapBitmap bmp = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);// 方法二：从图片中加载Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.img, null); 除这两种方法以外，还有其他几种方法（比如构造一个具有 Matrix 的图像副本），这里不再涉及，大家可以去查看 Bitmap 的构造函数。 2. 在 onDraw() 函数中使用需要注意的是，如果我们用 Bitmap 构造了一个 Canvas，那这个 Canvas 上绘制的图像也都会保存在这个 Bitmap 上，而不是画在 View 上。如果想画在 View 上就必须使用 OnDraw(Canvas canvas) 函数中传入的 Canvas 画一遍 Bitmap。 下面举个例子：123456789101112131415161718192021222324public class TestView extends View &#123; private Paint mPaint; private Bitmap mBitmap; private Canvas mBitmapCanvas; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setTextSize(50); mPaint.setColor(Color.RED); mBitmap = Bitmap.createBitmap(500, 500, Bitmap.Config.ARGB_8888); mBitmapCanvas = new Canvas(mBitmap); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mBitmapCanvas.drawText(&quot;先小涛&quot;, 100, 100, mPaint); // canvas.drawBitmap(mBitmap, 0, 0, mPaint); &#125;&#125; 运行上述代码后会发现，结果是一片空白，我们写的字去哪儿了？在 onDraw() 函数中，我们只是将文字画在了 mBitmapCanvas 上，也就是我们新建 mBitmap 图片上，而最终没有将图片画在画布上。因为文字被写在了图片上，而画布上却没有任何内容，所以结果是一片空白。如果将注释掉的最后一句打开，即可将图片画在画布上，在视图上就会显示文字了，如下图所示。 9.1.3 方法三：调动 SurfaceHolder.lockCanvas() 函数在使用 SurfaceView 时，当调用 SurfaceHolder.lockCanvas() 函数时，也会创建 Canvas 对象，有关 SurfaceView 的知识可以参考第 10 章。]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[08.4 精通自定义 View 之 混合模式——目标图像模式与其他模式]]></title>
    <url>%2F2019%2F07%2F08%2FCustom%20View%2F08.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%9B%AE%E6%A0%87%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[8.4.1 目标图像模式我们知道，在与 SRC 相关的模式中，在处理相交区域时，优先以源图像显示为主；而在与 DST 相关的模式中，在处理相交区域时，优先以目标图像显示为主。这部分所涉及的模式有 Mode.DST、Mode.DST_IN、Mode.DST_OUT、Mode.DST_OVER、Mode.DST_ATOP。 1. Mode.DST计算公式：[Da, Dc]。从公式中也可以看出，在处理源图像所在区域的相交问题时，正好与 Mode.SRC 模式相反，全部以目标图像显示。示例图像如下图所示。 2. Mode.DST_IN1）概述计算公式为：[Da Sa,Dc Sa]。 将这个公式与 Mode.SRC_IN 的公式（[Sa Da, Sc Da]）对比一下，发现正好与 SRC_IN 相反，Mode.DST_IN 是在相交时利用源图像的透明度来改变目标图像的透明度和饱和度。当源图像透明度为 0时，目标图像就完全不显示。 示例图像为： 利用 SRC 模式能实现的效果，只需要将源图像与目标图像对调，利用对应的 DST 模式就可以实现同样的效果。比如，在 8.3 节中所实现的圆角效果，它对应的 DST 模式的代码如下：12345678910111213141516171819202122232425262728public class TestView extends View &#123; private Paint mPaint; private Bitmap bmpDST, bmpSRC; private PorterDuffXfermode mMode; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); bmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.dog,null); bmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.dog_shade,null); mMode = new PorterDuffXfermode(PorterDuff.Mode.DST_IN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(bmpDST,0,0,mPaint); mPaint.setXfermode(mMode); canvas.drawBitmap(bmpSRC,0,0,mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125;&#125; 很明显，这里只改了两部分代码：首先，在解析图片时，将要显示的小狗图像作为目标图像，将控制哪部分显示的遮罩图像作为源图像；其次，将合成模式改为 Mode.DST_IN。其效果与 8.3 节中圆角效果一致。 2）示例：区域波纹 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132public class TestView extends View &#123; private Paint mPaint; private Canvas mTempCanvas; // 用来生成波纹 private Path mPath; // 波纹图像为目标图像，要显示的内容 private Bitmap dstBmp; // 文字图像为源图像 private Bitmap srcBmp; // 波纹动画移动的距离 private int mDx; // 波纹下降动画的位移 private int mDy; // 一个波长 private int mItemWaveLength = 1000; private PorterDuffXfermode mMode; private String mText; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mPaint.setColor(Color.RED); mPaint.setStyle(Paint.Style.FILL_AND_STROKE); mMode = new PorterDuffXfermode(PorterDuff.Mode.DST_IN); mPath = new Path(); mTempCanvas = new Canvas(); mText = &quot;先小涛&quot;; srcBmp = makeTextBitmap(); dstBmp = Bitmap.createBitmap(srcBmp.getWidth(), srcBmp.getHeight(), Bitmap.Config.ARGB_8888); startAnim(); &#125; /** * 开启动画 */ public void startAnim() &#123; // 波纹动画 ValueAnimator waveAnimator = ValueAnimator.ofInt(0, mItemWaveLength); waveAnimator.setDuration(2000); waveAnimator.setRepeatCount(ValueAnimator.INFINITE); waveAnimator.setInterpolator(new LinearInterpolator()); waveAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mDx = (Integer) animation.getAnimatedValue(); postInvalidate(); &#125; &#125;); // 下降动画 ValueAnimator downAnimator = ValueAnimator.ofInt(0, srcBmp.getHeight()); downAnimator.setDuration(8000); downAnimator.setRepeatCount(ValueAnimator.INFINITE); downAnimator.setInterpolator(new LinearInterpolator()); downAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mDy = (Integer) animation.getAnimatedValue(); &#125; &#125;); AnimatorSet animatorSet = new AnimatorSet(); animatorSet.play(waveAnimator).with(downAnimator); animatorSet.start(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 将生成的波纹绘制到空白区域 generateWavePath(); mTempCanvas.setBitmap(dstBmp); mTempCanvas.drawColor(Color.BLACK, PorterDuff.Mode.CLEAR); mTempCanvas.drawPath(mPath, mPaint); // 先绘制文字，再绘制合成效果 canvas.drawBitmap(srcBmp, 0, 0, mPaint); int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(dstBmp, 0, 0, mPaint); mPaint.setXfermode(mMode); canvas.drawBitmap(srcBmp, 0, 0, mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125; /** * 将字符串转化成 bitmap * @return Bitmap */ private Bitmap makeTextBitmap() &#123; Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG); paint.setTextSize(200); paint.setColor(Color.WHITE); paint.setTextAlign(Paint.Align.LEFT); Paint.FontMetricsInt fm = paint.getFontMetricsInt(); int width = (int) paint.measureText(mText); int height = fm.descent - fm.ascent; Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); canvas.drawText(mText, 0, fm.leading - fm.ascent, paint); canvas.save(); return bitmap; &#125; /** * 生成波纹 */ private void generateWavePath() &#123; mPath.reset(); // int originY = srcBmp.getHeight() / 2; int originY = mDy; int halfWaveLen = mItemWaveLength / 2; mPath.moveTo(-mItemWaveLength + mDx, originY); for (int i = -mItemWaveLength; i &lt;= getWidth() + mItemWaveLength; i+= mItemWaveLength) &#123; mPath.rQuadTo(halfWaveLen / 2f, -50, halfWaveLen, 0); mPath.rQuadTo(halfWaveLen / 2f, 50, halfWaveLen, 0); &#125; mPath.lineTo(srcBmp.getWidth(), srcBmp.getHeight()); mPath.lineTo(0, srcBmp.getHeight()); mPath.close(); &#125;&#125; 3）示例：区域不规则波纹3. Mode.DST_OUT计算公式为：[Da (1 - Sa), Dc (1 - Sa)]。 将这个公式与 Mode.SRC_OUT 的公式（[Sa (1 - Da), Sc (1 - Da)]）对比一下可以看出，Mode.SRC_OUT 是利用目标图像的透明度的补值来改变源图像的透明度和饱和度。而 Mode.DST_OUT 反过来，是通过源图像的透明度补值来改变目标图像的透明度和饱和度。简单来说，在 Mode.DST_OUT 模式下，就是相交区域显示的是目标图像，目标图像的透明度和饱和度与源图像的透明度相反，当源图像透明底是100%时，则相交区域为空值。当源图像透明度为0时，则完全显示目标图像。非相交区域完全显示目标图像。示例图像如下图所示。 用下图的分解图来讲解一下这个效果的生成方式，如下图所示。 图中区域一的相交区域：在 DST_OUT 模式下，由于源图像的透明度是 100%，所以计算后的结果图像在这个区域是空白像素。 图中区域二的非相交区域：在 DST_OUT 模式下，这个区域的源图像透明度仍为 100%，所以计算后的结果图像在这个区域仍是空白像素。 所以，当源图像区域透明度为 100%时，所在区域计算结果为透明像素，当源图像的区域透明时，计算结果就是目标图像。 这与 SRC_OUT 模式的结果正好相反，在 SRC_OUT 模式下，当目标图像区域透明度为 100% 时，所在区域计算结果为透明像素；当目标图像的区域透明时，非相交区域的计算结果就是源图像。 所以，在 8.3.3 节中使用 SRC_OUT 模式实现的橡皮擦效果和刮刮卡效果都是可以使用 DST_OUT 模式实现的，只需要将 SRC 和 DST 所对应的图像翻转一下就可以了。 4. Mode.DST_OVER计算公式为：[Sa + (1 - Sa) Da, Rc = Dc + (1 - Da) Sc]。 同样先与 Mode.SRC_OVER 的公式（[Sa + (1 - Sa)Da, Rc = Sc + (1 - Sa) Dc]）对比一下，可以看出，从 SRC 模式中以显示 SRC 图像为主变成了以显示 DST 图像为主，从 SRC 模式中的使用目标图像控制结果图像的透明度和饱和度变成了由源图像控件结果图像的透明度和饱和度。 5. Mode.DST_ATOP计算公式为：[Sa, Sa Dc + Sc (1 - Da)]。 在 SRC 中，一般而言，SRC_ATOP 是可以和 SRC_IN 通用的，但 SRC_ATOP 所产生的效果图在目标图的透明度不是 0 或 100% 的时候，会比 SRC_IN 模式产生的效果图更亮。 我们再来对比下 DST 中的两种模式与 SRC 中的这两种模式的公式的区别： 模式 公式 SRC_IN [Sa Da, Sc Da] SRC_ATOP [Da, Sc Da + (1 - Sa) Dc] DST_IN [Da Sa, Dc Sa ] DST_ATOP [Sa, Sa Dc + Sc (1 - Da)] 从公式中可以看到，在 SRC 模式中，以显示源图像为主，透明度和饱和度利用 Da 来调节；而在 DST 模式中，以显示目标图像为主，透明度和饱和度利用 Sa 来调节。 所以，Mode.DST_ATOP 与 Mode.DST_IN 的关系也是：一般而言，DST_ATOP 是可以和 DST_IN 通用的，但 DST_ATOP 所产生的效果图在源图像的透明度不是 0 或 100% 的时候，会比 DST_IN 模式产生的效果图更亮。 同样，使用 Mode.DST_ATOP 也可以实现 8.3.2 节中利用 Mode.SRC_ATOP 所实现的两个示例：圆角效果和图片倒影，这里就不再讲了。 到这里，有关 DST 相关模式都讲完了，我们总结一下： DST 相关模式是完全可以使用 SRC 对应的模式来实现的，只需将目标图像和源图像对调一下即可。 在 SRC 模式中，是以显示源图像为主，通过目标图像的透明度来调节计算结果的透明度和饱和度，而在 DST 模式中，是以显示目标图像为主，通过源图像的透明度来调节计算结果的透明度和饱和度。 8.4.2 其他模式计算公式：[0, 0]。 从公式中可以看到，计算结果直接就是[0,0]，即空白像素。也就是说，源图像所在区域都会变成空像素，这样就起到了清空源图像所在区域图像的作用。 8.4.3 模式总结在实际应用中，我们可以从以下三个方面来决定使用哪种模式。 目标图像和源图像混合，需不需要生成颜色的叠加特效。如果需要，则从颜色叠加相关模式中选择，有 Mode.ADD（饱和度相加）、Mode.DARKEN（变暗）、Mode.LIGHTEN（变亮）、Mode.MULTIPLY（正片叠底）、Mode.OVERLAY（叠加）、Mode.SCREEN（滤色）。 当不需要特效，而需要根据某张图片的透明像素来裁剪时，就需要使用 SRC 相关或 DST 相关模式了。而 SRC 相关模式与 DST 相关模式是相通的，唯一不同的是决定当前哪个图像是目标图像和源图像。 当需要清空图像时，使用 Mode.CLEAR 模式。]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[08.3 精通自定义 View 之 混合模式——PorterDuffXfermode 之源图像模式]]></title>
    <url>%2F2019%2F07%2F08%2FCustom%20View%2F08.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode%20%E4%B9%8B%E6%BA%90%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[除 Photoshop 中存在的几个模式以外，还有几种是在处理结果时以源图像显示为主的几个模式，所以大家在遇到图像相交，需要显示源图像的情况时，就需要从这几种模式中考虑了，主要有 Mode.SRC、Mode.SRC_IN、Mode.SRC_OUT、Mode.SRC_OVER、Mode.SRC_ATOP。 8.3.1 Mode.SRC计算公式为：[Sa, Sc]。从公式中也可以看出，在处理源图像所在区域的相交问题时，全部以源图像显示。示例图像如下图所示。 8.3.2 Mode.SRC_IN1. 概述计算公式为：[Sa Da, Sc Da]。在这个公式中结果值的透明度和颜色值都是由 Sa、Sc 分别乘以目标图像的 Da 来计算的。所以当目标图像为空白像素时，计算结果也将会为空白像素。示例图像如下图所示。 大家注意 SRC_IN 模式与 SRC 模式的区别。一般而言，是在相交区域时无论 SRC_IN 还是 SRC 模式都是显示源图像，而唯一不同的是，当目标图像是空白像素时，在 SRC_IN 所对应的区域也将会变成空白像素。 其实更严格的来讲，SRC_IN 模式是在相交时利用目标图像的透明度来改变源图像的透明度和饱和度。当目标图像透明度为 0 时，源图像就完全不显示。 利用这个特性，我们能完成很多功能，比如圆角效果和图片倒影。 圆角效果的生成非常简单，依然使用两张图片合成，如下图所示。 小狗图像是源图像，目标图像是一张遮罩图，可以看到这张遮罩图的 4 个角都是圆形切角，而且是透明的。这里我们就需要使用 SRC_IN 模式的特性：当目标图像与源图像相交时，根据目标图像的透明度来决定显示源图像的哪部分。 代码如下：12345678910111213141516171819202122232425262728public class TestView extends View &#123; private Paint mPaint; private Bitmap bmpDST, bmpSRC; private PorterDuffXfermode mMode; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); bmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.dog_shade,null); bmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.dog,null); mMode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(bmpDST,0,0,mPaint); mPaint.setXfermode(mMode); canvas.drawBitmap(bmpSRC,0,0,mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125;&#125; 2. 图片倒影效果SRC_IN 模式是在相交时利用目标图像的透明度来改变源图像的透明度和饱和度。所以当目标图像的透明度在 0~255 之间时，就会把源图像的透明度和颜色值都会变小。利用这个特性，可以做出倒影效果，如下图所示。 很明显，由于 SRC_IN 模式的特性是根据目标图像的透明度来决定如何显示源图像，而我们要显示的是小狗图像，所以，源图像是小狗图像，目标图像是一张遮罩图，它是一个从上到下的白色填充渐变，白色的透明度从 49% 到 0。 小效果图中，我们先画出小狗图像，然后将画布下移，最后将源图像与目标图像再次合成，画出倒影即可。代码如下：1234567891011121314151617181920212223242526272829303132333435public class TestView extends View &#123; private Paint mBitPaint; private Bitmap bmpDST, bmpSRC, bmpRevert; private PorterDuffXfermode mode; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mBitPaint = new Paint(); mode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN); bmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.dog_invert_shade,null); bmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.dog,null); Matrix matrix = new Matrix(); matrix.setScale(1F, -1F); // 生成倒影图 bmpRevert = Bitmap.createBitmap(bmpSRC, 0, 0, bmpSRC.getWidth(), bmpSRC.getHeight(), matrix, true); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 先画出小狗图片 canvas.drawBitmap(bmpSRC,0,0,mBitPaint); // 再画出倒影 int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); canvas.translate(0, bmpSRC.getHeight()); canvas.drawBitmap(bmpDST,0,0,mBitPaint); mBitPaint.setXfermode(mode); canvas.drawBitmap(bmpRevert,0,0,mBitPaint); mBitPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125;&#125; 8.3.3 Mode.SRC_OUT1. 概述计算公式为：[Sa (1 - Da), Sc (1 - Da)]。示例图像如下图所示。 从公式中可以看出，计算结果的透明度为 Sa * (1 - Da)；也就是说当目标图像图像完全不透明时，计算结果将是透明的。 从示例图中也可以看出，源图像与目标图像的相交部分由于目标图像的不透明度为 100%，所以相交部分的计算结果为空白像素。在目标图像为空白像素时，完全以源图像显示。 所以这个模式的特性可以概括为：以目标图像的透明度的补值来调节源图像的透明度和色彩饱和度。即当目标图像为空白像素时，就完全显示源图像，当目标图像的不透明度为 100%时，交合区域为空像素。简单来说，当目标图像有图像时结果显示空白像素，当目标图像没有图像时，结果显示源图像。 2. 橡皮擦效果利用 SRC_OUT 模式的特性，可以实现橡皮擦效果，如下图所示。 原理：对于 Mode.SRC_OUT 模式，当目标图像有图像时计算结果为空白像素；当目标图像没有图像时，显示源图像。所以我们把手指轨迹做为目标图像，在与源图像计算时，有手指轨迹的地方就变为空白像素了，看起来的效果就是被擦除了。 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class TestView extends View &#123; private Paint mPaint; private Bitmap mDstBmp; private Bitmap mSrcBmp; private Path mPath; private float mPreX, mPreY; private PorterDuffXfermode mMode; private Canvas mTempCanvas; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mPaint.setColor(Color.RED); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(100); mPaint.setStrokeCap(Paint.Cap.ROUND); BitmapFactory.Options options = new BitmapFactory.Options(); options.inSampleSize = 2; mSrcBmp = BitmapFactory.decodeResource(getResources(), R.drawable.meinv, options); mDstBmp = Bitmap.createBitmap(mSrcBmp.getWidth(), mSrcBmp.getHeight(), Bitmap.Config.ARGB_8888); mPath = new Path(); mTempCanvas = new Canvas(); mMode = new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mPath.moveTo(event.getX(), event.getY()); mPreX = event.getX(); mPreY = event.getY(); return true; case MotionEvent.ACTION_MOVE: float endX = (mPreX + event.getX()) / 2; float endY = (mPreY + event.getY()) / 2; mPath.quadTo(mPreX, mPreY, endX, endY); mPreX = event.getX(); mPreY = event.getY(); break; case MotionEvent.ACTION_UP: break; &#125; postInvalidate(); return super.onTouchEvent(event); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); // 先把手势轨迹画到目标图像上 mTempCanvas.setBitmap(mDstBmp); mTempCanvas.drawPath(mPath, mPaint); // 然后把目标图像画到画布上 canvas.drawBitmap(mDstBmp, 0 , 0, mPaint); // 计算源图像区域 mPaint.setXfermode(mMode); canvas.drawBitmap(mSrcBmp, 0, 0, mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125;&#125; 3. 刮刮卡效果 需要准备两张图片，一张是刮奖遮罩层图片（scratch_over.png），一张是中奖图片图片（scratch.png），如下图所示。 示例代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class TestView extends View &#123; private Paint mPaint; private Bitmap mDstBmp; private Bitmap mSrcBmp; private Bitmap mTextBmp; private Path mPath; private float mPreX, mPreY; private PorterDuffXfermode mMode; private Canvas mTempCanvas; private RectF mRect; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mPaint.setColor(Color.RED); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(100); mPaint.setStrokeCap(Paint.Cap.ROUND); mTextBmp = BitmapFactory.decodeResource(getResources(), R.drawable.scratch); mSrcBmp = BitmapFactory.decodeResource(getResources(), R.drawable.scratch_over); mDstBmp = Bitmap.createBitmap(mSrcBmp.getWidth(), mSrcBmp.getHeight(), Bitmap.Config.ARGB_8888); mPath = new Path(); mTempCanvas = new Canvas(); mMode = new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT); mRect = new RectF(); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mPath.moveTo(event.getX(), event.getY()); mPreX = event.getX(); mPreY = event.getY(); return true; case MotionEvent.ACTION_MOVE: float endX = (mPreX + event.getX()) / 2; float endY = (mPreY + event.getY()) / 2; mPath.quadTo(mPreX, mPreY, endX, endY); mPreX = event.getX(); mPreY = event.getY(); break; case MotionEvent.ACTION_UP: break; &#125; postInvalidate(); return super.onTouchEvent(event); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); float width = mTextBmp.getWidth(); float height = mTextBmp.getHeight(); float screenWidth = getWidth(); if (width &gt; screenWidth) &#123; height = height * screenWidth / width; width = screenWidth; &#125; mRect.set(0, 0, width, height); // 先画底层奖励文案图片 canvas.drawBitmap(mTextBmp, null, mRect, mPaint); int layerId = canvas.saveLayer(140, 70, width - 140, height - 70, null, Canvas.ALL_SAVE_FLAG); // 把手势轨迹画到目标图像上 mTempCanvas.setBitmap(mDstBmp); mTempCanvas.drawPath(mPath, mPaint); // 然后把目标图像画到画布上 canvas.drawBitmap(mDstBmp, 0, 0, mPaint); // 计算源图像区域 mPaint.setXfermode(mMode); mRect.set(140, 70, width-140, height-70); canvas.drawBitmap(mSrcBmp, null, mRect, mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125;&#125; 8.3.4 Mode.SRC_OVER计算公式为：[Sa + (1 - Sa) Da, Rc = Sc + (1 - Sa) Dc]。示例图像为： 在计算结果中，源图像没有改变。它的意思就是，在目标图像的顶部绘制源图像。从公式中也可以看出，目标图像的透明度为 Sa + (1 - Sa) * Da；即在源图像的透明度基础上增加一部分目标图像的透明度。增加的透明度是源图像透明度的补量；目标图像的色彩值的计算方式同理，所以当源图像透明度为 100% 时，就原样显示源图像。 8.3.5 Mode.SRC_ATOP计算公式为：[Da, Sc Da + (1 - Sa) Dc]。 很奇怪，它的效果图竟然与 SRC_IN 模式是相同的，我们来对比一下它们的公式： SRC_IN：[Sa Da, Sc Da]SRC_ATOP：[Da, Sc Da + (1 - Sa) Dc] 先看透明度：在 SRC_IN 中是 Sa * Da,在 SRC_ATOP 是 Da。SRC_IN 是源图像透明度乘以目标图像的透明度做为结果透明度，而SRC_ATOP 是直接使用目标图像的透明度做为结果透明度。 再看颜色值：SRC_IN 的颜色值为 Sc Da，SRC_ATOP 的颜色值为Sc Da + (1 - Sa) Dc，SRC_ATOP 在 SRC_IN 的基础上还增加了(1 - Sa) Dc。 所以，结论为：1）当透明度是 100% 和 0 时，SRC_ATOP 和 SRC_IN 模式是通用的。2）当透明度不是 100% 和 0 时，SRC_ATOP 相比 SRC_IN 源图像的饱和度会增加，即会显得更亮。]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[08.2 精通自定义 View 之 混合模式——PorterDuffXfermode]]></title>
    <url>%2F2019%2F07%2F08%2FCustom%20View%2F08.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode%2F</url>
    <content type="text"><![CDATA[8.2.1 PorterDuffXfermode 概述官方文档链接PorterDuffXfermode 的构造函数如下：1public PorterDuffXfermode(PorterDuff.Mode mode) 它只有一个参数 PorterDuff.Mode，表示混合模式，枚举值有18个，表示各种图形混合模式，每一种模式都对应着一种算法，如下图所示。 比如，LIGHTEN 的计算方式为[Sa + Da - Sa Da, Sc (1 - Da) + Dc (1 - Sa) + max(Sc, Dc)]，其中 Sa 全称为 Source alpha 表示源图的 Alpha 通道；Sc 全称为 Source color 表示源图的颜色；Da 全称为 Destination alpha 表示目标图的 Alpha 通道；Dc 全称为 Destination color 表示目标图的颜色，在每个公式中，都会被分为两部分[……，……]，其中 “,” 前的部分为 “Sa + Da - Sa Da” 这一部分的值代表计算后的 Alpha 通道；而 “,” 后的部分为 “Sc (1 - Da) + Dc (1 - Sa) + max(Sc, Dc)” 这一部分的值代表计算后的颜色值，图形混合后的图片就是依据这个公式来对 DST 和 SR C两张图像中每一个像素进行计算，得到最终的结果的。 显示的是两个图形一圆一方通过一定的计算产生不同的组合效果，其中圆形是底部的目标图像，方形是上方的源图像。 在上面的公式中涉及到一个概念，目标图 DST，源图 SRC。那什么是源图，什么是目标图呢？我们简单举例子来说明一下： 首先需要自定义一个控件并进行初始化；然后禁用硬件加速；新建两张空白图片，然后在图片上分别画一个圆形 (DST) 和一个矩形 (SRC) 并填充相应的颜色，图形以外的位置都是空白像素；最后在离屏绘制部分，现在 (0, 0) 位置把圆形图像画出来，然后设置 PorterDuffXfermode 的模式为 Mode.SRC_IN，之后再以圆形中心为左上角点画出矩形，清空 Xfermode。 在 Xfermode 设置前画出的图像叫做目标图像，即给谁应用 Xfermode；在 Xfermode 设置后画出的图像叫做源图像，即拿什么应用 Xfermode。12345678910111213141516171819202122232425262728293031323334353637383940414243public class TestView extends View &#123; private Paint mPaint; private Bitmap dstBmp; private Bitmap srcBmp; private int width = 200; private int height = 200; private PorterDuffXfermode mMode; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); dstBmp = makeBitmap(width, height, 0xFFFFCC44, &quot;oval&quot;); srcBmp = makeBitmap(width, height, 0xFF66AAFF, &quot;rect&quot;); mMode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN); &#125; private Bitmap makeBitmap(int w, int h, int color, String type) &#123; Bitmap bmp = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bmp); Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG); paint.setColor(color); if (&quot;oval&quot;.equals(type)) &#123; canvas.drawOval(new RectF(0, 0, w, h), paint); &#125; else &#123; canvas.drawRect(0, 0, w, h, paint); &#125; return bmp; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.translate(100, 100); int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(dstBmp, 0, 0, mPaint); mPaint.setXfermode(mMode); canvas.drawBitmap(srcBmp, width / 2f, height / 2f, mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125;&#125; 该示例的效果如下图所示。 对于 Mode.SRC_IN，它的计算公式为[Sa Da, Sc Da]。在这个公式中，结果值的透明度和颜色值都是由 Sa、Sc 分别乘以目标图像的 Da 来计算的。当目标图像为空白像素时，计算结果也将为空白像素；当目标图像不透明时，相交区域将显示源图像像素。所以，从效果图中可以看出，两图像相交部分显示的是源图像；对于不相交的部分，此时目标图像的透明度是 0，源图像不显示。 8.2.2 颜色叠加相关模式这部分涉及到的几个模式有 Mode.ADD（饱和度相加）、Mode.LIGHTEN（变亮）、Mode.DARKEN（变暗）、Mode.MULTIPLY（正片叠底）、Mode.OVERLAY（叠加），Mode.SCREEN（滤色）。 1. Mode.ADD（饱和度相加）它的公式是 Saturate(S + D)。ADD 模式简单来说就是对 SRC 与 DST 两张图片相交区域的饱和度进行相加。使用 8.2.1 节中的例子，将 PorterDuff.Mode.SRC_IN 改为 PorterDuff.Mode.ADD，效果如下图所示。 从效果图中可以看出，只有源图与目标图像相交的部分的图像的饱和度产生了变化，没相交的部分是没有变的，因为对方的饱和度是 0，当然不相交的位置饱和度是不会变的。这个模式的应用范围比较少，暂时想不到哪里会用到。 2. Mode.LIGHTEN（变亮）它的算法是： [Sa + Da - Sa Da, Sc (1 - Da) + Dc * (1 - Sa) + max(Sc, Dc)]。 这个效果比较容易理解，两个图像重合的区域才会有颜色值变化，所以只有重合区域才有变亮的效果，源图像非重合的区域，由于对应区域的目标图像是空白像素，所以直接显示源图像。 在实际应用中，会出现这种情况：当选中一本书时，给这本书加上灯光效果，如下图所示。 代码如下：1234567891011121314151617181920212223242526272829public class TestView extends View &#123; private Paint mPaint; private Bitmap bmpDST, bmpSRC; private PorterDuffXfermode mMode; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); bmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.book_bg,null); bmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.book_light,null); mMode = new PorterDuffXfermode(PorterDuff.Mode.LIGHTEN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); // 先画书架，做为目标图像 canvas.drawBitmap(bmpDST,0,0,mPaint); mPaint.setXfermode(mMode); // 再图光点 canvas.drawBitmap(bmpSRC,0,0,mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125;&#125; 3. Mode.DARKEN（变暗）对应公式是： [Sa + Da - Sa Da, Sc (1 - Da) + Dc * (1 - Sa) + max(Sc, Dc)]。 4. Mode.MULTIPLY（正片叠底）公式是：[Sa Da, Sc Dc]。 从公式中可以看出，计算 Alpha 值时的公式是 Sa * Da，是用源图像的 Alpha 值乘以目标图像的 Alpha 值。由于源图像的非相交区域所对应的目标图像像素的 Alpha 是 0，所以结果像素的 Alpha 值仍是 0，源图像的非相交区域在计算后是透明的。 5. Mode.OVERLAY（叠加）Google 没有给出这种模式的算法，效果如下图所示。 6. Mode.SCREEN（滤色）对应公式是：[Sa + Da - Sa Da, Sc + Dc - Sc Dc]。 到这里，这六种混合模式就讲完了，下面总结一下： 这几种模式都是 PhotoShop 中存在的模式，是通过计算改变交合区域的颜色值的。 除了 Mode.MULTIPLY（正片叠底）会在目标图像透明时将结果对应区域置为透明，其它图像都不受目标图像透明像素影响，即源图像非交合部分保持原样。 7. 示例：Twitter 标识的描边效果 在图一中，小鸟整个都是蓝色的。在图二中，只有小鸟的边缘部分是白色的，中间部分是透明的。在最终的合成图中：图一和图二中小鸟与边缘的是显示的，而且还有某种效果，但小鸟中间的区域变透明了，显示的是底部Activity的背景色。 前面学到的几种样式中，只有 Mode.MULTIPLY（正片叠底）会在两个图像的一方透明时，结果像素就是透明的。所以这里使用的模式就是 Mode.MULTIPLY 模式。 代码如下：12345678910111213141516171819202122232425262728public class TestView extends View &#123; private Paint mPaint; private Bitmap bmpDST, bmpSRC; private PorterDuffXfermode mMode; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); bmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.twiter_bg,null); bmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.twiter_light,null); mMode = new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(bmpDST,0,0,mPaint); mPaint.setXfermode(mMode); canvas.drawBitmap(bmpSRC,0,0,mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125;&#125;]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[08.1 精通自定义 View 之 混合模式——AvoidXfermode]]></title>
    <url>%2F2019%2F07%2F08%2FCustom%20View%2F08.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AvoidXfermode%2F</url>
    <content type="text"><![CDATA[8.1.1 混合模式概述混合模式能够将两张图片无缝结合，实现类似 Photoshop 中的两张图片融合效果。 混合模式是通过 Paint 类中的 Xfermode setXfermode(Xfermode xfermode) 函数实现的，它的参数 Xfermode 是一个空类，主要靠它的子类来实现不同的功能，如下图所示。 在启舰的书里派生自 Xfermode 的子类有 AvoidXfermode、PixelXorXfermode 和 PorterDuffXfermode，并且讲解了相关的知识。但笔者在 2019 年最新的官方文档中，已经找不到 AvoidXfermode 和 PixelXorXfermode 这两个类的相关文档，且在 AndroidX 系列中不支持相关 API。若想了解详情，请点击前往启舰的博客。 在使用 Xfermode 时，需要做两件事。1）禁用硬件加速1setLayerType(View.LAYER_TYPE_SOFTWARE, null); 2）使用离屏绘制（详见第九章）12345678// 新建图层int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG);// 核心绘制代码...// 还原图层canvas.restoreToCount(layerId);]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07.6 精通自定义 View 之 绘图进阶——Shader 之 RadialGradient]]></title>
    <url>%2F2019%2F07%2F07%2FCustom%20View%2F07.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20RadialGradient%2F</url>
    <content type="text"><![CDATA[RadialGradient 是 Shader 的另一种实现，它的含义是放射渐变，即它会像一个放射源一样，从一个点开始向外扩散，从一种颜色变成另一种颜色。 7.6.1 双色渐变RadialGradient 有两个构造函数，分别能完成双色渐变和多色渐变。双色渐变的构造函数如下：12RadialGradient(float centerX, float centerY, float radius, int centerColor, int edgeColor, Shader.TileMode tileMode) centerX：渐变中心点X坐标。 centerY：渐变中心点Y坐标。 radius：渐变半径。 centerColor：渐变的起始颜色，即渐变中心点的颜色,取值类型必须是八位的0xAARRGGBB色值！透明底Alpha值不能省略，不然不会显示出颜色。 edgeColor：渐变结束时的颜色，即渐变圆边缘的颜色，同样，取值类型必须是八位的0xAARRGGBB色值。 TileMode：与我们前面讲的各个Shader一样，用于指定当控件区域大于指定的渐变区域时，空白区域的颜色填充方式。 示例：1234567891011121314151617181920212223242526public class TestView extends AppCompatTextView &#123; private Paint mPaint; private RadialGradient mRadialGradient; private int mRadius; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE, null); mPaint = getPaint(); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mRadius = w / 5; mRadialGradient = new RadialGradient(w / 2f, h / 2f, mRadius, 0xffff0000, 0xff00ff00, Shader.TileMode.CLAMP); mPaint.setShader(mRadialGradient); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(getWidth()/2f, getHeight()/2f, mRadius, mPaint); &#125;&#125; 效果如下图所示。 7.6.2 多色渐变12RadialGradient(float centerX, float centerY, float radius, int[] colors, float[] stops, Shader.TileMode tileMode) int[] colors：表示所需要的渐变颜色数组。+float[] stops：表示每个渐变颜色所在的位置百分点，取值 0~1，数量必须与 colors 数组保持一致，不然直接 crash。一般第一个数值取 0，最后一个数值取 1，比如，取一个位置数组：{0.2,0.5,0.8}，起始点是0.2百分比位置，结束点是0.8百分比位置，而 0~0.2 百分比位置和 0.8~1.0 百分比的位置都是没有指定颜色的。这些位置的颜色就是根据我们指定的 TileMode 空白区域填充模式来自行填充。但有时效果我们是不可控的。所以，为了方便起见，建议大家 stop 数组的起始和终止数值设为 0 和 1。 示例：12345678910111213141516171819202122232425262728public class TestView extends AppCompatTextView &#123; private Paint mPaint; private RadialGradient mRadialGradient; private int mRadius; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE, null); mPaint = getPaint(); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mRadius = w / 5; int[] colors = &#123;0xffff0000, 0xff00ff00, 0xff0000ff, 0xffffff00&#125;; float[] stops = &#123;0f, 0.2f, 0.5f, 1f&#125;; mRadialGradient = new RadialGradient(w / 2f, h / 2f, mRadius, colors, stops, Shader.TileMode.CLAMP); mPaint.setShader(mRadialGradient); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(getWidth()/2f, getHeight()/2f, mRadius, mPaint); &#125;&#125; 效果图如下： 7.6.3 TileMode 填充模式在 RadialGradient 构造函数中，只有一个 TileMode 参数，这说明当填充空白区域时，X 轴和 Y 轴使用同一种填充模式。而不能像 BitmapShader 那样分别指定 X 轴与 Y 轴的填充参数。 分别设置填充模式为：TileMode.CLAMP、TileMode.MIRROR、TileMode.REPEAT。 示例代码：1234567891011121314151617181920212223242526public class TestView extends AppCompatTextView &#123; private Paint mPaint; private RadialGradient mGradient; private int mRadius; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE, null); mPaint = getPaint(); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mRadius = w / 10; mGradient = new RadialGradient(w / 2f, h / 2f, mRadius, 0xffff0000, 0xff00ff00, Shader.TileMode.REPEAT); mPaint.setShader(mGradient); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawRect(0, 0, getWidth(), getHeight(), mPaint); &#125;&#125; 7.6.4 示例：水波纹按钮效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class TestView extends AppCompatButton &#123; private int mX, mY; private ObjectAnimator mAnimator; private int DEFAULT_RADIUS = 50; private int mCurRadius = 0; private RadialGradient mRadialGradient; private Paint mPaint; public TestView(Context context) &#123; super(context); init(); &#125; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public TestView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init() &#123; setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; if (mX != event.getX() || mY != mY) &#123; mX = (int) event.getX(); mY = (int) event.getY(); setRadius(DEFAULT_RADIUS); &#125; if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; return true; &#125; else if (event.getAction() == MotionEvent.ACTION_UP) &#123; if (mAnimator != null &amp;&amp; mAnimator.isRunning()) &#123; mAnimator.cancel(); &#125; if (mAnimator == null) &#123; mAnimator = ObjectAnimator.ofInt(this,&quot;radius&quot;,DEFAULT_RADIUS, getWidth()); &#125; mAnimator.setInterpolator(new AccelerateInterpolator()); mAnimator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123;&#125; @Override public void onAnimationEnd(Animator animation) &#123; setRadius(0); &#125; @Override public void onAnimationCancel(Animator animation) &#123;&#125; @Override public void onAnimationRepeat(Animator animation) &#123;&#125; &#125;); mAnimator.start(); &#125; return super.onTouchEvent(event); &#125; public void setRadius(final int radius) &#123; mCurRadius = radius; if (mCurRadius &gt; 0) &#123; mRadialGradient = new RadialGradient(mX, mY, mCurRadius, 0x00FFFFFF, 0xFF58FAAC, Shader.TileMode.CLAMP); mPaint.setShader(mRadialGradient); &#125; postInvalidate(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(mX, mY, mCurRadius, mPaint); &#125;&#125;]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07.5 精通自定义 View 之 绘图进阶——Shader 之 LinearGradient]]></title>
    <url>%2F2019%2F07%2F07%2FCustom%20View%2F07.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20LinearGradient%2F</url>
    <content type="text"><![CDATA[通过 LinearGradient 可以实现线性渐变效果。 7.5.1 概述1. 构造函数第一个构造函数：12public LinearGradient(float x0, float y0, float x1, float y1, int color0, int color1, TileMode tile) (x0,y0) ：起始渐变点坐标；(x1,y1) ：结束渐变点坐标。 color0：起始颜色；color1：终止颜色。颜色值必须使用 0xAARRGGBB 形式的 16 进制表示，表示透明度的 AA 一定不能少。 TileMode tile：与 BitmapShader 一样，用于指定控件区域大于指定的渐变区域时，空白区域的颜色填充方法。 第二个构造函数：12public LinearGradient(float x0, float y0, float x1, float y1, int colors[], float positions[], TileMode tile) colors[]：用于指定渐变的颜色值数组。同样，颜色值必须使用 0xAARRGGBB 形式的 16 进制表示，表示透明度的 AA 一定不能少。 positions[]：与渐变的颜色相对应，取值是 0-1 的 float 类型，表示在每一个颜色在整条渐变线中的百分比位置 2. 双色渐变使用示例自定义一个从左到右的双色渐变控件，代码如下。12345678910111213141516171819202122232425262728public class TestView extends View &#123; private Paint mPaint; private int mWidth, mHeight; private LinearGradient mLinearGradient; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mWidth = getMeasuredWidth(); mHeight = getMeasuredHeight(); mLinearGradient = new LinearGradient(0, mHeight / 2f, mWidth, mHeight / 2f, 0xFFFF0000, 0xFF00FF00, Shader.TileMode.CLAMP); mPaint.setShader(mLinearGradient); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawRect(0, 0, mWidth, mHeight, mPaint); &#125;&#125; 3. 多色渐变使用示例在上面示例的基础上，使用多色渐变来构造 LinearGradient 实例。123456789101112131415161718192021222324252627282930public class TestView extends View &#123; private Paint mPaint; private int mWidth, mHeight; private LinearGradient mLinearGradient; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mWidth = getMeasuredWidth(); mHeight = getMeasuredHeight(); int[] colors = &#123;0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFFFFFF00, 0xFF00FFFF&#125;; float[] pos = &#123;0f, 0.2f, 0.4f, 0.6f, 1.0f&#125;; mLinearGradient = new LinearGradient(0, mHeight / 2f, mWidth, mHeight / 2f, colors, pos, Shader.TileMode.CLAMP); mPaint.setShader(mLinearGradient); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawRect(0, 0, mWidth, mHeight, mPaint); &#125;&#125; 效果如下图所示。 从这里可以看出，渐变的开始点同样是控件左边中点，渐变的结束点也同样是控件右边中点；这里我们指定了五种渐变颜色，而且指定了每个颜色的位置，前四种颜色是按 20% 均匀分布的，最后两种颜色相距 40%；最后通过 canvas.drawRect() 函数把整个控件区域画出来。 注意：colors 和 pos 的个数一定要相等，也就是说必须指定每一个颜色值的位置。如果元素个数不相等，则会直接报错，如下图所示。 4. TileMode 填充模式从构造函数中可以看出，LiearGradient 只有一个 TileMode 参数，这说明 X 轴与 Y 轴共用这一个 TileMode 填充参数，而不能像 BitmapShader 那样分别指定 X 轴与 Y 轴的填充参数。 示例：分别指定不同的填充模式 1234567891011121314151617181920212223242526272829303132333435363738public class TestView extends View &#123; private Paint mPaint; private int mWidth, mHeight; private LinearGradient mGradientCLAMP, mGradientMIRROR, mGradientREPEAT; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mWidth = getMeasuredWidth(); mHeight = 200; int[] colors = &#123;0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFFFFFF00, 0xFF00FFFF&#125;; float[] pos = &#123;0f, 0.2f, 0.4f, 0.6f, 1.0f&#125;; mGradientCLAMP = new LinearGradient(0, 0, mWidth / 2f, mHeight / 2f, colors, pos, Shader.TileMode.CLAMP); mGradientMIRROR = new LinearGradient(0, mHeight, mWidth / 2f, mHeight * 3f / 2, colors, pos, Shader.TileMode.MIRROR); mGradientREPEAT = new LinearGradient(0, mHeight * 2f, mWidth / 2f, mHeight*5 / 2f, colors, pos, Shader.TileMode.REPEAT); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setShader(mGradientCLAMP); canvas.drawRect(0, 0, mWidth, mHeight, mPaint); mPaint.setShader(mGradientMIRROR); canvas.drawRect(0, mHeight, mWidth, mHeight * 2, mPaint); mPaint.setShader(mGradientREPEAT); canvas.drawRect(0, mHeight * 2, mWidth, mHeight * 3, mPaint); &#125;&#125; 5. Shader 填充与显示区域所有 Shader 都是一样的：Shader 的布局和显示是分离的；Shader 总是从控件的左上角开始布局的；如果单张图片无法覆盖整个控件，则会使用 TileMode 重复模式来填充空白区域；而 canvas.draw 系列函数则只表示哪部分区域被显示出来。 下面利用 drawText() 函数实现一个渐变文字效果。 1234567891011121314151617181920212223242526public class TestView extends View &#123; private Paint mPaint; private String mText; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mPaint.setTextSize(80); mText = &quot;欢迎关注先先生的Blog&quot;; float width = mPaint.measureText(mText); int[] colors = &#123;0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFFFFFF00, 0xFF00FFFF&#125;; float[] pos = &#123;0f, 0.2f, 0.4f, 0.6f, 1.0f&#125;; LinearGradient gradient = new LinearGradient(0, 0, width / 2f, 0, colors, pos, Shader.TileMode.MIRROR); mPaint.setShader(gradient); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawText(mText, 0, 100, mPaint); &#125;&#125; 7.5.2 示例：闪光文字效果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class TestView extends AppCompatTextView &#123; private Paint mPaint; private LinearGradient mLinearGradient; private int mDx; private Matrix mMatrix; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE, null); mPaint = getPaint(); mMatrix = new Matrix(); int length = (int) mPaint.measureText(getText().toString()); createAnim(length); createLinearGradient(length); &#125; private void createAnim(int length) &#123; ValueAnimator animator = ValueAnimator.ofInt(0, 2 * length); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mDx = (Integer) animation.getAnimatedValue(); postInvalidate(); &#125; &#125;); animator.setRepeatMode(ValueAnimator.RESTART); animator.setRepeatCount(ValueAnimator.INFINITE); animator.setDuration(2000); animator.start(); &#125; private void createLinearGradient(int length) &#123; mLinearGradient = new LinearGradient(-length, 0, 0, 0, new int[]&#123;getCurrentTextColor(), 0xFF00FF00, getCurrentTextColor()&#125;, new float[]&#123;0, 0.5f, 1&#125;, Shader.TileMode.CLAMP); &#125; @Override protected void onDraw(Canvas canvas) &#123; mMatrix.reset(); mMatrix.setTranslate(mDx, 0); mLinearGradient.setLocalMatrix(mMatrix); mPaint.setShader(mLinearGradient); super.onDraw(canvas); &#125;&#125; 在 res/layout/act_main.xml123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;com.xxt.xtest.TestView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;20dp&quot; android:textSize=&quot;24sp&quot; android:text=&quot;欢迎关注先先生的Blog&quot;/&gt;&lt;/LinearLayout&gt; 控件派生自 TextView 的子类，所以可以使用 TextView 的自带方法 getCurrentTextColor() 来获取文字颜色、画笔、文字长度等；利用 Shader.setLocalMatrix(Matrix localM) 设置逐渐平移的矩阵，最后用 ValueAnimator 来控制矩阵平移的位移 mDx，移动距离是从 0 到两倍的 text 距离。]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07.4 精通自定义 View 之 绘图进阶——Shader 与 BitmapShader]]></title>
    <url>%2F2019%2F07%2F07%2FCustom%20View%2F07.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B8%8E%20BitmapShader%2F</url>
    <content type="text"><![CDATA[7.4.1 Shader 概述Shader 在三维软件中称之为着色器，是用来给空白图形上色用的。在 PhotoShop 中有一个印章工具，能够指定印章的样式来填充图形。印章的样式可以是图像、颜色、渐变色等。这里的 Shader 实现的效果与印章类似。我们也是通过给 Shader 指定对应的图像、渐变色等来填充图形的。Paint 中有一个函数专门用于设置 Shader，其声明如下：1public Shader setShader(Shader shader) Shader 类只是一个基类，其中只有两个函数 setLocalMatrix(Matrix localM) 和 getLocalMatrix(Matrix localM)，用来设置坐标变换矩阵的。 Shader 类其实是一个空类，它的功能主要是靠它的派生类来实现的。继承关系如下图所示。 7.4.2 BitmapShader 的基本用法它的构造函数如下：1public BitmapShader(Bitmap bitmap, TileMode tileX, TileMode tileY) 这就相当于 PhotoShop 中的印章工具，bitmap 用来指定图案，tileX 用来指定当 X 轴超出单个图片大小时时所使用的重复策略，同样 tileY 用于指定当 Y 轴超出单个图片大小时时所使用的重复策略。 其中TileMode的取值有： TileMode.CLAMP：用边缘色彩填充多余空间。 TileMode.REPEAT：重复原图像来填充多余空间。 TileMode.MIRROR：重复使用镜像模式的图像来填充多余空间。 1. 示例这里使用的印章图像如下图所示 (dog.png)。 中间是一幅小狗头像，四周被四种不同的颜色给包围。设置 Shader 的完整代码如下：123456789101112131415161718public class TestView extends View &#123; private Paint mPaint; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); Bitmap mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.dog_edge); mPaint.setShader(new BitmapShader(mBitmap, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT)); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawRect(0, 0, getWidth(), getHeight(), mPaint); &#125;&#125; 效果图如下所示： 给自定义的控件添加上宽高限制：1234567&lt;!--&lt;com.xxt.xtest.TestView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt;--&gt;&lt;com.xxt.xtest.TestView android:layout_width=&quot;300dp&quot; android:layout_height=&quot;450dp&quot; android:layout_gravity=&quot;center_horizontal&quot;/&gt; 效果图如下： 从效果图中可以看出： 在 X 轴和 Y 轴都使用 REPEAT 模式下，在超出单个图像的区域后，就会重复绘制这个图像。 绘制是从控件的左上角开始的，而不是从屏幕原点开始的。这点很好理解，因为我们只会在自定义控件上绘图，不会在全屏幕上绘图。 2. TileMode 模式解析上面初步看到了 REPEAT 模式的用法，现在我们分别来看在各个模式下的不同表现。1）TileMode.REPEAT 模式：重复原图像来填充多余空间在更改模式时，只需要更新setShader里的代码：1mPaint.setShader(new BitmapShader(mBmp, TileMode.REPEAT, TileMode.REPEAT)); 在这里，X 轴、Y 轴全部设置成 REPEAT 模式，所以当控件的显示范围超出了单个图的显示范围时，在 X 轴上将使用 REPEAT 模式；同样，在 Y 轴上也将使用 REPEAT 模式。 2）TileMode.MIRROR 模式：重复使用镜像模式的图像来填充多余空间同样，将 X 轴、Y 轴全部改为 MIRROR 模式：1mPaint.setShader(new BitmapShader(mBmp, TileMode.MIRROR, TileMode.MIRROR)); 效果如下图所示。 在 X 轴上每两张图片的显示都像镜子一样翻转一下。同样，在 Y 轴上每两张图片的显示也都像镜子一样翻转一下。所以这就是镜相效果的作用，镜相效果其实就是在显示下一图片的时候，就相当于两张图片中间放了一个镜子一样。 3）TileMode.CLAMP：用边缘色彩填充多余空间1mPaint.setShader(new BitmapShader(mBmp, TileMode.CLAMP, TileMode.CLAMP)); CLAMP 模式的意思就是当控件区域超过当前单个图片的大小时，空白位置的颜色填充就用图片的边缘颜色来填充。 4）TileMode.CLAMP 与填充顺序当 X 轴、Y 轴全部都是 CLAMP 模式时，X 轴的空白区域会用图像的右侧边缘颜色来填充；Y 轴的空白区域会用图像的底部的边缘颜色来填充，那效果应该是这样的： 明显右下角的空白位置根本与图像是不沾边的，那它要用什么颜色来填充呢？是填充上方的蓝色还是填充左侧的绿色呢？ 从最终的效果图来看，这部分填充的颜色是绿色的，可为什么呢？其实这是跟填充顺序有关的，并且是先填充竖向再填充横向。如果是先填充横向再填充竖向，那么右下角颜色应该是蓝色。 4）使用混合填充模式比如在 X 轴填充空白区域时使用 MIRROR 样式、在填充 Y 轴空白区域时使用REPEAT样式：1mPaint.setShader(new BitmapShader(mBmp, TileMode.MIRROR, TileMode.REPEAT)); 从效果图中可以看出来，首先使用 REPEAT 模式填充 Y 轴，然后使用 MIRROR 模式填充 X 轴。 总之：无论哪两种模式混合或者相同模式，都是先填充 Y 轴，然后填充 X 轴。 3. 绘图位置与图像显示在上面的例子中，我们利用 drawRect 把整个控件大小都给覆盖了，那假如我们只画一个小矩形而不完全覆盖整个控件，那我们 setShader() 函数中所设置的图片是从哪里开始画的呢？12345678910111213141516171819202122public class TestView extends View &#123; private Paint mPaint; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); Bitmap mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.dog_edge); mPaint.setShader(new BitmapShader(mBitmap, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT)); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); float left = getWidth() / 3f; float top = getHeight() / 3f; float right = getWidth() * 2f / 3; float bottom = getHeight() * 2f / 3; canvas.drawRect(left,top,right,bottom, mPaint); &#125;&#125; 即在绘图时，并不是完全覆盖控件大小的，而是取控件中间位置的 1/3 区域显示的。效果如下图所示。 7.4.3 示例一：望远镜效果 这里要实现的效果是：根据手指所在的位置，把对应的图像绘制出来。这样看起来就是望远镜效果了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class TestView extends View &#123; private Paint mPaint; private Rect mRect; private int mDx = -1; private int mDy = -1; private Bitmap mBitmap, mBitmapBg; private int mRadius = 300; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.meinv); mRect = new Rect(); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mDx = (int) event.getX(); mDy = (int) event.getY(); invalidate(); return true; case MotionEvent.ACTION_MOVE: mDx = (int) event.getX(); mDy = (int) event.getY(); break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: mDx = -1; mDy = -1; break; &#125; invalidate(); return super.onTouchEvent(event); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mBitmapBg == null) &#123; mBitmapBg = Bitmap.createBitmap(getWidth(), getHeight(), Bitmap.Config.ARGB_8888); Canvas canvasBg = new Canvas(mBitmapBg); mRect.set(0, 0, getWidth(), getHeight()); canvasBg.drawBitmap(mBitmap, null, mRect, mPaint); &#125; if (mDx != -1 &amp;&amp; mDy != -1) &#123; mPaint.setShader(new BitmapShader(mBitmapBg, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT)); canvas.drawCircle(mDx, mDy, mRadius, mPaint); &#125; &#125;&#125; 我们主要来看下 OnDraw() 函数：在 onDraw() 函数中，第一部分，就是新建一个空白的 bitmap，这个 bitmap 的大小与控件一样，然后把我们的背景图进行拉伸，画到这个空白的 bitmap 上。由于这里的 canvasBg 是用 mBitmapBg 创建的，所以所画的任何图像都会直接显示在 mBitmapBg 上，而我们创建的 mBitmapBg 是与控件一样大的，所以当把 mBitmapBg 做为 Shader 来设置给 mPaint 时，mBitmapBg 会正好覆盖整个控件，而不会有多余的空白像素。 这里需要注意的就是我们在将原图像画到 mBitmapBg 时，进行了拉伸压缩，把它拉伸到和当前控件一样大小。然后利用 OnMotionEvent 来捕捉用户的手指位置，当用户手指下按时，在手指位置画一个半径为 mRadius 的圆形，把对应的位置的图像显示出来就可以了。 7.4.4 示例二：生成不规则头像 res/values/attrs.xml1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;TestView&quot;&gt; &lt;attr name=&quot;src&quot; format=&quot;reference&quot; /&gt; &lt;attr name=&quot;format&quot; format=&quot;enum&quot;&gt; &lt;enum name=&quot;circle&quot; value=&quot;0&quot;/&gt; &lt;enum name=&quot;rectTangle&quot; value=&quot;1&quot;/&gt; &lt;/attr&gt; &lt;attr name=&quot;radius&quot; format=&quot;integer&quot; /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 自定义控件：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class TestView extends View &#123; private Paint mPaint; private Bitmap mBitmap; private BitmapShader mBitmapShader; private int mEnumFormat = 0; private int mRadius = 5; private RectF mRectF; private Matrix mMatrix; public TestView(Context context, AttributeSet attrs) throws Exception&#123; super(context, attrs); init(context,attrs); &#125; public TestView(Context context, AttributeSet attrs, int defStyle) throws Exception&#123; super(context, attrs, defStyle); init(context,attrs); &#125; private void init(Context context,AttributeSet attrs) throws Exception&#123; // 提取属性定义 TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.TestView); int BitmapID = typedArray.getResourceId(R.styleable.TestView_src,-1); if (BitmapID == -1)&#123; throw new Exception(&quot;TestView 需要定义 Src 属性，而且必须是图像&quot;); &#125; mBitmap = BitmapFactory.decodeResource(getResources(),BitmapID); mEnumFormat = typedArray.getInt(R.styleable.TestView_format,0); if (mEnumFormat == 1)&#123; mRadius = typedArray.getInt(R.styleable.TestView_radius,5); &#125; typedArray.recycle(); mPaint = new Paint(); mBitmapShader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); mRectF = new RectF(); mMatrix = new Matrix(); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int measureWidth = MeasureSpec.getSize(widthMeasureSpec); int measureHeight = MeasureSpec.getSize(heightMeasureSpec); int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec); int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec); int width = mBitmap.getWidth(); int height = mBitmap.getHeight(); width = (measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth: width; height = (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight: height; setMeasuredDimension(width, height); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); float scale = (float) getWidth()/mBitmap.getWidth(); mMatrix.reset(); mMatrix.setScale(scale, scale); mBitmapShader.setLocalMatrix(mMatrix); mPaint.setShader(mBitmapShader); float half = getWidth() / 2f; if (mEnumFormat == 0)&#123; canvas.drawCircle(half, half, getWidth() / 2f, mPaint); &#125; else if(mEnumFormat == 1)&#123; mRectF.set(0, 0, getWidth(), getHeight()); canvas.drawRoundRect(mRectF, mRadius, mRadius, mPaint); &#125; &#125;&#125; 在 XML 中使用：123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:padding=&quot;20dp&quot; android:orientation=&quot;vertical&quot;&gt; &lt;com.xxt.xtest.TestView android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; app:src=&quot;@drawable/meinv&quot; app:format=&quot;circle&quot;/&gt; &lt;com.xxt.xtest.TestView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; app:src=&quot;@drawable/head&quot; app:format=&quot;circle&quot;/&gt; &lt;com.xxt.xtest.TestView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:layout_marginTop=&quot;10dp&quot; app:src=&quot;@drawable/meinv&quot; app:format=&quot;rectTangle&quot; app:radius=&quot;10&quot;/&gt; &lt;com.xxt.xtest.TestView android:layout_width=&quot;130dp&quot; android:layout_height=&quot;130dp&quot; android:layout_marginTop=&quot;10dp&quot; app:src=&quot;@drawable/head&quot; app:format=&quot;rectTangle&quot; app:radius=&quot;30&quot;/&gt; &lt;com.xxt.xtest.TestView android:layout_width=&quot;150dp&quot; android:layout_height=&quot;150dp&quot; android:layout_marginTop=&quot;10dp&quot; app:src=&quot;@drawable/meinv&quot; app:format=&quot;rectTangle&quot; app:radius=&quot;70&quot;/&gt;&lt;/LinearLayout&gt;]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07.3 精通自定义 View 之 绘图进阶——BlurMaskFilter 发光效果与图片阴影]]></title>
    <url>%2F2019%2F07%2F07%2FCustom%20View%2F07.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94BlurMaskFilter%20%E5%8F%91%E5%85%89%E6%95%88%E6%9E%9C%E4%B8%8E%E5%9B%BE%E7%89%87%E9%98%B4%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[在这张效果图中涉及三个发光效果：文字、图形和位图。 从最后一张美女位图所形成的发光效果中可以看到，与 setShadowLayer() 函数一样，发光效果也只会影响边缘部分图像，内部图像是不受影响的。 从第三幅图像（红绿各一半的位图）中可以看到：发光效果是无法指定发光颜色的，采用边缘部分的颜色取样来进行模糊发光。所以边缘是什么颜色，发出的光也就是什么颜色的。 所以初步我们对发光效果有如下结论： 与 setShadowLayer() 函数一样，发光效果使用的也是高斯模糊算法，并且只会影响边缘部分图像，内部图像是不受影响的。 发光效果是无法指定发光颜色的，采用边缘部分的颜色取样来进行模糊发光。所以边缘是什么颜色，发出的光也就是什么颜色的。 7.3.1 概述1public MaskFilter setMaskFilter(MaskFilter maskfilter) setMaskFilter() 函数中的 MaskFilter 也是没有具体实现的，是通过派生子类来实现具体的不同功能的。MaskFilter 有两个派生类：BlurMaskFilter 和 EmbossMaskFilter。其中，BlurMaskFilter 就能够实现发光效果；而 EmbossMaskFilter 则可以用于实现浮雕效果，用处很少，这里就不再讲解了。另一点需要注意的是，setMaskFilter() 函数是不支持硬件加速的，必须关闭硬件加速才可以。 BlurMaskFilter 的构造函数如下：1public BlurMaskFilter(float radius, Blur style) float radius：用来定义模糊半径，同样是高斯模糊算法。 Blur style：发光样式，有内 Blur.INNER(内发光)、Blur.SOLID(外发光)、Blur.NORMAL(内外发光)、Blur.OUTER(仅发光部分可见)。 上面效果图的示例代码如下：123456789101112131415161718192021222324252627282930public class TestView extends View &#123; private Paint mPaint = new Paint(); private Bitmap mHeadBmp; private Rect mRect; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; private void init()&#123; setLayerType(LAYER_TYPE_SOFTWARE, null); mPaint.setColor(Color.GREEN); mPaint.setTextSize(50); mHeadBmp = BitmapFactory.decodeResource(getResources(), R.drawable.head); mRect = new Rect(); mPaint.setMaskFilter(new BlurMaskFilter(40, BlurMaskFilter.Blur.SOLID)); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawText(&quot;xian小涛&quot;,100,100, mPaint); canvas.drawCircle(300,300,50, mPaint); mRect.set(300,500,300 + mHeadBmp.getWidth(),500 + mHeadBmp.getHeight()); canvas.drawBitmap(mHeadBmp,null, mRect, mPaint); &#125;&#125; BlurStyle 发光效果图 示例代码：12345678910111213141516171819202122232425262728293031323334353637public class TestView extends View &#123; private Paint mPaint; private BlurMaskFilter inner, solid, normal, outer; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mPaint.setColor(Color.RED); inner = new BlurMaskFilter(40, BlurMaskFilter.Blur.INNER); solid = new BlurMaskFilter(40, BlurMaskFilter.Blur.SOLID); normal = new BlurMaskFilter(40, BlurMaskFilter.Blur.NORMAL); outer = new BlurMaskFilter(40, BlurMaskFilter.Blur.OUTER); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setMaskFilter(inner); canvas.drawCircle(200,200,100, mPaint); canvas.translate(300, 0); mPaint.setMaskFilter(solid); canvas.drawCircle(200,200,100, mPaint); canvas.translate(300, 0); mPaint.setMaskFilter(normal); canvas.drawCircle(200,200,100, mPaint); canvas.translate(300, 0); mPaint.setMaskFilter(outer); canvas.drawCircle(200,200,100, mPaint); &#125;&#125; 其中，Blur.OUTER 比较特殊，在这种模式下仅显示发光效果，会把原图像中除发光部分外的其他部分全部变为透明。 7.3.2 给图片添加纯色阴影大家是否可以看出来发光效果与 setShadowLayer() 函数所生成的阴影之间有什么联系？ 先来分析一下 setShadowLayer() 函数的阴影形成过程（假定阴影画笔是灰色）。对于文字和图形，它首先产生一个跟原型一样的灰色副本。然后对这个灰色副本应用 BlurMaskFilter，使其内外发光；这样就形成了所谓的阴影，当然最后再偏移一段距离。 所以，我们要给图片添加灰色阴影效果，就可以仿照这个过程：先绘制一幅跟图片一样大小的灰色图像，然后给这个灰色图形应用 BlurMaskFilter 使其内外发光，最后偏移原图形一段距离绘制阴影。 这里涉及到三个点： 绘制一幅跟图片一样大小的灰色图像。 对灰色图像应用 BlurMaskFilter 使其内外发光。 偏移原图形一段距离绘制阴影。 1. 抽取灰色图像首先来看怎么能绘出一个指定位图所对应的灰色图像。我们知道 canvas.drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint) 中的画笔颜色对画出来的位图是没有任何影响的，所以，如果我们需要画一张对应的灰色图像，就需要新建一张一样大小的空白图，而且新图片的透明度要与原图片保持一致。这样一来，如何从原图片中抽出 Alpha 值成为关键。即我们只需要创建一个与原图片一样大小且Alpha相同的图片即可。 其实，Bitmap 中已经存在抽取出只具有 Alpha 值图片的函数：1public Bitmap extractAlpha(); 这个函数的功能是：新建一张空白图片，该图片具有与原图片一样的 Alpha 值，把这个新建的 Bitmap 作为结果返回。这个空白图片中每个像素都具有与原图片一样的 Alpha 值，而且具体的颜色是在使用canvas.drawBitmap() 函数绘制时由传入的画笔颜色指定的。 总结：extractAlpha() 会新建一幅仅具有 Alpha 值的空白图像，而且这张图像的颜色是在使用 canvas.drawBitmap() 函数绘制时传入的画笔颜色指定的。 下面拿一张图片来做实验，这张 PNG 图片中，只有一只小狗，其余地方都是透明色。 下面分别利用 extractAlpha() 函数画出该图片所对应的灰色和黑色阴影，效果图如下所示。 示例代码：12345678910111213141516171819202122232425262728293031323334public class TestView extends View &#123; private Paint mPaint; private Bitmap mBitmap, mAlphaBmp; private Rect mRect; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mRect = new Rect(); mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.dog); mAlphaBmp = mBitmap.extractAlpha(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int width = 200; int height = width * mAlphaBmp.getHeight() / mAlphaBmp.getWidth(); // 绘制原图 mRect.set(50, 50, 50 + width, 50 + height); canvas.drawBitmap(mBitmap, null, mRect, mPaint); // 绘制灰色阴影 canvas.translate(width + 100, 0); mPaint.setColor(Color.GRAY); canvas.drawBitmap(mAlphaBmp, null, mRect, mPaint); // 绘制黑色阴影 canvas.translate(width + 100, 0); mPaint.setColor(Color.BLACK); canvas.drawBitmap(mAlphaBmp, null, mRect, mPaint); &#125;&#125; 2. 绘制阴影在上面灰色纯色图像的基础上，将此灰色图像使用 BlurMaskFilter 使其内外发光。然后再在灰色模糊阴影的基础上画上原图像，就形成了模糊阴影。代码如下：123456789101112131415161718192021222324252627282930313233343536public class TestView extends View &#123; private Paint mPaint; private Bitmap mBitmap, mAlphaBmp; private Rect mRect; private BlurMaskFilter mFilter; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mRect = new Rect(); mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.dog); mAlphaBmp = mBitmap.extractAlpha(); mFilter = new BlurMaskFilter(30, BlurMaskFilter.Blur.NORMAL); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int width = 200; int height = width * mAlphaBmp.getHeight() / mAlphaBmp.getWidth(); mRect.set(50, 50, 50 + width, 50 + height); // 绘制灰色阴影 mPaint.setColor(Color.GRAY); mPaint.setMaskFilter(mFilter); canvas.drawBitmap(mAlphaBmp, null, mRect, mPaint); // 绘制原图 mPaint.setMaskFilter(null); canvas.translate(-10, -10); canvas.drawBitmap(mBitmap, null, mRect, mPaint); &#125;&#125; 效果如下图所示。 7.3.3 封装控件将它封装成一个控件，具有如下功能： 让用户定义图片内容。 让用户定义偏移距离。 让用户定义阴影颜色和阴影模糊程度。 可以使用wrap_content属性自适应大小。 下面程序经过多次测试，效果并不完美，待完善。 res/values/xshadow.xml12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;XShadowImageView&quot;&gt; &lt;attr name=&quot;src&quot; format=&quot;reference&quot;/&gt; &lt;attr name=&quot;shadowDx&quot; format=&quot;integer&quot; /&gt; &lt;attr name=&quot;shadowDy&quot; format=&quot;integer&quot; /&gt; &lt;attr name=&quot;shadowColor&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;shadowRadius&quot; format=&quot;float&quot;/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; src/…/XShadowImageView.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class XShadowImageView extends View &#123; private Paint mPaint; private Bitmap mBitmap, mShadowBitmap; private int mDx, mDy; private float mRadius; private int mShadowColor; private BlurMaskFilter mBlurMaskFilter; private Rect mRect; public XShadowImageView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(context, attrs); &#125; public XShadowImageView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context, attrs); &#125; private void init(Context context, @Nullable AttributeSet attrs) &#123; // 禁用硬件加速 setLayerType(LAYER_TYPE_SOFTWARE, null); // 提取属性 TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.XShadowImageView); mDx = ta.getInt(R.styleable.XShadowImageView_shadowDx, 0); mDy = ta.getInt(R.styleable.XShadowImageView_shadowDy, 0); mRadius = ta.getFloat(R.styleable.XShadowImageView_shadowRadius, 0); mShadowColor = ta.getInt(R.styleable.XShadowImageView_shadowColor, Color.BLACK); int bitmapId = ta.getResourceId(R.styleable.XShadowImageView_src, -1); if (bitmapId != -1) &#123; mBitmap = BitmapFactory.decodeResource(getResources(), bitmapId); &#125; ta.recycle(); // 其他初始化 mRect = new Rect(); mPaint = new Paint(); mPaint.setColor(mShadowColor); mBlurMaskFilter = new BlurMaskFilter(mRadius, BlurMaskFilter.Blur.NORMAL); if (mBitmap != null) &#123; mShadowBitmap = mBitmap.extractAlpha(); &#125; &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int measureWidth = MeasureSpec.getSize(widthMeasureSpec); int measureHeight = MeasureSpec.getSize(heightMeasureSpec); int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec); int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec); int width = mBitmap.getWidth(); int height = mBitmap.getHeight(); width = (measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth: width; height = (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight: height; setMeasuredDimension(width, height); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mBitmap != null) &#123; int width = getWidth() - mDx; int height = getHeight() - mDy; // 绘制阴影 mPaint.setMaskFilter(mBlurMaskFilter); mRect.set(mDx, mDy, width, height); canvas.drawBitmap(mShadowBitmap, null, mRect, mPaint); // 绘制原图像 mPaint.setMaskFilter(null); mRect.set(0, 0, width, height); canvas.drawBitmap(mBitmap, null, mRect, mPaint); &#125; &#125;&#125; 使用：12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:orientation=&quot;vertical&quot;&gt; &lt;com.xxt.xtest.XShadowImageView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:layout_gravity=&quot;center_horizontal&quot; app:src=&quot;@drawable/head&quot; app:shadowDx=&quot;30&quot; app:shadowDy=&quot;30&quot; app:shadowRadius=&quot;30.0&quot; app:shadowColor=&quot;@android:color/black&quot;/&gt; &lt;com.xxt.xtest.XShadowImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_horizontal&quot; app:src=&quot;@drawable/head&quot; app:shadowDx=&quot;30&quot; app:shadowDy=&quot;30&quot; app:shadowRadius=&quot;30.0&quot; app:shadowColor=&quot;@android:color/holo_red_dark&quot;/&gt; &lt;com.xxt.xtest.XShadowImageView android:layout_width=&quot;260dp&quot; android:layout_height=&quot;360dp&quot; android:layout_gravity=&quot;center_horizontal&quot; app:src=&quot;@drawable/meinv&quot; app:shadowDx=&quot;40&quot; app:shadowDy=&quot;40&quot; app:shadowRadius=&quot;40.0&quot; app:shadowColor=&quot;@android:color/holo_red_dark&quot;/&gt;&lt;/LinearLayout&gt;]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07.2 精通自定义 View 之 绘图进阶——setShadowLayer 与阴影效果]]></title>
    <url>%2F2019%2F07%2F07%2FCustom%20View%2F07.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94setShadowLayer%20%E4%B8%8E%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[利用 layer-list 只能实现按钮的阴影效果，对于文字和图片都无法实现阴影效果，除了 layer-list，我们只能用自定义控件来实现阴影效果了，Paint 中有一个专门用来实现阴影效果的函数 setShadowLayer，我们先来看看这个函数实现的阴影效果图： 从效果图中可以看出 setShadowLayer 函数能够实现： 定制阴影模糊程度 定制阴影偏移距离 清除阴影和显示阴影 7.2.1 setShadowLayer() 构造函数1. 概述1public void setShadowLayer(float radius, float dx, float dy, int color) float radius：意思是模糊半径，radius 越大越模糊，越小越清晰，但是如果 radius 设置为0，则阴影消失不见。 float dx：阴影的横向偏移距离，正值向右偏移，负值向左偏移。 float dy：阴影的纵向偏移距离，正值向下偏移，负值向上偏移。 int color：绘制阴影的画笔颜色，即阴影的颜色（对图片阴影无效）。 setShadowLayer 使用的是高斯模糊算法，高斯模糊的具体算法是：对于正在处理的每一个像素，取周围若干个像素的 RGB 值并且平均，然后这个平均值就是模糊处理过的像素。如果对图片中的所有像素都这么处理的话，处理完成的图片就会变得模糊。其中，所取周围像素的半径就是模糊半径。所以，模糊半径越大，所得平均像素与原始像素相差就越大，也就越模糊。 绘制阴影的画笔颜色为什么对图片无效？ 从上面的效果图中可以看出，使用 setShadowLayer 所产生的阴影，对于文字和绘制的图形的阴影都是使用自定义的阴影画笔颜色来画的；而图片的阴影则是直接产生一张相同的图片，仅对阴影图片的边缘进行模糊。之所以生成一张相同的背景图片，是因为如果统一使用某一种颜色来做阴影可能会与图片的颜色相差很大，而且不协调，比如某张图片的色彩非常丰富，而阴影如果使用灰色来做，可能就会显得很突兀，所以为了解决这个问题，针对图片的阴影就不再是统一颜色了，而是复制出这张图片，把复制出的图片的边缘进行模糊，做为阴影。但这样又会引起一个问题，就是如果我们想把图片的阴影做成灰色怎么办？使用 setShadowLayer 自动生成阴影是没办法了，在下篇我们会具体来讲，如何给图片添加指定颜色的阴影。 注意：setShadowLayer 只有文字绘制阴影支持硬件加速，其它都不支持硬件加速，为了方便起见，需要在自定义控件中禁用硬件加速。 2. 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class TestView extends View &#123; private Paint mPaint = new Paint(); private Bitmap mHeadBmp; private Rect mRect; private int mRadius = 1; private int mDx = 10; private int mDy = 10; private boolean mSetShadow = true; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; private void init()&#123; setLayerType(LAYER_TYPE_SOFTWARE, null); mPaint.setColor(Color.GREEN); mPaint.setTextSize(50); mHeadBmp = BitmapFactory.decodeResource(getResources(), R.drawable.head); mRect = new Rect(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mSetShadow) &#123; mPaint.setShadowLayer(mRadius, mDx, mDy, Color.GRAY); &#125; else &#123; mPaint.clearShadowLayer(); &#125; canvas.drawText(&quot;xian小涛&quot;,100,100, mPaint); canvas.drawCircle(200,200,50, mPaint); mRect.set(200,300,200 + mHeadBmp.getWidth(),300 + mHeadBmp.getHeight()); canvas.drawBitmap(mHeadBmp,null, mRect, mPaint); &#125; public void changeRadius() &#123; mRadius++; postInvalidate(); &#125; public void changeDx() &#123; mDx+=5; postInvalidate(); &#125; public void changeDy() &#123; mDy+=5; postInvalidate(); &#125; public void clearShadow()&#123; mSetShadow = false; postInvalidate(); &#125; public void showShadow()&#123; mSetShadow = true; postInvalidate(); &#125;&#125; 使用代码：1234567891011121314151617181920212223242526272829303132333435363738public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private TestView mView; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); mView = findViewById(R.id.view); findViewById(R.id.radius_btn).setOnClickListener(this); findViewById(R.id.dx_btn).setOnClickListener(this); findViewById(R.id.dy_btn).setOnClickListener(this); findViewById(R.id.clear_btn).setOnClickListener(this); findViewById(R.id.show_btn).setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.radius_btn: mView.changeRadius(); break; case R.id.dx_btn: mView.changeDx(); break; case R.id.dy_btn: mView.changeDy(); break; case R.id.clear_btn: mView.clearShadow(); break; case R.id.show_btn: mView.showShadow(); break; &#125; &#125;&#125; 7.2.2 清除阴影清除阴影其实有两个方法，可以将setShadowLayer的radius的值设为0，也可以使用专门的清除阴影的函数：1public void clearShadowLayer() 具体效果见上面例子。 7.2.3 示例：给文字添加阴影 从图中可以看到，TextView、Button、EditText 中的文字自定添加了阴影。而且对于 EditText 而言，新输入的文字依然有阴影效果。 setShadowLayer 是 API 1 就已经引入的函数，而且添加了 TextView 类 和 TextView 的派生类来支持阴影设置。TextView 的派生类如下图所示。 1. 通过 XML 属性添加阴影123456&lt;TextView ...... android:shadowRadius=&quot;3&quot; android:shadowDx=&quot;5&quot; android:shadowDy=&quot;5&quot; android:shadowColor=&quot;@android:color/darker_gray&quot;/&gt; 示例：123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;使用XML添加阴影效果&quot; android:shadowRadius=&quot;3&quot; android:shadowDx=&quot;5&quot; android:shadowDy=&quot;5&quot; android:shadowColor=&quot;@android:color/darker_gray&quot;/&gt; &lt;Button android:id=&quot;@+id/radius_btn&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;使用XML添加阴影效果&quot; android:shadowRadius=&quot;3&quot; android:shadowDx=&quot;5&quot; android:shadowDy=&quot;5&quot; android:shadowColor=&quot;@android:color/darker_gray&quot;/&gt; &lt;EditText android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;使用XML添加阴影效果&quot; android:shadowRadius=&quot;3&quot; android:shadowDx=&quot;5&quot; android:shadowDy=&quot;5&quot; android:shadowColor=&quot;@android:color/darker_gray&quot;/&gt;&lt;/LinearLayout&gt; 2. 代码实现TextView 及其派生类都有一个 Paint.setShadowLayer 的同名方法：1public void setShadowLayer(float radius, float dx, float dy, int color) 示例：12TextView tv = findViewById(R.id.tv);tv.setShadowLayer(3, 5, 5, Color.GRAY);]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07.1 精通自定义 View 之 绘图进阶——贝济埃曲线]]></title>
    <url>%2F2019%2F07%2F07%2FCustom%20View%2F07.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E8%B4%9D%E6%B5%8E%E5%9F%83%E6%9B%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[7.1.1 概述在 Path 的系列函数中，除了一些基本的设置和绘图用法外，还有一个强大的工具——贝济埃曲线。它能将利用 moveTo、lineTo 连接的生硬路径变得平滑，也能够实现很多炫酷的效果，比如水波纹等。 1. 贝赛尔曲线来源贝塞尔曲线于 1962 年，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由 Paul de Casteljau 于 1959 年运用 de Casteljau 算法开发，以稳定数值的方法求出贝塞尔曲线。 在数学的数值分析领域中，贝赛尔曲线（Bézier 曲线）是电脑图形学中相当重要的参数曲线。更高维度的广泛化贝塞尔曲线就称作贝塞尔曲面，其中贝塞尔三角是一种特殊的实例。 2. 贝济埃曲线公式1）一阶贝济埃曲线 P0 为起点、P1 为终点，t 表示当前时间，B(t) 表示公式的结果值。注意，曲线的意义就是公式结果 B(t) 随时间的变化，其取值所形成的轨迹。在动画中，黑色点表示在当前时间 t 下公式 B(t) 的取值。而红色的那条线就不在各个时间点下不同取值的 B(t) 所形成的轨迹。 总而言之：对于一阶贝济埃曲线，大家可以理解为在起始点和终点形成的这条直线上，匀速移动的点。 2）二阶贝济埃曲线 在这里 P0 是起始点，P2 是终点，P1 是控制点。假设将时间定在 t=0.25 的时刻，此时的状态如下图所示： 首先，P0 点和 P1 点形成了一条贝济埃曲线，还记得我们上面对一阶贝济埃曲线的总结么：就是一个点在这条直线上做匀速运动；所以 P0-P1 这条直线上的移动的点就是 Q0。 同样，P1、P2 形成了一条一阶贝济埃曲线，在这条一阶贝济埃曲线上，它们的随时间移动的点是 Q1。 最后，动态点 Q0 和 Q1 又形成了一条一阶贝济埃曲线，在它们这条一阶贝济埃曲线动态移动的点是 B。而 B 的移动轨迹就是这个二阶贝济埃曲线的最终形态。从上面的讲解大家也可以知道，之所以叫它二阶贝济埃曲线是因为，B 的移动轨迹是建立在两个一阶贝济埃曲线的中间点 Q0、Q1 的基础上的。 在理解了二阶贝赛尔曲线的形成原理以后，我们就不难理解三阶贝赛尔曲线了。 3）三阶贝济埃曲线 同样，我们取其中一点来讲解轨迹的形成原理，当 t=0.25 时,此时状态如下： 同样，P0 是起始点，P3 是终点；P1 是第一个控制点，P2 是第二个控制点。 首先，这里有三条一阶贝济埃曲线，分别是 P0-P1、P1-P2、P2-P3，他们随时间变化的点分别为 Q0、Q1、Q2。然后是由 Q0、Q1、Q2 这三个点，再次连接，形成了两条一阶贝济埃曲线，分别是Q0-Q1、Q1-Q2，他们随时间变化的点为 R0、R1。 同样，R0 和 R1 同样可以连接形成一条一阶贝济埃曲线，在 R0-R1 这条贝赛尔曲线上随时间移动的点是 B，而 B 的移动轨迹就是这个三阶贝济埃曲线的最终形状。 从上面的解析大家可以看出，所谓几阶贝济埃曲线，全部是由一条条一阶贝济埃曲线搭起来的。在上图中，形成一阶贝济埃曲线的直线是灰色的，形成二阶贝济埃曲线线是绿色的，形成三阶贝济埃曲线的线是蓝色的。 在理解了上面的二阶和三阶贝济埃曲线以后，我们再来看几个贝济埃曲线的动态图。 4）四阶贝济埃曲线 5）五阶贝济埃曲线 3. 贝济埃曲线与 PhotoShop 钢笔工具在专业绘图工具 Photoshop 中，有一个钢笔工具，它使用的路径弯曲效果就是二阶贝济埃曲线，下面利用 Photoshop 的钢笔工具来得出二阶贝济埃曲线的相关控制点。 我们拿最终成形的图形来看一下为什么钢笔工具是二阶贝济埃曲线： 右图演示的假设某一点 t=0.25 时，动态点 B 的位置图。同样，这里 P0 是起始点，P2 是终点，P1 是控制点。P0-P1、P1-P2 形成了第一层的一阶贝济埃曲线。它们随时间的动态点分别是 Q0、Q1；动态点 Q0、Q1 又形成了第二层的一阶贝济埃曲线，它们的动态点是 B。而 B 的轨迹跟钢笔工具的形状是完全一样的，所以说钢笔工具的拉伸效果使用的是二阶贝济埃曲线。 这里需要注意的是，我们在使用钢笔工具时，拖动的是 P5 点。其实二阶贝济埃曲线的控制点是其对面的 P1 点，钢笔工具这样设计是当然是因为操作起来比较方便。 7.1.2 贝济埃曲线之 quadTo在 Path 类中有四个方法与贝济埃曲线相关，分别是：123456// 二阶济埃尔public void quadTo(float x1, float y1, float x2, float y2)public void rQuadTo(float dx1, float dy1, float dx2, float dy2)// 三阶济埃尔public void cubicTo(float x1, float y1, float x2, float y2,float x3, float y3)public void rCubicTo(float x1, float y1, float x2, float y2,float x3, float y3) 在这四个函数中 quadTo、rQuadTo 是二阶贝济埃曲线，cubicTo、rCubicTo 是三阶贝济埃曲线；我们这篇文章以二阶贝济埃曲线的 quadTo、rQuadTo 为主，三阶贝济埃曲线 cubicTo、rCubicTo 用的使用方法与二阶贝济埃曲线类似，用处也比较少，这篇就不再细讲了。 1. quadTo 使用原理1public void quadTo(float x1, float y1, float x2, float y2) 参数中 (x1,y1) 是控制点坐标，(x2,y2) 是终点坐标。大家可能会有一个疑问：有控制点和终点坐标，那起始点是多少呢？整条线的起始点是通过 Path.moveTo(x,y) 来指定的，而如果我们连续调用 quadTo()，前一个 quadTo() 的终点，就是下一个 quadTo() 函数的起点；如果初始没有调用 Path.moveTo(x,y) 来指定起始点，则默认以控件左上角(0,0)为起始点。大家可能还是有点迷糊，下面我们就举个例子来看看，我们利用 quadTo() 来画下面的这条波浪线： 下面分析一下，在这条路径轨迹中，控制点分别在哪个位置，如下图所示。 我们先看 P0-P2 这条轨迹，P0 是起点，假设位置坐标是 (100,300)，P2 是终点，假充位置坐标是 (300,300)；在以 P0 为起始点，P2 为终点这条二阶贝济埃曲线上，P1 是控制点，很明显 P1 大概在 P0、P2 中间的位置，所以它的 X 坐标应该是 200，关于 Y 坐标，我们无法确定，但很明显的是 P1 在 P0、P2 点的上方，也就是它的 Y 值比它们的小，所以根据钢笔工具上面的位置，我们让 P1 的比 P0、P2 的小 100，所以 P1的坐标是 (200，200)。 同理，不难求出在 P2-P4 这条二阶贝济埃曲线上，它们的控制点 P3 的坐标位置应该是 (400,400)。 所以我们就可以自定义一个控件，并重写它的 onDraw() 函数。123456789101112131415161718192021222324public class TestView extends View &#123; private Paint mPaint; private Path mPath; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setStrokeWidth(4); mPaint.setColor(Color.GRAY); mPaint.setStyle(Paint.Style.STROKE); mPaint.setAntiAlias(true); mPath = new Path(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPath.moveTo(100, 300); mPath.quadTo(200, 200, 300, 300); mPath.quadTo(400, 400, 500, 300); canvas.drawPath(mPath, mPaint); &#125;&#125; 通过这个例子希望大家知道两点： 整条线的起始点是通过 Path.moveTo(x,y) 来指定的，如果初始没有调用 Path.moveTo(x,y) 来指定起始点，则默认以控件左上角 (0,0) 为起始点。 如果我们连续调用 quadTo()，前一个 quadTo() 的终点，就是下一个 quadTo() 函数的起点。 2. 示例：手指轨迹要实现手指轨迹其实是非常简单的，我们只需要在自定义中拦截 OnTouchEvent，然后根据手指的移动轨迹来绘制 Path 即可。最简单的方法就是直接使用 Path.lineTo() 就能实现把各个点连接起来。 123456789101112131415161718192021222324252627282930313233343536public class TestView extends View &#123; private Paint mPaint; private Path mPath; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.GREEN); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(4); mPath = new Path(); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: mPath.moveTo(event.getX(), event.getY()); return true; case MotionEvent.ACTION_MOVE: mPath.lineTo(event.getX(), event.getY()); invalidate(); break; default: break; &#125; return super.onTouchEvent(event); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawPath(mPath, mPaint); &#125;&#125; 虽然实现了画出手指的移动轨迹，但我们仔细来看看画出来的图： 我们把轨迹放大，明显看出，在两个点连接处有明显的转折，而且在轨迹顶部位置横纵坐标变化比较快的位置，看起来跟图片这大后的马赛克一样；利用 Path 绘图，是不可能出现马赛克的，因为除了 Bitmap 以外的任何 canvas 绘图全部都是矢量图，也就是利用数学公式来作出来的图，无论放在多大屏幕上，都不可能会出现马赛克。这里利用 Path 绘图，在轨迹顶部之所以看起来像是马赛克是因为这个轨迹是由各个不同点之间连线写出来的，而之间并没有平滑过渡，所以当坐标变化比较剧烈时，线与线之间的转折就显得特别明显了。 所以要想优化这种效果，就得实现线与线之间的平滑过渡，很显然，二阶贝济埃曲线就是干这个事的。下面我们就利用我们新学的 Path.quadTo 函数来重新实现下移动轨迹效果。 3. 优化：使用 Path.quadTo() 函数实现手势过渡使用 Path.lineTo() 的最大问题就是线段转折处不够平滑。Path.quadTo() 可以实现平滑过渡，但使用 Path.quadTo() 的最大问题是，如何找到起始点和结束点。 下图中，有用绿点表示的三个点，连成的两条直线，很明显他们转折处是有明显折痕的 下面我们在 PhotoShop 中利用钢笔工具，看如何才能实现这两条线之间的转折。 最终的贝济埃曲线连接如下图所示。 从这两个线段中可以看出，我们使用 Path.lineTo() 的时候，是直接把手指触点 A、B、C 给连起来。而钢笔工具要实现这三个点间的流畅过渡，就只能将这两个线段的中间点做为起始点和结束点，而将手指的倒数第二个触点 B 做为控制点。 大家可能会觉得，那这样，在结束的时候，A 到 P0 和 P1 到 C1 的这段距离岂不是没画进去？是的，如果 Path 最终没有 close 的话，这两段距离是被抛弃掉的。因为手指间滑动时，每两个点间的距离很小，所以 P1 到 C 之间的距离可以忽略不计。 下面我们就利用这种方法在photoshop中求证，在连接多个线段时，是否能行？ 在这个图形中，有很多点连成了弯弯曲曲的线段，我们利用上面我们讲的，将两个线段的中间做为二阶贝济埃曲线的起始点和终点，把上一个手指的位置做为控制点，来看看是否真的能组成平滑的连线整个连接过程如动画所示： 在最终的路径中看来，各个点间的连线是非常平滑的。从这里也可以看出，在为了实现平滑效果，我们只能把开头的线段一半和结束的线段的一半抛弃掉。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class TestView extends View &#123; private Paint mPaint; private Path mPath; private float mPreX, mPreY; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.GREEN); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(4); mPath = new Path(); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: mPath.moveTo(event.getX(), event.getY()); mPreX = event.getX(); mPreY = event.getY(); return true; case MotionEvent.ACTION_MOVE: float endX = (mPreX + event.getX()) / 2; float endY = (mPreY + event.getY()) / 2; mPath.quadTo(mPreX, mPreY, endX, endY); mPreX = event.getX(); mPreY = event.getY(); invalidate(); break; default: break; &#125; return super.onTouchEvent(event); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawPath(mPath, mPaint); &#125;&#125; 7.1.3 贝济埃曲线之 rQuadTo1. 概述1public void rQuadTo(float dx1, float dy1, float dx2, float dy2) dx1：控制点 X 坐标，表示相对上一个终点 X 坐标的位移坐标，可为负值，正值表示相加，负值表示相减。 dy1：控制点 Y 坐标，表示相对上一个终点 Y 坐标的位移坐标。同样可为负值，正值表示相加，负值表示相减。 dx2：终点 X 坐标，同样是一个相对坐标，相对上一个终点 X 坐标的位移值，可为负值，正值表示相加，负值表示相减。 dy2：终点 Y 坐标，同样是一个相对，相对上一个终点 Y 坐标的位移值。可为负值，正值表示相加，负值表示相减。 这四个参数都是传递的都是相对值，相对上一个终点的位移值。 比如，我们上一个终点坐标是 (300,400) 那么利用，rQuadTo(100,-100,200,100) 得到的控制点坐标是 (300+100, 400-100) 即 (500,300)；同样，得到的终点坐标是 (300+200, 400+100)，即 (500,500)。1234567// 利用 quadTo 定义一个绝对坐标：path.moveTo(300,400);path.quadTo(500,300,500,500);// 与利用 rQuadTo 定义相对坐标是等价的：path.moveTo(300,400);path.rQuadTo(100,-100,200,100) 2. 使用 rQuadTo() 函数实现波浪线123456789mPath.moveTo(100, 300);/*mPath.quadTo(200, 200, 300, 300);mPath.quadTo(400, 400, 500, 300);*/// 替换成mPath.rQuadTo(100, -100, 200, 0);mPath.rQuadTo(100, 100, 200, 0);canvas.drawPath(mPath, mPaint); 第一句：path.rQuadTo(100,-100,200,0); 是建立在 (100,300) 这个点基础上来计算相对坐标的，所以：控制点X坐标 = 上一个终点X坐标+控制点X位移 = 100+100=200；控制点Y坐标 = 上一个终点Y坐标+控制点Y位移 = 300-100=200；终点X坐标 = 上一个终点X坐标+终点X位移 = 100+200=300；终点Y坐标 = 上一个终点Y坐标+终点Y位移 = 300+0=300;所以这句与 path.quadTo(200,200,300,300); 对等的。 第二句：path.rQuadTo(100,100,200,0); 是建立在它的前一个终点即 (300,300) 的基础上来计算相对坐标的，所以：控制点X坐标 = 上一个终点X坐标+控制点X位移 = 300+100=200；控制点Y坐标 = 上一个终点Y坐标+控制点Y位移 = 300+100=200；终点X坐标 = 上一个终点X坐标+终点X位移 = 300+200=500；终点Y坐标 = 上一个终点Y坐标+终点Y位移 = 300+0=300;所以这句与 path.quadTo(400,400,500,300); 对等的。 最终效果也是一样的。 通过这个例子，只想让大家明白一点：rQuadTo(float dx1, float dy1, float dx2, float dy2) 中的位移坐标，都是以上一个终点位置为基准来做偏移的。 7.1.4 示例：波浪效果 我们将 mPath 的起始位置向左移一个波长，然后利用 for 循环画出当前屏幕中可能容得下的所有波。然后画一个波的左右两个半波：1234// 画的是一个波长中的前半个波mPath.rQuadTo(halfWaveLen/2, -100, halfWaveLen, 0); // 画的是一个波长中的后半个波mPath.rQuadTo(halfWaveLen/2, 100, halfWaveLen, 0); 大家在这里可以看到，屏幕左右都多画了一个波长的图形。这是为了波形移动做准备的。 让波纹动起来其实挺简单，利用调用在 path.moveTo 的时候，将起始点向右移动即可实现移动，而且只要我们移动一个波长的长度，波纹就会重合，就可以实现无限循环了。 完整的代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class TestView extends View &#123; private Paint mPaint; private Path mPath; private int mItemWaveLength = 1000; private int dx; public TestView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPath = new Path(); mPaint = new Paint(); mPaint.setColor(Color.GREEN); mPaint.setStyle(Paint.Style.FILL_AND_STROKE); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPath.reset(); int originY = 300; int halfWaveLen = mItemWaveLength/2; mPath.moveTo(-mItemWaveLength+dx,originY); for (int i = -mItemWaveLength; i&lt;=getWidth()+mItemWaveLength; i+=mItemWaveLength)&#123; mPath.rQuadTo(halfWaveLen/2f,-100,halfWaveLen,0); mPath.rQuadTo(halfWaveLen/2f,100,halfWaveLen,0); &#125; mPath.lineTo(getWidth(),getHeight()); mPath.lineTo(0,getHeight()); mPath.close(); canvas.drawPath(mPath,mPaint); &#125; public void startAnim()&#123; ValueAnimator animator = ValueAnimator.ofInt(0,mItemWaveLength); animator.setDuration(2000); animator.setRepeatCount(ValueAnimator.INFINITE); animator.setInterpolator(new LinearInterpolator()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; dx = (int)animation.getAnimatedValue(); postInvalidate(); &#125; &#125;); animator.start(); &#125;&#125; 使用 TestView1234567891011public class MainActivity extends AppCompatActivity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); TestView view = findViewById(R.id.view); view.startAnim(); &#125;&#125;]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06.3 精通自定义 View 之 Paint 基本使用——常用函数]]></title>
    <url>%2F2019%2F07%2F06%2FCustom%20View%2F06.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[6.1.1 基本函数设置我们先来看一下paint中基本设置的函数都有哪些。123456789101112131415161718192021222324252627// 重置画笔reset()// 给画笔设置颜色值setColor(int color)// 设置颜色，利用 ARGB 分开设置setARGB(int a, int r, int g, int b)// 设置画笔透明度setAlpha(int a)// 设置画笔样式，取值有：Paint.Style.FILL、STROKE、FILL_AND_STROKEsetStyle(Paint.Style style)// 设置画笔宽度setStrokeWidth(float width)// 设置画笔是否抗锯齿setAntiAlias(boolean aa)// 设置线冒样式，取值有Cap.ROUND(圆形线冒)、// Cap.SQUARE(方形线冒)、Paint.Cap.BUTT(无线冒)setStrokeCap(Paint.Cap cap)// 设置线段连接处样式，取值有：Join.MITER（结合处为锐角）、// Join.Round(结合处为圆弧)、Join.BEVEL(结合处为直线)setStrokeJoin(Paint.Join join)// 设置笔画的倾斜度，区别不明显setStrokeMiter(float miter)// 设置路径样式。取值类型是所有派生自 PathEffect 的子类：// ComposePathEffect、CornerPathEffect、DashPathEffect、// DiscretePathEffect、PathDashPathEffect、SumPathEffectsetPathEffect(PathEffect effect) 1. setStrokeCap(Paint.Cap cap)设置线帽样式，取值有 Cap.ROUND (圆形线帽)、Cap.SQUARE (方形线帽)、Paint.Cap.BUTT (无线帽) 红线左侧多出来的区域就是线帽。 1234567891011121314151617181920212223242526272829303132333435public class TestView extends View &#123; private Paint mPaint; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.GREEN); mPaint.setStrokeWidth(80); mPaint.setStyle(Paint.Style.STROKE); mPaint.setAntiAlias(true); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 无线帽 mPaint.setStrokeCap(Paint.Cap.BUTT); canvas.drawLine(100, 200, 400, 200, mPaint); // 方形线帽 mPaint.setStrokeCap(Paint.Cap.SQUARE); canvas.drawLine(100, 400, 400, 400, mPaint); // 圆形线帽 mPaint.setStrokeCap(Paint.Cap.ROUND); canvas.drawLine(100, 600, 400, 600, mPaint); // 画辅助线 mPaint.reset(); mPaint.setStrokeWidth(2); mPaint.setColor(Color.RED); canvas.drawLine(100, 50, 100, 750, mPaint); &#125;&#125; 2. setStrokeJoin(Paint.Join join)参数取值有：Join.MITER (结合处为锐角)、Join.Round (结合处为圆弧)、Join.BEVEL(结合处为直线) 示例： 123456789101112131415161718192021222324252627282930313233343536373839public class TestView extends View &#123; private Paint mPaint; private Path mPath; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.GREEN); mPaint.setStrokeWidth(40); mPaint.setStyle(Paint.Style.STROKE); mPaint.setAntiAlias(true); mPath = new Path(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 结合处为锐角 MITER mPath.moveTo(100, 100); mPath.lineTo(250, 100); mPath.lineTo(100, 250); mPaint.setStrokeJoin(Paint.Join.MITER); canvas.drawPath(mPath, mPaint); // 结合处为圆弧 ROUND mPath.moveTo(300, 100); mPath.lineTo(450, 100); mPath.lineTo(300, 250); mPaint.setStrokeJoin(Paint.Join.ROUND); canvas.drawPath(mPath, mPaint); // 结合处为直线 BEVEL mPath.moveTo(500, 100); mPath.lineTo(650, 100); mPath.lineTo(500, 250); mPaint.setStrokeJoin(Paint.Join.BEVEL); canvas.drawPath(mPath, mPaint); &#125;&#125; 3. setPathEffect(PathEffect effect)设置路径样式。取值类型是所有派生自 PathEffect 的子类：ComposePathEffect、CornerPathEffect、DashPathEffect、DiscretePathEffect、PathDashPathEffect、SumPathEffect。 1）CornerPathEffect它的作用就是将原来 Path 生硬的直线拐角，变成圆形拐角。1public CornerPathEffect(float radius) 参数 radius：即当前连接两条直线所使用的圆的半径。 示例： 123456789101112131415161718192021222324252627282930313233343536public class TestView extends View &#123; private Paint mPaint; private Path mPath; private CornerPathEffect effect100, effect200; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.GREEN); mPaint.setStrokeWidth(4); mPaint.setStyle(Paint.Style.STROKE); mPaint.setAntiAlias(true); mPath = new Path(); effect100 = new CornerPathEffect(100); effect200 = new CornerPathEffect(200); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPath.moveTo(100,600); mPath.lineTo(400,100); mPath.lineTo(700,900); canvas.drawPath(mPath, mPaint); mPaint.setColor(Color.RED); mPaint.setPathEffect(effect100); canvas.drawPath(mPath, mPaint); mPaint.setColor(Color.BLUE); mPaint.setPathEffect(effect200); canvas.drawPath(mPath, mPaint); &#125;&#125; 2）DashPathEffect 虚线效果1public DashPathEffect(float intervals[], float phase) phase：开始绘制的偏移值。intervals[]：表示组成虚线的各个线段的长度；整条虚线就是由intervals[] 中这些基本线段循环组成的。比如，我们定义new float[] {20,10}；那这个虚线段就是由两段线段组成的，第一个可见的线段长为20，每二个线段不可见，长度为10。 对于 intervals[] 数组的有两个限定： 长度必须大于等于 2；因为必须有一个实线段和一个空线段来组成虚线。 个数必须为偶数，如果是基数，最后一个数字将被忽略；这个很好理解，因为一组虚线的组成必然是一个实线和一个空线成对组成的。 示例： 1234567891011121314151617181920212223242526272829303132333435363738public class TestView extends View &#123; private Paint mPaint; private Path mPath; private DashPathEffect effect1, effect2; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.GREEN); mPaint.setStrokeWidth(4); mPaint.setStyle(Paint.Style.STROKE); mPaint.setAntiAlias(true); mPath = new Path(); effect1 = new DashPathEffect(new float[]&#123;20,10,100,100&#125;,0); effect2 = new DashPathEffect(new float[]&#123;20,10,50,100&#125;,15); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPath.moveTo(100,600); mPath.lineTo(400,100); mPath.lineTo(700,900); canvas.drawPath(mPath, mPaint); mPaint.setColor(Color.RED); mPaint.setPathEffect(effect1); canvas.translate(0, 100); canvas.drawPath(mPath, mPaint); mPaint.setColor(Color.BLUE); mPaint.setPathEffect(effect2); canvas.translate(0, 100); canvas.drawPath(mPath, mPaint); &#125;&#125; 3）DiscretePathEffect 离散路径效果DiscretePathEffect 就是将原来路径分隔成定长的线段，然后将每条线段随机偏移一段位置，我们可以用它来模拟一种类似生锈铁丝的效果。1public DiscretePathEffect(float segmentLength, float deviation) 参数 segmentLength：表示将原来的路径切成多长的线段。如果值为2，那么这个路径就会被切成一段段由长度为 2 的小线段。所以这个值越小，所切成的小线段越多；这个值越大，所切成的小线段越少。 参数 deviation：表示被切成的每个小线段的可偏移距离。值越大，就表示每个线段的可偏移距离就越大，就显得越凌乱，值越小，每个线段的可偏移原位置的距离就越小。 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class TestView extends View &#123; private Paint mPaint; private Path mPath; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mPaint = getPaint(); mPath = getPath(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 第一条原生 Path canvas.drawPath(mPath, mPaint); // 第二条 Path canvas.translate(0,200); mPaint.setPathEffect(new DiscretePathEffect(2,5)); canvas.drawPath(mPath, mPaint); // 第三条 Path canvas.translate(0,200); mPaint.setPathEffect(new DiscretePathEffect(6,5)); canvas.drawPath(mPath, mPaint); // 第四条 Path canvas.translate(0,200); mPaint.setPathEffect(new DiscretePathEffect(6,15)); canvas.drawPath(mPath, mPaint); &#125; private Path getPath()&#123; Path path = new Path(); // 定义路径的起点 path.moveTo(0, 0); // 定义路径的各个点 for (int i = 0; i &lt;= 40; i++) &#123; path.lineTo(i*35, (float) (Math.random() * 150)); &#125; return path; &#125; private Paint getPaint()&#123; Paint paint = new Paint(); paint.setStrokeWidth(4); paint.setColor(Color.GREEN); paint.setStyle(Paint.Style.STROKE); paint.setAntiAlias(true); return paint; &#125;&#125; 4）PathDashPathEffect 印章路径效果它的作用就是用另一个路径图案做为印章，沿着指定路径一个个盖上去。1public PathDashPathEffect(Path shape, float advance, float phase,Style style) Path shape：表示印章路径，比如我们下面示例中的三角形加右上角一个点。 float advance：表示两个印章路径间的距离，印章间距离越大，间距就越大。 float phase：路径绘制偏移距离，与上面 DashPathEffect 中的 float phase 参数意义相同。 Style style：表示在遇到转角时，如何操作印章以使转角平滑过渡，取值有：Style.ROTATE，Style.MORPH，Style.TRANSLATE；Style.ROTATE 表示通过旋转印章来过渡转角；Style.MORPH 表示通过变形印章来过渡转角；Style.TRANSLATE 表示通过位移来过渡转角。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class TestView extends View &#123; private Paint mPaint; private Path mPath; private PathDashPathEffect mEffectMORPH, mEffectROTATE, mEffectTRANSLATE; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mPaint = getPaint(); mPath = getPath(); // 构建印章路径 Path stampPath = getStampPath(); stampPath.addCircle(0,0,3, Path.Direction.CCW); mEffectMORPH = new PathDashPathEffect(stampPath,35,0, PathDashPathEffect.Style.MORPH); mEffectROTATE = new PathDashPathEffect(stampPath,35,0, PathDashPathEffect.Style.ROTATE); mEffectTRANSLATE = new PathDashPathEffect(stampPath,35,0, PathDashPathEffect.Style.TRANSLATE); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 原始线 canvas.drawPath(mPath, mPaint); // 使用印章路径效果 MORPH canvas.translate(0,200); mPaint.setPathEffect(mEffectMORPH); canvas.drawPath(mPath, mPaint); // 使用印章路径效果 ROTATE canvas.translate(0,200); mPaint.setPathEffect(mEffectROTATE); canvas.drawPath(mPath, mPaint); // 使用印章路径效果 TRANSLATE canvas.translate(0,200); mPaint.setPathEffect(mEffectTRANSLATE); canvas.drawPath(mPath, mPaint); &#125; private Path getPath()&#123; Path path = new Path(); // 定义路径的起点 path.moveTo(0, 0); // 定义路径的各个点 for (int i = 0; i &lt;= 40; i++) &#123; path.lineTo(i*35, (float) (Math.random() * 150)); &#125; return path; &#125; private Path getStampPath()&#123; Path path = new Path(); path.moveTo(0,20); path.lineTo(10,0); path.lineTo(20,20); path.close(); path.addCircle(0,0,3, Path.Direction.CCW); return path; &#125; private Paint getPaint()&#123; Paint paint = new Paint(); paint.setStrokeWidth(4); paint.setColor(Color.GREEN); paint.setStyle(Paint.Style.STROKE); paint.setAntiAlias(true); return paint; &#125;&#125; 5）ComposePathEffect &amp; SumPathEffect这两个都是用来合并两个特效的。但它们之间是有区别的：12public ComposePathEffect(PathEffect outerpe, PathEffect innerpe)public SumPathEffect(PathEffect first, PathEffect second) ComposePathEffect 合并两个特效是有先后顺序的，它会先将第二个参数的 PathEffect innerpe 的特效作用于路径上，然后再在此加了特效的路径上作用第一个特效。 而 SumPathEffect 是分别对原始路径分别作用第一个特效和第二个特效。然后再将这两条路径合并，做为最终结果。 示例： 1234567891011121314151617181920212223242526272829// 画原始路径Paint paint = getPaint();Path path = getPath();canvas.drawPath(path,paint); // 仅应用圆角特效的路径canvas.translate(0,200);CornerPathEffect cornerPathEffect = new CornerPathEffect(100);paint.setPathEffect(cornerPathEffect);canvas.drawPath(path,paint); // 仅应用虚线特效的路径canvas.translate(0,200);DashPathEffect dashPathEffect = new DashPathEffect(new float[]&#123;2,5,10,10&#125;,0);paint.setPathEffect(dashPathEffect);canvas.drawPath(path,paint); // 利用 ComposePathEffect 先应用圆角特效，再应用虚线特效canvas.translate(0,200);ComposePathEffect composePathEffect = new ComposePathEffect(dashPathEffect,cornerPathEffect);paint.setPathEffect(composePathEffect);canvas.drawPath(path,paint); // 利用 SumPathEffect，分别将圆角特效应用于原始路径，然后将生成的两条特效路径合并canvas.translate(0,200);paint.setStyle(Paint.Style.STROKE);SumPathEffect sumPathEffect = new SumPathEffect(cornerPathEffect,dashPathEffect);paint.setPathEffect(sumPathEffect);canvas.drawPath(path,paint); 6.1.2 字体相关函数setTextSize(float textSize)设置文字大小 setFakeBoldText(boolean fakeBoldText)设置是否为粗体文字 setStrikeThruText(boolean strikeThruText)设置带有删除线效果 setUnderlineText(boolean underlineText)设置下划线 setTextAlign(Paint.Align align)设置开始绘图点位置 setTextScaleX(float scaleX)水平拉伸设置 setTextSkewX(float skewX)设置字体水平倾斜度，普通斜体字是-0.25，可见往右斜 setTypeface(Typeface typeface)字体样式 setLinearText(boolean linearText)设置是否打开线性文本标识；由于文本想要快速绘制出来，必然是需要提前缓存在显存中的，一般而言每个文字需要一个字节的大小来存储它（当然具体需要多少字节与编码方式有关），那如果是长篇文章，可见所需的大小可想而知。我们可以通过 setLinearText (true) 告诉 Android 我们不需要这样的文本缓存。但如果我们不用文本缓存，虽然能够省去一些内存空间，但这是以显示速度为代价的。 由于这个是 API 1 的函数，由于当时的 android 手机的内存大小还是很小的，所以尽量减少内存使用是每个应用的头等大事，在当时的的环境下这个函数还是很有用的。 但在今天，内存动不动就是 4G 以上了，文本缓存的所占的那点内存就微不足道了，没有哪个 APP 会牺牲性能来减少这点这内存占用了，所以这个函数基本没用了。 setSubpixelText(boolean subpixelText)表示是否打开亚像素设置来绘制文本。亚像素的概念比较难理解，首先，我们都知道像素，比如一个 android 手机的分辨率是 1280720，那就是指它的屏幕在垂直方向有 1280 个像素点，水平方向上有 720 个像素点。我们知道每个像素点都是一个独立显示一个颜色的个体。所以如果一副图片，在一个屏幕上用了 300100 个相素点，而在另一个屏幕上却用了 450*150 个像素来显示。那么，请问在哪个屏幕上这张图片显示的更清晰？当然是第二个屏幕，因为它使用的像素点更多，所显示的细节更精细。 那么问题来了，android 设置在出厂时，设定的像素显示都是固定的几个范围：320480，480800，7201280，10801920 等等；那么如何在同样的分辨率的显示器中增强显示清晰度呢？ 亚像素的概念就油然而生了，亚像素就是把两个相邻的两个像素之间的距离再细分，再插入一些像素，这些通过程序加入的像素就是亚像素。在两个像素间插入的像素个数是通过程序计算出来的，一般是插入两个、三个或四个。 所以打开亚像素显示，是可以在增强文本显示清晰度的，但由于插入亚像素是通过程序计算而来的，所以会耗费一定的计算机性能。注意：亚像素是通过程序计算出来模拟插入的，在没有改变硬件构造的情况下，来改善屏幕分辨率大小。 亚像素显示，是仅在液晶显示器上使用的一种增强字体清晰度的技术。但这种技术有时会出现问题，用投影仪投射到白色墙壁上，会出出字体显示不正常的情况，而且对于老式的CRT显示器是根本不支持的。]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06.2 精通自定义 View 之 Paint 基本使用——文字]]></title>
    <url>%2F2019%2F07%2F06%2FCustom%20View%2F06.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E6%96%87%E5%AD%97%2F</url>
    <content type="text"><![CDATA[6.2.1 概述1. 四线格与基线小时候，我们在刚开始学习写字母时，用的本子是四线格的，我们必须把字母按照规则写在四线格内。 在 canvas 在利用 drawText 绘制文字时，也是有规则的，这个规则就是基线！我们先来看一下什么是基线： 可见基线就是四线格中的第三条线。也就是说，只要基线的位置定了，那文字的位置必然是定了的！ 2. canvas.drawText()1）canvas.drawText() 与基线1234567/** * text:要绘制的文字 * x：绘制原点x坐标 * y：绘制原点y坐标 * paint:用来做画的画笔 */public void drawText(String text, float x, float y, Paint paint) 上面这个构造函数是最常用的 drawText 方法，传进去一个 String 对象就能画出对应的文字。但这里有两个参数需要非常注意，表示原点坐标的 x 和 y。很多同学可能会认为，这里传进去的原点参数 (x,y) 是所在绘制文字所在矩形的左上角的点。但实际上并不是！比如，我们上面如果要画 “harvic’s blog” 这几个字，这个原点坐标应当是下图中绿色小点的位置。 一般而言，(x,y) 所代表的位置是所画图形对应的矩形的左上角点。但在 drawText 中是非常例外的，y 所代表的是基线的位置。 2）示例12345678910111213141516protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int baseLineX = 0; int baseLineY = 200; // 画基线 Paint paint = new Paint(); paint.setColor(Color.RED); canvas.drawLine(baseLineX, baseLineY, 3000, baseLineY, paint); // 写文字 paint.setColor(Color.GREEN); paint.setTextSize(120); // 以px为单位 canvas.drawText(&quot;harvic\&apos;s blog&quot;, baseLineX, baseLineY, paint);&#125; 首先，我们把 (0,200) 所在的这条横线画出来，所以我先画了一条线从点坐标为 (0,200) 到点坐标为 (3000,200) 的一条直线，然后利用 canvas.drawText 以 (0,200) 为原点画出文字，最终效果图如下： 结论： drawText() 函数中的参数 y 是基线的位置。 一定要清楚的是，只要 x 坐标、基线位置、文字大小确定，文字的位置就是确定了。 3. paint.setTextAlign() 函数在上面我们讲了，drawText() 函数中的 y 参数表示所要绘制文字的基线所在位置。从上面的例子中可以看到，绘制是从 x 坐标的右边开始的，但这并不是必然的结果。我们来看一张图： 在 drawText(text, x, y, paint) 中传进去的原点坐标 (x,y)。其中，y 表示的基线的位置。那 x 代表什么呢？从上面的例子运行结果来看，应当是文字开始绘制的地方。 并不是！x 代表所要绘制文字所在矩形的相对位置。相对位置就是指指定点 (x,y) 在在所要绘制矩形的位置。我们知道所绘制矩形的纵坐标是由 y 值来确定的，而相对 x 坐标的位置，只有左、中、右三个位置了。也就是所绘制矩形可能是在 x 坐标的左侧绘制，也有可能在 x 坐标的中间，也有可能在 x 坐标的右侧。而定义在 x 坐标在所绘制矩形相对位置的函数是：1234/** * 其中 Align 的取值为：Panit.Align.LEFT,Paint.Align.CENTER,Paint.Align.RIGHT */Paint::setTextAlign(Align align); 仍然使用上面的例子，当设置不同的 Align 取值时，效果如下图所示。Paint.Align.LEFT： Paint.Align.CENTER： Paint.Align.RIGHT： 4. 注意这里需要再次强调的是：相对位置是根据所要绘制文字所在矩形来计算的。比如，只写一个大写字母 A，将其相对位置设置为 Paint.Align.CENTER。12mPaint.setTextAlign(Paint.Align.CENTER);canvas.drawText(&quot;A&quot;, baseLineX, baseLineY, mPaint); 效果如下图所示： 6.2.2 绘图四线格与 FontMetrics1. 文字的绘图四线格除了基线以外，系统在绘制文字时还有 4 条线，分别是 ascent、descent、top、bottom，如下图所示。 ascent：系统建议的，绘制单个字符时，字符应当的最高高度所在线。 descent：系统建议的，绘制单个字符时，字符应当的最低高度所在线。 top：可绘制的最高高度所在线。 bottom：可绘制的最低高度所在线。 我们在绘制文字时，ascent 是推荐的绘制文字的最高高度，就表示在绘制文字时，尽力要在这个最高高度以下绘制文字。descent 是推荐的绘制文字的最底高度线，同样表示是在绘制文字时尽量在这个 descent 线以上来绘制文字。而 top 线则指该文字可以绘制的最高高度线，bottom 则是表示该文字可以绘制的最低高度线。ascent、descent 是系统建议上的绘制高度，而 top、bottom 则是物理上屏幕最高、最低可以画的高度值。 2. FontMetrics1）FontMetrics 概述我们知道基线的位置是我们在构造 drawText() 函数时由参数 y 来决定的，那 ascent、descent、top、bottom 这些线的位置要怎么计算出来呢？ Android 给我们提供了一个类：FontMetrics，它里面有四个成员变量：1234FontMetrics::ascent;FontMetrics::descent;FontMetrics::top;FontMetrics::bottom; 他们的意义与值的计算方法分别如下： ascent = ascent 线的 y 坐标 - baseline 线的 y 坐标。 descent = descent 线的 y 坐标 - baseline 线的 y 坐标。 top = top 线的 y 坐标 - baseline 线的 y 坐标。 bottom = bottom 线的 y 坐标 - baseline 线的 y 坐标。 我们再来看个图： 从这个图中，我们先说明两点，然后再回过头来看上面的公式：1、X 轴，Y 轴的正方向走向是 X 轴向右是正方向，Y 轴向下是正方向，所以越往下 Y 坐标越大！2、大家千万不要将 FontMetrics 中的 ascent、descent、top、bottom 与现实中的 ascent、descent、top、bottom 所在线混淆！这几条线是真实存在的，而 FontMetrics 中的 ascent、descent、top、bottom 这个变量的值就是用来计算这几条线的位置的。1ascent = ascent线的y坐标 - baseline线的y坐标 FontMetrics 的这几个变量的值都是以 baseline 为基准的，对于 ascent 来说，baseline 线在 ascent 线之下，所以必然 baseline 的 y 值要大于 ascent 线的 y 值，所以 ascent 变量的值是负的。 同理，对于 descent 而言：1descent = descent线的y坐标 - baseline线的y坐标 descent 线在 baseline 线之下，所以必然 descent 线的 y 坐标要大于 baseline 线的 y 坐标，所以 descent 变量的值必然是正数。 2）得到 Text 四线格的各线位置先列出一个公式：1ascent 线 Y 坐标 = baseline 线 Y 坐标 + fontMetric.ascent 推算过程如下： 因为 ascent 线的 Y 坐标等于 baseline 线的 Y 坐标减去从 baseline 线到 ascent 线的这段距离。也就是：(|fontMetric.ascent|表示取绝对值)。ascent 线 Y 坐标 = baseline 线 Y 坐标 - |fontMetric.ascent|;又因为 fontMetric.ascent 是负值，所以：ascent 线 Y 坐标 = baseline 线 Y 坐标 - |fontMetric.ascent|;ascent 线 Y 坐标 = baseline 线 Y 坐标 - (-fontMetric.ascent);ascent 线 Y 坐标 = baseline 线 Y 坐标 + fontMetric.ascent; 这就是整个推算过程，没什么难度，同理可以得到： ascent 线 Y 坐标 = baseline 线的 y 坐标 + fontMetric.ascent； descent 线 Y 坐标 = baseline 线的 y 坐标 + fontMetric.descent； top 线 Y 坐标 = baseline 线的 y 坐标 + fontMetric.top； bottom 线 Y 坐标 = baseline 线的 y 坐标 + fontMetric.bottom； 3）获取 FontMetrics 对象123Paint paint = new Paint();Paint.FontMetrics fm = paint.getFontMetrics();Paint.FontMetricsInt fmInt = paint.getFontMetricsInt(); 从这里可以看到，通过 paint.getFontMetrics() 得到对应的 FontMetrics 对象。这里还有另外一个 FontMetrics 同样的类叫做 FontMetricsInt，它的意义与 FontMetrics 完全相同，只是得到的值的类型不一样而已，FontMetricsInt 中的四个成员变量的值都是 Int 类型，而 FontMetrics 得到的四个成员变量的值则都是 float 类型的。 4）示例：计算 Text 四线格位置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class TestView extends View &#123; private Paint mPaint; private Paint.FontMetrics mFm; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.GREEN); mPaint.setTextSize(120); mPaint.setTextAlign(Paint.Align.LEFT); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int baseLineX = 0; int baseLineY = 200; // 写文字 canvas.drawText(&quot;harvic\&apos;s blog&quot;, baseLineX, baseLineY, mPaint); // 计算各线在位置 mFm = mPaint.getFontMetrics(); float ascent = baseLineY + mFm.ascent; float descent = baseLineY + mFm.descent; float top = baseLineY + mFm.top; float bottom = baseLineY + mFm.bottom; // 画基线 mPaint.setColor(Color.RED); canvas.drawLine(baseLineX, baseLineY, 3000, baseLineY, mPaint); // 画 top mPaint.setColor(Color.BLUE); canvas.drawLine(baseLineX, top, 3000, top, mPaint); // 画 ascent mPaint.setColor(Color.GREEN); canvas.drawLine(baseLineX, ascent, 3000, ascent, mPaint); // 画 descent mPaint.setColor(Color.YELLOW); canvas.drawLine(baseLineX, descent, 3000, descent, mPaint); // 画 bottom mPaint.setColor(Color.RED); canvas.drawLine(baseLineX, bottom, 3000, bottom, mPaint); &#125;&#125; 6.2.3 常用函数1. 字符串所占高度和宽度1）高度字符串所占高度很容易得到，直接用 bottom 线所在位置的 Y 坐标减去 top 线所在位置的 Y 坐标就是字符串所占的高度：12345mFm = mPaint.getFontMetricsInt();int top = baseLineY + fm.top;int bottom = baseLineY + fm.bottom;// 所占高度int height = bottom - top; 2）、宽度宽度是非常容易得到的，直接利用下面的函数就可以得到：1int width = mPaint.measureText(&quot;harvic&apos;s blog&quot;); 2. 最小矩形1）概述要获取最小矩形，也是通过系统函数来获取的，函数及意义如下：12345678/** * 获取指定字符串所对应的最小矩形，以（0，0）点所在位置为基线 * @param text 要测量最小矩形的字符串 * @param start 要测量起始字符在字符串中的索引 * @param end 所要测量的字符的长度 * @param bounds 接收测量结果 */public void getTextBounds(String text, int start, int end, Rect bounds); 示例：12345678String text = &quot;harvic\&apos;s blog&quot;;Paint paint = new Paint();// 设置paintpaint.setTextSize(120); Rect minRect = new Rect();paint.getTextBounds(text,0,text.length(),minRect);Log.e(&quot;xian&quot;,minRect.toShortString()); 可以看到这个矩形的左上角位置为（8,-90），右下角的位置为（654,25）；大家可能会有疑问，为什么左上角的 Y 坐标是个负数？从代码中，我们也可以看到，我们并没有给 getTextBounds() 传递基线位置。那它就是以（0,0）为基线来得到这个最小矩形的！所以这个最小矩形的位置就是以（0,0）为基线的结果！ 2）得到最小矩形的实际位置我们先来看一个原理图： 在上面这个图中，我们将黑色矩形平行下移距离Y（黄色线依照的是基线的位置），那么平移后的左上角点的 y 坐标就是 y2 = y1 + Y。 同样的道理，由于 paint.getTextBounds() 得到最小矩形的基线是 y = 0；那我们直接将这个矩形移动 baseline 的距离就可以得到这个矩形实际应当在的位置了。 所以矩形应当所在实际位置的坐标是：123456Rect minRect = new Rect();paint.getTextBounds(text,0,text.length(),minRect);// 最小矩形，实际 top 位置int minTop = bounds.top + baselineY;// 最小矩形，实际 bottom 位置int minBottom = bounds.bottom + baselineY; 3）完整的代码1234567891011121314151617181920212223242526272829303132333435@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); String text = &quot;harvic\&apos;s blog&quot;; int baseLineY = 200; int baseLineX = 0 ; // 设置paint Paint paint = new Paint(); paint.setTextSize(120); //以px为单位 paint.setTextAlign(Paint.Align.LEFT); // 画text所占的区域 Paint.FontMetricsInt fm = paint.getFontMetricsInt(); int top = baseLineY + fm.top; int bottom = baseLineY + fm.bottom; int width = (int)paint.measureText(text); Rect rect = new Rect(baseLineX,top,baseLineX+width,bottom); paint.setColor(Color.GREEN); canvas.drawRect(rect,paint); // 画最小矩形 Rect minRect = new Rect(); paint.getTextBounds(text,0,text.length(),minRect); minRect.top = baseLineY + minRect.top; minRect.bottom = baseLineY + minRect.bottom; paint.setColor(Color.RED); canvas.drawRect(minRect,paint); // 写文字 paint.setColor(Color.BLACK); canvas.drawText(text, baseLineX, baseLineY, paint);&#125; 6.2.4 示例：定点写字1. 给定左上顶点绘图 在这个图中，我们给定左上角的位置，即 (left,top)；我们知道要画文字，drawText() 中传进去的 Y 坐标是基线的位置，所以我们就必须根据 top 的位置计算出 baseline 的位置。 我们来看一个公式：FontMetrics.top = top - baseline; 所以：baseline = top - FontMetrics.top; 因为 FontMetrics.top 是可以得到的，又因为我们的 top 坐标是给定的，所以通过这个公式就能得到 baseline 的位置了。 代码：12345678910111213141516171819202122232425262728293031public class TestView extends View &#123; private Paint mPaint; private Paint.FontMetrics mFm; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.GREEN); mPaint.setTextSize(120); mPaint.setTextAlign(Paint.Align.LEFT); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mFm = mPaint.getFontMetrics(); float top = 0; int baseLineX = 0; float baseLineY = top - mFm.top; // 写文字 canvas.drawText(&quot;harvic\&apos;s blog&quot;, 0, baseLineY, mPaint); // 画基线 mPaint.setColor(Color.RED); canvas.drawLine(baseLineX, baseLineY, 3000, baseLineY, mPaint); &#125;&#125; 2. 给定中间线位置绘图先来看一张图： 在这个图中，总共有四条线：top 线、bottom 线、baseline 和 center线。其中 center 线正是在 top 线和 bottom 线的正中间。 为了方便推导公式，另外标了三个距离 A、B、C。显然，距离 A 和距离 C 是相等的，都等于文字所在矩形高度以的一半，即 A = C = (bottom - top)/2。 又因为：bottom = baseline + FontMetrics.bottomtop = baseline + FontMetrics.top将这两个公式代入上面的公式，就可得到：A = C = (FontMetrics.bottom - FontMetrics.top)/2 而距离 B 则表示 center 线到 baseline 的距离。很显然距离B = C - (bottom - baseline) 又因为：FontMetrics.bottom = bottom - baselineC = A所以：B = A - FontMetrics.bottom 从而有：baseline = center + B = center + A - FontMetrics.bottom = center + (FontMetrics.bottom - FontMetrics.top)/2 - FontMetrics.bottom 根据上面的推导过程，我们最终可知，当给定中间线 center 位置以后，baseline 的位置为：baseline = center + (FontMetrics.bottom - FontMetrics.top)/2 - FontMetrics.bottom]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06.1 精通自定义 View 之 Paint 基本使用——硬件加速]]></title>
    <url>%2F2019%2F07%2F06%2FCustom%20View%2F06.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[参考文档：硬件加速 6.1.1 本质和原理1. 概念所谓硬件加速，指的是把某些计算工作交给专门的硬件来做，而不是和普通的计算工作一样交给 CPU 来处理。这样不仅减轻了 CPU 的压力，而且由于有了「专人」的处理，这份计算工作的速度也被加快了。这就是「硬件加速」。 而对于 Android 来说，硬件加速有它专属的意思：在 Android 里，硬件加速专指把 View 中绘制的计算工作交给 GPU 来处理。进一步地再明确一下，这个「绘制的计算工作」指的就是把绘制方法中的那些 Canvas.drawXXX() 变成实际的像素这件事。 2. 原理在硬件加速关闭的时候，Canvas 绘制的工作方式是：把要绘制的内容写进一个 Bitmap，然后在之后的渲染过程中，这个 Bitmap 的像素内容被直接用于渲染到屏幕。这种绘制方式的主要计算工作在于把绘制操作转换为像素的过程（例如由一句 Canvas.drawCircle() 来获得一个具体的圆的像素信息），这个过程的计算是由 CPU 来完成的。大致就像这样： 而开启硬件加速后，Canvas 的工作方式改变了：它把绘制的内容转为 GPU 的操作保存下来，然后交给 GPU 来完成显示工作。大致过程： 从上图可以看出，开启硬件加速后，绘制的计算工作有 CPU 交给 GPU，不过这怎么就能起到加速作用，让绘制变快了呢？ 本来CPU的工作，分摊一部分给GPU，自然可以提高效率； 相对于CPU来说，GPU自身的设计本来就对于很多常见类型内容的计算(例如简单的圆形、方形)具有优势； 由于绘制流程的不同；硬件加速在界面内容发生重绘的时候绘制流程可以得到优化，避免一些重复操作，从而大幅提升绘制效率。 关于第三点，它的原理大致说一下： 关闭硬件加速时，绘制内容会被 CPU 转为实际的像素，然后直接渲染到屏幕，具体来说，这个 [实际的像素]，是由 bitmap 承载的，在界面的某个 View 由于内容发生改变而调用 invalidat() 方法时，如果没有开启硬件加速，为了正确计算 bitmap 的像素，这个 View 的父 View、父 View 的父 View 乃至一直向上知道最顶级的 View，以及所有和它相交的 View，都需要被调用 invalidate() 来重绘，一个View的改变使得大半个界面甚至整个界面重绘一遍，这个工作量是非常大的。 而在开启硬件加速时，绘制的内容会被转换成 GPU 的操作保存下来(承载的形式成为 displaylist，对应的类也叫作 DisplayList)，再转交给 GPU。由于所有绘制的内容都没有变成最终的像素，所以它们之间是相互独立的，那么在界面内容发生改变时，只需把发生了改变的 View 调用 invalidate() 方法以更新它所对应的 GPU 就好，至于它的父 View 和兄弟 View，只需要保持原样，那么这个工作量就很小了。 正是由于上面的原因，硬件加速不仅是由于 GPU 的引入提高效率，而且因为绘制机制的改变，而极大的提高了界面内容改变时的刷新效率。 总结：用了 GPU，绘制更快；绘制机制的改变，导致界面内容改变时的刷新效率极大提高。 6.1.2 在 Android 中的限制可事实就是，硬件加速不止有好处，也有限制：收到 GPU 绘制方式的限制，Canvas 的有些方法在硬件加速开启时会失效或者无法正常工作，比如：开启硬件加速，clipPath() 在 API 18 及以上系统中才有效，具体的 API 限制和 API 版本的关系如下图： 所以，如果你对自定义控件有自定义绘制的内容，最好参照一下表格，确保你的绘制操作可以正确地在所有用户手机中正常显示，而不是只在你最新 Android 系统的 Nexus 或 Pixel 里测试一遍没问题就发布。那就小心被祭天了。 6.1.3 禁用 GPU 硬件加速的方法1）在 AndroidManifest.xml 文件中为 application 标签添加如下属性，即可为整个应用程序开启/关闭硬件加速。1&lt;application android:hardwareAccelerated=&quot;true&quot; ...&gt; 2）在 AndroidManifest.xml 文件中为 activity 标签下使用 hardwareAccelerated 属性开启/关闭硬件加速。1&lt;activity android:hardwareAccelerated=&quot;false&quot; ...&gt; 3）在 Window 层级上使用如下代码开启硬件加速（Window 层级不支持关闭硬件加速）：1getWindow().setFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED); 4）在 View 层级上使用如下代码关闭硬件加速(在 View 层级上不支持开启硬件加速)1setLayerType(LAYER_TYPE_SOFTWARE,null); 或者在layout xml中使用1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layerType=&quot;software&quot; &gt;&lt;/LinearLayout&gt; 事实上，view.setLayerType(LAYER_TYPE_SOFTWARE, null) 这个方法的作用并不是关闭硬件加速，只是当它的参数为 LAYER_TYPE_SOFTWARE 的时候，可以顺便把硬件加速关掉而已；并且除了这个方法外，Android 并没有提供专门的 View 级别的硬件加速开关，所以它就顺便成了一个开关硬件加速的方法。 参数为 LAYER_TYPE_SOFTWARE 时，使用软件来绘制 View Layer，绘制到一个 Bitmap，并顺便关闭硬件加速； 参数为 LAYER_TYPE_HARDWARE 时，使用 GPU 来绘制 View Layer，绘制到一个 OpenGL texture (如果硬件加速关闭，那么行为和 LAYER_TYPE_SOFTWARE 一致)； 参数为 LAYER_TYPE_NONE 时，关闭 View Layer。]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05.2 精通自定义 View 之动画进阶——SVG 动画]]></title>
    <url>%2F2019%2F07%2F05%2FCustom%20View%2F05.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94SVG%20%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[5.2.1 概述SVG 全称是 Scalable Vector Graphics（可缩放矢量图形），即 SVG 是矢量图。与矢量图对应的是位图，Bitmap 就是位图，它由一个个像素点组成，当图片放大到一定大小时，就会出现马赛克现象，Photoshop 就是常用的位图处理软件。而矢量图则由一个个点组成，经过数学计算利用直线和曲线绘制而成，无论如何放大，都不会出现马赛克现象，Illustrator 就是常用的矢量图绘图软件。 SVG 与 Bitmap 相比有以下好处： SVG 使用 XML 格式定义图形，可被非常多的工具读取和修改。 SVG 由点来存储，由计算机根据点信息绘图，不会失真，无须根据分辨率适配多套图标。 SVG 的占用空间明显比 Bitmap 小。如 500px X 500px 的图像，转成 SVG 后占用的空间大小是 20KB，而 PNG 图片则需要 732KB 的空间。 SVG 可以转换为 Path 路径，与 Path 动画相结合，可以形成丰富的动画。 对于 Android 5.0 以下的机型，可以通过引入 com.android.support:appcompat-v7:23.4.0 及以上版本进行支持。 Android 并没有对原生的 SVG 图像语法进行支持，而是以一种简化的方式对 SVG 进行兼容，也就是通过使用它的 path 标签，几乎可以实现 SVG 中的其他所有标签。这些东西可以通过工具来完成。 5.2.2 vector 标签与图像显示res/drawable/svg.xml123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:width=&quot;200dp&quot; android:height=&quot;100dp&quot; android:viewportWidth=&quot;100&quot; android:viewportHeight=&quot;50&quot;&gt; &lt;path android:name=&quot;bar&quot; android:pathData=&quot;M50,23 L100,23&quot; android:strokeWidth=&quot;2&quot; android:strokeColor=&quot;@color/colorAccent&quot;/&gt;&lt;/vector&gt; 效果图： vector 标签：指定画布大小，上图蓝框区域。 path 标签：绘制路径，对应上图中的红色线段。 width &amp; height 属性：表示该 SVG 图形的具体大小。 viewportWidth &amp; viewportHeight 属性：表示 SVG 图形划分的比例。 width &amp; height 类似于指定画布的大小，而 viewportWidth &amp; viewportHeight 则是指将画布的宽、高分为多少个点，而 Path 中的点坐标都是以 viewportWidth &amp; viewportHeight 的点数为坐标的，而不是 dp 值。此处将宽度 200dp 分为 100 个点，在高度 100dp 分为 50 个点，每个点有 2dp。而 path 中字母 M 表示 moveTo，字母 L 表示 lineTo，所以，这里代表从（50, 23) 到点 (100, 23) 画了一条线段。 1. path 标签1）常用属性 android:name：声明一个标记，类似于 ID。 android:pathData：对 SVG 矢量图的描述。 android:strokeWidth：画笔的宽度 android:fillColor：填充颜色。 android:fillAlpha：填充颜色的透明度。 android:strokeColor：描边颜色。 android:strokeWidth：描边宽度。 android:strokeAlpha：描边透明度。 android:strokeLineJoin：用于指定折线拐角形状，取值有 miter（结合处为锐角）、round（结合处为圆弧）、bevel（结合处为直线）。 android:strokeLineCap：画出线条的终点的形状（线帽），取值有 butt（无线帽）、round（圆形线帽）、square（方形线帽） android:strokeMiterLimit：设置斜角的上限。当 strokeLineJoin 为 “round” 或 “bevel” 时，该属性无效。 2）android:trimPathStart 属性该属性用于指定路径从哪里开始，取值为 0~1，表示路径开始位置的百分比。取值为 0 时，表示从头开始；取值为 1 时，整条路径不可见。123456&lt;path android:name=&quot;bar&quot; android:pathData=&quot;M50,23 L100,23&quot; android:strokeWidth=&quot;2&quot; android:trimPathStart=&quot;0.5&quot; android:strokeColor=&quot;@color/colorAccent&quot;/&gt; 灰色部分代表的是被删除的部分，实际上是不会显示出来的，这里只是为了展示效果，下同。 3）android:trimPathEnd 属性该属性用于指定路径的结束位置，取值为 0~1，表是路径结束位置的百分比。取值为 1 时，路径正常结束；取值为 0 时，表示从开始位置就已经结束了，即整条路径不可见。123456&lt;path android:name=&quot;bar&quot; android:pathData=&quot;M50,23 L100,23&quot; android:strokeWidth=&quot;2&quot; android:trimPathEnd=&quot;0.8&quot; android:strokeColor=&quot;@color/colorAccent&quot;/&gt; 4）android:trimPathOffset 属性该属性用于指定路径的位移距离，取值 0~1。取值为 0 时，不位移；当取值 为 1 时，位移整条路径的长度。12345678&lt;path android:name=&quot;bar&quot; android:pathData=&quot;M50,23 L100,23&quot; android:strokeWidth=&quot;2&quot; android:trimPathStart=&quot;0.2&quot; android:trimPathEnd=&quot;0.4&quot; android:trimPathOffset=&quot;0.6&quot; android:strokeColor=&quot;@color/colorAccent&quot;/&gt; 5）android:pathData 属性指定 SVG 图像的显示内容。 M = moveTo(M X,Y)：将画笔移动到指定的坐标位置。 L = lineTo(L X,Y)：画直线到指定的坐标位置。 H = horizontal lineTo(H X)：画水平线到指定的 X 坐标位置。 V = vertical lineTo(V Y)：画垂直线到指定的 Y 坐标位置。 C = curveTo(C X1,Y1,X2,Y2,ENDX,ENDY)：三阶贝济埃曲线。 S = smooth curveTo(S X2,Y2,ENDX,ENDY)：三阶贝济埃曲线。S 指令会将上一条指令的终点作为这条指令的起始点。 Q = quadratic Bezier curve(Q X,Y,ENDX,ENDY)：二阶贝济埃曲线。 T = smooth quadratic Bezier curveTo(T ENDX,ENDY)：映射前面路径后的终点。 A = elliptical Arc(A RX,RY,XROTATION,FLAG1,FLAG2,X,Y)：弧线。 Z = closePath()：关闭路径。 使用上面的指令时，需要注意的几点： 坐标轴以（0,0）位中心，X轴水平向右，Y轴水平向下。 所有指令大小写均可，大写绝对定位，参照全局坐标系，小写相对定位，参照父容器坐标系。 指令和数据间的空格可以无视。 同一指令出现多次可以用一个。 2. group 标签group 标签用于定义一系列路径或者将 path 标签分组。具有以下常用属性。 android:name：组的名称，用于与动画相关联。 android:rotation：指定该组图像的旋转度数。 android:pivotX：定义缩放和旋转该组时的 X 参考点。 android:pivotY：定义缩放和旋转该组时的 Y 参考点。 android:scaleX：指定该组 X 轴缩放大小。 android:scaleY：指定该组 Y 轴缩放大小。 android:translateX：指定该组沿 X 轴平移的距离。 android:translateY：指定该组沿 Y 轴平移的距离。 示例：围绕画布中心旋转 90 度。1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:width=&quot;200dp&quot; android:height=&quot;100dp&quot; android:viewportWidth=&quot;100&quot; android:viewportHeight=&quot;50&quot;&gt; &lt;group android:rotation=&quot;90&quot; android:pivotX=&quot;50&quot; android:pivotY=&quot;25&quot;&gt; &lt;path android:name=&quot;bar&quot; android:pathData=&quot;M50,23 L100,23&quot; android:strokeWidth=&quot;2&quot; android:strokeColor=&quot;@color/colorAccent&quot;/&gt; &lt;/group&gt;&lt;/vector&gt; 3. 制作 SVG 图像方法一：设计软件如果有绘图基础，可以直接使用 Illustrator 或在线 SVG 工具制作 SVG 图像（如 http://editor.method.ac/），或者通过 SVG 源文件下载网站下载后进行编辑。 方法二：Iconfont有很多 Iconfont 开源网站，比如国内的阿里巴巴矢量图库，地址为 http://www.iconfont.cn/。 4. 在 Android 中引入 SVG 图像在 Android 中是不支持 SVG 图像解析的，我们必须将 SVG 图像转换为 vector 标签描述，这里同样有两种方法。 方法一：在线转换。This tool has been deprecated. Use official Vector Asset Studio instead. 方法二：Vector Asset StudioAndroid Studio 2.0 及以上版本中支持创建 Vector 文件，如下图所示。 5. 示例1）引入兼容包123compile &apos;com.android.support:appcompat-v7:23.4.0&apos;// 或使用 androidximplementation &apos;androidx.appcompat:appcompat:1.0.2&apos; 在项目的 build.gradle 脚本中添加对 Vector 兼容性的支持。12345android &#123; defaultConfig &#123; vectorDrawables.useSupportLibrary = true &#125;&#125; 2）生成 Vector 图像使用前面例子中的一条横线的 Vector 图像（src/drawable/svg.xml）123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:width=&quot;200dp&quot; android:height=&quot;100dp&quot; android:viewportWidth=&quot;100&quot; android:viewportHeight=&quot;50&quot;&gt; &lt;path android:name=&quot;bar&quot; android:pathData=&quot;M50,23 L100,23&quot; android:strokeWidth=&quot;2&quot; android:strokeColor=&quot;@color/colorAccent&quot;/&gt;&lt;/vector&gt; 3）在 ImageView、ImageButton 中使用12345&lt;ImageView android:id=&quot;@+id/iv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:srcCompat=&quot;@drawable/svg&quot;/&gt; 在代码中设置12ImageView iv = findViewById(R.id.iv);iv.setImageResource(R.drawable.svg); 本人测试使用 android:background=”@drawable/svg” 也是正常的。测试机型 Pixel XL，Android 7.1.2。 4）在 Button、RadioButton 中使用Button 并不能直接通过 app:srcCompat 属性来使用 Vector 图像，而需要通过 selector 标签来使用（selector_svg.xml）12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@drawable/svg&quot; android:state_pressed=&quot;true&quot;/&gt; &lt;item android:drawable=&quot;@drawable/svg&quot;/&gt;&lt;/selector&gt; 如果到这里并不能直接运行，需要把下面这段代码放在 Activity 的前面。123456789public class MainActivity extends AppCompatActivity &#123; static &#123; AppCompatDelegate.setCompatVectorFromResourcesEnabled(true); &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; ... &#125;&#125; 本人测试可以直接使用 android:background=”@drawable/svg” 并且不需要在 Activity 中加入上述代码 即可正常运行。测试机型 Pixel XL，Android 7.1.2。 5.2.3 动态 Vector实现 Vector 动画，步骤如下：1）使用上述 drawable/svg.xml2）创建 animator/anim_trim_start.xml 文件123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:propertyName=&quot;trimPathStart&quot; android:valueFrom=&quot;0&quot; android:valueTo=&quot;1&quot; android:duration=&quot;2000&quot;/&gt; 3）关联 Vector &amp; Animator。drawable/animated_vector.xml1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animated-vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:drawable=&quot;@drawable/svg&quot;&gt; &lt;target android:animation=&quot;@animator/anim_trim_start&quot; android:name=&quot;bar&quot;/&gt;&lt;/animated-vector&gt; 4）最后在代码中使用123456789101112131415161718192021public class MainActivity extends AppCompatActivity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); final ImageView imageView = findViewById(R.id.iv); AnimatedVectorDrawableCompat compat = AnimatedVectorDrawableCompat.create( MainActivity.this, R.drawable.animated_vector); imageView.setImageDrawable(compat); findViewById(R.id.btn).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; ((Animatable) imageView.getDrawable()).start(); &#125; &#125;); &#125;&#125; 效果图如下所示： 5.2.4 示例：输入搜索动画 1. 准备 SVG 图像res/drawable/svg.xml12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:width=&quot;150dp&quot; android:height=&quot;24dp&quot; android:viewportWidth=&quot;150&quot; android:viewportHeight=&quot;24&quot;&gt; &lt;!-- 搜索图形 --&gt; &lt;path android:name=&quot;search&quot; android:pathData=&quot;M141,17 A9,9 0 1,1 142,16 L149,23&quot; android:strokeWidth=&quot;2&quot; android:strokeColor=&quot;@color/colorAccent&quot;/&gt; &lt;path android:name=&quot;bar&quot; android:trimPathStart=&quot;1&quot; android:pathData=&quot;M0,23 L149,23&quot; android:strokeWidth=&quot;2&quot; android:strokeColor=&quot;@color/colorAccent&quot;/&gt;&lt;/vector&gt; 2. 准备动画res/animator/anim_bar_trim_start.xml1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:propertyName=&quot;trimPathStart&quot; android:valueFrom=&quot;0&quot; android:valueTo=&quot;1&quot; android:valueType=&quot;floatType&quot; android:duration=&quot;500&quot;/&gt; res/animator/anim_search_trim_start.xml1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:propertyName=&quot;trimPathEnd&quot; android:valueFrom=&quot;0&quot; android:valueTo=&quot;1&quot; android:valueType=&quot;floatType&quot; android:duration=&quot;500&quot;/&gt; 关联 Vector &amp; Animator12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animated-vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:drawable=&quot;@drawable/svg&quot;&gt; &lt;target android:animation=&quot;@animator/anim_bar_trim_start&quot; android:name=&quot;bar&quot;/&gt; &lt;target android:animation=&quot;@animator/anim_search_trim_start&quot; android:name=&quot;search&quot;/&gt;&lt;/animated-vector&gt; 3. 布局与开始动画res/layout/act_main.xml1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:padding=&quot;20dp&quot; &gt; &lt;EditText android:id=&quot;@+id/edit&quot; android:layout_width=&quot;150dp&quot; android:layout_height=&quot;24dp&quot; android:hint=&quot;点击输入&quot; android:background=&quot;@null&quot;/&gt; &lt;ImageView android:id=&quot;@+id/iv&quot; android:layout_width=&quot;150dp&quot; android:layout_height=&quot;24dp&quot; /&gt;&lt;/FrameLayout&gt; 开始动画代码：1234567891011121314151617181920212223242526public class MainActivity extends AppCompatActivity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); final ImageView imageView = findViewById(R.id.iv); // 将焦点放在 ImageView 上 imageView.setFocusable(true); imageView.setFocusableInTouchMode(true); imageView.requestFocus(); imageView.requestFocusFromTouch(); EditText editText = findViewById(R.id.edit); editText.setOnFocusChangeListener(new View.OnFocusChangeListener() &#123; @Override public void onFocusChange(View v, boolean hasFocus) &#123; AnimatedVectorDrawableCompat compat = AnimatedVectorDrawableCompat.create( MainActivity.this, R.drawable.animated_vector); imageView.setImageDrawable(compat); ((Animatable) imageView.getDrawable()).start(); &#125; &#125;); &#125;&#125;]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05.1 精通自定义 View 之动画进阶——利用 PathMeasure 实现路径动画]]></title>
    <url>%2F2019%2F07%2F05%2FCustom%20View%2F05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[PathMeasure 类似一个计算器，可以计算出指定路径的一些信息，比如路径总长、指定长度所对应的坐标等。我们可以通过 PathMeasure 可以实现复杂的动画效果。 5.1.1 初始化123456// 初始化方法一public PathMeasure();setPath(Path path, boolean forceClosed);// 初始化方法二public PathMeasure(Path path, boolean forceClosed); 参数 boolean forceClosed 表示Path 最终是否需要闭合，如果为 true，则不管关联的 Path 是否是闭合的，都会被闭合。但是 forceClosed 参数对绑定的 Path 不会产生任何影响，例如一个折线段的 Path，本身是没有闭合的，当 forceClosed 设置为 true 的时候，PathMeasure 计算的 Path 是闭合的，但 Path 绘制出来的是不会闭合的。forceClosed 参数只对 PathMeasure 的测量结果有影响，例如一个折线段的 Path，本身没有闭合，当 forceClosed 设置为 true 时，PathMeasure 的计算就会包含最后一段闭合的路径，与原来的 Path 不同。 示例：123456789101112131415161718192021222324252627282930313233public class TestView extends View &#123; private Paint mPaint; private Path mPath; private PathMeasure mPathMeasureFalse; private PathMeasure mPathMeasureTrue; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.BLACK); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(8); mPath = new Path(); mPath.moveTo(50, 50); mPath.lineTo(50, 150); mPath.lineTo(150, 150); mPath.lineTo(150, 50); mPathMeasureFalse = new PathMeasure(mPath, false); mPathMeasureTrue = new PathMeasure(mPath, true); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Log.i(&quot;xian&quot;, &quot;forceClosed=false----&gt;&quot; + mPathMeasureFalse.getLength()); Log.i(&quot;xian&quot;, &quot;forceClosed=true-----&gt;&quot; + mPathMeasureTrue.getLength()); canvas.drawPath(mPath, mPaint); &#125;&#125; 结果： 从图中可以看到，我们创建的只是正方形的三条边，而日志打印结果表示：如果 forceClosed 为 false，则测量的是当前 Path 状态的长度；如果 forceClosed 为 true，则不论 Path 是否闭合，测量的都是 Path 的闭合长度。 5.1.2 简单函数使用1. getLength()12// 获取一段路径的长度，不一定是整个 Path 的长度public float getLength() 2. isClosed()12// 判断测量 Path 时是否计算闭合，返回值是 forceClosedpublic boolean isClosed() 3. nextContour()1public boolean nextContour() Path 可以由多条曲线构成，但不论是 getLength()、getSegment() 还是其他函数，都会只针对其中第一条线段进行计算。而 nextContour() 就是用于跳转到下一条曲线的函数。如果跳转成功，则返回 true；如果跳转失败，则返回 false。 示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class TestView extends View &#123; private Paint mPaint; private Path mPath1, mPath2, mPath3; private PathMeasure mPathMeasure; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.BLACK); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(8); mPath1 = new Path(); mPath1.addRect(-50, -50, 50, 50, Path.Direction.CW); mPath2 = new Path(); mPath2.addRect(-100, -100, 100, 100, Path.Direction.CW); mPath3 = new Path(); mPath3.addRect(-120, -120, 120, 120, Path.Direction.CW); mPathMeasure = new PathMeasure(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.translate(150, 150); // 只绘画最大的区域 // mPath.addRect(-50, -50, 50, 50, Path.Direction.CW); // mPath.addRect(-100, -100, 100, 100, Path.Direction.CW); // mPath.addRect(-120, -120, 120, 120, Path.Direction.CW); // canvas.drawPath(mPath, mPaint); mPath1.addPath(mPath2); mPath1.addPath(mPath3); canvas.drawPath(mPath1, mPaint); mPathMeasure.setPath(mPath1, false); do &#123; float len = mPathMeasure.getLength(); Log.i(&quot;xian&quot;, &quot;len=&quot; + len); &#125; while (mPathMeasure.nextContour()); &#125;&#125; 结果： 通过这个例子可以得出以下结论： nextContour() 函数得到的曲线的顺序与 Path 中添加的顺序相同。 getLength() 等函数针对的是当前线段，不是整个 Path。 5.1.3 getSegment() 函数1public boolean getSegment(float startD, float stopD, Path dst, boolean startWithMoveTo) 用于截取整个 Path 中的某个片段，通过参数 startD 与 stopD 来控制截取的长度，并将截取后的 Path 保存并添加（不是替换）到参数 dst 中。startWithMoveTo 表示起始点是否使用 moveTo 将路径的新起点移动到结果 Path 的起始点，通常设置为 true，以保证每次截取的 Path 都是正常的、完整的；如果设置为 false，则新增的片段会从上一次 Path 终点开始计算，这样可以保证截取的 Path 片段是连续的，但不一定时正常的。 注意： 如果 startD、stopD 的数值不在取值范围[0, getLength] 内，或者 startD == stopD，则返回值为 false，而且不会改变 dst 中的内容。 使用 getSegment() 函数时需要禁用硬件加速功能。 setLayerType(LAYER_TYPE_SOFTWARE, null)。 示例一：用法举例1234567891011121314151617181920212223242526272829public class TestView extends View &#123; private Paint mPaint; private Path mPath, mDst; private PathMeasure mPathMeasure; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.BLACK); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(8); mPath = new Path(); mPath.addRect(-50, -50, 50, 50, Path.Direction.CW); mDst = new Path(); mPathMeasure = new PathMeasure(mPath, false); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.translate(100, 100); mPathMeasure.getSegment(0, 150, mDst, true); canvas.drawPath(mDst, mPaint); &#125;&#125; 效果图如下： 结论一：路径截取是以路径的左上角为起始点开始的。 示例二：逆时针将生成路径的方式指定为逆时针。12// mPath.addRect(-50, -50, 50, 50, Path.Direction.CW);mPath.addRect(-50, -50, 50, 50, Path.Direction.CCW); 效果图如下： 结论二：路径的截取方向与路径的生成方向相同。 示例三：如果 dst 路径不为空123mDst = new Path();mDst.lineTo(10, 100);mPathMeasure = new PathMeasure(mPath, false); 效果图如下： 结论三：会将截取的 Path 片段添加到路径 dst 中，而不是替换 dst 中的内容。 示例四：如果 startWithMoveTo 参数为 false12// mPathMeasure.getSegment(0, 150, mDst, true);mPathMeasure.getSegment(0, 150, mDst, false); 效果图如下： 结论四：如果 startWithMoveTo 为 true，则被截取出来的 Path 片段保持原状；如果 startWithMoveTo 为 false，则会截取出来的 Path 片段的起始点移动到 dst 的最后一个点，以保证 dst 路径的连续性。 示例：路径加载动画 12345678910111213141516171819202122232425262728293031323334353637383940414243public class TestView extends View &#123; private Paint mPaint; private Path mCirclePath, mDstPath; private PathMeasure mPathMeasure; private float mCurAnimValue; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.BLACK); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(4); mDstPath = new Path(); mCirclePath = new Path(); mCirclePath.addCircle(100, 100, 50, Path.Direction.CW); mPathMeasure = new PathMeasure(mCirclePath, false); ValueAnimator animator = ValueAnimator.ofFloat(0, 1); animator.setRepeatCount(ValueAnimator.INFINITE); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mCurAnimValue = (Float) animation.getAnimatedValue(); invalidate(); &#125; &#125;); animator.setDuration(1000); animator.start(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.WHITE); float stop = mPathMeasure.getLength() * mCurAnimValue; mDstPath.reset(); mPathMeasure.getSegment(0, stop, mDstPath, true); canvas.drawPath(mDstPath, mPaint); &#125;&#125; 上述示例中，在生成动画路径时，始终是从 0 位置开始的。如果我们稍微改变一下生成路径的起始点位置，就可以完成一个比较有意思的加载图动画，效果图如下所示： 修改代码如下：12345678910protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.WHITE); float length = mPathMeasure.getLength(); float stop = length * mCurAnimValue; float start = (float) (stop - ((0.5 - Math.abs(mCurAnimValue - 0.5)) * length)); mDstPath.reset(); mPathMeasure.getSegment(start, stop, mDstPath, true); canvas.drawPath(mDstPath, mPaint);&#125; 5.1.4 getPosTan() 函数1boolean getPosTan(float distance, float[] pos, float[] tan) 用于得到路径上某一长度的位置以及该位置的正切值。参数： float distance：距离 Path 起始点的长度，取值范围 0 ≤ distance ≤ getLength。 float[] pos：该点的坐标值。pos[0] 表示 x 坐标，pos[1] 表示 y 坐标。 float[] tan：该点的正切值。 在 Math 类中，有两个求反切值的函数，即夹角 a 的值。12double atan(double d)double atan2(double x, double y) 示例：飞机加载动画 动画效果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class TestView extends View &#123; private Paint mPaint; private Path mCirclePath, mDstPath; private PathMeasure mPathMeasure; private float mCurAnimValue; private Bitmap mPlaneBmp; private Matrix mMatrix; private ValueAnimator mValueAnimator; private float[] pos = new float[2]; private float[] tan = new float[2]; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE, null); mPlaneBmp = BitmapFactory.decodeResource(getResources(), R.drawable.plane); mPaint = new Paint(); mPaint.setColor(Color.BLACK); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(4); mDstPath = new Path(); mCirclePath = new Path(); mPathMeasure = new PathMeasure(); mMatrix = new Matrix(); mValueAnimator = ValueAnimator.ofFloat(0, 1); mValueAnimator.setRepeatCount(ValueAnimator.INFINITE); mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mCurAnimValue = (Float) animation.getAnimatedValue(); invalidate(); &#125; &#125;); mValueAnimator.setDuration(2000); mValueAnimator.setInterpolator(new AccelerateDecelerateInterpolator()); mValueAnimator.start(); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int width = MeasureSpec.getSize(widthMeasureSpec); int height = MeasureSpec.getSize(heightMeasureSpec); int radius; if (width &gt;= height) &#123; radius = height / 2 - height / 8; &#125; else &#123; radius = width / 2 - width / 8; &#125; // 先画圆的 path，但是这个圆只是用来计算 mCirclePath.addCircle(width / 2f, height / 2f, radius, Path.Direction.CW); //计算圆的path的长度 mPathMeasure.setPath(mCirclePath, false); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 绘制路径加载动画 float length = mPathMeasure.getLength(); float stop = length * mCurAnimValue; float start = (float) (stop - ((0.5 - Math.abs(mCurAnimValue - 0.5)) * length)); mDstPath.reset(); mPathMeasure.getSegment(start, stop, mDstPath, true); canvas.drawPath(mDstPath, mPaint); // 旋转飞机图片并绘制 // 使用 getMatrix // mPathMeasure.getMatrix(stop, mMatrix, PathMeasure.POSITION_MATRIX_FLAG|PathMeasure.TANGENT_MATRIX_FLAG); // mMatrix.preTranslate(-mPlaneBmp.getWidth() / 2f,-mPlaneBmp.getHeight() / 2f); // 使用 getPosTan mPathMeasure.getPosTan(stop, pos, tan); float degrees = (float) (Math.atan2(tan[1], tan[0]) * 180.0 / Math.PI); float px = mPlaneBmp.getWidth() / 2f; float py = mPlaneBmp.getHeight() / 2f; mMatrix.reset(); mMatrix.postRotate(degrees, mPlaneBmp.getWidth() / 2f, mPlaneBmp.getHeight() / 2f); mMatrix.postTranslate(pos[0] - px, pos[1] - py); canvas.drawBitmap(mPlaneBmp, mMatrix, mPaint); &#125; @Override protected void onDetachedFromWindow() &#123; super.onDetachedFromWindow(); mValueAnimator.cancel(); mValueAnimator = null; &#125;&#125; 5.1.5 getMatrix() 函数1boolean getMatrix(float distance, Matrix matrix, int flags) 用于得到路径上某一长度的位置以及该位置的正切值的矩阵。 distance：距离 Path 起始点的长度。 matrix：根据flags 封装好的 matrix 会根据 flags 的设置而存入不同的内容。 flags：用于指定哪些内容会存入 matrix 中。flags 值有两个：PathMeasure.POSITION_MATRIX_FLAG 表示获取位置信息；PathMeasure.TANGENT_MATRIX_FLAG 表示获取切边信息，使得图片按 Path 旋转。可以只指定一个，也可以用“|”同时指定。 很明显，getMatrix() 函数只是 PathMeasure.getPosTan() 函数的另一种实现而已。如下更改飞机加载动画：1234567891011121314151617181920212223242526protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 绘制路径加载动画 float length = mPathMeasure.getLength(); float stop = length * mCurAnimValue; float start = (float) (stop - ((0.5 - Math.abs(mCurAnimValue - 0.5)) * length)); mDstPath.reset(); mPathMeasure.getSegment(start, stop, mDstPath, true); canvas.drawPath(mDstPath, mPaint); // 旋转飞机图片并绘制 // 使用 getMatrix mMatrix.reset(); mPathMeasure.getMatrix(stop, mMatrix, PathMeasure.POSITION_MATRIX_FLAG|PathMeasure.TANGENT_MATRIX_FLAG); mMatrix.preTranslate(-mPlaneBmp.getWidth() / 2f,-mPlaneBmp.getHeight() / 2f); // 使用 getPosTan // mPathMeasure.getPosTan(stop, pos, tan); // float degrees = (float) (Math.atan2(tan[1], tan[0]) * 180.0 / Math.PI); // float px = mPlaneBmp.getWidth() / 2f; // float py = mPlaneBmp.getHeight() / 2f; // mMatrix.postRotate(degrees, mPlaneBmp.getWidth() / 2f, mPlaneBmp.getHeight() / 2f); // mMatrix.postTranslate(pos[0] - px, pos[1] - py); canvas.drawBitmap(mPlaneBmp, mMatrix, mPaint);&#125; 5.1.6 示例：支付宝支付成功动画 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class TestView extends View &#123; private Paint mPaint; private Path mCirclePath, mDstPath; private PathMeasure mPathMeasure; private float mCurAnimValue; private ValueAnimator mValueAnimator; private boolean mNext = false; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.BLACK); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(8); mDstPath = new Path(); mCirclePath = new Path(); mPathMeasure = new PathMeasure(); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); mCirclePath.reset(); int width = MeasureSpec.getSize(widthMeasureSpec); int height = MeasureSpec.getSize(heightMeasureSpec); int centerX = width / 2; int centerY = height / 2; int radius = Math.min(centerX, centerY) / 2; mCirclePath.addCircle(centerX, centerY, radius, Path.Direction.CW); mCirclePath.moveTo(centerX - radius/2f, centerY); // 勾的起点 mCirclePath.lineTo(centerX,centerY + radius/2f); // 勾的拐点 mCirclePath.lineTo(centerX + radius/2f,centerY - radius/3f); // 勾的终点 mPathMeasure.setPath(mCirclePath,false); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mCurAnimValue &lt; 1) &#123; float stop = mPathMeasure.getLength() * mCurAnimValue; mPathMeasure.getSegment(0, stop, mDstPath, true); &#125; else &#123; if (!mNext) &#123; mNext = true; mPathMeasure.getSegment(0, mPathMeasure.getLength(), mDstPath, true); mPathMeasure.nextContour(); &#125; else &#123; float stop = mPathMeasure.getLength() * (mCurAnimValue - 1); mPathMeasure.getSegment(0, stop, mDstPath, true); &#125; &#125; canvas.drawPath(mDstPath, mPaint); &#125; @Override protected void onDetachedFromWindow() &#123; super.onDetachedFromWindow(); if (mValueAnimator != null) &#123; mValueAnimator.cancel(); mValueAnimator = null; &#125; &#125; public void startAnim() &#123; mValueAnimator = ValueAnimator.ofFloat(0, 2); mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mCurAnimValue = (Float) animation.getAnimatedValue(); invalidate(); &#125; &#125;); mValueAnimator.setDuration(2000); mValueAnimator.start(); &#125;&#125; 使用自定义控件12345678910111213141516public class MainActivity extends AppCompatActivity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); findViewById(R.id.start_btn).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; TestView tv = findViewById(R.id.test_view); tv.startAnim(); &#125; &#125;); &#125;&#125;]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04.4 精通自定义 View 之属性动画进阶——NineOldAndroids]]></title>
    <url>%2F2019%2F07%2F04%2FCustom%20View%2F04.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94NineOldAndroids%2F</url>
    <content type="text"><![CDATA[Android 3.0 推出了全新的 Animation API，使用起来很方便，但是不能在 3.0 以下版本中使用。NineOldAndroids 是一个可以在任意 Android 版本上使用的 Animation API。 常用类有 ObjectAnimator、ValueAnimator、AnimatorSet、PropertyValuesHolder、Keyframe、ViewPropertyAnimator、ViewHelper. 4.4.1 NineOldAndroids 中的 ViewPropertyAnimator12345// 官方 API（3.1 以上）mView.animate().setDuration(5000).rotationY(720).x(100).y(100).start();// NineOldAndroidsViewPropertyAnimator.animate(mView).setDuration(5000).rotationY(720).x(100).y(100).start(); 从对比中可以看出，唯一不同的是 animate() 函数，其他诸如链式操作、各属性对应的函数、添加监听器都与官方 API 完全相同 4.4.2 NineOldAndroids 中的 ViewHelper1. 概述ViewHelper 提供了一系列 set/get 函数去操作 View 的各种属性，比如透明度、偏移量、旋转角度等，大大方便了我们的使用，而且无须考虑低版本的兼容性问题。1234567891011121314151617181920212223242526272829303132333435363738394041public static float getAlpha(View view)public static void setAlpha(View view, float alpha)public static float getPivotX(View view)public static void setPivotX(View view, float pivotX)public static float getPivotY(View view)public static void setPivotY(View view, float pivotY)public static float getRotation(View view)public static void setRotation(View view, float rotation)public static float getRotationX(View view)public static void setRotationX(View view, float rotationX)public static float getRotationY(View view)public static void setRotationY(View view, float rotationY)public static float getScaleX(View view)public static void setScaleX(View view, float scaleX)public static float getScaleY(View view)public static void setScaleY(View view, float scaleY)public static float getScrollX(View view)public static void setScrollX(View view, float scrollX)public static float getScrollY(View view)public static void setScrollY(View view, float scrollY)public static float getTranslationX(View view)public static void setTranslationX(View view, float translationX)public static float getTranslationY(View view)public static void setTranslationY(View view, float translationY)public static float getX(View view)public static void setX(View view, float x)public static float getY(View view)public static void setY(View view, float y) 2. 示例1234567891011121314final TextView tv = (TextView) findViewById(R.id.tv);findViewById(R.id.btn).setOnClickListener(new View.OnClickListener() &#123; public void onClick(View v) &#123; ValueAnimator animator = ValueAnimator.ofFloat(0, 200); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; Float cur = (Float) valueAnimator.getAnimatedValue(); ViewHelper.setTranslationX(tv, cur); ViewHelper.setTranslationY(tv, cur); &#125; &#125;); &#125;&#125;);]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04.3 精通自定义 View 之属性动画进阶——为 ViewGroup 内的组件添加动画]]></title>
    <url>%2F2019%2F07%2F04%2FCustom%20View%2F04.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E4%B8%BA%20ViewGroup%20%E5%86%85%E7%9A%84%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[4.3.0 概述为 ViewGroup 内的组件添加动画，Android 共提供了 4 种方法。1. layoutAnimation 标签与 LayoutAnimationController第一：定义一个 layoutAnimation 的 animation 文件，如：(anim/layout_animation.xml)12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layoutAnimation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:delay=&quot;1&quot; android:animationOrder=&quot;normal&quot; android:animation=&quot;@anim/slide_in_left&quot;/&gt; 第二步：在 viewGroup 类型的控件中，添加android:layoutAnimation=”@anim/layout_animation”，如：12345&lt;ListView android:id=&quot;@+id/listview&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layoutAnimation=&quot;@anim/layout_animation&quot; /&gt; 其中 @anim/slide_in_left 文件：12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;1000&quot;&gt; &lt;translate android:fromXDelta=&quot;-50%p&quot; android:toXDelta=&quot;0&quot;/&gt; &lt;alpha android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot;/&gt;&lt;/set&gt; 注意：android:layoutAnimation 只在 ViewGroup 创建的时候，才会对其中的 item 添加动画。在创建成功以后，再向其中添加 item 将不会再有动画。 2. gridLayoutAnimation 标签与 GridLayoutAnimationControllergridLayoutAnimation 与 layoutAnimation 一样有缺陷：即在 GridView 初次创建的时候有入场动画，之后新添加的数据是不会有入场动画的。 详情请点击前往：layoutAnimation &amp; gridLayoutAnimation 3. animateLayoutChanges 属性在 API 11 之后，Android 为了支持 ViewGroup 类控件，在添加和移除其中控件时自动添加动画，为我们提供了一个非常简单的属性：android:animateLayoutChanges=[true/false]，所有派生自 ViewGroup 的控件都具有此属性，只要在 XML 中添加上这个属性，就能实现添加/删除其中控件时，带有默认动画了。 4. LayoutTransition在 API 11 之后引入，可以实现在 ViewGroup 动态添加或删除其中的控件时指定动画。动画可以自定义。对比前三种方法，LayoutTransition 是最强大的。 4.3.1 animateLayoutChanges 属性 在相应的 GroupView 子类中添加 android:animateLayoutChanges=”true”。123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:id=&quot;@+id/add_btn&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;添加控件&quot;/&gt; &lt;Button android:id=&quot;@+id/remove_btn&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;移除控件&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id=&quot;@+id/layoutTransitionGroup&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:animateLayoutChanges=&quot;true&quot; android:orientation=&quot;vertical&quot;/&gt;&lt;/LinearLayout&gt; 代码：1234567891011121314151617181920212223242526272829303132333435363738394041public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private LinearLayout layoutTransitionGroup; private int i = 0; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); layoutTransitionGroup = findViewById(R.id.layoutTransitionGroup); findViewById(R.id.add_btn).setOnClickListener(this); findViewById(R.id.remove_btn).setOnClickListener(this); &#125; private void addButtonView() &#123; i++; Button button = new Button(this); button.setText(&quot;button&quot; + i); LinearLayout.LayoutParams params = new LinearLayout.LayoutParams( ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); button.setLayoutParams(params); layoutTransitionGroup.addView(button, 0); &#125; private void removeButtonView() &#123; if (i &gt; 0) &#123; layoutTransitionGroup.removeViewAt(0); &#125; i--; &#125; @Override public void onClick(View v) &#123; if (v.getId() == R.id.add_btn) &#123; addButtonView(); &#125; if (v.getId() == R.id.remove_btn) &#123; removeButtonView(); &#125; &#125;&#125; 4.3.2 LayoutTransition上面虽然在 ViewGroup 类控件 XML 中仅添加一行android:animateLayoutChanges=[true] 即可实现内部控件添加删除时都加上动画效果。但却只能使用默认动画效果，而无法自定义动画。 为了能让我们自定义动画，谷歌在 API 11 时，同时为我们引入了一个类 LayoutTransaction。要使用LayoutTransaction是非常容易的，只需要三步： 创建实例 1LayoutTransaction transitioner = new LayoutTransition(); 创建动画并设置 12ObjectAnimator animOut = ObjectAnimator.ofFloat(null, &quot;rotation&quot;, 0f, 90f, 0f);transitioner.setAnimator(LayoutTransition.DISAPPEARING, animOut); 将 LayoutTransaction 设置进 ViewGroup 1linearLayout.setLayoutTransition(mTransitioner); 在第二步中，transitioner.setAnimator 设置动画的函数声明为：1public void setAnimator(int transitionType, Animator animator) int transitionType：表示当前应用动画的对象范围，取值有：APPEARING：元素在容器中出现时所定义的动画。DISAPPEARING：元素在容器中消失时所定义的动画。CHANGE_APPEARING：由于容器中要显现一个新的元素，其它需要变化的元素所应用的动画。CHANGE_DISAPPEARING：当容器中某个元素消失，其它需要变化的元素所应用的动画。 Animator animator：表示当前所选范围的控件所使用的动画。 1. LayoutTransition.APPEARING 与 LayoutTransition.APPEARINGLayoutTransition.APPEARING 所对应的当一个控件出现时所对应的动画；LayoutTransition.DISAPPEARING 在一个控件被移除时所对应的动画。修改上一个示例代码：1234567891011121314layoutTransitionGroup = findViewById(R.id.layoutTransitionGroup);findViewById(R.id.add_btn).setOnClickListener(this);findViewById(R.id.remove_btn).setOnClickListener(this);mTransitioner = new LayoutTransition();// 入场动画：view 在这个容器中出现时触发的动画ObjectAnimator animIn = ObjectAnimator.ofFloat(null, &quot;rotationY&quot;, 0f, 360f,0f);mTransitioner.setAnimator(LayoutTransition.APPEARING, animIn);// 出场动画：view 在这个容器中消失时触发的动画ObjectAnimator animOut = ObjectAnimator.ofFloat(null, &quot;rotation&quot;, 0f, 90f, 0f);mTransitioner.setAnimator(LayoutTransition.DISAPPEARING, animOut);layoutTransitionGroup.setLayoutTransition(mTransitioner); 同时要删除 XML 中的 android:animateLayoutChanges=”true” 设置。 2. LayoutTransition.CHANGE_APPEARING在添加控件时，除了被添加控件本身的入场动画以外，其它需要移动位置的控件，在移动位置时，也被添加上了动画（left 点位移动画），这些除了被添加控件以外的其它需要移动位置的控件组合，所对应的动画就是 LayoutTransition.CHANGE_APPEARING。同样，在移除一个控件时，其它所有需要改变位置的控件组合所对应的动画就是 LayoutTransition.CHANGE_DISAPPEARING。12345678910111213141516171819202122232425public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); layoutTransitionGroup = (LinearLayout) findViewById(R.id.layoutTransitionGroup); findViewById(R.id.add_btn).setOnClickListener(this); findViewById(R.id.remove_btn).setOnClickListener(this); mTransitioner = new LayoutTransition(); // 入场动画：view 在这个容器中出现时触发的动画 ObjectAnimator animIn = ObjectAnimator.ofFloat(null, &quot;rotationY&quot;, 0f, 360f,0f); mTransitioner.setAnimator(LayoutTransition.APPEARING, animIn); // 出场动画：view 在这个容器中消失时触发的动画 ObjectAnimator animOut = ObjectAnimator.ofFloat(null, &quot;rotation&quot;, 0f, 90f, 0f); mTransitioner.setAnimator(LayoutTransition.DISAPPEARING, animOut); PropertyValuesHolder pvhLeft = PropertyValuesHolder.ofInt(&quot;left&quot;,0,100,0); PropertyValuesHolder pvhTop = PropertyValuesHolder.ofInt(&quot;top&quot;,1,1); Animator changeAppearAnimator = ObjectAnimator.ofPropertyValuesHolder( layoutTransitionGroup, pvhLeft,pvhBottom,pvhTop,pvhRight); mTransitioner.setAnimator(LayoutTransition.CHANGE_APPEARING,changeAppearAnimator); layoutTransitionGroup.setLayoutTransition(mTransitioner);&#125; 注意：1、LayoutTransition.CHANGE_APPEARING 和 LayoutTransition.CHANGE_DISAPPEARING 必须使用 PropertyValuesHolder 所构造的动画才会有效果，不然无效！也就是说使用 ObjectAnimator 构造的动画，在这里是不会有效果的！2、在构造 PropertyValuesHolder 动画时，“left”、“top” 属性的变动是必写的。如果不需要变动，则直接写为：12PropertyValuesHolder pvhLeft = PropertyValuesHolder.ofInt(&quot;left&quot;,0,0);PropertyValuesHolder pvhTop = PropertyValuesHolder.ofInt(&quot;top&quot;,0,0); 3、在构造 PropertyValuesHolder 时，所使用的 ofInt、ofFloat 中的参数值，第一个值和最后一个值必须相同，不然此属性所对应的的动画将被放弃，在此属性值上将不会有效果。4、在构造 PropertyValuesHolder 时，所使用的 ofInt，ofFloat 中，如果所有参数值都相同，也将不会有动画效果。 3. LayoutTransition.CHANGE_DISAPPEARING123456789101112131415161718192021PropertyValuesHolder outLeft = PropertyValuesHolder.ofInt(&quot;left&quot;,0,0);PropertyValuesHolder outTop = PropertyValuesHolder.ofInt(&quot;top&quot;,0,0); Keyframe frame0 = Keyframe.ofFloat(0f, 0);Keyframe frame1 = Keyframe.ofFloat(0.1f, -20f);Keyframe frame2 = Keyframe.ofFloat(0.2f, 20f);Keyframe frame3 = Keyframe.ofFloat(0.3f, -20f);Keyframe frame4 = Keyframe.ofFloat(0.4f, 20f);Keyframe frame5 = Keyframe.ofFloat(0.5f, -20f);Keyframe frame6 = Keyframe.ofFloat(0.6f, 20f);Keyframe frame7 = Keyframe.ofFloat(0.7f, -20f);Keyframe frame8 = Keyframe.ofFloat(0.8f, 20f);Keyframe frame9 = Keyframe.ofFloat(0.9f, -20f);Keyframe frame10 = Keyframe.ofFloat(1, 0);PropertyValuesHolder mPropertyValuesHolder = PropertyValuesHolder.ofKeyframe( &quot;rotation&quot;,frame0,frame1,frame2,frame3,frame4, frame5,frame6,frame7,frame8,frame9,frame10); ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder( this, outLeft,outTop,mPropertyValuesHolder);mTransitioner.setAnimator(LayoutTransition.CHANGE_DISAPPEARING, animator); 第一步：由于 left、top 属性是必须的，但我们做响铃效果时，是不需要 left，top 变动的，所有给他们设置为无效值。第二步：用 KeyFrame 构造 PropertyValuesHolder。第三步：设置 LayoutTransition.CHANGE_DISAPPEARING 动画。 4.3.3 其他函数1. 基本设置1234567891011121314151617181920212223/** * 设置所有动画完成所需要的时长 */public void setDuration(long duration)/** * 针对单个type，设置动画时长； * transitionType取值为：APPEARING、DISAPPEARING、CHANGE_APPEARING、CHANGE_DISAPPEARING */public void setDuration(int transitionType, long duration) /** * 针对单个type设置插值器 * transitionType取值为：APPEARING、DISAPPEARING、CHANGE_APPEARING、CHANGE_DISAPPEARING */public void setInterpolator(int transitionType, TimeInterpolator interpolator)/** * 针对单个type设置动画延时 * transitionType取值为：APPEARING、DISAPPEARING、CHANGE_APPEARING、CHANGE_DISAPPEARING */public void setStartDelay(int transitionType, long delay)/** * 针对单个type设置，每个子item动画的时间间隔 */public void setStagger(int transitionType, long duration) 2. LayoutTransition 设置监听12345public void addTransitionListener(TransitionListener listener)public interface TransitionListener &#123; public void startTransition(LayoutTransition transition, ViewGroup container,View view, int transitionType); public void endTransition(LayoutTransition transition, ViewGroup container,View view, int transitionType);&#125; 在 TransitionListener 中总共有四个参数： LayoutTransition transition：当前的 LayoutTransition 实例。 ViewGroup container：当前应用 LayoutTransition 的 container。 View view：当前在做动画的 View 对象。 int transitionType：当前的 LayoutTransition 类型，取值有：APPEARING、DISAPPEARING、CHANGE_APPEARING、CHANGE_DISAPPEARING。 在添加控件时，先是 start 回调，再是 end 回调；APPEARING 事件所对应的 View 是控件，而 CHANGE_APPEARING 所对应的控件是容器。删除控件时，原理相同。 这是因为，在添加控件时，APPEARING 事件只针对当前被添加的控件做动画，所以返回的 View 是当前被添加的控件。而 CHANGE_APPEARING 是对容器中所有已存在的控件做动画，所以返回的 View 是容器。]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04.2 精通自定义 View 之属性动画进阶——ViewPropertyAnimator]]></title>
    <url>%2F2019%2F07%2F04%2FCustom%20View%2F04.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94ViewPropertyAnimator%2F</url>
    <content type="text"><![CDATA[4.2.1 概述使用 ObjectAnimator：12ObjectAnimator animator = ObjectAnimator.ofFloat(mView, &quot;alpha&quot;, 0f);animator.start(); 使用 ViewPropertyAnimator：1mView.animate().alpha(0f); 除此之外，还可以非常容易地将多个动画结合起来。比如：将控件移动到点 (50, 100) 且完全透明。1mView.animate().x(50).y(100).alpha(0f); 此类事专门针对 View 对象动画而操作的类：链式调用，自动 start， 简化流程，提高效率： 提供了更简洁的链式调用设置多个属性动画，这些动画可以同时进行的。 拥有更好的性能，多个属性动画是一次同时变化，只执行一次 UI 刷新（也就是只调用一次 invalidate，而 n 个 ObjectAnimator 就会进行 n 次属性变化，就有 n 次 invalidate）。 每个属性提供两种类型方法设置。如：scaleX()、scaleXBy()。 该类只能通过 View 的 animate() 获取其实例对象的引用。 4.2.2 常用函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263view.animate() // 获取ViewPropertyAnimator对象 // 位移 .translationX(100) .translationXBy(100) .translationY(100) .translationYBy(100) .translationZ(100) // Z 轴移动，API 21 添加 .translationZBy(100) // API 21 添加 // 改变坐标 .x(100) .xBy(100) .y(100) .yBy(100) // 改变透明度 .alpha(0.1f) .alphaBy(0.1f) // 改变透明度 .scaleX(0.1f) .scaleXBy(0.1f) .scaleY(0.1f) .scaleYBy(0.1f) // 旋转 .rotation(180) .rotationX(180) .rotationBy(180) .rotationY(180) .rotationYBy(180) // 持续时间 .setDuration(1000) // 动画开始时执行 runnable，API 16 添加 .withStartAction(new Runnable() &#123; @Override public void run() &#123; &#125; &#125;) // 动画结束时执行 runnable，API 16 添加 .withEndAction(new Runnable() &#123; @Override public void run() &#123; &#125; &#125;) .withLayer() // 硬件加速,API 16添加 .setStartDelay(1000) // 执行延迟 // 设置插值器 .setInterpolator(new LinearInterpolator()) // 设置更新监听 .setUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123;&#125; &#125;) // 动画监听 .setListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123;&#125; @Override public void onAnimationEnd(Animator animation) &#123;&#125; @Override public void onAnimationCancel(Animator animation) &#123;&#125; @Override public void onAnimationRepeat(Animator animation) &#123;&#125; &#125;) .start(); 举例说明一下 xxxX() 和 xxxXBy() 函数之间的区别。如 scaleY(2f) 和 scaleYBy(2f)。12345678910111213141516171819202122public class MainActivity extends AppCompatActivity &#123; private TextView tv1, tv2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); Button startBtn = findViewById(R.id.start_btn); tv1 = findViewById(R.id.tv1); tv2 = findViewById(R.id.tv2); startBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; tv1.animate().scaleX(2f); tv2.animate().scaleXBy(2f); &#125; &#125;); &#125;&#125; 原图： 第一次点击开始动画按钮，效果图如下所示： 第二次点击开始动画按钮，效果图如下所示：]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04.1 精通自定义 View 之属性动画进阶——PropertyValuesHolder 与 Keyframe]]></title>
    <url>%2F2019%2F07%2F04%2FCustom%20View%2F04.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94PropertyValuesHolder%20%E4%B8%8E%20Keyframe%2F</url>
    <content type="text"><![CDATA[ValueAnimator、ObjectAnimator 除了 ofInt()、ofFloat()、ofObject() 函数创建 Animator 实例的方法以外，都还有一个方法：123456// valueAnimator 的public static ValueAnimator ofPropertyValuesHolder ( PropertyValuesHolder... values) // ObjectAnimator的public static ObjectAnimator ofPropertyValuesHolder ( Object target,PropertyValuesHolder... values) 4.1.1 PropertyValuesHolder1. 概述PropertyValuesHolder 这个类的意义就是，它其中保存了动画过程中所需要操作的属性和对应的值。我们通过 ofFloat(Object target, String propertyName, float… values) 构造的动画，ofFloat() 的内部实现其实就是将传进来的参数封装成 PropertyValuesHolder 实例来保存动画状态。在封装成 PropertyValuesHolder 实例以后，后期的各种操作也是以 PropertyValuesHolder 为主的。 PropertyValuesHolder 中有很多函数，有些函数的 api 等级是11，有些函数的 api 等级是 14 和 21，具体参考文档《Google：PropertyValuesHolder》 首先，我们来看看创建实例的函数：1234public static PropertyValuesHolder ofFloat(String propertyName, float... values)public static PropertyValuesHolder ofInt(String propertyName, int... values) public static PropertyValuesHolder ofObject(String propertyName, TypeEvaluator evaluator, Object... values)public static PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values) 2. PropertyValuesHolder 之 ofFloat()、ofInt()1）ofFloat()、ofInt()12public static PropertyValuesHolder ofFloat(String propertyName, float... values)public static PropertyValuesHolder ofInt(String propertyName, int... values) propertyName：表示 ObjectAnimator 需要操作的属性名。即 ObjectAnimator 需要通过反射查找对应属性的 setProperty() 函数的那个 property. values：属性所对应的参数，同样是可变长参数，可以指定多个，还记得我们在 ObjectAnimator 中讲过，如果只指定了一个，那么 ObjectAnimator 会通过查找 getProperty() 方法来获得初始值。 2）ObjectAnimator.ofPropertyValuesHolder()ObjectAnimator 提供了一个方法，构造 PropertyValuesHolder 来构造动画。12public static ObjectAnimator ofPropertyValuesHolder(Object target, PropertyValuesHolder... values) target：指需要执行动画的控件。 values：是一个可变长参数，可以传进去多个PropertyValuesHolder 实例，由于每个 PropertyValuesHolder 实例都会针对一个属性做动画，所以如果传进去多个 PropertyValuesHolder 实例，将会对控件的多个属性同时做动画操作。 3）示例 123456789101112131415161718192021222324252627282930public class MainActivity extends AppCompatActivity &#123; private TextView mTv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); Button startBtn = findViewById(R.id.start_btn); mTv = findViewById(R.id.tv); startBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startAnim(); &#125; &#125;); &#125; private void startAnim() &#123; PropertyValuesHolder rotationHolder = PropertyValuesHolder.ofFloat(&quot;rotation&quot;, 60f, -60f, 40f, -40f, 20f, -20f, 10f, -10f, 0f); PropertyValuesHolder alphaHolder = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 0.1f, 1f, 0.1f, 1f); ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(mTv, rotationHolder, alphaHolder); animator.setDuration(3000); animator.start(); &#125;&#125; 3. PropertyValuesHolder 之 ofObject()1）概述12public static PropertyValuesHolder ofObject(String propertyName, TypeEvaluator evaluator, Object... values) propertyName：ObjectAnimator 动画操作的属性名。 evaluator：Evaluator 实例，Evaluator 是将当前动画进度计算出当前值的类，可以使用系统自带的 IntEvaluator、FloatEvaluator 也可以自定义。 values：可变长参数，表示操作动画属性的值。 2）示例： 1234567891011121314151617181920212223242526272829public class MainActivity extends AppCompatActivity &#123; private TextView mTv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); Button startBtn = findViewById(R.id.start_btn); mTv = findViewById(R.id.tv); startBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startAnim(); &#125; &#125;); &#125; private void startAnim() &#123; PropertyValuesHolder charHolder = PropertyValuesHolder.ofObject(&quot;CharText&quot;, new CharEvaluator(), Character.valueOf(&apos;A&apos;), Character.valueOf(&apos;Z&apos;)); ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(mTv, charHolder); animator.setDuration(3000); animator.setInterpolator(new AccelerateInterpolator()); animator.start(); &#125;&#125; 自定义 View 和 Evaluator123456789101112131415161718192021public class MyTextView extends AppCompatTextView &#123; private Character charText; public MyTextView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public void setCharText(Character charText) &#123; setText(String.valueOf(charText)); &#125;&#125;public class CharEvaluator implements TypeEvaluator&lt;Character&gt; &#123; @Override public Character evaluate(float fraction, Character startValue, Character endValue) &#123; int startInt = (int) startValue; int endInt = (int) endValue; int result = (int) (startInt + fraction * (endInt - startInt)); return (char) result; &#125;&#125; 4.1.2 Keyframe1. 概述如果要控制动画速率的变化，可以通过自定义插值器，也可以通过自定义 Evaluator 来实现。但需要足够的数学知识。 为了解决方便的控制动画速率的问题，谷歌为了我们定义了一个 KeyFrame 的类，KeyFrame 直译过来就是关键帧。1public static Keyframe ofFloat(float fraction, float value) fraction：表示当前的显示进度，即从加速器中 getInterpolation() 函数的返回值。 value：表示当前应该在的位置。 比如 Keyframe.ofFloat(0, 0) 表示动画进度为 0 时，动画所在的数值位置为 0；Keyframe.ofFloat(0.25f, -20f) 表示动画进度为 25% 时，动画所在的数值位置为 -20；Keyframe.ofFloat(1f, 0) 表示动画结束时，动画所在的数值位置为 0。 PropertyValuesHolder 是这样使用 KeyFrame 对象的：1public static PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values) propertyName：动画所要操作的属性名。 values：Keyframe 的列表，PropertyValuesHolder 会根据每个 Keyframe 的设定，定时将指定的值输出给动画。 所以完整的 KeyFrame 的使用代码应该是这样的：12345678Keyframe frame0 = Keyframe.ofFloat(0f, 0);Keyframe frame1 = Keyframe.ofFloat(0.1f, -20f);Keyframe frame2 = Keyframe.ofFloat(1, 0);PropertyValuesHolder frameHolder = PropertyValuesHolder.ofKeyframe( &quot;rotation&quot;,frame0,frame1,frame2);Animator animator = ObjectAnimator.ofPropertyValuesHolder(mImage,frameHolder);animator.setDuration(1000);animator.start(); 2. 示例 1）布局文件 act_main.xml123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:padding=&quot;20dp&quot;&gt; &lt;Button android:id=&quot;@+id/start_btn&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;start animation&quot;/&gt; &lt;ImageView android:id=&quot;@+id/tel_img&quot; android:layout_width=&quot;70dp&quot; android:layout_height=&quot;70dp&quot; android:layout_margin=&quot;30dp&quot; android:src=&quot;@drawable/icon_tel&quot;/&gt;&lt;/LinearLayout&gt; 2）MainActivity.java 核心代码1234567891011121314151617Keyframe frame0 = Keyframe.ofFloat(0f, 0);Keyframe frame1 = Keyframe.ofFloat(0.1f, -20f);Keyframe frame2 = Keyframe.ofFloat(0.2f, 20f);Keyframe frame3 = Keyframe.ofFloat(0.3f, -20f);Keyframe frame4 = Keyframe.ofFloat(0.4f, 20f);Keyframe frame5 = Keyframe.ofFloat(0.5f, -20f);Keyframe frame6 = Keyframe.ofFloat(0.6f, 20f);Keyframe frame7 = Keyframe.ofFloat(0.7f, -20f);Keyframe frame8 = Keyframe.ofFloat(0.8f, 20f);Keyframe frame9 = Keyframe.ofFloat(0.9f, -20f);Keyframe frame10 = Keyframe.ofFloat(1f, 0);PropertyValuesHolder frameHolder = PropertyValuesHolder.ofKeyframe(&quot;rotation&quot;, frame0, frame1, frame2, frame3, frame4, frame5, frame6, frame7, frame8, frame9, frame10);Animator animator = ObjectAnimator.ofPropertyValuesHolder(mView, frameHolder);animator.setDuration(2000);animator.start(); 3. ofInt 和 ofFloat123456// ofFloatpublic static Keyframe ofFloat(float fraction) public static Keyframe ofFloat(float fraction, float value)// ofIntpublic static Keyframe ofInt(float fraction)public static Keyframe ofInt(float fraction, int value) fraction 表示当前关键帧所在的动画进度位置，value 表示当前位置所对应的值。 Keyframe 还有一些常用函数来设置 fraction，value 和 interpolator，定义如下：123456// 设置fraction参数，即Keyframe所对应的进度public void setFraction(float fraction) // 设置当前Keyframe所对应的值public void setValue(Object value)// 设置Keyframe动作期间所对应的插值器public void setInterpolator(TimeInterpolator interpolator) 如果使用 ofFloat(float fraction) 来构造，也必须使用 setValue(Object value) 来设置这个关键帧所对应的值。 4. 插值器如果给某个 Keyframe 设置上插值器，那么这个插值器就是从上一个 Keyframe 开始到当前设置插值器的 Keyframe 时，这个过程值的计算是利用这个插值器的，比如：12345Keyframe frame0 = Keyframe.ofFloat(0f, 0);Keyframe frame1 = Keyframe.ofFloat(0.1f, -20f);frame1.setInterpolator(new BounceInterpolator());Keyframe frame2 = Keyframe.ofFloat(1f, 20f);frame2.setInterpolator(new LinearInterpolator()); 在上面的代码中，我们给 frame1 设置了插值器 BounceInterpolator，那么在 frame0 到 frame1 的中间值计算过程中，就是用的就是回弹插值器；同样，我们给 frame2 设置了线性插值器 LinearInterpolator，所以在 frame1 到 frame2 的中间值计算过程中，使用的就是线性插值器。很显然，给 Keyframe.ofFloat(0f, 0) 设置插值器是无效的，因为它是第一帧。 5. Keyframe 之 ofObject 12public static Keyframe ofObject(float fraction)public static Keyframe ofObject(float fraction, Object value) 同样，如果使用 ofObject(float fraction) 来构造，也必须使用 setValue(Object value) 来设置这个关键帧所对应的值。 还以 TextView 更改字母的例子来使用下 Keyframe.ofObject：123456789Keyframe frame0 = Keyframe.ofObject(0f, Character.valueOf(&apos;A&apos;));Keyframe frame1 = Keyframe.ofObject(0.1f, Character.valueOf(&apos;L&apos;));Keyframe frame2 = Keyframe.ofObject(1f, Character.valueOf(&apos;Z&apos;));PropertyValuesHolder frameHolder = PropertyValuesHolder.ofKeyframe(&quot;CharText&quot;, frame0, frame1, frame2);frameHolder.setEvaluator(new CharEvaluator());Animator animator = ObjectAnimator.ofPropertyValuesHolder(mView, frameHolder);animator.setDuration(2000);animator.start(); 6. 疑问：如果没有设置进度为0或者进度为1时的关键帧，展示是怎样的？ 如果去掉第 0 帧，将以第一个关键帧为起始位置。 如果去掉结束帧，将以最后一个关键帧为结束位置。 使用 Keyframe 来构建动画，至少要有两个或两个以上帧，否则奔溃。 4.1.3 PropertyValuesHolder 其他函数PropertyValuesHolder 除了上面的讲到的 ofInt、ofFloat、ofObject、ofKeyframe 以外，API 11 的还有几个函数：123456789101112// 设置动画的Evaluatorpublic void setEvaluator(TypeEvaluator evaluator)// 用于设置ofFloat所对应的动画值列表public void setFloatValues(float... values)// 用于设置ofInt所对应的动画值列表public void setIntValues(int... values)// 用于设置ofKeyframe所对应的动画值列表public void setKeyframes(Keyframe... values)// 用于设置ofObject所对应的动画值列表public void setObjectValues(Object... values)// 设置动画属性名public void setPropertyName(String propertyName) 4.1.4 示例：电话响铃效果 核心代码12345678910111213141516171819202122232425262728293031323334// 左右晃动Keyframe frame0 = Keyframe.ofFloat(0f, 0);Keyframe frame1 = Keyframe.ofFloat(0.1f, -20f);Keyframe frame2 = Keyframe.ofFloat(0.2f, 20f);Keyframe frame3 = Keyframe.ofFloat(0.3f, -20f);Keyframe frame4 = Keyframe.ofFloat(0.4f, 20f);Keyframe frame5 = Keyframe.ofFloat(0.5f, -20f);Keyframe frame6 = Keyframe.ofFloat(0.6f, 20f);Keyframe frame7 = Keyframe.ofFloat(0.7f, -20f);Keyframe frame8 = Keyframe.ofFloat(0.8f, 20f);Keyframe frame9 = Keyframe.ofFloat(0.9f, -20f);Keyframe frame10 = Keyframe.ofFloat(1f, 0);PropertyValuesHolder frameHolder = PropertyValuesHolder.ofKeyframe(&quot;rotation&quot;, frame0, frame1, frame2, frame3, frame4, frame5, frame6, frame7, frame8, frame9, frame10);// X 轴缩放Keyframe scaleXFrame0 = Keyframe.ofFloat(0f, 1);Keyframe scaleXFrame1 = Keyframe.ofFloat(0.1f, 1.2f);Keyframe scaleXFrame9 = Keyframe.ofFloat(0.9f, 1.2f);Keyframe scaleXFrame10 = Keyframe.ofFloat(1f, 1);PropertyValuesHolder scaleXholder = PropertyValuesHolder.ofKeyframe(&quot;scaleX&quot;, scaleXFrame0, scaleXFrame1, scaleXFrame9, scaleXFrame10);// Y 轴缩放Keyframe scaleYFrame0 = Keyframe.ofFloat(0f, 1);Keyframe scaleYFrame1 = Keyframe.ofFloat(0.1f, 1.2f);Keyframe scaleYFrame9 = Keyframe.ofFloat(0.9f, 1.2f);Keyframe scaleYFrame10 = Keyframe.ofFloat(1f, 1);PropertyValuesHolder scaleYholder = PropertyValuesHolder.ofKeyframe(&quot;scaleY&quot;, scaleYFrame0, scaleYFrame1, scaleYFrame9, scaleYFrame10);Animator animator = ObjectAnimator.ofPropertyValuesHolder(mView, frameHolder, scaleXholder, scaleYholder);animator.setDuration(2000);animator.start();]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03.6 精通自定义 View 之属性动画——Animator 动画的 XML 实现]]></title>
    <url>%2F2019%2F07%2F03%2FCustom%20View%2F03.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94Animator%20%E5%8A%A8%E7%94%BB%E7%9A%84%20XML%20%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[在 xml 中对应 animator 总共有三个标签，分别是：123&lt;animator /&gt;: 对应ValueAnimator&lt;objectAnimator /&gt;: 对应ObjectAnimator&lt;set /&gt;: 对应AnimatorSet 3.6.1 animator 标签1. 概述下面是完整的 animator 所有的字段及取值范围：123456789&lt;animator android:duration=&quot;int&quot; android:valueFrom=&quot;float | int | color&quot; android:valueTo=&quot;float | int | color&quot; android:startOffset=&quot;int&quot; android:repeatCount=&quot;int&quot; android:repeatMode=[&quot;repeat&quot; | &quot;reverse&quot;] android:valueType=[&quot;intType&quot; | &quot;floatType&quot;] android:interpolator=[&quot;@android:interpolator/XXX&quot;]/&gt; android:duration：每次动画播放的时长。 android:valueFrom：初始动化值；取值范围为 float、int 和 color，如果取值为 float 对应的值样式应该为 89.0，取值为 Int 时，对应的值样式为：89；当取值为 clolor 时，对应的值样式为 #333333。 android:valueTo：动画结束值；取值范围同样是 float、int 和 color 这三种类型的值。 android:startOffset：动画激活延时；对应代码中的 startDelay(long delay) 函数； android:repeatCount：动画重复次数 android:repeatMode：动画重复模式，取值为 repeat 和 reverse；repeat 表示正序重播，reverse 表示倒序重播 android:valueType：表示参数值类型，取值为 intType 和 floatType；与 android:valueFrom、android:valueTo 相对应。如果这里的取值为 intType，那么 android:valueFrom、android:valueTo 的值也就要对应的是 int 类型的数值。如果这里的数值是 floatType，那么 android:valueFrom、android:valueTo 的值也要对应的设置为 float 类型的值。非常注意的是，如果 android:valueFrom、android:valueTo 的值设置为 color 类型的值，那么不需要设置这个参数。 android:interpolator：设置加速器；有关系统加速器所对应的 xml 值对照表如下： 加载 XML 文件到程序中的方法：123ValueAnimator valueAnimator = (ValueAnimator) AnimatorInflater.loadAnimator( MainActivity.this,R.animator.animator);valueAnimator.start(); 2. 示例1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:valueFrom=&quot;0&quot; android:valueTo=&quot;300&quot; android:duration=&quot;1000&quot; android:valueType=&quot;intType&quot; android:interpolator=&quot;@android:anim/bounce_interpolator&quot;/&gt; 1234567891011ValueAnimator valueAnimator = (ValueAnimator) AnimatorInflater.loadAnimator( MainActivity.this, R.animator.animator);valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; int offset = (int)animation.getAnimatedValue(); mTv1.layout(offset, offset, mTv1.getWidth() + offset, mTv1.getHeight() + offset); &#125;&#125;);valueAnimator.start(); 3.6.2 objectAnimator 标签1. 概述12345678910&lt;objectAnimator android:propertyName=&quot;string&quot; android:duration=&quot;int&quot; android:valueFrom=&quot;float | int | color&quot; android:valueTo=&quot;float | int | color&quot; android:startOffset=&quot;int&quot; android:repeatCount=&quot;int&quot; android:repeatMode=[&quot;repeat&quot; | &quot;reverse&quot;] android:valueType=[&quot;intType&quot; | &quot;floatType&quot;] android:interpolator=[&quot;@android:interpolator/XXX&quot;]/&gt; android:propertyName：对应属性名，即 ObjectAnimator 所需要操作的属性名。其它字段的意义与 animator 的意义与取值是一样的，下面再重新列举一下。 2. 示例1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:propertyName=&quot;TranslationY&quot; android:duration=&quot;2000&quot; android:valueFrom=&quot;0.0&quot; android:valueTo=&quot;400.0&quot; android:interpolator=&quot;@android:anim/accelerate_interpolator&quot; android:valueType=&quot;floatType&quot; android:repeatCount=&quot;1&quot; android:repeatMode=&quot;reverse&quot; android:startOffset=&quot;2000&quot;/&gt; 1234ObjectAnimator animator = (ObjectAnimator) AnimatorInflater.loadAnimator( MainActivity.this, R.animator.object_animator);animator.setTarget(mTv1);animator.start(); 3. color123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:propertyName=&quot;BackgroundColor&quot; android:duration=&quot;5000&quot; android:valueFrom=&quot;#ffff00ff&quot; android:valueTo=&quot;#ffffff00&quot;/&gt; 1234ObjectAnimator animator = (ObjectAnimator) AnimatorInflater.loadAnimator( MainActivity.this, R.animator.color_animator);animator.setTarget(mTv1);animator.start(); 3.6.3 set 标签1&lt;set android:ordering=[&quot;together&quot; | &quot;sequentially&quot;]&gt; 示例：12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:ordering=&quot;together&quot;&gt; &lt;objectAnimator android:propertyName=&quot;x&quot; android:duration=&quot;500&quot; android:valueFrom=&quot;0&quot; android:valueTo=&quot;400&quot; android:valueType=&quot;floatType&quot;/&gt; &lt;objectAnimator android:propertyName=&quot;y&quot; android:duration=&quot;500&quot; android:valueFrom=&quot;0&quot; android:valueTo=&quot;300&quot; android:valueType=&quot;floatType&quot;/&gt;&lt;/set&gt; 加载：1234AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator( MainActivity.this, R.animator.set_animator);set.setTarget(mTv1);set.start();]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03.5 精通自定义 View 之属性动画——AnimatorSet]]></title>
    <url>%2F2019%2F07%2F03%2FCustom%20View%2F03.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94AnimatorSet%2F</url>
    <content type="text"><![CDATA[ValueAnimator 和 ObjectAnimator 都只能单单实现一个动画，那如果我们想要使用一个组合动画，就需要用到 AnimatorSet。 AnimatorSet 针对 ValueAnimator 和 ObjectAnimator 都是适用的，但一般而言，我们不会用到 ValueAnimator 的组合动画，所以我们这篇仅讲解 ObjectAnimator 下的组合动画实现。 在 AnimatorSet 中直接给为我们提供了两个方法 playSequentially 和 playTogether，playSequentially 表示所有动画依次播放，playTogether 表示所有动画一起开始。 3.5.1 playSequentially() 与 playTogether() 函数1. playSequentially()12public void playSequentially(Animator... items);public void playSequentially(List&lt;Animator&gt; items); 这里有两种声明，第一个是我们最常用的，它的参数是可变长参数，也就是说我们可以传进去任意多个 Animator 对象。这些对象的动画会逐个播放。第二个构造函数，是传进去一个 List&lt; Animator&gt; 的列表。原理一样，也是逐个去取 List 中的动画对象，然后逐个播放。 示例： 123456789101112131415161718192021222324252627282930313233343536public class MainActivity extends AppCompatActivity &#123; private Button mButton; private TextView mTv1, mTv2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); mButton = findViewById(R.id.btn); mTv1 = findViewById(R.id.tv_1); mTv2 = findViewById(R.id.tv_2); mButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; doPlaySequentiallyAnimator(); &#125; &#125;); &#125; private void doPlaySequentiallyAnimator() &#123; ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1, &quot;BackgroundColor&quot;, 0xffff00ff, 0xffffff00, 0xffff00ff); ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1, &quot;translationY&quot;, 0, 300, 0); ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2, &quot;translationY&quot;, 0, 400, 0); AnimatorSet animatorSet = new AnimatorSet(); animatorSet.playSequentially(tv1BgAnimator, tv1TranslateY, tv2TranslateY); animatorSet.setDuration(1000); animatorSet.start(); &#125;&#125; 布局 act_main.xml：123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:id=&quot;@+id/btn&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:padding=&quot;10dp&quot; android:text=&quot;start anim&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv_2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_marginRight=&quot;30dp&quot; android:background=&quot;#ff00ff&quot; android:padding=&quot;10dp&quot; android:text=&quot;TextView-2&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_toLeftOf=&quot;@id/tv_2&quot; android:layout_marginRight=&quot;30dp&quot; android:background=&quot;#ffff00&quot; android:padding=&quot;10dp&quot; android:text=&quot;TextView-1&quot; /&gt;&lt;/RelativeLayout&gt; 2. playTogether()12public void playTogether(Animator... items);public void playTogether(Collection&lt;Animator&gt; items); 将上例中的代码更改为：12// animatorSet.playSequentially(tv1BgAnimator, tv1TranslateY, tv2TranslateY);animatorSet.playTogether(tv1BgAnimator, tv1TranslateY, tv2TranslateY); 即三个动画同时播放。 3、playSequentially 和 playTogether 函数的真正意义想必大家都看到赛马，在赛马开始前，每个马都会被放在起点的小门后面，到点了，门打开，马开始一起往前跑。而假如我们把每匹马看做是一个动画，那我们的 playTogether 就相当于赛马场里每个赛道上门的意义（当比赛开始时，每个赛道上的门会打开，马就可以开始比赛了）；也就是说，playTogether 只是一个时间点上的一起开始，对于开始后，各个动画怎么操作就是他们自己的事了，至于各个动画结不结束也是他们自已的事了。所以最恰当的描述就是门只负责打开，打开之后马咋跑，门也管不着，最后，马回不回来跟门也没啥关系。门的责任只是到点就打开而已。放在动画上，就是在激活动画之后，动画开始后的操作只是动画自己来负责。至于动画结不结束，也只有动画自己知道。 而 playSequentially 的意义就是当一匹马回来以后，再放另一匹。那如果上匹马永远没回来，那下一匹马也永远不会被放出来。放到动画上，就是把激活一个动画之后，动画之后的操作就是动画自己来负责了，这个动画结束之后，再激活下一个动画。如果上一个动画没有结束，那下一个动画就永远也不会被激活。 首先用 playTogether 来看个例子：1234567891011121314ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1, &quot;BackgroundColor&quot;, 0xffff00ff, 0xffffff00, 0xffff00ff);ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1, &quot;translationY&quot;, 0, 300, 0);tv1TranslateY.setStartDelay(1000);tv1TranslateY.setRepeatCount(ValueAnimator.INFINITE);ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2, &quot;translationY&quot;, 0, 400, 0);tv2TranslateY.setStartDelay(1000);AnimatorSet animatorSet = new AnimatorSet();animatorSet.playTogether(tv1BgAnimator, tv1TranslateY, tv2TranslateY);animatorSet.setDuration(1000);animatorSet.start(); 在这个例子中，我们将 tv1TranslateY 开始延迟 1000 毫秒开始，并设为无限循环。tv2TranslateY 设为开始延迟 1000 毫秒。而tv1BgAnimator 则是没有任何设置，所以是默认直接开始。我们来看效果图： 将上述例子做如下更改：12// animatorSet.playTogether(tv1BgAnimator, tv1TranslateY, tv2TranslateY);animatorSet.playSequentially(tv1BgAnimator, tv1TranslateY, tv2TranslateY); 使用 playSequentially 来逐个播放这三个动画，首先是tv1BgAnimator，动画结束之后，激活 tv1TranslateY。不过由于设置了延时，故 1000 毫秒再开始，而且该动画会无限循环。无限循环也就是说它永远也不会结束。那么第三个动画 tv2TranslateY 也永远不会开始。效果图如下： 总结： playTogether 和 playSequentially 在激活动画后，控件的动画情况与它们无关，他们只负责定时激活控件动画。 playSequentially 只有上一个控件做完动画以后，才会激活下一个控件的动画，如果上一控件的动画是无限循环，那下一个控件就别再指望能做动画了。 4. 实现无限循环动画因为 AnimatorSet 中没有设置循环次数的函数，所以得为每个动画设置了无限循环，并且只能用 playTogether() 函数。1234567891011121314ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1, &quot;BackgroundColor&quot;, 0xffff00ff, 0xffffff00, 0xffff00ff);tv1BgAnimator.setRepeatCount(ValueAnimator.INFINITE);ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1, &quot;translationY&quot;, 0, 300, 0);tv1TranslateY.setRepeatCount(ValueAnimator.INFINITE);ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2, &quot;translationY&quot;, 0, 400, 0);tv2TranslateY.setRepeatCount(ValueAnimator.INFINITE);AnimatorSet animatorSet = new AnimatorSet();animatorSet.playTogether(tv1BgAnimator, tv1TranslateY, tv2TranslateY);animatorSet.setDuration(1000);animatorSet.start(); 3.5.2 AnimatorSet.Builder1. 概述playTogether 和 playSequentially，分别能实现一起开始动画和逐个开始动画。但并不是非常自由的组合动画，比如我们有三个动画 A、B、C 我们想先播放 C 然后同时播放 A 和 B。利用 playTogether 和 playSequentially 是没办法实现的，所以为了更方便的组合动画，谷歌的开发人员另外给我们提供一个类 AnimatorSet.Builder。 我们这里使用 AnimatorSet.Builder 实现两个控件一同开始动画。12345678910111213ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1, &quot;BackgroundColor&quot;, 0xffff00ff, 0xffffff00, 0xffff00ff);ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1, &quot;translationY&quot;, 0, 300, 0);ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2, &quot;translationY&quot;, 0, 400, 0);AnimatorSet animatorSet = new AnimatorSet();AnimatorSet.Builder builder = animatorSet.play(tv1BgAnimator);builder.with(tv1TranslateY).with(tv2TranslateY);// animatorSet.playTogether(tv1BgAnimator, tv1TranslateY, tv2TranslateY);animatorSet.setDuration(1000);animatorSet.start(); 2. AnimatorSet.Builder 的函数从上面的代码中，我们可以看到 AnimatorSet.Builder 是通过 animatorSet.play(tv1BgAnimator) 生成的，这是生成AnimatorSet.Builder对象的唯一途径！12345678910// 表示要播放哪个动画public Builder play(Animator anim)// 和前面动画一起执行public Builder with(Animator anim)// 执行前面的动画后才执行该动画public Builder before(Animator anim)// 执行先执行这个动画再执行前面动画public Builder after(Animator anim)// 延迟 n 毫秒之后执行动画public Builder after(long delay) play(Animator anim) 表示当前在播放哪个动画，另外的 with(Animator anim)、before(Animator anim)、after(Animator anim) 都是以 play 中的当前所播放的动画为基准的。 比如，当 play(playAnim) 与 before(beforeAnim) 共用，则表示在播放 beforeAnim 之前，先播放 playAnim 动画；同样，当 play(playAnim) 与 after(afterAnim) 共用时，则表示在在播放 afterAnim 动画之后，再播放 playAnim 动画。 每个函数的返回值都是 Builder 对象，于是可以使用串行方式使用它们：1animatorSet.play(tv1BgAnimator).with(tv1TranslateY).with(tv2TranslateY); 3.5.3 AnimatorSet 监听器在 AnimatorSet 中也可以添加监听器，对应的监听器为：12345678910111213public static interface AnimatorListener &#123; // 当AnimatorSet开始时调用 void onAnimationStart(Animator animation); // 当AnimatorSet结束时调用 void onAnimationEnd(Animator animation); // 当AnimatorSet被取消时调用 void onAnimationCancel(Animator animation); /** * 当 AnimatorSet 重复时调用，由于 AnimatorSet 没有设置 * repeat 的函数，所以这个方法永远不会被调用。 */ void onAnimationRepeat(Animator animation);&#125; 示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class MainActivity extends AppCompatActivity &#123; private AnimatorSet mAnimatorSet; private TextView mTv1, mTv2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); mTv1 = findViewById(R.id.tv_1); mTv2 = findViewById(R.id.tv_2); findViewById(R.id.start_btn).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mAnimatorSet = doPlayAnimatorSet(); &#125; &#125;); findViewById(R.id.cancel_btn).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (mAnimatorSet != null) &#123; mAnimatorSet.cancel(); &#125; &#125; &#125;); &#125; private AnimatorSet doPlayAnimatorSet() &#123; ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1, &quot;translationY&quot;, 0, 400, 0); ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2, &quot;translationY&quot;, 0, 400, 0); tv2TranslateY.setRepeatCount(ValueAnimator.INFINITE); AnimatorSet animatorSet = new AnimatorSet(); animatorSet.play(tv1TranslateY).with(tv2TranslateY); animatorSet.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; Log.e(&quot;xian&quot;, &quot;animator start&quot;); &#125; @Override public void onAnimationEnd(Animator animation) &#123; Log.e(&quot;xian&quot;, &quot;animator end&quot;); &#125; @Override public void onAnimationCancel(Animator animation) &#123; Log.e(&quot;xian&quot;, &quot;animator cancel&quot;); &#125; @Override public void onAnimationRepeat(Animator animation) &#123; Log.e(&quot;xian&quot;, &quot;animator repeat&quot;); &#125; &#125;); animatorSet.setDuration(1000); animatorSet.start(); return animatorSet; &#125;&#125; 日志输出如下： 总结一下 AnimatorSet 的监听：1、AnimatorSet 的监听函数也只是用来监听 AnimatorSet 的状态的，与其中的动画无关。2、AnimatorSet 中没有设置循环的函数，所以 AnimatorSet 监听器中永远无法运行到 onAnimationRepeat() 中。 3.5.4 常用函数1. 概述在 AnimatorSet 中还有几个函数：123456// 设置单次动画时长public AnimatorSet setDuration(long duration);// 设置加速器public void setInterpolator(TimeInterpolator interpolator)// 设置ObjectAnimator动画目标控件public void setTarget(Object target) 在 AnimatorSet 中设置以后，会覆盖单个 ObjectAnimator 中的设置；即如果 AnimatorSet 中没有设置，那么就以 ObjectAnimator 中的设置为准。如果 AnimatorSet 中设置以后，ObjectAnimator 中的设置就会无效。 下面我们简单举个例子来看下：1234567891011ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1, &quot;translationY&quot;, 0, 400, 0);tv1TranslateY.setDuration(500000000);tv1TranslateY.setInterpolator(new BounceInterpolator());ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2, &quot;translationY&quot;, 0, 400, 0);tv2TranslateY.setInterpolator(new AccelerateDecelerateInterpolator());AnimatorSet animatorSet = new AnimatorSet();animatorSet.play(tv2TranslateY).with(tv1TranslateY);animatorSet.setDuration(2000);animatorSet.start(); 在第这个例子中，我们通过 animatorSet.setDuration(2000); 设置为所有动画单词运动时长为 2000 毫秒，虽然我们给 tv1TranslateY 设置了单次动画时长为 tv1TranslateY.setDuration(500000000); 但由于 AnimatorSet 设置了 setDuration(2000) 这个参数以后，单个动画的时长设置将无效。所以每个动画的时长为 2000 毫秒。 但我们这里还分别给 tv1 和 tv2 设置了加速器，但并没有给 AnimatorSet 设置加速器，那么 tv1、tv2 将按各自加速器的表现形式做动画。同样，如果我们给 AnimatorSet 设置上了加速器，那么单个动画中所设置的加速器都将无效，以 AnimatorSet 中的加速器为准。 2. setTarget(Object target) 函数12// 设置 ObjectAnimator 动画目标控件public void setTarget(Object target) 这个函数是用来设置目标控件的，也就是说，只要通过 AnimatorSet 的 setTartget 函数设置了目标控件，那么单个动画中的目标控件都以 AnimatorSet 设置的为准。12345678ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1, &quot;BackgroundColor&quot;, 0xffff00ff, 0xffffff00, 0xffff00ff);ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2, &quot;translationY&quot;, 0, 400, 0);AnimatorSet animatorSet = new AnimatorSet();animatorSet.playTogether(tv1BgAnimator,tv2TranslateY);animatorSet.setDuration(2000);animatorSet.setTarget(mTv2);animatorSet.start(); 在这段代码中，我们给 tv1 设置了改变背景色，给 tv2 设置了上下移动。但由于我们通过 animatorSet.setTarget(mTv2); 将各个动画的目标控件设置为 mTv2，所以 tv1 将不会有任何动画，所有的动画都会发生在 tv2 上。 3. setStartDelay(long startDelay) 函数12// 设置延时开始动画时长public void setStartDelay(long startDelay) 上面我们讲了，当 AnimatorSet 所拥有的函数与单个动画所拥有的函数冲突时，就以 AnimatorSet 设置为准。但唯一的例外就是 setStartDelay。 AnimatorSet 的延时是仅针对性的延长 AnimatorSet 激活时间的，对单个动画的延时设置没有影响。 AnimatorSet 真正激活延时 = AnimatorSet.startDelay + 第一个动画.startDelay 在 AnimatorSet 激活之后，第一个动画绝对是会开始运行的，后面的动画则根据自己是否延时自行处理。 3.5.5 示例：路径动画 代码 MainActivity.java：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class MainActivity extends AppCompatActivity &#123; private Button btn1, btn2, btn3, btn4, btn5; private boolean mIsMenuOpen = false; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); Button menu = findViewById(R.id.menu); btn1 = findViewById(R.id.btn1); btn2 = findViewById(R.id.btn2); btn3 = findViewById(R.id.btn3); btn4 = findViewById(R.id.btn4); btn5 = findViewById(R.id.btn5); menu.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (mIsMenuOpen) &#123; closeMenu(); mIsMenuOpen = false; &#125; else &#123; openMenu(); mIsMenuOpen = true; &#125; &#125; &#125;); &#125; private void openMenu() &#123; doAnimateOpen(btn1, 0, 5, 600); doAnimateOpen(btn2, 1, 5, 600); doAnimateOpen(btn3, 2, 5, 600); doAnimateOpen(btn4, 3, 5, 600); doAnimateOpen(btn5, 4, 5, 600); &#125; private void closeMenu() &#123; doAnimatColse(btn1, 0, 5, 600); doAnimatColse(btn2, 1, 5, 600); doAnimatColse(btn3, 2, 5, 600); doAnimatColse(btn4, 3, 5, 600); doAnimatColse(btn5, 4, 5, 600); &#125; private void doAnimateOpen(View view, int index, int total, int radius) &#123; double degree = Math.toRadians(90) / (total - 1) * index; int translationX = -(int) (Math.sin(degree) * radius); int translationY = -(int) (Math.cos(degree) * radius); AnimatorSet animatorSet = new AnimatorSet(); animatorSet.playTogether( ObjectAnimator.ofFloat(view, &quot;translationX&quot;, 0, translationX), ObjectAnimator.ofFloat(view, &quot;translationY&quot;, 0, translationY), ObjectAnimator.ofFloat(view, &quot;scaleX&quot;, 0f, 1f), ObjectAnimator.ofFloat(view, &quot;scaleY&quot;, 0f, 1f), ObjectAnimator.ofFloat(view, &quot;alpha&quot;, 0f, 1f)); animatorSet.setDuration(500); animatorSet.start(); &#125; private void doAnimatColse(View view, int index, int total, int radius) &#123; double degree = Math.toRadians(90) / (total - 1) * index; int translationX = -(int) (Math.sin(degree) * radius); int translationY = -(int) (Math.cos(degree) * radius); AnimatorSet animatorSet = new AnimatorSet(); animatorSet.playTogether( ObjectAnimator.ofFloat(view, &quot;translationX&quot;, translationX, 0), ObjectAnimator.ofFloat(view, &quot;translationY&quot;, translationY, 0), ObjectAnimator.ofFloat(view, &quot;scaleX&quot;, 1f, 0f), ObjectAnimator.ofFloat(view, &quot;scaleY&quot;, 1f, 0f), ObjectAnimator.ofFloat(view, &quot;alpha&quot;, 1f, 0f)); animatorSet.setDuration(500); animatorSet.start(); &#125;&#125; 布局文件 act_main：12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:padding=&quot;20dp&quot;&gt; &lt;Button android:id=&quot;@+id/btn1&quot; style=&quot;@style/MenuItemStyle&quot; android:background=&quot;@drawable/circle1&quot;/&gt; &lt;Button android:id=&quot;@+id/btn2&quot; style=&quot;@style/MenuItemStyle&quot; android:background=&quot;@drawable/circle2&quot;/&gt; &lt;Button android:id=&quot;@+id/btn3&quot; style=&quot;@style/MenuItemStyle&quot; android:background=&quot;@drawable/circle3&quot;/&gt; &lt;Button android:id=&quot;@+id/btn4&quot; style=&quot;@style/MenuItemStyle&quot; android:background=&quot;@drawable/circle4&quot;/&gt; &lt;Button android:id=&quot;@+id/btn5&quot; style=&quot;@style/MenuItemStyle&quot; android:background=&quot;@drawable/circle5&quot;/&gt; &lt;Button android:id=&quot;@+id/menu&quot; style=&quot;@style/MenuStyle&quot; android:background=&quot;@drawable/circle&quot;/&gt;&lt;/FrameLayout&gt; 引用资源 circle.xml：12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;oval&quot;&gt; &lt;solid android:color=&quot;@color/colorAccent&quot;/&gt; &lt;solid android:color=&quot;#983B90&quot;/&gt; &lt;solid android:color=&quot;#785B90&quot;/&gt; &lt;solid android:color=&quot;#587BA0&quot;/&gt; &lt;solid android:color=&quot;#389BF0&quot;/&gt; &lt;solid android:color=&quot;#18DB00&quot;/&gt;&lt;/shape&gt; 主题样式 style.xml：1234567891011121314&lt;resources&gt; ... &lt;style name=&quot;MenuStyle&quot; &gt; &lt;item name=&quot;android:layout_width&quot;&gt;50dp&lt;/item&gt; &lt;item name=&quot;android:layout_height&quot;&gt;50dp&lt;/item&gt; &lt;item name=&quot;android:layout_gravity&quot;&gt;right|bottom&lt;/item&gt; &lt;/style&gt; &lt;style name=&quot;MenuItemStyle&quot; &gt; &lt;item name=&quot;android:layout_width&quot;&gt;40dp&lt;/item&gt; &lt;item name=&quot;android:layout_height&quot;&gt;40dp&lt;/item&gt; &lt;item name=&quot;android:layout_margin&quot;&gt;5dp&lt;/item&gt; &lt;item name=&quot;android:layout_gravity&quot;&gt;right|bottom&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt;]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03.4 精通自定义 View 之属性动画——ObjectAnimator]]></title>
    <url>%2F2019%2F07%2F03%2FCustom%20View%2F03.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ObjectAnimator%2F</url>
    <content type="text"><![CDATA[3.4.1 概述1. 引入ObjectAnimator 派生自 ValueAnimator，所以 ValueAnimator 能用的方法，ObjectAnimator 都能用，ObjectAnimator 是 ValueAnimator 的子类。 ObjectAnimator 重载了几个方法，例如 ofInt()，ofFloat() 等，这里我以 ofFloat() 做个例子：123ObjectAnimator animator = ObjectAnimator.ofFloat(mView, &quot;alpha&quot;, 1, 0, 1);animator.setDuration(2000);animator.start(); 其构造函数如下：1public static ObjectAnimator ofFloat(Object target, String propertyName, float... values) 第一个参数用于指定这个动画要操作的是哪个控件。 第二个参数用于指定这个动画要操作这个控件的哪个属性。 第三个参数是可变长参数，是指这个属性值如何变化。 2. set 函数ObjectAnimator 做动画，是通过指定属性所对应的 set 方法来改变的。比如，我们上面指定的改变 alpha 的属性值，ObjectAnimator 在做动画时就会到指定控件（TextView）中去找对应的 setAlpha() 方法来改变控件中对应的值。在 View 中有关动画，总共有下面几组 set 方法：123456789101112131415// 1. 透明度：alpha public void setAlpha(float alpha) // 2. 旋转度数：rotation、rotationX、rotationY public void setRotation(float rotation) public void setRotationX(float rotationX) public void setRotationY(float rotationY) // 3. 平移：translationX、translationY public void setTranslationX(float translationX) public void setTranslationY(float translationY) // 4. 缩放：scaleX、scaleY public void setScaleX(float scaleX) public void setScaleY(float scaleY) 注意： 要使用 ObjectAnimator 来构造对画，要操作的控件中，必须存在对应的属性的 set 方法，而且参数类型必须与构造所使用的ofFloat() 或者 ofInt() 函数一致。 set 方法的命名必须以骆驼拼写法命名，即 set 后每个单词首字母大写，其余字母小写，即类似于 setPropertyName 所对应的属性为propertyName。 1）改变旋转度数 rotation、rotationX、rotationY float rotationX：表示围绕 X 轴旋转，rotationX 表示旋转度数 float rotationY：表示围绕 Y 轴旋转，rotationY 表示旋转度数 float rotation：表示围绕 Z 轴（垂直于屏幕）旋转，rotation 表示旋转度数 示例：12345ObjectAnimator animator = ObjectAnimator.ofFloat(mView, &quot;rotationX&quot;, 0, 270, 0);// ObjectAnimator animator = ObjectAnimator.ofFloat(mView, &quot;rotationY&quot;, 0, 180, 0);// ObjectAnimator animator = ObjectAnimator.ofFloat(mView, &quot;rotation&quot;, 0, 270, 0);animator.setDuration(2000);animator.start(); 2）移动 translationX、translationY float translationX：表示在 X 轴上的平移距离，以当前控件为原点，向右为正方向，参数 translationX 表示移动的距离。 float translationY：表示在 Y 轴上的平移距离，以当前控件为原点，向下为正方向，参数 translationY 表示移动的距离。 3）缩放 scaleX、scaleY float scaleX：在 X 轴上缩放，scaleX 表示缩放倍数 float scaleY：在 Y 轴上缩放，scaleY 表示缩放倍数 4）改变透明度 alpha float alpha：改变透明度 3.4.2 ObjectAnimator 动画原理 与 ValueAnimator 不同的是最后一步，在 ValueAnimator 中，我们要通过添加监听器来监听当前数字值。而在 ObjectAnimator 中，则是先根据属性值拼装成对应的 set 函数的名字，比如这里的 scaleY 的拼装方法就是将属性的第一个字母强制大写后，与 set 拼接，所以就是 setScaleY 。然后通过反射找到对应控件的 setScaleY(float scaleY) 函数，将当前数字值做为 setScaleY(float scale) 的参数将其传入。 如果我们要自定义 ObjectAnimator 属性就要注意以下几个点： 在命名时 set 之后的名字就是属性的名字。同时属性名字第一个字母不区分大小写，后面的名字必须与属性的名字相同。 在知道参数类型后我们才能确定我们是调用 ofFloat 还是 ofInt，这个参数是根据 setXXX 方法中的参数类型决定的。例如：setAlpha(float alpha) 其中参数类型是 float 所以上面我们使用的是 ofFloat，当然 ObjectAnimator 继承 ValueAnimatior 也有。ofObject()支持任意类型，不过和前面我们讲到的一样这里我们就要自定义自己的估值器了。 3.4.3 自定义 ObjectAnimator 属性 自定义 FallingBallImageView 和 Evaluator1234567891011121314151617181920212223public class FallingBallImageView extends AppCompatImageView &#123; public FallingBallImageView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public void setFallingPos(Point pos) &#123; layout(pos.x, pos.y, pos.x + getWidth(), pos.y + getHeight()); &#125; public static class FallingBallEvaluator implements TypeEvaluator&lt;Point&gt; &#123; private Point point = new Point(); @Override public Point evaluate(float fraction, Point startValue, Point endValue) &#123; point.x = (int)(startValue.x + fraction * (endValue.x - startValue.x)); if (fraction * 2 &lt; 1) &#123; point.y = (int) (startValue.y + fraction * 2 * (endValue.y - startValue.y)); &#125; else &#123; point.y = endValue.y; &#125; return point; &#125; &#125;&#125; 在代码中，开始动画：1234567891011121314151617181920public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); final FallingBallImageView view = findViewById(R.id.ball_img); findViewById(R.id.start_btn).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; ObjectAnimator animator = ObjectAnimator.ofObject(view, &quot;fallingPos&quot;, new FallingBallImageView.FallingBallEvaluator(), new Point(0, 0), new Point(500, 500)); animator.setDuration(2000); animator.start(); &#125; &#125;); &#125;&#125; 布局文件 act_main.xml1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;center_horizontal&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;com.xxt.xtest.FallingBallImageView android:id=&quot;@+id/ball_img&quot; android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; android:src=&quot;@drawable/circle&quot;/&gt; &lt;Button android:id=&quot;@+id/start_btn&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;30dp&quot; android:text=&quot;开启动画&quot;/&gt;&lt;/LinearLayout&gt; 其中，drawable/circle.xml123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;oval&quot;&gt; &lt;solid android:color=&quot;#FF0000&quot;/&gt;&lt;/shape&gt; 3.4.4 何时需要实现对应的 get 函数ObjectAnimator 有三个构造函数：ofInt()、ofFloat() 和 ofObject()，它们的最后一个参数都是可变长参数，用于指定动画值的变化区间。如果我们只定义一个值，如上例中改成：123ObjectAnimator animator = ObjectAnimator.ofObject(view, &quot;fallingPos&quot;, new FallingBallImageView.FallingBallEvaluator(), new Point(500, 500)); 则会发生异常，信息如下： 当且仅当我们只给动画一个值时，程序才会调用属性对应的 get 函数来得到动画初始值。如果没有初始值，就会使用系统默认值。比如 ofInt() 函数中使用的参数类型是 int 类型，而 int 类型的默认值是 0，动画就会从 0 开始。所以上述自定义控件 FallingBallImageView 设置 get 函数，那么将会以 get 函数的返回值作为初始值。123456public class FallingBallImageView extends AppCompatImageView &#123; ... public Point getFallingPos() &#123; return new Point(0, 0); &#125;&#125; 总结：当且仅当动画只有一个过渡值时，系统才会调用属性对应的 get 函数来得到动画的初始值。当不存在 get 函数时，则会去动画参数类型的默认值作为初始值；当无法取得动画参数类型的默认值时，则会直接奔溃。 3.4.5 常用函数用法和效果与 ValueAnimator 的函数是完全一样的。]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03.3 精通自定义 View 之属性动画——ofObject]]></title>
    <url>%2F2019%2F07%2F03%2FCustom%20View%2F03.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ofObject%2F</url>
    <content type="text"><![CDATA[1public static ValueAnimator ofObject(TypeEvaluator evaluator, Object... values) 3.3.1 示例：字母从 A 变化到 Z 123456789101112131415161718192021222324private void startAnim() &#123; ValueAnimator animator = ValueAnimator.ofObject(new CharEvaluator(), Character.valueOf(&apos;A&apos;), Character.valueOf(&apos;Z&apos;)); animator.setDuration(3000); animator.setInterpolator(new AccelerateInterpolator()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; char text = (Character) animation.getAnimatedValue(); mView.setText(String.valueOf(text)); &#125; &#125;); animator.start();&#125;public class CharEvaluator implements TypeEvaluator&lt;Character&gt; &#123; @Override public Character evaluate(float fraction, Character startValue, Character endValue) &#123; int startInt = (int) startValue; int endInt = (int) endValue; int value = (int) (startInt + fraction * (endInt - startInt)); return (char) value; &#125;&#125; 3.3.2 示例：抛物动画 123456789101112131415161718192021222324252627private void startAnim() &#123; ValueAnimator animator = ValueAnimator.ofObject(new FallingBallEvaluator(), new Point(0, mTop), new Point(500, 500)); animator.setDuration(3000); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; Point p = (Point) animation.getAnimatedValue(); mView.layout(p.x, p.y, p.x + mView.getWidth(), p.y + mView.getHeight()); &#125; &#125;); animator.start();&#125;public class FallingBallEvaluator implements TypeEvaluator&lt;Point&gt; &#123; private Point point = new Point(); @Override public Point evaluate(float fraction, Point startValue, Point endValue) &#123; point.x = (int)(startValue.x + fraction * (endValue.x - startValue.x)); if (fraction * 2 &lt; 1) &#123; point.y = (int) (startValue.y + fraction * 2 * (endValue.y - startValue.y)); &#125; else &#123; point.y = endValue.y; &#125; return point; &#125;&#125;]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03.2 精通自定义 View 之属性动画——自定义插值器与 Evaluator]]></title>
    <url>%2F2019%2F07%2F03%2FCustom%20View%2F03.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E5%80%BC%E5%99%A8%E4%B8%8E%20Evaluator%2F</url>
    <content type="text"><![CDATA[视图动画，只能设置插值器；但对于 Animator 而言，不仅可以设置插值器，还可以设置 Evaluator。 3.2.1 自定义插值器插值器就是用来控制动画的区间值如何被计算出来的。 1、系统自带插值器12345678910111213141516171819public class AccelerateDecelerateInterpolator extends BaseInterpolator &#123; public AccelerateDecelerateInterpolator() &#123; &#125; @SuppressWarnings(&#123;&quot;UnusedDeclaration&quot;&#125;) public AccelerateDecelerateInterpolator(Context context, AttributeSet attrs) &#123; &#125; public float getInterpolation(float input) &#123; return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f; &#125;&#125;...// 最终实现的接口：TimeInterpolatorpublic interface TimeInterpolator &#123; float getInterpolation(float input);&#125; 在 TimeInterpolator 的代码里，它只有一个函数 float getInterpolation(float input)。 参数 input：input 是 Float 类型的，它的取值范围是 0 ~ 1，表示当前动画的进度。取 0 时表示动画刚开始，取 1 时表示动画结束，取 0.5 时表示动画中间的位置，其他以此类推。它是时间概念。 返回值：表示当前实际想要显示的进度。取值可以超过 ，也可以小于 0。超过 1 表示已经超过目标值，小于 0 表示小于开始位置。 而 AccelerateDecelerateInterpolator 返回的显示进度值为：1return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f; input 是从 0 到 1，即cos(π) 到 cos(2π) 的结果值是从 -1 到 1。最终返回结果还是从 0 到 1，但是由于 Math.cos() 导致速率变化了，先加速后减速。 2、自定义插值器示例想要先减速后加速的效果，可以重写 getInterpolation 方法。123float x = (-1 + input * 2.0f) / 4f; // -0.25 ~ 0.25float y = (float) Math.tan(x * Math.PI);return y / 2f + 0.5f; 由于 tan 函数曲线变化不明显，导致加速减速效果也不明显，趋向于匀速。1234567891011121314class DecelerateAccelerateInterpolator implements TimeInterpolator &#123; public DecelerateAccelerateInterpolator() &#123; &#125; @SuppressWarnings(&#123;&quot;UnusedDeclaration&quot;&#125;) public DecelerateAccelerateInterpolator(Context context, AttributeSet attrs) &#123; &#125; public float getInterpolation(float input) &#123; float x = (-1 + input * 2.0f) / 4f; // -0.25 ~ 0.25 float y = (float) Math.tan(x * Math.PI); return y / 2f + 0.5f; &#125;&#125; 使用1animator.setInterpolator(new DecelerateAccelerateInterpolator()); 3.2.2 Evaluator1. 概述 上图所述的 4 个步骤的具体含义是：1）ofInt（0，400）：表示指定动画的数值区间，从0运动到400。2）插值器：在动画开始后通过插值器会返回当前动画进度所对应的数值进度，这个数值进度是以小数表示的，如0.2。3）Evaluator：我们通过监听器拿到的是当前动画所对应的具体数值，而不是用小数表示的数值。那么必须有一个地方会根据当前的数值进度将其转换为对应的数值，这个地方就是Evaluator。Evaluator用于将从插值器返回的数值进度（小数，0 - 1.0）转换成对应的数值。4）监听器返回：在 AnimatorUpdateListener 监听器中使用 animation.getAnimatedValue() 函数拿到 Evaluator 中返回的数值。 2. 各种 Evaluator插值器返回的小数值表示的是当前动画的数值进度，这对于无论是使用 ofFloat() 函数还是使用 ofInt() 函数定义的动画都是适用的。因为无论是什么动画，它的进度必然在 0～1 之间。0 表示还没开始，1 表示动画结束，这对于任何动画都是适用的。 而 Evaluator 则不一样，它把插值器返回的小数进度转换成当前数值进度所对应的值。如果使用 ofInt() 函数来定义动画，动画中的值应该都是 Integer 类型的，所对应的 Evaluator 在返回值时，必然返回 Integer 类型的值；如果使用 ofFloat() 函数来定义动画，动画中的值都是 Float 类型的，Evaluator 在返回值时，必然返回 Float 类型的值。 所以，每种定义方式所对应的 Evaluator 必然是它专用的。Evaluator 专用的原因在于动画数值类型不一样，在通过 Evaluator 返回时会报强转错误，所以只有在动画数值类型一样时，所对应的 Evaluator 才能通用。ofInt() 函数对应的 Evaluator 类名为 IntEvaluator，而 ofFloat() 函数对应的 Evaluator 类名为 FloatEvaluator。 通过 animator.setEvaluator() 函数来设置 Evaluator，比如：123456789101112131415private void startAnimationArgbEvaluator() &#123; ValueAnimator animator = ValueAnimator.ofInt(0xffffff00, 0xff0000ff); // 设置Evaluator animator.setEvaluator(new ArgbEvaluator()); animator.setDuration(3000); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; int curValue = (Integer) animation.getAnimatedValue(); tv_text.setBackgroundColor(curValue); &#125; &#125;); animator.start();&#125; ofInt() 函数的默认 Evaluator 是 IntEvaluator，而 ofFloat() 函数的默认 Evaluator 则是 FloatEvaluator。 可以继续看下 IntEvaluator 的源码：12345678public class IntEvaluator implements TypeEvaluator&lt;Integer&gt; &#123; public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123; int startInt = startValue; // 当前的值 = 100 + (400 - 100) * 显示进度 return (int)(startInt + fraction * (endValue - startInt)); &#125;&#125; 在 IntEvaluator 中只有一个函数 evaluate(float fraction, Integer startValue, Integer endValue)： fraction 参数就是插值器中的返回值，表示当前动画的数值进度，以百分制的小数表示。 startValue 和 endValue 分别对应 ofInt(int start，int end) 函数中 start 和 end 的数值。假设当我们定义的动画 ofInt(100，400) 进行到数值进度 20% 的时候，那么此时在 evaluate() 函数中，fraction 的值就是 0.2，startValue 的值是 100，endValue 的值是 400。 返回值就是当前数值进度所对应的具体数值，这个数值就是我们在 AnimatorUpdateListener 监听器中通过 animation.getAnimatedValue() 函数得到的数值。 总之：既可以通过重写插值器改变数值进度来改变数值位置，也可以通过改变 Evaluator 中数值进度所对应的具体数值来改变数值位置。 3. 简单实现 Evaluator自定义 MyEvaluator，并设定一个位移量。1234567891011public class MyEvaluator implements TypeEvaluator&lt;Integer&gt; &#123; private int offset; public MyEvaluator(int offset) &#123; this.offset = offset; &#125; @Override public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123; int startInt = startValue; return (int) (startInt + (endValue - startInt) * fraction + offset); &#125;&#125; 使用：1234567891011121314mView = findViewById(R.id.tv);ValueAnimator animator = ValueAnimator.ofInt(0, 400);animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; int curValue = (Integer) animation.getAnimatedValue(); mView.layout(curValue, curValue, curValue + mView.getWidth(), curValue + mView.getHeight()); &#125;&#125;);animator.setDuration(1000);animator.setEvaluator(new MyEvaluator(200));animator.start(); 4. 自定义 Evaluator 实现倒序输出1234567891011121314151617public class ReverseEvaluator implements TypeEvaluator&lt;Integer&gt; &#123; private boolean isReverse = true; public MyEvaluator() &#123; &#125; public MyEvaluator(boolean isReverse) &#123; this.isReverse = isReverse; &#125; @Override public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123; int startInt = startValue; if (isReverse) &#123; return (int) (endValue - (endValue - startInt) * fraction); &#125; else &#123; return (int) (startInt + (endValue - startInt) * fraction); &#125; &#125;&#125; 5. ArgbEvaluator除 IntEvaluator 和 FloatEvaluator 外，在 android.animation 包下还有另一个 Evaluator，名为 ArgbEvaluator，它是用来实现颜色值过渡转换的。 示例：12345678910111213public void startAnim(View v) &#123; ValueAnimator animator = ValueAnimator.ofInt(0xFFFFFF00, 0xFF0000FF); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; int curValue = (Integer) animation.getAnimatedValue(); mView.setBackgroundColor(curValue); &#125; &#125;); animator.setDuration(3000); animator.setEvaluator(new ArgbEvaluator()); animator.start();&#125; 实现原理：1234567891011121314151617181920212223242526272829303132333435363738public class ArgbEvaluator implements TypeEvaluator &#123; public Object evaluate(float fraction, Object startValue, Object endValue) &#123; int startInt = (Integer) startValue; float startA = ((startInt &gt;&gt; 24) &amp; 0xff) / 255.0f; float startR = ((startInt &gt;&gt; 16) &amp; 0xff) / 255.0f; float startG = ((startInt &gt;&gt; 8) &amp; 0xff) / 255.0f; float startB = ( startInt &amp; 0xff) / 255.0f; int endInt = (Integer) endValue; float endA = ((endInt &gt;&gt; 24) &amp; 0xff) / 255.0f; float endR = ((endInt &gt;&gt; 16) &amp; 0xff) / 255.0f; float endG = ((endInt &gt;&gt; 8) &amp; 0xff) / 255.0f; float endB = ( endInt &amp; 0xff) / 255.0f; // convert from sRGB to linear startR = (float) Math.pow(startR, 2.2); startG = (float) Math.pow(startG, 2.2); startB = (float) Math.pow(startB, 2.2); endR = (float) Math.pow(endR, 2.2); endG = (float) Math.pow(endG, 2.2); endB = (float) Math.pow(endB, 2.2); // compute the interpolated color in linear space float a = startA + fraction * (endA - startA); float r = startR + fraction * (endR - startR); float g = startG + fraction * (endG - startG); float b = startB + fraction * (endB - startB); // convert back to sRGB in the [0..255] range a = a * 255.0f; r = (float) Math.pow(r, 1.0 / 2.2) * 255.0f; g = (float) Math.pow(g, 1.0 / 2.2) * 255.0f; b = (float) Math.pow(b, 1.0 / 2.2) * 255.0f; return Math.round(a) &lt;&lt; 24 | Math.round(r) &lt;&lt; 16 | Math.round(g) &lt;&lt; 8 | Math.round(b); &#125;&#125;]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03.1 精通自定义 View 之属性动画——ValueAnimator 的基本使用]]></title>
    <url>%2F2019%2F07%2F03%2FCustom%20View%2F03.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ValueAnimator%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[3.1.1 概述Animation： View Animation（视图动画，API Level 1）|—- Tween Animation（补间动画）|—- Frame Animation（逐帧动画） Property Animation（属性动画，API Level 11）|—- ValueAnimator|—- ObjectAnimator 视图动画仅能对指定的控件做动画，而属性动画是通过改变控件的某一属性值来做动画的。视图动画还有一个缺陷，就是只能点击原始区域才能响应事件。 3.1.2 ValueAnimator 的简单使用ValueAnimator 不会对控件执行任何操作，我们可以给它设定从哪个值运动到哪个值，通过监听这些值的渐变过程来使自己操作控件。 示例：12345678910111213141516171819202122232425262728293031323334353637383940414243public class MainActivity extends AppCompatActivity &#123; private TextView mView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); mView = findViewById(R.id.tv); findViewById(R.id.start_btn).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; doAnimation(); &#125; &#125;); mView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, &quot;你逮到我了&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; private void doAnimation() &#123; final int left, top; left = mView.getLeft(); top = mView.getTop(); ValueAnimator animator = ValueAnimator.ofInt(0, 400, 200); animator.setDuration(2000); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; int curValue = (Integer) animation.getAnimatedValue(); mView.layout(curValue + left, curValue + top, curValue + left + mView.getWidth(), curValue + top + mView.getHeight()); &#125; &#125;); animator.start(); &#125;&#125; ValueAnimator 只负责对指定值区间进行动画运算，我们需要对运算过程进行监听，然后自己对控件执行动画操作；动画结束后，控件仍然可以响应单击事件。 3.1.3 常用函数1. ofInt 与 ofFloat12public static ValueAnimator ofInt(int... values)public static ValueAnimator ofFloat(float... values) 参数类型都是可变长参数，如上例中的 ofInt(0, 400, 200) 就表示从数字 0 变化到数字 400 再变化到 200。1public Object getAnimatedValue() 上例中可以强转为 Integer 是因为使用的是 ofInt 方法设定动画初始值。当使用 ofFloat 函数设定初始值后，则需要强转为 Float 类型。后面介绍的 ofObject 函数也是如此。 2. 常用函数 方法 描述 ValueAnimator setDuration(long duration) 设置动画时长，单位是毫秒 Object getAnimatedValue() 获取 ValueAnimator 在运动时当前运动点的值 void start() 开始动画 void cancel() 取消动画 void setRepeatCount(int value) 循环次数，ValueAnimator.INFINITE 表示无线循环 void setRepeatMode(int value) 循环模式：ValueAnimator.RESTART、REVERSE void setStartDelay(long startDelay) 延时多久开始，毫秒 ValueAnimator clone() 完全克隆一个 ValueAnimator 示例，包括所有设置和对监听器代码的处理。 3. 监听器1）添加监听器12345678910111213141516171819// 监听器一：监听动画过程中值的实时变化animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; // doSomething &#125;&#125;);// 监听器二：监听动画变化时的 4 个状态animator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123;&#125; @Override public void onAnimationEnd(Animator animation) &#123;&#125; @Override public void onAnimationCancel(Animator animation) &#123;&#125; @Override public void onAnimationRepeat(Animator animation) &#123;&#125;&#125;); 2）移除监听器1234567// 移除 AnimatorUpdateListenervoid removeUpdateListener(AnimatorUpdateListener listener);void removeAllUpdateListeners();// 移除 AnimatorListenervoid removeListener(AnimatorListener listener);void removeAllListeners(); 3.1.4 示例：弹跳加载中效果 自定义 LoadingImageView.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class LoadingImageView extends AppCompatImageView &#123; private int mTop; // 当前动画图片索引 private int mCurImgIndex = 0; // 动画图片总张数 private static int mImgCount = 3; public LoadingImageView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; private void init() &#123; ValueAnimator animator = ValueAnimator.ofInt(0, 200, 0); animator.setRepeatCount(ValueAnimator.INFINITE); animator.setRepeatMode(ValueAnimator.RESTART); animator.setDuration(2000); animator.setInterpolator(new AccelerateDecelerateInterpolator()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; int dx = (Integer) animation.getAnimatedValue(); setTop(mTop - dx); &#125; &#125;); animator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; setImageDrawable(getResources().getDrawable(R.drawable.pic_1)); &#125; @Override public void onAnimationEnd(Animator animation) &#123;&#125; @Override public void onAnimationCancel(Animator animation) &#123;&#125; @Override public void onAnimationRepeat(Animator animation) &#123; mCurImgIndex++; switch (mCurImgIndex % mImgCount) &#123; case 0: // setImageDrawable(getResources().getDrawable(R.drawable.pic_1)); setImageDrawable(ResourcesCompat.getDrawable( getResources(), R.drawable.pic_1, null)); break; case 1: setImageDrawable(ResourcesCompat.getDrawable( getResources(), R.drawable.pic_2, null)); break; case 2: setImageDrawable(ResourcesCompat.getDrawable( getResources(), R.drawable.pic_3, null)); break; &#125; &#125; &#125;); animator.start(); &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); mTop = top; &#125;&#125; act_main.xml123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;center_horizontal&quot; android:orientation=&quot;vertical&quot;&gt; &lt;com.xxt.xtest.LoadingImageView android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; android:layout_marginTop=&quot;100dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:src=&quot;@drawable/pic_1&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_horizontal&quot; android:layout_marginTop=&quot;10dp&quot; android:gravity=&quot;center&quot; android:text=&quot;加载中...&quot;/&gt;&lt;/LinearLayout&gt;]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02.5 精通自定义 View 之视图动画——逐帧动画]]></title>
    <url>%2F2019%2F07%2F02%2FCustom%20View%2F02.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E9%80%90%E5%B8%A7%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[2.5.1 XML 实现新建一个动画 XML 文件，在文件中使用 标签来定义动画帧序列，使用 标签来定义动画的每一帧，并在其中指定帧的持续时间等属性。 1）定义 XML 动画文件res/drawable/playing_anim.xml 或 res/anim/playing_anim.xml12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@mipmap/img00&quot; android:duration=&quot;120&quot; /&gt; &lt;item android:drawable=&quot;@mipmap/img01&quot; android:duration=&quot;120&quot; /&gt; &lt;item android:drawable=&quot;@mipmap/img02&quot; android:duration=&quot;120&quot; /&gt; &lt;item android:drawable=&quot;@mipmap/img03&quot; android:duration=&quot;120&quot; /&gt; &lt;item android:drawable=&quot;@mipmap/img04&quot; android:duration=&quot;120&quot; /&gt; &lt;item android:drawable=&quot;@mipmap/img05&quot; android:duration=&quot;120&quot; /&gt; &lt;item android:drawable=&quot;@mipmap/img06&quot; android:duration=&quot;120&quot; /&gt; &lt;item android:drawable=&quot;@mipmap/img07&quot; android:duration=&quot;120&quot; /&gt; &lt;item android:drawable=&quot;@mipmap/img08&quot; android:duration=&quot;120&quot; /&gt; &lt;item android:drawable=&quot;@mipmap/img10&quot; android:duration=&quot;120&quot; /&gt; &lt;item android:drawable=&quot;@mipmap/img11&quot; android:duration=&quot;120&quot; /&gt; &lt;item android:drawable=&quot;@mipmap/img12&quot; android:duration=&quot;120&quot; /&gt; &lt;item android:drawable=&quot;@mipmap/img13&quot; android:duration=&quot;120&quot; /&gt; &lt;item android:drawable=&quot;@mipmap/img14&quot; android:duration=&quot;120&quot; /&gt; &lt;item android:drawable=&quot;@mipmap/img15&quot; android:duration=&quot;120&quot; /&gt; &lt;item android:drawable=&quot;@mipmap/img16&quot; android:duration=&quot;120&quot; /&gt; &lt;item android:drawable=&quot;@mipmap/img17&quot; android:duration=&quot;120&quot; /&gt; &lt;item android:drawable=&quot;@mipmap/img18&quot; android:duration=&quot;120&quot; /&gt; &lt;item android:drawable=&quot;@mipmap/img19&quot; android:duration=&quot;120&quot; /&gt; &lt;item android:drawable=&quot;@mipmap/img20&quot; android:duration=&quot;120&quot; /&gt; &lt;item android:drawable=&quot;@mipmap/img21&quot; android:duration=&quot;120&quot; /&gt; &lt;item android:drawable=&quot;@mipmap/img22&quot; android:duration=&quot;120&quot; /&gt; &lt;item android:drawable=&quot;@mipmap/img23&quot; android:duration=&quot;120&quot; /&gt; &lt;item android:drawable=&quot;@mipmap/img24&quot; android:duration=&quot;120&quot; /&gt;&lt;/animation-list&gt; oneshot 用来控制动画是否循环播放，如果取值为 true，表示动画不会循环播放，否则动画会循环播放；duration 用来指定每一帧的持续播放时间。 2）设置 ImageView设置动画资源有两种方式：android:src、android:background。12345&lt;ImageView android:id=&quot;@+id/frame_image&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/playing_anim&quot;/&gt; 3）AnimationDrawable 开始动画123ImageView image = findViewById(R.id.frame_image);AnimationDrawable anim = (AnimationDrawable) image.getDrawable();anim.start(); 注意：android:src 对应 image.getDrawable()；android:background 对应 image.getBackground(); 2.5.2 代码实现12345678910111213141516AnimationDrawable animationDrawable = new AnimationDrawable();int id = 0;for (int i = 0; i &lt; 24; i++) &#123; if (i &lt; 10) &#123; id = getResources().getIdentifier(&quot;img0&quot; + i, &quot;mipmap&quot;, getPackageName()); &#125; else &#123; id = getResources().getIdentifier(&quot;img&quot; + i, &quot;mipmap&quot;, getPackageName()); &#125; Drawable drawable = getResources().getDrawable(id); animationDrawable.addFrame(drawable, 120);&#125;image.setImageDrawable(animationDrawable);animationDrawable.setOneShot(false);animationDrawable.start(); 帧动画使用比较简单，但是容易引起 OOM，在使用帧动画时应该尽量避免使用过多尺寸较大的图片。]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02.4 精通自定义 View 之视图动画——动画示例]]></title>
    <url>%2F2019%2F07%2F02%2FCustom%20View%2F02.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E5%8A%A8%E7%94%BB%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[2.4.1 镜头由远及近效果12345678910111213141516public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); ScaleAnimation scaleAnim = new ScaleAnimation(1.0f, 3f, 1.0f, 3f, Animation.RELATIVE_TO_SELF, 0.4f, Animation.RELATIVE_TO_PARENT, 0.8f); scaleAnim.setDuration(6000); scaleAnim.setFillAfter(true); scaleAnim.setInterpolator(new BounceInterpolator()); findViewById(R.id.image).startAnimation(scaleAnim); &#125;&#125; act_main.xml12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ImageView android:id=&quot;@+id/image&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:scaleType=&quot;fitXY&quot; android:src=&quot;@drawable/meinv&quot;/&gt;&lt;/LinearLayout&gt; 效果图如下： 2.4.2 加载框效果12345678910111213141516public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); RotateAnimation rotateAnim = new RotateAnimation(0, 360, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); rotateAnim.setRepeatCount(Animation.INFINITE); rotateAnim.setDuration(2000); rotateAnim.setInterpolator(new LinearInterpolator()); findViewById(R.id.loading).startAnimation(rotateAnim); &#125;&#125; 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ImageView android:id=&quot;@+id/loading&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_marginTop=&quot;50dp&quot; android:src=&quot;@drawable/loading&quot;/&gt;&lt;/RelativeLayout&gt; 效果图如下： 2.4.3 扫描动画 1234567891011121314151617181920212223242526public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); final Animation anim1 = AnimationUtils.loadAnimation(MainActivity.this, R.anim.scale_alpha_anim); final Animation anim2 = AnimationUtils.loadAnimation(MainActivity.this, R.anim.scale_alpha_anim); final Animation anim3 = AnimationUtils.loadAnimation(MainActivity.this, R.anim.scale_alpha_anim); final Animation anim4 = AnimationUtils.loadAnimation(MainActivity.this, R.anim.scale_alpha_anim); findViewById(R.id.start_can).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; findViewById(R.id.circle1).startAnimation(anim1); anim2.setStartOffset(500); findViewById(R.id.circle2).startAnimation(anim2); anim3.setStartOffset(1000); findViewById(R.id.circle3).startAnimation(anim3); anim4.setStartOffset(1500); findViewById(R.id.circle4).startAnimation(anim4); &#125; &#125;); &#125;&#125; act_main.xml1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;View android:id=&quot;@+id/circle1&quot; android:layout_width=&quot;130dp&quot; android:layout_height=&quot;130dp&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_marginTop=&quot;70dp&quot; android:background=&quot;@drawable/scan_circle&quot;/&gt; &lt;View android:id=&quot;@+id/circle2&quot; android:layout_width=&quot;130dp&quot; android:layout_height=&quot;130dp&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_marginTop=&quot;70dp&quot; android:background=&quot;@drawable/scan_circle&quot;/&gt; &lt;View android:id=&quot;@+id/circle3&quot; android:layout_width=&quot;130dp&quot; android:layout_height=&quot;130dp&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_marginTop=&quot;70dp&quot; android:background=&quot;@drawable/scan_circle&quot;/&gt; &lt;View android:id=&quot;@+id/circle4&quot; android:layout_width=&quot;130dp&quot; android:layout_height=&quot;130dp&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_marginTop=&quot;70dp&quot; android:background=&quot;@drawable/scan_circle&quot;/&gt; &lt;ImageView android:id=&quot;@+id/start_can&quot; android:layout_width=&quot;130dp&quot; android:layout_height=&quot;130dp&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_marginTop=&quot;70dp&quot; android:src=&quot;@drawable/music&quot;/&gt;&lt;/RelativeLayout&gt; scan_circle.xml12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;oval&quot;&gt; &lt;solid android:color=&quot;#FF6C2F&quot;/&gt;&lt;/shape&gt; scale_alpha_anim.xml12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;2000&quot;&gt; &lt;alpha android:repeatCount=&quot;infinite&quot; android:fromAlpha=&quot;0.4&quot; android:toAlpha=&quot;0&quot;/&gt; &lt;scale android:repeatCount=&quot;infinite&quot; android:fromXScale=&quot;1.0&quot; android:fromYScale=&quot;1.0&quot; android:toXScale=&quot;3&quot; android:toYScale=&quot;3&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; /&gt;&lt;/set&gt;]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02.3 精通自定义 View 之视图动画——插值器初探]]></title>
    <url>%2F2019%2F07%2F02%2FCustom%20View%2F02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[2.3.0 概述有关动画的变化速率的问题是由 Interpolator 类来决定的。Interpolator 叫插值器，也叫加速器，是用来指定动画如何变化的变量。它只是一个接口，通过实现这个接口就可以自定义动画的变化速率。系统提供了如下几个实现了插值器的类： nterpolator class Resource ID AccelerateDecelerateInterpolator @android:anim/accelerate_decelerate_interpolator AccelerateInterpolator @android:anim/accelerate_interpolator DecelerateInterpolator @android:anim/decelerate_interpolator LinearInterpolator @android:anim/linear_interpolator BounceInterpolator @android:anim/bounce_interpolator AnticipateInterpolator @android:anim/anticipate_interpolator OvershootInterpolator @android:anim/overshoot_interpolator AnticipateOvershootInterpolator @android:anim/anticipate_overshoot_interpolator CycleInterpolator @android:anim/cycle_interpolator 关于插值器，有两种使用方法。 方法一、在 XML 文件中引用插值器123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fromAlpha=&quot;1.0&quot; android:toAlpha=&quot;0.1&quot; android:duration=&quot;3000&quot; android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;/&gt; 方法二、通过 setInterpolator() 函数设置插值器123AlphaAnimation alphaAnim = new AlphaAnimation(1.0f, 0.1f);alphaAnim.setDuration(3000);alphaAnim.setInterpolator(new LinearInterpolator()); 2.3.1 AccelerateDecelerateInterpolator加速减速插值器，表示在开始与结束的地方速率改变比较慢，在中间的时候加速。1234567TranslateAnimation alphaAnim = new TranslateAnimation( Animation.RELATIVE_TO_SELF, 0, Animation.RELATIVE_TO_PARENT, 0.5f, Animation.RELATIVE_TO_SELF, 0, Animation.RELATIVE_TO_PARENT, 0.5f);alphaAnim.setDuration(2000);alphaAnim.setFillAfter(true);alphaAnim.setInterpolator(new AccelerateDecelerateInterpolator());view.startAnimation(alphaAnim); 2.3.2 AccelerateInterpolator加速插值器，表示在动画开始的地方速率比较慢，然后开始加速。1alphaAnim.setInterpolator(new AccelerateInterpolator()); 2.3.3 DecelerateInterpolator减速插值器，表示在动画开始的一瞬间加速到最大值，然后逐渐变慢。1alphaAnim.setInterpolator(new DecelerateInterpolator()); 2.3.4 LinearInterpolator线性插值器，也称匀速插值器，显然，它的速率是保持恒定的。1alphaAnim.setInterpolator(new LinearInterpolator()); 2.3.5 BounceInterpolator弹跳插值器，模拟了控件自由落地后回弹的效果。1alphaAnim.setInterpolator(new BounceInterpolator()); 2.3.6 AnticipateInterpolator初始偏移插值器，表示在动画开始的时候向前偏移一段距离，然后应用动画。12public AnticipateInterpolator()public AnticipateInterpolator(float tension) 参数 float tension 对应的 XML 属性为 android:tension，表示张力值，默认值为 2。值越大，初始的偏移量越大，而且速度越快。0 表示不偏移。 示例：1alphaAnim.setInterpolator(new AnticipateInterpolator(4)); 2.3.7 OvershootInterpolator结束偏移插值器，表示在动画结束的时候沿动画方向继续运动一段距离后再结束动画。12public OvershootInterpolator()public OvershootInterpolator(float tension) 参数 float tension 对应的 XML 属性为 android:tension，表示张力值，默认值为 2。值越大，结束时的偏移量越大。0 表示不偏移。 1alphaAnim.setInterpolator(new OvershootInterpolator()); 2.3.8 AnticipateOvershootInterpolator是 AnticipateInterpolator 和 OvershootInterpolator 的合体，即在动画开始时向前偏移一段距离后，在动画结束的时候沿动画方向继续运动一段距离后再结束动画。123public AnticipateOvershootInterpolator()public AnticipateOvershootInterpolator(float tension)public AnticipateOvershootInterpolator(float tension, float extraTension) 参数 float tension 对应的 XML 属性为 android:tension，表示张力值，默认值为 2。值越大，初始和结束的偏移量越大。0 表示不偏移。 参数 float extraTension 对应的 XML 属性为 android:extraTension，表示额外张力值，默认值为 1.5。 1alphaAnim.setInterpolator(new AnticipateOvershootInterpolator()); 2.3.9 CycleInterpolator循环插值器，表示动画循环播放特定的次数，速率沿正弦曲线改变。123456TranslateAnimation alphaAnim = new TranslateAnimation( Animation.RELATIVE_TO_SELF, 0, Animation.RELATIVE_TO_PARENT, 0.5f, Animation.RELATIVE_TO_SELF, 0, Animation.RELATIVE_TO_PARENT, 0.5f);alphaAnim.setDuration(2000);alphaAnim.setFillAfter(true);alphaAnim.setInterpolator(new CycleInterpolator()); 虽然设置了 setFillAfter(true)，但对于 CycleInterpolator 而言并没有什么影响，动画结束后，视图还原到初始位置。]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02.2 精通自定义 View 之视图动画——视图动画的代码实现]]></title>
    <url>%2F2019%2F07%2F02%2FCustom%20View%2F02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[2.2.1 概述使用 XML 来添加动画可以很大限度地提高代码复用性，但有时只需要临时使用一个动画，就没有必要单独写一个XML动画文件了，可以使用代码的方法生成一个动画操作。 标签 类 scale ScaleAnimation alpha AlphaAnimation rotate RotateAnimation translate TranslateAnimation set AnimationSet Animation 类中共用的属性方法： 标签属性 方 法 说明 android:duration setDuration(long) 动画的运行时间(以毫秒为单位)；必须设置 android:fillAfter setFillAfter(boolean) 动画结束时是否保持动画最后的状态；默认为false，优先于fillBefore android:fillBefore setFillBefore(boolean) 动画结束时是否还原到开始动画前的状态；默认为true android:fillEnabled setFillEnabled(boolean) 是否应用fillBefore的值，对fillAfter无影响；默认为true android:repeatCount setRepeatCount(int) 重复次数，取值为整数或 Animation.INFINITE。 android:repeatMode setRepeatMode(int) 重复类型有两个值，reverse表示倒序回放，restart表示从头播放 android:interpolator setInterpolator(Interpolator) 设定插值器（指定的动画效果，譬如回弹等） android:detachWallpaper setDetachWallpaper(boolean) android:startOffset setStartOffset(long) 调用start函数之后等待开始运行的时间，单位为毫秒 android:zAdjustment setZAdjustment(int) 表示被设置动画的内容运行时在Z轴上的位置（top/bottom/normal），默认为normal 2.2.2 ScaleAnimation123456ScaleAnimation(float fromX, float toX, float fromY, float toY)ScaleAnimation(float fromX, float toX, float fromY, float toY, float pivotX, float pivotY)ScaleAnimation(float fromX, float toX, float fromY, float toY, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue) pivotXType 取值为：Animation.ABSOLUTE、Animation.RELATIVE_TO_SELF、Animation.RELATIVE_TO_PARENT 示例：123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fromXScale=&quot;0.0&quot; android:toXScale=&quot;1.4&quot; android:fromYScale=&quot;0.0&quot; android:toYScale=&quot;1.4&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:duration=&quot;700&quot;/&gt; 对应代码：12345ScaleAnimation scaleAnim = new ScaleAnimation(0.0f, 1.4f, 0.0f, 1.4f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);scaleAnim.setDuration(700);tv.startAnimation(scaleAnim); 2.2.3 AlphaAnimation1AlphaAnimation(float fromAlpha, float toAlpha) 示例：123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fromAlpha=&quot;1.0&quot; android:toAlpha=&quot;0.1&quot; android:fillBefore=&quot;true&quot; android:duration=&quot;3000&quot;/&gt; 对应代码：123AlphaAnimation alphaAnim = new AlphaAnimation(1.0f, 0.1f);alphaAnim.setDuration(3000);alphaAnim.setFillBefore(true); 2.2.4 RotateAnimation12345RotateAnimation(float fromDegrees, float toDegrees)RotateAnimation(float fromDegrees, float toDegrees, float pivotX, float pivotY)RotateAnimation(float fromDegrees, float toDegrees, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue) pivotXType 取值为：Animation.ABSOLUTE、Animation.RELATIVE_TO_SELF、Animation.RELATIVE_TO_PARENT 示例：12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fromDegrees=&quot;0&quot; android:toDegrees=&quot;-650&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:duration=&quot;3000&quot; android:fillAfter=&quot;true&quot;/&gt; 对应代码：12345RotateAnimation alphaAnim = new RotateAnimation(0, -650, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);alphaAnim.setDuration(3000);alphaAnim.setFillAfter(true); 2.2.5 TranslateAnimation123456TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta)TranslateAnimation(int fromXType, float fromXValue, int toXType, float toXValue, int fromYType, float fromYValue, int toYType, float toYValue) 示例：12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fromXDelta=&quot;0&quot; android:toXDelta=&quot;-80&quot; android:fromYDelta=&quot;0&quot; android:toYDelta=&quot;-80&quot; android:duration=&quot;2000&quot; android:fillBefore=&quot;true&quot;/&gt; 对应代码：12345TranslateAnimation alphaAnim = new TranslateAnimation( Animation.ABSOLUTE, 0, Animation.ABSOLUTE, -80, Animation.ABSOLUTE, 0, Animation.ABSOLUTE, -80);alphaAnim.setDuration(2000);alphaAnim.setFillBefore(true); 2.2.6 AnimationSet1AnimationSet(boolean shareInterpolator) shareInterpolator 参数取值为 true 时，用于 AnimationSet 类中定义一个插值器，其下面的所有动画共用该插值器；取值为 false，则表示其下面的动画定义各自的插值器。增加动画的函数：1public void addAnimation(Animation a) 示例：1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;2000&quot; android:fillAfter=&quot;true&quot;&gt; &lt;alpha android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot;/&gt; &lt;scale android:fromXScale=&quot;0.0&quot; android:toXScale=&quot;1.4&quot; android:fromYScale=&quot;0.0&quot; android:toYScale=&quot;1.4&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; /&gt; &lt;rotate android:fromDegrees=&quot;0&quot; android:toDegrees=&quot;720&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot;/&gt;&lt;/set&gt; 对应代码：123456789101112131415Animation alphaAnim = new AlphaAnimation(0, 1.0f);Animation scaleAnim = new ScaleAnimation(0, 1.4f, 0, 1.4f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);Animation rotateAnim = new RotateAnimation(0, 720, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);AnimationSet setAnim = new AnimationSet(true);setAnim.addAnimation(alphaAnim);setAnim.addAnimation(scaleAnim);setAnim.addAnimation(rotateAnim);setAnim.setDuration(3000);setAnim.setFillAfter(true);view.startAnimation(setAnim); 2.2.7 AnimationAnimation 还有一些比较实用的方法介绍，如下：| 方法 | 说明 || :—–: | —–: || cancel() | 取消动画 || reset() | 将控件重置到动画开始前状态 || hasStarted() | 判断当前 Animation 是否开始 || hasEnded() | 判断当前 Animation 是否结束 || setAnimationListener() | 设置动画监听 | Animation.AnimationListener：12345678public static interface AnimationListener &#123; // 动画开始时调用 void onAnimationStart(Animation animation); // 动画结束时调用 void onAnimationEnd(Animation animation); // 动画重复时调用 void onAnimationRepeat(Animation animation);&#125; 示例：12345678910111213141516171819202122final RotateAnimation rotateAnim = new RotateAnimation(0, 720, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);rotateAnim.setDuration(2000);rotateAnim.setFillAfter(true);ScaleAnimation scaleAnim = new ScaleAnimation(0, 1.4f, 0, 1.4f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);scaleAnim.setDuration(700);scaleAnim.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123;&#125; @Override public void onAnimationEnd(Animation animation) &#123; view.startAnimation(rotateAnim); &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125;&#125;);view.startAnimation(scaleAnim);]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02.1 精通自定义 View 之视图动画——视图动画标签]]></title>
    <url>%2F2019%2F07%2F02%2FCustom%20View%2F02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[Animation： View Animation（视图动画，API Level 1）|—- Tween Animation（补间动画）|—- Frame Animation（逐帧动画） Property Animation（属性动画，API Level 11）|—- ValueAnimator|—- ObjectAnimator 2.1.1 概述视图动画分为 5 种类型组成：scale：渐变透明度动画效果alpha：渐变尺寸伸缩动画效果rotate：画面转移旋转动画效果translate：画面变化位置移动动画效果set：定义动画集 1. 配置 XML 动画文件1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&gt;&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fromXScale=&quot;0.0&quot; android:toXScale=&quot;1.4&quot; android:fromYScale=&quot;0.0&quot; android:toYScale=&quot;1.4&quot; android:duration=&quot;700&quot; 2. 动画文件存放位置存放在 res/anim 文件夹下，访问时使用 R.anim.XXX。存放在 res/drawable 文件夹下，访问时使用 R.drawable.XXX。 3. 使用动画文件123View view = findViewById(R.id.view);Animation animation = AnimationUtils.loadAnimation(this, R.anim.scale_anim);view.startAnimation(animation); 2.1.2 scale 标签scale 标签用于缩放动画，可以实现动态调整控件尺寸的效果： android:fromXScale：动画开始时，控件在 X 轴方向上相对自身的缩放比例，浮点值。1.0 代表自身无变化，0.5 表示缩小一倍，2.0 代表放大一倍。 android:toXScale：动画结束时，控件在 X 轴方向上相对自身的缩放比例，浮点值。 android:fromYScale：动画开始时，控件在 Y 轴方向上相对自身的缩放比例，浮点值。 android:toYScale：动画结束时，控件在 Y 轴方向上相对自身的缩放比例，浮点值。 android:pivotX：缩放起始点 X 轴坐标。是数值如 50，则表示在当前控件的左上角原点 X 轴坐标 + 50px，作为缩放起始点 X 轴坐标；是百分数如 50%，则表示在当前控件的左上角原点 X 轴坐标 + 自身宽度的 50%，作为缩放起始点 X 轴坐标；是百分数 p 如 50%p，则表示在当前控件的左上角原点 X 轴坐标 + 父控件宽度的 50%，作为缩放起始点 X 轴坐标； android:pivotY：缩放起始点 Y 轴坐标。取值同上。 示例：缩放动画 scale1.xml：android:pivotX=”50”12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fromXScale=&quot;0.0&quot; android:toXScale=&quot;1.0&quot; android:fromYScale=&quot;0.0&quot; android:toYScale=&quot;1.0&quot; android:pivotX=&quot;50&quot; android:duration=&quot;700&quot;/&gt; 缩放动画 scale2.xml：android:pivotX=”50%”12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fromXScale=&quot;0.0&quot; android:toXScale=&quot;1.0&quot; android:fromYScale=&quot;0.0&quot; android:toYScale=&quot;1.0&quot; android:pivotX=&quot;50%&quot; android:duration=&quot;700&quot;/&gt; 缩放动画 scale3.xml：android:pivotX=”50%”12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fromXScale=&quot;0.0&quot; android:toXScale=&quot;1.0&quot; android:fromYScale=&quot;0.0&quot; android:toYScale=&quot;1.0&quot; android:pivotX=&quot;50%p&quot; android:duration=&quot;700&quot;/&gt; 2.1.3 Animation 继承属性所有的动画都继承自 Animation 类，它的内部实现了一些共用的动画属性： android:duration：一次动画的持续时间，单位毫秒。 android:fillAfter：为 true 表示控件动画结束时，将保持动画结束时的状态。 android:fillBefore：为 true 表示控件动画结束时，将还原到初始化状态。默认为 true。 android:fillEnabled：同 fillBefore。 android:repeatCount：指定动画的重复次数，取值为 infinite 时，表示无限循环。 android:repeatMode：设定重复的类型，有 reverse（倒序回放） 和 restart（重放） 两个值。与 repeatCount 一起使用才有效果。 android:interpolator：设定插值器，指定动画效果，比如弹跳效果。 2.1.4 alpha 标签alpha 标签用于实现渐变透明度动画效果。除从 Animation 类继承而来的属性外，自身所具有的属性如下： android:fromAlpha：动画开始的透明度，取值范围 0.0 ~ 1.0，0.0 表示完全透明，1.0 表示完全不透明。 android:toAlpha：动画结束的透明度，取值范围 0.0 ~ 1.0，0.0 表示完全透明，1.0 表示完全不透明。 示例：1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fromAlpha=&quot;1.0&quot; android:toAlpha=&quot;0.5&quot; android:repeatMode=&quot;reverse&quot; android:repeatCount=&quot;infinite&quot; android:duration=&quot;700&quot;/&gt; 2.1.5 rotate 标签rotate 标签用于实现画面转移旋转动画效果。除从 Animation 类继承而来的属性外，自身所具有的属性如下： android:fromDegrees：动画开始旋转时的角度位置，正值代表顺时针方向的度数，负值代表逆时针方向的度数。 android:toDegrees：动画结束时旋转到的角度位置，正值代表顺时针方向的度数，负值代表逆时针方向的度数。 android:pivotX：旋转中心点 X 轴坐标，默认旋转中心点为控件的坐标原点（左上角），可以是数值、百分数、百分数p 三种样式。 android:pivotY：旋转中心点 Y 轴坐标，同上。 示例：123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fromDegrees=&quot;0&quot; android:toDegrees=&quot;180&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:repeatMode=&quot;restart&quot; android:repeatCount=&quot;infinite&quot; android:duration=&quot;700&quot;/&gt; 2.1.6 translate 标签translate 标签用于实现画面转移旋转动画效果。除从 Animation 类继承而来的属性外，自身所具有的属性如下： android:fromXDelta：起始点 X 轴坐标，可以是数值、百分数、百分数p。 android:fromYDelta：起始点 Y 轴坐标，同上。 android:toXDelta：终点 X 轴坐标。 android:toYDelta：终点 Y 轴坐标。 示例：1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;0&quot; android:toXDelta=&quot;-50%&quot; android:toYDelta=&quot;-50%&quot; android:duration=&quot;1500&quot;/&gt; 2.1.7 set 标签set 标签是一个容器类标签，用于定义动画集。前面的 4 个标签只能完成特定的功能，而 set 标签则可以把这些动画效果组合起来，共同完成一个动画。set 标签自身没有属性，它的属性都是从 Animation 类继承而来的。当这些属性用于 set 标签时，就会对 set 标签下的所有子控件产生作用。但 repeateCount 属性是无效的，必须对每个动画单独设置才有作用。 示例：1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;2000&quot; android:fillAfter=&quot;true&quot;&gt; &lt;alpha android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot;/&gt; &lt;scale android:fromXScale=&quot;0.0&quot; android:toXScale=&quot;1.4&quot; android:fromYScale=&quot;0.0&quot; android:toYScale=&quot;1.4&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; /&gt; &lt;rotate android:fromDegrees=&quot;0&quot; android:toDegrees=&quot;720&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot;/&gt;&lt;/set&gt;]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01.6 精通自定义 View 之绘图基础——控件的使用方法]]></title>
    <url>%2F2019%2F07%2F01%2FCustom%20View%2F01.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.6.1 控件概述在自定义一个派生自 View 或 ViewGroup 类的控件时，必须实现一个构造函数。有三个构造函数供我们选择。 1234567891011public class CustomView extends View &#123; public CustomView(Context context) &#123; super(context); &#125; public CustomView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public CustomView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); &#125;&#125; 其实每种构造函数都是在特定的使用情景下所必须实现的，否则将会报 inflate 错误。 1.6.2 通过XML引入控件使用以下方式引入控件：1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout ...&gt; &lt;com.xxt.xtest.CustomView ... /&gt;&lt;/LinearLayout&gt; 就必须实现第二个构造函数：123public CustomView(Context context, AttributeSet attrs) &#123; super(context, attrs);&#125; 1.6.3 动态添加控件1. 概述示例如下：123456LinearLayout rootView = (LinearLayout)findViewById(R.id.root);CustomView customView = new CustomView(this);LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams ( LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.MATCH_PARENT);rootView.addView(customView,layoutParams); 2. LayoutParams12345// 第一个构造函数常用public LayoutParams(int width, int height)// 用于从 AttributeSet 中􏰑取出 layout_width、 layout_height 等各属性的值public LayoutParams(Context c, AttributeSet attrs)public LayoutParams(LayoutParams source) 每个容器类控件都会实现一套 LayoutParams 类，而子类则用的是父容器的 LayoutParams 类。比如上述中父容器是 LinearLayout，所以使用 LinearLayout.LayoutParams。之所以不能共用，是因为各个容器所对应的布局属性是不一样的。 在 RelativeLayout 中，实现添加到 TextView 控件的右侧：addRule()1234567RelativeLayout rootView = (RelativeLayout) findViewById(R.id.root); CustomView customView = new CustomView(this);RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams( RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_ PARENT);layoutParams.addRule(RelativeLayout.RIGHT_OF,R.id.text); rootView.addView(customView, layoutParams); 1）设置 margin12345LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams( LinearLayout. LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT);lp.setMargins(10, 20, 30, 40);imageView.setLayoutParams(lp); 2）设置 layout_weight (方法一)12345678TextView tv_like = new TextView(this);LinearLayout.LayoutParams LP_LIKE_MW = new LinearLayout.LayoutParams ( LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_ CONTENT, 1.0f);tv_like.setText(&quot;赞(8)&quot;); tv_like.setTextSize(16); layout_sub_Lin.addView(tv_like, LP_LIKE_MW); 3）设置 layout_weight (方法二)12345LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams( LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.MATCH_ PARENT);layoutParams.weight = 1.0f;rootView.addView(customView, layoutParams); 4）设置 layout_gravity123456LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams( LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.MATCH_ PARENT);params.gravity = Gravity.TOP;Button button = new Button(this);rootView.addView(button, layoutParams); 5）设置 android:gravity1234567891011RelativeLayout rootView = (RelativeLayout) findViewById(R.id.root);RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams( RelativeLayout.LayoutParams.WRAP_CONTENT, 200);layoutParams.addRule(RelativeLayout.RIGHT_OF, R.id.text);Button button = new Button(this); button.setGravity(Gravity.TOP);button.setText(&quot;btn&quot;);rootView.addView(button, layoutParams); rootView.setGravity(Gravity.TOP | Gravity.CENTER_HORIZONTAL); 3. addView动态添加控件都是通过 addView 来实现的，addView 是 ViewGroup 类中的一个函数，它有 5 个构造函数：123456789101112131415161718// 在节点末尾添加一个 View 控件，布局使用默认布局// layout_width = wrap_content、layout_height = wrap_contentpublic void addView(View child)// 在指定位置添加一个 View 控件，index 的取值有-1、0 和正数。// -1：表示在末尾添加一个 View 控件// 0：表示在容器顶端添加一个 View 控件// 正数：表示在对应的索引位置插入一个 View 控件public void addView(View child, int index)// 使用自定义自定义布局参数，在节点末尾添加一个 View 控件public void addView(View child, LayoutParams params)// 使用自定义自定义布局参数，在指定位置添加一个 View 控件public void addView(View child, int index, LayoutParams params)// 只指定宽和高public void addView(View child, int width, int height)]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01.5 精通自定义 View 之绘图基础——Canvas]]></title>
    <url>%2F2019%2F07%2F01%2FCustom%20View%2F01.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Canvas%2F</url>
    <content type="text"><![CDATA[1.5.1 Canvas变换1. 平移(Translate)画布的原始状态是以左上角为原点，向右是X轴正方向，向下是Y轴正方向。1void translate(float dx, float dy) 参数:float dx：水平方向平移的距离，正数为向正方向(向右)平移的量，负数为向负方向 (向左)平移的量。float dy：垂直方向平移的距离，正数为向正方向(向下)平移的量，负数为向负方向 (向上)平移的量。 示例：12345678paintGreen = generatePaint(Color.GREEN, Paint.Style.STROKE, 3);paintRed = generatePaint(Color.RED, Paint.Style.STROKE, 3);rect = new Rect(20,20,400,220);canvas.drawRect(rect, paintGreen);// 画布平移canvas.translate(100, 100);canvas.drawRect(rect, paintRed); 上述示例中，调用 canvas.translate(100, 100) 后，绿色矩形区域并没有随着画布移动。这是由于屏幕显示与 Canvas 根本不是一个概念！ 2. 屏幕显示与 Canvas 的关系Canvas 是一个很虚幻的概念，相当于一个透明图层。每次在 Canvas 上画图时(调用 drawXXX 系列函数)，都会先产生一个透明图层，然后在这个图层上画图，画完之后覆盖在屏幕上显示。所以，上述结果是经以下几个步骤形成的:(1) 在调用 canvas.drawRect(rect1, paint_green) 时，产生一个 Canvas 透明图层，由于当时还没有对坐标系进行平移，所以坐标原点是(0,0)；在 Canvas 上画好之后，覆盖到屏幕上显示出来。过程如下图所示。 (2) 在调用 canvas.drawRect(rect1, paint_red) 时，又会产生一个全新的 Canvas 透明图层，但此时画布坐标已经改变了，即分别向右和向下移动了 100 像素，所以此时的绘图方式如下图所示(合成视图，从上往下看的合成方式)。 总结： 当每次调用 drawXXX 系列函数来绘图时，都会产生一个全新的 Canvas 透明图层。 如果在调用 drawXXX 系列函数前，调用平移、旋转等函数对 Canvas 进行了操作，那么这个操作是不可逆的。每次产生的画布的最新位置都是这些操作后的位置。 在 Canvas 图层与屏幕合成时，超出屏幕范围的图像是不会显示出来的。 3. 旋转(Rotate)画布的旋转默认是围绕坐标原点来进行的。这里容易产生错觉，看起来是图片旋转了，其实我们旋转的是画布，以后在此画布上绘制的图形显示出来的时候看起来都是旋转的。12void rotate(float degrees)void rotate(float degrees, float px, float py) 参数： float degrees：旋转的度数，正数指顺时针旋转。旋转中心点是(0,0)。 float px, py：指定旋转的中心点坐标(px,py)。 示例：123456789101112131415public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.BLUE); mPaint.setStyle(Paint.Style.STROKE); mRect = new RectF(300,50,500,150);&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; canvas.drawRect(mRect, mPaint); mPaint.setColor(Color.RED); mPaint.setStyle(Paint.Style.FILL); canvas.rotate(30); canvas.drawRect(mRect, mPaint);&#125; 旋转原理： 4. 缩放(Scale)变更坐标轴密度。1public void scale(float sx, float sy) 参数:float sx：水平方向伸缩的比例。小数表示缩小，整数表示放大。float sy：垂直方向伸缩的比例。小数表示缩小，整数表示放大。 示例：1234567mPaintBlue = generatePaint(Color.BLUE, Paint.Style.STROKE, 5);mPaintRed = generatePaint(Color.RED, Paint.Style.STROKE, 5);mRect = new RectF(100,50,500,150);canvas.drawRect(mRect, mPaintBlue);canvas.scale(0.5f, 1);canvas.drawRect(mRect, mPaintRed); 蓝框是原坐标轴密度图形,红框是 X 轴密度缩小到 0.5 倍之后显示的图形。 5. 扭曲(Skew)1void skew(float sx, float sy) 参数：float sx：将画布在 X 轴方向上倾斜相应的角度，sx 为倾斜角度的正切值。float sy：将画布在 Y 轴方向上倾斜相应的角度，sy 为倾斜角度的正切值。 注意：这里都是倾斜角度的正切值。比如，在 X 轴方向上倾斜 60°，tan60=1.732。 示例：12345mRect = new RectF(100,100,300,300);canvas.drawRect(mRect, mPaintBlue);canvas.skew(0.5f, 0.5f);canvas.drawRect(mRect, mPaintRed); 6. 裁剪画布(clip 系列函数)裁剪画布是指利用 clip 系列函数，通过与 Rect、Path、Region 取交、并、差等集合运算来获得最新的画布形状。除调用 save()、restore()函数以外，这个操作是不可逆的，一旦 Canvas 被裁剪，就不能恢复。 在使用裁剪画布系列函数时，需要禁用硬件加速功能。setLayerType(LAYER_TYPE_SOFTWARE, null); 1234567891011121314boolean clipPath(Path path)boolean clipPath(Path path, Region.Op op)boolean clipRect(RectF rect)boolean clipRect(Rect rect)boolean clipRect(Rect rect, Region.Op op)boolean clipRect(RectF rect, Region.Op op)boolean clipRect(int left, int top, int right, int bottom)boolean clipRect(float left, float top, float right, float bottom)boolean clipRect(float left, float top, float right, float bottom, Region.Op op) boolean clipRegion(Region region)boolean clipRegion(Region region, Region.Op op) 示例：123canvas.drawColor(Color.RED);canvas.clipRect(new Rect(100, 100, 200, 200));canvas.drawColor(Color.GREEN); 先把背景色涂成红色，显示在屏幕上，然后裁剪画布，最后将最新的画布涂成绿色。可见，绿色部分只有一小块，而不再是整个屏幕。 1.5.2 画布的保存与恢复1. save()和 restore()函数前面介绍的所有对画布的操作都是不可逆的，如果要对画布的大小和状态(旋转角度、扭曲等)进行实时保存和恢复，需要借助save()和 restore() 这两个函数。 save() ：每次调用，都会先保存当前画布的状态，然后将其放入特定的栈中。restore() ：每次调用，都会把栈中顶层的画布状态取出来，并按照这个状态恢复当前的画布，然后在这个画布上作画。 示例：123456canvas.drawColor(Color.RED);// 保存当前画布大小,即整屏 canvas.save();canvas.clipRect(new Rect(100, 100, 800, 800));canvas.drawColor(Color.GREEN);// 恢复整屏画布 canvas.restore();canvas.drawColor(Color.BLUE); 2. restoreToCount(int saveCount)函数我们可以多次调用 save()函数，但每次调用 restore()函数，只会将顶层的画布状态出栈。有时可能只需要用到特定的画布，这就需要多次 出栈。为了解决这个问题，Google 提供了另一个出栈函数 restoreToCount(int saveCount)。1public int save(); 在利用 save()函数保存画布时，会有一个 int 类型的返回值。该返回值是当前所保存的画布所在栈的索引。1public void restoreToCount(int saveCount); 而 restoreToCount()函数的用法就是一直出栈，直到指定索引的画布出栈为止，即将指定索引的画布作为当前画布。 示例：1234567891011121314151617181920212223242526272829303132protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.RED); // 保存的画布大小为全屏幕大小 int c1 = canvas.save(); canvas.clipRect(new Rect(100, 100, 800, 800)); canvas.drawColor(Color.GREEN); // 保存的画布大小为Rect(100, 100, 800, 800) int c2 = canvas.save(); canvas.clipRect(new Rect(200, 200, 700, 700)); canvas.drawColor(Color.BLUE); // 保存的画布大小为Rect(200, 200, 700, 700) int c3 = canvas.save(); canvas.clipRect(new Rect(300, 300, 600, 600)); canvas.drawColor(Color.BLACK); // 保存的画布大小为Rect(300, 300, 600, 600) int c4 = canvas.save(); canvas.clipRect(new Rect(400, 400, 500, 500)); canvas.drawColor(Color.WHITE); // 连续三次出栈，将最后一次出栈的画布状态 // 作为当前画布，并填充为黄色 // canvas.restore(); // canvas.restore(); // canvas.restore(); canvas.restoreToCount(c2); canvas.drawColor(Color.YELLOW);&#125; 1.5.3 示例一:圆形头像 1234567891011121314151617181920212223242526272829303132public class TestView extends View &#123; private Paint mPaint; private Path mPath; private Bitmap mBmp; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; private void init() &#123; // 禁用硬件加速 // setLayerType(LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mPath = new Path(); mBmp = BitmapFactory.decodeResource(getResources(), R.drawable.image); int x = mBmp.getWidth() / 2; int y = mBmp.getHeight() / 2; int r = Math.min(x, y); mPath.addCircle(x, y, r, Path.Direction.CCW); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.save(); canvas.clipPath(mPath); canvas.drawBitmap(mBmp, 0, 0, mPaint); canvas.restore(); &#125;&#125; 前面说过，在使用 clip 系列函数时，要禁用硬件加速功能。 setLayerType(LAYER_TYPE_SOFTWARE,null);然而在手机型号 Pixel XL 上测试，是否禁用硬件加速功能并不影响 clip 函数。 1.5.4 示例二：裁剪动画 1. 原理动画原理就是每次将裁剪区域变大，在裁剪区域内的图像就会显示出来，而裁剪区域之外的图像不会显示。而关键问题在于如何计算裁剪区域。 这里很容易给大家造成错觉，以为黑色条是裁剪区域。其实不然，裁剪画布，在裁剪画布内的区域都是显示出来的，所以显示出来的区域才是裁剪区域。从图示中可以看出，有两个裁剪区域。 裁剪区域一：从左向右，逐渐变大。假设宽度是 clipWidth，高度是 CLIP_HEIGHT，那么裁剪区域一所对应的 Rect 对象如下:1Rect(0, 0, clipWidth, CLIP_HEIGHT); 裁剪区域二：从右向左，同样逐渐变大，它的宽度、高度都与裁剪区域一相同。但它是从右向左变化的，假设图片的宽度是 width，那么裁剪区域二所对应的 Rect 对象如下:1Rect(width - clipWidth, CLIP_HEIGHT, width, 2* CLIP_HEIGHT); 2. 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class TestView extends View &#123; private Paint mPaint; private Bitmap mBitmap; private int clipWidth = 0; private int width; private int height; private static final int CLIP_HEIGHT = 30; private Path mPath; private RectF mRect; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; private void init() &#123; setLayerType(LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bg); width = mBitmap.getWidth(); height = mBitmap.getHeight(); mPath = new Path(); mRect = new RectF(); &#125; @Override protected void onDraw(Canvas canvas) &#123; mPath.reset(); int i = 0; while (i * CLIP_HEIGHT &lt;= height) &#123; if (i % 2 == 0) &#123; mRect.set(0, i * CLIP_HEIGHT, clipWidth, (i+1) * CLIP_HEIGHT); &#125; else &#123; mRect.set(width - clipWidth, i * CLIP_HEIGHT, width, (i+1) * CLIP_HEIGHT); &#125; // 替换 Region.union 方法 mPath.addRect(mRect, Path.Direction.CCW); i++; &#125; // 替换 canvas.clipRegion 方法 canvas.clipPath(mPath); canvas.drawBitmap(mBitmap, 0, 0, mPaint); if (clipWidth &gt; width) &#123; return; &#125; clipWidth += 5; invalidate(); &#125;&#125;]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01.4 精通自定义 View 之绘图基础——Region]]></title>
    <url>%2F2019%2F07%2F01%2FCustom%20View%2F01.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Region%2F</url>
    <content type="text"><![CDATA[1.4.1 构造Region1. 直接构造123456// 复制一个 Region 的范围，不常用public Region(Region region) // 创建一个矩形区域public Region(Rect r) // 创建一个矩形区域public Region(int left, int top, int right, int bottom) 示例：12345678910Region region = new Region(new Rect(50,50,200,100));drawRegion(canvas,region,paint);private void drawRegion (Canvas canvas, Region rgn, Paint paint) &#123; RegionIterator iter = new RegionIterator(rgn); Rect r = new Rect(); while (iter.next(r)) &#123; canvas.drawRect(r, paint); &#125; &#125; Canvas 并没有提供针对 Region 的绘图方法，这就说明 Region 的本意并不是用来绘图的。对于上面构造的矩形填充，我们完全可以使用 Rect 来代替。 2. 间接构造间接构造主要是通过 public Region()的空构造函数与 set 系列函数相结合来实现的。123456789// 空构造函数public Region()// set 系列public void setEmpty() // 置空public boolean set(Region region)public boolean set(Rect r)public boolean set(int left, int top, int right, int bottom) public boolean setPath(Path path, Region clip) 无论调用 set 系列函数的 Region 是不是有区域值，当调用 set 系列函数后，原来的区域值就会被替换成 set 系列函数里的区域值。 其他函数不表，重点介绍 setPath() 函数：1boolean setPath(Path path, Region clip) 参数：Path path：用来构造区域的路径。Region clip：与前面的 path 所构成的路径取交集，并将该交集设置为最终的区域。 由于路径有很多种构造方法，而且可以轻易构造出非矩形的路径，因而摆脱了前面的构造函数只能构造矩形区域的限制。但这里有一个问题，即需要指定另一个区域来取交集。当然，如果想显示路径构造的区域，那么 Region clip 参数可以传入一个比 Path 范围大得多的区 域，取完交集之后，当然就是 Path path 参数所对应的区域了。 示例：123456789101112131415161718192021222324252627282930313233public class BaseView extends View &#123; private Paint paint; private Region region; public BaseView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); paint = new Paint(); paint.setColor(Color.RED); paint.setStyle(Paint.Style.FILL); // 构造一条椭圆路径 Path ovalPath = new Path(); RectF rectF = new RectF(50, 50, 200, 500); ovalPath.addOval(rectF, Path.Direction.CCW); // 在 setPath 中传入一个比椭圆区域小的矩形区域，让其取交集 region = new Region(); region.setPath(ovalPath, new Region(50, 50, 200, 200)); &#125; @Override protected void onDraw(Canvas canvas) &#123; drawRegion(canvas, region, paint); &#125; private void drawRegion(Canvas canvas, Region region, Paint paint) &#123; RegionIterator iterator = new RegionIterator(region); Rect rect = new Rect(); while (iterator.next(rect)) &#123; canvas.drawRect(rect, paint); &#125; &#125;&#125; 左侧分别画出了所构造的椭圆和矩形，二者相交之后，所画出的 Region 对象是如右侧图 像所示的椭圆上部分。 1.4.2 枚举区域——RegionIterator类对于特定的区域，可以使用多个矩形来表示其大致形状。事实上，如果矩形足够小，一定数量的矩形就能够精确表示区域的形状。也就是说，一定数量的矩形所合成的形状也可以代表区域的形状。RegionIterator 类就实现了获取组成区域的矩形集的功能。1234// 构造函数：根据区域构建对应的矩形集。RegionIterator(Region region)// 获取下一个矩形,将结果保存在参数 Rect r 中。boolean next(Rect r) 前面提到，由于在 Canvas 中没有直接绘制 Region 的函数，想要绘制一个区域，就只能通过 RegionIterator 类构造矩形集来逼近显示区域，所以 drawRegion()函数的具体实现如下:1234567private void drawRegion (Canvas canvas, Region rgn, Paint paint) &#123; RegionIterator iter = new RegionIterator(rgn); Rect r = new Rect(); while (iter.next(r)) &#123; canvas.drawRect(r, paint); &#125; &#125; 首先根据区域构造一个矩形集，然后利用next(Rect r)函数来逐个获取所有矩形并绘制出来，最终得到的就是整个区域。如果我们想画一个椭圆区域，并且把画笔样式从 FILL 改为 STROKE，则效果更清楚。1234567891011Paint paint = new Paint();paint.setColor(Color.RED);paint.setStyle(Paint.Style.STROKE);// 构造一条椭圆路径Path ovalPath = new Path();RectF rect = new RectF(50, 50, 200, 500); ovalPath.addOval(rect, Path.Direction.CCW);// 构造椭圆区域Region rgn = new Region();rgn.setPath(ovalPath, new Region(50, 50, 200, 500)); drawRegion(canvas,rgn,paint); 在代码中，同样先构造了一条椭圆路径，然后在形成 Region 时传入一个与构造的椭圆区域相同大小的矩形，所以取交集之后的结果就是椭圆路径所对应的区域。效果如下图所示： 从效果图中可以明显看出，在绘制 Region 对象时，其实就是先将其转换成矩形集，然后利用画笔将每个矩形画出来而已。 1.4.3 区域相交Region 不是用来绘图的，而是在区域的相交操作中。 1. union()函数1boolean union(Rect r) 该函数用于与指定矩形取并集，即将 Rect 所指定的矩形加入当前区域中。 示例：1234567paint = new Paint();paint.setColor(Color.RED);paint.setStyle(Paint.Style.FILL);region = new Region(20, 20, 200, 100);region.union(new Rect(20, 20, 50, 300));drawRegion(canvas, region, paint); 将横向、竖向两个矩形区域合并，效果图如下： 2. 区域操作123boolean op(Rect rect, Op op)boolean op(int left, int top, int right, int bottom, Op op)boolean op(Region, Op) 操作结果赋给当前的 Region 对象。如果计算成功，返回 true；否则返回 false。 Op 参数值及含义：12345678public enum Op &#123; DIFFERENCE(0), // 最终区域为 region1 与 region2 不同的区域 INTERSECT(1), // 最终区域为 region1 与 region2 相交的区域 UNION(2), // 最终区域为 region1 与 region2 组合在一起的区域 XOR(3), // 最终区域为 region1 与 region2 相交之外的区域 REVERSE_DIFFERENCE(4), // 最终区域为 region2 与 region1 不同的区域 REPLACE(5); // 最终区域为 region2 的区域&#125; 示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class BaseView extends View &#123; private Paint paint, paintFill; private Region region1,region2,region3,region4,region5,region6,region7,region8,region9,region10,region11,region12; private Rect rect1,rect2,rect3,rect4,rect5,rect6,rect7,rect8,rect9,rect10,rect11,rect12; public BaseView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); paint = generatePaint(Color.RED, Paint.Style.STROKE, 2); paintFill = generatePaint(Color.GREEN, Paint.Style.FILL, 0); rect1 = new Rect(100, 140, 400, 240); rect2 = new Rect(200, 40, 300, 340); rect3 = new Rect(500, 140, 800, 240); rect4 = new Rect(600, 40, 700, 340); rect5 = new Rect(900, 140, 1200, 240); rect6 = new Rect(1000, 40, 1100, 340); rect7 = new Rect(100, 540, 400, 640); rect8 = new Rect(200, 440, 300, 740); rect9 = new Rect(500, 540, 800, 640); rect10 = new Rect(600, 440, 700, 740); rect11 = new Rect(900, 540, 1200, 640); rect12 = new Rect(1000, 440, 1100, 740); region1 = new Region(rect1); region2 = new Region(rect2); region1.op(region2, Region.Op.DIFFERENCE); region3 = new Region(rect3); region4 = new Region(rect4); region3.op(region4, Region.Op.INTERSECT); region5 = new Region(rect5); region6 = new Region(rect6); region5.op(region6, Region.Op.UNION); region7 = new Region(rect7); region8 = new Region(rect8); region7.op(region8, Region.Op.XOR); region9 = new Region(rect9); region10 = new Region(rect10); region9.op(region10, Region.Op.REVERSE_DIFFERENCE); region11 = new Region(rect11); region12 = new Region(rect12); region11.op(region12, Region.Op.REPLACE); &#125; @Override protected void onDraw(Canvas canvas) &#123; canvas.drawRect(rect1, paint); canvas.drawRect(rect2, paint); drawRegion(canvas, region1, paintFill); canvas.drawRect(rect3, paint); canvas.drawRect(rect4, paint); drawRegion(canvas, region3, paintFill); canvas.drawRect(rect5, paint); canvas.drawRect(rect6, paint); drawRegion(canvas, region5, paintFill); canvas.drawRect(rect7, paint); canvas.drawRect(rect8, paint); drawRegion(canvas, region7, paintFill); canvas.drawRect(rect9, paint); canvas.drawRect(rect10, paint); drawRegion(canvas, region9, paintFill); canvas.drawRect(rect11, paint); canvas.drawRect(rect12, paint); drawRegion(canvas, region11, paintFill); &#125; private void drawRegion(Canvas canvas, Region region, Paint paint) &#123; RegionIterator iterator = new RegionIterator(region); Rect rect = new Rect(); while (iterator.next(rect)) &#123; canvas.drawRect(rect, paint); &#125; &#125; private Paint generatePaint(int color, Paint.Style style, int width) &#123; Paint paint = new Paint(); paint.setColor(color); paint.setStyle(style); paint.setStrokeWidth(width); return paint; &#125;&#125; 3. op 的重载12boolean op(Rect rect, Region region, Op op)boolean op(Region region1, Region region2, Region.Op op) 这两个函数允许我们传入两个 Region 对象进行区域操作，并将操作结果赋给当前的 Region 对象。同样，当操作成功时，返回 true；否则返回 false。1234Region region1 = new Region(100,100,400,200);Region region2 = new Region(200,0,300,300);Region region = new Region();region.op(region1, region2, Region.Op.INTERSECT); 在这里，将 region1、region2 相交的结果赋给 Region 对象。 1.4.4 其他函数1. 几个判断方法123456// 判断该区域是否为空public boolean isEmpty();// 判断该区域是否是一个矩阵public boolean isRect();// 判断该区域是否是多个矩阵的组合public boolean isComplex(); 2. getBound 系列函数123456// 返回能够包裹当前路径的最小矩形public Rect getBounds()public boolean getBounds(Rect r)// 返回当前矩形所对应的 Path 对象public Path getBoundaryPath()public boolean getBoundaryPath(Path path) 3. 是否包含12345// 判断该区域是否包含某个点public boolean contains(int x, int y);// 判断该区域是否包含某个矩形public boolean quickContains(Rect r)public boolean quickContains(int left, int top, int right,int bottom) 4. 是否相交12345// 判断该区域是否没有和指定矩形相交public boolean quickReject(Rect r)public boolean quickReject(int left, int top, int right, int bottom);// 判断该区域是否没有和指定区域相交public boolean quickReject(Region rgn) 5. 平移变换1234567// 将 Region 对象向 X 轴平移 dx 距离，向 Y 轴平移 dy 距离，// 并将结果赋给当前的 Region 对象。X 轴向右是正方向，Y 轴向下是正方向。public void translate(int dx, int dy)// 将 Region 对象向 X 轴平移 dx 距离，向 Y 轴平移 dy 距离。// 与上一个函数不同的是，该函数将结果赋给 dst 对象，// 而当前 Region 对象的值保持不变。public void translate(int dx, int dy, Region dst)]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01.3 精通自定义 View 之绘图基础——文字]]></title>
    <url>%2F2019%2F07%2F01%2FCustom%20View%2F01.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%96%87%E5%AD%97%2F</url>
    <content type="text"><![CDATA[1.3.1 Paint设置Paint 与文字相关的设置方法有如下几个： 普通设置 12345678910// 设置画笔宽度paint.setStrokeWidth (5); // 指定是否使用抗锯齿功能。如果使用,则会使绘图速度变慢paint.setAntiAlias(true);// 绘图样式,对于文字和几何图形都有效paint.setStyle(Paint.Style.FILL);// 设置文字对齐方式： Align.CENTER、Align.LEFT、Align.RIGHTpaint.setTextAlign(Align.CENTER);// 设置文字大小paint.setTextSize(12); 样式设置 12345678// 设置是否为粗体文字paint.setFakeBoldText(true); // 设置下画线paint.setUnderlineText(true); // 设置字体水平倾斜度,普通斜体字设为-0.25,右为负左为正paint.setTextSkewX((float) -0.25); // 设置带有删除线效果paint.setStrikeThruText(true); 其他设置 12// 只会将水平方向拉伸,高度不会变paint.setTextScaleX(2); 1. 填充样式的区别paint.setStyle()函数对文字和几何图形都有效。下面就来看看不同的填充样式对文字的影响：123456789101112mPaint = new Paint();mPaint.setColor(Color.RED);mPaint.setStrokeWidth(5);mPaint.setAntiAlias(true);mPaint.setTextSize(100);mPaint.setStyle(Paint.Style.STROKE);canvas.drawText(&quot;先小涛 STROKE&quot;, 100, 200, mPaint);mPaint.setStyle(Paint.Style.FILL);canvas.drawText(&quot;先小涛 FILL&quot;, 100, 320, mPaint);mPaint.setStyle(Paint.Style.FILL_AND_STROKE);canvas.drawText(&quot;先小涛 FILL_AND_STROKE&quot;, 100, 440, mPaint); 效果图如下： 2. setTextAlign()函数1public void setTextAlign(Align align) 用于设置所要绘制的字符串与起始点的相对位置。参数 Align align 的取值如下： Align.LEFT：居左绘制，即通过 drawText()函数指定的起始点在最左侧，文字从起始点位置开始绘制。 Align.CENTER：居中绘制，即通过 drawText()函数指定的起始点在文字中间位置。 Align.RIGHT：居右绘制，即通过 drawText()函数指定的起始点在文字右侧位置。 示例：12345678910111213141516mLinePaint = new Paint();mLinePaint.setColor(Color.BLUE);mPaint = new Paint();mPaint.setColor(Color.RED);mPaint.setStrokeWidth(5);mPaint.setAntiAlias(true);mPaint.setTextSize(80);canvas.drawCircle(400, 100, 5, mLinePaint);canvas.drawLine(400, 100, 400, 300, mLinePaint);mPaint.setTextAlign(Paint.Align.LEFT);canvas.drawText(&quot;先小涛&quot;, 400, 100, mPaint);mPaint.setTextAlign(Paint.Align.CENTER);canvas.drawText(&quot;先小涛&quot;, 400, 200, mPaint);mPaint.setTextAlign(Paint.Align.RIGHT);canvas.drawText(&quot;先小涛&quot;, 400, 300, mPaint); 从效果图中可以看出，当居左对齐(Align.LEFT)时，整个字符串都在起始点(400,100) 的右侧，也就是说,通过 drawText()函数指定的起始点(400,100)是居左的。同样，当居右对齐(Align.RIGHT)时，起始点也是居右的，也就是说，所有文字都在起始点(400,100)的左侧。 3. 设置字体样式1）常规设置123456// 设置是否粗体。当取 true 时，表示是粗体。void setFakeBoldText(boolean fakeBoldText)// 是否显示文字下画线。当取 true 时，显示下画线。void setUnderlineText(boolean underlineText)// 是否显示中间删除线。当取 true 时，显示中间删除线。void setStrikeThruText(boolean strikeThruText) 示例12345canvas.drawText(&quot;先小涛 DEFAULT&quot;, 100, 200, mPaint);mPaint.setFakeBoldText(true);mPaint.setUnderlineText(true);mPaint.setStrikeThruText(true);canvas.drawText(&quot;先小涛 SETTING&quot;, 100, 300, mPaint); 2）字体倾斜度设置1void setTextSkewX(float skewX) 该函数用于设置字体倾斜度。参数 float skewX 的默认值是 0，取负值时文字向右倾斜，取正值时文字向左倾斜，Word 文档中倾斜字体的倾斜度是 -0.25f。 示例：123456789101112mPaint = new Paint();mPaint.setColor(Color.RED);mPaint.setTextSize(80);// 正常样式canvas.drawText(mName, 100, 200, mPaint);// 向右倾斜mPaint.setTextSkewX(-0.25f);canvas.drawText(mName, 100, 300, mPaint);// 向左倾斜mPaint.setTextSkewX(0.25f);canvas.drawText(mName, 100, 400, mPaint); 4. 水平拉伸1void setTextScaleX(float scaleX) 该函数用于在水平方向拉伸文字。参数 float scaleX 表示拉伸倍数，当取值为 1 时，表示不拉伸。默认为不拉伸。 示例：12345// 正常样式canvas.drawText(mName, 100, 200, mPaint);// 拉伸两倍mPaint.setTextScaleX(2f);canvas.drawText(mName, 100, 300, mPaint); 1.3.2 Canvas绘制文本1. 普通绘制1234567// 该函数可以指定起始点(x, y)来绘制文字void drawText(String text, float x, float y, Paint paint)// 通过指定字符串中字符的起始和终止位置截取字符串的一部分绘制void drawText(String text, int start, int end, float x, float y, Paint paint)void drawText(char[] text, int index, int count, float x, float y, Paint paint)void drawText(CharSequence text, int start, int end, float x, float y, Paint paint) 参数：int start：表示起始绘制字符所在字符串中的索引。int end：表示结束绘制字符所在字符串中的索引。int index：指定起始绘制字符的位置。int count：指定从起始绘制字符开始绘制几个字符。 示例：1canvas.drawText(&quot;先小涛后大浪&quot;, 1, 4, 100, 200, mPaint); 2. 逐个指定文字位置12void drawPosText(String text, float[] pos, Paint paint)void drawPosText(char[] text, int index, int count, float[] pos, Paint paint) 参数： char[] text/String text：要绘制的字符串。 int index：第一个要绘制的文字的索引。 int count：要绘制的文字的个数，用来计算最后一个文字的位置，从第一个绘制的文字开始算起。 float[] pos：要绘制的每个文字的具体位置，同样两两一组，如{x1,y1,x2,y2,x3,y3,…}。 示例：12345678910111213141516171819public class TestView extends View &#123; private Paint mPaint; private String mName = &quot;先小涛后大浪&quot;; private float[] pos = &#123;80, 180, 80, 280, 80, 380, 200, 180, 200, 280, 200, 380&#125;; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.RED); mPaint.setTextSize(80); &#125; @Override protected void onDraw(Canvas canvas) &#123; canvas.drawPosText(mName, pos, mPaint); &#125;&#125; 3. 沿路径绘制1234void drawTextOnPath (String text, Path path, float hOffset, float vOffset, Paint paint)void drawTextOnPath (char[] text, int index, int count, Path path, float hOffset, float vOffset, Paint paint) float hOffset：与路径起始点的水平偏移量。 float vOffset：与路径中心的垂直偏移量。 示例：1234567891011121314151617mPaint = new Paint();mPaint.setColor(Color.RED);mPaint.setTextSize(50);mPaint.setStyle(Paint.Style.STROKE);mName = &quot;先小涛后大浪&quot;;mPath1 = new Path();mPath1.addCircle(220, 300, 150, Path.Direction.CCW);mPath2 = new Path();mPath2.addCircle(600, 300, 150, Path.Direction.CCW);// 辅助中线canvas.drawLine(70, 300, 750, 300, mPaint);canvas.drawPath(mPath1, mPaint);canvas.drawPath(mPath2, mPaint);mPaint.setColor(Color.BLUE);canvas.drawTextOnPath(mName, mPath1, 0, 0, mPaint);canvas.drawTextOnPath(mName, mPath2, 80, 50, mPaint); 1.3.3 设置字体样式在 Paint 中有一个函数是专门用来设置字体样式的。1Typeface setTypeface(Typeface typeface) Typeface 是专门用来设置字体样式的类，通过 paint.setTypeface()函数来指定即将绘制的文字的字体样式。可以指定系统中的字体样式，也可以在自定义的样式文件中获取。在构建 Typeface 类时，可以指定所用样式的正常体、斜体、粗体等。如果在指定样式中没有相关文 字的样式，就会用系统默认的样式来显示，一般默认是宋体。 1. 使用系统中的字体样式1）使用 Android 自带的字体样式在 Typeface 类中保存着三种自带的字体样式：Typeface.SANS_SERIF、Typeface.MONOSPACE 和 Typeface.SERIF。 示例：123456789// 衬线字体mPaint.setTypeface(Typeface.SERIF);canvas.drawText(mName, 100, 100, mPaint);// 设置等宽字体mPaint.setTypeface(Typeface.MONOSPACE);canvas.drawText(mName, 100, 170, mPaint);// 无衬线字体mPaint.setTypeface(Typeface.SANS_SERIF);canvas.drawText(mName, 100, 240, mPaint); 由于这三种字体样式对中文的支持不是很好。所以，当遇到不支持的文字时，会使用系统默认的样式来写。对中国用户而言，系统默认的字体一般是 DroidSansFallback，所以用这三种样式的文字写中文时是看不到差别的，我们一般不会使用这三种字体样式。 2）defaultFromStyle()函数1Typeface defaultFromStyle(int style) 该函数会根据字体样式获取对应的默认字体。参数 int style 的取值如下： Typeface.NORMAL：正常字体。 Typeface.BOLD：粗体。 Typeface.ITALIC：斜体。 Typeface.BOLD_ITALIC：粗斜体。 如果系统默认的字体是宋体，那么当指定defaultFromStyle(Typeface.BOLD_ITALIC)时，获取的将是粗斜体的宋体样式。 示例：123456789mPaint = new Paint();mPaint.setColor(Color.RED);mPaint.setTextSize(50);mPaint.setAntiAlias(true);mName = &quot;先小涛 xian@163.com&quot;;Typeface typeface = Typeface.defaultFromStyle(Typeface.BOLD_ITALIC);mPaint.setTypeface(typeface);canvas.drawText(mName, 100, 100, mPaint); 3）create(String familyName, int style)函数1Typeface create(String familyName, int style) 该函数直接通过指定字体名来加载系统中自带的字体样式。如果字体样式不存在，则会用系统样式替代并返回。 示例：12345String familyName = &quot;宋体&quot;;Typeface font = Typeface.create(familyName, Typeface.NORMAL);mPaint.setTypeface(font);canvas.drawText(mName, 100, 100, mPaint); 2. 自定义字体样式一般而言，我们不会指定系统自带的字体样式。因为除 Android 自带的三种字体样式以外，其他字体样式并不一定在每款手机上都有预装。所以，我们一般会选择加载自定义的字体文件来绘制文字，这样才不至于在每款手机上的表现不一样。 如果要自定义字体样式，就需要从外部字体文件中加载我们所需的字形，这时所使用的 Typeface 构造函数有如下三个:123Typeface createFromAsset(AssetManager mgr, String path)Typeface createFromFile(String path)Typeface createFromFile(File path) 示例：123456AssetManager manager = context.getAssets();// 加载字体文件：assets/fonts/xian.ttfTypeface typeface = Typeface.createFromAsset(manager, &quot;fonts/xian.ttf&quot;);mPaint.setTypeface(typeface);canvas.drawText(mName, 100, 200, mPaint); 加载 res/font/xian.ttf 字体文件方式：Typeface typeface = ResourcesCompat.getFont(context, R.font.xian);]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01.2 精通自定义 View 之绘图基础——路径]]></title>
    <url>%2F2019%2F07%2F01%2FCustom%20View%2F01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[1.2.1 概述画笔所画出来的一段不间断的曲线就是路径。在 Android 中，Path 类就代表路径。在 Canvas 中绘制路径的方法如下：1void drawPath(Path path, Paint paint) 1.2.2 直线路径画一条直线路径,一般涉及下面三个函数：1234567// (x1,y1)是直线的起始点，即将直线路径的绘制点定在(x1,y1)位置void moveTo(float x1, float y1)// (x2,y2)是直线的终点，又是下一次绘制直线路径的起始点；lineTo()函数可以一直使用。void lineTo(float x2, float y2)// 如果连续画了几条直线，但没有形成闭环，// 那么调用 close()函数会将路径首尾点连接起来，形成闭环。void close() 示例：12345678910111213141516171819// 初始化mPaint = new Paint();mPaint.setColor(Color.RED);mPaint.setStyle(Paint.Style.STROKE);mPaint.setStrokeWidth(5);mPath = new Path();// 闭环mPath.moveTo(20, 20);mPath.lineTo(20, 120);mPath.lineTo(300, 120);mPath.close();canvas.drawPath(mPath, mPaint);// 不闭环mPath.moveTo(320, 20);mPath.lineTo(320, 120);mPath.lineTo(600, 120);canvas.drawPath(mPath, mPaint); 闭合三角形：先沿逆时针方向画了两条直线，分别是从(20, 20)到(20, 120)和从(20, 120)到(300, 120)，然后利用 path.close()函数将路径闭合，路径的终点(300,120)就会自行向路径的起始点 (20,20)画一条闭合线，所以最终我们看到的是一个路径闭合的三角形。 1.2.3 弧线路径1void arcTo(RectF oval, float startAngle, float sweepAngle) 这是一个画弧线路径的方法，弧线是从椭圆上截取的一部分。参数: RectF oval：生成椭圆的矩形。 float startAngle：弧开始的角度，以 X 轴正方向为 0°。 float sweepAngle：弧持续的角度。 示例：1234567891011121314// 初始化mPaint = new Paint();mPaint.setStyle(Paint.Style.STROKE);mPaint.setStrokeWidth(5);mRect = new RectF(100, 20, 200, 100);mPath = new Path();mPath.moveTo(20, 20);mPath.arcTo(mRect, 0, 90);// onDrawmPaint.setColor(Color.LTGRAY);canvas.drawRect(mRect, mPaint);mPaint.setColor(Color.RED);canvas.drawPath(mPath, mPaint); 上述示例中弧最终还是会和起始点(20,20)连接起来。因为在默认情况下路径都是连贯的，除非以下两种情况： 调用 addXXX 系列函数(参见 1.2.4 节)，将直接添加固定形状的路径。 调用 moveTo()函数改变绘制起始位置。 如果不想连接起来，需要使用 Path 类提供的另外两个重载方法。123void arcTo(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean forceMoveTo)void arcTo(RectF oval, float startAngle, float sweepAngle, boolean forceMoveTo) 参数 boolean forceMoveTo 的含义是是否强制将弧的起始点作为绘制起始位置。 将上面的代码稍加改造：12// mPath.arcTo(mRect, 0, 90);mPath.arcTo(mRect, 0, 90, true); 效果如下： 1.2.4 addXXX系列函数路径一般都是连贯的，而 addXXX 系列函数可以让我们直接往 Path 中添加一些曲线，而不必考虑连贯性。 示例：123456789101112mPaint = new Paint();mPaint.setColor(Color.RED);mPaint.setStyle(Paint.Style.STROKE);mPaint.setStrokeWidth(5);mPath = new Path();mPath.moveTo(40, 40);mPath.lineTo(100, 100);mRect = new RectF(100, 100, 200, 200);mPath.addArc(mRect, 0, 90);canvas.drawPath(mPath, mPaint); 先绘制了从(40,40)到(100,100)的线段，但是在我们往路径中添加了一条弧线之后，弧线并没有与线段连接。除了 addArc()函数，Path 类还提供了一系列的 add 函数： 1.添加矩形路径123void addRect(float left, float top, float right, float bottom, Path.Direction dir)void addRect(RectF rect, Path.Direction dir) 这里 Path 类创建矩形路径的参数与 Canvas 绘制矩形的参数差不多,唯一不同的是增加了 Path.Direction 参数。Path.Direction 参数有两个值。 Path.Direction.CCW：是 counter-clockwise 的缩写，指创建逆时针方向的矩形路径。 Path.Direction.CW：是 clockwise 的缩写，指创建顺时针方向的矩形路径。 示例：12345678910111213141516171819202122232425262728293031public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.LTGRAY); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(5); mTextPaint = new Paint(); mTextPaint.setColor(Color.BLUE); mTextPaint.setTextSize(35); mStr = &quot;苦心人天不负，有志者事竟成&quot;; // 逆时针路径 mCCWPath = new Path(); RectF rect1 = new RectF(50, 50, 240, 200); mCCWPath.addRect(rect1, Path.Direction.CCW); // 顺时针路径 mCWPath = new Path(); RectF rect2 = new RectF(290, 50, 480, 200); mCWPath.addRect(rect2, Path.Direction.CW);&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; canvas.drawPath(mCCWPath, mPaint); canvas.drawPath(mCWPath, mPaint); canvas.drawTextOnPath(mStr, mCCWPath, 0, 18, mTextPaint); canvas.drawTextOnPath(mStr, mCWPath, 0, 18, mTextPaint);&#125; 文字是可以依据路径排版的，文字的行走方向依据的就是路径的生成方向。 2.添加圆角矩形路径12void addRoundRect(RectF rect, float[] radii, Path.Direction dir)void addRoundRect(RectF rect, float rx, float ry, Path.Direction dir) 矩形的圆角都是利用椭圆生成的。参数： RectF rect：是当前所构造路径的矩形。 Path.Direction dir：依然是指路径的生成方向，当然只对依据路径布局的文字有用。 float[] radii：必须传入 8 个数值，分 4 组，分别对应每个角所使用的椭圆的横轴半径和纵轴半径。如{x1,y1,x2,y2,x3,y3,x4,y4}，其中，x1,y1 对应第一个角(左上角)的用来生成圆角的椭圆的横轴半径和纵轴半径，其他类推…… float rx：生成统一的圆角的椭圆的横轴半径。 float ry：生成统一的圆角的椭圆的纵轴半径。 示例：12345678910111213141516171819202122232425262728293031public class TestView extends View &#123; private Paint mPaint; private Path mCCWPath, mCWPath; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.RED); mPaint.setStyle(Paint.Style.STROKE); mPaint.setAntiAlias(true); mPaint.setStrokeWidth(5); // 逆时针路径 mCCWPath = new Path(); RectF rect1 = new RectF(50, 50, 240, 200); mCCWPath.addRoundRect(rect1, 10, 15, Path.Direction.CCW); // 顺时针路径 mCWPath = new Path(); RectF rect2 = new RectF(290, 50, 480, 200); float[] radii = &#123;10,15,20,25,30,35,40,45&#125;; mCWPath.addRoundRect(rect2, radii, Path.Direction.CW); &#125; @Override protected void onDraw(Canvas canvas) &#123; canvas.drawPath(mCCWPath, mPaint); canvas.drawPath(mCWPath, mPaint); &#125;&#125; 3.添加圆形路径1void addCircle(float x, float y, float radius, Path.Direction dir) 参数: float x：圆心 X 轴坐标。 float y：圆心 Y 轴坐标。 float radius：圆半径。 示例： 1234mPath = new Path();mPath.addCircle(100, 100, 50, Path.Direction.CCW);canvas.drawPath(mPath, mPaint); 4.添加椭圆路径1void addOval(RectF oval, Path.Direction dir) 参数: RectF oval：生成椭圆的矩形。 Path.Direction：路径的生成方向。 示例： 1234mPath = new Path();mPath.addOval(new RectF(100, 100, 300, 200), Path.Direction.CCW);canvas.drawPath(mPath, mPaint); 5.添加弧形路径123void addArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle)void addArc(RectF oval, float startAngle, float sweepAngle) 参数: RectF oval：弧是椭圆的一部分，这个参数就是生成椭圆的矩形。 float startAngle：弧开始的角度，以 X 轴正方向为 0°。 float sweepAngel：弧持续的角度。 示例： 12mPath.addArc(new RectF(100, 100, 300, 200), 0, 180);canvas.drawPath(mPath, mPaint); 1.2.5 填充模式Path 的填充模式与 Paint 的填充模式不同。Path 的填充模式是指填充 Path 的哪部分。Path.FillType 表示 Path 的填充模式，它有 4 个枚举值。 FillType.WINDING：默认值，当两个图形相交时，取相交和自身部分显示。 FillType.EVEN_ODD：取 path 所在并不相交的区域。 FillType.INVERSE_WINDING：取 path 的外部区域。 FillType.INVERSE_EVEN_ODD：取 path 的外部和相交区域。 Inverse 就是取反的意思，所以 FillType.INVERSE_WINDING 就是取 FillType.WINDING 的相反部分；同理，FillType.INVERSE_EVEN_ODD 就是取 FillType.EVEN_ODD 的相反部分。 示例：1234567891011mPaint = new Paint();mPaint.setColor(Color.RED);mPaint.setStyle(Paint.Style.FILL);mPaint.setAntiAlias(true);mPath = new Path();mPath.addRect(100, 100, 300, 300, Path.Direction.CW);mPath.addCircle(300, 300, 100, Path.Direction.CW);mPath.setFillType(Path.FillType.INVERSE_EVEN_ODD);canvas.drawPath(mPath, mPaint); 1.2.6 重置路径1.概述当我们需要重绘一条全新的路径时，Android 开发人员为了重复利用空间，允许我们重置路径对象。路径对象一旦被重置，其中保存的所有路径都将被清空，这样我们就不需要重新定义一个路径对象了。重新定义路径对象的问题在于老对象的回收和新对象的内存分配，当然这些过程都是会消耗手机性能的。 系统提供了两个重置路径的方法，分别是：12void reset();void rewind(); 这两个函数的共同点是都会清空内部所保存的所有路径，但二者也有区别。 rewind()函数会清除 FillType 及所有的直线、曲线、点的数据等，但是会保留数据结构。 这样可以实现快速重用，提高一定的性能。例如，重复绘制一类线段，它们的点的数量都相等，那么使用 rewind()函数可以保留装载点数据的数据结构，效率会更高。一定要注意的是，只有在重复绘制相同的路径时，这些数据结构才是可以复用的。 reset()函数类似于新建一个路径对象，它的所有数据空间都会被回收并重新分配，但不会清除 FillType。 2.reset()与 FillType12345mPath.setFillType(Path.FillType.INVERSE_WINDING);mPath.reset();mPath.addCircle(100, 100, 50, Path.Direction.CW);canvas.drawPath(mPath, mPaint); 效果如下： 把 reset()改成 rewind()。效果如下： 1.2.7 示例：蜘蛛网状图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136package com.xxt.xtest;import android.content.Context;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.Path;import android.util.AttributeSet;import android.view.View;import androidx.annotation.Nullable;public class SpiderView extends View &#123; private Paint mRadarPaint; // 蜘蛛网 private Paint mRadarLinePaint; // 蜘蛛网辐射的六根线 private Paint mValuePaint; // 数据 private float radius; // 网格最大半径 private int centerX; // 中心 X private int centerY; // 中心 Y private Path mPath; private int mRadarPaintColor = 0xFF0099CC; // 网格默认颜色 private int count = 6; // 多边形，默认值为 6 private double angle = 2*Math.PI / count; // 角度，值为 2π / count，默认 private double[] data = &#123;2,3,1,3,4,3&#125;; // 数据 private int maxValue = 4; // 最大值 public SpiderView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; private void init() &#123; mRadarPaint = generatePaint(mRadarPaintColor, Paint.Style.FILL); mRadarLinePaint = generatePaint(Color.WHITE, Paint.Style.STROKE); mValuePaint = generatePaint(0xAFFF0000, Paint.Style.FILL); mPath = new Path(); &#125; private Paint generatePaint(int color, Paint.Style style) &#123; Paint paint = new Paint(); paint.setColor(color); paint.setStyle(style); paint.setAntiAlias(true); return paint; &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; // 获得布局中心 centerX = w / 2; centerY = h / 2; radius = Math.min(w, h) / 2f * 0.8f; postInvalidate(); super.onSizeChanged(w, h, oldw, oldh); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 绘制蜘蛛网格 drawPolygon(canvas); // 绘制中线 drawLines(canvas); // 画数据图 drawRegion(canvas); &#125; private void drawPolygon(Canvas canvas) &#123; float r = radius / maxValue; // r是蜘蛛丝之间的间距 for (int i = 1; i &lt;= maxValue; i++) &#123; // 中心点不用绘制 float curR = r * i; // 当前半径 mPath.reset(); for (int j = 0; j &lt; count; j++) &#123; if (j == 0) &#123; mPath.moveTo(centerX + curR, centerY); &#125; else &#123; // 根据半径，计算出蜘蛛丝上每个点的坐标 float x = (float) (centerX + curR * Math.cos(angle * j)); float y = (float) (centerY + curR * Math.sin(angle * j)); mPath.lineTo(x, y); &#125; &#125; mPath.close(); // 闭合路径 mRadarPaint.setAlpha(getRadarPaintColor(i)); canvas.drawPath(mPath, mRadarPaint); &#125; &#125; private void drawLines(Canvas canvas) &#123; for (int i = 0; i &lt; count; i++) &#123; mPath.reset(); mPath.moveTo(centerX, centerY); float x = (float) (centerX + radius * Math.cos(angle * i)); float y = (float) (centerY + radius * Math.sin(angle * i)); mPath.lineTo(x, y); canvas.drawPath(mPath, mRadarLinePaint); &#125; &#125; private void drawRegion(Canvas canvas) &#123; mPath.reset(); for (int i = 0; i &lt; count; i++) &#123; double percent = data[i] / maxValue; float x = (float) (centerX + radius * Math.cos(angle * i) * percent); float y = (float) (centerY + radius * Math.sin(angle * i) * percent); if (i == 0) &#123; mPath.moveTo(x, centerY); &#125; else &#123; mPath.lineTo(x, y); &#125; &#125; canvas.drawPath(mPath, mValuePaint); &#125; /** * 由内到外，增加透明度 * @param i 第几个网格，从中心点算起 * @return int alpha 值 */ private int getRadarPaintColor(int i) &#123; if (i &gt; count || i &lt; 1) &#123; return 0xFF; &#125; int alpha = Color.alpha(mRadarPaintColor); int colorStep = alpha / (maxValue - 1) - 10; alpha = alpha - colorStep * (i - 1); return alpha; &#125;&#125;]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01.1 精通自定义 View 之绘图基础——基本图形绘制]]></title>
    <url>%2F2019%2F07%2F01%2FCustom%20View%2F01.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1.1.1 概述画图需要两个工具：纸和笔。在 Android 中，Paint 类就是画笔，而 Canvas 类就是纸，在这里叫作画布。 凡是跟画笔设置相关的，比如画笔大小、粗细、画笔颜色、透明度、字体的样式等，都在 Paint 类里设置；同样，凡是要画出成品的东西，比如圆形、矩形、文字等，都调用 Canvas 类里的函数生成。 示例： 1234567891011121314151617181920public class TestView extends View &#123; private Paint mPaint; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); // 设置画笔 mPaint = new Paint(); mPaint.setColor(Color.RED); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(50); &#125; @Override protected void onDraw(Canvas canvas) &#123; // 画圆 canvas.drawCircle(200, 200, 150, mPaint); &#125;&#125; 直接在主布局中使用自定义控件12345678&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.xxt.xtest.TestView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/LinearLayout&gt; 在 onDraw() 函数中不能创建变量。因为当需要重绘时就会调用 onDraw() 函数，这样会导致变量一直被重复创建，会引起频繁的程序 GC (回收内存)，进而引起程序卡顿。一般在构造函数中创建变量。 1.1.2 画笔的基本设置1. setAntiAlias()1void setAntiAlias(boolean aa) 表示是否打开抗锯齿功能。抗锯齿是依赖算法的，一般在绘制不规则的图形时使用，比如圆形、文字等。在绘制棱角分明的图像时，比如一个矩形、一张位图，是不需要打开抗锯齿功能的。 示例：12345678910111213141516171819202122232425public class TestView extends View &#123; private Paint mPaint1, mPaint2; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mPaint1 = new Paint(); mPaint1.setColor(Color.RED); mPaint1.setStyle(Paint.Style.FILL); mPaint1.setAntiAlias(true); mPaint1.setStrokeWidth(50); mPaint2 = new Paint(); mPaint2.setColor(Color.RED); mPaint2.setStyle(Paint.Style.FILL); mPaint2.setStrokeWidth(50); &#125; @Override protected void onDraw(Canvas canvas) &#123; canvas.drawCircle(200, 200, 150, mPaint1); canvas.drawCircle(540, 200, 150, mPaint2); &#125;&#125; 2. setColor()1void setColor(int color) 设置画笔颜色。一个颜色值是由红、绿、蓝三色合成出来的，所以，参数 color 只能取 8 位的 0xAARRGGBB 样式颜色值。其中: A 代表透明度(Alpha)，取值范围是 0~255(对应十六进制的 0x00~0xFF)，取值越小，透明度越高，图像也就越透明。当取 0 时，图像完全不可见。 R 代表红色值(Red)，取值范围是 0~255(对应十六进制的 0x00~0xFF)，取值越小，红色越少。当取 0 时，表示红色完全不可见；当取 255 时，红色完全显示。 G 代表绿色值(Green)，取值范围是 0~255(对应十六进制的 0x00~0xFF)，取值越小，绿色越少。当取 0 时，表示绿色完全不可见；当取 255 时，绿色完全显示。 B 代表蓝色值(Blue)，取值范围是 0~255(对应十六进制的 0x00~0xFF)，取值越小，蓝色越少。当取 0 时，表示蓝色完全不可见；当取 255 时，蓝色完全显示。 示例：12345678910111213141516171819202122232425public class TestView extends View &#123; private Paint mPaint1, mPaint2; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mPaint1 = generatePaint(Color.RED, Paint.Style.FILL, 50); mPaint2 = generatePaint(0x7EFFFF00, Paint.Style.FILL, 50); &#125; @Override protected void onDraw(Canvas canvas) &#123; canvas.drawCircle(200, 200, 150, mPaint1); canvas.drawCircle(200, 200, 100, mPaint2); &#125; private Paint generatePaint(int color, Paint.Style style, int strokeWidth) &#123; Paint paint = new Paint(); paint.setColor(color); paint.setStyle(style); paint.setStrokeWidth(strokeWidth); return paint; &#125;&#125; 3. setStyle()1void setStyle(Style style) 设置填充样式，对于文字和几何图形都有效。style 的取值如下： Paint.Style.FILL：仅填充内部。 Paint.Style.FILL_AND_STROKE：填充内部和描边。 Paint.Style.STROKE：仅描边。 示例： 123456789paintF = generatePaint(Color.RED, Paint.Style.FILL, 50);paintS = generatePaint(Color.RED, Paint.Style.STROKE, 50);paintFS = generatePaint(Color.RED, Paint.Style.FILL_AND_STROKE, 50);paintLine = generatePaint(Color.BLACK, Paint.Style.STROKE, 1);canvas.drawCircle(225, 300, 150, paintF);canvas.drawCircle(600, 300, 150, paintS);canvas.drawCircle(1000, 300, 150, paintFS);canvas.drawLine(225, 150, 1000, 150, paintLine); 4. setStrokeWidth()1void setStrokeWidth(float width) 设置描边宽度值，单位是 px。当画笔的 Style 样式是 STROKE、FILL_AND_STROKE 时有效。当 Style 不起作用时，用于设置画笔宽度。 1.1.3 Canvas使用基础1. 画布背景设置有三种方法可以实现画布背景设置：123void drawColor(int color)void drawARGB(int a, int r, int g, int b)void drawRGB(int r, int g, int b) drawColor() 函数中参数 color 的取值必须是 8 位的 0xAARRGGBB 样式颜色值。drawARGB() 函数允许分别传入 A、R、G、B 分量，每个颜色值的取值范围都是 0~255(对应十六进制的 0x00~0xFF)，内部会通过这些颜色分量构造出对应的颜色值。 drawRGB() 函数只允许传入 R、G、B 分量，透明度 Alpha 的值取 255。 示例：123canvas.drawColor(0xFFFF00FF);canvas.drawARGB(0xFF, 0xFF, 0, 0xFF);canvas.drawRGB(255, 0, 255); 2. 画直线12void drawLine(float startX, float startY, float stopX, float stopY, Paint paint) 参数: startX：起始点 X 坐标。 startY：起始点 Y 坐标。 stopX：终点 X 坐标。 stopY：终点 Y 坐标。 示例：123mPaintF = generatePaint(Color.RED, Paint.Style.FILL, 50);mPaintS = generatePaint(Color.RED, Paint.Style.STROKE, 50);mPaintFS = generatePaint(Color.RED, Paint.Style.FILL_AND_STROKE, 50); 从效果图中可以明显看出，直线的粗细与画笔 Style 是没有关系的。当设置不同的 StrokeWidth 时，效果如下图所示。123mPaintF = generatePaint(Color.RED, Paint.Style.FILL, 5);mPaintS = generatePaint(Color.RED, Paint.Style.STROKE, 25);mPaintFS = generatePaint(Color.RED, Paint.Style.FILL_AND_STROKE, 50); 可见，直线的粗细是与 paint.setStrokeWidth 有直接关系的。所以，一般而言，paint.setStrokeWidth 在 Style 起作用时，用于设置描边宽度；在 Style 不起作用时，用于设置画笔宽度。 3. 多条直线1void drawLines(float[] pts, Paint paint) 参数：pts：点的集合。从下面的代码中可以看到，这里不是形成连接线，而是每两个点形成一条直线，pts 的组织方式 {x1,y1,x2,y2,x3,y3,…}。 示例：1234567mPaint = new Paint();mPaint.setColor(Color.RED);mPaint.setStrokeWidth(5);float []pts = &#123;10,10,100,100,200,200,400,400&#125;;// onDraw()canvas.drawLines(pts, mPaint); 上面有 4 个点，分别是(10,10)、(100,100)、(200,200)和(400,400)，两两连成一条直线。 另一个构造函数：1void drawLines(float[] pts, int offset, int count, Paint paint) 相比上面的构造函数，这里多了两个参数。 int offset：集合中跳过的数值个数。注意不是点的个数！一个点有两个数值。 int count：参与绘制的数值个数，指 pts 数组中数值的个数，而不是点的个数，因为一个点有两个数值。 12float[] pts = &#123;10,10,100,100,200,200,400,400&#125;;canvas.drawLines(pts, 2, 4, paint); 表示从 pts 数组中索引为 2 的数字开始绘图，有 4 个数值参与绘图，也就是点(100,100) 和(200,200)，所以效果图就是这两个点的连线。 4. 点1void drawPoint(float x, float y, Paint paint) 示例：12345mPaint = new Paint();mPaint.setColor(Color.RED);mPaint.setStrokeWidth(15);canvas.drawPoint(100, 100, mPaint); 在(100,100)位置画一个点。同样，点的大小只与 paint.setStrokeWidth(width) 有关，而与 paint.setStyle 无关。 5. 多个点123void drawPoints(@Size(multiple = 2) @NonNull float[] pts, @NonNull Paint paint)void drawPoints(@Size(multiple = 2) float[] pts, int offset, int count, @NonNull Paint paint) 这几个参数的含义与多条直线中的参数含义相同。 float[] pts：点的合集，与上面的直线一致，样式为{x1,y1,x2,y2,x3,y3,…}。 int offset：集合中跳过的数值个数。注意不是点的个数！一个点有两个数值。 int count：参与绘制的数值个数，指 pts 数组中数值的个数，而不是点的个数。 示例：12345678private Paint mPaint;float[] pts = &#123;10,10, 100,100, 200,200, 400,400&#125;;mPaint = new Paint();mPaint.setColor(Color.RED);mPaint.setStrokeWidth(15);canvas.drawPoints(pts, 2, 4, mPaint); 同样是上面的 4 个点：(10,10)、(100,100)、(200,200)和(400,400)，在 drawPoints()函数里跳过前两个数值，即第一个点的横、纵坐标，画出后面 4 个数值代表的点，即第二、三个点，第四个点没画。 6. RectF &amp; Rect这两个类都是矩形工具类，根据 4 个点构造出一个矩形结构。RectF 与 Rect 中的方法、 成员变量完全一样，唯一不同的是：RectF 是用来保存 float 类型数值的矩形结构的；而 Rect 是用来保存 int 类型数值的矩形结构的。12345678910// RectF 的构造函数有如下 4 个,但最常用的还是第二个RectF()RectF(float left, float top, float right, float bottom)RectF(RectF r)RectF(Rect r)// Rect 的构造函数有如下 3 个Rect()Rect(int left, int top, int right, int bottom)Rect(Rect r) 一般而言，要构造一个矩形结构,可以通过以下两种方法来实现。12345// 方法一：直接构造Rect rect = new Rect(10,10,100,100); // 方法二：间接构造Rect rect = new Rect(); rect.set(10,10,100,100); 7. 矩形123void drawRect(float left, float top, float right, float bottom, Paint paint) void drawRect(RectF rect, Paint paint)void drawRect(Rect r, Paint paint) 第一个函数是直接传入矩形的 4 个点来绘制矩形的；第二、三个函数是根据传入 RectF 或者 Rect 的矩形变量来指定所绘制的矩形的。 示例：12345678mPaintS = generatePaint(Color.RED, Paint.Style.STROKE, 15);mPaintF = generatePaint(Color.RED, Paint.Style.FILL, 15);mRect = new RectF(210f, 10f, 300f, 100f);// 直接构造canvas.drawRect(10, 10, 100, 100, mPaintS);// 使用 RectF 构造canvas.drawRect(mRect, mPaintF); 8. 圆角矩形1void drawRoundRect(RectF rect, float rx, float ry, Paint paint) 参数: RectF rect：要绘制的矩形。 float rx：生成圆角的椭圆的 X 轴半径。 float ry：生成圆角的椭圆的 Y 轴半径。 示例：1234mPaintF = generatePaint(Color.RED, Paint.Style.FILL, 15);mRect = new RectF(100, 110, 300, 200);canvas.drawRoundRect(mRect, 20, 10, mPaintF); 9. 圆形1void drawCircle(float cx, float cy, float radius, Paint paint) 参数: float cx：圆心点的 X 轴坐标。 float cy：圆心点的 Y 轴坐标。 float radius：圆的半径。 10. 椭圆1void drawOval(RectF oval, Paint paint) 参数:RectF oval：用来生成椭圆的矩形。 椭圆是根据矩形生成的，以矩形的长为椭圆的 X 轴，以矩形的宽为椭圆的 Y 轴。 示例： 123456mPaintO = generatePaint(Color.RED, Paint.Style.STROKE, 5);mPaintR = generatePaint(Color.BLUE, Paint.Style.STROKE, 5);mRect = new RectF(100, 110, 300, 200);canvas.drawRect(mRect, mPaintR); // 画矩形canvas.drawOval(mRect, mPaintO); // 画椭圆 11. 弧12void drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint) 参数: RectF oval：生成椭圆的矩形。 float startAngle：弧开始的角度，以 X 轴正方向为 0°。 float sweepAngle：弧持续的角度。 boolean useCenter：是否有弧的两边。为 true 时，表示带有两边；为 false 时，只有一条弧。 示例：12345678mPaint = generatePaint(Color.RED, Paint.Style.STROKE, 5);mRect1 = new RectF(100, 100, 200, 200);mRect2 = new RectF(220, 100, 320, 200);// 带弧的两边canvas.drawArc(mRect1, 0, 90, true, mPaint);// 不带弧的两边canvas.drawArc(mRect2, 0, 90, false, mPaint); 上述代码中，仅将 paint 的样式设置为 FILL 。效果图如下： 当画笔设为填充模式时，填充区域只限于圆弧的起始点和终点所形成的区域。当带有两边时，会将两边及圆弧内部全部填充；如果没有两边，则只填充圆弧部分。 1.1.4 Rect与RectF1.是否包含点、矩形1）判断是否包含某个点1boolean contains(int x, int y) 该函数用于判断某个点是否在当前矩形中。如果在，则返回 true；如果不在，则返回 false。 参数(x,y)就是当前要判断的点的坐标。 示例：绘制一个灰色矩形，当手指在这个矩形区域内时，矩形变为红色。 123456789101112131415161718192021222324252627282930313233343536373839404142public class TestView extends View &#123; private float mX, mY; private Paint mPaint; private RectF mRect; public TestView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; private void init() &#123; mPaint = new Paint(); mPaint.setStyle(Paint.Style.FILL); mRect = new RectF(100, 100, 500, 350); &#125; @Override protected void onDraw(Canvas canvas) &#123; if (mRect.contains(mX, mY)) &#123; mPaint.setColor(Color.RED); &#125; else &#123; mPaint.setColor(Color.GRAY); &#125; canvas.drawRect(mRect, mPaint); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; mX = event.getX(); mY = event.getY(); if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; invalidate(); return true; &#125; else if (event.getAction() == MotionEvent.ACTION_UP) &#123; mX = -1; mY = -1; &#125; invalidate(); return super.onTouchEvent(event); &#125;&#125; 上述代码注意两点： 在 MotionEvent.ACTION_DOWN 中返回 true，因为当 MotionEvent. ACTION_DOWN 消息到来时，系统会判断返回值，当返回 true 时，表示当前控件已经在拦截 (消费)这个消息了，所以后续的 ACTION_MOVE、ACTION_UP 消息仍然继续传过来。如果返回 false(系统默认返回 false)，就表示当前控件不需要这个消息，那么后续的 ACTION_MOVE、ACTION_UP 消息就不会再传到这个控件。 postInvalidate()和 invalidate()函数都是用来重绘控件的，区别是 invalidate()函数一定要在主线程中执行，否则就会报错；而 postInvalidate()函数则没有那么多讲究，它可以在任何线程中执行，而不必一定是主线程。因为在 postInvalidate()函数中就是利用 handler 给主线程发送刷新界面的消息来实现的，所以它可以在任何线程中执行而不会出错。而正因为它是通过发送消息来实现的，所以它的界面刷新速度可能没有直接调用 invalidate()函数那么快。确定当前线程是主线程的情况下，以 invalidate()函数为主。否则调用调用 postInvalidate()函数为好。因为 onTouchEvent()函数本来就是在主线程中的，所以使用 invalidate()函数更合适。 2）判断是否包含某个矩形123// 根据矩形的 4 个点或者一个 Rect 矩形对象来判断这个矩形是否在当前的矩形区域内。boolean contains(float left, float top, float right, float bottom)boolean contains(RectF r) 2.判断两个矩形是否相交1）静态方法判断是否相交1static boolean intersects(Rect a, Rect b) 这是 Rect 类的一个静态方法，用来判断参数中所传入的两个 Rect 矩形是否相交，如果相交则返回 true，否则返回 false。2）成员方法判断是否相交判断当前 Rect 对象与其他矩形是否相交。1boolean intersects(int left, int top, int right, int bottom) 使用方法：12Rect rect_1 = new Rect(10,10,200,200);boolean interset1_2 = rect_1.intersects(190, 10, 250, 200); 3）判断相交并返回结果12boolean intersect(int left, int top, int right, int bottom)boolean intersect(Rect r) 这两个成员方法与 intersects()方法的区别是，不仅会返回是否相交的结果，而且会把相交部分的矩形赋给当前 Rect 对象。如果两个矩形不相交，则当前 Rect 对象的值不变。 3.合并1）合并两个矩形合并两个矩形的意思就是将两个矩形合并成一个矩形，即无论这两个矩形是否相交，取两个矩形最小左上角点作为结果矩形的左上角点，取两个矩形最大右下角点作为结果矩形的右下角点。如果要合并的两个矩形有一方为空，则将有值的一方作为最终结果。12public void union(int left, int top, int right, int bottom)public void union(Rect r) 示例：12345678910111213141516mPaint = new Paint();mPaint.setStyle(Paint.Style.STROKE);mRect1 = new RectF(200, 100, 500, 300);mRect2 = new RectF(100, 200, 300, 400);// 画出右上的红色矩形mPaint.setColor(Color.RED);canvas.drawRect(mRect1, mPaint);// 画出左下的绿色矩形mPaint.setColor(Color.GREEN);canvas.drawRect(mRect2, mPaint);// 矩形合并mRect1.union(mRect2);// 画出合并后的矩形（蓝色部分）mPaint.setColor(Color.BLUE);canvas.drawRect(mRect1, mPaint); 2）合并矩形与某个点1public void union(int x, int y) 先判断当前矩形与目标合并点的关系。如果不相交，则根据目标点(x,y)的位置，将目标点设置为当前矩形的左上角点或者右下角点。如果当前矩形是一个空矩形，则最后的结果矩形为([0,0],[x,y])，即结果矩形的左上角点为[0,0]，右下角点为[x,y]。 1.1.5 ColorColor 是 Android 中与颜色处理有关的类。 1. 常量颜色123456789101112@ColorInt public static final int BLACK = 0xFF000000;@ColorInt public static final int DKGRAY = 0xFF444444;@ColorInt public static final int GRAY = 0xFF888888;@ColorInt public static final int LTGRAY = 0xFFCCCCCC;@ColorInt public static final int WHITE = 0xFFFFFFFF;@ColorInt public static final int RED = 0xFFFF0000;@ColorInt public static final int GREEN = 0xFF00FF00;@ColorInt public static final int BLUE = 0xFF0000FF;@ColorInt public static final int YELLOW = 0xFFFFFF00;@ColorInt public static final int CYAN = 0xFF00FFFF;@ColorInt public static final int MAGENTA = 0xFFFF00FF;@ColorInt public static final int TRANSPARENT = 0; Color.XXX 来直接使用这些颜色，比如红色：Color.RED。 2. 构造颜色1234// 带有透明度的颜色static int argb(int alpha, int red, int green, int blue)// 不带透明度的颜色：alpha 值取 255static int rgb(int red, int green, int blue) argb() 函数的源码：1234public static int argb(int alpha, int red, int green, int blue) &#123; // 位运算，值得借鉴 return (alpha &lt;&lt; 24) | (red &lt;&lt; 16) | (green &lt;&lt; 8) | blue;&#125; 3. 提取颜色分量1234static int alpha(int color)static int red(int color)static int green(int color)static int blue(int color) 通过上面的 4 个函数提取出对应的 A、R、G、B 颜色分量。12// 得到的结果 green 的值就是 0x0Fint green = Color.green(0xFF000F00);]]></content>
      <categories>
        <category>Custom View</category>
      </categories>
      <tags>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ANDROID 目录]]></title>
    <url>%2F2017%2F06%2F03%2FANDROID%2F00Catalog%2F</url>
    <content type="text"><![CDATA[ANDROID 基础知识、中级知识结构目录… 二、Android中级知识 01 Android安全系列篇一(加密、密钥、签名和证书) 一、Android基础知识 15 代码控制Layout 14 Fragment 13 Android6.0运行时权限处理 12 权限系统 11 日志系统 10 BroadcastReceiver 09 Service总结篇 08 Service通信 07 Service 06 Context 05 Intent概念及应用 04 Activity启动模式 03 Activity之间传递参数 02 Activity生命周期 01 环境搭建]]></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ANDROID 目录]]></title>
    <url>%2F2017%2F06%2F01%2FANDROID%2FINTERMEDIATE%2F01Android%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%E7%AF%87%E4%B8%80(%E5%8A%A0%E5%AF%86%E3%80%81%E5%AF%86%E9%92%A5%E3%80%81%E7%AD%BE%E5%90%8D%E4%B8%8E%E8%AF%81%E4%B9%A6)%2F</url>
    <content type="text"><![CDATA[一、安全要解决什么问题在典型的场景中，安全主要用于解决4类需求： 保密（Security/Confidentiality）不希望通信中的信息被第三方窥探；密码；公司机要文件等； 鉴别/认证（Authentication）明确通信对端的身份是你认为的身份。如打电话时通过声音语气等明确对方的身份；银行柜台办理业务时，银行业务员会仔细辨别身份证照片与本人相貌以及问一些能验证身份相关的问题。 完整性（Integrity）能确定信息是否被篡改或丢失。如借钱的收据一般用大写数字，或者阿拉伯数字之间没有空格等要求，防止收据被篡改。 不可否认性（non-repudiation）能明确是谁产生，且无法被“赖掉”。如手印、指纹、皇帝诏书等。 二、你都会的密码术]]></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15 代码控制Layout]]></title>
    <url>%2F2017%2F05%2F31%2FANDROID%2FBASE%2F16RecyclerView%2F</url>
    <content type="text"></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15 代码控制Layout]]></title>
    <url>%2F2017%2F05%2F30%2FANDROID%2FBASE%2F15%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6Layout%2F</url>
    <content type="text"><![CDATA[虽然Google官方强烈建议我们视图应该在配置文件中定义，但是我们依然得掌握使用代码来控制布局文件。123456789101112131415161718192021222324252627282930313233343536373839package com.xianxiaotao.layout;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.LinearLayout;public class MainActivity extends AppCompatActivity &#123; private LinearLayout rootView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); rootView = new LinearLayout(this); rootView.setOrientation(LinearLayout.VERTICAL); setContentView(rootView); for (int i = 0; i &lt; 5; i++) &#123; Button button = new Button(this); button.setAllCaps(false); button.setText("Click To Remove Me"); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; rootView.removeView(v); &#125; &#125;); LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams( LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT ); lp.weight = 1; rootView.addView(button, lp); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[14 Fragment]]></title>
    <url>%2F2017%2F05%2F29%2FANDROID%2FBASE%2F14Fragment%2F</url>
    <content type="text"><![CDATA[一、使用Fragment1、自定义SecondFragment12345678910111213141516171819202122232425package com.xianxiaotao.fragment;import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v4.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;public class SecondFragment extends Fragment &#123; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View root = inflater.inflate(R.layout.fragment_second, container, false); root.findViewById(R.id.btnBackFirstFragment).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; getActivity().getSupportFragmentManager().popBackStack(); // 返回 &#125; &#125;); return root; &#125;&#125; 2、自定义FirstFragment12345678910111213141516171819202122232425262728package com.xianxiaotao.fragment;import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v4.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;public class FirstFragment extends Fragment &#123; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View root = inflater.inflate(R.layout.fragment_first, container, false); root.findViewById(R.id.btnStartSecondFragment).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // SecondFragment替换当前的FirstFragment getActivity().getSupportFragmentManager().beginTransaction() .addToBackStack(null) /* 返回键返回上一个Fragment */ .replace(R.id.container, new SecondFragment()) .commit(); &#125; &#125;); return root; &#125;&#125; 3、MainActivity12345678910111213141516171819package com.xianxiaotao.fragment;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (savedInstanceState == null) &#123; getSupportFragmentManager().beginTransaction() .add(R.id.container, new FirstFragment()) .commit(); &#125; &#125;&#125; 4、布局文件activity_main.xml、fragment_first.xml 和 fragment_second.xml123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/container" android:layout_width="match_parent" android:layout_height="match_parent"/&gt;&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView android:text="This is first fragment" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;Button android:text="Start Second Fragment" android:textAllCaps="false" android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/btnStartSecondFragment"/&gt;&lt;/LinearLayout&gt;&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView android:text="This is second fragment" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;Button android:text="Go Back" android:textAllCaps="false" android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/btnBackFirstFragment"/&gt;&lt;/LinearLayout&gt; 5、静态使用Fragment上述为动态的使用Fragment，静态的使用方式是在布局文件里指定使用哪个Fragment：12345&lt;fragment android:id="@+id/fragment_first" android:name="com.xianxiaotao.FirstFragment" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; 二、Fragment的生命周期简述Fragment必须是依存与Activity而存在的，因此Activity的生命周期会直接影响到Fragment的生命周期。官网这张图很好的说明了两者生命周期的关系：可以看到Fragment比Activity多了几个额外的生命周期回调方法：onAttach(Activity)当Fragment与Activity发生关联时调用。onCreateView(LayoutInflater, ViewGroup,Bundle)创建该Fragment的视图onActivityCreated(Bundle)当Activity的onCreate方法返回时调用onDestoryView()与onCreateView想对应，当该Fragment的视图被移除时调用onDetach()与onAttach相对应，当Fragment与Activity关联被取消时调用注意：除了onCreateView，其他的所有方法如果你重写了，必须调用父类对于该方法的实现 测试在上述Demo中每个Fragment里重写所有的生命周期方法以及MainActivity，并输出日志信息。如下：12345@Overridepublic void onAttach(Context context) &#123; super.onAttach(context); System.out.println("FirstFragment onAttach");&#125; 1、启动程序，在MainActivity的onCreate方法中引用了FirstFragment。日志如下：123456789MainActivity onCreateFirstFragment onAttachFirstFragment onCreateFirstFragment onCreateViewFirstFragment onActivityCreatedFirstFragment onStartMainActivity onStartMainActivity onResumeFirstFragment onResume 2、Start Second Fragment，使用SecondFragment替换FirstFragment。日志：123456789SecondFragment onAttachSecondFragment onCreateFirstFragment onPauseFirstFragment onStopFirstFragment onDestroyViewSecondFragment onCreateViewSecondFragment onActivityCreatedSecondFragment onStartSecondFragment onResume 3、Go Back，由SecondFragment返回到FirstFragment。日志：123456789SecondFragment onPauseSecondFragment onStopSecondFragment onDestroyViewSecondFragment onDestroySecondFragment onDetachFirstFragment onCreateViewFirstFragment onActivityCreatedFirstFragment onStartFirstFragment onResume 4、返回，即退出应用程序。日志：12345678FirstFragment onPauseMainActivity onPauseFirstFragment onStopMainActivity onStopFirstFragment onDestroyViewFirstFragment onDestroyFirstFragment onDetachMainActivity onDestroy]]></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13 Android6.0运行时权限处理]]></title>
    <url>%2F2017%2F05%2F29%2FANDROID%2FBASE%2F13Android6.0%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[参考文档： google官方文档 Android 6.0 运行时权限处理完全解析 探讨Android 6.0及以上新权限系统的检测与处理 一、新的权限机制Google将权限分为两类，一类是Normal Permissions，这类权限一般不涉及用户隐私，是不需要用户进行授权的，比如手机震动、访问网络等；另一类是Dangerous Permissions,一般是涉及到用户隐私的，需要用户进行授权，比如读取sdcard、访问通讯录等。 Normal Permissions123456789101112131415161718192021222324252627282930313233ACCESS_LOCATION_EXTRA_COMMANDSACCESS_NETWORK_STATEACCESS_NOTIFICATION_POLICYACCESS_WIFI_STATEBLUETOOTHBLUETOOTH_ADMINBROADCAST_STICKYCHANGE_NETWORK_STATECHANGE_WIFI_MULTICAST_STATECHANGE_WIFI_STATEDISABLE_KEYGUARDEXPAND_STATUS_BARGET_PACKAGE_SIZEINSTALL_SHORTCUTINTERNETKILL_BACKGROUND_PROCESSESMODIFY_AUDIO_SETTINGSNFCREAD_SYNC_SETTINGSREAD_SYNC_STATSRECEIVE_BOOT_COMPLETEDREORDER_TASKSREQUEST_INSTALL_PACKAGESSET_ALARMSET_TIME_ZONESET_WALLPAPERSET_WALLPAPER_HINTSTRANSMIT_IRUNINSTALL_SHORTCUTUSE_FINGERPRINTVIBRATEWAKE_LOCKWRITE_SYNC_SETTINGS Dangerous Permissions123456789101112131415161718192021222324252627282930313233343536373839404142group:android.permission-group.CONTACTS permission:android.permission.WRITE_CONTACTS permission:android.permission.GET_ACCOUNTS permission:android.permission.READ_CONTACTSgroup:android.permission-group.PHONE permission:android.permission.READ_CALL_LOG permission:android.permission.READ_PHONE_STATE permission:android.permission.CALL_PHONE permission:android.permission.WRITE_CALL_LOG permission:android.permission.USE_SIP permission:android.permission.PROCESS_OUTGOING_CALLS permission:com.android.voicemail.permission.ADD_VOICEMAILgroup:android.permission-group.CALENDAR permission:android.permission.READ_CALENDAR permission:android.permission.WRITE_CALENDARgroup:android.permission-group.CAMERA permission:android.permission.CAMERAgroup:android.permission-group.SENSORS permission:android.permission.BODY_SENSORSgroup:android.permission-group.LOCATION permission:android.permission.ACCESS_FINE_LOCATION permission:android.permission.ACCESS_COARSE_LOCATIONgroup:android.permission-group.STORAGE permission:android.permission.READ_EXTERNAL_STORAGE permission:android.permission.WRITE_EXTERNAL_STORAGEgroup:android.permission-group.MICROPHONE permission:android.permission.RECORD_AUDIOgroup:android.permission-group.SMS permission:android.permission.READ_SMS permission:android.permission.RECEIVE_WAP_PUSH permission:android.permission.RECEIVE_MMS permission:android.permission.RECEIVE_SMS permission:android.permission.SEND_SMS permission:android.permission.READ_CELL_BROADCASTS Dangerous Permissions分组机制：如果你申请某个危险的权限，假设你的app早已被用户授权了同一组的某个危险权限，那么系统立即授权，而不需要用户点击授权。比如你的app对READ_CONTACTS已经授权了，当你的app申请WRITE_CONTACTS时，系统会直接授权通过。此外，对于申请时弹出的dialog上面的文本说明也是对整个权限组的说明，而不是单个权限的说明。 不过需要注意的是，不要对权限组过多的依赖，尽可能对每个危险权限都进行正常流程的申请，因为在后期的版本中这个权限组可能会产生变化。 二、API的使用1、在AndroidManifest文件中添加需要的权限：1&lt;uses-permission android:name="android.permission.READ_CONTACTS"/&gt; 2、检查权限：12345if (ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) &#123; // 未被授权，申请权限&#125; else &#123; // 已被授权&#125; ContextCompat.checkSelfPermission：主要用于检测某个权限是否已经被授予，方法返回值为PackageManager.PERMISSION_DENIED或者PackageManager.PERMISSION_GRANTED。当返回DENIED就需要进行申请授权了。 3、申请权限授权12345ActivityCompat.requestPermissions( thisActivity, /* Context */ new String[]&#123;Manifest.permission.READ_CONTACTS&#125;, /* 需要申请的权限的字符串数组 */ MY_PERMISSIONS_REQUEST_READ_CONTACTS /* requestCode,用于回调时检测 */ ); 该方法是异步的，支持一次性申请多个权限授权，而系统会通过对话框逐一询问用户是否授权。 4、处理申请回调123456789101112@Overridepublic void onRequestPermissionResult(int requestCode, String[] permissions, int[] grantResult) &#123; switch(requestCode) &#123; // If request is cancelled, the result arrays are empty. if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; // Permission was granted, yay! Do the contacts-related task you need to do. &#125; else &#123; // Permission denied, boo! Disable the functionality that depends on this permission. &#125; return; &#125;&#125; 对于权限的申请结果，首先验证requestCode定位到你的申请，然后验证grantResults对应于申请的结果，这里的数组对应于申请时的第二个权限字符串数组。如果你同时申请两个权限，那么grantResults的length就为2，分别记录你两个权限的申请结果。如果申请成功，就可以做你的事情了~ 5、还有个API值得提一下：123456// Should we show an explanation?if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity, Manifest.permission.READ_CONTACTS)) // Show an expanation to the user *asynchronously* -- don't block // this thread waiting for the user's response! After the user // sees the explanation, try again to request the permission.&#125; 这个API主要用于给用户一个申请权限的解释，该方法只有在用户在上一次已经拒绝过你的这个权限申请。也就是说，用户已经拒绝一次了，你又弹个授权框，你需要给用户一个解释，为什么要授权，则使用该方法。 6、综合上述步骤：12345678910111213141516171819202122232425// Here, thisActivity is the current activityif (ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) &#123; // Should we show an explanation? if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity, Manifest.permission.READ_CONTACTS)) &#123; // Show an expanation to the user *asynchronously* -- don't block // this thread waiting for the user's response! After the user // sees the explanation, try again to request the permission. &#125; else &#123; // No explanation needed, we can request the permission. ActivityCompat.requestPermissions(thisActivity, new String[]&#123;Manifest.permission.READ_CONTACTS&#125;, MY_PERMISSIONS_REQUEST_READ_CONTACTS); // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an // app-defined int constant. The callback method gets the // result of the request. &#125;&#125; 三、Simple Demo ：直接拨打电话AndroidManifest.xml123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.xianxiaotao.callphone"&gt; &lt;uses-permission android:name="android.permission.CALL_PHONE"/&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.LAUNCHER"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; MainActivity.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.xianxiaotao.callphone;import android.Manifest;import android.content.Intent;import android.content.pm.PackageManager;import android.net.Uri;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; private static final int MY_PERMISSIONS_REQUEST_CALL_PHONE = 1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void callPhone(View v) &#123; if (ContextCompat.checkSelfPermission(this, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.CALL_PHONE&#125;, MY_PERMISSIONS_REQUEST_CALL_PHONE); &#125; else &#123; call(); &#125; &#125; public void call() &#123; Intent intent = new Intent(Intent.ACTION_CALL); Uri data = Uri.parse("tel:" + 10086); intent.setData(data); try &#123; startActivity(intent); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; if (requestCode == MY_PERMISSIONS_REQUEST_CALL_PHONE) &#123; if (grantResults[0] == PackageManager.PERMISSION_GRANTED) call(); else Toast.makeText(MainActivity.this, "Permission Denied", Toast.LENGTH_SHORT).show(); return; &#125; super.onRequestPermissionsResult(requestCode, permissions, grantResults); &#125;&#125; 在Android 6.x上运行是，点击testCall，即会弹出授权窗口，如何你Allow则直接拨打电话，如果Denied则Toast弹出”Permission Denied”。 对于Intent这种方式，很多情况下是不需要授权的甚至权限都不需要的，比如以下情况就不需要申请权限：你是到拨号界面而不是直接拨打电话；打开系统图库去选择照片；调用系统相机app去拍照等。]]></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12 权限系统]]></title>
    <url>%2F2017%2F05%2F28%2FANDROID%2FBASE%2F12%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[请求权限代码中包含这样的代码：1mWebView.loadUrl("https://xianxiaotao.github.io/"); 我们需要为它请求网络权限，在AndroidMainfest.xml文件中添加以下权限：1&lt;uses-permission android:name="android.permission.INTERNET"/&gt; 为代码添加权限检查在AndroidMainfest.xml文件中声明一个自定义权限：1&lt;permission android:name="com.xianxiaotao.checkpermission.permission.DO_SOMETHING" /&gt; 当我们需要在代码中为应用添加权限检查功能时，如：123456789101112131415161718192021222324public class CheckPermission &#123; public static final String PERMISSION_DO_SOMETHING = "com.xianxiaotao.checkpermission.permission.DO_SOMETHING"; public static void doSomething(Context context) &#123; int checkResult = context.checkCallingOrSelfPermission(PERMISSION_DO_SOMETHING); if (checkResult != PackageManager.PERMISSION_GRANTED) &#123; throw new SecurityException("doSomething need permission: " + PERMISSION_DO_SOMETHING); &#125; System.out.println("If allowed, do something!"); &#125;&#125;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); CheckPermission.doSomething(this); &#125;&#125; 此时运行程序，发生SecurityException。为此，我们需要添加权限：1&lt;uses-permission android:name="com.xianxiaotao.checkpermission.permission.DO_SOMETHING"/&gt; 为基本组件添加权限检查这种自定义的权限通常是为其他应用访问本应用所设的限制。例如在AndroidMainfest.xml文件中声明一个自定义权限：1&lt;permission android:name="com.xianxiaotao.music.permission.PLAY_MUSIC" /&gt; 然后为PlayMusicActivity添加权限检查：12345678&lt;activity android:name=".activity.PlayMusicActivity" android:permission="com.xianxiaotao.music.permission.PLAY_MUSIC"&gt; &lt;intent-filter&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;action android:name="com.xianxiaotao.music.intent.action.PLAY_MUSIC"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 应用内部执行下列语句，则不需要做额外工作，在同一个应用内，对于四大组件来说默认拥有访问权限。1startActivity(new Intent(MainActivity.this, PlayMusicActivity.class)); 但是对于其他应用，如果：1startActivity(new Intent("com.xianxiaotao.music.permission.PLAY_MUSIC")); 就需要添加权限才能访问PlayMusicActivity：1&lt;uses-permission android:name="com.xianxiaotao.music.permission.PLAY_MUSIC"/&gt;]]></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11 日志系统]]></title>
    <url>%2F2017%2F05%2F28%2FANDROID%2FBASE%2F11%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[使用日志API使用1234567private static final String TAG = "MainActivity";Log.e(TAG, "错误信息");Log.w(TAG, "警告信息");Log.i(TAG, "普通信息");Log.d(TAG, "调试信息");Log.v(TAG, "无用信息"); // 便于程序猿唠叨 Java日志：System.out对应Log.i；System.err对应Log.w 日志分类在Android Studio中对日志进行分类呈现，便于开发调试： Android Monitor -&gt; 选择Log level: Verbose、Debug、Info、Warn、Error Regex：进行搜索 Edit Filter Configuration DDMS中查看日志1) 使用Android Studio中的DDMSTools -&gt; Android -&gt; Android Device Monitor2) 独立的 DDMS 查看日志双击Mac电脑上文件：/xianxiaotao/Library/Android/SDK/tools/ddms 日志工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.xianxiaotao.utils;import android.util.Log;/** * Log统一管理类 */public class L &#123; private L() &#123; /* cannot be instantiated */ throw new UnsupportedOperationException("cannot be instantiated"); &#125; public static boolean isDebug = true; // 是否需要打印bug，可以在application的onCreate函数里面初始化 private static final String TAG = "xian"; // 下面四个是默认tag的函数 public static void v(String msg) &#123; if (isDebug) Log.v(TAG, msg); &#125; public static void d(String msg) &#123; if (isDebug) Log.d(TAG, msg); &#125; public static void i(String msg) &#123; if (isDebug) Log.i(TAG, msg); &#125; public static void w(String msg) &#123; if (isDebug) Log.w(TAG, msg); &#125; public static void e(String msg) &#123; if (isDebug) Log.e(TAG, msg); &#125; // 下面是传入自定义tag的函数 public static void v(String tag, String msg) &#123; if (isDebug) Log.v(tag, msg); &#125; public static void d(String tag, String msg) &#123; if (isDebug) Log.d(tag, msg); &#125; public static void i(String tag, String msg) &#123; if (isDebug) Log.i(tag, msg); &#125; public static void w(String tag, String msg) &#123; if (isDebug) Log.w(tag, msg); &#125; public static void e(String tag, String msg) &#123; if (isDebug) Log.e(tag, msg); &#125;&#125; 以后进阶：奔溃日志收集与上传]]></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10 BroadcastReceiver]]></title>
    <url>%2F2017%2F05%2F28%2FANDROID%2FBASE%2F10BroadcastReceiver%2F</url>
    <content type="text"><![CDATA[一、基本概念广播 有序广播：被广播接收器接收后，可被终止，无法往下继续传达。 普通广播：发送至每一个已经注册（订阅）的广播接收器，无法被终止。 广播接收器 静态注册广播接收器：在AndroidManifest.xml中设置，程序不用启动亦可接收。 动态注册广播接收器：代码中注册广播，程序未启动时，无法接收广播。 二、使用BroadcastReceiver创建MyReceiver.java1234567891011121314151617181920212223242526package com.xianxiaotao.learnreceiver;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;public class MyReceiver extends BroadcastReceiver &#123; private static final String ARG = "data"; public MyReceiver() &#123;&#125; @Override public void onReceive(Context context, Intent intent) &#123; System.out.println("My Receiver : " + intent.getStringExtra(ARG)); &#125; /** * 静态注册发送广播方式 */ public static Intent newIntent(Context context, String args) &#123; Intent intent = new Intent(context, MyReceiver.class); intent.putExtra(ARG, args); return intent; &#125;&#125; 静态注册123456789&lt;application&gt; ... &lt;receiver android:name=".MyReceiver" android:enabled="true" android:exported="true"&gt; &lt;/receiver&gt;&lt;/application&gt; 发送广播1sendBroadcast(MyReceiver.newIntent(this, "xianxiaotao")); 三、动态注册和注销BroadcastReceiver动态注册不需要在AndroidMainfest.xml文件中配置删除AndroidMainfest.xml文件中对MyReceiver的声明 为MyReceiver增加动新的发送广播方式12345678910111213141516public class MyReceiver extends BroadcastReceiver &#123; private static final String ARG = "data"; public static final String ACTION = "MyReceiver.intent.action"; ... /** * 动态注册发送广播方式 */ public static Intent newIntent(String args) &#123; Intent intent = new Intent(MyReceiver.ACTION); intent.putExtra(ARG, args); return intent; &#125;&#125; MainActivity中动态注册、发送广播和注销广播123456789101112131415161718192021222324252627public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private MyReceiver mMyReceiver = null; ... @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btnSendBroadcast: // 发送广播 sendBroadcast(MyReceiver.newIntent("xianxiaotao")); break; case R.id.btnRegBroadcast: // 注册广播 if (mMyReceiver == null) &#123; mMyReceiver = new MyReceiver(); registerReceiver(mMyReceiver, new IntentFilter(MyReceiver.ACTION)); &#125; break; case R.id.btnUnregBroadcast: // 注销广播 if (mMyReceiver != null) &#123; unregisterReceiver(mMyReceiver); mMyReceiver = null; &#125; break; &#125; &#125;&#125; 实际开发中必须在onDestroy方法中注销广播，否则有内存泄漏的风险！！！ 四、动态注册和静态注册的区别 动态注册的广播会受Activity的生命周期的影响，当Activity销毁的时候，广播就失效了。 而静态注册的广播，即使Activity销毁了，仍然可以收到广播。更牛掰的是即使杀死进程，仍然可以收到广播，关于这点不同的手机测试的结果是不同的。 静态注册的广播，必需单独成一个类，不能像动态注册那样写在某个界面里。 在Android中，有一些action是不支持静态注册的： android.intent.action.SCREEN_ON android.intent.action.SCREEN_OFF android.intent.action.BATTERY_CHANGED android.intent.action.CONFIGURATION_CHANGED android.intent.action.TIME_TICK 五、BroadcastReceiver的优先级配置文件中可以设置优先级：android:priority=”10”12345678910111213141516&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.xianxiaotao.learnreceiver"&gt; &lt;application&gt; ... &lt;receiver android:name=".MyReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter android:priority="10"&gt; &lt;action android:name="com.xianxiaotao.learnreceiver.intent.action"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;/application&gt;&lt;/manifest&gt; 发送、终止/拦截有序广播 发送有序广播必须使用sendOrderedBroadcast()方法。 终止有序广播需要在onReceive()方法里使用abortBroadcast()。 终止的是普通广播则会发生RuntimeException。 有序广播优先级规则 优先级高的先接收（数字越大，优先级越高，其范围有待研究） 同优先级的动静态广播接收器，动态优先于静态 同优先级的动态广播接收器，或者同优先级的静态广播接收器，按照注册顺序。即静态：先扫描的大于后扫描的，动态：先注册的大于后注册的。 普通广播优先级规则 无视优先级，动态广播接收器优先于静态广播接收器。 按照注册顺序。静态：先扫描的大于后扫描的，动态：先注册的大于后注册的。]]></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[09 Service总结篇]]></title>
    <url>%2F2017%2F05%2F26%2FANDROID%2FBASE%2F09Service%E6%80%BB%E7%BB%93%E7%AF%87%2F</url>
    <content type="text"><![CDATA[博客原文：Android总结篇系列：Android Service Service通常总是称之为“后台服务”，其中“后台”一词是相对于前台而言的，具体是指其本身的运行并不依赖于用户可视的UI界面，因此，从实际业务需求上来理解，Service的适用场景应该具备以下条件：1.并不依赖于用户可视的UI界面（当然，这一条其实也不是绝对的，如前台Service就是与Notification界面结合使用的）；2.具有较长时间的运行特性。 1、Service AndroidManifest.xml 声明一般而言，从Service的启动方式上，可以将Service分为Started Service和Bound Service。无论哪种具体的Service启动类型，都是通过继承Service基类自定义而来。在使用Service时，要想系统能够找到此自定义Service，无论哪种类型，都需要在AndroidManifest.xml中声明，语法格式如下：12345678910&lt;service android:enabled=["true" | "false"] android:exported=["true" | "false"] android:icon="drawable resource" android:isolatedProcess=["true" | "false"] android:label="string resource" android:name="string" android:permission="string" android:process="string" &gt; . . .&lt;/service&gt; 其中，android:name对应Service类名，android:permission是权限声明，android:process设置具体的进程名称。需要注意的是Service能否单独使用一个进程与其启动方式有关，本后下面会给出具体说明。其他的属性此处与其他组件基本相同，不再过多描述。 如果自定义Service没有在AndroidManifest.xml中声明，当具体使用时，不会像Activity那样直接崩溃报错，对于显式Intent启动的Service，此时也会给出waring信息“IllegalArgumentException: Service not registered”，有时候不容易发现忘了声明而一时定位不到问题。 2、Started Service通过context.startService(Intent serviceIntent)启动Service，context.stopService(Intent serviceIntent)停止此Service。当然，在Service内部，也可以通过stopSelf(…)方式停止其本身。注意：如果服务是通过绑定服务开启的，stopSelf方法无效。1) Started Service自定义123456789101112131415161718192021222324252627282930public class MyService extends Service &#123; public static final String TAG = "MyService"; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onCreate() &#123; super.onCreate(); Log.w(TAG, "in onCreate"); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.w(TAG, "in onStartCommand"); Log.w(TAG, "MyService:" + this); String name = intent.getStringExtra("name"); Log.w(TAG, "name:" + name); return START_STICKY; &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.w(TAG, "in onDestroy"); &#125;&#125; 其中，onBind(…)函数是Service基类中的唯一抽象方法，子类都必须重写实现，此函数的返回值是针对Bound Service类型的Service才有用的，在Started Service类型中，此函数直接返回 null 即可。onCreate(…)、onStartCommand(…)和onDestroy()都是Started Service相应生命周期阶段的回调函数。 2) Started Service使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MainActivity extends Activity &#123; public static final String TAG = "MainActivity"; private Button startServiceBtn; private Button stopServideBtn; private Button goBtn; private Intent serviceIntent; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); startServiceBtn = (Button) findViewById(R.id.start_service); stopServideBtn = (Button) findViewById(R.id.stop_service); goBtn = (Button) findViewById(R.id.go); startServiceBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; serviceIntent = new Intent(MainActivity.this, MyService.class); startService(serviceIntent); &#125; &#125;); stopServideBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; stopService(serviceIntent); &#125; &#125;); goBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(MainActivity.this, BActivity.class); startActivity(intent); &#125; &#125;); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); Log.w(TAG, "in onDestroy"); &#125;&#125; 当Client调用startService(Intent serviceIntent)后，如果MyService是第一次启动，首先会执行 onCreate()回调，然后再执行onStartCommand(Intent intent, int flags, int startId)，当Client再次调用startService(Intent serviceIntent)，将只执行onStartCommand(Intent intent, int flags, int startId)，因为此时Service已经创建了，无需执行onCreate()回调。无论多少次的startService，只需要一次stopService()即可将此Service终止，执行onDestroy()函数（其实很好理解，因为onDestroy()与onCreate()回调是相对的）。 下面重点关注下onStartCommand(Intent intent, int flags, int startId)方法：其中参数flags默认情况下是0，对应的常量名为START_STICKY_COMPATIBILITY。startId是一个唯一的整型，用于表示此次Client执行startService(…)的请求请求标识，在多次startService(…)的情况下，呈现0,1,2….递增。另外，此函数具有一个int型的返回值，具体的可选值及含义如下： START_NOT_STICKY：当Service因为内存不足而被系统kill后，接下来未来的某个时间内，即使系统内存足够可用，系统也不会尝试重新创建此Service。除非程序中Client明确再次调用startService(…)启动此Service。 START_STICKY：当Service因为内存不足而被系统kill后，接下来未来的某个时间内，当系统内存足够可用的情况下，系统将会尝试重新创建此Service，一旦创建成功后将回调onStartCommand(…)方法，但其中的Intent将是null，pendingintent除外。 START_REDELIVER_INTENT：与START_STICKY唯一不同的是，回调onStartCommand(…)方法时，其中的Intent将是非空，将是最后一次调用startService(…)中的intent。 START_STICKY_COMPATIBILITY：compatibility version of {@link #START_STICKY} that does not guarantee that {@link #onStartCommand} will be called again after being killed。此值一般不会使用，所以注意前面三种情形就好。 以上的描述中，”当Service因为内存不足而被系统kill后“一定要非常注意，因为此函数的返回值设定只是针对此种情况才有意义的，换言之，当人为的kill掉Service进程，此函数返回值无论怎么设定，接下来未来的某个时间内，即使系统内存足够可用，Service也不会重启。另外，需要注意的是，小米手机针对此处做了一定的修改。在“自启动管理”中有一个自启动应用列表，默认情况下，只有少应用（如微信、QQ、YY、360等）默认是可以自启动的，其他应用默认都是禁止的。用户可以手动添加自启动应用，添加后的应用中如果Started Service onStartCommand(…)回调返回值是START_STICKY或START_REDELIVER_INTENT，当用户在小米手机上长按Home键结束App后，接下来未来的某个时间内，当系统内存足够可用时，Service依然可以按照上述规定重启。当然，如果用户在 设置 &gt;&gt; 应用 &gt;&gt; 强制kill掉App进程，此时Service是不会重启的。注：以上实验结论基于小米2S亲测。 3) Started Service生命周期及进程相关1.onCreate(Client首次startService(..)) &gt;&gt; onStartCommand &gt;&gt; onStartCommand - optional … &gt;&gt; onDestroy(Client调用stopService(..))注：onStartCommand(..)可以多次被调用，onDestroy()与onCreate()想匹配，当用户强制kill掉进程时，onDestroy()是不会执行的。2.对于同一类型的Service，Service实例一次永远只存在一个，而不管Client是否是相同的组件，也不管Client是否处于相同的进程中。3.Service通过startService(..)启动Service后，此时Service的生命周期与Client本身的什么周期是没有任何关系的，只有Client调用stopService(..)或Service本身调用stopSelf(..)才能停止此Service。当然，当用户强制kill掉Service进程或系统因内存不足也可能kill掉此Service。4.Client A 通过startService(..)启动Service后,可以在其他Client（如Client B、Client C）通过调用stopService(..)结束此Service。5.Client调用stopService(..)时，如果当前Service没有启动，也不会出现任何报错或问题，也就是说，stopService(..)无需做当前Service是否有效的判断。6.startService(Intent serviceIntent)，其中的intent既可以是显式Intent，也可以是隐式Intent，当Client与Service同处于一个App时，一般推荐使用显示Intent。当处于不同App时，只能使用隐式Intent。当Service需要运行在单独的进程中，AndroidManifest.xml声明时需要通过android:process指明此进程名称，当此Service需要对其他App开放时，android:exported属性值需要设置为true(当然，在有intent-filter时默认值就是true)。12345678&lt;service android:name=".MyService" android:exported="true" android:process=":MyCorn" &gt; &lt;intent-filter&gt; &lt;action android:name="com.example.androidtest.myservice" /&gt; &lt;/intent-filter&gt;&lt;/service&gt; 4) Started Service Client与Service通信相关当Client调用startService(Intent serviceIntent)启动Service时，Client可以将参数通过Intent直接传递给Service。Service执行过程中，如果需要将参数传递给Client，一般可以通过借助于发送广播的方式（此时，Client需要注册此广播）。 3、Bound Service相对于Started Service，Bound Service具有更多的知识点。Bound Service的主要特性在于Service的生命周期是依附于Client的生命周期的，当Client不存在时，Bound Service将执行onDestroy，同时通过Service中的Binder对象可以较为方便进行Client-Service通信。Bound Service一般使用过程如下：1.自定义Service继承基类Service，并重写onBind(Intent intent)方法，此方法中需要返回具体的Binder对象；2.Client通过实现ServiceConnection接口来自定义ServiceConnection，并通过bindService (Intent service, ServiceConnection sc, int flags)方法将Service绑定到此Client上；3.自定义的ServiceConnection中实现onServiceConnected(ComponentName name, IBinder binder)方法，获取Service端Binder实例；4.通过获取的Binder实例进行Service端其他公共方法的调用，以完成Client-Service通信；5.当Client在恰当的生命周期（如onDestroy等）时，此时需要解绑之前已经绑定的Service，通过调用函数unbindService(ServiceConnection sc)。在Bound Service具体使用过程中，根据onBind(Intent intent)方法放回的Binder对象的定义方式不同，又可以将其分为以下三种方式，且每种方式具有不同的特点和适用场景：1）Extending the Binder class就是上述Demo中的代码形式，这是Bound Service中最常见的一种使用方式，也是Bound Service中最简单的一种。局限：Clinet与Service必须同属于同一个进程，不能实现进程间通信（IPC）。否则则会出现类似于“android.os.BinderProxy cannot be cast to xxx”错误。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122public class MyBindService extends Service &#123; public static final String TAG = "MyBindService"; private MyBinder mBinder = new MyBinder(); public class MyBinder extends Binder &#123; MyBindService getService() &#123; return MyBindService.this; &#125; &#125; @Override public void onCreate() &#123; super.onCreate(); Log.w(TAG, "in onCreate"); &#125; @Override public IBinder onBind(Intent intent) &#123; Log.w(TAG, "in onBind"); return mBinder; &#125; @Override public boolean onUnbind(Intent intent) &#123; Log.w(TAG, "in onUnbind"); return super.onUnbind(intent); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.w(TAG, "in onDestroy"); &#125;&#125;public class BActivity extends Activity &#123; public static final String TAG = "BActivity"; private Button bindServiceBtn; private Button unbindServiceBtn; private Button startIntentService; private Intent serviceIntent; private ServiceConnection sc = new MyServiceConnection(); private MyBinder mBinder; private MyBindService mBindService; private boolean mBound; private class MyServiceConnection implements ServiceConnection &#123; @Override public void onServiceConnected(ComponentName name, IBinder binder) &#123; Log.w(TAG, "in MyServiceConnection onServiceConnected"); mBinder = (MyBinder) binder; mBindService = mBinder.getService(); mBound = true; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; // This is called when the connection with the service has been // unexpectedly disconnected -- that is, its process crashed. Log.w(TAG, "in MyServiceConnection onServiceDisconnected"); mBound = false; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.b); bindServiceBtn = (Button) findViewById(R.id.bind_service); unbindServiceBtn = (Button) findViewById(R.id.unbind_service); startIntentService = (Button) findViewById(R.id.start_intentservice); bindServiceBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(BActivity.this, MyBindService.class); bindService(intent, sc, Context.BIND_AUTO_CREATE); &#125; &#125;); unbindServiceBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; excuteUnbindService(); &#125; &#125;); startIntentService.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(BActivity.this, MyIntentService.class); startService(intent); &#125; &#125;); &#125; private void excuteUnbindService() &#123; if (mBound) &#123; unbindService(sc); mBound = false; &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); Log.w(TAG, "in onDestroy"); excuteUnbindService(); &#125;&#125; 首次点击bindServiceBtn进行bindService(..)时，依次回调顺序如下：123MyBindService(13457): in onCreateMyBindService(13457): in onBindBActivity(13457): in MyServiceConnection onServiceConnected 再次点击bindServiceBtn按钮时，发现没有任何输出，说明MyBindService没有进行任何回调。点击unbindServiceBtn进行unbindService(..)时，回调顺序为：12MyBindService(13457): in onUnbindMyBindService(13457): in onDestroy 注：在四大基本组件中，需要注意的的是BroadcastReceiver不能作为Bound Service的Client，因为BroadcastReceiver的生命周期很短，当执行完onReceive(..)回调时，BroadcastReceiver生命周期完结。而Bound Service又与Client本身的生命周期相关，因此，Android中不允许BroadcastReceiver去bindService(..)，当有此类需求时，可以考虑通过startService(..)替代。 2）Using a MessengerMessenger，在此可以理解成”信使“，通过Messenger方式返回Binder对象可以不用考虑Clinet - Service是否属于同一个进程的问题，并且，可以实现Client - Service之间的双向通信。极大方便了此类业务需求的实现。局限：不支持严格意义上的多线程并发处理，实际上是以队列去处理。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MyMessengerService extends Service &#123; public static final String TAG = "MyMessengerService"; public static final int MSG_FROM_CLIENT_TO_SERVER = 1; public static final int MSG_FROM_SERVER_TO_CLIENT = 2; private Messenger mClientMessenger; private Messenger mServerMessenger = new Messenger(new ServerHandler()); @Override public IBinder onBind(Intent intent) &#123; Log.w(TAG, "in onBind"); return mServerMessenger.getBinder(); &#125; class ServerHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; Log.w(TAG, "thread name:" + Thread.currentThread().getName()); switch (msg.what) &#123; case MSG_FROM_CLIENT_TO_SERVER: Log.w(TAG, "receive msg from client"); mClientMessenger = msg.replyTo; // service发送消息给client Message toClientMsg = Message.obtain(null, MSG_FROM_SERVER_TO_CLIENT); try &#123; Log.w(TAG, "server begin send msg to client"); mClientMessenger.send(toClientMsg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; break; default: super.handleMessage(msg); &#125; &#125; &#125; @Override public boolean onUnbind(Intent intent) &#123; Log.w(TAG, "in onUnbind"); return super.onUnbind(intent); &#125; @Override public void onDestroy() &#123; Log.w(TAG, "in onDestroy"); super.onDestroy(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114public class CActivity extends Activity &#123; public static final String TAG = "CActivity"; private Button bindServiceBtn; private Button unbindServiceBtn; private Button sendMsgToServerBtn; private ServiceConnection sc = new MyServiceConnection(); private boolean mBound; private Messenger mServerMessenger; private Handler mClientHandler = new MyClientHandler(); private Messenger mClientMessenger = new Messenger(mClientHandler); private class MyClientHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; if (msg.what == MyMessengerService.MSG_FROM_SERVER_TO_CLIENT) &#123; Log.w(TAG, "reveive msg from server"); &#125; &#125; &#125; private class MyServiceConnection implements ServiceConnection &#123; @Override public void onServiceConnected(ComponentName name, IBinder binder) &#123; Log.w(TAG, "in MyServiceConnection onServiceConnected"); mServerMessenger = new Messenger(binder); mBound = true; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; // This is called when the connection with the service has been // unexpectedly disconnected -- that is, its process crashed. Log.w(TAG, "in MyServiceConnection onServiceDisconnected"); mBound = false; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.c); bindServiceBtn = (Button) findViewById(R.id.bind_service); unbindServiceBtn = (Button) findViewById(R.id.unbind_service); sendMsgToServerBtn = (Button) findViewById(R.id.send_msg_to_server); bindServiceBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(CActivity.this, MyMessengerService.class); bindService(intent, sc, Context.BIND_AUTO_CREATE); &#125; &#125;); unbindServiceBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; excuteUnbindService(); &#125; &#125;); sendMsgToServerBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; sayHello(); &#125; &#125;); new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; Intent intent = new Intent(CActivity.this, MyAlarmBroadcastReceiver.class); sendBroadcast(intent); &#125; &#125;, 3 * 1000); &#125; public void sayHello() &#123; if (!mBound) return; // Create and send a message to the service, using a supported 'what' value Message msg = Message.obtain(null, MyMessengerService.MSG_FROM_CLIENT_TO_SERVER, 0, 0); // 通过replyTo把client端的Messenger(信使)传递给service msg.replyTo = mClientMessenger; try &#123; mServerMessenger.send(msg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; private void excuteUnbindService() &#123; if (mBound) &#123; unbindService(sc); mBound = false; &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); Log.w(TAG, "in onDestroy"); excuteUnbindService(); &#125;&#125; 其中，需要注意的几点是：1.MyMessengerService自定中，通过new Messenger(new ServerHandler())创建Messenger对象，在onBind(..)回调中，通过调用Messenger对象的getBinder()方法，将Binder返回；2.Client在ServiceConnection的onServiceConnected(..)的回调中，通过new Messenger(binder)获取到Service传递过来的mServerMessenger；3.接下来，就可以通过mServerMessenger.send(msg)方法向Service发送message，Service中的Messenger构造器中的Handler即可接收到此信息，在handleMessage(..)回调中处理；4.至此只是完成了从Client发送消息到Service，同样的道理，想实现Service发送消息到Client，可以在客户端定义一个Handler，并得到相应的Messenger，在Clinet发送消息给Service时，通过msg.replyTo = mClientMessenger方式将Client信使传递给Service；5.Service接收到Client信使后，获取此信使，并通过mClientMessenger.send(toClientMsg)方式将Service消息发送给Client。 至此，完成了Client - Service之间的双向通信流程。 3）AIDL（Android Interface Definition Language）一般情况下，Messenger这种方式都是可以满足需求的，当然，通过自定义AIDL方式相对更加灵活。这种方式需要自己在项目中自定义xxx.aidl文件，然后系统会自动在gen目录下生成相应的接口类文件，接下来整个的流程与Messenger方式差别不大，网上也有不少实例，在此不再具体给出。注：无论哪种方式的Bound Service，在进行unbind(..)操作时，都需要注意当前Service是否处于已经绑定状态，否则可能会因为当前Service已经解绑后继续执行unbind(..)会导致崩溃。这点与Started Service区别很大（如前文所述：stopService(..)无需做当前Service是否有效的判断）。 4、Local Service VS Remote ServiceLocal Service：不少人又称之为”本地服务“，是指Client - Service同处于一个进程；Remote Service：又称之为”远程服务“，一般是指Service处于单独的一个进程中。 5、Service特性1.Service本身都是运行在其所在进程的主线程（如果Service与Clinet同属于一个进程，则是运行于UI线程），但Service一般都是需要进行”长期“操作，所以经常写法是在自定义Service中处理”长期“操作时需要新建线程，以免阻塞UI线程或导致ANR；2.Service一旦创建，需要停止时都需要显示调用相应的方法（Started Service需要调用stopService(..)或Service本身调用stopSelf(..)， Bound Service需要调用unbindService(..)），否则对于Started Service将处于一直运行状态，对于Bound Service，当Client生命周期结束时也将因此问题。也就是说，Service执行完毕后，必须人为的去停止它 6、IntentServiceIntentService是系统提供给我们的一个已经继承自Service类的特殊类，IntentService特殊性是相对于Service本身的特性而言的：1.默认直接实现了onBind(..)方法，直接返回null，并定义了抽象方法onHandlerIntent(..)，用户自定义子类时，需要实现此方法；2.onHandlerIntent(..)主要就是用来处于相应的”长期“任务的，并且已经自动在新的线程中，用户无需自定义新线程；3.当”长期“任务执行完毕后（也就是onHandlerIntent(..)执行完毕后），此IntentService将自动结束，无需人为调用方法使其结束；4.IntentService处于任务时，也是按照队列的方式一个个去处理，而非真正意义上的多线程并发方式。下面是一个基本的继承自IntentService的自定义Service：12345678910111213141516171819public class MyIntentService extends IntentService &#123; public static final String TAG = "MyIntentService"; public MyIntentService() &#123; super(TAG); &#125; public MyIntentService(String name) &#123; super(name); &#125; @Override protected void onHandleIntent(Intent intent) &#123; Log.w(TAG, "in onHandleIntent"); Log.w(TAG, "thread name:" + Thread.currentThread().getName()); &#125;&#125; 7、前台ServiceAndroid中Service接口中还提供了一个称之为”前台Service“的概念。通过Service.startForeground (int id, Notification notification)方法可以将此Service设置为前台Service。在UI显示上，notification将是一个处于onGoing状态的通知，使得前台Service拥有更高的进程优先级，并且Service可以直接notification通信。下面是一个简单的前台Service使用实例：123456789101112131415161718192021222324252627282930313233343536373839public class MyService extends Service &#123; public static final String TAG = "MyService"; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onCreate() &#123; super.onCreate(); Log.w(TAG, "in onCreate"); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.w(TAG, "in onStartCommand"); Log.w(TAG, "MyService:" + this); String name = intent.getStringExtra("name"); Log.w(TAG, "name:" + name); Notification notification = new Notification(R.drawable.ic_launcher, "test", System.currentTimeMillis()); Intent notificationIntent = new Intent(this, DActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntesnt, 0); notification.setLatestEventInfo(this, "title", "content", pendingIntent); startForeground(1, notification); return START_REDELIVER_INTENT; &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.w(TAG, "in onDestroy"); &#125;&#125;]]></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[08 Service通信]]></title>
    <url>%2F2017%2F05%2F26%2FANDROID%2FBASE%2F08Service%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[一、应用内通信1、启动Service并传递数据启动一个Service并且向该Service传递数据:123Intent intent = new Intent(this, MyService.class);intent.putExtra("data", mEditText.getText().toString().trim());startService(intent); MyService接收数据：1234567private String data = "MyService default info";@Overridepublic int onStartCommand(Intent intent, int flags, int startId) &#123; data = intent.getStringExtra("data"); return super.onStartCommand(intent, flags, startId);&#125; 2、绑定Service进行通信——&gt;与被绑定的Service进行通信，首先自定义一个Binder的实现类，拥有setData(String data)方法，并在onBind方法中返回自定义类的对象：1234567891011121314151617public class MyService extends Service &#123; private String data = "MyService default info"; @Override public IBinder onBind(Intent intent) &#123; return new MyBinder(); &#125; public class MyBinder extends Binder &#123; public void setData(String data) &#123; MyService.this.data = data; &#125; &#125; ...&#125; 在ServiceConnection实现类中onServiceConnected方法里获取服务绑定成功时返回的对象1234567891011public class MainActivity extends AppCompatActivity implements View.OnClickListener, ServiceConnection &#123; private MyService.MyBinder mMyBinder; ... @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mMyBinder = (MyService.MyBinder) service; &#125;&#125; 然后MainActivity就可以实时的想MyService同步数据了：12if (mMyBinder != null) mMyBinder.setData(mEditText.getText().toString().trim()); 输出日志123456789I/System.out: MyService onCreateI/System.out: MyService default infoI/System.out: MyService default infoI/System.out: MyService default infoI/System.out: MyService default infoI/System.out: MainActivity say somethingI/System.out: MainActivity say somethingI/System.out: MainActivity say somethingI/System.out: MyService onDestroy 3、绑定Service进行通信&lt;——侦听被绑定的Service的内部状态，需要借助回调接口。首先定义回调接口并设置set(callBack)方法：1234567891011121314public class MyService extends Service &#123; private CallBack mCallBack; public void setCallBack(CallBack callBack) &#123; mCallBack = callBack; &#125; public static interface CallBack &#123; public void onDataChange(String data); &#125; ...&#125; 自定义类MyBinder中增加一个方法，返回当前Service的对象，以便于外部客户端调用set(callBack)方法12345678public class MyBinder extends Binder &#123; ... public MyService getService() &#123; return MyService.this; &#125;&#125; 在Service中将状态信息通过回调接口通知外界123i++;if (mCallBack != null) mCallBack.onDataChange(i + " " + data); ServiceConnection的实现类（此处为MainActivity）在onServiceConnected方法中获取Service对象，并将自定义的回调接口告知Service：1234567891011121314@Overridepublic void onServiceConnected(ComponentName name, IBinder service) &#123; mMyBinder = (MyService.MyBinder) service; mMyBinder.getService().setCallBack(new MyService.CallBack() &#123; @Override public void onDataChange(String data) &#123; Message msg = new Message(); Bundle bundle = new Bundle(); bundle.putString("data", data); msg.setData(bundle); mHandler.sendMessage(msg); &#125; &#125;);&#125; 借助Handler，将数据同步到TextView上：1234567private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); mTextView.setText(msg.getData().getString("data")); &#125;&#125;; 二、跨应用通信——AIDL1、跨应用启动Service从Android5.0以后，只能通过显示Intent来启动服务。123456789101112131415161718192021package com.xianxiaotao.firstapp;public class MainActivity extends AppCompatActivity &#123; private Intent mIntent; @Override protected void onCreate(Bundle savedInstanceState) &#123; ... mIntent = new Intent(); mIntent.setComponent(new ComponentName("com.xianxiaotao.secondapp", "com.xianxiaotao.secondapp.AppService")); startService(mIntent) &#125; @Override protected void onDestroy() &#123; super.onDestroy(); stopService(mIntent); &#125;&#125; 2、跨应用绑定Service新建AIDL文件：New -&gt; AIDL -&gt; AIDL File -&gt; IAppServiceRemoteBinder.aidl12345package com.xianxiaotao.secondapp;interface IAppServiceRemoteBinder &#123; void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString);&#125; 在Service里实现该接口：12345678910111213141516package com.xianxiaotao.secondapp;public class AppService extends Service &#123; ... @Override public IBinder onBind(Intent intent) &#123; return new IAppServiceRemoteBinder.Stub() &#123; @Override public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) &#123; // TODO &#125; &#125;; &#125;&#125; 在第一个应用中绑定服务和解除绑定服务：12bindService(mIntent, this, Context.BIND_AUTO_CREATE);unbindService(this); 3、跨应用绑定Service并通信在IAppServiceRemoteBinder接口中新增setData方法1234interface IAppServiceRemoteBinder &#123; void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString); void setData(String data);&#125; 其子类需要实现该方法12345678910111213@Overridepublic IBinder onBind(Intent intent) &#123; return new IAppServiceRemoteBinder.Stub() &#123; @Override public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) &#123; // TODO &#125; @Override public void setData(String data) throws RemoteException &#123; AppService.this.data = data; &#125; &#125;;&#125; 在第一个应用里创同样的IAppServiceRemoteBinder.aidl文件，注意包名也要一致。 firstApp -&gt; New -&gt; Folder -&gt; AIDL Folder aidl -&gt; New -&gt; Package -&gt; com.xianxiaotao.secondapp -&gt; OK 在该文件夹里创建同样的IAppServiceRemoteBinder.aidl文件，测试时可以直接复制粘贴。上述操作执行完毕后，该应用绑定secondapp的AppService时，可以获取到IBinder的实例了。1234567891011121314151617private IAppServiceRemoteBinder binder = null;@Overridepublic void onServiceConnected(ComponentName name, IBinder service) &#123; // 此处不能用强制类型转换，虽然类名相同，但两个类在内存中地址不一样 binder = IAppServiceRemoteBinder.Stub.asInterface(service);&#125;...if (binder != null) &#123; try &#123; binder.setData(mEditText.getText().toString().trim()); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125;&#125;]]></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07 Service]]></title>
    <url>%2F2017%2F05%2F26%2FANDROID%2FBASE%2F07Service%2F</url>
    <content type="text"><![CDATA[一、初识Service1、启动Service和停止Service12startService(new Intent(MainActivity.this, MyService.class)); // 启动服务stopService(new Intent(MainActivity.this, MyService.class)); // 停止服务 服务在系统中最多只有一个实例，即使上述代码中创建了两个不同的Intent实例，但是启动和停止的服务是同一个。只创建一个Intent实例也是可以的，如下所示：1234567private Intent mIntent;...mIntent = new Intent(MainActivity.this, MyService.class);...startService(mIntent);...stopService(mIntent); Service代码：12345678910111213141516171819202122232425262728293031323334package com.xianxiaotao.learnservice;import android.app.Service;import android.content.Intent;import android.os.IBinder;public class MyService extends Service &#123; public MyService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; System.out.println("MyService onBind"); return new Binder(); &#125; @Override public void onCreate() &#123; super.onCreate(); System.out.println("MyService onCreate"); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; System.out.println("MyService onStartCommand"); return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); System.out.println("MyService onDestroy"); &#125;&#125; 2、绑定Service和解除绑定服务API:12345678// 绑定服务的APIpublic boolean bindService(Intent service, ServiceConnection conn, int flags) &#123; return mBase.bindService(service, conn, flags);&#125;// 解除绑定服务的APIpublic void unbindService(ServiceConnection conn) &#123; mBase.unbindService(conn);&#125; 实现接口ServiceConnection：12345678910111213141516public class MainActivity extends AppCompatActivity implements ServiceConnection &#123; private Intent mIntent; ... @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; System.out.println("Service Connected"); // 服务被成功绑定之后执行 &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; System.out.println("Service Disconnected"); // 服务所在的进程崩溃时或者被kill时执行 &#125;&#125; 绑定Service和解除绑定Service：12bindService(mIntent, MainActivity.this, Context.BIND_AUTO_CREATE);unbindService(MainActivity.this); 二、Service生命周期1、启动服务生命周期第一次启动服务日志如下：12I/System.out: MyService onCreateI/System.out: MyService onStartCommand 第二、三次启动服务日志：12I/System.out: MyService onStartCommandI/System.out: MyService onStartCommand 接着停止服务日志：1I/System.out: MyService onDestroy 2、启动服务后并退出启动服务后并退出当前程序的日志：12I/System.out: MyService onCreateI/System.out: MyService onStartCommand 重新启动应用并停止服务：1I/System.out: MyService onDestroy 3、绑定服务生命周期第一次绑定服务日志：123I/System.out: MyService onCreateI/System.out: MyService onBindI/System.out: Service Connected 第二、三次绑定服务无任何日志输出解除绑定服务日志：1I/System.out: MyService onDestroy 4、绑定服务并退出成功绑定服务后并退出当前程序的日志：123456789101112131415161718192021I/System.out: MyService onCreateI/System.out: MyService onBindI/System.out: Service ConnectedE/ActivityThread: Activity com.xianxiaotao.learnservice.MainActivity has leaked ServiceConnection com.xianxiaotao.learnservice.MainActivity@f45fa7c that was originally bound here android.app.ServiceConnectionLeaked: Activity com.xianxiaotao.learnservice.MainActivity has leaked ServiceConnection com.xianxiaotao.learnservice.MainActivity@f45fa7c that was originally bound here at android.app.LoadedApk$ServiceDispatcher.&lt;init&gt;(LoadedApk.java:1336) at android.app.LoadedApk.getServiceDispatcher(LoadedApk.java:1231) at android.app.ContextImpl.bindServiceCommon(ContextImpl.java:1450) at android.app.ContextImpl.bindService(ContextImpl.java:1422) at android.content.ContextWrapper.bindService(ContextWrapper.java:636) at com.xianxiaotao.learnservice.MainActivity$3.onClick(MainActivity.java:39) at android.view.View.performClick(View.java:5637) at android.view.View$PerformClick.run(View.java:22429) at android.os.Handler.handleCallback(Handler.java:751) at android.os.Handler.dispatchMessage(Handler.java:95) at android.os.Looper.loop(Looper.java:154) at android.app.ActivityThread.main(ActivityThread.java:6121) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:889) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:779)I/System.out: MyService onDestroy 如果绑定服务后，请确保在异常情况下解除绑定服务。比如在Activity的onDestroy方法中解除绑定服务。 5、启动服务后绑定服务启动服务：12I/System.out: MyService onCreateI/System.out: MyService onStartCommand 绑定服务：12I/System.out: MyService onBindI/System.out: Service Connected 解除绑定服务：无日志停止服务：1I/System.out: MyService onDestroy 总结： 启动服务后可以通过调用stopService()方法停止服务(也可以由其他应用程序调用、或者服务自身调用stopSelf()来停止服务）。 只有第一次启动服务时，系统会调用Service的onCreate和onStartCommand方法，其他只会调用onStartCommand方法。 绑定服务时，系统会调用Service的onCreate、onBind方法，以及ServiceConnection实现类的onServiceConnected方法。 如果绑定了服务，请在停止服务前或退出程序前必须解除服务绑定。]]></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06 Context]]></title>
    <url>%2F2017%2F05%2F24%2FANDROID%2FBASE%2F06Context%2F</url>
    <content type="text"><![CDATA[本文参考阅读：Context都没弄明白，还怎么做Android开发？ Activity mActivity = new Activity();作为Android开发者，不知道你有没有思考过这个问题，Activity可以new吗？Android的应用程序开发采用JAVA语言，Activity本质上也是一个对象，那上面的写法有什么问题呢？估计很多人说不清道不明。Android程序不像Java程序一样，随便创建一个类，写个main()方法就能运行，Android应用模型是基于组件的应用设计模式，组件的运行要有一个完整的Android工程环境，在这个环境下，Activity、Service等系统组件才能够正常工作，而这些组件并不能采用普通的Java对象创建方式，new一下就能创建实例了，而是要有它们各自的上下文环境，也就是我们这里讨论的Context。可以这样讲，Context是维持Android程序中各组件能够正常工作的一个核心功能类。 Context到底是什么Context的中文翻译为：语境; 上下文; 背景; 环境，在开发中我们经常说称之为“上下文”，那么这个“上下文”到底是指什么意思呢？在语文中，我们可以理解为语境，在程序中，我们可以理解为当前对象在程序中所处的一个环境，一个与系统交互的过程。比如微信聊天，此时的“环境”是指聊天的界面以及相关的数据请求与传输，Context在加载资源、启动Activity、获取系统服务、创建View等操作都要参与。 那Context到底是什么呢？一个Activity就是一个Context，一个Service也是一个Context。Android程序员把“场景”抽象为Context类，他们认为用户和操作系统的每一次交互都是一个场景，比如打电话、发短信，这些都是一个有界面的场景，还有一些没有界面的场景，比如后台运行的服务（Service）。一个应用程序可以认为是一个工作环境，用户在这个环境中会切换到不同的场景，这就像一个前台秘书，她可能需要接待客人，可能要打印文件，还可能要接听客户电话，而这些就称之为不同的场景，前台秘书可以称之为一个应用程序。 如何生动形象的理解Context上面的概念中采用了通俗的理解方式，将Context理解为“上下文”或者“场景”，如果你仍然觉得很抽象，不好理解。在这里我给出一个可能不是很恰当的比喻，希望有助于大家的理解：一个Android应用程序，可以理解为一部电影或者一部电视剧，Activity，Service，Broadcast Receiver，Content Provider这四大组件就好比是这部戏里的四个主角：胡歌，霍建华，诗诗，Baby。他们是由剧组（系统）一开始就定好了的，整部戏就是由这四位主演领衔担纲的，所以这四位主角并不是大街上随随便便拉个人（new 一个对象）都能演的。有了演员当然也得有摄像机拍摄啊，他们必须通过镜头（Context）才能将戏传递给观众，这也就正对应说四大组件（四位主角）必须工作在Context环境下（摄像机镜头）。那Button，TextView，LinearLayout这些控件呢，就好比是这部戏里的配角或者说群众演员，他们显然没有这么重用，随便一个路人甲路人乙都能演（可以new一个对象），但是他们也必须要面对镜头（工作在Context环境下），所以Button mButton=new Button（Context）是可以的。虽然不很恰当，但还是很容易理解的，希望有帮助。 源码中的Context123456789101112131415161718/** * Interface to global information about an application environment. This is * an abstract class whose implementation is provided by * the Android system. It * allows access to application-specific resources and classes, as well as * up-calls for application-level operations such as launching activities, * broadcasting and receiving intents, etc. */public abstract class Context &#123; /** * File creation mode: the default mode, where the created file can only * be accessed by the calling application (or all applications sharing the * same user ID). */ public static final int MODE_PRIVATE = 0x0000; ...&#125; 源码中的注释是这么来解释Context的：Context提供了关于应用环境全局信息的接口。它是一个抽象类，它的执行被Android系统所提供。它允许获取以应用为特征的资源和类型，是一个统领一些资源（应用程序环境变量等）的上下文。就是说，它描述一个应用程序环境的信息（即上下文）；是一个抽象类，Android提供了该抽象类的具体实现类；通过它我们可以获取应用程序的资源和类（包括应用级别操作，如启动Activity，发广播，接受Intent等）。既然上面Context是一个抽象类，那么肯定有他的实现类咯，我们在Context的源码中通过IDE可以查看到他的子类最终可以得到如下关系图：Context类本身是一个纯abstract类，它有两个具体的实现子类：ContextImpl和ContextWrapper。其中ContextWrapper类，如其名所言，这只是一个包装而已，ContextWrapper构造函数中必须包含一个真正的Context引用，同时ContextWrapper中提供了attachBaseContext（）用于给ContextWrapper对象中指定真正的Context对象，调用ContextWrapper的方法都会被转向其所包含的真正的Context对象。ContextThemeWrapper类，如其名所言，其内部包含了与主题（Theme）相关的接口，这里所说的主题就是指在AndroidManifest.xml中通过android：theme为Application元素或者Activity元素指定的主题。当然，只有Activity才需要主题，Service是不需要主题的，因为Service是没有界面的后台场景，所以Service直接继承于ContextWrapper，Application同理。而ContextImpl类则真正实现了Context中的所以函数，应用程序中所调用的各种Context类的方法，其实现均来自于该类。一句话总结：Context的两个子类分工明确，其中ContextImpl是Context的具体实现类，ContextWrapper是Context的包装类。Activity，Application，Service虽都继承自ContextWrapper（Activity继承自ContextWrapper的子类ContextThemeWrapper），但它们初始化的过程中都会创建ContextImpl对象，由ContextImpl实现Context中的方法。 一个应用程序有几个Context其实这个问题本身并没有什么意义，关键还是在于对Context的理解，从上面的关系图我们已经可以得出答案了，在应用程序中Context的具体实现子类就是：Activity，Service，Application。那么Context数量=Activity数量+Service数量+应用进程数量(一般为1)。当然如果你足够细心，可能会有疑问：我们常说四大组件，这里怎么只有Activity，Service持有Context，那Broadcast Receiver，Content Provider呢？Broadcast Receiver，Content Provider并不是Context的子类，他们所持有的Context都是其他地方传过去的，所以并不计入Context总数。上面的关系图也从另外一个侧面告诉我们Context类在整个Android系统中的地位是多么的崇高，因为很显然Activity，Service，Application都是其子类，其地位和作用不言而喻。 Context能干什么Context到底可以实现哪些功能呢？这个就实在是太多了，弹出Toast、启动Activity、启动Service、发送广播、操作数据库等等都需要用到Context。12345678TextView tv = new TextView(getContext());ListAdapter adapter = new SimpleCursorAdapter(getApplicationContext(), ...);AudioManager am = (AudioManager) getContext().getSystemService(Context.AUDIO_SERVICE);getApplicationContext().getSharedPreferences(name, mode);getApplicationContext().getContentResolver().query(uri, ...);getContext().getResources().getDisplayMetrics().widthPixels * 5 / 8;getContext().startActivity(intent);getContext().startService(intent);getContext().sendBroadcast(intent); Context作用域虽然Context神通广大，但并不是随便拿到一个Context实例就可以为所欲为，它的使用还是有一些规则限制的。由于Context的具体实例是由ContextImpl类去实现的，因此在绝大多数场景下，Activity、Service和Application这三种类型的Context都是可以通用的。不过有几种场景比较特殊，比如启动Activity，还有弹出Dialog。出于安全原因的考虑，Android是不允许Activity或Dialog凭空出现的，一个Activity的启动必须要建立在另一个Activity的基础之上，也就是以此形成的返回栈。而Dialog则必须在一个Activity上面弹出（除非是System Alert类型的Dialog），因此在这种场景下，我们只能使用Activity类型的Context，否则将会出错。从上图我们可以发现Activity所持有的Context的作用域最广，无所不能。因为Activity继承自ContextThemeWrapper，而Application和Service继承自ContextWrapper，很显然ContextThemeWrapper在ContextWrapper的基础上又做了一些操作使得Activity变得更强大，这里我就不再贴源码给大家分析了，有兴趣的童鞋可以自己查查源码。上图中的YES和NO我也不再做过多的解释了，这里我说一下上图中Application和Service所不推荐的两种使用情况。1：如果我们用ApplicationContext去启动一个LaunchMode为standard的Activity的时候会报错android.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?这是因为非Activity类型的Context并没有所谓的任务栈，所以待启动的Activity就找不到栈了。解决这个问题的方法就是为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候就为它创建一个新的任务栈，而此时Activity是以singleTask模式启动的。所有这种用Application启动Activity的方式不推荐使用，Service同Application。2：在Application和Service中去layout inflate也是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。所以这种方式也不推荐使用。一句话总结：凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。 如何获取Context通常我们想要获取Context对象，主要有以下四种方法1：View.getContext,返回当前View对象的Context对象，通常是当前正在展示的Activity对象。2：Activity.getApplicationContext,获取当前Activity所在的(应用)进程的Context对象，通常我们使用Context对象时，要优先考虑这个全局的进程Context。3：ContextWrapper.getBaseContext():用来获取一个ContextWrapper进行装饰之前的Context，可以使用这个方法，这个方法在实际开发中使用并不多，也不建议使用。4：Activity.this 返回当前的Activity实例，如果是UI控件需要使用Activity作为Context对象，但是默认的Toast实际上使用ApplicationContext也可以。 getApplication()和getApplicationContext()上面说到获取当前Application对象用getApplicationContext，不知道你有没有联想到getApplication()，这两个方法有什么区别？相信这个问题会难倒不少开发者。程序是不会骗人的，我们通过上面的代码，打印得出两者的内存地址都是相同的，看来它们是同一个对象。其实这个结果也很好理解，因为前面已经说过了，Application本身就是一个Context，所以这里获取getApplicationContext()得到的结果就是Application本身的实例。那么问题来了，既然这两个方法得到的结果都是相同的，那么Android为什么要提供两个功能重复的方法呢？实际上这两个方法在作用域上有比较大的区别。getApplication()方法的语义性非常强，一看就知道是用来获取Application实例的，但是这个方法只有在Activity和Service中才能调用的到。那么也许在绝大多数情况下我们都是在Activity或者Service中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助getApplicationContext()方法了。1234567public class MyReceiver extends BroadcastReceiver&#123; @Override publicvoidonReceive(Contextcontext,Intentintent)&#123; ApplicationmyApp=(Application)context.getApplicationContext(); &#125;&#125; Context引起的内存泄露但Context并不能随便乱用，用的不好有可能会引起内存泄露的问题，下面就示例两种错误的引用方式。 错误的单例模式:123456789101112131415public class Singleton &#123; private static Singleton instance; private Context mContext; private Singleton(Context context) &#123; this.mContext = context; &#125; public static Singleton getInstance(Context context) &#123; if (instance == null) &#123; instance = new Singleton(context); &#125; return instance; &#125;&#125; 这是一个非线程安全的单例模式，instance作为静态对象，其生命周期要长于普通的对象，其中也包含Activity，假如Activity A去getInstance获得instance对象，传入this，常驻内存的Singleton保存了你传入的Activity A对象，并一直持有，即使Activity被销毁掉，但因为它的引用还存在于一个Singleton中，就不可能被GC掉，这样就导致了内存泄漏。 View持有Activity引用:123456789101112public class MainActivity extends Activity &#123; private static Drawable mDrawable; @Override protected void onCreate(Bundle saveInstanceState) &#123; super.onCreate(saveInstanceState); setContentView(R.layout.activity_main); ImageView iv = new ImageView(this); mDrawable = getResources().getDrawable(R.drawable.ic_launcher); iv.setImageDrawable(mDrawable); &#125;&#125; 有一个静态的Drawable对象当ImageView设置这个Drawable时，ImageView保存了mDrawable的引用，而ImageView传入的this是MainActivity的mContext，因为被static修饰的mDrawable是常驻内存的，MainActivity是它的间接引用，MainActivity被销毁时，也不能被GC掉，所以造成内存泄漏。 正确使用Context一般Context造成的内存泄漏，几乎都是当Context销毁的时候，却因为被引用导致销毁失败，而Application的Context对象可以理解为随着进程存在的，所以我们总结出使用Context的正确姿势：1：当Application的Context能搞定的情况下，并且生命周期长的对象，优先使用Application的Context。2：不要让生命周期长于Activity的对象持有到Activity的引用。3：尽量不要在Activity中使用非静态内部类，因为非静态内部类会隐式持有外部类实例的引用，如果使用静态内部类，将外部实例引用作为弱引用持有。 总结总之Context在Android系统中的地位很重要，它几乎无所不能，但它也不是你想用就能随便用的，谨防使用不当引起的内存问题。]]></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05 Intent概念及应用]]></title>
    <url>%2F2017%2F05%2F24%2FANDROID%2FBASE%2F05Intent%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[启动Activity分为两种，显示调用和隐式调用。显示调用通过指定Intent组件名称来实现的，它一般用在知道目标组件名称的前提下，一般是在相同的应用程序内部实现的。隐式调用通过Intent Filter来实现的，它一般用在没有明确指出目标组件名称的前提下，一般是用于在不同应用程序之间。 显示调用123Intent intent=new Intent(MainActivity.this,SettingActivity.class);intent.putExtra(EXTRA,contentEditText.getText().toString());startActivity(intent); 而Manifest文件描述为：1234567&lt;activity android:name=".MainActivity" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".SettingActivity" /&gt; 隐式调用隐式不明确指定启动哪个Activity，而是在Intent Filter中设置Action、Data、Category，让系统来筛选出合适的Activity。清单文件配置如下：12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.king.bester.myapplication"&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".TargetActivity" android:launchMode="singleTask" android:taskAffinity="com.king.bester.myapplication" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.SEND"/&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;data android:mimeType="text/plain"/&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name="com.king.bester.demo" /&gt; &lt;action android:name="com.king.bester.DEMO" /&gt; &lt;category android:name="com.king.bester.a" /&gt; &lt;category android:name="com.king.bester.b" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;data android:mimeType="text/plain"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 代码调用：12345678910111213141516// 匹配第一组intent-filterpublic void startA(View view) &#123; Intent intent = new Intent(); intent.setAction("android.intent.action.SEND"); intent.setType("text/plain"); startActivity(intent);&#125;// 匹配第二组intent-filterpublic void startB(View view) &#123; Intent intent = new Intent(); intent.setAction("com.king.bester.demo"); intent.addCategory("com.king.bester.a"); intent.setType("text/plain"); startActivity(intent);&#125; 1、startA()中没有设置category，是因为系统在调用startActivity或者startActivityForResult的时候会默认为Intent加上“android.intent.category.DEFAULT”这个category。所以，为了我们的Activity能接收隐式调用，必须在intent-filter中指定这个category。2、action区分大小写3、一个Activity可以有多个intent-filter，一个intent只要能匹配任何一组intent-filter即可启动对应的Activity。 浏览器启动本地AppIntent的过滤器：123456&lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW"/&gt; &lt;category android:name="android.intent.category.BROWSABLE"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;data android:scheme="app"/&gt;&lt;/intent-filter&gt; 网页链接：1&lt;a href="app://hello"&gt;Launch My App&lt;/a&gt; 代码获取网页传递过来的参数：12Uri uri = getIntent().getData();System.out.println(uri); 输出：1app://hello]]></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04 Activity启动模式]]></title>
    <url>%2F2017%2F05%2F23%2FANDROID%2FBASE%2F04Activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[ActivityManagerService（AMS）内部维护着一个ActivityStack栈，系统会将Activity实例一一放入栈内（先进后出），默认情况下创建一个实例压入栈内。如果多次创建同一个Activity，栈内将压入多个实例。为此，Android提供了启动模式来修改系统的默认行为。目前有四种启动模式：standard、singleTop、singleTask和singleInstance。 一、代码BaseActivity:123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.xianxiaotao.launchmode;import android.content.Intent;import android.content.pm.ActivityInfo;import android.content.pm.PackageManager;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.Log;/** * Created by xianxiaotao on 17/5/23. * * 基类：输出Activity实例信息及所属任务栈信息 */public class BaseActivity extends AppCompatActivity &#123; private static final String TAG = "Xian Xiaotao"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 区别类名，区别同类名是否同实例，区别任务栈 Log.i(TAG, "onCreate：" + getClass().getSimpleName() + " hasCode:" + this.hashCode() + " TaskId: " + getTaskId()); // 任务栈名称，默认为包名相关 dumpTaskAffinity(); &#125; @Override protected void onNewIntent(Intent intent) &#123; super.onNewIntent(intent); Log.i(TAG, "onNewIntent：" + getClass().getSimpleName() + " hasCode:" + this.hashCode() + " TaskId: " + getTaskId()); dumpTaskAffinity(); &#125; protected void dumpTaskAffinity()&#123; try &#123; ActivityInfo info = this.getPackageManager().getActivityInfo(getComponentName(), PackageManager.GET_META_DATA); Log.i(TAG, "taskAffinity:" + info.taskAffinity); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; MainActivity:1234567891011121314151617181920212223242526272829package com.xianxiaotao.launchmode;import android.content.Intent;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;public class MainActivity extends BaseActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.startMainButton).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startActivity(new Intent(MainActivity.this, MainActivity.class)); &#125; &#125;); findViewById(R.id.startOtherButton).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startActivity(new Intent(MainActivity.this, OtherActivity.class)); &#125; &#125;); &#125;&#125; OtherActivity:12345678910111213141516171819202122232425262728package com.xianxiaotao.launchmode;import android.content.Intent;import android.os.Bundle;import android.view.View;public class OtherActivity extends BaseActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_other); findViewById(R.id.startMainButton).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startActivity(new Intent(OtherActivity.this, MainActivity.class)); &#125; &#125;); findViewById(R.id.startOtherButton).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startActivity(new Intent(OtherActivity.this, OtherActivity.class)); &#125; &#125;); &#125;&#125; 布局文件activity_main.xml，activity_other.xml文件与此类似123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/activity_main" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="This is main activity"/&gt; &lt;Button android:id="@+id/startMainButton" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textAllCaps="false" android:text="Start Main Activity"/&gt; &lt;Button android:id="@+id/startOtherButton" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textAllCaps="false" android:text="Start Other Activity"/&gt;&lt;/LinearLayout&gt; 二、测试1、standard两个Activity都没有设置启动模式，即默认为标准模式。然后启动App，点击Start Main Activity按钮，然后再点击Start Other Activity按钮，然后再点击Start Main Activity。日志输出如下：12345678I/Xian Xiaotao: onCreate：MainActivity hasCode:110059330 TaskId: 523I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmodeI/Xian Xiaotao: onCreate：MainActivity hasCode:250944109 TaskId: 523I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmodeI/Xian Xiaotao: onCreate：OtherActivity hasCode:39080781 TaskId: 523I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmodeI/Xian Xiaotao: onCreate：MainActivity hasCode:42988356 TaskId: 523I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmode 上述日志中所有的hashCode都不相同，即每次启动Activity都创建一个新的实例。连续按四次返回键退出应用。TaskId都相同，表明这些实例都在同一个任务栈里。 2、singleTop在AndroidMainfest.xml文件中，为MainActivity添加属性：android:launchMode=”singleTop”。启动App、点击Start Main Activity按钮、再点击Start Other Activity按钮，再点击Start Main Activity。日志输出如下：12345678I/Xian Xiaotao: onCreate：MainActivity hasCode:29797800 TaskId: 525I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmodeI/Xian Xiaotao: onNewIntent：MainActivity hasCode:29797800 TaskId: 525I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmodeI/Xian Xiaotao: onCreate：OtherActivity hasCode:42572600 TaskId: 525I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmodeI/Xian Xiaotao: onCreate：MainActivity hasCode:97104763 TaskId: 525I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmode 第一次点击Start Main Activity按钮时，调用了onNewIntent方法，且hashCode与之前的MainActivity实例的hashCode相同，即复用实例而不是重新创建。第二次点击Start Main Activity按钮时，也就是说从OtherActivity里启动MainActivity，此时调用了onCreate方法，而且hashCode与之前的不相同，即重新创建了MainActivity的实例。连续按三次返回键退出应用。TaskId都相同，表明这些实例都在同一个任务栈里。 3、singleTask将MainActivity设置为singleTop，然后执行之前相同的动作。日志输出如下：12345678I/Xian Xiaotao: onCreate：MainActivity hasCode:29797800 TaskId: 527I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmodeI/Xian Xiaotao: onNewIntent：MainActivity hasCode:29797800 TaskId: 527I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmodeI/Xian Xiaotao: onCreate：OtherActivity hasCode:121783201 TaskId: 527I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmodeI/Xian Xiaotao: onNewIntent：MainActivity hasCode:29797800 TaskId: 527I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmode 此时发现MainActivity的实例都相同，即第一次创建后，后面的都是复用实例而不是重新创建。按一次返回键退出应用。TaskId都相同，表明这些实例都在同一个任务栈里。 4、singleInstance将MainActivity设置为singleInstance，然后执行之前相同的动作。日志输出如下：I/Xian Xiaotao: onCreate：MainActivity hasCode:29797800 TaskId: 529I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmodeI/Xian Xiaotao: onNewIntent：MainActivity hasCode:29797800 TaskId: 529I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmodeI/Xian Xiaotao: onCreate：OtherActivity hasCode:42572600 TaskId: 530I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmodeI/Xian Xiaotao: onNewIntent：MainActivity hasCode:29797800 TaskId: 529I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmode此时发现MainActivity的实例依然相同，即第一次创建后，后面的都是复用实例而不是重新创建。按两次返回键退出应用。TaskId不同，即MainActivity与OtherActivity不在一个Activity中。 读者可以通过多个Activity设置不同的启动模式进行复杂的测试。 三、结论standard标准模式，也是系统默认模式。每次启动一个Activity都会重新创建一个新的实例，不管这个实例是否已经存在。谁启动了这个Activity，那么这个Activity就运行在启动它的那个Activity所在的栈中。ABCBB singleTop栈顶复用模式。如果新Activity已经位于任务栈的栈顶，那么只调用它的onNewIntent方法实现复用，而不会创建新的实例。如果新的Activity的实例已存在但不是位于栈顶，仍然重新创建。假设目前栈内情况为ABCD（ABCD为四个Activity，A位于栈底），此时再次启动，如果D的启动模式为singleTop，那么栈内仍然是ABCD；如果D的启动模式为standard，D将被重新创建，栈内情况变为ABCDD。 singleTask栈内复用模式。在同一个栈内，它是单实例模式。在这种模式下，启动一个Activity A，系统首先会寻找是否存在A想要的任务栈，如果不存在，就重新创建一个任务栈，然后创建A的实例并压入栈内；如果存在所需的任务栈，这时要看A是否在栈中有实例存在，如果有，那么系统就会把A调到栈顶并调用它的onNewIntent方法，不存在就创建并压入栈中。1、目前任务栈栈S1(ABC)，此时Activity D以singleTask模式请求启动，其所需的任务栈为S2，由于S2和D的实例均不存在，所以系统先创建任务栈S2，然后再创建D的实例并将其放入栈S2中。2、另外一种情况，假设D所需的任务栈为S1，上述S1已存在，所以系统会直接创建D的实例并压入栈S1内。3、如果D所需的任务栈为S1，其中为ADBC，此时系统将D上面的Activity出栈，把D切换到栈顶并调用onNewIntent方法，最终S1栈内为AD。 singleInstance：该模式具备singleTask模式的所有特性外，与它的区别就是，这种模式下的Activity会单独占用一个Task栈，具有全局唯一性，即整个系统中就这么一个实例，由于栈内复用的特性，后续的请求均不会创建新的Activity实例，除非这个特殊的任务栈被销毁了。以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。 启动模式参考博客]]></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03 Activity之间传递参数]]></title>
    <url>%2F2017%2F05%2F23%2FANDROID%2FBASE%2F03Activity%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一、传递简单数据发送数据：123Intent intent = new Intent(MainActivity.this, OtherActivity.class);intent.putExtra("data", "data value");startActivity(intent); 接受数据：12String data = getIntent().getStringExtra("data");textView.setText(data); 优化代码：123456789101112131415161718192021222324252627282930313233343536// 传递参数public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void sendArgs(View view) &#123; Intent intent = OtherActivity.newIntent(this, "data value"); startActivity(intent); &#125;&#125;// 接受参数public class OtherActivity extends AppCompatActivity &#123; private static final String ARG = "data"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_other); TextView textView = (TextView) findViewById(R.id.tv); String data = getIntent().getStringExtra(ARG); textView.setText(data); &#125; // 解除参数名称"data"带来的依赖性 public static Intent newIntent(Context context, String data) &#123; Intent intent = new Intent(context, OtherActivity.class); intent.putExtra(ARG, data); return intent; &#125;&#125; 二、传递数据包Bundle发送数据包：123456Intent intent = new Intent(MainActivity.this, OtherActivity.class);Bundle bundle = new Bundle();bundle.putString("name", "xian xiaotao");bundle.putInt("age", 28);intent.putExtras(bundle);startActivity(intent); 接受数据包：12Bundle data = getIntent().getExtras();textView.setText(String.format(Locale.getDefault(), "name=%s,age=%d", data.getString("name"), data.getInt("age"))); 三、传递值对象实现Parcelable12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import android.os.Parcel;import android.os.Parcelable;public class User implements Parcelable &#123; private String mName; private int mAge; public User(String name, int age) &#123; mName = name; mAge = age; &#125; public String getName() &#123; return mName; &#125; public void setName(String name) &#123; mName = name; &#125; public int getAge() &#123; return mAge; &#125; public void setAge(int age) &#123; mAge = age; &#125; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; // 更复杂的数据借用Bundle dest.writeString(getName()); dest.writeInt(getAge()); &#125; public static final Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() &#123; @Override public User createFromParcel(Parcel source) &#123; return new User(source.readString(), source.readInt()); &#125; @Override public User[] newArray(int size) &#123; return new User[size]; &#125; &#125;;&#125; 传递参数：123Intent intent = new Intent(MainActivity.this, OtherActivity.class);intent.putExtra("user", new User("xian xiaotao", 28));startActivity(intent); 接收参数12User user = getIntent().getParcelableExtra("user");textView.setText(String.format(Locale.getDefault(), "name=%s,age=%d", user.getName(), user.getAge())); Serializable的作用是为了保存对象的属性到本地文件、数据库、网络流、rmi以方便数据传输，当然这种传输可以是程序内的也可以是两个程序间的。而Android的Parcelable的设计初衷是因为Serializable效率过慢，为了在程序内不同组件间以及不同Android程序间(AIDL)高效的传输数据而设计，这些数据仅在内存中存在，Parcelable是通过IBinder通信的消息的载体。Parcelable的性能比Serializable好，在内存开销方面较小，所以在内存间数据传输时推荐使用Parcelable，如activity间传输数据，而Serializable可将数据持久化方便保存，所以在需要保存或网络传输数据时选择Serializable，因为android不同版本Parcelable可能不同，所以不推荐使用Parcelable进行数据持久化 四、获取Activity返回参数12345678910111213141516171819202122public class QuizActivity extends AppCompatActivity &#123; private static final int REQUEST_CODE_CHEAT = 0; ... // startActivityForResult代码 Intent i = CheatActivity.newIntent(QuizActivity.this, answerIsTrue); startActivityForResult(i, REQUEST_CODE_CHEAT); @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (resultCode != Activity.RESULT_OK) return; if (requestCode == REQUEST_CODE_CHEAT) &#123; if (data == null) return; mIsCheater = CheatActivity.wasAnswerShown(data); &#125; &#125;&#125; 123456789101112131415public class CheatActivity extends AppCompatActivity &#123; private static final String EXTRA_ANSWER_SHOWN = "com.xxtking.geoquiz.CheatActivity.answer_shown"; ... private void setAnswerShownResult(boolean isAnswerShown) &#123; Intent data = new Intent(); data.putExtra(EXTRA_ANSWER_SHOWN, isAnswerShown); setResult(RESULT_OK, data); &#125; public static boolean wasAnswerShown(Intent result) &#123; return result.getBooleanExtra(EXTRA_ANSWER_SHOWN, false); &#125;&#125;]]></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02 Activity生命周期]]></title>
    <url>%2F2017%2F05%2F23%2FANDROID%2FBASE%2F02Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[整个生命周期来说，成对出现的。onCreate和onDestroy是成对的，代表着创建与销毁；onStart和onStop表示Activity对于程序是否可见（后台）；onResume和onPause表示Activity对于用户是否可见（前台）。 正常生命周期1、初次启动ActivityonCreate -&gt; onStart -&gt; onResume 2、界面显示时按了返回键onPause -&gt; onStop -&gt; onDestroy 3、界面显示时按了Home键onPause -&gt; onStop 4、Home键之后再次启动onRestart -&gt; onStart -&gt; onResume 5、界面显示时按了锁屏键及解锁锁屏：onPause -&gt; onStop解锁：onRestart -&gt; onStart -&gt; onResume 6、从A Activity启动 B ActivityA onPause -&gt; B onCreate -&gt; B onStart -&gt; B onResume -&gt; A onStop返回：B onPause -&gt; A onRestart -&gt; A onStart -&gt; A onResume -&gt; B onStop -&gt; B onDestroy 7、从A Activity启动 B Activity (android:theme=”@style/Base.Theme.AppCompat.Dialog”)A onPause -&gt; B onCreate -&gt; B onStart -&gt; B onResume返回：B onPause -&gt; A onResume -&gt; B onStop -&gt; B onDestroy 切换横竖屏幕targetSdkVersion 25，没有设置android:configChanges：1、竖屏切横屏：onConfigurationChanged() -&gt; onPause() -&gt; onSaveInstanceState() -&gt; onStop() -&gt; onDestroy() -&gt; onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume()2、横屏切竖屏：onConfigurationChanged() -&gt; onPause() -&gt; onSaveInstanceState() -&gt; onStop() -&gt; onDestroy() -&gt; onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume() 本人使用的是模拟器（minSdkVersion 16 / targetSdkVersion 25）测试，无论是否设置Activity的android:configChanges，或者属性值设为orientation或orientation|keyboardHidden，无论是竖屏切横屏还是横屏切竖屏，流程都如上所述，当android:configChanges=”orientation|keyboardHidden|screenSize”时，只会调用onConfigurationChanged()。经过查资料，android:targetSdkVersion这个属性会影响横竖屏切换的生命周期。详见xiaoQLud的博客 异常生命周期1、系统配置发生改变后，默认情况下Activity会被销毁然后重新创建，生命周期参考横竖屏切换。常用的系统配置只有local、orientation和keyboardHidden。2、资源内存不足导致低优先级的Activity被杀死，生命周期参考横竖屏切换。3、运行时发生了异常，程序直接崩溃。例如：12for (int i = 10; i &gt;= 0; i++) System.out.println(10 / i)]]></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01 环境搭建]]></title>
    <url>%2F2017%2F05%2F23%2FANDROID%2FBASE%2F01%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[一、JDK1、https://www.oracle.com/index.html2、Menu -&gt; Downloads -&gt; Java -&gt; All Java Downloads -&gt; Java SE Downloads3、http://www.oracle.com/technetwork/java/javase/downloads/index.html4、JDK DOWNLOAD 二、Mac平台搭建集成开发环境1、https://www.android.com/2、底部 -&gt; DEVELOPERS -&gt; App Developer Resources -&gt; DEVELOP3、获取Android Studio （https://developer.android.com/studio/index.html）4、下载 ANDROID STUDIO FOR MAC 三、Windows平台搭建1、在Windows平台上，按照Mac平台搭建环境的步骤进行下载即可 四、Linux平台搭建1、在Linux平台上，按照Mac平台搭建环境的步骤进行下载即可2、解压到opt目录下：sudo mv android-studio /opt/3、输入密码4、命令行：cd /opt/android-studio/bin/5、命令行：./studio.sh6、安装失败则需要下载解压JDK文件，与上述步骤雷同7、配置JDK路径：sudo nano /etc/profile8、文件末尾添加：export JDK_HOME=/opt/jdk1.8.0_409、退出保存并立即生效：source /etc/profile10、验证：echo $JDK_HOME11、重新安装：./studio.sh 大神的下载安装教程]]></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Note | 研发录之重构]]></title>
    <url>%2F2017%2F04%2F13%2FANDROID%2FNote%20%E7%A0%94%E5%8F%91%E5%BD%95%E4%B9%8B%E9%87%8D%E6%9E%84%2F</url>
    <content type="text"><![CDATA[一、重构项目结构Step 1. 自定义业务无关的基础类库 com.baselib.activity: 封装业务无关的公用逻辑，如后面的BaseActivity代码 com.baselib.cache: 缓存数据和图片的处理 com.baselib.net: 网络底层封装库 com.baselib.ui: 自定义控件 com.baselib.utils: 业务无关的公用方法 Step 2. 实际项目中类进行归类划分 com.myapp.activity: 所有的Activity，其他三大组件同样如此 com.myapp.adapter: 所有的适配器 com.myapp.entity: 实体类 com.myapp.db: SQLite相关的逻辑封装 com.myapp.engine: 业务相关的类 com.myapp.ui: 自定义控件 com.myapp.utils: 工具类 com.myapp.interfaces: 接口，以I作为开头 com.myapp.listener: 基于Listener的接口，命名以On作为开头 二、Activity 模板1. com.baselib.activity.BaseActivity123456789101112131415161718public abstract class BaseActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); initVariables(); initViews(savedInstanceState); loadData(); &#125; // 初始化变量，包括Intent带的数据和Activity内的变量 protected abstract void initVariables(); // 加载layout布局文件，初始化控件，为控件挂上事件方法 protected abstract void initViews(Bundle savedInstanceState); // 获取数据 protected abstract void loadData();&#125; 2. com.myapp.activity.LoginActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class LoginActivity extends BaseActivity &#123; private int loginTimes; private String strEmail; private EditText etPassword; private EditText etEmail; private Button btnLogin; @Override protected void initVariables() &#123; loginTimes = -1; Bundle bundle = getIntent().getExtras(); strEmail = bundle.getString(AppConstants.Email); &#125; protected void initViews(Bundle savedInstanceState) &#123; setContentView(R.layout.activity_login); etEmail = (EditText) findViewById(R.id.email); etEmail.setText(strEmail); etPassword = (EditText) findViewById(R.id.password); // 登录事件 btnLogin = (Button) findViewById(R.id.sign_in_button); btnLogin.setOnClickListener( new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; gotoLoginActivity(); &#125; &#125;); &#125; private void gotoLoginActivity() &#123; startActivity(new Intent(LoginActivity.this, PersonCenterActivity.class)); &#125; @Override protected void loadData() &#123; loadWeatherData(); loadCityData(); &#125; ...&#125; 三、Adapter 模板com.myapp.adapter.WeatherAdapter1234567891011121314151617181920212223242526272829303132333435363738394041public class WeatherAdapter extends BaseAdapter &#123; private final ArrayList&lt;WeatherInfo&gt; weatherList; private final BaseActivity context; public WeatherAdapter(ArrayList&lt;WeatherInfo&gt; weatherList, BaseActivity context) &#123; this.weatherList = weatherList; this.context = context; &#125; public int getCount() &#123; return weatherList.size(); &#125; public WeatherInfo getItem(final int position) &#123; return weatherList.get(position); &#125; public long getItemId(final int position) &#123; return position; &#125; public View getView(final int position, View convertView, final ViewGroup parent) &#123; final Holder holder; if (convertView == null) &#123; holder = new Holder(); convertView = context.getLayoutInflater().inflate(R.layout.item_weatherlist, null); holder.tvCity = (TextView) convertView.findViewById(R.id.tvCity); convertView.setTag(holder); &#125; else &#123; holder = (Holder) convertView.getTag(); &#125; WeatherInfo weatherInfo = weatherList.get(position); holder.tvCity.setText(weatherInfo.getCity()); return convertView; &#125; class Holder &#123; TextView tvCity; &#125;&#125; ListDemoActivity.onCreate()12345678910lvWeatherList = (ListView) findViewById(R.id.lvWeatherlist);WeatherAdapter adapter = new WeatherAdapter(weatherList, ListDemoActivity.this);lvWeatherList.setAdapter(adapter);lvWeatherList.setOnItemClickListener( new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; // do something... &#125; &#125;); 四、实体化编程1. JSON 数据123456789&#123; "weatherinfo":&#123; "city":"北京", "cityid":"101010100", "temp":"24", "WD":"南风", "SD":"74%", "time":"17:45" &#125;&#125; 2. 生成实体类可以使用插件，也可以使用公开的工具，如包建强提供的实体生成器下载地址 3. 序列化123456789101112131415161718192021public class Weatherinfo implements Serializable &#123; private static final long serialVersionUID = 1L; private String city; private String cityid; private String temp; private String WD; private String SD; private String time; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; ...&#125; 4. fastJSON12345WeatherEntity weatherEntity = JSON.parseObject(jsonContent, WeatherEntity.class);WeatherInfor weatherInfor = weatherEntity.getWeatherInfo();if (weatherInfor != null) &#123; tvCity.setText(weatherInfo.getCity());&#125; 如果使用崩溃，试下在混淆文件中加以下两行:12-keepattributes Signature // 避免混淆泛型-keepattributes *Annotation* // 不混淆注解 5. 传递1intent.putExtra(AppContants.Weather, weatherInfo); 五、类型安全转换函数valueOf1234567891011121314public final static int convertToInt(Object value, int defaultValue) &#123; if (value == null || "".equals(value.toString().trim())) &#123; return defaultValue; &#125; try &#123; return Integer.valueOf(value.toString()); &#125; catch (Exception e) &#123; try &#123; return Double.valueOf(value.toString()).intValue(); &#125; catch (Exception e) &#123; return defaultValue; &#125; &#125;&#125; substring12345String cityName = "T";String firstLetter = "";if (cityName.length() &gt; 1) &#123; firstLetter = cityName.substring(1, 2);&#125;]]></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
        <tag>研发录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ANDROID | 使用Fragment兼容平板与手机]]></title>
    <url>%2F2017%2F04%2F10%2FANDROID%2FANDROID%20Building%20a%20Dynamic%20UI%20with%20Fragments%2F</url>
    <content type="text"><![CDATA[界面效果在手机设备上，由于采用单窗格用户界面，因此可能更适合一次只显示一个片段。 相反，由于平板电脑屏幕尺寸较大，可以为用户显示更多信息，因此最好将片段设计为并排显示。 布局文件小屏布局文件，如手机res/layout/news_articles.xml:12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/fragment_container" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; 大屏布局文件，如平板电脑res/layout-large/news_articles.xml:1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;fragment android:name="com.king.demo.fragment.HeadlinesFragment" android:id="@+id/headlines_fragment" android:layout_weight="1" android:layout_width="0dp" android:layout_height="match_parent" /&gt; &lt;fragment android:name="com.king.demo.fragment.ArticleFragment" android:id="@+id/article_fragment" android:layout_weight="2" android:layout_width="0dp" android:layout_height="match_parent" /&gt;&lt;/LinearLayout&gt; 判断加载哪个布局文件当设备屏幕尺寸小于large时加载第一个布局文件，否则加载第二个布局文件，是否large则由系统判断，而我们可以通过以下方法判断加载的是哪个布局：12345678if (findViewById(R.id.fragment_container) != null) &#123; // 此处加载了第一个布局文件&#125;ArticleFragment articleFrag = (ArticleFragment) getSupportFragmentManager().findFragmentById(R.id.article_fragment);if (articleFrag != null) &#123; // 此处加载了第二个布局&#125; 片段处理FragmentManager类提供的方法让您可以在运行时为 Activity 添加、移除和替换片段，从而营造出动态的用户体验。 在运行时为 Activity 添加片段在您的 Activity 内，使用 Support Library API 调用 getSupportFragmentManager() 以获取 FragmentManager。然后，调用 beginTransaction() 创建一个 FragmentTransaction，并调用 add() 添加一个片段。12345678910111213141516171819202122232425262728293031323334353637import android.support.v4.app.FragmentActivity;import android.os.Bundle;import android.support.v4.app.FragmentTransaction;import com.king.demo.R;public class DynamicFragmentsActivity extends FragmentActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.news_articles); // Check whether the activity is using the layout version with // the fragment_container FrameLayout. If so, we must add the first fragment if (findViewById(R.id.fragment_container) != null) &#123; // However, if we're being restored from a previous state, // then we don't need to do anything and should return or else // we could end up with overlapping fragments. if (savedInstanceState != null) &#123; return; &#125; // Create an instance of ExampleFragment HeadlinesFragment firstFragment = new HeadlinesFragment(); // In case this activity was started with special instructions from an Intent, // pass the Intent's extras to the fragment as arguments firstFragment.setArguments(getIntent().getExtras()); // Add the fragment to the 'fragment_container' FrameLayout getSupportFragmentManager().beginTransaction() .add(R.id.fragment_container, firstFragment).commit(); &#125; &#125;&#125; 替换片段替换片段的步骤与添加片段类似，只不过调用的方法从 add() 改为 replace()。请谨记，当您执行替换或移除片段等片段事务时，通常最好让用户能够回退并“撤消”更改。 要让用户回退所执行的片段事务，您必须先调用 addToBackStack()，然后再提交 FragmentTransaction。片段替换示例：123456789101112131415161718192021222324252627// Capture the article fragment from the activity layoutArticleFragment articleFrag = (ArticleFragment) getSupportFragmentManager().findFragmentById(R.id.article_fragment);if (articleFrag != null) &#123; // If article frag is available, we're in two-pane layout... // Call a method in the ArticleFragment to update its content articleFrag.updateArticleView(position);&#125; else &#123; // If the frag is not available, we're in the one-pane layout and must swap frags... // Create fragment and give it an argument for the selected article ArticleFragment newFragment = new ArticleFragment(); Bundle args = new Bundle(); args.putInt(ArticleFragment.ARG_POSITION, position); newFragment.setArguments(args); FragmentTransaction transaction = getSupportFragmentManager().beginTransaction(); // Replace whatever is in the fragment_container view with this fragment, // and add the transaction to the back stack so the user can navigate back transaction.replace(R.id.fragment_container, newFragment); transaction.addToBackStack(null); // Commit the transaction transaction.commit();&#125; 片段通信通常您希望一个片段与另一个片段进行通信，例如根据用户事件更改内容。所有片段到片段的通信是通过Activity完成的。两个片段不应该直接交流。若要允许片段与其Activity进行通信，您可以在片段类中定义接口并在Activity中实现它。片段捕捉接口实现其onattach()生命周期方法中可以调用接口的方法以进行交流活动。 1、声明接口在HeadlinesFragment声明接口OnHeadlineSelectedListener：123456789101112131415161718192021222324public class HeadlinesFragment extends ListFragment &#123; OnHeadlineSelectedListener mCallback; // Container Activity must implement this interface public interface OnHeadlineSelectedListener &#123; public void onArticleSelected(int position); &#125; @Override public void onAttach(Activity activity) &#123; super.onAttach(activity); // This makes sure that the container activity has implemented // the callback interface. If not, it throws an exception try &#123; mCallback = (OnHeadlineSelectedListener) activity; &#125; catch (ClassCastException e) &#123; throw new ClassCastException(activity.toString() + " must implement OnHeadlineSelectedListener"); &#125; &#125; ...&#125; 2、实现接口在DynamicFragmentsActivity中实现接口：12345678910111213141516171819202122232425262728293031323334353637public static class DynamicFragmentsActivity extends Activity implements HeadlinesFragment.OnHeadlineSelectedListener&#123; ... public void onArticleSelected(int position) &#123; // The user selected the headline of an article from the HeadlinesFragment // Do something here to display that article ArticleFragment articleFrag = (ArticleFragment) getSupportFragmentManager().findFragmentById(R.id.article_fragment); if (articleFrag != null) &#123; // If article frag is available, we're in two-pane layout... // Call a method in the ArticleFragment to update its content articleFrag.updateArticleView(position); &#125; else &#123; // Otherwise, we're in the one-pane layout and must swap frags... // Create fragment and give it an argument for the selected article ArticleFragment newFragment = new ArticleFragment(); Bundle args = new Bundle(); args.putInt(ArticleFragment.ARG_POSITION, position); newFragment.setArguments(args); FragmentTransaction transaction = getSupportFragmentManager().beginTransaction(); // Replace whatever is in the fragment_container view with this fragment, // and add the transaction to the back stack so the user can navigate back transaction.replace(R.id.fragment_container, newFragment); transaction.addToBackStack(null); // Commit the transaction transaction.commit(); &#125; &#125;&#125; 3、回调在HeadlinesFragment回调接口中的方法：1234567891011public class HeadlinesFragment extends ListFragment &#123; OnHeadlineSelectedListener mCallback; ... @Override public void onListItemClick(ListView l, View v, int position, long id) &#123; // Notify the parent activity of selected item mCallback.onArticleSelected(position); &#125;&#125; 参考文档链接全部源码链接]]></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ANDROID | 源码分析事件分发]]></title>
    <url>%2F2017%2F03%2F28%2FANDROID%2FANDROID%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%2F</url>
    <content type="text"><![CDATA[源码分析1、Activity ——&gt; Window123456789101112131415161718/** * Called to process touch screen events. You can override this to * intercept all touch screen events before they are dispatched to the * window. Be sure to call this implementation for touch screen events * that should be handled normally. * * @param ev The touch screen event. * @return boolean Return true if this event was consumed. */public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); // Empty method &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; 首先事件开始交给Activity所附属的Window进行分发，如果返回true，整个事件循环就结束了，返回false意味着没人处理，所有View的onTouchEvent都返回了false，此时就会调用Activity的onTouchEvent。 2、Window ——&gt; PhoneWindow1234567891011121314151617181920/** * Abstract base class for a top-level window look and behavior policy. An * instance of this class should be used as the top-level view added to the * window manager. It provides standard UI policies such as a background, title * area, default key processing, etc. * * &lt;p&gt;The only existing implementation of this abstract class is * android.view.PhoneWindow, which you should instantiate when needing a * Window. */public abstract class Window &#123; /** * Used by custom windows, such as Dialog, to pass the touch screen event * further down the view hierarchy. Application developers should * not need to implement or call this. */ public abstract boolean superDispatchTouchEvent(MotionEvent event); // other code ... &#125; Window为抽象类，superDispatchTouchEvent为抽象方法，而注释告知我们唯一实现类是PhoneWindow。 3、PhoneWindow ——&gt; DecorView123456789101112public class PhoneWindow extends Window implements MenuBuilder.Callback &#123; // This is the top-level view of the window, containing the window decor. private DecorView mDecor; @Override public boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event); &#125; // other code ... &#125; PhoneWindow将事件直接传递给了DecorView，那这个DecorView是什么呢？DecorView is the top-level view of the window, containing the window decor. 4、DecorView ——&gt; ViewGroup12345678/** @hide */public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks &#123; public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event); // ViewGroup. &#125; // other code ... &#125; DecorView是一个顶级View，也叫根View，继承FrameLayout，也就是说DecorView是一个ViewGroup。接下来就是将事件分发到ViewGroup的Child。 5、ViewGroup ——&gt; Children1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public abstract class ViewGroup extends View implements ViewParent, ViewManager &#123; @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; // other code ... // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; // other code ... final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex); if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; &#125; // other code ... &#125; 上述代码是ViewGroup中dispatchTouchEvent方法的主要分发代码：首先调用onInterceptTouchEvent()判断是否要拦截，如果是false则遍历ViewGroup的所有子元素，判断子元素是否能够接受点击事件以及事件坐标是否落在子元素的区域内；如果某个子元素满足这个条件，那么事件就会传递给它来处理；dispatchTransformedTouchEvent方法中有如下一段代码，即child不是null，就会调用子类的dispatchTouchEvent方法，就交给子元素处理，从而完成一轮事件分发。12345if (child == null) &#123; handled = super.dispatchTouchEvent(event);&#125; else &#123; handled = child.dispatchTouchEvent(event);&#125; ViewGroup分发事件时，自带记忆功能，即如果某个子元素消耗了ACTION_DOWN事件，那么同一事件序列中的其他事件都会交给它来处理，否则将事件交给它的父类来处理（同样带记忆）。 6、View如果ViewGroup分发的子元素还是ViewGroup，则重复5，直到分发到的子元素是一个View。因为它没有子元素可以向下传递事件，所以只能自己处理。以下是View中的dispatchTouchEvent方法中核心代码：123456789101112131415161718192021222324252627282930/** * Pass the touch screen motion event down to the target view, or this * view if it is the target. * * @param event The motion event to be dispatched. * @return True if the event was handled by the view, false otherwise. */public boolean dispatchTouchEvent(MotionEvent event) &#123; // other code ... boolean result = false; if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; return result;&#125; 首先判断有没有设置OnTouchListener，如果没有设置或其中的onTouch方法返回false，就会调用onTouchEvent()方法了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * Implement this method to handle touch screen motion events. * &lt;p&gt; * If this method is used to detect click actions, it is recommended that * the actions be performed by implementing and calling * &#123;@link #performClick()&#125;. This will ensure consistent system behavior, * including: * &lt;ul&gt; * &lt;li&gt;obeying click sound preferences * &lt;li&gt;dispatching OnClickListener calls * &lt;li&gt;handling &#123;@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK&#125; when * accessibility features are enabled * &lt;/ul&gt; * * @param event The motion event. * @return True if the event was handled, false otherwise. */public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE); &#125; if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: // ... break; case MotionEvent.ACTION_CANCEL: // ... break; case MotionEvent.ACTION_MOVE: // ... break; &#125; return true; &#125; return false;&#125; 首先不可用状态下的View照样会消耗点击事件并返回；接着，如果View设置了代理，那么还会执行TouchDelegate的onTouchEvent方法（机制与OnTouchListener类似）；然后具体处理点击事件：只要View的CLICKABLE、LONG_CLICKABLE和CONTEXT_CLICKABLE有一个为true，那么它就会消耗事件，即onTouchEvent方法返回true，不管它是不是DISABLE状态如何；然后当ACTION_UP事件发生时，会调用performClick方法，如果View设置了OnClickListener，那么performClick方法内部会调用它的onClick方法。12345678910111213141516171819202122/** * Call this view's OnClickListener, if it is defined. Performs all normal * actions associated with clicking: reporting accessibility event, playing * a sound, etc. * * @return True there was an assigned OnClickListener that was called, false * otherwise is returned. */public boolean performClick() &#123; final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); // 调用OnClickListener.onClick result = true; &#125; else &#123; result = false; &#125; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); return result;&#125; 传递规则 同一个事件序列是指从手指触摸屏幕那一刻开始，中间包含数量不定的 move 事件到手指离开屏幕那一刻（down-&gt;move…move-&gt;up)。 正常情况下一个事件序列只能被一个 View 拦截且消耗，每个 View 一旦决定拦截，同一个事件序列所有事件都会直接交给它处理，并且它的 onInterceptTouchEvent 不会再被调用。 某个View一旦开始处理事件，如果它不消耗ACTION_DOWN（onTouchEvent返回了false），那么同一事件序列中其他事件都不会再交给它来处理，事件将重新交给他的父元素处理，即父元素的 onTouchEvent 会被调用。 如果某个View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以收到后续事件，最终这些消失的点击事件会传递给Activity 处理。 View没有onInterceptTouchEvent方法，一旦有事件传递给它，那么它的onTouchEvent方法就会被调用。 View的onTouchEvent 方法默认消耗事件（返回true），除非他是不可点击的（clickable、longClickable和contextClickable同时为false）。View的longClickable 属性默认都为false，clickable属性分情况，Button默认为true，TextView默认为false。 onClick发生的前提是View可点击，并且它收到了down和up事件。 事件传递过程是由外而内，事件总是先传递给父元素，然后在由父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以在子元素干预父元素的事件分发过程，但ACTION_DOWN事件除外。]]></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ANDROID | 工具类]]></title>
    <url>%2F2017%2F03%2F27%2FANDROID%2FANDROID%20Activity%2F</url>
    <content type="text"><![CDATA[一、生命周期整个生命周期来说，成对出现的。onCreate和onDestroy是成对的，代表着创建与销毁；onStart和onStop表示Activity对于程序是否可见（后台）；onResume和onPause表示Activity对于用户是否可见（前台）。 正常生命周期1、启动ActivityA：onCreate() -&gt; onStart() -&gt; onResume()2、按了back键返回：onPause() -&gt; onStop() -&gt; onDestroy()3、用户按了Home键：onPause() -&gt; onStop()4、启动ActivityB：A.onPause() -&gt; B.onCreate() -&gt; B.onStart() -&gt; B.onResume() -&gt; A.onStop()5、ActivityB返回：B.onPause() -&gt; A.onRestart() -&gt; A.onStart() -&gt; A.onResume() -&gt; B.onStop()-&gt; B.onDestroy() 切换横竖屏幕targetSdkVersion 25，没有设置android:configChanges：1、竖屏切横屏：onConfigurationChanged() -&gt; onPause() -&gt; onSaveInstanceState() -&gt; onStop() -&gt; onDestroy() -&gt; onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume()2、横屏切竖屏：onConfigurationChanged() -&gt; onPause() -&gt; onSaveInstanceState() -&gt; onStop() -&gt; onDestroy() -&gt; onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume() 本人使用的是模拟器（minSdkVersion 16 / targetSdkVersion 25）测试，无论是否设置Activity的android:configChanges，或者属性值设为orientation或orientation|keyboardHidden，无论是竖屏切横屏还是横屏切竖屏，流程都如上所述，当android:configChanges=”orientation|keyboardHidden|screenSize”时，只会调用onConfigurationChanged()。经过查资料，android:targetSdkVersion这个属性会影响横竖屏切换的生命周期。详见xiaoQLud的博客 异常生命周期1、系统配置发生改变后，默认情况下Activity会被销毁然后重新创建，生命周期参考横竖屏切换。常用的系统配置只有local、orientation和keyboardHidden。2、资源内存不足导致低优先级的Activity被杀死，生命周期参考横竖屏切换。3、运行时发生了异常，程序直接崩溃。例如：12for (int i = 10; i &gt;= 0; i++) System.out.println(10 / i) 二、数据存储当Activity在异常情况下被终止，在onStop之前，系统会调用onSaveInstanceState方法，来保存当前Activity状态。当Activity被重新创建后，系统会调用onRestoreInstanceState，并且把Activity销毁时onSaveInstanceState方法所保存的Bundle对象作为参数同时传递给onRestoreInstanceState和onCreate方法。1234567891011121314151617181920212223@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (savedInstanceState != null) &#123; String name = savedInstanceState.getString("name"); Log.i(tag, "onCreate() name : " + name); &#125;&#125;@Overrideprotected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); Log.i(tag, "onSaveInstanceState()"); outState.putString("name", "xianxiaotao");&#125;@Overrideprotected void onRestoreInstanceState(Bundle savedInstanceState) &#123; super.onRestoreInstanceState(savedInstanceState); String name = savedInstanceState.getString("name"); Log.i(tag, "onRestoreInstanceState() name : " + name);&#125; android提供的一些控件也实现了onSaveInstanceState和onRestoreInstanceState方法，如TextView。 三、启动模式ActivityManagerService（AMS）内部维护着一个ActivityStack栈，系统会将Activity实例一一放入栈内（先进后出），默认情况下创建一个实例压入栈内。如果多次创建同一个Activity，栈内将压入多个实例。为此，Android提供了启动模式来修改系统的默认行为。目前有四种启动模式：standard、singleTop、singleTask和singleInstance： standard标准模式，也是系统默认模式。每次启动一个Activity都会重新创建一个新的实例，不管这个实例是否已经存在。谁启动了这个Activity，那么这个Activity就运行在启动它的那个Activity所在的栈中。ABCBB singleTop栈顶复用模式。如果新Activity已经位于任务栈的栈顶，那么只调用它的onNewIntent方法实现复用，而不会创建新的实例。如果新的Activity的实例已存在但不是位于栈顶，仍然重新创建。假设目前栈内情况为ABCD（ABCD为四个Activity，A位于栈底），此时再次启动，如果D的启动模式为singleTop，那么栈内仍然是ABCD；如果D的启动模式为standard，D将被重新创建，栈内情况变为ABCDD。 singleTask栈内复用模式。在同一个栈内，它是单实例模式。在这种模式下，启动一个Activity A，系统首先会寻找是否存在A想要的任务栈，如果不存在，就重新创建一个任务栈，然后创建A的实例并压入栈内；如果存在所需的任务栈，这时要看A是否在栈中有实例存在，如果有，那么系统就会把A调到栈顶并调用它的onNewIntent方法，不存在就创建并压入栈中。1、目前任务栈栈S1(ABC)，此时Activity D以singleTask模式请求启动，其所需的任务栈为S2，由于S2和D的实例均不存在，所以系统先创建任务栈S2，然后再创建D的实例并将其放入栈S2中。2、另外一种情况，假设D所需的任务栈为S1，上述S1已存在，所以系统会直接创建D的实例并压入栈S1内。3、如果D所需的任务栈为S1，其中为ADBC，此时系统将D上面的Activity出栈，把D切换到栈顶并调用onNewIntent方法，最终S1栈内为AD。 singleInstance：该模式具备singleTask模式的所有特性外，与它的区别就是，这种模式下的Activity会单独占用一个Task栈，具有全局唯一性，即整个系统中就这么一个实例，由于栈内复用的特性，后续的请求均不会创建新的Activity实例，除非这个特殊的任务栈被销毁了。以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。以下代码是用于测试启动模式的BaseActivity，具体的Activity继承BaseActivity：123456789101112131415161718192021222324252627282930313233343536373839package com.king.bester.demo;import android.content.Intent;import android.content.pm.ActivityInfo;import android.content.pm.PackageManager;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;public class BaseActivity extends AppCompatActivity &#123; private static final String TAG = "Xian Xiaotao"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 区别类名，区别同类名是否同实例，区别任务栈 Log.i(TAG, "onCreate：" + getClass().getSimpleName() + " hasCode:" + this.hashCode() + " TaskId: " + getTaskId()); // 任务栈名称，默认为包名相关 dumpTaskAffinity(); &#125; @Override protected void onNewIntent(Intent intent) &#123; super.onNewIntent(intent); Log.i(TAG, "onNewIntent：" + getClass().getSimpleName() + " hasCode:" + this.hashCode() + " TaskId: " + getTaskId()); dumpTaskAffinity(); &#125; protected void dumpTaskAffinity()&#123; try &#123; ActivityInfo info = this.getPackageManager().getActivityInfo(getComponentName(), PackageManager.GET_META_DATA); Log.i(TAG, "taskAffinity:" + info.taskAffinity); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 配置形式：1234&lt;activity android:name=".ActivitySingleTop" android:launchMode="singleTop" android:taskAffinity="com.king.bester.demo"/&gt; 启动模式参考博客 四、意图调用启动Activity分为两种，显示调用和隐式调用。显示调用通过指定Intent组件名称来实现的，它一般用在知道目标组件名称的前提下，一般是在相同的应用程序内部实现的。隐式调用通过Intent Filter来实现的，它一般用在没有明确指出目标组件名称的前提下，一般是用于在不同应用程序之间。 显示调用123Intent intent=new Intent(MainActivity.this,SettingActivity.class);intent.putExtra(EXTRA,contentEditText.getText().toString());startActivity(intent); 而Manifest文件描述为：1234567&lt;activity android:name=".MainActivity" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".SettingActivity" /&gt; 隐式调用隐式不明确指定启动哪个Activity，而是在Intent Filter中设置Action、Data、Category，让系统来筛选出合适的Activity。清单文件配置如下：12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.king.bester.myapplication"&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".TargetActivity" android:launchMode="singleTask" android:taskAffinity="com.king.bester.myapplication" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.SEND"/&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;data android:mimeType="text/plain"/&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name="com.king.bester.demo" /&gt; &lt;action android:name="com.king.bester.DEMO" /&gt; &lt;category android:name="com.king.bester.a" /&gt; &lt;category android:name="com.king.bester.b" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;data android:mimeType="text/plain"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 代码调用：12345678910111213141516// 匹配第一组intent-filterpublic void startA(View view) &#123; Intent intent = new Intent(); intent.setAction("android.intent.action.SEND"); intent.setType("text/plain"); startActivity(intent);&#125;// 匹配第二组intent-filterpublic void startB(View view) &#123; Intent intent = new Intent(); intent.setAction("com.king.bester.demo"); intent.addCategory("com.king.bester.a"); intent.setType("text/plain"); startActivity(intent);&#125; 1、startA()中没有设置category，是因为系统在调用startActivity或者startActivityForResult的时候会默认为Intent加上“android.intent.category.DEFAULT”这个category。所以，为了我们的Activity能接收隐式调用，必须在intent-filter中指定这个category。2、action区分大小写3、一个Activity可以有多个intent-filter，一个intent只要能匹配任何一组intent-filter即可启动对应的Activity。]]></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
        <tag>util</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ANDROID | 自定义VIEW入门]]></title>
    <url>%2F2017%2F02%2F01%2FANDROID%2FANDROID%20%E8%87%AA%E5%AE%9A%E4%B9%89View%20%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[一、自定义ViewAndroid系统内置的View无法满足业务需求，需要自定义。 Step 1 : 继承View123456789public class CustomView extends View &#123; public CustomView(Context context) &#123; super(context); &#125; public CustomView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125;&#125; 至少写2个构造函数 Step 2 : 自定义属性有些属性希望由用户指定，只有当用户不指定的时候才用我们硬编码的值，比如默认的宽高，在res/values/styles.xml文件里声明：12345678&lt;resources&gt; &lt;!-- suggestion：the name is the class name --&gt; &lt;declare-styleable name="CustomView"&gt; &lt;attr name="default_size" format="dimension" /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 布局文件activity_main.xml中使用自定义的属性12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:xian="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;!-- xian为命名空间，名称随便定义，其值固定为"http://schemas.android.com/apk/res-auto" --&gt; &lt;com.king.demo.customview.CustomView android:layout_width="match_parent" android:layout_height="100dp" xian:default_size="100dp" /&gt;&lt;/LinearLayout&gt; 构造器中读取配置信息并初始化12345678private int defaultSize;public CustomView(Context context, AttributeSet attrs) &#123; super(context, attrs); TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CustomView); defaultSize = a.getDimensionPixelSize(R.styleable.CustomView_default_size, 100); a.recycle(); // 回收TypedArray对象&#125; Step 3 : 重写onMeasure()测量宽高尺寸并设置需要的值。如果不需要制定自定义控件的宽高，无需重写此方法。123456789101112131415161718192021222324252627282930313233343536373839@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); // 重构控件宽高，此处设宽高相等 int width = getMySize(100, widthMeasureSpec); int height = getMySize(100, heightMeasureSpec); if (width &lt; height) height = width; else width = height; setMeasuredDimension(width, height);&#125;/** * 辅助方法，计算宽高 * @param defaultSize 设置宽高默认的值 * @param measureSpec * @return */private int getMySize(int defaultSize, int measureSpec) &#123; int mySize = defaultSize; int mode = MeasureSpec.getMode(measureSpec); int size = MeasureSpec.getSize(measureSpec); switch (mode) &#123; case MeasureSpec.UNSPECIFIED: // 如果没有指定大小，就设置为默认大小 mySize = defaultSize; break; case MeasureSpec.AT_MOST: // 如果测量模式是最大取值为size case MeasureSpec.EXACTLY: // 如果是固定的大小，那就不要去改变它 mySize = size; break; &#125; return mySize;&#125; onMeasure()至少会被调用两次，第一次读取xml文件中的参数layout_width和layout_width，它们可以不用指定具体的尺寸，如值为wrap_content或match_parent。为了更好的适配各种尺寸的屏幕，需要根据父类布局或子类控件宽高动态计算实际宽高，而不是在xml中指定具体的数值。 widthMeasureSpec和heightMeasureSpec都是int，前面2个bit用于区分不同的测量模式，后面30个bit存放的是尺寸的数据。测量模式分三种：UNSPECIFIED（父容器没有对当前View有任何限制，当前View可以任意取尺寸）、EXACTLY（当前的尺寸就是当前View应该取的尺寸，对应match_parent和固定值）、AT_MOST（当前尺寸是当前View能取的最大尺寸，对应wrap_content） Step 4 : 重写onDraw()123456789101112@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int r = getMeasuredWidth() / 2; int centerX = getLeft() + r; int centerY = getTop() + r; Paint paint = new Paint(); paint.setColor(Color.RED); canvas.drawCircle(centerX, centerY, r, paint);&#125; 效果图 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.king.demo.customview;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.util.AttributeSet;import android.view.View;/** * 继承View，至少写2个构造函数 */public class CustomView extends View &#123; private int defaultSize; public CustomView(Context context) &#123; super(context); &#125; public CustomView(Context context, AttributeSet attrs) &#123; super(context, attrs); TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CustomView); defaultSize = a.getDimensionPixelSize(R.styleable.CustomView_default_size, 100); a.recycle(); // 回收TypedArray对象 &#125; /** * 辅助方法，计算宽高 * @param defaultSize 设置宽高默认的值 * @param measureSpec * @return */ private int getMySize(int defaultSize, int measureSpec) &#123; int mySize = defaultSize; int mode = MeasureSpec.getMode(measureSpec); int size = MeasureSpec.getSize(measureSpec); switch (mode) &#123; case MeasureSpec.UNSPECIFIED: // 如果没有指定大小，就设置为默认大小 mySize = defaultSize; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: // 如果是固定的大小，那就不要去改变它 mySize = size; break; &#125; return mySize; &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); // 重构控件宽高 int width = getMySize(defaultSize, widthMeasureSpec); int height = getMySize(defaultSize, heightMeasureSpec); if (width &lt; height) &#123; height = width; &#125; else &#123; width = height; &#125; setMeasuredDimension(width, height); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int r = getMeasuredWidth() / 2; int centerX = getLeft() + r; int centerY = getTop() + r; Paint paint = new Paint(); paint.setColor(Color.RED); canvas.drawCircle(centerX, centerY, r, paint); &#125;&#125; 二、自定义ViewGroup模拟一个简易垂直布局，详情可参考Android内置的LinearLayout源码。 Step 1 : 继承ViewGroup必须实现onLayout(boolean changed, int left, int top, int right, int bottom)方法，用于“摆放”各个子View。123456789101112131415161718/** * Created by xianxiaotao on 17/3/11. */public class SimpleLinearLayout extends ViewGroup &#123; public SimpleLinearLayout(Context context) &#123; super(context); &#125; public SimpleLinearLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; // TODO &#125;&#125; Step 2 : 自定义属性（同上）Step 3 : 重写onMeasure()1234567891011121314151617181920212223242526@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); measureChildren(widthMeasureSpec, heightMeasureSpec); // 触发每个子View的onMeasure方法 int count = getChildCount(); int maxWidth = 0; int height = 0; for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); if (child == null || child.getVisibility() == View.GONE) continue; int childWidth = child.getMeasuredWidth(); int childHeight = child.getMeasuredHeight(); maxWidth = childWidth &gt; maxWidth ? childWidth : maxWidth; height += childHeight; // 不考虑Margin &#125; if (MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.AT_MOST) maxWidth = MeasureSpec.getSize(widthMeasureSpec); if (MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.AT_MOST) height = MeasureSpec.getSize(heightMeasureSpec); setMeasuredDimension(maxWidth, height);&#125; Step 4 : 重写onLayout()12345678910111213@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int count = getChildCount(); int curHeight = t; // 记录当前的高度位置 for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); int height = child.getMeasuredHeight(); int width = child.getMeasuredWidth(); child.layout(l, curHeight, l + width, curHeight + height); curHeight += height; &#125;&#125; 配置文件123456789101112131415161718192021222324252627&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:xian="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;com.king.demo.customview.SimpleLinearLayout android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="#00FFFF"&gt; &lt;Button android:layout_width="100dp" android:layout_height="wrap_content" android:text="btn" /&gt; &lt;Button android:layout_width="200dp" android:layout_height="wrap_content" android:text="btn" /&gt; &lt;Button android:layout_width="75dp" android:layout_height="wrap_content" android:text="btn" /&gt; &lt;/com.king.demo.customview.SimpleLinearLayout&gt;&lt;/LinearLayout&gt; 效果图]]></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
        <tag>CUSTOM VIEW</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DESIGN PATTERN | Strategy 策略设计模式]]></title>
    <url>%2F2017%2F01%2F13%2FPATTERN%2FDesign%20pattern%20%E7%AD%96%E7%95%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[返回设计模式目录 使用模式之前给定如下表达式：如”1+4”、”4 *2”、”9- 2”、”3/1”，计算结果并打印。1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 由于java7.0的新特性，本类采用switch代替if-else * @author xianxiaotao */public class CalculateUtil &#123; private CalculateUtil()&#123;&#125; /** * 计算表达式，并返回结果 * @param exp * @param opt * @return */ public static int calculate(String exp, String opt) &#123; String[] operandStrs = exp.split(opt); int beforeOperand = Integer.parseInt(operandStrs[0].trim()); int afterOperand = Integer.parseInt(operandStrs[1].trim()); int result = Integer.MIN_VALUE; switch (opt) &#123; case "\\+": result = beforeOperand + afterOperand; break; case "-": result = beforeOperand - afterOperand; break; case "\\*": result = beforeOperand * afterOperand; break; case "/": result = beforeOperand / afterOperand; break; &#125; return result; &#125; public static void main(String[] args) &#123; System.out.println(calculate("4 +2", "\\+")); // 6 System.out.println(calculate("4 -2", "-")); // 2 System.out.println(calculate("4 *2", "\\*")); // 8 System.out.println(calculate("4 /2", "/")); // 2 &#125;&#125; 对于上述代码，新增一个取余表达式与修改加法业务都要修改calculate方法，扩展性和维护性很差。可以使用策略模式规避。 使用策略模式新增一个取余表达式，则直接新增一个实现类，无需修改关联代码。使得算法可以自由切换，避免使用多重条件判断，扩展性良好。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.xian.design.strategy;/** * 此处应该是接口，但我需要一个辅助方法spit，懒得新建一个抽象类并继承之 */abstract class Calculator &#123; public abstract int calculate(String exp); public int[] split(String exp, String opt) &#123; String array[] = exp.split(opt); int arrayInt[] = new int[2]; arrayInt[0] = Integer.parseInt(array[0].trim()); arrayInt[1] = Integer.parseInt(array[1].trim()); return arrayInt; &#125;&#125;class Add extends Calculator &#123; @Override public int calculate(String exp) &#123; int arrayInt[] = split(exp, "\\+"); return arrayInt[0] + arrayInt[1]; &#125;&#125;class Sub extends Calculator &#123; @Override public int calculate(String exp) &#123; int arrayInt[] = split(exp, "-"); return arrayInt[0] - arrayInt[1]; &#125; &#125;class Mul extends Calculator &#123; @Override public int calculate(String exp) &#123; int arrayInt[] = split(exp, "\\*"); return arrayInt[0] * arrayInt[1]; &#125; &#125;class Div extends Calculator &#123; @Override public int calculate(String exp) &#123; int arrayInt[] = split(exp, "/"); return arrayInt[0] / arrayInt[1]; &#125; &#125;class Executor &#123; private Calculator calculator; public Executor(Calculator calculator) &#123; this.calculator = calculator; &#125; public int execute(String exp) &#123; return calculator.calculate(exp); &#125;&#125;public class StrategyTest &#123; public static void main(String[] args) &#123; Executor executor = new Executor(new Add()); System.out.println("4 + 2 = " + executor.execute("4 +2")); executor = new Executor(new Sub()); System.out.println("4 - 2 = " + executor.execute("4 -2")); executor = new Executor(new Mul()); System.out.println("4 * 2 = " + executor.execute("4 * 2")); executor = new Executor(new Div()); System.out.println("4 / 2 = " + executor.execute("4/ 2")); &#125;&#125; 输出：4 + 2 = 64 - 2 = 24 * 2 = 84 / 2 = 2 策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口。 如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。 所有策略类都需要对外暴露。]]></content>
      <categories>
        <category>DESIGN PATTERN</category>
      </categories>
      <tags>
        <tag>DESIGN PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DESIGN PATTERN | Flyweight 享元设计模式]]></title>
    <url>%2F2017%2F01%2F12%2FPATTERN%2FDesign%20pattern%20%E4%BA%AB%E5%85%83%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[返回设计模式目录 享元模式运用共享技术有效地支持大量细粒度的对象，减少创建对象的数量，以减少内存占用和提高性能。在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。通常与工厂模式一起使用，而工厂类中含有共享池(HashMap)。 实例演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.xian.design.flyweight;import java.util.HashMap;interface Shape &#123; void draw();&#125;/** * 需要共享的元对象 * @author xianxiaotao */class Circle implements Shape &#123; private String color; private int x; private int y; private int radius; public Circle(String color) &#123; this.color = color; &#125; public void setX(int x) &#123; this.x = x; &#125; public void setY(int y) &#123; this.y = y; &#125; public void setRadius(int radius) &#123; this.radius = radius; &#125; @Override public void draw() &#123; System.out.println("Circle: Draw() [Color : " + color +", x : " + x +", y :" + y +", radius :" + radius); &#125;&#125;/** * 工厂类，提供缓存池，用于控制元对象的重复利用 */class ShapeFactory &#123; private static final HashMap&lt;String, Shape&gt; circleMap = new HashMap&lt;&gt;(); private ShapeFactory() &#123;&#125; // 无需实例化 public static Shape getCircle(String color) &#123; Circle circle = (Circle) circleMap.get(color); if (null == circle) &#123; circle = new Circle(color); circleMap.put(color, circle); System.out.println("Creating circle of color : " + color); // 如果重复利用则不会输出这句 &#125; return circle; &#125;&#125;/** * 测试 */public class FlyweightTest &#123; private static final String[] colors = &#123;"Red", "Green", "Blue", "White", "Black"&#125;; private static String getRandomColor() &#123; return colors[(int)(Math.random() * colors.length)]; &#125; private static int getRandoms() &#123; return (int)(Math.random() * 100); &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 20; i++) &#123; String color = getRandomColor(); Circle circle = (Circle) ShapeFactory.getCircle(color); circle.setX(getRandoms()); circle.setY(getRandoms()); circle.setRadius(getRandoms()); circle.draw(); &#125; &#125;&#125; 输出：Creating circle of color : GreenCircle: Draw() [Color : Green, x : 69, y :5, radius :73]Creating circle of color : WhiteCircle: Draw() [Color : White, x : 92, y :6, radius :17]Circle: Draw() [Color : White, x : 99, y :8, radius :88]Creating circle of color : RedCircle: Draw() [Color : Red, x : 74, y :18, radius :28]Creating circle of color : BlackCircle: Draw() [Color : Black, x : 35, y :47, radius :12]Circle: Draw() [Color : Black, x : 59, y :73, radius :11]Creating circle of color : BlueCircle: Draw() [Color : Blue, x : 25, y :10, radius :52]Circle: Draw() [Color : Black, x : 33, y :83, radius :19]Circle: Draw() [Color : Black, x : 56, y :5, radius :45]Circle: Draw() [Color : Blue, x : 83, y :13, radius :87]Circle: Draw() [Color : Red, x : 49, y :43, radius :48]Circle: Draw() [Color : Green, x : 91, y :33, radius :62]Circle: Draw() [Color : Green, x : 84, y :62, radius :87]Circle: Draw() [Color : White, x : 76, y :4, radius :85]Circle: Draw() [Color : Green, x : 96, y :30, radius :0]Circle: Draw() [Color : White, x : 68, y :54, radius :27]Circle: Draw() [Color : Green, x : 13, y :52, radius :14]Circle: Draw() [Color : Green, x : 44, y :51, radius :70]Circle: Draw() [Color : Red, x : 1, y :46, radius :12]Circle: Draw() [Color : Blue, x : 70, y :12, radius :66] 不同颜色的圆都只创建了一次，其余的都是重复利用，大大减少对象的创建，降低系统的内存，使效率提高。但是重复利用对象时，需要分离出外部状态和内部状态，上述代码Circle属性color是外部状态，x、y、radius是内部状态，但是得必须保证不管内部状态如何变化都不会影响到外部状态。]]></content>
      <categories>
        <category>DESIGN PATTERN</category>
      </categories>
      <tags>
        <tag>DESIGN PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DESIGN PATTERN | Composite 组合设计模式]]></title>
    <url>%2F2017%2F01%2F11%2FPATTERN%2FDesign%20pattern%20%E7%BB%84%E5%90%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[返回设计模式目录 组合模式又叫部分整体模式，用于把一组相似的对象当做一个单一的对象。依据树形结构来组合对象，以便表示部分及整体层次。 使用场景1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作树、操作符和另一个操作数。2、树形菜单3、二叉树4、文件与文件夹的管理5、员工 关键代码树枝和叶子实现统一接口，树枝内部组合该接口，并且含有内部属性 List，里面放Component。定义时为具体类。 实例演示演示类使用Employee类来添加部门层次结构，并打印所有员工。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.xian.design.composite;import java.util.ArrayList;import java.util.List;/** * 员工类 * @author xianxiaotao */public class Employee &#123; private String name; private String dept; private int salary; private List&lt;Employee&gt; subordinates; // 下属员工 public Employee(String name, String dept, int salary) &#123; this.name = name; this.dept = dept; this.salary = salary; subordinates = new ArrayList&lt;&gt;(); &#125; public List&lt;Employee&gt; getSubordinates() &#123; return subordinates; &#125; public void add(Employee e) &#123; subordinates.add(e); &#125; public void remove(Employee e) &#123; subordinates.remove(e); &#125; @Override public String toString() &#123; return "Employee [name=" + name + ", dept=" + dept + ", salary=" + salary + "]"; &#125;&#125;/** * 组合模式测试类，打印Employee层次结构 * * @author xianxiaotao */public class CompositeTest &#123; public static void main(String[] args) &#123; Employee CEO = new Employee("xianxiaotao", "CEO", 100000000); Employee headSales = new Employee("Bill Gates", "Head Sales", 50000000); Employee headMarketing = new Employee("Michel", "Head Marketing", 20000000); Employee salesExecutive1 = new Employee("Richard", "Sales", 10000); Employee salesExecutive2 = new Employee("Rob", "Sales", 10000); Employee clerk1 = new Employee("Laura", "Marketing", 10000); Employee clerk2 = new Employee("Bob", "Marketing", 10000); CEO.add(headSales); CEO.add(headMarketing); headSales.add(salesExecutive1); headSales.add(salesExecutive2); headMarketing.add(clerk1); headMarketing.add(clerk2); printEmployee(CEO, 0); &#125; // 利用递归打印树形结构 public static void printEmployee(Employee e, int level) &#123; System.out.print(""); for (int i = 0; i &lt; level; i++) System.out.print(" "); System.out.println(e); List&lt;Employee&gt; employees = e.getSubordinates(); if (employees.size() &gt; 0) &#123; level++; for (Employee employee : employees) printEmployee(employee, level); &#125; &#125;&#125; 输出：]]></content>
      <categories>
        <category>DESIGN PATTERN</category>
      </categories>
      <tags>
        <tag>DESIGN PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DESIGN PATTERN | Bridge 桥接设计模式]]></title>
    <url>%2F2017%2F01%2F10%2FPATTERN%2FDesign%20pattern%20%E6%A1%A5%E6%8E%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[返回设计模式目录 桥接模式桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。 如果看完实例一还是不明白桥接模式，请看实例二。 实例一演示12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 接口: 驱动，一个维度public interface Driver &#123; public void connect();&#125;// Mysql对于驱动的具体实现public class MysqlDriver implements Driver &#123; @Override public void connect() &#123; System.out.println("Mysql driver connect"); &#125;&#125;// Oracle对于驱动的具体实现public class OracleDriver implements Driver &#123; @Override public void connect() &#123; System.out.println("Oracle driver connect"); &#125;&#125;// 管理类，另一个维度public abstract class Manager &#123; protected Driver driver; protected Manager(Driver driver) &#123; this.driver = driver; &#125; public abstract void connect();&#125;// 管理类的实现类public class DriverManager extends Manager &#123; protected DriverManager(Driver driver) &#123; super(driver); &#125; @Override public void connect() &#123; driver.connect(); &#125;&#125;// 测试类public class BridgeTest &#123; public static void main(String[] args) &#123; Manager mysqlDriver = new DriverManager(new MysqlDriver()); Manager oracleDriver = new DriverManager(new OracleDriver()); mysqlDriver.connect(); oracleDriver.connect(); &#125;&#125; 输出：Mysql driver connectOracle driver connect 桥接模式最主要的就是将抽象与实现分开，即将上述接口Driver的实现，实际上是由Manager子类负责实现。这样的好处就是Driver与Manager都可以独立变化，例如新增DB2对与Driver的实现，而其他类可以不做任何修改（除测试代码），就能完美切合。123456public class DB2Driver implements Driver &#123; @Override public void connect() &#123; System.out.println("DB2 driver connect"); &#125;&#125; 对于Manager的子类来说，一样可以任意扩展，比如上述DriverManager类的实现比较粗糙，现在新增一个更完善的实现类。而这样的更改对Driver的实现类没有任何影响（除测试代码）。如下：123456789101112131415161718192021public class AdvancedDriverManager extends Manager &#123; protected DriverManager(Driver driver) &#123; super(driver); &#125; @Override public void connect() &#123; prepare(); driver.connect(); monitor(); &#125; private void prepare() &#123; System.out.println("连接前进行检查和准备工作"); &#125; private void monitor() &#123; System.out.println("监听连接，并处理异常情况"); &#125;&#125; 实例二演示1、传统方式：继承汽车上路行驶。既有小汽车又有公共汽车，它们都不但能在市区中的公路上行驶，也能在高速公路上行驶。这你会发现，对于交通工具（汽车）有不同的类型，它们所行驶的环境（路）也有不同类型，在软件系统中就要适应两个方面（不同车型，不同道路）的变化，怎样实现才能应对这种变化呢？传统做法是继承。即抽象出道路（Road），提供run方法；路分高速（SpeedWay）和街道（Street）；车有公交车和小汽车，为了能在高速公路上行驶，继承SpeedWay，即有OnSpeedWayCar、OnSpeedWayBus，为了能在街道上行驶，继承Street，即有OnStreetCar、OnStreetBus。具体代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Road &#123; void run() &#123; System.out.println("路"); &#125;&#125;// 市区街道class Street extends Road &#123; void run() &#123; System.out.println("市区街道"); &#125;&#125;// 高速公路class SpeedWay extends Road &#123; void run() &#123; System.out.println("高速公路"); &#125;&#125;// 市区街道行驶的小汽车class OnStreetCar extends Street &#123; void run() &#123; System.out.println("小汽车在市区街道行驶"); &#125;&#125;// 市区街道行驶的公交车class OnStreetBus extends Street &#123; void run() &#123; System.out.println("公交车在市区街道行驶"); &#125;&#125;// 小汽车在高速公路行驶class OnSpeedWayCar extends SpeedWay &#123; void run() &#123; System.out.println("小汽车在高速公路行驶"); &#125;&#125;// 公交车在高速公路行驶class OnSpeedWayBus extends SpeedWay &#123; void run() &#123; System.out.println("公交车在高速公路行驶"); &#125;&#125;//测试public class BridgeTest &#123; public static void main(String[] args) &#123; OnSpeedWayCar onSpeedWayCar = new OnSpeedWayCar(); // 小汽车在高速公路行驶 onSpeedWayCar.run(); OnStreetBus onStreetbus = new OnStreetBus(); // 公交车在市区街道行驶 onStreetbus.run(); &#125;&#125; 输出：小汽车在高速公路行驶公交车在市区街道行驶 对于上述代码中，高速公路又分一级、二级、三级和四级公路，而小汽车和公交车为了能在这些高速公路衍生路中行驶，可以通过继承，但会导致类的结构过于复杂，继承关系太多，难于维护，扩展性太差。 2、设计模式：桥接可以将车当做一个维度，并抽象出run方法，将路当做另一个维度，并通过对象组合的方式，即路持有车，从而把两个角色之间的继承关系改为了耦合的关系，从而使这两者可以从容自若的各自独立的变化，这也是Bridge模式的本意。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.design.bridge;// 汽车维度的父类（抽象类或接口）abstract class AbstractCar &#123; abstract void run();&#125;// 汽车维度的子类或实现类Carclass Car extends AbstractCar &#123; @Override void run() &#123; System.out.println("Car running"); &#125;&#125;// 汽车维度的子类或实现类Busclass Bus extends AbstractCar &#123; @Override void run() &#123; System.out.println("Bus running"); &#125;&#125;// 路维度的父类（抽象类或接口）abstract class AbstractRoad &#123; protected AbstractCar abstractCar; // 利用组合，持有对象 protected AbstractRoad(AbstractCar abstractCar) &#123; this.abstractCar = abstractCar; &#125; abstract void run();&#125;// 路维度的子类或实现类Street，供车行驶class Street extends AbstractRoad &#123; protected Street(AbstractCar abstractCar) &#123; super(abstractCar); &#125; @Override void run() &#123; System.out.print("Street : "); abstractCar.run(); &#125;&#125;// 路维度的子类或实现类Street，供车行驶class SpeedWay extends AbstractRoad &#123; protected SpeedWay(AbstractCar abstractCar) &#123; super(abstractCar); &#125; @Override void run() &#123; System.out.print("SpeedWay : "); abstractCar.run(); &#125;&#125;// 人维度的父类（抽象类或接口）abstract class AbstractPerson &#123; protected AbstractRoad abstractRoad; protected AbstractPerson(AbstractRoad abstractRoad) &#123; this.abstractRoad = abstractRoad; &#125; abstract void run();&#125;// 测试public class BridgeTest &#123; public static void main(String[] args) &#123; SpeedWay carOnSpeedWay = new SpeedWay(new Car()); SpeedWay busOnSpeedWay = new SpeedWay(new Bus()); Street carOnStreet = new Street(new Car()); Street busOnStreet = new Street(new Bus()); carOnSpeedWay.run(); busOnSpeedWay.run(); carOnStreet.run(); busOnStreet.run(); &#125;&#125; 输出：SpeedWay : Car runningSpeedWay : Bus runningStreet : Car runningStreet : Bus running 无论公路分几级，或者汽车分几厢，2个维度各自独立变化衍生，都互不影响。不仅如此，还可以轻易新增一个维度，比如人，即不同的人在不同的道路上驾驶不同的汽车。 3、新增维度：人1234567891011121314151617181920212223242526272829303132333435363738394041424344// 人维度的父类（抽象类或接口）abstract class AbstractPerson &#123; protected AbstractRoad abstractRoad; protected AbstractPerson(AbstractRoad abstractRoad) &#123; this.abstractRoad = abstractRoad; &#125; abstract void run();&#125;// 人维度的子类或实现类Manclass Man extends AbstractPerson &#123; protected Man(AbstractRoad abstractRoad) &#123; super(abstractRoad); &#125; @Override void run() &#123; System.out.print("Man : "); abstractRoad.run(); &#125;&#125;// 人维度的子类或实现类Manclass Woman extends AbstractPerson &#123; protected Woman(AbstractRoad abstractRoad) &#123; super(abstractRoad); &#125; @Override void run() &#123; System.out.print("Woman : "); abstractRoad.run(); &#125;&#125;// 测试public class BridgeTest &#123; public static void main(String[] args) &#123; AbstractPerson person = new Man(new Street(new Car())); person.run(); &#125;&#125; 输出：Man : Street : Car running 人持有路、路持有车，因为演示桥接模式的优点，所以导致设计不合理，读者可以自行更改成路持有车、车持有人。]]></content>
      <categories>
        <category>DESIGN PATTERN</category>
      </categories>
      <tags>
        <tag>DESIGN PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DESIGN PATTERN | Facade 外观设计模式]]></title>
    <url>%2F2017%2F01%2F09%2FPATTERN%2FDesign%20pattern%20%E5%A4%96%E8%A7%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[返回设计模式目录 外观模式为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式是解决了类与类之家的依赖关系，提高了系统的灵活性、安全性，但不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。 实例演示用户一键开启电脑，而电脑则启动CPU、Memory、Disk等，这些操作及顺序是用户无需知道的。 1、电脑中的各个组件1234567891011121314151617181920212223242526public class CPU &#123; public void startup() &#123; System.out.println("cpu startup!"); &#125; public void shutdown() &#123; System.out.println("cpu shutdown!"); &#125;&#125;class Memory &#123; public void startup() &#123; System.out.println("memory startup!"); &#125; public void shutdown() &#123; System.out.println("memory shutdown!"); &#125;&#125;class Disk &#123; public void startup() &#123; System.out.println("disk startup!"); &#125; public void shutdown() &#123; System.out.println("disk shutdown!"); &#125;&#125; 2、对外提供一个一致的界面123456789101112131415161718192021222324252627public class Computer &#123; private CPU cpu; private Memory memory; private Disk disk; public Computer() &#123; cpu = new CPU(); memory = new Memory(); disk = new Disk(); &#125; public void startUp() &#123; System.out.println("start the computer!"); cpu.startUp(); memory.startUp(); disk.startUp(); System.out.println("start computer finished!\n"); &#125; public void shutDown() &#123; System.out.println("begin to close the computer!"); cpu.shutDown();; memory.shutDown(); disk.shutDown(); System.out.println("computer closed!"); &#125;&#125; 3、测试及输出1234567public class FacadeTest &#123; public static void main(String[] args) &#123; Computer computer = new Computer(); computer.startUp(); computer.shutDown(); &#125;&#125; 输出：start the computer!cpu startup!memory startup!disk startup!start computer finished! begin to close the computer!cpu shutdown!memory shutdown!disk shutdown!computer closed! 如果我们没有Computer类，那么，CPU、Memory、Disk他们之间将会相互持有实例，产生关系，这样会造成严重的依赖，修改一个类，可能会带来其他类的修改，这不是我们想要看到的，有了Computer类，他们之间的关系被放在了Computer类里，这样就起到了解耦的作用，这，就是外观模式！]]></content>
      <categories>
        <category>DESIGN PATTERN</category>
      </categories>
      <tags>
        <tag>DESIGN PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DESIGN PATTERN | Proxy 代理设计模式]]></title>
    <url>%2F2017%2F01%2F08%2FPATTERN%2FDesign%20pattern%20%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[返回设计模式目录 代理模式代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。举例说明，就是一个人或者一个机构代表另一个人或者另一个机构采取行动。在一些情况下，一个客户不想或者不能够直接引用一个对象，而代理对象可以在客户端和目标对象之前起到中介的作用。 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 实例一演示通过上面的代理模式描述我们可以知道，其目的就是为了控制对象引用，生活场景中我们以买车为例，如果我们要买一辆轿车必须通过汽车4S店，汽车4s店就是充当代理角色，其目的就是控制买车客户的买车行为，必须通过汽车4S店才能从汽车厂商买一辆车。 1、新建一个买车的接口123public interface IBuyCar &#123; public void buyCar(); // 买车&#125; 2、声明一个要买车的客户，实现买车接口12345678910111213141516public class Customer implements IBuyCar &#123; private int cash; // 购车款 public int getCash() &#123; return cash; &#125; public void setCash(int cash) &#123; this.cash = cash; &#125; @Override public void buyCar() &#123; System.out.println("买一辆车花费了" + cash + "元"); &#125;&#125; 3、声明一个买车代理汽车4S店，同样也实现买车接口，必须接受客户下单123456789101112public class BuyCarProxy implements IBuyCar &#123; private Customer customer; // 接收买车客户 public BuyCarProxy(Customer customer) &#123; this.customer = customer; &#125; @Override public void buyCar() &#123; // 实现为客户买车 customer.buyCar(); &#125;&#125; 4、测试，模拟一次买车12345678public class ProxyTest &#123; public static void main(String[] args) &#123; Customer customer = new Customer(); customer.setCash(150000); BuyCarProxy proxy = new BuyCarProxy(customer); proxy.buyCar(); &#125;&#125; 输出：买一辆车花费了150000元 5、通过代理模式实现权限控制通过上面的例子，我们可能有个疑问，难道就不能直接去厂家买车吗？当然可以，如果在使用场景中实现类能满足要求时，我们当然可以直接实现类，但当实现类不能满足要求，要扩展需求，根据开闭原则你又不能修改实现类代码，这时你就用代理类。比如购买一辆车我们要对客户进行一个购车款审核，如果符合条件就买车，不符合要求我们就告知客户购车款不足。12345678910111213141516171819202122232425262728293031323334353637/** * 修改后的代理类 */public class BuyCarProxy implements IBuyCar &#123; private Customer customer; // 接收买车客户 public BuyCarProxy(Customer customer) &#123; this.customer = customer; &#125; @Override public void buyCar() &#123; // 实现为客户买车 int cash = customer.getCash(); if (cash &lt; 100000) &#123; System.out.println("你的钱不够买一辆车"); return; &#125; customer.buyCar();; &#125;&#125;/** * 测试 */public class ProxyTest &#123; public static void main(String[] args) &#123; Customer customer=new Customer(); customer.setCash(120000); BuyCarProxy buyCarProxy=new BuyCarProxy(customer); buyCarProxy.buyCar(); Customer customer1 =new Customer(); customer1.setCash(90000); BuyCarProxy buyCarProxy1 =new BuyCarProxy(customer1); buyCarProxy1.buyCar(); &#125;&#125; 输出：买一辆车花费了120000元你的钱不够买一辆车 实例二演示模拟一个场景：现有程序中有一个RealImage类，实现了Image接口。当创建RealImage类时就会从磁盘中加载一次，从而入驻内存。为了减少RealImage对象加载的内存占用，使用一个代理类ImageProxy，延迟加载。 1、Image接口及其实现类RealImage123456789101112131415161718192021public interface Image &#123; public void display();&#125;public class RealImage implements Image &#123; private String fileName; public RealImage(String fileName) &#123; this.fileName = fileName; loadFromDisk(fileName); &#125; @Override public void display() &#123; System.out.println("Displaying " + fileName); &#125; private void loadFromDisk(String fileName) &#123; System.out.println("Loading " + fileName); &#125;&#125; 2、代理类，延迟加载123456789101112131415public class ImageProxy implements Image &#123; private String fileName; private RealImage realImage; public ImageProxy(String fileName) &#123; this.fileName = fileName; &#125; @Override public void display() &#123; if (null == realImage) // 延迟加载 realImage = new RealImage(fileName); realImage.display(); &#125;&#125; 3、测试：当被请求时，使用ProxyImage来获取RealImage类的对象123456789public class ProxyTest &#123; public static void main(String[] args) &#123; Image realImage = new RealImage("real_image.jpg"); Image imageProxy = new ImageProxy("proxy_image.jpg"); System.out.println("Calling method"); realImage.display(); imageProxy.display(); // 延迟加载图像，调用时才将图像从磁盘加载 &#125;&#125; 输出：Loading real_image.jpgCalling method…Displaying real_image.jpgLoading proxy_image.jpgDisplaying proxy_image.jpg]]></content>
      <categories>
        <category>DESIGN PATTERN</category>
      </categories>
      <tags>
        <tag>DESIGN PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DESIGN PATTERN | Decorator 装饰器设计模式]]></title>
    <url>%2F2017%2F01%2F07%2FPATTERN%2FDesign%20pattern%20%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[返回设计模式目录 装饰器模式装饰器模式允许向一个现有的对象添加新的功能，同时又不改变其结构。一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。在不想增加很多子类的情况下扩展类，此时使用装饰器模式。 1、应用实例1、孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。 2、使用场景扩展一个类的功能，动态增加功能、动态撤销，可代替继承 3、优点缺点 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。 多层装饰比较复杂，而且产生过多相似的对象，不易排错。 4、关键代码 Component类充当抽象角色（如下案例中的Shape接口），不应该具体实现； 修饰类引用和继承Component类（如下的ShapeDecorator抽象类），具体扩展类重写父类方法（如RedShapeDecorator） 实例演示一个形状接口（Shape），拥有draw方法，有2个子类（Circle、Rectangle），而现在需要为该系列的类扩展一个功能：画红边框。分以下步骤： 1、创建接口及其子类1234567891011121314151617public interface Shape &#123; public void draw();&#125;public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println("Shape: Circle"); &#125;&#125;public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println("Shape: Rectangle"); &#125;&#125; 2、创建实现了Shape接口的抽象装饰类123456789101112public abstract class ShapeDecorator implements Shape &#123; protected Shape decoratedShape; // protected是为了让子类继承 public ShapeDecorator(Shape decoratedShape) &#123; this.decoratedShape = decoratedShape; &#125; @Override public void draw() &#123; decoratedShape.draw(); &#125;&#125; 3、创建扩展了ShapeDecorator类的实体装饰类1234567891011121314151617181920public class RedShapeDecorator extends ShapeDecorator &#123; public RedShapeDecorator(Shape decoratedShape) &#123; super(decoratedShape); &#125; @Override public void draw() &#123; decoratedShape.draw(); setRedBorder(decoratedShape); &#125; /** * 扩展的功能：边框着色 * @param decoratedShape */ private void setRedBorder(Shape decoratedShape) &#123; System.out.println("Border Color: Red"); &#125;&#125; 4、测试及输出1234567891011121314public class DecoratorTest &#123; public static void main(String[] args) &#123; Shape circle = new Circle(); Shape redCircle = new RedShapeDecorator(new Circle()); Shape redRectangle = new RedShapeDecorator(new Rectangle()); System.out.println("Circle with normal border"); circle.draw(); System.out.println("\nCircle of red border"); redCircle.draw(); System.out.println("\nRectangle of red border"); redRectangle.draw(); &#125;&#125; 输出：Circle with normal borderShape: Circle Circle of red borderShape: CircleBorder Color: Red Rectangle of red borderShape: RectangleBorder Color: Red ShapeDecorator作为抽象装饰类，是为了让不同的子类装饰器为Shape子类扩展不同的功能。上述代码中RedShapeDecorator扩展了setRedBorder()，也可以继续新增一个FillShapeDecorator，继承ShapeDecorator，并扩展fillShape(int color)。 5、不同的装饰器12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 装饰器：括展功能（填充颜色） */public class FillShapeDecorator extends ShapeDecorator &#123; private String color; // 测试代码暂用String public FillShapeDecorator(Shape decoratedShape, String color) &#123; super(decoratedShape); this.color = color; &#125; @Override public void draw() &#123; decoratedShape.draw(); fillColor(color); &#125; /** * 扩展的功能：填充颜色 * @param color 实际开发中使用Color对象或int */ private void fillColor(String color) &#123; System.out.println("filling Color: " + color); &#125;&#125;/** * 测试 */ public class DecoratorTest &#123; public static void main(String[] args) &#123; Shape circle = new Circle(); Shape redCircle = new FillShapeDecorator(new Circle(), "red"); Shape redRectangle = new FillShapeDecorator(new Rectangle(), "blue"); System.out.println("Circle with normal color"); circle.draw(); System.out.println("\nCircle of red background"); redCircle.draw(); System.out.println("\nRectangle of blue background"); redRectangle.draw(); &#125;&#125; 输出：Circle with normal colorShape: Circle Circle of red backgroundShape: Circlefilling Color: red Rectangle of blue backgroundShape: Rectanglefilling Color: blue]]></content>
      <categories>
        <category>DESIGN PATTERN</category>
      </categories>
      <tags>
        <tag>DESIGN PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DESIGN PATTERN | Adapter 适配器设计模式]]></title>
    <url>%2F2017%2F01%2F06%2FPATTERN%2FDesign%20pattern%20%E9%80%82%E9%85%8D%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[返回设计模式目录 适配器模式适配器模式将某个类的接口转换成客户端期望的另一个接口表示，这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本读取内存卡。 应用实例1、美国电器110V，中国220V，就要有一个适配器将110V转化为220V。2、JAVA JDK 1.1 提供了Enumeration接口，而在1.2中提供了Iterator接口，想要使用1.2的JDK，则要将以前系统的Enumeration接口转化为Iterator接口，这时就需要适配器模式。3、在 LINUX 上运行 WINDOWS 程序。4、JAVA 中的 jdbc。 关键代码适配器继承或依赖已有的对象，实现想要的目标接口。建议使用依赖。 实例演示实例：音频播放器设备只能播放mp3文件，通过使用一个更高级的音频播放器来播放vlc和mp4文件。分析：要有一个MediaPlayer接口及其实体类AudioPlayer。默认情况下，AudioPlayer可以播放mp3格式的音频文件。另外还要有一个接口AdvancedMediaPlayer及其实体类VlcPlayer、Mp4Player，分别可以播放vlc和mp4格式的文件。现在想让AudioPlayer播放其他格式的音频文件，就需要创建一个实现了MediaPlayer接口的适配器类MediaAdapter，并使用AdvancedMediaPlayer对象来播放所需的格式。 1、接口：为媒体播放器、更高级的媒体播放器1234567891011121314/** * 接口：媒体播放器 */public interface MediaPlayer &#123; public void play(String audioType, String fileName);&#125;/** * 接口：更高级的媒体播放器 */public interface AdvancedMediaPlayer &#123; public void playVlc(String fileName); public void playMp4(String fileName);&#125; 2、实现类：实现AdvanceMediaPlayer接口的子类（VlcPlayer、Mp4Player）1234567891011121314151617181920212223242526272829/** * 播放器：可播放Vlc格式 */public class VlcPlayer implements AdvancedMediaPlayer &#123; @Override public void playVlc(String fileName) &#123; System.out.println("Playing vlc file. Name: "+ fileName); &#125; @Override public void playMp4(String fileName) &#123; // nothing to do &#125;&#125;/** * 播放器：可播放Mp4格式 */public class Mp4Player implements AdvancedMediaPlayer &#123; @Override public void playVlc(String fileName) &#123; // nothing to do &#125; @Override public void playMp4(String fileName) &#123; System.out.println("Playing mp4 file. Name: "+ fileName); &#125;&#125; 3、创建实现了MediaPlayer接口的适配器类1234567891011121314151617181920212223/** * 适配器：实现MediaPlayer，持有AdvancedMediaPlayer实现类，即将二者关联起来。 */public class MediaAdapter implements MediaPlayer &#123; private AdvancedMediaPlayer advancedMusicPlayer; // 依赖 public MediaAdapter(String audioType) &#123; if (audioType.equalsIgnoreCase("vlc")) &#123; advancedMusicPlayer = new VlcPlayer(); &#125; else if (audioType.equalsIgnoreCase("mp4")) &#123; advancedMusicPlayer = new Mp4Player(); &#125; &#125; @Override public void play(String audioType, String fileName) &#123; if (audioType.equalsIgnoreCase("vlc")) &#123; advancedMusicPlayer.playVlc(fileName); &#125; else if (audioType.equalsIgnoreCase("mp4")) &#123; advancedMusicPlayer.playMp4(fileName); &#125; &#125;&#125; 4、创建实现了MediaPlayer接口的实体类AudioPlayer123456789101112131415161718/** * MediaPlayer的实现类，持有适配器后扩展功能。 */public class AudioPlayer implements MediaPlayer &#123; private MediaAdapter adapter; @Override public void play(String audioType, String fileName) &#123; if (audioType.equalsIgnoreCase("mp3")) &#123; // 内置的可以播放mp3的功能 System.out.println("Playing mp3 file. Name: " + fileName); &#125; else if (audioType.equalsIgnoreCase("vlc") || audioType.equalsIgnoreCase("mp4")) &#123; adapter = new MediaAdapter(audioType); // mediaAdapter提供了播放其他文件格式的支持 adapter.play(audioType, fileName); &#125; else &#123; System.out.println("Invalid media. " + audioType + " format not supported"); &#125; &#125;&#125; 5、测试123456789public class AdapterTest &#123; public static void main(String[] args) &#123; AudioPlayer audioPlayer = new AudioPlayer(); audioPlayer.play("mp3", "beyond the horizon.mp3"); audioPlayer.play("mp4", "alone.mp4"); audioPlayer.play("vlc", "far far away.vlc"); audioPlayer.play("avi", "mind me.avi"); &#125;&#125; 6、输出Playing mp3 file. Name: beyond the horizon.mp3Playing mp4 file. Name: alone.mp4Playing vlc file. Name: far far away.vlcInvalid media. avi format not supported 其他详解有人将适配器模式详细分为三种：类的适配器模式、对象的适配器模式、接口的适配器模式。 1、类的适配器模式有一个Source类，拥有一个方法，待适配，目标接口是Targetable，通过Adapter类，将Source的功能扩展到Targetable里，看代码：12345678910111213141516171819202122232425262728public class Source &#123; public void method1() &#123; System.out.println("this is original method!"); &#125;&#125;public interface Targetable &#123; public void method1(); // 与原类中的方法相同 public void method2(); // 新类的方法&#125; /** * Adapter类继承Source类，实现Targetable接口 */public class ClassAdapter extends Source implements Targetable &#123; @Override public void method2() &#123; System.out.println("this is the targetable method!"); &#125;&#125;public class AdapterTest &#123; public static void main(String[] args) &#123; Targetable target = new ClassAdapter(); target.method1(); target.method2(); &#125;&#125; 输出：this is original method!this is the targetable method! 这样Targetable接口的实现类就具有了Source类的功能。 2、对象的适配器模式基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。1234567891011121314151617181920212223242526272829303132/** * ObjectAdapter替换ClassAdapter */public class ObjectAdapter implements Targetable &#123; private Source source; public ObjectAdapter(Source source)&#123; super(); this.source = source; &#125; @Override public void method1() &#123; source.method1(); &#125; @Override public void method2() &#123; System.out.println("this is the targetable method!"); &#125; &#125;/** * 测试代码略作修改 */public class AdapterTest &#123; public static void main(String[] args) &#123; Targetable target = new ObjectAdapter(new Source()); target.method1(); target.method2(); &#125; &#125; 输出与第一种一样，只是适配的方法不同而已。 3、接口的适配器模式有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 原始接口有很多方法 */public interface Sourceable &#123; public void method1(); public void method2(); public void method3(); &#125; /** * 借助抽象类作为适配器 */ public abstract class SourceableAdapter implements Sourceable&#123; public void method1()&#123;&#125; public void method2()&#123;&#125; public void method3()&#123;&#125;&#125; /** * 适配器将子类所需要实现的方法减少 */ public class SourceSub1 extends SourceableAdapter &#123; public void method1()&#123; System.out.println("the sourceable interface's first Sub1!"); &#125; &#125;/** * 适配器将子类所需要实现的方法减少 */ public class SourceSub2 extends SourceableAdapter &#123; public void method1()&#123; System.out.println("the sourceable interface's second Sub2!"); &#125; &#125;public class AdapterTest &#123; public static void main(String[] args) &#123; Sourceable source1 = new SourceSub1(); Sourceable source2 = new SourceSub2(); source1.method1(); source1.method2(); source2.method1(); source2.method2(); &#125; &#125; 测试输出：the sourceable interface’s first Sub1!the sourceable interface’s second Sub2! 类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Adapter类，持有原类的一个实例，在Adapter类的方法中，调用实例的方法就行。接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter，实现所有方法，我们写别的类的时候，继承抽象类即可。]]></content>
      <categories>
        <category>DESIGN PATTERN</category>
      </categories>
      <tags>
        <tag>DESIGN PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DESIGN PATTERN | Prototype 原型设计模式]]></title>
    <url>%2F2017%2F01%2F05%2FPATTERN%2FDesign%20pattern%20%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[返回设计模式目录 原型模式该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象，同时又能保证性能。在JAVA中，复制对象是通过clone()实现的。 使用场景：1、资源优化场景。2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。3、性能和安全要求的场景。4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。5、一个对象多个修改者的场景。6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。123456789101112131415161718192021/** * 原型类，只需要实现Cloneable空接口 */public class Prototype implements Cloneable &#123; /** * 覆写clone方法 */ @Override protected Object clone() throws CloneNotSupportedException &#123; Prototype prototype = (Prototype) super.clone(); return prototype; &#125; /** * 自定义方法，也能克隆。重点是super.clone(); */ protected Object clonePrototype() throws CloneNotSupportedException &#123; Prototype prototype = (Prototype) super.clone(); return prototype; &#125;&#125; 一个原型类，只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如clonePrototype，因为此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法，而在Object类中，clone()是native的，具体怎么实现暂不深究。 深浅复制。复制又分浅复制、深复制：浅复制：将一个对象复制后，克隆的对象引用与原型对象引用不相同。其基本数据类型变量的值相同，而引用类型变量指向的还是原对象所指向的。深复制：将一个对象复制后，克隆的对象引用与原型对象引用不相同。其基本数据类型变量的值相同，而引用类型变量指向的不是原对象所指向的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * 原型类，测试深浅复制 */public class Prototype implements Cloneable, Serializable &#123; private static final long serialVersionUID = 1L; private int num; // 基本数据类型 private SerializableObject obj; // 引用类型 public Prototype(int num, SerializableObject obj) &#123; this.num = num; this.obj = obj; &#125; /** * 浅复制 */ @Override protected Object cone() throws CloneNotSupportedException &#123; Prototype prototype = (Prototype) super.clone(); return prototype; &#125; /** * 深复制 * 要实现深复制，需要采用流的形式读入当前对象的二进制输入，再写出二进制数据对应的对象。（暂不考虑关闭流） */ protected Object deepClone() throws IOException, ClassNotFoundException &#123; /* 写入当前对象的进制流 */ ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); /* 读出二进制流产生的新对象 */ ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())); return ois.readObject(); &#125; public int getNum() &#123; return num; &#125; public void setNum(int num) &#123; this.num = num; &#125; public SerializableObject getObj() &#123; return obj; &#125; public void setObj(SerializableObject obj) &#123; this.obj = obj; &#125;&#125;class SerializableObject implements Serializable &#123; private static final long serialVersionUID = 2L;&#125;/** * 测试原型模式中的深浅复制 */public class PrototypeTest &#123; public static void main(String[] args) throws Exception &#123; Prototype prototype = new Prototype(1, new SerializableObject()); Prototype shallowPrototype = (Prototype) prototype.shallowClone(); // 浅复制 Prototype deepPrototype = (Prototype) prototype.deepClone(); // 深复制 System.out.println(prototype == shallowPrototype); // false 浅复制比较克隆对象与原型对象是否指向相同地址 System.out.println(prototype.getNum() == shallowPrototype.getNum());// true 浅复制比较基本数据类型 System.out.println(prototype.getObj() == shallowPrototype.getObj());// true 浅复制比较引用数据类型 System.out.println(prototype == deepPrototype); // false 深复制比较克隆对象与原型对象是否指向相同地址 System.out.println(prototype.getNum() == deepPrototype.getNum()); // true 深复制比较基本数据类型 System.out.println(prototype.getObj() == deepPrototype.getObj()); // false 深复制比较引用数据类型 &#125;&#125; 与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现Serializable读取二进制流。]]></content>
      <categories>
        <category>DESIGN PATTERN</category>
      </categories>
      <tags>
        <tag>DESIGN PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DESIGN PATTERN | Builder 建造者设计模式]]></title>
    <url>%2F2017%2F01%2F04%2FPATTERN%2FDesign%20pattern%20%E5%BB%BA%E9%80%A0%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[返回设计模式目录 建造者模式使用多个简单的对象一步一步构建成一个复杂的对象。将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。也就是说当一些有共性的基本部件不会变，而其组合经常变化，此时使用建造者模式。 现实案例肯德基快餐店提供一个典型的套餐：一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（Coke）或百事可乐（Pepsi），它们是装载瓶子中。使用建造者模式创建不同的套餐。 代码实现创建一个食物条目接口Item，以及实现Item接口的实体类（汉堡和冷饮）；然后表示一个食物包装接口Packing，以及实现Packing接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中；然后创建一个Meal（餐）类，套餐用一些实现Item接口对象的集合；最后就是负责通过不同的Item子类组合来创建不同的Meal对象的MealBuilder。下面就是演示用MealBuilder（建造者）创建一个Meal（套餐）。 1、创建接口：食物包装、食物条目123456789101112131415/** * 接口：食物包装 */public interface Packing &#123; public String pack(); // 包装方式&#125;/** * 接口：食物条目 */public interface Item &#123; public String name(); // 食物名称 public Packing packing(); // 包装方式 public float price(); // 食物价格&#125; 2、创建实现Packing接口的实现类：纸包、瓶装12345678910111213141516171819/** * 用纸包装 */public class Wrapper implements Packing &#123; @Override public String pack() &#123; return "Wrapper"; &#125;&#125;/** * 用瓶包装 */public class Bottle implements Packing &#123; @Override public String pack() &#123; return "Bottle"; &#125;&#125; 3、创建实现Item接口的抽象类并提供默认功能：汉堡（纸包）、冷饮（瓶装）。1234567891011121314151617181920212223/** * 抽象类汉堡，默认纸包 */public abstract class Burger implements Item &#123; @Override public Packing packing() &#123; return new Wrapper(); &#125; @Override public abstract float price();&#125;/** * 抽象类冷饮，默认瓶装 */public abstract class ColdDrink implements Item &#123; @Override public Packing packing() &#123; return new Bottle(); &#125; @Override public abstract float price();&#125; 4、创建扩展Burger和ColdDrink的实体类：VerBurger（素食汉堡）、ChickenBurger（鸡肉汉堡）、Coke（可口可乐）、Pepsi（百事可乐）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 素食汉堡 */public class VerBurger extends Burger &#123; @Override public String name() &#123; return "VerBurger"; &#125; @Override public float price() &#123; return 25.0f; &#125;&#125;/** * 鸡肉汉堡 */public class ChickenBurger extends Burger &#123; @Override public String name() &#123; return "Chicken Burger"; &#125; @Override public float price() &#123; return 50.0f; &#125;&#125;/** * 可口可乐 */public class Coke extends ColdDrink &#123; @Override public String name() &#123; return "Coke"; &#125; @Override public float price() &#123; return 30.0f; &#125;&#125;/** * 百事可乐 */public class Pepsi extends ColdDrink &#123; @Override public String name() &#123; return "Pepsi"; &#125; @Override public float price() &#123; return 35.0f; &#125;&#125; 5、创建Meal类，包含上面定义的Item子类对象。1234567891011121314151617181920212223242526/** * 套餐 */public class Meal &#123; private List&lt;Item&gt; items = new ArrayList&lt;&gt;(); public void addItem(Item item) &#123; // 添加食物 items.add(item); &#125; public float getCost() &#123; // 套餐总价 float cost = 0.0f; for (Item item : items) cost += item.price(); return cost; &#125; public void showItems() &#123; // 展示餐单 for (Item item : items) &#123; System.out.print("Item : " + item.name()); System.out.print(", Packing : " + item.packing().pack()); System.out.println(", Price : " + item.price()); &#125; System.out.println("Total Cost : " + getCost()); &#125;&#125; 6、创建MealBuilder类，负责创建Meal对象123456789101112131415161718/** * 创建套餐的建造者（MealBuilder） */public class MealBuilder &#123; public Meal prepareVegMeal() &#123; Meal meal = new Meal(); meal.addItem(new VerBurger()); meal.addItem(new Coke()); return meal; &#125; public Meal prepareNoVegMeal() &#123; Meal meal = new Meal(); meal.addItem(new ChickenBurger()); meal.addItem(new Pepsi()); return meal; &#125;&#125; 7、测试12345678910111213141516/** * 测试类 */public class BuilderTest &#123; public static void main(String[] args) &#123; MealBuilder mealBuilder = new MealBuilder(); Meal vegMeal = mealBuilder.prepareVegMeal(); System.out.println("Veg Meal"); vegMeal.showItems(); Meal nonVegMeal = mealBuilder.prepareNonVegMeal(); System.out.println("\n\nNon-Veg Meal"); nonVegMeal.showItems(); &#125;&#125; 8、输出12345678910Veg MealItem : Ver Burger, Packing : Wrapper, Price : 25.0Item : Coke, Packing : Bottle, Price : 30.0Total Cost : 55.0Non-Veg MealItem : Chicken Burger, Packing : Wrapper, Price : 50.0Item : Pepsi, Packing : Bottle, Price : 35.0Total Cost : 85.0 从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。所以与工厂模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。因此，是选择工厂模式还是建造者模式，依实际情况而定。]]></content>
      <categories>
        <category>DESIGN PATTERN</category>
      </categories>
      <tags>
        <tag>DESIGN PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DESIGN PATTERN | Singleton 单例]]></title>
    <url>%2F2017%2F01%2F03%2FPATTERN%2FDesign%20pattern%20%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[返回设计模式目录 单例模式最简洁的单例：1234567891011/** * 饿汉式 * @author xianxiaotao */public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton() &#123;&#125; public static Singleton getInstance() &#123; return instance; &#125;&#125; 上述代码中，随着类的加载就持有对象，由于static修饰，则将常驻内存。为此，可做如下修改： 12345678910111213/** * 懒汉式 * @author xianxiaotao */public class Singleton &#123; private static Singleton instance = null; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (null == instance) instance = new Singleton(); return instance; &#125;&#125; 修改之后，可以减少对象入驻内存时间，但是在多线程中不能保证只创建了一个对象。我们可以使用synchronized来规避风险。 12345public static synchronized Singleton getInstance() &#123; if (null == instance) instance = new Singleton(); return instance;&#125; 用synchronized修饰方法，这将因每次调用getInstance()都要对对象上锁，从而导致性能下降。事实上，只有在第一次创建对象的时候需要加锁，之后就不需要了，所以，这个地方需要改进。 12345678public static Singleton getInstance() &#123; if (null == instance) synchronized (Singleton.class) &#123; if (null == instance) instance = new Singleton(); &#125; return instance;&#125; 双重判断，即可规避每次都要加锁。然而，为了保证对象的唯一性，我们需要借助序列化与反序列化来存储对象，但这样会破坏单例。 完美单例123456789101112131415161718192021222324252627/** * 完美的单例 * final：禁止被继承 * readResolve：防止被序列化与反序列化破坏单例 * * @author xianxiaotao */public final class Singleton implements Serializable &#123; private static final long serialVersionUID = -7316915605453163797L; private static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (null == instance) synchronized (Singleton.class) &#123; if (null == instance) instance = new Singleton(); &#125; return instance; &#125; private Object readResolve() &#123; return instance; &#125;&#125; 完美只是相对于之前的代码，笔者对于反射破坏单例而束手无策。 饿汉式变异使用一个静态内部类来维护单例12345678910111213/** * 饿汉式 * @author xianxiaotao */public class Singleton &#123; private static class SingletonFactory &#123; private static final Singleton instance = new Singleton(); &#125; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; return SingletonFactory.instance; &#125;&#125;]]></content>
      <categories>
        <category>DESIGN PATTERN</category>
      </categories>
      <tags>
        <tag>DESIGN PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DESIGN PATTERN | Factory 工厂方法模式和抽象工厂模式]]></title>
    <url>%2F2017%2F01%2F01%2FPATTERN%2FDesign%20pattern%20%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[返回设计模式目录 一、工厂方法模式建立一个工厂类，对实现了同一接口的一些类进行实例的创建。可以模拟一个场景：生活中需要装载机器（Loader），载人的有汽车（Car），载货的有货车（Truck）,而这些可以由一个工厂（LoaderFactory）生产（produce）。根据订单要求（参数）来生产不同的装载机。 普通工厂方法模式1、同一的接口123456/** * 接口：装载 */public interface Loader &#123; public void load();&#125; 2、实现装载接口的类12345678910111213141516171819/** * 实现装载接口：载人 */public class Car implements Loader &#123; @Override public void load() &#123; System.out.println("load person"); &#125;&#125;/** * 实现装载接口：载货 */public class Truck implements Loader &#123; @Override public void load() &#123; System.out.println("load goods"); &#125;&#125; 3、工厂类123456789101112131415/** * 工厂：根据订单要求（参数）来生产不同的装载机 */public class LoaderFactory &#123; public Loader produce(String type) &#123; if ("Car".equalsIgnoreCase(type)) &#123; return new Car(); &#125; else if ("Truck".equalsIgnoreCase(type)) &#123; return new Truck(); &#125; else &#123; System.out.println("请输入正确的类型"); return null; &#125; &#125;&#125; 4、测试123456789public class FactoryTest &#123; public static void main(String[] args) &#123; LoaderFactory factory = new LoaderFactory(); Loader carLoader = factory.produce("car"); Loader truckLoader = factory.produce("truck"); carLoader.load(); truckLoader.load(); &#125;&#125; 5、输出：load personload goods 多个工厂方法模式这是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。1234567891011/** * 工厂类，以多个方法代替字符串参数判定 */public class LoaderFactory &#123; public Loader produceCar() &#123; return new Car(); &#125; public Loader produceTruck() &#123; return new Truck(); &#125;&#125; 测试123456789public class FactoryTest &#123; public static void main(String[] args) &#123; LoaderFactory factory = new LoaderFactory(); Loader carLoader = factory.produceCar(); Loader truckLoader = factory.produceTruck(); carLoader.load(); truckLoader.load(); &#125;&#125; 输出：load personload goods 静态工厂方法模式——建议使用将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。123456789101112/** * 工厂类，静态方法，禁止实例化工厂对象 */public class LoaderFactory &#123; private LoaderFactory() &#123;&#125; // 禁止实例化 public static Loader produceCar() &#123; return new Car(); &#125; public static Loader produceTruck() &#123; return new Truck(); &#125;&#125; 测试123456public class FactoryTest &#123; public static void main(String[] args) &#123; LoaderFactory.produceCar().load(); LoaderFactory.produceTruck().load(); &#125;&#125; 输出：load personload goods 总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。 二、抽象工厂模式工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。可以模拟一个场景：生活中需要载货机器（Loader），陆地载货的有火车（Train），水上载货的有货轮（Ship）,而这些可以由专门的工厂（实现Provider的工厂类：TrainLoaderFactory、ShipLoaderFactory）生产（produce）不同的装载器。12345678910111213141、载货接口和工厂接口/** * 载货接口：火车、货轮、飞机实现此接口才能载货 */public interface Loader &#123; public void loading();&#125;/** * 工厂接口：所有的工厂必须能生产载货机器，生产具体的机器由子类实现 */public interface Provider &#123; public Loader producing();&#125; 2、载货的机器：火车、货轮12345678910111213141516171819/** * 火车载货 */public class TrainLoader implements Loader &#123; @Override public void loading() &#123; System.out.println("This train conveys goods."); &#125;&#125;/** * 货轮载货 */public class ShipLoader implements Loader &#123; @Override public void loading() &#123; System.out.println("This Ship conveys goods."); &#125;&#125; 3、专门生产不同方式载货机器的工厂12345678910111213141516171819/** * 专门生产陆地载货的火车制造工厂 */public class TrainLoaderFactory implements Provider &#123; @Override public Loader producing() &#123; return new TrainLoader(); &#125;&#125;/** * 专门生产水上载货的货轮制造工厂 */public class ShipLoaderFactory implements Provider &#123; @Override public Loader producing() &#123; return new ShipLoader(); &#125;&#125; 4、测试及输出123456public class FactoryTest &#123; public static void main(String[] args) &#123; new TrainLoaderFactory().producing().loading(); new ShipLoaderFactory().producing().loading(); &#125;&#125; This train conveys goods.This Ship conveys goods. 其实这个模式的好处就是，如果你现在想增加一个功能：空中载货，则只需做一个实现类（PlaneLoader），实现Loader接口，同时做一个工厂类（PlaneLoaderFactory），实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！]]></content>
      <categories>
        <category>DESIGN PATTERN</category>
      </categories>
      <tags>
        <tag>DESIGN PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DESIGN PATTERN | List]]></title>
    <url>%2F2017%2F01%2F01%2FPATTERN%2FDesign%20pattern%2F</url>
    <content type="text"><![CDATA[JAVA设计模式目录（23种）创建型模式：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。结构型模式：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。行为型模式：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 参考链接一参考链接二]]></content>
      <categories>
        <category>DESIGN PATTERN</category>
      </categories>
      <tags>
        <tag>DESIGN PATTERN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ANDROID | 工具类]]></title>
    <url>%2F2016%2F10%2F24%2FANDROID%2FANDROID%20%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[常用工具类： L.java 日志 一、日志工具类(L.java)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.xxt.util;import android.util.Log;/** * Log统一管理类 * isDebug 控制是否输出日志 * level 控制输出日志等级 * LV: VERBOSE * LD: DEBUG * LI: INFO * LW: WARN * LE: ERROR * * Created by xianxiaotao on 17/3/2. */public class L &#123; private static final String TAG = "LOG"; // 输出日志等级 public static final int LV = 1; public static final int LD = 2; public static final int LI = 3; public static final int LW = 4; public static final int LE = 5; /** * 输出日志总开关，可以在Application的onCreate方法中初始化 */ public static boolean isDebug = true; /** * 输出日志等级，值为LV，则输出所有日志，值为LE，则只输出Error日志 */ public static int level = LV; private L() &#123;&#125; /* cannot be instantiated */ public static void v(String msg) &#123; if (isDebug &amp;&amp; level &lt;= LV) Log.v(TAG, msg); &#125; public static void d(String msg) &#123; if (isDebug &amp;&amp; level &lt;= LD) Log.d(TAG, msg); &#125; public static void i(String msg) &#123; if (isDebug &amp;&amp; level &lt;= LI) Log.i(TAG, msg); &#125; public static void w(String msg) &#123; if (isDebug &amp;&amp; level &lt;= LW) Log.w(TAG, msg); &#125; public static void e(String msg) &#123; if (isDebug &amp;&amp; level &lt;= LE) Log.e(TAG, msg); &#125; public static void v(String tag, String msg) &#123; if (isDebug &amp;&amp; level &lt;= LV) Log.v(tag, msg); &#125; public static void d(String tag, String msg) &#123; if (isDebug &amp;&amp; level &lt;= LD) Log.d(tag, msg); &#125; public static void i(String tag, String msg) &#123; if (isDebug &amp;&amp; level &lt;= LI) Log.i(tag, msg); &#125; public static void w(String tag, String msg) &#123; if (isDebug &amp;&amp; level &lt;= LW) Log.w(tag, msg); &#125; public static void e(String tag, String msg) &#123; if (isDebug &amp;&amp; level &lt;= LE) Log.e(tag, msg); &#125;&#125;]]></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
        <tag>util</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ANDROID | 动态权限]]></title>
    <url>%2F2016%2F10%2F23%2FANDROID%2FANDROID%206.0%20%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[在Android6.0及以上版本中，即使在AndroidManifest.xml文件里配置了如下权限：1&lt;uses-permission android:name="android.permission.CALL_PHONE"/&gt; 运行时会也会报错：java.lang.SecurityException: Permission Denial: starting Intent { act=android.intent.action.CALL dat=tel:xxxxxx cmp=com.android.server.telecom/.components.UserCallActivity } from ProcessRecord{ece7708 3894:com.test.xianxiaotao.test/u0a79} (pid=3894, uid=10079) with revoked permission android.permission.CALL_PHONE 这是因为Android6.0及以上版本增添了动态权限。在哪个页面需要这个权限只需要直接去请求就行了，而且还有了相应的监听的方法供你来判断。具体使用参考如下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MainActivity extends AppCompatActivity &#123; private EditText editText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 动态请求权限 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.CALL_PHONE&#125;, 0x11); editText = (EditText) findViewById(R.id.editText); &#125; /** * 拨打 * @param v 触发监听事件的view */ public void call(View v) &#123; String number = editText.getText().toString(); if (null == number || number.length() == 0) return; Intent intent = new Intent(); intent.setAction(Intent.ACTION_CALL); intent.setData(Uri.parse("tel://" + number)); startActivity(intent); &#125; /** * 监听权限是否允许 * @param requestCode * @param permissions * @param grantResults */ @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode == 0x11) &#123; if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) Log.i("CMCC", "权限被允许"); else Log.i("CMCC", "权限被拒绝"); &#125; &#125;&#125; 运行结果： 使用权限的页面中弹出提示框并被允许，则以后不再弹出。]]></content>
      <categories>
        <category>ANDROID</category>
      </categories>
      <tags>
        <tag>ANDROID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA | 多线程断点下载]]></title>
    <url>%2F1900%2F03%2F03%2F00JAVA%2FJAVA%20%7C%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%AD%E7%82%B9%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[基本原理：利用URLConnection获取要下载文件的长度、头部等相关信息，并设置响应的头部信息。并且通过URLConnection获取输入流，将文件分成指定的块，每一块单独开辟一个线程完成数据的读取、写入。通过输入流读取下载文件的信息，然后将读取的信息用RandomAccessFile随机写入到本地文件中。同时，每个线程写入的数据都文件指针也就是写入数据的长度，需要保存在一个临时文件中。这样当本次下载没有完成的时候，下次下载的时候就从这个文件中读取上一次下载的文件长度，然后继续接着上一次的位置开始下载。并且将本次下载的长度写入到这个文件中。 最简单的下载代码：12345678910111213141516171819202122232425262728293031package com.xian.blog;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.FileOutputStream;import java.net.HttpURLConnection;import java.net.URL;public class SimpleDownload &#123; public static void main(String[] args) &#123; try &#123; URL url = new URL("http://ww1.sinaimg.cn/large/adc90466gy1fcptk0wnt2j20e90ifmz4"); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setConnectTimeout(3000); int code = conn.getResponseCode(); if (200 == code) &#123; BufferedInputStream in = new BufferedInputStream(conn.getInputStream()); BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream("/Users/xianxiaotao/desktop/activitylife.png")); byte[] buf = new byte[1024]; int len = -1; while (-1 != (len = in.read(buf))) out.write(buf, 0, len); in.close(); out.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 上述代码简易，但不适合大型文件下载。 多线程断点下载代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package com.xian.blog;import java.io.BufferedInputStream;import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;import java.net.HttpURLConnection;import java.net.URL;public class XDownloadTask extends Thread&#123; private static final String DIR_PATH = "/Users/xianxiaotao/downloads"; // 下载目录 private static final int THREAD_AMOUNT = 3; // 总线程数 private URL url; // 目标下载地址 private File dataFile; // 本地文件 private File tempFile; // 存储线程下载进度的临时文件 private long totalLength; // 服务端文件总长度 private long threadLenght; // 每个线程要下载的长度 private long totalFinish; // 记录：总共完成了多少 private long begin; // 用来记录下载开始时间 public XDownloadTask(String address) throws IOException &#123; url = new URL(address); // 记住下载地址 dataFile = new File(DIR_PATH, address.substring(address.lastIndexOf("/") + 1)); // 截取地址中的文件名，创建本地文件 tempFile = new File(dataFile.getAbsolutePath() + ".temp"); // 在本地文件所在文件夹中创建临时文件 &#125; public void run() &#123; try &#123; HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setConnectTimeout(10000); totalLength = conn.getContentLength(); // 获取服务端发送过来的文件长度 threadLenght = (totalLength + THREAD_AMOUNT - 1) / THREAD_AMOUNT; // 计算每个线程要下载的长度 if (!tempFile.exists()) &#123; // 如果临时文件不存在 RandomAccessFile raf = new RandomAccessFile(tempFile, "rw"); // 创建临时文件，用来记录每个线程已下载多少 for (int i = 0; i &lt; THREAD_AMOUNT; i++) raf.writeInt(0); raf.close(); &#125; for (int i = 0; i &lt; THREAD_AMOUNT; i++) // 按线程数循环 new DownloadThread(i).start(); // 开启线程，每个线程将会下载一部分数据到本地文件中 begin = System.currentTimeMillis(); // 记录开始时间 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private class DownloadThread extends Thread &#123; private int id; // 用来标记当前线程是下载任务中的第几个线程 public DownloadThread(int id) &#123; this.id = id; &#125; public void run() &#123; try &#123; RandomAccessFile tempRaf = new RandomAccessFile(tempFile, "rws"); // 记录进度的临时文件 tempRaf.seek(id * 4); // 将指针移动到当前线程的位置 int threadFinish = tempRaf.readInt(); // 读取当前线程已完成了多少 synchronized(XDownloadTask.this) &#123; // 多个下载线程之间同步 totalFinish += threadFinish; // 统计所有线程总共完成了多少 &#125; long start = id * threadLenght + threadFinish; // 计算当前线程起始位置 long end = id * threadLenght + threadLenght - 1; // 计算当前线程结束位置 System.out.println("线程" + id + ": " + start + "-" + end); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setConnectTimeout(10000); conn.setRequestProperty("Range", "bytes=" + start + "-" + end); // 设置当前线程下载的范围 BufferedInputStream in = new BufferedInputStream(conn.getInputStream());// 获取连接的输入流 RandomAccessFile dataRaf = new RandomAccessFile(dataFile, "rws"); // 保存数据的本地文件 dataRaf.seek(start); // 设置当前线程保存数据的位置 byte[] buf = new byte[1024]; int len = -1; while (-1 != (len = in.read(buf))) &#123; dataRaf.write(buf, 0, len); threadFinish += len; tempRaf.seek(id * 4); tempRaf.writeInt(threadFinish); // 将当前线程完成了多少写入到临时文件 synchronized (XDownloadTask.this) &#123; totalFinish += len; &#125; &#125; dataRaf.close(); tempRaf.close(); System.out.println("线程" + id + "下载完毕"); if (totalFinish == totalLength) &#123; System.out.println("下载完成，耗时：" + (System.currentTimeMillis() - begin)); tempFile.delete(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) throws IOException &#123; new XDownloadTask("http://ww1.sinaimg.cn/large/adc90466gy1fcptk0wnt2j20e90ifmz4").start(); &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA | equals 的正确姿势]]></title>
    <url>%2F1900%2F03%2F02%2F00JAVA%2FJAVA%20%7C%20equals%20%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[职员（Employee）及其子类（Manager），当判断对象是否等同取决于所有属性时，建议使用1if (getClass() != otherObject.getClass()) return false; 而不是1if (!(otherObject instanceof Employee)) return false; 如果当父类能够明确判断对象是否相同的条件时，可以使用instanceof。比如，实际中职员都有一个唯一ID，只要id相同即是同一个职员。那么将父类Employee的equals方法设计为判断ID值是否相同即可，当然hashCode方法也要由id来决定。1234567891011121314@Overridepublic int hashCode() &#123; return Objects.hash(this.id);&#125;@Overridepublic boolean equals(Object otherObject) &#123; if (this == otherObject) return true; if (otherObject == null) return false; if (!(otherObject instanceof Employee)) return false; Employee other = (Employee) otherObject; return this.id == other.id;&#125; 全部代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class Employee &#123; private String name; private double salary; private LocalDate hireDay; public Employee(String name, double salary, int year, int month, int day) &#123; this.name = name; this.salary = salary; this.hireDay = LocalDate.of(year, month, day); &#125; public String getName() &#123; return this.name; &#125; public double getSalary() &#123; return this.salary; &#125; public LocalDate getHireDay() &#123; return this.hireDay; &#125; public void raiseSalary(double byPercent) &#123; double raise = this.salary * byPercent / 100; this.salary += raise; &#125; @Override public int hashCode() &#123; return Objects.hash(this.name, this.salary, this.hireDay); &#125; @Override public boolean equals(Object otherObject) &#123; if (this == otherObject) return true; if (otherObject == null) return false; if (getClass() != otherObject.getClass()) return false; Employee other = (Employee) otherObject; return Objects.equals(this.name, other.name) &amp;&amp; this.salary == other.salary &amp;&amp; Objects.equals(this.hireDay, other.hireDay); &#125; @Override public String toString() &#123; return getClass().getName() + " [name=" + name + ", salary=" + salary + ", hireDay=" + hireDay + "]"; &#125;&#125;class Manager extends Employee &#123; private double bonus; public Manager(String name, double salary, int year, int month, int day) &#123; super(name, salary, year, month, day); bonus = 0; &#125; public void setBonus(double bonus) &#123; this.bonus = bonus; &#125; public double getSalary() &#123; double baseSalary = super.getSalary(); return baseSalary + bonus; &#125; @Override public int hashCode() &#123; return super.hashCode() + 17 * Double.hashCode(bonus); &#125; @Override public boolean equals(Object otherObject) &#123; if (!super.equals(otherObject)) return false; Manager other = (Manager) otherObject; return bonus == other.bonus; &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA | 使用克隆防止破坏封装性]]></title>
    <url>%2F1900%2F03%2F01%2F00JAVA%2FJAVA%20%7C%20%E4%BD%BF%E7%94%A8%E5%85%8B%E9%9A%86%E9%98%B2%E6%AD%A2%E7%A0%B4%E5%9D%8F%E5%B0%81%E8%A3%85%E6%80%A7%2F</url>
    <content type="text"><![CDATA[请先看一个案例：12345678910111213141516/** * 职员类 * * @author xianxiaotao */public class Employee &#123; private Date hireDay; public Employee(Date hireDay) &#123; this.hireDay = hireDay; &#125; public Date getHireDay() &#123; return this.hireDay; // bad coding &#125;&#125; 职员，受雇日期是固定不变的，即使将属性设置为私有，依然可以使用这段代码直接将职员工龄增加10年：1234Employee harry = new Employee(new Date());Date d = harry.getHireDay();double tenYearsInMilliSeconds = 10 * 365.25 * 24 * 60 * 60 * 1000;d.setTime(d.getTime() - (long) tenYearsInMilliSeconds); 如果需要返回一个可变对象的引用，应该首先对它进行克隆（clone），代码修改如下：123public Date getHireDay() &#123; return (Date) hireDay.clone();// Ok&#125; 建议使用LocalDate代替Date]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA | java8之Lambda]]></title>
    <url>%2F1900%2F02%2F03%2F00JAVA%2FJAVA%208%20Lambda%2F</url>
    <content type="text"><![CDATA[一、基本语法Java是一种面向对象语言，所以必须构造一个对象，这个对象的类需要有一个方法能包含所需的代码。如下：12345678class LengthComparator implements Comparator&lt;String&gt; &#123; public int compare(String first, String second) &#123; return first.length - second.first; &#125;&#125;// usesArrays.sort(strings, new LengthComparator()); 如果使用Lambda表达式，则使用代码更改为：1Arrays.sort(strings, (String first, String second) -&gt; &#123; return first.length - second.first; &#125;)); 简化在这里，编译器可以推导出first和second必然是字符串，参数类型可以省略不写；方法体里只有一行，亦可简化。如下：1Arrays.sort(strings, (first, second) -&gt; first.length() - second.length()); 无参即使lambda表达式没有参数，仍然要提供括号，就像无参数方法一样：1() -&gt; &#123; for (int i = 100; i &gt;= 0; i--) System.out.println(i); &#125; 一参如果方法只有一个参数，而且这个参数的类型可以推导得出，那么甚至还可以省略小括号：1ActionListener listener = event -&gt; System.out.println("The time is " + new Date()); 注意1）无需指定lambda表达式的返回类型，因为返回类型总是会由上下文推导得出。2）如果一个lambda表达式只在某些分支返回一个值，而在另外一些分支不返回值，这是不合法的。例如，(int x) -&gt; { if (x &gt;= 0) return 1; }就不合法。 Demo12345678910111213141516171819202122232425package com.xian.lambda;import java.util.Arrays;import java.util.Date;import javax.swing.JOptionPane;import javax.swing.Timer;public class LambdaTest &#123; public static void main(String[] args) &#123; String[] masters = &#123;"liyao", "zhaoyu", "hufeng", "xianxiaotao", "cuihongquan"&#125;; System.out.println(Arrays.toString(masters)); System.out.println("Sorted in dictionary order:"); Arrays.sort(masters); System.out.println(Arrays.toString(masters)); System.out.println("Sorted by length:"); Arrays.sort(masters, (first, second) -&gt; first.length() - second.length()); System.out.println(Arrays.toString(masters)); Timer t = new Timer(10000, event -&gt; System.out.println("The time is" + new Date())); t.start(); JOptionPane.showMessageDialog(null, "Quit program?"); System.exit(0); &#125;&#125; 二、函数式接口对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这个接口称为函数式接口。如上例中的Comparator接口，或者java.util.function包中的接口Predicate：1234public interface Predicate&lt;T&gt; &#123; boolean test(T t); // Additional default and static methods&#125; ArrayList类有一个removeIf方法它的参数就是一个Predicate。这个接口专门用来传递lambda表达式。1list.removeIf(e -&gt; e == null); 三、方法引用表达式System.out::println是一个方法引用，等价于lambda表达式x -&gt; System.out.println(x)。又如下列两行代码等同：12Timer t = new Timer(1000, event -&gt; System.out.println(event));Timer t = new Timer(1000, System.out::println); 操作符 “::” 用来分割方法名与对象或类名。主要分为三种情况：123objcet::instanceMethod 如：System.out::println x -&gt; System.out.println(x)Class::staticMethod 如：Math::pow (x, y) -&gt; Math.pow(x, y)Class::instanceMethod 如：String::compareToIgnoreCase (x, y) -&gt; x.compareToIgnoreCase(y) 对于第三种情况，第一个参数会成为方法的目标。12Arrays.sort(masters, String::compareToIgnoreCase);Arrays.sort(masters, (first, second) -&gt; first.compareToIgnoreCase(second)); 注意：对于重载方法，编译器会尝试从上下文中找出你指的那一个方法；方法引用不能独立存在，总是会转换为函数式接口的实例；方法引用中可以使用this和super参数，例如this::equals等同于x -&gt; this.equals(x)；使用super作为目标，会调用方法的超类版本，格式为super::instanceMethod；this是指创建lambda表达式的方法所属的对象，super同理。 四、构造器引用构造器引用与方法引用类似，只不过方法名为new。例如，Person::new是Person构造器的一个引用。至于哪一个构造器，这取决于上下文。假如你有一个字符串列表，并把它转换为Person对象数组，其如下：123ArrayList&lt;String&gt; names = ...;Stream&lt;Person&gt; stream = names.stream().map(Person::new);List&lt;Person&gt; people = stream.collect(Collectors.toList()); 根据上下文，编译器会选择一个String参数的构造器。可以用数组类型建立构造器引用。例如，int[]::new，这等价于lambda表达式x -&gt; new int[x]。 五、变量lambda表达式中捕获的变量必须实际上是最终变量，即这个变量初始化之后就不会再为它赋新值。如下例中的text总是指示同一个String对象，所以此处合法。123456789101112public class LambdaTest &#123; public static void main(String[] args) &#123; repeatMessage("hello", 1000); JOptionPane.showMessageDialog(null, "Quit program?"); System.exit(0); &#125; public static void repeatMessage(String text, int delay) &#123; ActionListener listener = event -&gt; System.out.println(text); new Timer(delay, listener).start(); &#125;&#125; 当lambda表达式捕获外围作用域中变量的，无论是外部改变还是内部改变都不合法的。1234567891011121314151617// 外部改变：public static void repeat(String text, int count) &#123; for (int i = 1; i &lt;= count; i++) &#123; ActionListener listener = event -&gt; &#123; System.out.println(i + ": " + text); // Error: Cannot refer to changing i &#125;; new Timer(1000, listener).start(); &#125;&#125;// 内部改变：public static void countDown(int start, int delay) &#123; ActionListener listener = event -&gt; &#123; start--; // Error: Cannot mutate captured variable System.out.println(start); &#125;; new Timer(delay, listener).start();&#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA | java8之LocalDate]]></title>
    <url>%2F1900%2F02%2F02%2F00JAVA%2FJAVA%208%20LocalDate%2F</url>
    <content type="text"><![CDATA[java.time.LocalDate 8 static LocalDate now()构造一个表示当前日期的对象。 static LocalDate of(int year, int month, int day)构造一个表示给定日期的对象。 int getYear() int getMonthValue() int getDayOfMonth()得到当前日期的年、月和日。 DayOfWeek getDayOfWeek()得到当前日期是星期几，作为DayOfWeek类的一个实例返回。调用getValue来得到1 ~ 7之间的一个数，表示这是星期几，1表示星期一，7表示星期日。 LocalDate plusDays(int n) LocalDate minusDays(int n)生成当前日期之后或之前n天的日期。 使用LocalDate输出日历123456789101112131415161718192021222324252627282930313233package com.xian.date18;import java.time.DayOfWeek;import java.time.LocalDate;public class LocalDateDemo &#123; public static void printCalendar(LocalDate date) &#123; int month = date.getMonthValue(); int today = date.getDayOfMonth(); date = date.minusDays(today - 1); // set to start of month DayOfWeek weekday = date.getDayOfWeek(); int value = weekday.getValue(); // 1 = Monday, ... 7 = Sunday System.out.println("Mon Tue Wed Thu Fri Sat Sun"); for (int i = 1; i &lt; value; i++) System.out.print(" "); while (date.getMonthValue() == month) &#123; System.out.printf("%3d", date.getDayOfMonth()); if (date.getDayOfMonth() == today) System.out.print("*"); else System.out.print(" "); date = date.plusDays(1); if (date.getDayOfWeek().getValue() == 1) System.out.println(); &#125; &#125; public static void main(String[] args) &#123; printCalendar(LocalDate.now()); &#125;&#125; 输出： Mon Tue Wed Thu Fri Sat Sun 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19* 20 21 22 23 24 25 26 27 28 29 30 31]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA | java8之Interface]]></title>
    <url>%2F1900%2F02%2F01%2F00JAVA%2FJAVA%208%20Interface%2F</url>
    <content type="text"><![CDATA[静态方法目前为止，通常的做法都是将静态方法放在伴随类中。在标准库中，你会看到成对出现的接口和使用工具类，如Collection/Collections或Path/Paths。在Java SE 8中，允许在接口中增加静态方法，节省一个伴随类，只是这有违于将接口作为抽象规范的初衷。示例如下：1234interface MyComparable&lt;T&gt; &#123; public static &lt;T&gt; int compare(java.lang.Comparable&lt;T&gt; t1, T t2) &#123; return t1.compareTo(t2); &#125; int compareTo(T t);&#125; 默认方法可以为接口方法提供一个默认实现。必须用default修饰符标记这样一个方法。123456public interface Collection &#123; int size(); // An abstract method default boolean isEmpty() &#123; return size() == 0; &#125;&#125; 解决默认方法冲突如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，会发生什么情况？Java的相应规则如下：1）超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。确保与Java SE 7兼容。1234567interface Named &#123; default String getName() &#123; return getClass().getName() + "_" + hashCode(); &#125;&#125;class Person &#123; public String getName() &#123; return getClass().getName(); &#125;&#125;class Student extends Person implements Named &#123; // super.getName() &#125; 2）接口冲突。如果两个接口都提供了同名同参的默认方法，实现类必须覆盖这个方法类解决冲突。123456789interface Named &#123; default String getName() &#123; return "Named:" + getClass().getName() + "_" + hashCode(); &#125;&#125;interface Called &#123; default String getName() &#123; return "Called:" + getClass().getName() + "_" + hashCode(); &#125;&#125;class Student implements Named, Called &#123; public String getName() &#123; return Named.super.getName(); &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Socket 如何演化成 Tomcat]]></title>
    <url>%2F1900%2F01%2F15%2F00JAVA%2F15%20Java%20Socket%20%E5%A6%82%E4%BD%95%E6%BC%94%E5%8C%96%E6%88%90%20Tomcat%2F</url>
    <content type="text"><![CDATA[相关文章：Java SocketJava Socket 聊天室原理Java Socket 如何演化成 Tomcat 模拟请求表单； 简易服务器代码获取请求； HTTP协议； 抽象封装Response和Request； 将与客户端的交互封装成Servlet； 使用分发器多线程处理各种业务； 分发器使用的上下文及全局变量； 利用反射优化代码； 在配置文件中设置路径与Servlet的对应关系； 完整源码下载链接 一、请求表单首先在前端模拟一个注册请求表单，代码如下：1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;注册&lt;/title&gt; &lt;meta http-equiv="content-type" content="text/html; charset=UTF-8"/&gt;&lt;/head&gt;&lt;body&gt; &lt;form method="post" action="http://localhost:8888/index.html"&gt; 昵称：&lt;input type="text" name="username" id="username"/&gt; 密码：&lt;input type="password" name="password" id="password"/&gt; 兴趣：&lt;input type="checkbox" name="fav" value="0"/&gt;篮球 &lt;input type="checkbox" name="fav" value="1"/&gt;足球 &lt;input type="checkbox" name="fav" value="2"/&gt;冰球 &lt;input type="submit" value="注册"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; method是请求方式，默认为get，其数据量小，安全性不高，而post量大，安全性相对高；action为请求的服务器路径；id用于前端区分唯一性；name用于服务器区分唯一性，如要提交数据给后台，必须声明name；此处fav的值对应多个，用于测试服务器解析参数。 二、简易服务器用一个简易的服务器代码输出来自浏览器的请求信息。12345678910111213141516171819202122232425262728293031323334353637383940public class Server &#123; private ServerSocket server; private boolean isRunning = true; // 开启服务 public void start() &#123; try &#123; server = new ServerSocket(8888); while (isRunning) &#123; receive(); &#125; &#125; catch (IOException e) &#123; stop(); &#125; &#125; // 处理请求并响应 private void receive() &#123; try &#123; Socket client = server.accept(); // 以下代码临时用于接受客户端的请求信息 byte[] data = new byte[1024 * 10]; int len = client.getInputStream().read(data); String requestInfo = new String(data, 0, len).trim(); requestInfo = URLDecoder.decode(requestInfo, "utf-8"); System.out.println(requestInfo); // 以下代码为返回信息，遵从HTTP协议 // TODO &#125; catch (IOException e) &#123; &#125; &#125; // 关闭服务 public void stop() &#123; isRunning = true; CloseUtil.closeServerSocket(server); &#125;&#125; 开启上述服务器，以默认或GET方式发送表单，服务端接收到的信息是：1234567GET /index.html?username=先小涛&amp;password=123456&amp;fav=0&amp;fav=2 HTTP/1.1Host: localhost:8888Accept: text/html,application/xhtml xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-cnConnection: keep-aliveAccept-Encoding: gzip, deflateUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/600.8.9 (KHTML, like Gecko) Version/8.0.8 Safari/600.8.9 以POST方式发送表单，服务端接收到的信息是：123456789101112POST /index.html HTTP/1.1Host: localhost:8888Content-Type: application/x-www-form-urlencodedOrigin: file://Connection: keep-aliveAccept: text/html,application/xhtml xml,application/xml;q=0.9,*/*;q=0.8User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/600.8.9 (KHTML, like Gecko) Version/8.0.8 Safari/600.8.9Accept-Language: zh-cnAccept-Encoding: gzip, deflateContent-Length: 102username=先小涛&amp;password=123456&amp;fav=0&amp;fav=2 三、HTTP协议上述两段请求信息由于请求方式不同导致略有差别，而这些固定格式的信息是由遵从HTTP协议的浏览器负责生成的。服务端响应的信息也要遵从HTTP协议，否则客户端无法解析返回的数据。HTTP响应格式与请求一样，由三个部分构成，分别是：1、HTTP协议版本、状态代码、描述2、响应头(Response Head)3、响应正文(Response Content)可以用代码方式拼接响应字符串：1234567891011121314151617// 响应正文StringBuilder responseContext = new StringBuilder();responseContext.append("&lt;html&gt;&lt;title&gt;HTTP响应示例&lt;/title&gt;&lt;body&gt;I defined a tomcat&lt;/body&gt;&lt;/html&gt;");// 响应全文StringBuilder response = new StringBuilder();response.append("HTTP/1.1").append(" ").append("200").append(" ").append("OK");response.append("Server:xianxiaotao Server/0.0.1").append("\r\n");response.append("Date:").append(new Date()).append("\r\n");response.append("Content-type:text/html;charset=utf-8").append("\r\n");response.append("Content-Length:").append(responseContext.toString().getBytes().length).append("\r\n");response.append("\r\n");response.append(responseContext);// 返回数据BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));bw.write(response.toString());bw.flush();bw.close(); HTTP协议中常用的一些信息：1、状态代码：200 OK400 Bad Request404 Not Found405 Method Not Allowed500 Server Error 2、内容类型：超文本：Content-type:text/html;charset=GBK纯文本：Content-type:text/plain;charset=GBK下载流：Content-type:application/octet-stream 响应信息都是固定格式，不必每次都要拼字符串，可抽取共性封装成Response对象。Request如是。 四、Response123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class Response &#123; public static final String CRLF = "\r\n"; // 回车符 public static final String BLANK = " "; // 空格符 private StringBuilder headInfo; // 头信息 private StringBuilder content; // 正文 private int len; // 正文长度 private BufferedWriter bw; // 推送信息到客户端的流 private Response() &#123; headInfo = new StringBuilder(); content = new StringBuilder(); len = 0; &#125; public Response(Socket socket) &#123; this(); try &#123; bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); &#125; catch (IOException e) &#123; headInfo = null; &#125; &#125; // 构建正文 public Response print(String info) &#123; content.append(info); len += info.getBytes().length; return this; &#125; // 构建正文+回车 public Response println(String info) &#123; content.append(info).append(CRLF); len += (info + CRLF).getBytes().length; return this; &#125; // 生产响应头信息 private void createHeadInfo(int code) &#123; headInfo.append("HTTP/1.1").append(BLANK).append(code).append(BLANK); switch (code) &#123; case 200: headInfo.append("OK"); break; case 404: headInfo.append("NOT FOUND"); break; case 500: headInfo.append("SERVER ERROR"); break; &#125; headInfo.append("Server:xianxiaotao Server/0.0.1").append(CRLF); headInfo.append("Date:").append(new Date()).append(CRLF); headInfo.append("Content-type:text/html;charset=utf-8").append(CRLF); headInfo.append("Content-Length:").append(len).append(CRLF); headInfo.append(CRLF); &#125; // 推送到客户端 public void pushToClient(int code) throws IOException &#123; if (null == headInfo) code = 500; else &#123; createHeadInfo(code); bw.append(headInfo.toString()); bw.append(content.toString()); bw.flush(); &#125; &#125; public void close() &#123; CloseUtil.closeIO(bw); &#125;&#125; 五、Request主要解析请求信息中的请求方式和参数，并将结果封装成Request对象。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127public class Request &#123; public static final String CRLF = "\r\n"; private String method; // 请求方式 private String url; // 请求资源 private Map&lt;String, List&lt;String&gt;&gt; parameterMapValues; // 请求参数 private BufferedInputStream bis;// 流 private String requestInfo; // 请求信息 private Request() &#123; method = ""; url = ""; parameterMapValues = new HashMap&lt;&gt;(); &#125; public Request(Socket client) &#123; this(); try &#123; this.bis = new BufferedInputStream(client.getInputStream()); byte[] buf = new byte[10240]; int len = bis.read(buf); requestInfo = new String(buf, 0, len); &#125; catch (IOException e) &#123; return; &#125; parseRequestInfo(); &#125; /** * 解析请求信息 */ private void parseRequestInfo() &#123; if (null == requestInfo || requestInfo.trim().length() == 0) return; String paramString = ""; // 请求参数 String firstLine = requestInfo.substring(0, requestInfo.indexOf(CRLF)); int idx = firstLine.indexOf("/"); this.method = firstLine.substring(0, idx).trim(); String urlStr = firstLine.substring(idx, firstLine.indexOf("HTTP/")).trim(); if (method.equalsIgnoreCase("post")) &#123; this.url = urlStr; paramString = requestInfo.substring(requestInfo.lastIndexOf(CRLF)).trim(); &#125; else if (method.equalsIgnoreCase("get")) &#123; if (urlStr.contains("?")) &#123; // 是否存在参数 String[] urlArray = urlStr.split("\\?"); this.url = urlArray[0]; paramString = urlArray[1]; &#125; else &#123; this.url = urlStr; &#125; &#125; if (paramString.equals("")) return; parseParams(paramString); // 解析请求参数 &#125; /** * 解析请求信息中的参数 * @param paramString */ private void parseParams(String paramString) &#123; StringTokenizer token = new StringTokenizer(paramString, "&amp;"); while (token.hasMoreTokens()) &#123; String str = token.nextToken(); String[] keyAndVal = str.split("="); if (keyAndVal.length == 1) &#123; // 只有参数没有值 keyAndVal = Arrays.copyOf(keyAndVal, 2); keyAndVal[1] = null; &#125; String key = keyAndVal[0].trim(); String val = (null == keyAndVal[1] ? null : decode(keyAndVal[1].trim(), "utf-8")); if (!parameterMapValues.containsKey(key)) &#123; parameterMapValues.put(key, new ArrayList&lt;&gt;()); &#125; List&lt;String&gt; values = parameterMapValues.get(key); values.add(val); &#125; &#125; /** * 解决中文问题 * @param value 需要正确显示中文的字符 * @param code 字符集（gbk、utf-8等） * @return String 如异常则返回null */ private String decode(String value, String code) &#123; try &#123; return URLDecoder.decode(value, code); &#125; catch (UnsupportedEncodingException e) &#123;&#125; return null; &#125; /** * 获取网页对应name的多个值 * @param name * @return String[] 一个name有多个值 */ public String[] getParameterValues(String name) &#123; List&lt;String&gt; values = parameterMapValues.get(name); if (null == values) return null; else return values.toArray(new String[0]); &#125; /** * 获取网页对应name的值 * @param name * @return String name对应的值 */ public String getParameter(String name) &#123; String[] values = getParameterValues(name); return (null == values) ? null : values[0]; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125;&#125; 需要注意参数值为中文、一参多值的情况。 六、Servlet客户端与服务器端的交互形式不定，如登录、注册、查看信息等。可抽象出一个抽象类，如下：12345678public abstract class Servlet &#123; public void service(Request req, Response rep) throws Exception &#123; doGet(req, rep); doPost(req, rep); &#125; public abstract void doGet(Request req, Response rep) throws Exception; public abstract void doPost(Request req, Response rep) throws Exception;&#125; 具体的交互业务类Servlet继承抽象类，利用JAVA的多态优化其他代码。示例如下：12345678910public class RegisterServlet extends Servlet &#123; @Override public void doGet(Request req, Response rep) throws Exception &#123; rep.println("&lt;html&gt;&lt;title&gt;HTTP响应示例&lt;/title&gt;&lt;body&gt;欢迎用户" + req.getParameter("username") + "注册成功&lt;/body&gt;&lt;/html&gt;"); &#125; @Override public void doPost(Request req, Response rep) throws Exception &#123;&#125;&#125; 七、分发器Dispatcher既然交互方式不定，同一种交互方式的交互次数不定，需要借助分发器（多线程）进行优化处理。12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 分发器，多线程（一个请求响应，创建一个此对象） * @author xianxiaotao */public class Dispatcher implements Runnable &#123; private Socket client; private Request req; private Response rep; private int code = 200; // 默认200 public Dispatcher(Socket client) &#123; this.client = client; try &#123; req = new Request(client.getInputStream()); rep = new Response(client.getOutputStream()); &#125; catch (IOException e) &#123; code = 500; return; &#125; &#125; @Override public void run() &#123; try &#123; // 根据请求参数中的url找到对应的Servlet Servlet servlet = WebApp.getServlet(req.getUrl()); if (null == servlet) // 找不到处理 this.code = 404; else servlet.service(req, rep); rep.pushToClient(code); &#125; catch (Exception e) &#123; this.code = 500; &#125; // 再推送一次 try &#123; rep.pushToClient(code); &#125; catch (IOException e) &#123;&#125; CloseUtil.closeSocket(client); &#125;&#125; 八、上下文ServletContext和全局变量WebApp分发器需要根据请求参数中的url，从上下文中找出对应的Servlet来做相应的处理。1234567891011121314151617181920212223242526272829/** * 上下文 * @author xianxiaotao */public class ServletContext &#123; private Map&lt;String, String&gt; mapping; // url(/register) ——&gt; 别名(register) private Map&lt;String, Servlet&gt; servlet; // 别名(register) ——&gt; 对应的Servlet(RegisterServlet)，后期使用反射其全类名获取对象 public ServletContext() &#123; mapping = new HashMap&lt;&gt;(); servlet = new HashMap&lt;&gt;(); &#125; public Map&lt;String, String&gt; getMapping() &#123; return mapping; &#125; public void setMapping(Map&lt;String, String&gt; mapping) &#123; this.mapping = mapping; &#125; public Map&lt;String, Servlet&gt; getServlet() &#123; return servlet; &#125; public void setServlet(Map&lt;String, Servlet&gt; servlet) &#123; this.servlet = servlet; &#125;&#125; 创建WebApp，保存全局变量（上下文），以及对应的操作（解析、获取）123456789101112131415161718192021222324public class WebApp &#123; private static ServletContext context; // 初始化请求资源路径与Servlet的对应关系，临时代码，后期解析配置文件获取对应关系 static &#123; context = new ServletContext(); Map&lt;String, String&gt; mapping = context.getMapping(); mapping.put("/reg", "register"); mapping.put("/register", "register"); Map&lt;String, Servlet&gt; servlet = context.getServlet(); servlet.put("register", new RegisterServlet()); &#125; /** * 根据url获取对应的Servlet * @param url 表单Action中的值 * @return Servlet */ public static Servlet getServlet(String url) &#123; if (null == url || url.trim().length() == 0) return null; return context.getServlet().get(context.getMapping().get(url)); &#125;&#125; 如果将上下文中存放的Servlet对象，改成存放对象全类名字符串。需要对象时，利用JAVA中的反射技术创建对象，这将极大优化内存。 九、反射123456789Map&lt;String, String &gt; servlet = context.getServlet();servlet.put("register", "com.xian.blog.xtomcat.RegisterServlet");public static Servlet getServlet(String url) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; if (null == url || url.trim().length() == 0) return null; String servletName = context.getServlet().get(context.getMapping().get(url)); return (Servlet)Class.forName(servletName).newInstance();&#125; 十、Xml配置文件将请求资源路径与Servlet的对应关系写死在程序中，不便于代码维护扩展。最好的方式将其配置的xml文件中，程序负责解析而不用经常修改代码。配置文件格式如下：123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;register&lt;/servlet-name&gt; &lt;servlet-class&gt;com.xian.blog.xtomcat.RegisterServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;register&lt;/servlet-name&gt; &lt;url-pattern&gt;/reg&lt;/url-pattern&gt; &lt;url-pattern&gt;/register&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 从文件中抽象出2个对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 存放配置信息： * &lt;servlet&gt; * &lt;servlet-name&gt;register&lt;/servlet-name&gt; * &lt;servlet-class&gt;com.xian.blog.xtomcat.RegisterServlet&lt;/servlet-class&gt; * &lt;/servlet&gt; * @author xianxiaotao */public class Entity &#123; private String name; private String clzz; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getClzz() &#123; return clzz; &#125; public void setClzz(String clzz) &#123; this.clzz = clzz; &#125;&#125;/** * 存放配置信息： * &lt;servlet-mapping&gt; * &lt;servlet-name&gt;register&lt;/servlet-name&gt; * &lt;url-pattern&gt;/reg&lt;/url-pattern&gt; * &lt;url-pattern&gt;/register&lt;/url-pattern&gt; * &lt;/servlet-mapping&gt; * @author xianxiaotao */public class Mapping &#123; private String name; private List&lt;String&gt; urlPattern; public Mapping() &#123; urlPattern = new ArrayList&lt;&gt;(); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;String&gt; getUrlPattern() &#123; return urlPattern; &#125; public void setUrlPattern(List&lt;String&gt; urlPattern) &#123; this.urlPattern = urlPattern; &#125;&#125; 具体子类实现DefaultHandler中的方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class WebHandler extends DefaultHandler &#123; private List&lt;Entity&gt; entityList; private List&lt;Mapping&gt; mappingList; private Entity entity; private Mapping mapping; private String beginTag; private boolean isMapping; @Override public void startDocument() throws SAXException &#123; // 文档解析开始 entityList = new ArrayList&lt;&gt;(); mappingList = new ArrayList&lt;&gt;(); &#125; @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; // 开始元素 if (null != qName) &#123; beginTag = qName; if (qName.equals("servlet")) &#123; isMapping = false; entity = new Entity(); &#125; else if (qName.equals("servlet-mapping")) &#123; isMapping = true; mapping = new Mapping(); &#125; &#125; &#125; @Override public void characters(char[] ch, int start, int length) throws SAXException &#123; // 处理元素 if (null != beginTag) &#123; String str = new String(ch, start, length); if (isMapping) &#123; if (beginTag.equals("servlet-name")) &#123; mapping.setName(str); &#125; else if (beginTag.equals("url-pattern")) &#123; mapping.getUrlPattern().add(str); &#125; &#125; else &#123; if (beginTag.equals("servlet-name")) &#123; entity.setName(str); &#125; else if (beginTag.equals("servlet-class")) &#123; entity.setClzz(str); &#125; &#125; &#125; &#125; @Override public void endElement(String uri, String localName, String qName) throws SAXException &#123; // 结束元素 if (null != qName) &#123; if (qName.equals("servlet")) &#123; entityList.add(entity); &#125; else if (qName.equals("servlet-mapping")) &#123; mappingList.add(mapping); &#125; &#125; beginTag = null; &#125; @Override public void endDocument() throws SAXException &#123; // 文档解析结束 &#125; public List&lt;Entity&gt; getEntityList() &#123; return entityList; &#125; public void setEntityList(List&lt;Entity&gt; entityList) &#123; this.entityList = entityList; &#125; public List&lt;Mapping&gt; getMappingList() &#123; return mappingList; &#125; public void setMappingList(List&lt;Mapping&gt; mappingList) &#123; this.mappingList = mappingList; &#125;&#125; 解析配置文件代码如下：1234567891011121314151617181920212223// 初始化请求资源路径与Servlet的对应关系，临时代码，后期解析配置文件获取对应关系static &#123; try &#123; SAXParserFactory factory = SAXParserFactory.newInstance(); // 获取解析工厂 SAXParser parser = factory.newSAXParser(); WebHandler handler = new WebHandler(); parser.parse(Thread.currentThread().getContextClassLoader().getResourceAsStream("com/xian/blog/xtomcat/web.xml"), handler); context = new ServletContext(); Map&lt;String, String &gt; servlet = context.getServlet(); for (Entity entity : handler.getEntityList()) servlet.put(entity.getName(), entity.getClzz()); Map&lt;String, String&gt; mapping = context.getMapping(); for (Mapping mapp : handler.getMappingList()) &#123; List&lt;String&gt; urlPatterns = mapp.getUrlPattern(); for (String url : urlPatterns) &#123; mapping.put(url, mapp.getName()); &#125; &#125; &#125; catch (Exception e) &#123; &#125;&#125; 十一、完整代码下载链接https://pan.baidu.com/s/1bo3Dd0r]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Socket 之聊天室原理]]></title>
    <url>%2F1900%2F01%2F14%2F00JAVA%2F14%20Java%20Socket%20%E8%81%8A%E5%A4%A9%E5%AE%A4%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[相关文章：Java SocketJava Socket 聊天室原理Java Socket 如何演化成 Tomcat JAVA为基于TCP协议开发提供了相关API，具体代码如下。客户端：12345678Socket client = new Socket("localhost", 9876); // 创建客户端，并指定服务器端地址和端口DataOutputStream dos = new DataOutputStream(client.getOutputStream());dos.writeUTF("客户端向服务器端发送数据"); // 客户端向服务器发送数据 DataInputStream dis = new DataInputStream(client.getInputStream());String msg = dis.readUTF(); // 客户端接受服务器端返回的数据System.out.println(msg);client.close(); 服务端：12345678910ServerSocket server = new ServerSocket(9876); // 创建服务器并指定端口Socket socket = server.accept(); // 接受客户端连接（阻塞式）DataInputStream dis = new DataInputStream(socket.getInputStream());String msg = dis.readUTF(); // 读取客户端请求数据DataOutputStream dos = new DataOutputStream(socket.getOutputStream());dos.writeUTF("服务器接受的数据：" + msg); // 服务器端返回客户端数据dos.flush();server.close(); 上述代码中，只建立一次请求，为实现双方多次交互，则需要加入循环处理；而且客户端发送数据和接受数据都在一个线程中，意味着客户端不发送数据就接受不了服务端返回的数据，因此他们需要在不同的线程中处理各自的业务。服务器端同理。 客户端实现多线程发送数据线程：123456789101112131415161718192021222324252627282930313233343536373839public class Send implements Runnable &#123; private BufferedReader console; // 测试时使用控制台输入信息 private DataOutputStream dos; // 输出流（发送数据） private boolean isRunning = true; // 控制线程运行 public Send(Socket client) &#123; console = new BufferedReader(new InputStreamReader(System.in)); try &#123; dos = new DataOutputStream(client.getOutputStream()); &#125; catch (IOException e) &#123; end(); &#125; &#125; private String getMsgFromConsole() &#123; try &#123; return console.readLine(); &#125; catch (IOException e) &#123;&#125; return ""; &#125; private void end() &#123; // 出现异常则结束线程 isRunning = false; CloseUtil.closeIO(console, dos); &#125; private void send() &#123; // 发送数据 String msg = getMsgFromConsole(); try &#123; if (null != msg &amp;&amp; msg.length() &gt; 0) dos.writeUTF(msg); &#125; catch (IOException e) &#123; end(); &#125; &#125; public void run() &#123; // 线程体 while (isRunning) send(); &#125;&#125; 接受数据线程：1234567891011121314151617181920212223242526272829303132public class Receive implements Runnable &#123; private DataInputStream dis; // 输入流（接受数据） private boolean isRunning = true; // 控制线程运行 public Receive (Socket client) &#123; try &#123; dis = new DataInputStream(client.getInputStream()); &#125; catch (IOException e) &#123; end(); &#125; &#125; private void end() &#123; // 出现异常则结束线程 isRunning = false; CloseUtil.closeIO(dis); &#125; private String receive() &#123; // 接受数据 String msg = ""; try &#123; msg = dis.readUTF(); &#125; catch (IOException e) &#123; end(); &#125; return msg; &#125; public void run() &#123; while (isRunning) System.out.println(receive()); &#125;&#125; 客户端只需开启Send、Receive两个线程：123Socket client = new Socket("localhost", 9876); // 创建客户端，并指定服务器端地址和端口new Thread(new Send(client)).start();new Thread(new Receive(client)).start(); 服务端实现群聊群聊，将服务端作为中转站，转发所有客户消息给其他客户（不需转给自己）。因此，服务端需要管理所有的连接通道，每个通道封装数据信息以及对应的操作。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class Server &#123; // 保存连接通道 private List&lt;ChatChannel&gt; channels = new ArrayList&lt;&gt;(); // 启动服务 public void start() throws IOException &#123; @SuppressWarnings("resource") ServerSocket server = new ServerSocket(9876); while (true) &#123; Socket client = server.accept(); ChatChannel channel = new ChatChannel(client); channels.add(channel); new Thread(channel).start(); &#125; &#125; // 连接通道类 private class ChatChannel implements Runnable &#123; private DataInputStream dis; private DataOutputStream dos; private boolean isRunning = true; public ChatChannel(Socket socket) &#123; try &#123; dis = new DataInputStream(socket.getInputStream()); dos = new DataOutputStream(socket.getOutputStream()); &#125; catch (IOException e) &#123; end(); &#125; &#125; private String receive() &#123; String msg = ""; try &#123; msg = dis.readUTF(); &#125; catch (IOException e) &#123; end(); &#125; return msg; &#125; private void send(String msg) &#123; if (null == msg || msg.length() == 0) return; try &#123; dos.writeUTF(msg); dos.flush(); &#125; catch (IOException e) &#123; end(); &#125; &#125; private void end() &#123; CloseUtil.closeIO(dis, dos); isRunning = false; channels.remove(this); &#125; @Override public void run() &#123; while (isRunning) &#123; String msg = receive(); for (ChatChannel other : channels) &#123; if (other == this) continue; other.send(msg); &#125; &#125; &#125; &#125;&#125; 开启服务1new Server().start(); 私聊要找到对应的用户进行私聊，需要对每个客户端进行唯一性标示，即创建客户端的时候指定用户名/ID并发送给服务端，服务端在创建对应的ChatChannel时，保存获取到的用户名/ID信息。而私聊的代码实现就是将信息转发到指定的ChatChannel连接通道中。 按照面向对象编程的思想，用户信息、消息本体都要封装成一个个的对象。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Socket]]></title>
    <url>%2F1900%2F01%2F13%2F00JAVA%2F13%20Java%20Socket%2F</url>
    <content type="text"><![CDATA[参考文章：https://www.jianshu.com/p/cde27461c226https://www.cnblogs.com/diaobiyong/p/9929319.htmlhttps://www.cnblogs.com/futao123/p/5068632.html 相关文章：Java SocketJava Socket 聊天室原理Java Socket 如何演化成 Tomcat 一、概述 Socket 是 Java 网络编程的基础，了解还是有好处的，这篇文章主要讲解 Socket 的基础编程。Socket 用在哪呢，主要用在进程间，网络间通信。 1.1、网络编程中两个主要的问题一个是如何准确的定位网络上一台或多台主机，另一个就是找到主机后如何可靠高效的进行数据传输。 在 TCP/I P协议中 IP 层主要负责网络主机的定位，数据传输的路由，由 IP 地址可以唯一地确定 Internet 上的一台主机。 而 TCP 层则提供面向应用的可靠（TCP）的或非可靠（UDP）的数据传输机制，这是网络编程的主要对象，一般不需要关心 IP 层是如何处理数据的。 目前较为流行的网络编程模型是客户机/服务器（C/S）结构。 即通信双方一方作为服务器等待客户提出请求并予以响应。客户则在需要服务时向服务器提出申请。服务器一般作为守护进程始终运行，监听网络端口，一旦有客户请求，就会启动一个服务进程来响应该客户，同时自己继续监听服务端口，使后来的客户也能及时得到服务。 1.2、两类传输协议：TCP 和 UDPTCP 是 Tranfer Control Protocol 的简称，是一种面向连接的保证可靠传输的协议。通过 TCP 协议传输，得到的是一个顺序的无差错的数据流。发送方和接收方的成对的两个 socket 之间必须建立连接，以便在 TCP 协议的基础上进行通信，当一个 socket（通常都是server socket）等待建立连接时，另一个 socket 可以要求进行连接，一旦这两个 socket 连接起来，它们就可以进行双向数据传输，双方都可以进行发送或接收操作。 UDP 是 User Datagram Protocol 的简称，是一种无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。 TCP 和 UDP 的区别：UDP：1）每个数据报中都给出了完整的地址信息，因此无需要建立发送方和接收方的连接。2）UDP传输数据时是有大小限制的，每个被传输的数据报必须限定在 64KB 之内。3）UDP 是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方。 TCP：1）面向连接的协议，在 socket 之间进行数据传输之前必然要建立连接，所以在 TCP 中需要连接时间。2）TCP 传输数据大小限制，一旦连接建立起来，双方的 socket 就可以按统一的格式传输大的数据。3）TCP是一个可靠的协议，它确保接收方完全正确地获取发送方所发送的全部数据。 应用：1，TCP 在网络通信上有极强的生命力，例如远程连接（Telnet）和文件传输（FTP）都需要不定长度的数据被可靠地传输。但是可靠的传输是要付出代价的，对数据内容正确性的检验必然占用计算机的处理时间和网络的带宽，因此 TCP 传输的效率不如 UDP 高。 2，UDP 操作简单，而且仅需要较少的监护，因此通常用于局域网高可靠性的分散系统中 client/server 应用程序。例如视频会议系统，并不要求音频视频数据绝对的正确，只要保证连贯性就可以了，这种情况下显然使用UDP会更合理一些。 二、Java Socket 2.1、什么是 Socket网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个 Socket。Socket 通常用来实现客户方和服务方的连接。Socket 是 TCP/IP 协议的一个十分流行的编程界面，一个 Socket 由一个 IP 地址和一个端口号唯一确定。 但是，Socket 所支持的协议种类也不光 TCP/IP 一种，因此两者之间是没有必然联系的。在 Java 环境下，Socket 编程主要是指基于 TCP/IP 协议的网络编程。 2.2、Socket 通讯的过程Server 端 Listen（监听）某个端口是否有连接请求，Client 端向 Server 端发出 Connect（连接）请求，Server 端向 Client 端发回 Accept（接受）消息。一个连接就建立起来了。Server 端和 Client 端都可以通过 Send，Write 等方法与对方通信。 对于一个功能齐全的 Socket，都要包含以下基本结构，其工作过程包含以下四个基本的步骤：1）创建 Socket；2）打开连接到 Socket 的输入/出流；3）按照一定的协议对 Socket 进行读/写操作；4）关闭 Socket.（在实际应用中，并未使用到显示的 close，虽然很多文章都推荐如此，不过在我的程序中，可能因为程序本身比较简单，要求不高，所以并未造成什么影响。） 2.3、创建 SocketJava 在包 java.net 中提供了两个类：Socket 和 ServerSocket，分别用来表示双向连接的客户端和服务端。这是两个封装得非常好的类，使用很方便。其构造方法如下：12345678910Socket(InetAddress address, int port);Socket(InetAddress address, int port, boolean stream);Socket(String host, int prot);Socket(String host, int prot, boolean stream);Socket(SocketImpl impl)Socket(String host, int port, InetAddress localAddr, int localPort)Socket(InetAddress address, int port, InetAddress localAddr, int localPort)ServerSocket(int port);ServerSocket(int port, int backlog);ServerSocket(int port, int backlog, InetAddress bindAddr) 其中 address、host 和 port 分别是双向连接中另一方的 IP 地址、主机名和端口号，stream 指明 socket 是流 socket 还是数据报 socket，localPort 表示本地主机的端口号，localAddr 和 bindAddr 是本地机器的地址（ServerSocket 的主机地址），impl 是 socket 的父类，既可以用来创建 serverSocket 又可以用来创建 Socket。count 则表示服务端所能支持的最大连接数。12Socket client = new Socket(&quot;127.0.01.&quot;, 80);ServerSocket server = new ServerSocket(80); 注意，在选择端口时，必须小心。每一个端口提供一种特定的 服务，只有给出正确的端口，才能获得相应的服务。0~1023 的端口号为系统所保留，例如 http 服务的端口号为 80，telnet 服务的端口号为 21，ftp 服务的端口号为 23，所以我们在选择端口号时，最好选择一个大于 1023 的数以防止发生冲突。 在创建 socket 时如果发生错误，将产生 IOException，在程序中必须对之作出处理。所以在创建 Socket 或 ServerSocket 是必须捕获或抛出例外。 2.4 示例服务器端：12345678910111213141516171819202122232425262728import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;public class SocketServer &#123; public static void main(String[] args) throws Exception &#123; // 监听指定的端口 int port = 55533; ServerSocket server = new ServerSocket(port); // server将一直等待连接的到来 System.out.println(&quot;server将一直等待连接的到来&quot;); Socket socket = server.accept(); // 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取 InputStream inputStream = socket.getInputStream(); byte[] bytes = new byte[1024]; int len; StringBuilder sb = new StringBuilder(); while ((len = inputStream.read(bytes)) != -1) &#123; //注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8 sb.append(new String(bytes, 0, len,&quot;UTF-8&quot;)); &#125; System.out.println(&quot;get message from client: &quot; + sb); inputStream.close(); socket.close(); server.close(); &#125;&#125; 客户端：123456789101112131415161718import java.io.OutputStream;import java.net.Socket;public class SocketClient &#123; public static void main(String args[]) throws Exception &#123; // 要连接的服务端IP地址和端口 String host = &quot;127.0.0.1&quot;; int port = 55533; // 与服务端建立连接 Socket socket = new Socket(host, port); // 建立连接后获得输出流 OutputStream outputStream = socket.getOutputStream(); String message=&quot;你好 xianxiaotao&quot;; socket.getOutputStream().write(message.getBytes(&quot;UTF-8&quot;)); outputStream.close(); socket.close(); &#125;&#125; 客户端通过 IP 和端口，连接到指定的 server，然后通过 Socket 获得输出流，并向其输出内容，服务器会获得消息。最终服务端控制台打印如下：12server将一直等待连接的到来get message from client: 你好 xianxiaotao 通过这个例子应该掌握并了解： Socket 服务端和客户端的基本编程 传输编码统一指定，防止乱码 这个例子做为学习的基本例子，实际开发中会有各种变形，比如客户端在发送完消息后，需要服务端进行处理并返回。 三、消息通信优化 3.1 双向通信，发送消息并接受消息1234567891011121314151617181920212223242526272829303132333435import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;public class SocketServer &#123; public static void main(String[] args) throws Exception &#123; // 监听指定的端口 int port = 55533; ServerSocket server = new ServerSocket(port); // server将一直等待连接的到来 System.out.println(&quot;server将一直等待连接的到来&quot;); Socket socket = server.accept(); // 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取 InputStream inputStream = socket.getInputStream(); byte[] bytes = new byte[1024]; int len; StringBuilder sb = new StringBuilder(); //只有当客户端关闭它的输出流的时候，服务端才能取得结尾的-1 while ((len = inputStream.read(bytes)) != -1) &#123; // 注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8 sb.append(new String(bytes, 0, len, &quot;UTF-8&quot;)); &#125; System.out.println(&quot;get message from client: &quot; + sb); OutputStream outputStream = socket.getOutputStream(); outputStream.write(&quot;Hello Client,I get the message.&quot;.getBytes(&quot;UTF-8&quot;)); inputStream.close(); outputStream.close(); socket.close(); server.close(); &#125;&#125; 与之前 server 的不同在于，当读取完客户端的消息后，打开输出流，将指定消息发送回客户端，客户端程序为：123456789101112131415161718192021222324252627282930313233import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;public class SocketClient &#123; public static void main(String args[]) throws Exception &#123; // 要连接的服务端IP地址和端口 String host = &quot;127.0.0.1&quot;; int port = 55533; // 与服务端建立连接 Socket socket = new Socket(host, port); // 建立连接后获得输出流 OutputStream outputStream = socket.getOutputStream(); String message = &quot;你好 xianxiaotao&quot;; socket.getOutputStream().write(message.getBytes(&quot;UTF-8&quot;)); //通过shutdownOutput高速服务器已经发送完数据，后续只能接受数据 socket.shutdownOutput(); InputStream inputStream = socket.getInputStream(); byte[] bytes = new byte[1024]; int len; StringBuilder sb = new StringBuilder(); while ((len = inputStream.read(bytes)) != -1) &#123; //注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8 sb.append(new String(bytes, 0, len,&quot;UTF-8&quot;)); &#125; System.out.println(&quot;get message from server: &quot; + sb); inputStream.close(); outputStream.close(); socket.close(); &#125;&#125; 客户端也有相应的变化，在发送完消息时，调用关闭输出流方法，然后打开输出流，等候服务端的消息。 3.2 关闭通信正常来说，客户端打开一个输出流，如果不做约定，也不关闭它，那么服务端永远不知道客户端是否发送完消息，那么服务端会一直等待下去，直到读取超时。所以怎么告知服务端已经发送完消息就显得特别重要。 3.2.1 关闭 Socket当 Socket 关闭的时候，服务端就会收到响应的关闭信号，那么服务端也就知道流已经关闭了，这个时候读取操作完成，就可以继续后续工作。但是这种方式有一些缺点 客户端 Socket 关闭后，将不能接受服务端发送的消息，也不能再次发送消息。 如果客户端想再次发送消息，需要重现创建 Socket 连接。 3.2.2 shutdownOutput通过 Socket 关闭输出流的方式是：1socket.shutdownOutput(); 而不是（outputStream为发送消息到服务端打开的输出流）：1outputStream.close(); 如果关闭了输出流，那么相应的 Socket 也将关闭，和直接关闭 Socke t一个性质。 调用 Socket 的 shutdownOutput() 方法，底层会告知服务端我这边已经写完了，那么服务端收到消息后，就能知道已经读取完消息，如果服务端有要返回给客户的消息那么就可以通过服务端的输出流发送给客户端，如果没有，直接关闭 Socket。 这种方式通过关闭客户端的输出流，告知服务端已经写完了，虽然可以读到服务端发送的消息，但是还是有一点缺点：不能再次发送消息给服务端，如果再次发送，需要重新建立Socket连接。 这个缺点，在访问频率比较高的情况下将是一个需要优化的地方。 3.2.3 通过约定符号这种方式的用法，就是双方约定一个字符或者一个短语，来当做消息发送完成的标识，通常这么做就需要改造读取方法。 假如约定单独的一行为 end，代表发送完成，例如下面的消息，end则代表消息发送完成：12hello 先小涛end 那么服务端响应的读取操作需要进行如下改造：123456789Socket socket = server.accept();// 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取BufferedReader read=new BufferedReader(new InputStreamReader(socket.getInputStream(),&quot;UTF-8&quot;));String line;StringBuilder sb = new StringBuilder();while ((line = read.readLine()) != null &amp;&amp; !&quot;end&quot;.equals(line)) &#123; //注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8 sb.append(line);&#125; 可以看见，服务端不仅判断是否读到了流的末尾，还判断了是否读到了约定的末尾。这么做的优缺点如下： 优点：不需要关闭流，当发送完一条命令（消息）后可以再次发送新的命令（消息）。 缺点：需要额外的约定结束标志，太简单的容易出现在要发送的消息中，误被结束，太复杂的不好处理，还占带宽。经过了这么多的优化还是有缺点，难道就没有完美的解决方案吗，答案是有的，看接下来的内容。 3.2.4 通过指定长度如果你了解一点 class 文件的结构，那么你就会佩服这么设计方式，也就是说我们可以在此找灵感，就是我们可以先指定后续命令的长度，然后读取指定长度的内容做为客户端发送的消息。 现在首要的问题就是用几个字节指定长度呢，我们可以算一算： 1个字节：最大256，表示256B2个字节：最大65536，表示64K3个字节：最大16777216，表示16M4个字节：最大4294967296，表示4G依次类推… 这个时候是不是很纠结，最大的当然是最保险的，但是真的有必要选择最大的吗，其实如果你稍微了解一点UTF-8的编码方式，那么你就应该能想到为什么一定要固定表示长度字节的长度呢，我们可以使用变长方式来表示长度的表示，比如： 第一个字节首位为0：即0XXXXXXX，表示长度就一个字节，最大128，表示128B第一个字节首位为110，那么附带后面一个字节表示长度：即110XXXXX 10XXXXXX，最大2048，表示2K第一个字节首位为1110，那么附带后面二个字节表示长度：即110XXXXX 10XXXXXX 10XXXXXX，最大131072，表示128K依次类推 上面提到的这种用法适合高富帅的程序员使用，一般呢，如果用作命名发送，两个字节就够了，如果还不放心4个字节基本就能满足你的所有要求，下面的例子我们将采用2个字节表示长度，目的只是给你一种思路，让你知道有这种方式来获取消息的结尾： 服务端程序：12345678910111213141516171819202122232425262728293031323334353637import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;public class SocketServer &#123; public static void main(String[] args) throws Exception &#123; // 监听指定的端口 int port = 55533; ServerSocket server = new ServerSocket(port); // server将一直等待连接的到来 System.out.println(&quot;server将一直等待连接的到来&quot;); Socket socket = server.accept(); // 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取 InputStream inputStream = socket.getInputStream(); byte[] bytes; // 因为可以复用Socket且能判断长度，所以可以一个Socket用到底 while (true) &#123; // 首先读取两个字节表示的长度 int first = inputStream.read(); //如果读取的值为-1 说明到了流的末尾，Socket已经被关闭了，此时将不能再去读取 if(first==-1)&#123; break; &#125; int second = inputStream.read(); int length = (first &lt;&lt; 8) + second; // 然后构造一个指定长的byte数组 bytes = new byte[length]; // 然后读取指定长度的消息即可 inputStream.read(bytes); System.out.println(&quot;get message from client: &quot; + new String(bytes, &quot;UTF-8&quot;)); &#125; inputStream.close(); socket.close(); server.close(); &#125;&#125; 此处的读取步骤为，先读取两个字节的长度，然后读取消息，客户端为：123456789101112131415161718192021222324252627282930313233343536373839import java.io.OutputStream;import java.net.Socket;public class SocketClient &#123; public static void main(String args[]) throws Exception &#123; // 要连接的服务端IP地址和端口 String host = &quot;127.0.0.1&quot;; int port = 55533; // 与服务端建立连接 Socket socket = new Socket(host, port); // 建立连接后获得输出流 OutputStream outputStream = socket.getOutputStream(); String message = &quot;你好 xianxiaotao&quot;; //首先需要计算得知消息的长度 byte[] sendBytes = message.getBytes(&quot;UTF-8&quot;); //然后将消息的长度优先发送出去 outputStream.write(sendBytes.length &gt;&gt;8); outputStream.write(sendBytes.length); //然后将消息再次发送出去 outputStream.write(sendBytes); outputStream.flush(); //==========此处重复发送一次，实际项目中为多个命名，此处只为展示用法 message = &quot;第二条消息&quot;; sendBytes = message.getBytes(&quot;UTF-8&quot;); outputStream.write(sendBytes.length &gt;&gt;8); outputStream.write(sendBytes.length); outputStream.write(sendBytes); outputStream.flush(); //==========此处重复发送一次，实际项目中为多个命名，此处只为展示用法 message = &quot;the third message!&quot;; sendBytes = message.getBytes(&quot;UTF-8&quot;); outputStream.write(sendBytes.length &gt;&gt;8); outputStream.write(sendBytes.length); outputStream.write(sendBytes); outputStream.close(); socket.close(); &#125;&#125; 客户端要多做的是，在发送消息之前先把消息的长度发送过去。 当然如果是需要服务器返回结果，那么也依然使用这种方式，服务端也是先发送结果的长度，然后客户端进行读取。当然现在流行的就是，长度+类型+数据模式的传输方式。 四、服务端优化 4.1 服务端并发处理能力在上面的例子中，服务端仅仅只是接受了一个 Socket 请求，并处理了它，然后就结束了，但是在实际开发中，一个 Socket 服务往往需要服务大量的 Socket 请求，那么就不能再服务完一个 Socket 的时候就关闭了，这时候可以采用循环接受请求并处理的逻辑：123456789101112131415161718192021222324252627282930import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;public class SocketServer &#123; public static void main(String args[]) throws IOException &#123; // 监听指定的端口 int port = 55533; ServerSocket server = new ServerSocket(port); // server将一直等待连接的到来 System.out.println(&quot;server将一直等待连接的到来&quot;); while(true) &#123; Socket socket = server.accept(); // 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取 InputStream inputStream = socket.getInputStream(); byte[] bytes = new byte[1024]; int len; StringBuilder sb = new StringBuilder(); while ((len = inputStream.read(bytes)) != -1) &#123; // 注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8 sb.append(new String(bytes, 0, len, &quot;UTF-8&quot;)); &#125; System.out.println(&quot;get message from client: &quot; + sb); inputStream.close(); socket.close(); &#125; &#125;&#125; 这种一般也是新手写法，但是能够循环处理多个 Socket 请求，不过当一个请求的处理比较耗时的时候，后面的请求将被阻塞，所以一般都是用多线程的方式来处理 Socket，即每有一个 Socket 请求的时候，就创建一个线程来处理它。 不过在实际生产中，创建的线程会交给线程池来处理，为了： 线程复用，创建线程耗时，回收线程慢。 防止短时间内高并发，指定线程池大小，超过数量将等待，方式短时间创建大量线程导致资源耗尽，服务挂掉。 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class SocketServer &#123; public static void main(String args[]) throws Exception &#123; // 监听指定的端口 int port = 55533; ServerSocket server = new ServerSocket(port); // server将一直等待连接的到来 System.out.println(&quot;server将一直等待连接的到来&quot;); //如果使用多线程，那就需要线程池，防止并发过高时创建过多线程耗尽资源 ExecutorService threadPool = Executors.newFixedThreadPool(100); while (true) &#123; Socket socket = server.accept(); Runnable runnable=()-&gt;&#123; try &#123; // 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取 InputStream inputStream = socket.getInputStream(); byte[] bytes = new byte[1024]; int len; StringBuilder sb = new StringBuilder(); while ((len = inputStream.read(bytes)) != -1) &#123; // 注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8 sb.append(new String(bytes, 0, len, &quot;UTF-8&quot;)); &#125; System.out.println(&quot;get message from client: &quot; + sb); inputStream.close(); socket.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;; threadPool.submit(runnable); &#125; &#125;&#125; 使用线程池的方式，算是一种成熟的方式。可以应用在生产中。 4.2 服务端其他属性ServerSocket 有以下 3 个属性： SO_TIMEOUT：表示等待客户连接的超时时间。一般不设置，会持续等待。 SO_REUSEADDR：表示是否允许重用服务器所绑定的地址。一般不设置，经我的测试没必要，下面会进行详解。 SO_RCVBUF：表示接收数据的缓冲区的大小。一般不设置，用系统默认就可以了。 4.3 性能再次提升当现在的性能还不能满足需求的时候，就需要考虑使用 NIO，这不是本篇的内容。 五、Socket 的其它知识其实如果经常看有关网络编程的源码的话，就会发现Socket还是有很多设置的，可以学着用，但是还是要有一些基本的了解比较好。下面就对Socket的Java API中涉及到的进行简单讲解。首先呢Socket有哪些可以设置的选项，其实在SocketOptions接口中已经都列出来了： int TCP_NODELAY = 0x0001：对此连接禁用 Nagle 算法。 int SO_BINDADDR = 0x000F：此选项为 TCP 或 UDP 套接字在 IP 地址头中设置服务类型或流量类字段。 int SO_REUSEADDR = 0x04：设置套接字的 SO_REUSEADDR。 int SO_BROADCAST = 0x0020：此选项启用和禁用发送广播消息的处理能力。 int IP_MULTICAST_IF = 0x10：设置用于发送多播包的传出接口。 int IP_MULTICAST_IF2 = 0x1f：设置用于发送多播包的传出接口。 int IP_MULTICAST_LOOP = 0x12：此选项启用或禁用多播数据报的本地回送。 int IP_TOS = 0x3：此选项为 TCP 或 UDP 套接字在 IP 地址头中设置服务类型或流量类字段。 int SO_LINGER = 0x0080：指定关闭时逗留的超时值。 int SO_TIMEOUT = 0x1006：设置阻塞 Socket 操作的超时值： ServerSocket.accept(); SocketInputStream.read(); DatagramSocket.receive(); 选项必须在进入阻塞操作前设置才能生效。 int SO_SNDBUF = 0x1001：设置传出网络 I/O 的平台所使用的基础缓冲区大小的提示。 int SO_RCVBUF = 0x1002：设置传入网络 I/O 的平台所使用基础缓冲区的大小的提示。 int SO_KEEPALIVE = 0x0008：为 TCP 套接字设置 keepalive 选项时 int SO_OOBINLINE = 0x1003：置 OOBINLINE 选项时，在套接字上接收的所有 TCP 紧急数据都将通过套接字输入流接收。 5.1 客户端绑定端口服务端绑定端口是可以理解的，因为要监听指定的端口，但是客户端可以绑定端口吗？如果非要指定一个端口，就不能用Socket的构造方法，要一步一步来：1234567// 要连接的服务端IP地址和端口String host = &quot;localhost&quot;; int port = 55533;// 与服务端建立连接Socket socket = new Socket();socket.bind(new InetSocketAddress(55534));socket.connect(new InetSocketAddress(host, port)); 这样做就可以了，但是当这个程序执行完成以后，再次执行就会报，端口占用异常：1java.net.BindException: Address already in use: connect 明明上一个Socket已经关闭了，为什么再次使用还会说已经被占用了呢？如果你是用netstat 命令来查看端口的使用情况：12netstat -n|findstr &quot;55533&quot;TCP 127.0.0.1:55534 127.0.0.1:55533 TIME_WAIT 就会发现端口的使用状态为TIME_WAIT。简单来说，当连接主动关闭后，端口状态变为TIME_WAIT，其他程序依然不能使用这个端口，防止服务端因为超时重新发送的确认连接断开对新连接的程序造成影响。 TIME_WAIT的时间一般有底层决定，一般是2分钟，还有1分钟和30秒的。 5.2 读超时 SO_TIMEOUT读超时这个属性还是比较重要的，当Socket优化到最后的时候，往往一个Socket连接会一直用下去，那么当一端因为异常导致连接没有关闭，另一方是不应该持续等下去的，所以应该设置一个读取的超时时间，当超过指定的时间后，还没有读到数据，就假定这个连接无用，然后抛异常，捕获异常后关闭连接就可以了，调用方法为：12public void setSoTimeout(int timeout)throws SocketException timeout - 指定的以毫秒为单位的超时值。设置0为持续等待下去。建议根据网络环境和实际生产环境选择。 这个选项设置的值将对以下操作有影响：ServerSocket.accept()SocketInputStream.read()DatagramSocket.receive() 5.3 设置连接超时这个连接超时和上面说的读超时不一样，读超时是在建立连接以后，读数据时使用的，而连接超时是在进行连接的时候，等待的时间。 5.4 判断Socket是否可用当需要判断一个Socket是否可用的时候，不能简简单单判断是否为null，是否关闭，下面给出一个比较全面的判断Socket是否可用的表达式，这是根据Socket自身的一些状态进行判断的，它的状态有： bound：是否绑定 closed：是否关闭 connected：是否连接 shutIn：是否关闭输入流 shutOut：是否关闭输出流 1socket != null &amp;&amp; socket.isBound() &amp;&amp; !socket.isClosed() &amp;&amp; socket.isConnected()&amp;&amp; !socket.isInputShutdown() &amp;&amp; !socket.isOutputShutdown() 建议如此使用，但这只是第一步，保证Socket自身的状态是可用的，但是当连接正常创建后，上面的属性如果不调用本方相应的方法是不会改变的，也就是说如果网络断开、服务器主动断开，Java底层是不会检测到连接断开并改变Socket的状态，所以，真实的检测连接状态还是得通过额外的手段，有两种方式。 5.4.1 自定义心跳包双方需要约定，什么样的消息属于心跳包，什么样的消息属于正常消息，假设你看了上面的章节现在说就容易理解了，我们定义前两个字节为消息的长度，那么我们就可以定义第 3 个字节为消息的属性，可以指定一位为消息的类型，1 为心跳，0 为正常消息。那么要做的有如下： 客户端发送心跳包 服务端获取消息判断是否是心跳包，若是丢弃 当客户端发送心跳包失败时，就可以断定连接不可用 5.4.2 通过发送紧急数据Socket 自带一种模式，那就是发送紧急数据，这有一个前提，那就是服务端的 OOBINLINE 不能设置为true，它的默认值是 false。 OOBINLINE 的 true 和 false 影响了什么： 对客户端没有影响 对服务端，如果设置为true，那么服务端将会捕获紧急数据，这会对接收数据造成混淆，需要额外判断 发送紧急数据通过调用Socket的方法：1socket.sendUrgentData(0); 发送数据任意即可，因为 OOBINLINE 为 false 的时候，服务端会丢弃掉紧急数据。当发送紧急数据报错以后，我们就会知道连接不通了。 5.4.3 真的需要判断连接断开吗通过上面的两种方式已经可以判断出连接是否可用，然后我们就可以进行后续操作，可是请大家认真考虑下面的问题： 发送心跳成功时确认连接可用，当再次发送消息时能保证连接还可用吗？即便中间的间隔很短 如果连接不可用了，你会怎么做？重新建立连接再次发送数据？还是说单单只是记录日志？ 如果你打算重新建立连接，那么发送心跳包的意义何在？为何不在发送异常时再新建连接？ 如果你认真考虑了上面的问题，那么你就会觉得发送心跳包完全是没有必要的操作，通过发送心跳包来判断连接是否可用是通过捕获异常来判断的。那么我们完全可以在发送消息报出IO异常的时候，在异常中重新发送一次即可，这两种方式的编码有什么不同呢，下面写一写伪代码。 提前检测连接是否可用：1234567891011//有一个连接中的socketSocket socket=...//要发送的数据String data=&quot;&quot;;try&#123; //发送心跳包或者紧急数据，来检测连接的可用性&#125;catch (Excetption e)&#123; //打印日志，并重连Socket socket=new Socket(host,port);&#125;socket.write(data); 直接发送数据，出异常后重新连接再次发送：1234567891011//有一个连接中的socketSocket socket=...//要发送的数据String data=&quot;&quot;;try&#123; socket.write(data);&#125;catch (Excetption e)&#123; //打印日志，并重连Socket socket=new Socket(host,port); socket.write(data);&#125; 通过比较可以发现两种方式的特点，现在简单介绍下： 两种方式均可实现连接断开重新连接并发送 提前检测，再每次发送消息的时候都要检测，影响效率，占用带宽]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射三：类内部信息获取]]></title>
    <url>%2F1900%2F01%2F12%2F00JAVA%2F12%20%E5%8F%8D%E5%B0%84%E4%B8%89%EF%BC%9A%E7%B1%BB%E5%86%85%E9%83%A8%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%2F</url>
    <content type="text"><![CDATA[原文链接：夯实JAVA基本之二 —— 反射（3）：类内部信息获取 相关文章：Java RelfectJava RelfectUtils反射一：基本类周边信息获取反射二：泛型相关周边信息获取反射三：类内部信息获取 上两篇文章中，给大家讲了，有关类周边信息的获取方法，这篇文章中我们将深入到类的内部，看看类的构造函数，内部变量，函数等信息的获取方法。相比而言，这篇更重要。 一、构造函数相关获取 1、获取构造函数要获取类的构造函数，有下面几种方法：1234567// 获取 public 类型的构造函数Constructor&lt;?&gt;[] getConstructors();Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes); // 获取所有类型的构造函数Constructor&lt;?&gt;[] getDeclaredConstructors();Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) 这四种方法中，getConstructors 与 getConstructor 获取的是声明为 public 的构造函数。无法得到声明为 protected、private 的构造函数。而加有 Declared（声明）的两个函数 getDeclaredConstructors、getDeclaredConstructor 能获取所有声明的构造函数，无论它是 public、protected 还是 private 类型，都能获取到。所以这两个函数较为常用。 下面我们举个例子来看下 getDeclaredConstructors 和 getDeclaredConstructor 的用法。1Constructor&lt;?&gt;[] getDeclaredConstructors(); 首先，构造一个类 Person：1234567891011121314151617181920212223242526public class Person &#123; private int age; private String name; public Person() &#123; &#125; private Person(int age, String name) &#123; this.age = age; this.name = name; &#125; private Person(Integer age, String name) &#123; this.age = age; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 在 Person 类中，目前我们只关心构造函数，所以我们声明了三个构造函数，有一个无参数的构造函数，和两个有参数的构造函数。我们把无参的构造函数声明为 public，另外两个都声明为 private。在上面我们说过，在四个获取构造函数的方法中，只有具有 Declared 的两个 getDeclaredXXX() 的函数才能获取类中所有的函数。而另外两个只能获取声明为 public 的函数。下面我们就利用一个例子来获取Person类的构造函数：12345678910// 1、枚举Class&lt;?&gt; clazz = Person.class;Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors();for (Constructor item:constructors)&#123; Log.d(TAG,&quot;枚举到的构造函数：&quot;+item.toString());&#125;// 2、根据类型，获取指定的构造的构造函数Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(Integer.class, String.class);Log.d(TAG, &quot;指定参数得到的构造函数：&quot;+constructor.toString()); 结果如下： 使用根据类型获取指定的构造的构造函数时，有两点要非常注意： parameterTypes 是数据类型的 Class 对象，如果是原始类型，那么应该对应的是 int.class、double.class（原始类型也是有 class 对象的）。 parameterTypes 一定要与要得到的构造函数中的参数声明顺序、类型及个数要完全匹配，如果多一个、少一个或类型不匹配也是找不到的。这一点是极其要注意的，getDeclaredConstructor 不是模糊匹配而是精确匹配。 例如上述两个私有构造函数，第一个构造函数的 age 类型是原始类型 int，第二个构造函数的 age 参数类型是 Integer。那下列语句要匹配哪个构造函数呢？1clazz.getDeclaredConstructor(Integer.class, String.class); 由于这里是严格匹配，所以这里必然匹配的是 private Person(Integer age, String name) 函数，如果我们要匹配 private Person(int age, String name) 要怎么办呢？那获取构造函数的方法就要这么写了：1clazz.getDeclaredConstructor(int.class, String.class); 这里要非常提醒大家的是，不光派生自 Object 的类具有 Class 对象，原始的数据类型也是具有 Class 对象的。 2、Constructor 构造实例利用 Constructor 的对象来构造实例时，主要是使用的是 newInstance 方法：1public T newInstance(Object... args); 可以看到 newInstance 有可以传入可变长参数，值得非常注意的是，传入的参数类型、顺序及个数都必须与当前的 Constructor 对象一一对应，不然就会报下面的错误：1java.lang.IllegalArgumentException: Wrong number of arguments; expected 2, got 0 继续使用上述 Person 类，下面来看看，如何使用 newInstance 来构造 Person 的实例：1234567891011121314151617Class&lt;?&gt; clazz = Person.class;Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(Integer.class, String.class);constructor.setAccessible(true);// 构造实例一Person person1 = (Person) constructor.newInstance(new Integer(30), new String(&quot;xian&quot;));Log.d(TAG, &quot;构造的参数为：&quot; + person1.getName() + &quot; &quot; + person1.getAge());// 构造实例二Person person2 = (Person) constructor.newInstance(50,&quot;xiao&quot;);Log.d(TAG,&quot;构造的参数为：&quot;+person2.getName() + &quot; &quot;+ person2.getAge());// 构造实例三Person person3 = (Person) constructor.newInstance();person3.setAge(30);person3.setName(&quot;xian&quot;);Log.d(TAG,&quot;构造的参数为：&quot;+person3.getName() + &quot; &quot;+ person3.getAge()); 结果如下： 这段代码总共分为四部分：第一部分：获取 Constructor 对象123Class&lt;?&gt; clazz = Person.class;Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(Integer.class, String.class);constructor.setAccessible(true); 首先，通过 getDeclaredConstructor(Integer.class, String.class) 获取指定的构造函数，要得到的这个构造函数，第一个参数是 Integer 类型，第二个参数是 String 类型。所以匹配的是下面这个构造函数：1234private Person(Integer age, String name) &#123; this.age = age; this.name = name;&#125; 最后一句利用的是 Constructor 的函数 setAccessible，它完整的声明是：1void setAccessible(boolean flag) 它代表的含义是，是否将任何函数或字段设置为可访问的。如果设置为 true，就不管这个函数或者字段是声明为 private 还是 public，都是可以访问的，默认情况下是 false，即只有 public 类型是可访问的。如果没有设置 setAccessible(true) 的话，在使用 protected 或者 private 构造函数创建实例时，会提示访问拒绝，如下所示：1234java.lang.IllegalAccessException: Class java.lang.Class&lt;com.xxt.xtest.TestActivity&gt; cannot access private method void com.xxt.xtest.Person.&lt;init&gt;(java.lang.Integer, java.lang.String) of class java.lang.Class&lt;com.xxt.xtest.Person&gt; 在反射中，总共有三种类型具有 setAccessible(boolean flag) 函数：Constructor、Field、Method；分别对应构造函数，成员变量和成员函数。我们知道在一个类中，也就只有构造函数，成员变量和成员函数这三部分，而且这三部分都可能会被设置为 private 和 protected，所以它们三个都会具有设置是否可访问的 setAccessible(boolean flag) 函数。 第二部分：使用标准的 Integer, String 构造实例123// 构造实例一Person person1 = (Person) constructor.newInstance(new Integer(30), new String(&quot;xian&quot;));Log.d(TAG, &quot;构造的参数为：&quot; + person1.getName() + &quot; &quot; + person1.getAge()); 在这个利用中，我们向 newInstance() 函数中传递的两个参数是严格遵守 constructor 所对应的构造函数的，即第一个参数是 Integer 类型，第二个参数是 String 类型。然后将 constructor.newInstance 的返回值强转成 Person 的实例。最后通过 person 的函数 person1.getName() 和 person1.getAge() 获取它的内容。 第三部分：使非标准，但可转换的参数来构造实例123// 构造实例二Person person2 = (Person) constructor.newInstance(50,&quot;xiao&quot;);Log.d(TAG,&quot;构造的参数为：&quot;+person2.getName() + &quot; &quot;+ person2.getAge()); 在这个构造方法中，我们传递的两个参数都不是标准的 Integer 和 String 类型。但第一个参数 50 是可以强转成 Integer 类型的，而第二个字符串，也是可以强转为 String 类型的。所以对于可以强转成为参数类型的数值，也是可以成功接受的。所以从结果也可以看出，我们可以成功得到 person2 中的值。 第四部分：如果不按规则传递参数会怎样我们知道，我们得到的 constructor 对应的构造函数是：private Person(Integer age, String name)，所在我们在 newInstance 的时候，必须声明这个 Constructor 时的参数类型，顺序及个数一个个传进去参数的对应值，如果我们不传、少传或者多传，结果会怎样呢？我们来看看第三个构造实例：12345// 构造实例三Person person3 = (Person) constructor.newInstance();person3.setAge(30);person3.setName(&quot;xian&quot;);Log.d(TAG,&quot;构造的参数为：&quot;+person3.getName() + &quot; &quot;+ person3.getAge()); 在这个实例中，我们没有按照 constructor 的参数顺序去填对应的值，而是压根没有填任何的值。如果我们 constructor 对应的构造函数是下面这个没有参数的构造函数的话，这么做是允许的。12public Person() &#123;&#125; 而我们这里的 constructor 对应的构造函数却是：private Person(Integer age, String name)，即便我们后面利用 set 方法重新设置进了各种参数，但这是没用的，因为在程序执行到 constructor.newInstance(); 的时候就已经报错了。错误信息为：参数个数不对。1java.lang.IllegalArgumentException: Wrong number of arguments; expected 2, got 0 3、Constructor 获取参数类型Constructor 中获取参数类型的主要有两个方法：1234// 用于解析一般函数Class&lt;?&gt;[] getParameterTypes();// 用于解析泛型对象Type[] getGenericParameterTypes(); 此处举例说明 getParameterTypes() 。下面的程序将实现，分别打印出 Person.class 中所有构造函数的参数类型列表：12345678910111213Class&lt;?&gt; clazz = Person.class;Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors();for (Constructor&lt;?&gt; c : constructors)&#123; c.setAccessible(true); Class&lt;?&gt;[] types = c.getParameterTypes(); StringBuilder builder = new StringBuilder(&quot;获取参数类型为：&quot;); for(Class t : types)&#123; builder.append(t.getName()); builder.append(&quot; &quot;); &#125; Log.d(TAG,builder.toString());&#125; 执行结果如下： 4、Constructor 获取构造函数的访问修饰符示例函数：打印出每个构造函数的访问修饰符。1234567Class&lt;?&gt; clazz = Person.class;Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors();for (Constructor&lt;?&gt; c:constructors) &#123; c.setAccessible(true); int modifier = c.getModifiers(); Log.d(TAG,&quot;一个访问修饰符为：&quot; + Modifier.toString(modifier));&#125; 结果如下： 5、Constructor getDeclaringClass()方法声明如下：1Class&lt;T&gt; getDeclaringClass(); 该函数用于得到声明 Constructor 的类的 Class 对象。用个例子来说明下：1234Class&lt;?&gt; clazz = Person.class;Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor();Class&lt;?&gt; declareClassClazz = constructor.getDeclaringClass();Log.d(TAG,declareClassClazz.getName()); 结果如下：12020-03-08 18:48:00.432 10977-10977/com.xxt.xtest D/xian: com.xxt.xtest.Person 二、成员变量的获取与设置 1、获取 Field 对象类中的信息，无外乎有三种：构造函数、成员变量和成员函数。类中成员变量相关的信息都保存在 Filed 类型的对象里。Class 中对 Field 对象的获取有下面四个函数：123456// 仅能获取声明类型为 public 的成员变量Field[] getFields();Field getField(String name);// 可以获取全部的成员变量Field[] getDeclaredFields();Field getDeclaredField(String name) 1.1、getDeclaredFields()使用上面的 Person.class 进行测试：1234567public class Person &#123; private int age; private String name; public Person() &#123; &#125; ...&#125; 在 Person 类中，我们有两个成员变量，一个是 int age，另一个是 String name，非常注意的是这两个变量全部都被声明为 private。一方面，我们只有利用 getDeclaredXXX() 系列函数才能得到他们的Field；另一方面，如果要访问每个成员变量所对应 Field 对象的信息，就必须设置 field.setAccessible(true); 。 在 Constructor 中，我们已经提到在类中的三部分：构造函数、成员变量、成员函数，他们都可能会被设置为 private 或 protected 类型，所以为了能让用户访问 private 或 protected 类型的对象，在它们三个所对应的类型 Constructor、Field、Method 中都有实现 setAccessible(boolean flag) 函数。意义与都完全一样：表示是否将当前对象设置成为可访问的。默认是 false，即如果当前对象的声明类型为 private 或 protected 就无法访问。 示例代码：1234567Class&lt;?&gt; clazz = Person.class;Field[] fields = clazz.getDeclaredFields();for (Field field : fields) &#123; field.setAccessible(true); Class&lt;?&gt; type = field.getType(); Log.d(TAG,&quot;枚举到的 field: &quot; + type.getName() + &quot; &quot; + field.getName());&#125; 结果为：1234.../com.xxt.xtest D/xian: 枚举到的 field: int age.../com.xxt.xtest D/xian: 枚举到的 field: java.lang.String name.../com.xxt.xtest D/xian: 枚举到的 field: com.android.tools.ir.runtime.IncrementalChange $change.../com.xxt.xtest D/xian: 枚举到的 field: long serialVersionUID 1.2、getDeclaredField(String name)12345Class&lt;?&gt; clazz = Person.class;Field field = clazz.getDeclaredField(&quot;age&quot;);field.setAccessible(true);Class&lt;?&gt; type = field.getType();Log.d(TAG,&quot;age field: &quot; + type.getName() + &quot; &quot; + field.getName()); 结果为：1.../com.xxt.xtest D/xian: age field: int age 2、Field：get &amp; set2.1、get() &amp; set()当获取或设置指定类对象中某变量的值时，可以使用 Field 中的 get、set 方法，声明如下：12void set(Object object, Object value)Object get(Object object) 示例代码：123456789Class&lt;?&gt; clazz = Person.class;Constructor&lt;?&gt; constructor = clazz.getConstructor();Person person = (Person)constructor.newInstance();Field fName = clazz.getDeclaredField(&quot;name&quot;);fName.setAccessible(true);fName.set(person, &quot;xian&quot;);String val = (String)fName.get(person);Log.d(TAG, &quot;fieldName: &quot; + val + &quot;, personName: &quot; + person.getName()); 结果如下：1.../com.xxt.xtest D/xian: fieldName: xian, personName: xian 大家注意，在 set 时，第一个参数是要设置的 Person 的实例，第二个参数是这个 Field 所对应的值。在 get 时，传递的参数是当前要获取的 Person 实例，得到的是当前实例中对应成员变量的值。 2.2、get 系列函数与 set 系列函数再回过头来看上面的 get 与 set 函数：12void set(Object object, Object value)Object get(Object object) 在 set 中，要传入所 Field 的值必须是派生自 Object 类型的，也就规定这个 Field 的所对应的成员变量类型就必须是派生自 Object 的的类型，比如 Integer、String 等。 那么问题就来了，那我们的成员变量的类型，并不一定是派生自 Object 的类型啊，也可能是原始的数据类型，比如 int、double、char、byte 等，那这些类型的成员变量的值要怎么设置与获取呢？为了解决这个问题，Java 的开发者们额外开发了几对 get 与 set 函数：123456789101112131415161718192021222324// 设置与获取 int 类型的值void setInt(Object object, int value)int getInt(Object object)// 设置与获取 double 类型的值void setDouble(Object object, double value)double getDouble(Object object)// 设置与获取 float 类型的值void setFloat(Object object, float value)float getFloat(Object object)// 设置与获取 bool 类型的值void setBoolean(Object object, boolean value)boolean getBoolean(Object object)// 设置与获取 short 类型的值void setShort(Object object, short value)short getShort(Object object)// 设置与获取 long 类型的值void setLong(Object object, long value)long getLong(Object object)// 设置与获取 byte 类型的值void setByte(Object object, byte value)byte getByte(Object object)// 设置与获取 char 类型的值void setChar(Object object, char value)char getChar(Object object) 示例代码：···Class&lt;?&gt; clazz = Person.class;Constructor&lt;?&gt; constructor = clazz.getConstructor();Person person = (Person)constructor.newInstance(); Field fAge = clazz.getDeclaredField(“age”);fAge.setAccessible(true);fAge.setInt(person, 20);Log.d(TAG, “fieldAge: “ + fAge.getInt(person) + “, personAge:” + person.getAge());···结果为：1.../com.xxt.xtest D/xian: fieldAge: 20, personAge:20 3、Field 之 isEnumConstant()1boolean isEnumConstant() 这个函数用于判断当前 Field 是否为枚举常量。举例：12345678public class Person &#123; public static enum COLOR&#123;WHITE,BLACK,YELLOW&#125; private int age; private String name; private COLOR color; ...&#125; 测试代码：123456789Class&lt;?&gt; clazz2 = Person.COLOR.class;Field field = clazz2.getDeclaredField(&quot;WHITE&quot;);Log.d(TAG,&quot;COLOR.WHITE 是否是枚举常量：&quot; + field.isEnumConstant());Class&lt;?&gt; clazz = Person.class;Field fColor = clazz.getDeclaredField(&quot;color&quot;);fColor.setAccessible(true);boolean isEnum = fColor.isEnumConstant();Log.d(TAG,&quot;color 是否是枚举常量：&quot; + isEnum); 结果为：122020-03-08 19:30:42.298 15040-15040/com.xxt.xtest D/xian: COLOR.WHITE 是否是枚举常量：true2020-03-08 19:30:42.298 15040-15040/com.xxt.xtest D/xian: color 是否是枚举常量：false 我们从结果中可以看到，首先 COLOR 枚举类中的 WHITE 是一个枚举常量，而利用 COLOR 定义的 color 变量不是枚举常量。 4、Field Modifiers getDeclaringClass()1234// 获取该成员变量所对应的访问修饰符组所对应的 Int 数字int getModifiers()// 获取声明该变量的类Class&lt;?&gt; getDeclaringClass() getModifiers()：获取该 Field 所对应的成员变量的访问修饰符。getDeclaringClass()：获取声明该成员变量的类的 Class 对象。1234Class&lt;?&gt; clazz = Person.class;Field fAge = clazz.getDeclaredField(&quot;age&quot;);Class&lt;?&gt; declareClazz = fAge.getDeclaringClass();Log.d(TAG, declareClazz.toString()); 结果为：1.../com.xxt.xtest D/xian: class com.xxt.xtest.Person 三、成员函数的获取与设置 1、获取 Method 对象与成员变量对应的类型为 Field 类似，类中的方法对应的类型是 Method。获取指定类中的成员函数的方法有下面四种方法：12345Method[] getMethods()Method getMethod(String name, Class&lt;?&gt;... parameterTypes)Method[] getDeclaredMethods()Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) 与上面所有的有 Declared 系列的函数组一样，getMethods() 和 getMethod() 只能获取声明为 public 的函数。而 getDeclaredMethods()、getDeclaredMethod() 可以得到所有的函数，无论声明为 public、protected 还是 private。 1.1、getDeclaredMethods()该函数能够获取类中所有声明的函数（不包括构造函数），举个例子来看他使用方法：12345Class&lt;?&gt; clazz = Person.class;Method[] methods = clazz.getDeclaredMethods();for (Method m : methods) &#123; Log.d(TAG, &quot;枚举到的方法：&quot; + m.toString());&#125; 结果为： 1.2、getDeclaredMethod(String, Class&lt;?&gt;…)1Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) name：表示要获取 Method 对象的成员函数名。 parameterTypes：需要匹配的成员函数需要传入的参数的类型，这里需要非常注意，这里的 getDeclaredMethod 是精确匹配的，如果我们传入的函数名以及参数类型、顺序、个数与该函数声明不一致的话，就会报错。 值得非常注意的是，当我们要找的方法所对应的参数类型是原始数据类型，比如 Int、double 等，它们所对应的 Class 对象为 int.class、double.class 即可；所以原始类型也是有 Class对象的。 示例代码：123Class&lt;?&gt; clazz = Person.class;Method method = clazz.getDeclaredMethod(&quot;setName&quot;, String.class);Log.d(TAG, &quot;方法：&quot; + method.toString()); 结果为：1.../com.xxt.xtest D/xian: 方法：public void com.xxt.xtest.Person.setName(java.lang.String) 2、Method InvokeInvoke 函数无疑是 Method 类中最重要的方法，它的功能是用于执行 Method 对象所对应的函数。完整的声明如下：1Object invoke(Object receiver, Object... args) Object receiver：指要执行该函数的类对象，比如我们的 Person 类的某一实例。 Object… args：可变长参数，用于传入该函数声明中的参数所对应的值的列表。 返回值：Object，将函数的结果返回，Object 对象就是执行此函数后返回的结果。 我们在 Person 中单独再加一个函数：12345678public class Person &#123; ... public Boolean testInvoke(Integer age, String name) &#123; Log.d(&quot;xian&quot;,&quot;得到参数 age: &quot; + age + &quot;, name: &quot;+name); return true; &#125;&#125; 示例代码：123456Class&lt;?&gt; clazz = Person.class;Person person = new Person();Method method = clazz.getDeclaredMethod(&quot;testInvoke&quot;, Integer.class, String.class);method.setAccessible(true);Boolean result = (Boolean)method.invoke(person, 25, &quot;I m xian&quot;);Log.d(TAG,&quot;执行结果: &quot;+result); 结果为：122020-03-08 19:53:51.572 16600-16600/com.xxt.xtest D/xian: 得到参数 age: 25, name: I m xian2020-03-08 19:53:51.573 16600-16600/com.xxt.xtest D/xian: 执行结果: true 这里总结一下，从 Field、Method 中都可以看出，Field、Method 的对象对应的不是哪个类实例中变量，而是类中变量的对象。也就是说，Field、Method 对象只有一个，是在编译时，保存在 Class 中的。而 Person 的实例却可以有很多个，如果要改变哪个 Person 实例中成员变量的值，就必须将该 Person 实例传入 Field 对象的参数中，让 Field 对象设置。 3、Method 获取参数类型与其它类的获取参数类型一样，这里同样针对普通变量和泛型有两种获取参数类型的方法：1234// 用于获取普通的参数类型Class&lt;?&gt;[] getParameterTypes()// 用于获取带有泛型参数的类型Type[] getGenericParameterTypes() 示例代码：123456Class&lt;?&gt; clazz = Person.class;Method method = clazz.getDeclaredMethod(&quot;testInvoke&quot;, Integer.class, String.class);Class&lt;?&gt;[] params = method.getParameterTypes();for (Class c : params)&#123; Log.d(TAG,&quot;枚举到参数类型：&quot;+c.getName());&#125; 结果为：122020-03-08 19:58:29.982 16600-16600/com.xxt.xtest D/xian: 枚举到参数类型：java.lang.Integer2020-03-08 19:58:29.982 16600-16600/com.xxt.xtest D/xian: 枚举到参数类型：java.lang.String 4、Method 获取返回值类型获取指定成员函数返回值类型的方法，同样根据返回值是否是泛型，同样有两种方法：12Class&lt;?&gt; getReturnType()Type getGenericReturnType() 示例代码：1234Class&lt;?&gt; clazz = Person.class;Method method = clazz.getDeclaredMethod(&quot;testInvoke&quot;, Integer.class, String.class);Class type = method.getReturnType();Log.d(TAG, &quot;返回值类型为：&quot; + type.getName()); 结果为：12020-03-08 20:01:26.430 16600-16600/com.xxt.xtest D/xian: 返回值类型为：java.lang.Boolean 四、实战实例讲解 1、Fragment.instantiate()在 V4 包中，Fragment 有一个函数，可以根据指定 Fragment 的路径名来得到对应 Fragment 的实例。它的完整声明如下：1public static Fragment instantiate(Context context, String fname, Bundle args) context：Context 类型对象; fname：对应 Fragment 类的完整的路径名，可以利用 Class.getName() 得到。 args：是在构造 Fragment 实例时需要的 Bundle参数。 使用方法新建一个Fragment：1234567import androidx.fragment.app.Fragment;public class DemoFragment extends Fragment &#123; public void printFragment(String name)&#123; Log.d(&quot;xian&quot;, name + &quot;知道你是个逗逼&quot;); &#125;&#125; 然后我利用 Fragment.instantiate 来获取它的实例：123Class&lt;?&gt; clazz = DemoFragment.class;DemoFragment fragment = (DemoFragment) Fragment.instantiate(this, clazz.getName(), null);fragment.printFragment(&quot;先小涛&quot;); 结果为：12020-03-08 20:10:23.552 17684-17684/com.xxt.xtest D/xian: 先小涛知道你是个逗逼 原理这个函数内部是如何实现的吧：12345678910111213141516171819202122232425public static Fragment instantiate(Context context, String fname, @Nullable Bundle args) &#123; try &#123; // 根据 fname 得到对应 Fragment 的 Class 对象 Class&lt;?&gt; clazz = sClassMap.get(fname); // 首先通过一个 sClassMap 中查找一下。如果没有，则通过 // ClassLoader 将其加载到内存中，并将其保存到 sClassMap中。 if (clazz == null) &#123; // Class not found in the cache, see if it&apos;s real, and try to add it clazz = context.getClassLoader().loadClass(fname); sClassMap.put(fname, clazz); &#125; // 得到对应 Fragment 的实例 Fragment f = (Fragment) clazz.getConstructor().newInstance(); if (args != null) &#123; // 将传入的 Bundle 参数 args 加入到 Fragment 的 mArguments参数对象中 args.setClassLoader(f.getClass().getClassLoader()); f.setArguments(args); &#125; // 将 Fragment 的实例 f 返回 return f; &#125; catch (ClassNotFoundException e) &#123; ... &#125; ...&#125; 2、PopupWindow.setTouchModal()如果我想要一个效果：点击 PopupWindow 外部区域，弹窗不消失，但是点击事件会向下面的 activity 传递，这时候就需要用到 PopupWindow 的 setTouchModal(boolean touchModal) 函数。该函数完整声明为：12345678/** * Set whether this window is touch modal or if outside touches will be sent to * other windows behind it. * @hide */public void setTouchModal(boolean touchModal) &#123; mNotTouchModal = !touchModal;&#125; 在注解中，利用 @hide 将此函数隐藏了，我们通过 PopupWindow对象是没有办法得到调用它的。 所以我们只有通过反射来做。下面我们来举个例子来调用这个函数：1234567891011121314public static void setPopupWindowTouchModal (PopupWindow popupWindow, boolean touchModal) &#123; if (null == popupWindow) &#123; return; &#125; try &#123; Method method = PopupWindow.class.getDeclaredMethod( &quot;setTouchModal&quot;, boolean.class); method.setAccessible(true); method.invoke(popupWindow, touchModal); &#125; catch (Exception e) &#123; System.out.println(e); &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射二：泛型相关周边信息获取]]></title>
    <url>%2F1900%2F01%2F11%2F00JAVA%2F11%20%E5%8F%8D%E5%B0%84%E4%BA%8C%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%91%A8%E8%BE%B9%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%2F</url>
    <content type="text"><![CDATA[原文链接：夯实JAVA基本之二 —— 反射（2）：泛型相关周边信息获取 相关文章：Java RelfectJava RelfectUtils反射一：基本类周边信息获取反射二：泛型相关周边信息获取反射三：类内部信息获取 在上篇中，讲解了如何利用反射来获取普通类型的类的使用，今天给大家讲解下，有关如何使用反射来获取泛型中的信息。 一、获取泛型超类和接口的相关信息 在这部分内容中，我们将讲述如何获取泛型的超类和接口，把上篇中遗留下来的两个函数先讲完。 1、获取泛型超类相关信息上篇中，我们讲了，要获取泛型类型的超类，要用到一个函数：12// 针对泛型父类而设计public Type getGenericSuperclass(); 下面我们就先看看这个函数怎么用，我们依然以上篇中的 Point 类以及它的派生类 PointImpl 为例：12345678910111213141516171819// Point 泛型类的实现public class Point&lt;T&gt; &#123; private T x,y; public T getX() &#123; return x; &#125; public void setX(T x) &#123; this.x = x; &#125; public T getY() &#123; return y; &#125; public void setY(T y) &#123; this.y = y; &#125;&#125;// PointImpl 类的实现public class PointImpl extends Point&lt;Integer&gt; &#123;&#125; 从上面的代码中，我们可以看到，Point 类是一个泛型类，具有一个泛型变量 T；而 PointImpl 派生自 Point 并且在派生时，将 Point 进行填充为 Point&lt;Integer&gt;，即将 Point 中的泛型变量填充为 Integer 类型。 下面， 我们将通过反射获取 PointImpl 的父类的类型，以及 PointImpl 的填充类型。我们在没看代码之前，我们先看看结果，我们知道 PointImpl 的父类类型是 Point，而 PointImpl 的填充类型应该是 Integer。然后我们再看看代码：12345678910111213141516Class&lt;?&gt; clazz = PointImpl.class;Type type = clazz.getGenericSuperclass();if (type instanceof ParameterizedType) &#123; ParameterizedType parameterizedType = (ParameterizedType) type; // 返回表示此类型实际类型参数的 Type 对象的数组 Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for (Type parameterArgType : actualTypeArguments) &#123; Class parameterArgClass = (Class) parameterArgType; Log.d(TAG,&quot;填充类型为：&quot; + parameterArgClass.getName()); &#125; // 返回 Type 对象，表示声明此类型的类或接口。 Type type1 = parameterizedType.getRawType(); Class class22 = (Class) type1; Log.d(TAG, &quot;PointImpl 的父类类型为：&quot; + class22.getName());&#125; 结果如下： 从结果中，我们可以看到，先获得到的是 PointImpl 在填充父类时的类型 Integer，然后获得的是 PointImpl 的父类类型。下面先看如何获取当前类在填充父类时的填充类型的。对应代码是这一块：1234567891011Class&lt;?&gt; clazz = PointImpl.class;Type type = clazz.getGenericSuperclass();if (type instanceof ParameterizedType) &#123; ParameterizedType parameterizedType = (ParameterizedType) type; // 返回表示此类型实际类型参数的 Type 对象的数组 Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for (Type parameterArgType : actualTypeArguments) &#123; Class parameterArgClass = (Class) parameterArgType; Log.d(TAG, &quot;填充类型为：&quot; + parameterArgClass.getName()); &#125;&#125; 1.1、获取泛型超类12Class&lt;?&gt; clazz = PointImpl.class;Type type = clazz.getGenericSuperclass(); 在这段代码中，我们通过 clazz.getGenericSuperclass() 获取 PointImpl.class 的超类。由于我们知道 PointImpl.class 的父类是泛型，所以我们只能使用 clazz.getGenericSuperclass() 来获取。得到的 type 的值对应的是 Point，而 type 对应的是 ParameterizedType，所以我们用 type instanceof ParameterizedType 来识别，然后将 type 变量强转为 ParameterizedType变量；再然后利用 parameterizedType.getActualTypeArguments() 获取当前泛型变量的填充列表，我们知道 Point 中泛型变量 T 被填充为Integer，所以我们得到的数组 Type[] 里，只有一个值，它对应的就是 Integer.Class；最后我们将得到的 Type 进行强转成 Class 类型，所以 parameterArgClass 对应的值就是 Integer.Class。所以parameterArgClass.getName() 的值为：java.lang.Integer。 上述所说的 Type 是什么呢？ 1.2、Type 类型我们先看看 Type 的源码，看他自己是怎么说的：123456789package java.lang.reflect; /** * Common interface implemented by all Java types. * @since 1.5 */public interface Type &#123; // Empty&#125; Type 是一个接口，这里意思是它是 Java 所有类型都会继承这个接口。但通过源码会发现 String、Integer、Double 这些类都没有继承这个接口，就连 Object 也没继承。再仔细查代码会出现，Class 继承了这个接口：123public final class Class&lt;T&gt; implements Serializable, AnnotatedElement, GenericDeclaration, Type &#123; ...&#125; 所以说，这个 Type 类型是泛型所特有的。那它用是来做什么的呢？他就是用来标识，当前 Class 中所填充的类型的。意思是，当我们在填充一个泛型时，比如上面我们的 PointImpl extends Point，这个填充类型就会放在 Type 的保存起来，当需要用到的时候再取出来。那问题又来了，我们这里填充的是 Integer 类型，那如果我们填充的是数组泛型呢，比如 Point，再假如我们填充的是一个通配符呢？这Type要怎么识别呢？ 为了解决这个问题，Java 的开发者，在 Type 的基础上派生了另外几个接口，分别来保存不同的类型，他们分别是： ParameterizedType这就是上面我们代码中用到的，他代表的是一个泛型类型，比如 Point，它就是一个泛型类型。 TypeVariable这个代表的就是泛型变量，例如 Point&lt;T&gt;，这里面的 T 就是泛型变量，而如果我们利用一种方法获得的对象是 T，那它对应的类型就是 TypeVariable。这个类型的应用后面会细讲。 WildcardType上面的 TypeVariable 对应的是泛型变量，而如果我们得到不是泛型变量，而是通配符比如：? extends Integer，那它对应的类型就是WildcardType。 GenericArrayType如果我们得到的是类似 String[] 这种数组形式的表达式，那它对应的类型就是 GenericArrayType，非常值得注意的是如果 type 对应的是表达式是 ArrayList 这种的，这个 type 类型应该是 ParameterizedType，而不是 GenericArrayType，只有类似 Integer[] 这种的才是 GenericArrayType 类型。 虽然我们后面会对 TypeVariable、WildcardType 进行讲解，这里还是先对他们三个类型对应的意义先总结一下，比如我们这里的 clazz.getGenericSuperclass()，得到的 Type 对应的是完整的泛型表达式即：Point，那它对应的类型就是 ParameterizedType，如果我们得到的 Type 对应的表达式，仅仅是 Point 中用来填充泛型变量 T 的 Integer，那这个 Type 对应的类型就是 TypeVariable，如果我们得到的是依然是填充泛型变量 T 的填充类型，这而个填充类型却是通配符 ？，那这个 Type 对应的类型就是 WildcardType。这一段看不大明白也没关系，后面还会再讲。 1.3、ParameterizedType上面我们已经提到当获取的 Type 类型，对应的是一个完整泛型表达式的时候（比如，我们这里获取到的 PointImpl.class 的父类）type 对应的完整表达式就是 Point。 在 ParameterizedType 中有两个极有用的函数：12Type[] getActualTypeArguments();Type getRawType(); getActualTypeArguments()用来返回当前泛型表达式中，用来填充泛型变量的真正值的列表。像我们这里得到的 Point，用来填充泛型变量 T 的是 Integer 类型，所以这里返回的 Integer 类型所对应的 Class 对象。 getRawType()上面示例这个它返回的值是 com.xxt.xtest.Point，它的意义是声明当前泛型表达式的类或者接口的 Class 对象。比如，我们这里的 type 对应的是 Point，而声明 Point 这个泛型的当然是 Point 类型，所以返回的是 Point.Class。 下面我们再回过来看看 getActualTypeArguments()。 我们上面说到，这个函数将返回用来填充泛型变量真实参数列表。像我们这里的是 Point，将返回 Integer 对应的 Class 对象。而并不是所有的每次都会返回填充类型对应的 Class 对象。我们知道我们在填充一个泛型时，是存在各种可能的，比如 Point、Point&lt;? extends Number&gt;、Point、Point]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射一：基本类周边信息获取]]></title>
    <url>%2F1900%2F01%2F10%2F00JAVA%2F10%20%E5%8F%8D%E5%B0%84%E4%B8%80%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%91%A8%E8%BE%B9%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%2F</url>
    <content type="text"><![CDATA[原文链接：夯实JAVA基本之二 —— 反射（1）：基本类周边信息获取 相关文章：Java RelfectJava RelfectUtils反射一：基本类周边信息获取反射二：泛型相关周边信息获取反射三：类内部信息获取 JAVA 反射机制是在运行状态中，对于任何一个类，都能够知道这个类的所有属性和方法；对于任何一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 JAVA 语言的反射机制。 一、引入 在开始反射之前，我们先看看 JVM 是如何将我们写的类对应的 java 文件加载到内存中的。 1、类的生命周期这部分我们先讲讲 JVM 的加载机制。写一个最简单的 Main 函数，来看看这个函数的是如何被执行的，代码如下：1234567891011121314151617public class Test &#123; public static void main(String[] args) &#123; Animal animal = new Animal(); animal.setName(&quot;cat&quot;); &#125; // 内部静态类 public static class Animal &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125;&#125; 这段代码很简单，我们定义了一个 Animal 的类，在 main() 函数中，我们首先定义了一个 Animal 实例，然后调用了该实例的 setName() 方法。 大家都知道，在拿到一个 java 源文件后，如果要经过源码编译，要经过两个阶段：编译（javac.exe）、运行（java.exe）。 编译 1javac Test.java 在执行后在同一目录下生成 Test.class 和 Animal 类对应的文件Test\$Animal.class（由于我们的 Animal 类是 Main 中的内部类，所以用 $ 表示）。 运行 1java Main 在这一阶段，又分为三个小阶段：装载，链接，初始化。 装载类的装载是通过类加载器完成的，加载器将 .class 文件的二进制文件装入 JVM 的方法区，并且在堆区创建描述这个类的 java.lang.Class 对象，用来封装数据。 但是同一个类只会被类装载器装载一次！ 链接链接就是把二进制数据组装为可以运行的状态。链接分为校验、准备、解析这三个阶段。校验一般用来确认此二进制文件是否适合当前的 JVM（版本），准备就是为静态成员分配内存空间，并设置默认值。解析指的是转换常量池中的代码作为直接引用的过程，直到所有的符号引用都可以被运行程序使用（建立完整的对应关系）。 初始化初始化就是对类中的变量进行初始化值。完成之后，类型也就完成了初始化，初始化之后类的对象就可以正常使用了，直到一个对象不再使用之后，将被垃圾回收，释放空间。 当没有任何引用指向 Class 对象时就会被卸载，结束类的生命周期。如果再次用到就再重新开始装载、链接和初始化的过程。 2、获取类类型2.1、泛型隐藏填充类型泛型隐藏填充类型默认填充为无界通配符？在上面，我们讲了，类只会被装载一次，利用装载的类可以实例化出各种不同的对象。而反射就是通过获取装载的类来做出各种操作的。装载的类，我们称为类类型，利用装载的类产生的实例，我们称为类实例。下面我们就看看，如何利用代码获取类类型的：123456// 使用方法一Class class1 = Animal.class;Log.i(TAG, class1.getName());// 使用方法二Class&lt;?&gt; class2 = Animal.class;Log.i(TAG, class2.getName()); 运行结果如下： 从结果中可以看出 class1 和 class2 是完全一样的，那构造他们时的方法一和方法二有什么区别呢？1234// 使用方法一Class class1 = Animal.class;// 使用方法二Class&lt;?&gt; class2 = Animal.class; 可以看到这两个方法，右边全部都是 Animal.class，而左边却有些不同。方法一中，是直接生成了一个 Class 的实例。而在方法二中，则生成的是一个 Class 的泛型，并且使用的是无界通配符来填充的。我们都知道，Class 类是一个泛型，而泛型的正规写法就应该是1Class&lt;Animal&gt; class2 = Animal.class; 而方法一，只是把泛型的填充给省略了.在泛型中，如果把泛型的填充给省略掉，那就会默认填充为无界通配符”？”。所以方法一的真实写法是这样的：1Class&lt;?&gt; class1 = Animal.class; 所以这两种写法是意义是完全相同的。如果我们不用通配符，也就只能这样写：1Class&lt;Animal&gt; class2 = Animal.class; 2.2、获取类类型的方法上面我们通过 Class&lt;?&gt; class1 = Animal.class; 即直接使用类名的 Class 对象来获取类类型，这只是其中一个方法，下面这四种方法都可以获得对应的类类型：123456789// 方法一：Person person = new Person(); Class a = person.getClass() // 方法二：Class b = Persion.class;// 方法三：Class c = Class.forName(String className); // 方法四：（不建议使用）Class d = context.getClassLoader().loadClass(String className); 方法一：通过类实例的 getClass() 方法得到类类型；方法二：直接通过类的 class 对象得到；方法三和方法四中是通过类名得到，这两点要非常注意，这里的 className 一定要从包名具体到类名，唯一定位到一个类才行，不然就会报 ClassNotFound 错误。 在上面我们提到过，类只会被加载一次，所以 a、b、c、d 都是相等的，因为他们都是指向同一个对象，如果用等号操作符来判断的话：1boolean result = (clazz1 == clazz2 &amp;&amp; clazz3 == clazz4 &amp;&amp; clazz1 == clazz3); result 的值为 true。 下面我们针对方法三和方法四举个粟子来看下：有一个单独的 Animal 类：1234567891011public class Animal &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 测试方法：1234567891011121314151617181920212223242526272829public class TestActivity extends BaseActivity &#123; private static final String TAG = &quot;xian&quot;; private Button btnCancel; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_test); btnCancel = findViewById(R.id.login_cancel_btn); btnCancel.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; try &#123; test(); &#125; catch (Exception e) &#123;&#125; &#125; &#125;); &#125; private void test() throws Exception &#123; Class&lt;?&gt; class1 = Class.forName(&quot;com.xxt.xtest.Animal&quot;); Log.d(TAG,&quot;通过 Class.forName 获得的类名：&quot; + class1.getName()); class1 = getClassLoader().loadClass(&quot;com.xxt.xtest.Animal&quot;); Log.d(TAG,&quot;通过 ClassLoader 获得的类名：&quot;+class1.getName()); &#125;&#125; 结果如下： 从上面的用法中，可以看出，我们要使用 Class.forName() 或者 getClassLoader().loadClass()，其中的类名必须是从包名到类名的完整路径。 从这里看来 Class.forName() 和 getClassLoader().loadClass() 是相同的，其实他们是有区别的。平时，我们不建议使用 getClassLoader().loadClass() 的方法来加载类类型。有关Class.forName() 和 getClassLoader().loadClass() 的具体区别，会在本篇末尾讲述。 二、基本类类型周边信息获取我们知道类分为基本类和泛型类，这篇我们只讲基本类类型的周边信息获取，有关泛型类的周边信息获取，我们会放到下一篇中。这部分主要讲述类类型周边信息获取方法，包括类名，包名，超类和继承接口。 1、类名、包名获取相关的有三个函数：123456// 获取完整的类名（包含包名）public String getName();// 仅获取类名public String getSimpleName();// 获取类类型所对应的 package 对象，几乎不用public Package getPackage() 函数使用如下：123456Class&lt;?&gt; class1 = Animal.class;Package package1 = class1.getPackage(); Log.d(TAG,&quot;完整的类名：&quot; + class1.getName());Log.d(TAG,&quot;仅获取类名：&quot; + class1.getSimpleName());Log.d(TAG,&quot;包名：&quot; + package1.getName()); 结果如下： 从结果中很清晰的看到，class.getName() 获取的是类名包含完整路径。调用 Class.forName() 就是用的这个值。class.getSimpleName() 得到的是仅仅是一个类名。而 class.getPackage() 得到的是该类对应的 Package 对象。通过 package.getName() 能获得该类所对应的包名。 2、获取超类 Class 对象获取 superClass 的类对象，涉及到两个函数：1234// 获取普通函数的父类 Class 对象public Class&lt;?&gt; getSuperclass();// 针对泛型父类而设计public Type getGenericSuperclass(); getSuperclass() 用来获取普通函数，而 getGenericSuperclass() 是用来获取泛型类型的父类而设计的，有关 getGenericSuperclass() 的知识我们后面会讲，这里先看看 getSuperclass() 的用法。 我们仍然利用前面讲到的 Animal 类，然后在其上派生一个 AnimalImpl 子类：1234567891011121314public class Animal &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; public class AnimalImpl extends Animal &#123;&#125; 然后使用：123Class&lt;?&gt; class2 = Class.forName(&quot;com.xxt.xtest.AnimalImpl&quot;);Class&lt;?&gt; parentClass = class2.getSuperclass();Log.d(TAG, &quot;父类：&quot; + parentClass.getName()); 结果如下： 在这里，我们使用了 Class.forName(“com.xxt.xtest.AnimalImpl”); 找到 AnimalImpl 的类类型对象，然后调用 class2.getSuperclass() 找到它的父类 Class 对象。很明显，它的父类是 Animal 类。由于我们这里得到了父类的 Class 对象 parentClass，所以可以对它使用 Class 的一切函数。所以调用 parentClass.getName() 就可以获得父类的名称了。 3、直接继承的接口的 Class 对象这里要先声明一个观点：Class 类，不同于定义类的 class 标识，Class 类是一个泛型。类对象是由 Class 对象来表示，而接口对象同样也是用 Class 对象来表示。所以同样是 Class 对象，它可能表示的类对象，也可能表示的是接口对象。获取接口对象的函数如下：1234// 获取普通接口的方法public Class&lt;?&gt;[] getInterfaces();// 获取泛型接口的方法public Type[] getGenericInterfaces(); 与获取 superClass 对象一样，这里同样有两个函数来获取接口对象，有关 getGenericInterfaces() 获取泛型接口的方法，我们下篇再讲，这里先讲讲获取普通接口的方法 getInterfaces()。 getInterfaces() 将获取指定类直接继承的接口列表，注意是直接继承。如果不是直接继承，那将是获取不到的。举个例子，以上面的 Animal 为例： 我们先声明一个接口，让 Animal 类来继承：1234public interface IAnimal &#123; void setName(String name); String getName();&#125; 然后是 Animal 类继承接口：12345678910111213public class Animal implements IAnimal &#123; private String name; @Override public String getName() &#123; return name; &#125; @Override public void setName(String name) &#123; this.name = name; &#125;&#125; 为了测试不是直接继承的接口是无法获取的问题，我们再从 Animal 派生一个子类 AnimalImpl:12public class AnimalImpl extends Animal &#123;&#125; 我们再整理一下思路，Animal 类直接继承了 IAnimal，而 AnimalImpl 仅仅派生自 Animal，它的 IAnimal 接口不是直接继承的，而是从它的父类 Aniaml 那带过来的。 然后我们分别看看 Animal 类和 AnimalImpl 类的的获取接口的结果，完整的代码如下：1234567891011121314151617// 获取 Animal 类的接口列表Class&lt;?&gt; class3 = Animal.class;Class&lt;?&gt;[] interfaces = class3.getInterfaces();for (Class interItem:interfaces)&#123; Log.d(TAG, &quot;Animal 继承的接口：&quot; + interItem.getName());&#125; // 获取 AnimalImpl 的接口列表class3 = AnimalImpl.class;interfaces = class3.getInterfaces();if (interfaces.length &gt;0) &#123; for (Class interItem : interfaces) &#123; Log.d(TAG, &quot;AnimalImpl 继承的接口：&quot; + interItem.getName()); &#125;&#125; else &#123; Log.d(TAG, &quot;AnimalImpl 无继承的接口&quot;);&#125; 结果如下： 从结果可以看出，这里找到了 Animal 类所继承的接口值；但 AnimalImpl 获取到的接口列表为空。所以这也证明了 getInterfaces() 只能获取类直接继承的接口列表。 4、获取某个类类型的所有接口如果我想传进去一下类类型，然后要得到它所有继承的接口列表要怎么办？不管它是不是直接继承来的都要列出来。 那只有靠递规了，我们需要递规它的父类直接继承的接口、父类的父类直接继承的接口以此类推，最终到 Object 类的时候就找到所有继承的接口了。 在开始递规获取所有接口之前，我们先构造下代码。由于我们要获取所有接口，为了效果更好些，我们在 Animal 和 AnimalImpl 基础上，多加几个继承的接口：1234567891011121314151617// 给 Animal 添加 IAnimal、Serializable 两个接口public class Animal implements IAnimal, Serializable &#123; private String name; @Override public String getName() &#123; return name; &#125; @Override public void setName(String name) &#123; this.name = name; &#125;&#125;// 给 AnimalImpl 添加 Serializable 接口public class AnimalImpl extends Animal implements Serializable &#123;&#125; 所以如果我们获取 AnimalImpl 类的接口列表，得到的应该是三个：自已直接继承的 Serializable、从父类 Animal 那继承的 IAnimal 和 Serializable。获取类类型所有接口列表的方法：123456789101112131415161718192021222324252627282930/** * 获取所传类类型的所有继承的接口列表 * @param clazz * @return */public Class&lt;?&gt;[] getAllInterface(Class&lt;?&gt; clazz)&#123; // 获取自身的所有接口 Class&lt;?&gt;[] interSelf = clazz.getInterfaces(); // 递规调用getAllInterface获取超类的所有接口 Class&lt;?&gt; superClazz = clazz.getSuperclass(); Class&lt;?&gt;[] interParent = null; if (null != superClazz) &#123; interParent = getAllInterface(superClazz); &#125; // 返回值 if (interParent == null &amp;&amp; interSelf != null) &#123; return interSelf; &#125; else if (interParent == null &amp;&amp; interSelf == null)&#123; return null; &#125; else if (interParent != null &amp;&amp; interSelf == null)&#123; return interParent; &#125; else &#123; final int length = interParent.length + interSelf.length; Class&lt;?&gt;[] result = new Class[length]; System.arraycopy(interSelf,0,result,0,interSelf.length); System.arraycopy(interParent,0,result,interSelf.length,interParent.length); return result; &#125;&#125; 测试代码：1234567Class&lt;?&gt;[] clazzes = getAllInterface(AnimalImpl.class);SpannableStringBuilder builder = new SpannableStringBuilder();for (Class clazz : clazzes) &#123; builder.append(clazz.getName()); builder.append(&quot; &quot;);&#125;Log.d(TAG, &quot;AnimalImpl 继承的所有接口: &quot; + builder.toString()); 先看看执行结果： 这段代码最关键的地方在于 getAllInterface(Class&lt;?&gt; clazz)；代码分为两部分，第一部分是获得自己的接口列表和父类的列表：通过 Class&lt;?&gt;[] interSelf = clazz.getInterfaces(); 获得自已直接继承的接口列表。然后，通过 Class&lt;?&gt; superClazz = clazz.getSuperclass(); 获取父类的 Class 类型，然后调用 getAllInterface(superClazz) 获得父类的所有接口列表。那么，把它们两个合并，就是所有的接口列表了。 合并逻辑：对 interParent 和 interSelf 判空，如果两个列表都是空，那直接返回空；如果有一个是空，另一个不是空，则返回那个不是空的列表；如果两个都不是空，则将他们合并，然后返回合并后的列表。 5、获取类的访问修饰符由于我们在定义类时，比如下面的内部类：12public static final class InnerClass &#123;&#125; 在类名，前面的那一坨 public static final，就是类的访问修饰符，是定义这个类在的访问区域和访问限定的。这部分就讲讲如何获取类的这部分访问修饰符，以上面的内部类 InnerClass 为例：123456Class&lt;?&gt; clazz = getClassLoader().loadClass(InnerClass.class.getName());int modifiers = clazz.getModifiers();String retval = Modifier.toString(modifiers);boolean isFinal = Modifier.isFinal(modifiers);Log.d(TAG, &quot;InnerClass 的定义修饰符: &quot; + retval);Log.d(TAG, &quot;is Final: &quot; + isFinal); 结果如下： 首先，在这部分代码中，我们又换了一种类加载方式，使用的是 ClassLoader。然后我们单独来看看这句：1int modifiers = clazz.getModifiers(); 通过 clazz.getModifiers() 得到一个整型变量，由于访问修饰符有很多，所以这些修饰符被打包成一个 int，对应的二进制中，每个修饰符是一个标志位，可以被置位或清零。另外 Java 开发人员单独提供了一个类来提取这个整型变量中各标识位的函数，这个类就是 Modifier。Modifier 中主要有以下几个方法：123456789101112131415// 根据整型变量来生成对应的修饰符字符串String Modifier.toString(int modifiers) // 以下这些方法来检查特定的修饰符是否存在boolean Modifier.isAbstract(int modifiers)boolean Modifier.isFinal(int modifiers)boolean Modifier.isInterface(int modifiers)boolean Modifier.isNative(int modifiers)boolean Modifier.isPrivate(int modifiers)boolean Modifier.isProtected(int modifiers)boolean Modifier.isPublic(int modifiers)boolean Modifier.isStatic(int modifiers)boolean Modifier.isStrict(int modifiers)boolean Modifier.isSynchronized(int modifiers)boolean Modifier.isTransient(int modifiers)boolean Modifier.isVolatile(int modifiers) 首先是 toString 函数：这个函数的作用就是根据传进来的整型，获取其中的标识位来判断具有哪个修饰符，然后将所有修饰符拼接起来输出。比如我们的例子中输出的就是：public static final。 其它的就是一些 isXXXX(int moifiers) 的判断指定标识位的函数了。在例子中，我们使用了 Modifier.isFinal(int modifiers) 来判断是不是具有 final 修饰符，返回结果为 true。 6、获取接口的访问修饰符从上面获取类的访问修饰符时，接口、类、函数都是通过 Modifier 类判断访问修饰符的，又因为类和接口类型全部都是用 Class 对象来标识，所以接口和类的获取访问修饰符的方式完全相同，下面就举一个简单的例子：123// 定义一个类部接口public static interface InnerInteface &#123;&#125; 测试代码：123456Class&lt;?&gt; clazz2 = InnerInteface.class;int modifiers = clazz2.getModifiers();String str = Modifier.toString(modifiers);boolean isInterface = Modifier.isInterface(modifiers);Log.d(TAG, &quot;InnerClass 的定义修饰符: &quot; + str);Log.d(TAG, &quot;isInterface: &quot; + isInterface); 如果我们要直接获取一个接口的对象，同样，也是通过开头所讲的那四种获取Class对象的方式。因为我们现在知道 Class 对象，不光代表类也可以代表接口。有关 Modifier 的使用与第五部分获取类的修饰符是一样的。 7、Class.forName 与 ClassLoader.loadClass 的区别我们通过源码来看看他们的区别。先看 Class.forName：123456789101112131415161718public static Class&lt;?&gt; forName(String className) throws ClassNotFoundException &#123; return forName(className, true, VMStack.getCallingClassLoader());&#125; public static Class&lt;?&gt; forName(String className, boolean initializeBoolean, ClassLoader classLoader) throws ClassNotFoundException &#123; Class&lt;?&gt; result; try &#123; result = classForName(className, initializeBoolean, classLoader); &#125; catch (ClassNotFoundException e) &#123; Throwable cause = e.getCause(); if (cause instanceof ExceptionInInitializerError) &#123; throw (ExceptionInInitializerError) cause; &#125; throw e; &#125; return result;&#125; 从源中可以看到 Class.forName(String className) 最终调用的是 forName(String className, boolean initializeBoolean, ClassLoader classLoader) 函数。其中： className：类名。 initializeBoolean：表示是否需要初始化；如果设为 true，表示在加载以后，还会进入链接阶段。 classLoader：ClassLoader 加载器。 我们知道源文件在编译后，在运行时，分为三个阶段：加载、链接和初始化。这里的 initializeBoolean 就是定义是否进行链接和初始化。而 Class.forName 默认是设置的为 true。所以利用 Class.forName() 得到的类类型，除了加载进来以外，还进行了链接和初始化操作。 下面再来看看 ClassLoader.loadClass()1234567891011121314151617181920public Class&lt;?&gt; loadClass(String className) throws ClassNotFoundException &#123; return loadClass(className, false);&#125;protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123; Class&lt;?&gt; clazz = findLoadedClass(className); if (clazz == null) &#123; try &#123; clazz = parent.loadClass(className, false); &#125; catch (ClassNotFoundException e) &#123; // Don&apos;t want to see this. &#125; if (clazz == null) &#123; clazz = findClass(className); &#125; &#125; return clazz;&#125; loadClass(String className) 最终是调用递规函数 loadClass(String className, boolean resolve) 来将类加载出来。通过代码也可以看出来 ClassLoader 的 loadClass(String className) 只是将类加载出来，并没有链接与初始化的步骤。 最后，我们总结一下，Class.forName(String className) 不仅会将类加载进来，而且会对其进行初始化，而 ClassLoader.loadClass(String ClassName) 则只是将类加载进来，而没有对类进行初始化。一般来讲，他们两个是通用的，但如果你加载类依赖初始化值的话，那 ClassLoader.loadClass(String ClassName) 将不再适用。 举例来说：在 JDBC 编程中，常看到这样的用法。Class.forName(“com.mysql.jdbc.Driver”); 如果换成了 getClass().getClassLoader().loadClass(“com.mysql.jdbc.Driver”); 就不行。 为什么呢？打开 com.mysql.jdbc.Driver 的源代码看看：12345678// Register ourselves with the DriverManagerstatic &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException(&quot;Can&apos;t register driver!&quot;); &#125;&#125; 原来，Driver 在 static 块中会注册自己到 java.sql.DriverManager。而 static 块就是在 Class 的初始化中被执行。所以这个地方就只能用Class.forName(className)。 这篇文章所涉及到的几个函数：123456789101112131415161718192021222324// 获取类类型对象的几种方式：Person person = new Person(); Class a = person.getClass() // 方法一Class b = Persion.class; // 方法二Class c = Class.forName(String ClassName); // 方法三Class d = context.getClassLoader().loadClass(String ClassName); // 方法四（不建议使用） // 获取包名类名public String getName(); // 获取完整的类名（包含包名）public String getSimpleName(); // 仅获取类名public Package getPackage(); // 获取类类型所对应的 package 对象 // 获取超类 Class 对象public Class&lt;?&gt; getSuperclass(); // 获取普通函数的父类 Class 对象public Type getGenericSuperclass(); // 针对泛型父类而设计（下篇讲解） // 获取接口 Class 对象public Class&lt;?&gt;[] getInterfaces(); // 获取普通接口的方法public Type[] getGenericInterfaces(); // 获取泛型接口的方法 // 类访问修饰符int modifiers = clazz.getModifiers(); // 获取类访问修饰符对应的 int 变量String Modifier.toString(int modifiers); // 根据整型变量来生成对应的修饰符字符串boolean Modifier.isAbstract(int modifiers); // isXXX() 系列函数用以检查特定的修饰符是否存在]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA ReflectUtils]]></title>
    <url>%2F1900%2F01%2F09%2F00JAVA%2F09%20Java%20RelfectUtils%2F</url>
    <content type="text"><![CDATA[相关文章：Java RelfectJava RelfectUtils反射一：基本类周边信息获取反射二：泛型相关周边信息获取反射三：类内部信息获取 Invoking Arbitrary Methods：12Method sqrt = Math.class.getMethod("sqrt", double.class);double x = (Double) sqrt.invoke(null, 100); // 此方法为静态方法，隐式参数为null ReflectionUtils：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306package com.xian.reflection;import java.lang.annotation.Annotation;import java.lang.reflect.AccessibleObject;import java.lang.reflect.Array;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.util.ArrayList;/** * ReflectionUtils : * 1 Get all features of a class * 2 A generic toString method that works for any class * 3 Copy array * * @author xianxiaotao */public class ReflectionUtils &#123; /** * flag to contain annotation and exception string */ private static int flag = 0b00000000_00000000_00000000_00000000; /** * flag : contain annotation string */ public static final int CONTAIN_ANNOTATION = 0b00000000_00000000_00000000_00000001; /** * flag : contain exception string */ public static final int CONTAIN_EXCEPTION = 0b00000000_00000000_00000000_00000010; // Cycles of references could cause an infinite recursion. Therefore, // the ObjectAnalyzer keeps track of objects that were already visited private static ArrayList&lt;Object&gt; visited = new ArrayList&lt;&gt;(); // Suppresses default constructor, ensuring non-instantiability. private ReflectionUtils() &#123;&#125; /** * Get all features of a class * @param className * @return * @throws ClassNotFoundException */ public static String getClass(String className) throws ClassNotFoundException &#123; StringBuilder sb = new StringBuilder(); Class&lt;?&gt; clazz = Class.forName(className); Class&lt;?&gt; superClazz = clazz.getSuperclass(); sb.append(clazz.getPackage().getName()).append("\n\n"); sb.append(getAnnotations(clazz.getDeclaredAnnotations())); sb.append(getModifiers(clazz.getModifiers())); sb.append("class ").append(className); if (superClazz != null &amp;&amp; superClazz != Object.class) sb.append(" extends ").append(superClazz.getName()); Class&lt;?&gt;[] interfaces = clazz.getInterfaces(); if (interfaces.length &gt; 0) sb.append(" implements "); for (int i = 0; i &lt; interfaces.length; i++) &#123; if (i &gt; 0) sb.append(", "); sb.append(interfaces[i].getName()); &#125; sb.append(" &#123;\n"); sb.append(getConstructors(clazz)).append("\n"); sb.append(getMethods(clazz)).append("\n"); sb.append(getFields(clazz)).append("\n"); sb.append("&#125;\n"); return sb.toString(); &#125; /** * Get all constructors * @param clazz * @return String */ public static String getConstructors(Class&lt;?&gt; clazz) &#123; StringBuilder sb = new StringBuilder(); Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors(); for (Constructor&lt;?&gt; c : constructors) &#123; sb.append(getAnnotations(c.getDeclaredAnnotations())); String name = c.getName(); sb.append(" "); String modifiers = Modifier.toString(c.getModifiers()); if (modifiers.length() &gt; 0) sb.append(modifiers).append(" "); sb.append(name).append("("); String paramStr = getParamTypes(c.getParameterTypes()); sb.append(paramStr).append(")"); sb.append(getExceptions(c.getExceptionTypes())); sb.append(";\n"); &#125; return sb.toString(); &#125; private static String getExceptions(Class&lt;?&gt;[] es) &#123; StringBuilder sb = new StringBuilder(); if (isContainException() &amp;&amp; es != null &amp;&amp; es.length &gt; 0) &#123; sb.append(" throws "); for (int i = 0; i &lt; es.length; i++) &#123; if (i &gt; 0) sb.append(", "); sb.append(es[i].getName()); &#125; &#125; return sb.toString(); &#125; /** * get annotation of a class, method or field * @param as * @return */ private static String getAnnotations(Annotation[] as) &#123; StringBuilder sb = new StringBuilder(); if (isContainAnnotation() &amp;&amp; as != null &amp;&amp; as.length &gt; 0) &#123; sb.append(" @"); for (int i = 0; i &lt; as.length; i++) &#123; sb.append(as[i].annotationType().getName()).append("\n"); &#125; &#125; return sb.toString(); &#125; /** * get parameter types * @param paramTypes * @return */ private static String getParamTypes(Class&lt;?&gt;[] paramTypes) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; paramTypes.length; i++) &#123; if (i &gt; 0) sb.append(", "); sb.append(paramTypes[i].getName()); &#125; return sb.toString(); &#125; private static String getModifiers(int modifier) &#123; String modifiers = Modifier.toString(modifier); if (modifiers.length() &gt; 0) return modifiers + " "; return ""; &#125; /** * Get all methods of a class * @param clazz * @return */ public static String getMethods(Class&lt;?&gt; clazz) &#123; return getMethods(clazz, null); &#125; /** * Gets the method for the specified method name * @param clazz * @return */ public static String getMethods(Class&lt;?&gt; clazz, String methodName) &#123; StringBuilder sb = new StringBuilder(); Method[] methods = clazz.getDeclaredMethods(); for (Method m : methods) &#123; sb.append(getAnnotations(m.getDeclaredAnnotations())); Class&lt;?&gt; returnType = m.getReturnType(); String name = m.getName(); if (methodName != null &amp;&amp; !methodName.equals(name)) continue; sb.append(" ").append(getModifiers(m.getModifiers())).append(returnType.getName()).append(" " + name + "("); String paramStr = getParamTypes(m.getParameterTypes()); sb.append(paramStr).append(")"); sb.append(getExceptions(m.getExceptionTypes())); sb.append(";\n"); &#125; return sb.toString(); &#125; /** * Get all fields of a class * @param clazz * @return */ public static String getFields(Class&lt;?&gt; clazz) &#123; StringBuilder sb = new StringBuilder(); Field[] fields = clazz.getDeclaredFields(); for (Field f : fields) &#123; Class&lt;?&gt; type = f.getType(); sb.append(" ").append(getModifiers(f.getModifiers())).append(type.getName()).append(" ").append(f.getName()).append(";\n"); &#125; return sb.toString(); &#125; /** * ReflectionUtils.setFlag(ReflectionUtils.CONTAIN_EXCEPTION | ReflectionUtils.CONTAIN_ANNOTATION); * @param state */ public static void setFlag(int state) &#123; flag = state; &#125; private static boolean isContainException() &#123; return (flag &amp; CONTAIN_EXCEPTION) == CONTAIN_EXCEPTION ? true : false; &#125; private static boolean isContainAnnotation() &#123; return (flag &amp; CONTAIN_ANNOTATION) == CONTAIN_ANNOTATION ? true : false; &#125; /** * Converts an object to a string representation that lists all fields. * @param obj * @return a string with the object's class name and all field names and values */ public static String toString(Object obj) &#123; if (obj == null) return "null"; if (visited.contains(obj)) return "..."; visited.add(obj); Class&lt;?&gt; clazz = obj.getClass(); if (clazz == String.class) return (String) obj; if (clazz.isArray()) &#123; String r = clazz.getComponentType() + "[]&#123;"; for (int i = 0; i &lt; Array.getLength(obj); i++) &#123; if (i &gt; 0) r += ","; Object val = Array.get(obj, i); if (clazz.getComponentType().isPrimitive()) r += val; else r += toString(val); // recursion &#125; return r + "&#125;"; &#125; // others : inspect the fields of this class and all superclasses String r = clazz.getName(); do &#123; r += " ["; Field[] fields = clazz.getDeclaredFields(); AccessibleObject.setAccessible(fields, true); // uses the setAccessible convenience method to make all fields accessible for (Field f : fields) &#123; // get the names and values of all fields if (!Modifier.isStatic(f.getModifiers())) &#123; if (!r.endsWith("[")) r += ","; r += f.getName() + "="; try &#123; Class&lt;?&gt; t = f.getType(); Object val = f.get(obj); if (t.isPrimitive()) r += val; else r += toString(val); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; r += "]"; clazz = clazz.getSuperclass(); if (clazz.getSuperclass() != Object.class) clazz = null; &#125; while (clazz != null); return r; &#125; /** * This method grows an array by allocating a new array of the same type and copying all elements. * @param a the array to grow. This can be an object array or a primitive type array * @return a larger array that contains all elements of a. */ public static Object copyOf(Object arr, int newLength) &#123; Class&lt;?&gt; clazz = arr.getClass(); if (!clazz.isArray()) return null; Class&lt;?&gt; componentType = clazz.getComponentType(); int length = Array.getLength(arr); Object newArray = Array.newInstance(componentType, newLength); System.arraycopy(arr, 0, newArray, 0, Math.min(length, newLength)); return newArray; &#125; // clear static ArrayList var(visited) public static void clean() &#123; visited.clear(); &#125; // unit test public static void main(String[] args) throws ClassNotFoundException &#123; // setFlag(CONTAIN_EXCEPTION | CONTAIN_ANNOTATION); // System.out.println(getClass("java.lang.String")); /* // 使用方式如下或者在自定义类中toString方法里添加 ReflectionUtils.clear(); return ReflectionUtils.toString(this); ArrayList&lt;Integer&gt; squares = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 5; i++) squares.add(i * i); System.out.println(ReflectionUtils.toString(squares)); ReflectionUtils.clear(); */ System.out.println(new Manager("xian xiaotao", 300000, 2020, 1, 1)); // com.xian.reflection.Manager [name=xian xiaotao, salary=300000.0, hireDay=2020-01-01] // com.xian.reflection.Manager [bonus=0.0] [id=0,name=xian xiaotao,salary=300000.0,hireDay=java.time.LocalDate [year=2020,month=1,day=1]] &#125;&#125; 输出：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108java.langpublic final class java.lang.String implements java.io.Serializable, java.lang.Comparable, java.lang.CharSequence &#123; public java.lang.String([B, int, int); public java.lang.String([B, java.nio.charset.Charset); public java.lang.String([B, java.lang.String) throws java.io.UnsupportedEncodingException; public java.lang.String([B, int, int, java.nio.charset.Charset); public java.lang.String([B, int, int, java.lang.String) throws java.io.UnsupportedEncodingException; java.lang.String([C, boolean); public java.lang.String(java.lang.StringBuilder); public java.lang.String(java.lang.StringBuffer); public java.lang.String([B); public java.lang.String([I, int, int); public java.lang.String(); public java.lang.String([C); public java.lang.String(java.lang.String); public java.lang.String([C, int, int); @java.lang.Deprecated public java.lang.String([B, int); @java.lang.Deprecated public java.lang.String([B, int, int, int); public boolean equals(java.lang.Object); public java.lang.String toString(); public int hashCode(); public volatile int compareTo(java.lang.Object); public int compareTo(java.lang.String); public int indexOf(java.lang.String, int); static int indexOf([C, int, int, java.lang.String, int); static int indexOf([C, int, int, [C, int, int, int); public int indexOf(int); public int indexOf(java.lang.String); public int indexOf(int, int); public static java.lang.String valueOf(char); public static java.lang.String valueOf(java.lang.Object); public static java.lang.String valueOf(boolean); public static java.lang.String valueOf([C, int, int); public static java.lang.String valueOf([C); public static java.lang.String valueOf(double); public static java.lang.String valueOf(float); public static java.lang.String valueOf(long); public static java.lang.String valueOf(int); private static void checkBounds([B, int, int); public int length(); public boolean isEmpty(); public char charAt(int); public int codePointAt(int); public int codePointBefore(int); public int codePointCount(int, int); public int offsetByCodePoints(int, int); public void getChars(int, int, [C, int); void getChars([C, int); public [B getBytes(); public [B getBytes(java.lang.String) throws java.io.UnsupportedEncodingException; @java.lang.Deprecated public void getBytes(int, int, [B, int); public [B getBytes(java.nio.charset.Charset); public boolean contentEquals(java.lang.StringBuffer); public boolean contentEquals(java.lang.CharSequence); private boolean nonSyncContentEquals(java.lang.AbstractStringBuilder); public boolean equalsIgnoreCase(java.lang.String); public int compareToIgnoreCase(java.lang.String); public boolean regionMatches(int, java.lang.String, int, int); public boolean regionMatches(boolean, int, java.lang.String, int, int); public boolean startsWith(java.lang.String); public boolean startsWith(java.lang.String, int); public boolean endsWith(java.lang.String); private int indexOfSupplementary(int, int); public int lastIndexOf(int, int); static int lastIndexOf([C, int, int, [C, int, int, int); static int lastIndexOf([C, int, int, java.lang.String, int); public int lastIndexOf(java.lang.String, int); public int lastIndexOf(int); public int lastIndexOf(java.lang.String); private int lastIndexOfSupplementary(int, int); public java.lang.String substring(int); public java.lang.String substring(int, int); public java.lang.CharSequence subSequence(int, int); public java.lang.String concat(java.lang.String); public java.lang.String replace(char, char); public java.lang.String replace(java.lang.CharSequence, java.lang.CharSequence); public boolean matches(java.lang.String); public boolean contains(java.lang.CharSequence); public java.lang.String replaceFirst(java.lang.String, java.lang.String); public java.lang.String replaceAll(java.lang.String, java.lang.String); public [Ljava.lang.String; split(java.lang.String, int); public [Ljava.lang.String; split(java.lang.String); public static transient java.lang.String join(java.lang.CharSequence, [Ljava.lang.CharSequence;); public static java.lang.String join(java.lang.CharSequence, java.lang.Iterable); public java.lang.String toLowerCase(java.util.Locale); public java.lang.String toLowerCase(); public java.lang.String toUpperCase(); public java.lang.String toUpperCase(java.util.Locale); public java.lang.String trim(); public [C toCharArray(); public static transient java.lang.String format(java.util.Locale, java.lang.String, [Ljava.lang.Object;); public static transient java.lang.String format(java.lang.String, [Ljava.lang.Object;); public static java.lang.String copyValueOf([C, int, int); public static java.lang.String copyValueOf([C); public native java.lang.String intern(); private final [C value; private int hash; private static final long serialVersionUID; private static final [Ljava.io.ObjectStreamField; serialPersistentFields; public static final java.util.Comparator CASE_INSENSITIVE_ORDER;&#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Relfect]]></title>
    <url>%2F1900%2F01%2F08%2F00JAVA%2F08%20Java%20Relfect%2F</url>
    <content type="text"><![CDATA[参考链接：反射技术 相关文章：Java RelfectJava RelfectUtils反射一：基本类周边信息获取反射二：泛型相关周边信息获取反射三：类内部信息获取 一、使用反射机制步骤如下 使用反射机制步骤如下 导入 java.lang.relfect 包 获得你想操作的类的 java.lang.Class 对象 调用诸如 getDeclaredMethods 的方法 使用反射API 来操作这些信息 获取class对象的3种方法 已经得到一个类的实例，可以使用如下方式来得到Class对象：Class c = 对象名.getClass(); 如果在编译期知道类的名字，可以使用如下方法：Class c = java.lang.String.class;Class c = Integer.TYPE; 如果类名在编译期不知道, 但是在运行期可以获得, 可以使用下面的方法：Class c = Class.forName(str); // 注意:str是类的全路径 示例：123456789101112131415161718192021222324class TestClass &#123; static &#123; System.out.println(&quot;static&quot;); &#125; private String name = &quot;先小涛&quot;; private String address = &quot;南京&quot;; public void print() &#123; System.out.println(&quot;name:&quot; + name + &quot; ,address:&quot; + address); &#125;&#125;// 测试代码private void test() throws Exception &#123; TestClass testObj = new TestClass(); // 同过反射机制得到类的对象 Class &lt;? extends TestClass&gt; clazzClass = testObj.getClass(); System.out.println(&quot;clazzClass:&quot; + clazzClass); // 调用无参构造方法，创建一个对象 TestClass testObj2 = (TestClass) clazzClass.newInstance(); System.out.println(&quot;gctObj==gctOb2 :&quot; + (testObj == testObj2)); System.out.println(&quot;gctObj.getClass() == gctOb2.getClass() :&quot; + (testObj.getClass() == testObj2.getClass())); testObj2.print();&#125; 这样获得 Class 类对象的方法，其实是利用反射 API 把指定字符串的类加载到内存中，所以也叫类加载器加载方法。这样的话，它会把该类的静态方法和静态属性，以及静态代码全部加载到内存中。但这时候，对象还没有产生。所以为什么静态方法不能访问非静态属性和方法。因为静态方法和属性产生的时机在非静态属性和方法之前。 在进行 testObj.getClass() 的时候，实际上是对指定类进行类加载，这时候，会把静态属性、方法以及静态代码块都加载到内存中。所以这时候会打印出”静态代码块运行”。但这时候，对象却还没有产生。所以”构造方法运行”这几个字不会打印。当执行 clazzClass.newInstance() 的时候，就是利用反射机制将 Class 对象生成一个该类的一个实例。这时候对象就产生了。所以打印”构造方法运行”。当执行到 TestClass testObj = new TestClass(); 语句时，又生成了一个对象。但这时候类已经加载完毕，静态的东西已经加载到内存中，而静态代码块只执行一次，所以不用再去加载类，所以只会打印”构造方法运行”，而”静态代码块运行”不会打印。 反射机制不但可以例出该类对象所拥有的方法和属性，还可以获得该类的构造方法及通过构造方法获得实例。也可以动态的调用这个实例的成员方法。 二、获得其他类中的全部构造函数 Java 通过反射机制获取获得其他类中的全部构造函数，步骤所用方法如下： forName()：返回给定串名相应的Class对象。 getConstructors()：返回当前Class对象表示的类的所有公有构造子对象数组。 示例：12345678910111213141516171819202122232425Class&lt;?&gt; testClazz = null;try &#123; testClazz = Class.forName(&quot;java.lang.String&quot;);&#125; catch (Exception e) &#123; e.printStackTrace();&#125;Constructor&lt;?&gt; cons[] = testClazz.getConstructors();for (int i = 0; i &lt; cons.length; i++) &#123; int mo = cons[i].getModifiers(); StringBuilder sb = new StringBuilder(); // 构造函数修饰符 sb.append(Modifier.toString(mo)).append(&quot; &quot;); // 构造函数名 sb.append(cons[i].getName()).append(&quot;(&quot;); // 构造函数参数 Class&lt;?&gt; p[] = cons[i].getParameterTypes(); for (int j = 0; j &lt; p.length; ++j) &#123; sb.append(p[j].getName()).append(&quot; arg&quot;).append(j); if (j &lt; p.length - 1) &#123; sb.append(&quot;,&quot;); &#125; &#125; sb.append(&quot;)&#123;&#125;&quot;); print(sb.toString());&#125; 三、实例化一个类的对象 Java 通过反射机制实例化一个类的对象，步骤所用方法如下： forName() 返回给定串名相应的Class对象。 newInstance() 创建类的新实例。 getConstructors() 返回当前Class对象表示的类的所有公有构造子对象数组。 getName() 返回Class对象表示的类型(类、接口、数组或基类型)的完整路径名字符串。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class User &#123; private int age; private String name; public User() &#123; super(); &#125; public User(String name) &#123; super(); this.name = name; &#125; public User(int age, String name) &#123; super(); this.age = age; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;User [age=&quot; + age + &quot;, name=&quot; + name + &quot;]&quot;; &#125;&#125;// 测试代码private void test() throws Exception &#123; Class&lt;?&gt; class1 = Class.forName(&quot;com.xxt.xtest.User&quot;); // 第一种方法，实例化默认构造方法，调用set赋值 User user = (User) class1.newInstance(); user.setAge(20); user.setName(&quot;先小涛&quot;); print(user); // 结果 User [age=20, name=先小涛] // 第二种方法 取得全部的构造函数 使用构造函数赋值 Constructor&lt;?&gt; cons[] = class1.getConstructors(); // 查看每个构造方法需要的参数 for (int i = 0; i &lt; cons.length; i++) &#123; Class&lt;?&gt; clazzs[] = cons[i].getParameterTypes(); print(&quot;cons[&quot; + i + &quot;] (&quot;); for (int j = 0; j &lt; clazzs.length; j++) &#123; if (j == clazzs.length - 1) print(clazzs[j].getName()); else print(clazzs[j].getName() + &quot;,&quot;); &#125; print(&quot;)&quot;); &#125; // 结果 // cons[0] () // cons[1] (int,java.lang.String) // cons[2] (java.lang.String) user = (User) cons[2].newInstance(&quot;先小涛&quot;); print(user); // 结果 User [age=0, name=先小涛] user = (User) cons[1].newInstance(20, &quot;先小涛&quot;); print(user); // 结果 User [age=20, name=先小涛]&#125; 四、获取某个类的全部属性 Java反射获取某个类的全部属性,步骤所用方法如下： forName()：返回给定串名相应的 Class 对象。 getDeclaredFields()：返回当前 Class 对象表示的类或接口的所有已说明的域对象数组。 getFields()：返回当前 Class 对象表示的类或接口的所有可访问的公有域对象数组。 getModifiers()：返回该类或接口的 Java 语言修改器代码。 getName()：返回 Class 对象表示的类型(类、接口、数组或基类型)的完整路径名字符串。 示例代码：1234567891011121314151617181920212223242526private void test() throws Exception &#123; Class&lt;?&gt; clazz = Class.forName(&quot;com.xxt.xtest.User&quot;); System.out.println(&quot;===============本类属性===============&quot;); // 取得本类的全部属性 Field[] field = clazz.getDeclaredFields(); for (int i = 0; i &lt; field.length; i++) &#123; // 权限修饰符 int mo = field[i].getModifiers(); String prev = Modifier.toString(mo); // 属性类型 Class&lt;?&gt; type = field[i].getType(); System.out.println(prev + &quot; &quot; + type.getName() + &quot; &quot; + field[i].getName() + &quot;;&quot;); &#125; System.out.println(&quot;==========实现的接口或者父类的属性==========&quot;); // 取得实现的接口或者父类的属性 Field[] filed1 = clazz.getFields(); for (int j = 0; j &lt; filed1.length; j++) &#123; // 权限修饰符 int mo = filed1[j].getModifiers(); String prev = Modifier.toString(mo); // 属性类型 Class&lt;?&gt; type = filed1[j].getType(); System.out.println(prev + &quot; &quot; + type.getName() + &quot; &quot; + filed1[j].getName() + &quot;;&quot;); &#125;&#125; 输出结果： 五、操作某个类的属性 Java 通过反射机制操作某个类的属性，步骤所用方法如下： forName()：返回给定串名相应的Class对象。 getDeclaredField()：返回当前 Class 对象表示的类或接口的指定已说明的一个域对象。 示例：12345678910private void test() throws Exception &#123; Class&lt;?&gt; clazz = Class.forName(&quot;com.xxt.xtest.User&quot;); Object obj = clazz.newInstance(); // 可以直接对 private 的属性赋值 Field field = clazz.getDeclaredField(&quot;name&quot;); field.setAccessible(true); field.set(obj, &quot;Java 反射机制&quot;); print(field.get(obj)); // 输出结果：Java 反射机制&#125; 六、获取某个类的全部方法 Java 通过反射机制获取某个类的全部方法，步骤所用方法如下： forName()：返回给定串名相应的Class对象。 getMethods()：返回当前Class对象表示的类或接口的所有公有成员方法对象数组，包括已声明的和从父类继承的方法。 getModifiers()：返回该类或接口的Java语言修改器代码。 getName()：返回Class对象表示的类型(类、接口、数组或基类型)的完整路径名字符串。 示例代码：123456789101112131415161718192021222324252627282930313233private void test() throws Exception &#123; Class&lt;?&gt; clazz = Class.forName(&quot;com.xxt.xtest.User&quot;); Method methods[] = clazz.getMethods(); StringBuilder sb = new StringBuilder(); for (Method method : methods) &#123; Class&lt;?&gt; returnType = method.getReturnType(); Class&lt;?&gt; paras[] = method.getParameterTypes(); int temp = method.getModifiers(); sb.append(Modifier.toString(temp)).append(&quot; &quot;); sb.append(returnType.getName()).append(&quot; &quot;); sb.append(method.getName()).append(&quot; &quot;).append(&quot;(&quot;); for (int i = 0; i &lt; paras.length; ++i) &#123; sb.append(paras[i].getName()).append(&quot; arg&quot;).append(i); if (i &lt; paras.length - 1) sb.append(&quot;, &quot;); &#125; Class&lt;?&gt; exceptions[] = method.getExceptionTypes(); if (exceptions.length &gt; 0) &#123; sb.append(&quot;) throws &quot;); for (int j = 0; j &lt; exceptions.length; ++j) &#123; sb.append(exceptions[j].getName()).append(&quot; &quot;); if (j &lt; exceptions.length - 1) &#123; sb.append(&quot;, &quot;); &#125; &#125; &#125; else &#123; sb.append(&quot;)&quot;); &#125; sb.append(&quot;\n&quot;); &#125; print(sb);&#125; 七、调用某个类的方法 Java通过反射机制调用某个类的方法，步骤所用方法如下： forName()：返回给定串名相应的 Class 对象。 getMethod()：返回当前 Class 对象表示的类或接口的指定的公有成员方法对象。 newInstance()：创建类的新实例。 示例代码：123456789101112131415161718192021class TestReflect &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; clazz = Class.forName(&quot;com.xxt.xtest.TestReflect&quot;); // 调用 TestReflect 类中的 reflect1 方法 Method method = clazz.getMethod(&quot;reflect1&quot;); method.invoke(clazz.newInstance()); // Java 反射机制 - 调用某个类的方法1. // 调用 TestReflect 的 reflect2 方法 method = clazz.getMethod(&quot;reflect2&quot;, int.class, String.class); method.invoke(clazz.newInstance(), 20, &quot;张三&quot;); // Java 反射机制 - 调用某个类的方法2. // age -&gt; 20. name -&gt; 张三 &#125; public void reflect1() &#123; System.out.println(&quot;Java 反射机制 - 调用某个类的方法1.&quot;); &#125; public void reflect2(int age, String name) &#123; System.out.println(&quot;Java 反射机制 - 调用某个类的方法2.&quot;); System.out.println(&quot;age -&gt; &quot; + age + &quot;. name -&gt; &quot; + name); &#125;&#125; 八、取得并修改数组的大小等信息 Java 通过反射机制取得并修改数组的大小等信息，步骤所用方法如下： getClass()：取得该类已经被实例化了的对象的该类的引用。 getComponentType()：如果当前类表示一个数组，则返回表示该数组组件的Class对象，否则返回null。 newInstance()：创建类的新实例。 示例代码：123456789101112131415161718192021222324252627282930public class TestReflect &#123; public static void main(String[] args) throws Exception &#123; int[] temp = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; int[] newTemp = (int[]) arrayInc(temp, 15); print(newTemp); String[] atr = &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;; String[] str1 = (String[]) arrayInc(atr, 8); print(str1); &#125; // 修改数组大小 public static Object arrayInc(Object obj, int len) &#123; Class&lt;?&gt; arr = obj.getClass().getComponentType(); Object newArr = Array.newInstance(arr, len); int co = Array.getLength(obj); System.arraycopy(obj, 0, newArr, 0, co); return newArr; &#125; // 打印 public static void print(Object obj) &#123; Class&lt;?&gt; c = obj.getClass(); if (!c.isArray()) &#123; return; &#125; System.out.println(&quot;数组长度为： &quot; + Array.getLength(obj)); for (int i = 0; i &lt; Array.getLength(obj); i++) &#123; System.out.print(Array.get(obj, i) + &quot; &quot;); &#125; System.out.println(); &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Annotation]]></title>
    <url>%2F1900%2F01%2F07%2F00JAVA%2F07%20Java%20Annotation%2F</url>
    <content type="text"><![CDATA[一、什么是注解 Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。 Java 注解用于为 Java 程序提供元数据。作为元数据，注解不直接影响代码的执行，但也有一些注解实际上可以用于这一目的。 什么是元数据，即一种描述数据的数据。所以可以说注解是描述源代码的数据。简单理解注解可以看出一个个标签，用来标记你的代码，是一种应用于类，方法，参数，变量，构造器及包的一种特殊修饰符。 注解和 class、interface 一样也是一种类型，通过 @interface 定义。如下：12345@Documented@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123;&#125; 使用：123@TestAnnotationpublic class Test &#123;&#125; 二、元注解 元注解就是注解到注解上的注解，或者说元注解是一种基本注解，它能用来注解其他注解。我们可以将元注解看成一种特殊的修饰符，用来解释说明注解，它是注解的元数据。例如上例中的 @Retention 等。 元注解一共用 5 种：@Retention、@Documented、@Target、@Inherited、@Repeatable。 1、@RetentionRetention 意为保留期，@Retention 用来解释说明一个注解的存活周期。@Retention 取值： RetentionPolicy.SOURCE注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 RetentionPolicy.CLASS注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 RetentionPolicy.RUNTIME注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。 示例：123@Retention(RetentionPolicy.CLASS)public @interface TestAnnotation &#123;&#125; 2、@Documented用于描述其它类型的 annotation 应该被作为被标注的程序成员的公共 API，因此可以被例如 javadoc 此类的工具文档化。Documented 是一个标记注解，没有成员。ANDROID 提供了的 NonNull 注解的源码如下：12345@Documented@Retention(CLASS)@Target(&#123;METHOD, PARAMETER, FIELD, LOCAL_VARIABLE, ANNOTATION_TYPE, PACKAGE&#125;)public @interface NonNull &#123;&#125; 3、@Target指定注解应用的地方，用来限定注解的应用场景（类，方法，参数等等）。不使用 @Target 注解则默认不限制。其取值如下： 取值 描述 ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举 示例：ANDROID 中的 @LayoutRes 注解，限定为布局资源。123456789public void setContentView(@LayoutRes int layoutResID) &#123; getDelegate().setContentView(layoutResID);&#125;@Documented@Retention(CLASS)@Target(&#123;METHOD, PARAMETER, FIELD, LOCAL_VARIABLE&#125;)public @interface LayoutRes &#123;&#125; 4、@Inherited标记这个注解是继承于哪个注解类。只能被用来标注 “Annotation 类型”，它所标注的 Annotation 具有继承性。当一个超类被 @Inherited 注解的注解（A 注解）进行过注解的话，如果它的子类没有被如何其他注解进行注解，那么这个子类就继承了超类的注解（A 注解）。示例如下：1234567891011@Retention(RetentionPolicy.CLASS)@Inheritedpublic @interface TestAnnotation &#123;&#125;@TestAnnotationpublic class TestA &#123;&#125;public class TestB extends TestA&#123;&#125; TestAnnotation 被 @Retention 注解，类 TestA 被 @TestAnnotation 注解，类 TestB 继承类 TestA，那么类 TestB 也拥有 TestAnnotation注解。 @Inherited annotation 类型是被标注过的 class 的子类所继承。类并不从它所实现的接口继承 annotation，方法并不从它所重载的方法继承 annotation。 5、@Repeatable@Repeatable 是自然可重复的意思，这是 Java 8 加进来的新特性。在需要对同一种注解多次使用时，往往需要借助 @Repeatable。示例：12345678910111213141516@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Roles &#123; Role[] value();&#125;@Repeatable(Roles.class)public @interface Role &#123; String role() default &quot;&quot;;&#125;@Role(role=&quot;husband&quot;)@Role(role=&quot;father&quot;)@Role(role=&quot;son&quot;)public class Person &#123;&#125; 上面的代码 @Repeatable 注解了 Role ，@Repeatable 后面括号中的类相当于一个容器注解。 什么是容器注解？本身也是注解，用来存放其他注解。按照规定，它里面必须要有一个 value 的属性，属性类型是一个被 @Repeatable 注解过的注解数组。 @Role(role=”husband”)，role=”husband” 表示给 Role 这个注解的 role 属性赋值，关于注解的属性下面会说明。Person 类需要多次使用 @Role 注解，所以这里使用 @Repeatable 注解 @Role。 测试一下注解效果：123456Annotation[] annotations = Person.class.getAnnotations();System.out.println(annotations.length);Roles p1 = (Roles) annotations[0];for (Role t : p1.value()) &#123; System.out.println(t.role());&#125; 打印如下：12341husbandfatherson 三、注解的属性 注解的属性也叫成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无参的方法”的形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。 注解的属性类型必须以下几种：8 种基本类型（byte、boolean、char、short、int、long、float、double）和 String、Enum、Class、annotation 类型，以及这些类型的数组。1234public @interface TestAnnotation &#123; int id(); String msg();&#125; 上面代码定义 TestAnnotation 这个注解有 id 和 msg 两个属性。在使用的时候我们需要给它们赋值。 赋值方式：括号内以 value=“” 的形式赋值，多个属性以逗号隔开。123@TestAnnotation(id = 1, msg = &quot;注解测试&quot;)public class Test &#123;&#125; 注解中可以设置默认值，默认值用 default 关键字指定。使用注解时对于指定了默认值的属性，如果不需要修改，可以不赋值。123456789public @interface TestAnnotation &#123; int id() default 0; String msg() default &quot;msg&quot;;&#125;// 使用默认值@TestAnnotation()public class Test &#123;&#125; 当一个注解只有一个属性且属性名为 value 时，使用此注解可以省略括号内的属性名直接赋值：1234567public @interface TestAnnotation &#123; String value();&#125;@TestAnnotation(&quot;1&quot;)public class Test &#123;&#125; 如果注解没有属性，括号也可以省略：123456public @interface TestAnnotation &#123;&#125;@TestAnnotationpublic class Test &#123;&#125; 四、JDK 内置注解 Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中，外加 JDK 7 以后新增 3个，共 10 个。分别是：@Override、@Deprecated、@SuppressWarnings；@Retention、@Documented、@Target、@Inherited；@SafeVarargs、@FunctionalInterface、@Repeatable。 取值 描述 作用在代码的注解： @Override 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 @Deprecated 标记过时元素的注解，用来标识类，方法或者变量已过时，不建议使用。调用过时方法时编译器会提醒。 @SuppressWarnings 指示编译器去忽略注解中声明的警告。 作用在其他注解的注解： @Retention 标识这个注解怎么保存，是只在代码中，还是编入 class 文件中，或者是在运行时可以通过反射访问。 @Documented 标记这些注解是否包含在用户文档中。 @Target 标记这个注解应该是哪种 Java 成员。 @Inherited 标记这个注解是继承于哪个注解类(默认注解没有继承于任何子类) 从 JAVA 7 开始新增： @SafeVarargs JAVA 7，参数安全类型注解。它的目的是提醒开发者不要用参数做一些不安全的操作，它的存在会阻止编译器产生 unchecked 这样的警告。 @FunctionalInterface JAVA 8，标识一个匿名函数或函数式接口。 @Repeatable JAVA 8，标识某注解可以在同一个声明上使用多次。 五、注解的提取与应用 注解通过反射获取，通过 Class 对象的方法获取注解。常用的三个方法：isAnnotationPresent方法判断是否应用了某个注解。1public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) &#123;...&#125; getAnnotation方法获取指定类型的注解。1public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) &#123;...&#125; getAnnotations方法获取注解到当前元素上的所有注解。1public Annotation[] getAnnotations() &#123;...&#125; 以运行时注解为例：获取下面 TestAnnotation 注解的 name 属性内容，可以如下获取。123456789101112131415161718@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.FIELD&#125;)@interface TestAnnotation &#123; String name();&#125;@TestAnnotation(name = &quot;先小涛&quot;)public class Person &#123;&#125;// 测试private void test() &#123; boolean hasAnnotation = Person.class.isAnnotationPresent(TestAnnotation.class); if (hasAnnotation)&#123; TestAnnotation annotation = Person.class.getAnnotation(TestAnnotation.class); Log.d(TAG, annotation.name()); &#125;&#125; 打印结果：12020-03-09 02:42:35.379 26182-26182/com.xxt.xtest D/xian: 先小涛 方法和属性也可以借助返回来获取注解：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Retention(RetentionPolicy.RUNTIME)@interface TestAnnotation &#123; String msg();&#125;@TestAnnotation(msg=&quot;注解类&quot;)public class Person &#123; @TestAnnotation(msg=&quot;注解成员变量&quot;) private String name; @TestAnnotation(msg=&quot;注解方法&quot;) private void setName(String name) &#123; this.name = name; &#125;&#125;// 测试private void test() &#123; boolean hasAnnotation = Person.class.isAnnotationPresent(TestAnnotation.class); if (hasAnnotation) &#123; TestAnnotation annotation = Person.class.getAnnotation(TestAnnotation.class); if (annotation != null) &#123; Log.d(TAG, annotation.msg()); &#125; &#125; try &#123; // 属性获取注解 Field nameField = Person.class.getDeclaredField(&quot;name&quot;); nameField.setAccessible(true); TestAnnotation annotation1 = nameField.getAnnotation(TestAnnotation.class); if (annotation1 != null) &#123; Log.d(TAG, annotation1.msg()); &#125; // 方法获取注解 Method setNameMethod = Person.class.getDeclaredMethod(&quot;setName&quot;, String.class); TestAnnotation annotation2 = setNameMethod.getAnnotation(TestAnnotation.class); if (annotation2 != null) &#123; Log.d(TAG, annotation2.msg()); &#125; &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125;&#125; 打印结果：1232020-03-09 02:53:23.584 27085-27085/com.xxt.xtest D/xian: 注解类2020-03-09 02:53:23.584 27085-27085/com.xxt.xtest D/xian: 注解成员变量2020-03-09 02:53:23.584 27085-27085/com.xxt.xtest D/xian: 注解方法 注意：如果一个注解要想在运行时被提取，那么@Retention(RetentionPolicy.RUNTIME) 是必须的。 注解的应用： 提供信息给编译器：编译器可以通过注解来探测错误和警告信息。 编译阶段处理：软件工具可以利用注解信息来自动生成代码，HTML文档或者做其他相应处理。 运行时的处理： 某些注解可以在程序运行时接收代码的提取。 当开发者使用注解修饰了类，方法，变量等成员后，注解不会自己生效，必须由开发者提供对应的代码来提取处理注解信息。 这些用来提取和处理注解信息的代码统称为APT（Annotation Processing Tool），注解处理器，它用来在编译时扫描和处理注解。 总结来说，注解（Annotation）相对于一种标记，注解的应用就是编译器，开发工具或者程序通过反射来提取你的类和各种元素有无这种标记，有某种标记就去做相应的处理。 参考文章：Java 注解 annotationJava 注解（Annotation）]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Generic]]></title>
    <url>%2F1900%2F01%2F06%2F00JAVA%2F06%20Java%20Generic%2F</url>
    <content type="text"><![CDATA[参考链接：JAVA 泛型、夯实 JAVA 基础 —— 泛型详解 What 什么是泛型，看表面的意思，泛型就是指广泛的、普通的类型。在 Java 中是指把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型。 ArrayList 就是使用泛型的典型案例，如下所示：123List&lt;String&gt; strList = new ArrayList&lt;String&gt;();List&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;();List&lt;Double&gt; doubleList = new ArrayList&lt;Double&gt;(); 可以看到，通过菱形语法（’&lt;&gt;’）可以将 List 内元素的类型限定为 String、Integer 和 Double 类型。需要注意的是 &lt;&gt; 内的类型只能是引用类型，当然对于基本类型，可以使用对应的包装类型。 Why 没有泛型会怎样？举个例子：实现两个能够设置点坐标的类，分别设置 Integer 类型的点坐标和 Float 类型的点坐标，代码如下：1234567891011121314151617181920212223242526272829303132333435// 设置 Integer 类型的点坐标class IntegerPoint &#123; private Integer x; // 表示 X 坐标 private Integer y; // 表示 Y 坐标 public void setX(Integer x)&#123; this.x = x; &#125; public void setY(Integer y)&#123; this.y = y; &#125; public Integer getX()&#123; return this.x; &#125; public Integer getY()&#123; return this.y; &#125;&#125;// 设置 Float 类型的点坐标class FloatPoint &#123; private Float x; // 表示 X 坐标 private Float y; // 表示 Y 坐标 public void setX(Float x) &#123; this.x = x; &#125; public void setY(Float y) &#123; this.y = y; &#125; public Float getX() &#123; return this.x; &#125; public Float getY() &#123; return this.y; &#125;&#125; 大家可以发现一个问题：它们除了变量类型不一样（一个是 Integer 一个是 Float）以外，其它并没有什么区别。那我们能不能合并成一个呢？ 答案是可以的，因为 Integer 和 Float 都是派生自 Object 的，我们用下面这段代码代替：12345678910111213141516class ObjectPoint &#123; private Object x; private Object y; public void setX(Object x) &#123; this.x = x; &#125; public void setY(Object y) &#123; this.y = y; &#125; public Object getX() &#123; return this.x; &#125; public Object getY() &#123; return this.y; &#125;&#125; 即全部都用 Object 来代替所有的子类。在使用的时候是这样的：123ObjectPoint integerPoint = new ObjectPoint();integerPoint.setX(new Integer(100));Integer integerX = (Integer) integerPoint.getX(); 在设置的时候，使用 new Integer(100) 来新建一个 Integer 对象，然后在取值的时候，进行强制转换。由于设置的类型和强转的类型是一致的，所以不会出错。 同理，FloatPoint 的设置和取值也是类似的，代码如下：123ObjectPoint floatPoint = new ObjectPoint();floatPoint.setX(new Float(100.12f));Float floatX = (Float) floatPoint.getX(); 但是上面的代码很容易发生运行时异常，且编译是不会报错。比如我们改成下面这样：123ObjectPoint floatPoint = new ObjectPoint();floatPoint.setX(new Float(100.12f));String floatX = (String) floatPoint.getX(); 因为编译器也不知道你传进去的是什么，而 floatPoint.getX() 返回的类型是 Object，所以编译时，将 Object 强转成 String 是成立的。必然不会报错。而在运行时，floatPoint 实例中明明传进去的是 Float 类型的变量，非要把它强转成 String 类型，肯定会报类型转换错误的！ 那有没有一种办法在编译阶段，即能合并成同一个，又能在编译时检查出来传进去类型不对呢？当然，这就是泛型。如下所示：1234567891011121314151617181920class Point&lt;T&gt; &#123; private T x; private T y; public T getX() &#123; return x; &#125; public void setX(T x) &#123; this.x = x; &#125; public T getY() &#123; return y; &#125; public void setY(T y) &#123; this.y = y; &#125;&#125; 如果使用不当，编译器会提示错误信息。 这样代码就不需要强制转换，而且只要在编译时期没有出现警告，那么运行时期就不会出现 ClassCastException 异常。 Type &amp; How 1. 泛型类泛型类也就是把泛型定义在类上，这样用户在使用类的时候才把类型给确定下来。1234567891011class Point&lt;T&gt; &#123; private T x; public T getX() &#123; return x; &#125; public void setX(T x) &#123; this.x = x; &#125;&#125; 可以看到上面这个程序，在使用时如果定义了类型，那么在使用时就可以不用进行强制类型转换，直接就可以得到一个 T 类型的对象。123456789// IntegerPoint 使用Point&lt;Integer&gt; p = new Point&lt;Integer&gt;() ; p.setX(new Integer(100)) ; System.out.println(p.getX()); // FloatPoint 使用Point&lt;Float&gt; p = new Point&lt;Float&gt;() ; p.setX(new Float(100.12f)) ; System.out.println(p.getX()); 下面来看看泛型是怎么定义及使用的吧。 Point&lt;T&gt;即在类名后面加一个尖括号，括号里是一个大写字母。这里写的是 T，其实这个字母可以是任何大写字母，意义是相同的。 T这个 T 表示派生自 Object 类的任何类，比如 String、Integer、Double 等等。这里要注意的是，T 一定是派生于 Object 类的。为方便起见，大家可以在这里把 T 当成 String，即 String 在类中怎么用，那 T 在类中就可以怎么用！所以它可以定义变量，作为返回值，作为参数传入。 12345678910// 定义变量private T x ; // 作为返回值public T getX()&#123; return x ; &#125; // 作为参数public void setX(T x)&#123; this.x = x ; &#125; 使用方式参考上面，不再表述。 2. 泛型变量上在我们只定义了一个泛型变量T，那如果我们需要传进去多个泛型要怎么办呢？只需要类似下面这样就可以了：12class MorePoint&lt;T, U&gt; &#123;&#125; 也就是在原来的 T 后面用逗号隔开，写上其它的任意大写字母即可。想加几个就加几个，比如我们想加五个泛型变量，那应该是这样的：12class MorePoint&lt;T, U, A, B, C&gt; &#123;&#125; 举个例子，我们在 Point 上再另加一个字段 name，也用泛型来表示，那要怎么做？代码如下：1234567891011121314151617181920212223class MorePoint&lt;T,U&gt; &#123; private T x; private T y; private U name; public void setX(T x) &#123; this.x = x; &#125; public T getX() &#123; return this.x; &#125; // 代码省略... public void setName(U name)&#123; this.name = name; &#125; public U getName() &#123; return this.name; &#125;&#125; 使用方式如下：1234// 使用MorePoint&lt;Integer, String&gt; morePoint = new MorePoint&lt;Integer, String&gt;();morePoint.setName(&quot;xian&quot;);Log.d(TAG, &quot;morPont.getName:&quot; + morePoint.getName()); 从上面的代码中，可以明显看出，就是在新添加的泛型变量 U 用法与 T 是一样的。上面提到任意一个大写字母都可以，他们的意义是完全相同的，但为了提高可读性，大家还是用有意义的字母比较好，一般来讲，在不同的情境下使用的字母意义如下： E — Element，常用在 java Collection 里，如：List、Iterator、Set； K, V — Key, Value，如：代表 Map 的键值对； N — Number，数字； T — Type，类型，如 String，Integer 等等。 使用约定俗成的大写字母，可以提高可读性。 3. 泛型接口在接口上定义泛型与在类中定义泛型是一样的，代码如下：12345interface Info&lt;T&gt; &#123; // 定义抽象方法，抽象方法的返回值就是泛型类 public T getVar(); 型 public void setVar(T x);&#125; 使用方式一：非泛型子类123456789101112131415161718192021class InfoImpl implements Info&lt;String&gt; &#123; private String var ; public InfoImpl(String var) &#123; this.setVar(var) ; &#125; @Override public void setVar(String var) &#123; this.var = var ; &#125; @Override public String getVar() &#123; return this.var ; &#125;&#125; public class Test &#123; public void main(String arsg[]) &#123; InfoImpl i = new InfoImpl(&quot;xian&quot;); System.out.println(i.getVar()) ; &#125;&#125;; InfoImpl 不是一个泛型类，因为他类名后没有 。然后在这里我们将 Info 中的泛型变量 T 定义填充为了 String 类型。所以在重写时 setVar() 和 getVar() 时，IDE 会也我们直接生成 String 类型的重写函数。在使用时，传进去 String 类型的字符串来构造 InfoImpl 实例，然后调用它的函数即可。 使用方法二：泛型子类在方法一中，我们在类中直接把 Info 接口给填充好了，但我们的类，是可以构造成泛型类的，那我们利用泛型类来构造填充泛型接口会是怎样呢？12345678910111213141516171819202122interface Info&lt;T&gt; &#123; public T getVar(); public void setVar(T var);&#125;class InfoImpl&lt;T&gt; implements Info&lt;T&gt; &#123; private T var ; public InfoImpl(T var) &#123; this.setVar(var) ; &#125; public void setVar(T var) &#123; this.var = var ; &#125; public T getVar() &#123; return this.var ; &#125;&#125;public class Test &#123; public static void main(String arsg[]) &#123; InfoImpl&lt;String&gt; i = new InfoImpl&lt;String&gt;(&quot;xian&quot;); System.out.println(i.getVar()) ; &#125;&#125; 在这个类中，我们构造了一个泛型类 InfoImpl，然后把泛型变量 T 传给了 Info，这说明接口和泛型类使用的都是同一个泛型变量。然后在使用时，就是构造一个泛型类的实例的过程，使用过程也不变。 使用泛型类来继承泛型接口的作用就是让用户来定义接口所使用的变量类型，而不是像方法一那样，在类中写死。 那我们稍微加深点难度，构造一个多个泛型变量的类，并继承自 Info 接口：1234567891011121314class InfoImpl&lt;T,K,U&gt; implements Info&lt;U&gt; &#123; private U var ; private T x; private K y; public InfoImpl(U var) &#123; this.setVar(var) ; &#125; public void setVar(U var) &#123; this.var = var ; &#125; public U getVar() &#123; return this.var ; &#125;&#125; 在这个例子中，我们在泛型类中定义三个泛型变量 T、K、U，并且把第三个泛型变量 U 用来填充接口 Info。所以在这个例子中 Info 所使用的类型就是由 U 来决定的。代码如下：12InfoImpl&lt;Integer, Double, String&gt; i = new InfoImpl&lt;&gt;(&quot;xian&quot;);System.out.println(i.getVar()) ; 4. 泛型函数上面我们讲解了类和接口的泛型使用，下面我们再说说，怎么单独在一个函数里使用泛型。新建一个普通的类 StaticFans，然后在其中定义了两个泛型函数：12345678910public class StaticFans &#123; // 静态函数 public static &lt;T&gt; void staticMethod(T a) &#123; Log.d(&quot;xian&quot;, &quot;staticMethod: &quot; + a.toString()); &#125; // 普通函数 public &lt;T&gt; void otherMethod(T a) &#123; Log.d(&quot;xian&quot;, &quot;otherMethod: &quot; + a.toString()); &#125;&#125; 上面分别是静态泛型函数和常规泛型函数的定义方法，与以往方法的唯一不同点就是在返回值前加上 来表示泛型变量。其它没什么区别。使用方法如下：123456// 静态方法StaticFans.staticMethod(&quot;Xian&quot;);// 常规方法StaticFans staticFans = new StaticFans();staticFans.otherMethod(123); 5. 泛型返回值有时，我们需要将泛型变量返回，比如下面这个函数：1234public static &lt;T&gt; List&lt;T&gt; parseArray(String response, Class&lt;T&gt; object) &#123; List&lt;T&gt; modelList = JSON.parseArray(response, object); return modelList;&#125; 6. 泛型数组在写程序时，大家可能会遇到类似 String[] list = new String[8]; 的需求，这里可以定义 String 数组，当然我们也可以定义泛型数组，泛型数组的定义方法为 T[]，与 String[] 是一致的，下面看看用法：12345678public static &lt;T&gt; T[] fun1(T... arg) &#123; return arg ; // 返回泛型数组 &#125; // 使用public static void main(String args[]) &#123; Integer[] i = fun1(1,2,3,4,5,6) ; Integer[] result = fun1(i) ;&#125; 通配符 1. 无界“?”可以接收任何类型。12345public void processElements(List&lt;?&gt; elements)&#123; for(Object o : elements)&#123; System.out.println(o); &#125;&#125; 2. 上界这种情况下能够接收 A 类或者 A 类的子类。12345public void processElements(List&lt;? extends A&gt; elements)&#123; for(A a : elements)&#123; System.out.println(a.getValue()); &#125;&#125; A 类也可以换成接口：12345678910111213public interface Comparable&lt;T&gt; &#123; public boolean compareTo(T i);&#125;// 添加上 extends Comparable 之后，就可以 Comparable 里的函数了public static &lt;T extends Comparable&gt; T min(T... a) &#123; T smallest = a[0]; for (T item : a) &#123; if (smallest.compareTo(item)) &#123; smallest = item; &#125; &#125; return smallest;&#125; 通配多个类：123456public static &lt;T extends Fruit &amp; Serializable&gt; String getFruitName(T t) &#123; return t.getName();&#125;public static &lt;T extends Comparable &amp; Serializable, U extends Runnable&gt; T foo(T t, U u) &#123;&#125; 3. 下界接收 A 类或者 A 类的父类：12345public static void insertElements(List&lt;? super A&gt; list)&#123; list.add(new A()); list.add(new B()); list.add(new C());&#125; 泛型通配符 &lt; ? extends T &gt; 来接收返回的数据，此写法的泛型集合不能使用 add 方 法， 而 &lt; ? super T &gt; 不能使用 get 方法，做为接口调用赋值时易出错。 当我们使用 extends 时，我们可以读元素，因为元素都是 T 类或子类，可以放心的用 T 类拿出。当使用 super 时，可以添加元素，因为都是 T 类或父类，那么就可以安全的插入 T 类。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Thread]]></title>
    <url>%2F1900%2F01%2F05%2F00JAVA%2F05%20Java%20Thread%2F</url>
    <content type="text"><![CDATA[线程对象是可以产生线程的对象。比如在 JAVA 平台中 Thread 对象、Runnable 对象。线程，是指正在执行的一个指点令序列。在 JAVA 平台上是指从一个线程对象的 start() 开始，运行 run() 方法体中的那一段相对独立的过程。 相比于多进程，多线程的优势有：1）进程之间不能共享数据，线程可以；2）系统创建进程需要为该进程重新分配系统资源，而同一类线程共享代码和数据空间，故创建线程代价比较小；3）JAVA 语言内置了多线程功能支持，简化了 JAVA 多线程编程。 一、创建线程和启动 1、继承 Thread 类通过继承 Thread 类创建线程类的具体步骤和具体代码如下：12345678910111213// 1. 定义一个继承 Thread 类的子类，并重写该类的 run() 方法；class TestThread extends Thread &#123; public void run() &#123; // do something here &#125;&#125; public void test() &#123; // 2. 创建 Thread 子类的实例，即创建了线程对象 TestThread thread = new TestThread(); // 3. 调用该线程对象的 start()方法启动线程。 thread.start();&#125; 2、实现 Runnable 接口通过实现 Runnable 接口创建线程类的具体步骤和具体代码如下：123456789101112131415// 1. 定义 Runnable 接口的实现类，并重写该接口的 run() 方法class TestRunnable implements Runnable &#123; public void run() &#123; // do something here &#125; &#125;public void test() &#123; // 2. 创建 Runnable 实现类的实例 Runnable runnable = new TestRunnable(); // 3. 将 Runnable 实例作为 Thread 的 target 对象 // 即该Thread对象才是真正的线程对象。 Thread thread = new Thread(runnable); thread.start(); &#125; 3、通过 Callable 和 Future 创建线程通过 Callable 和 Future 创建线程的具体步骤和具体代码如下： 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值其中。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 步骤一class TestCallable implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; int i = 0; while (i &lt; 10) &#123; print(Thread.currentThread().getName() + &quot; &quot; + i); i ++; &#125; return i; &#125;&#125;public void test() &#123; // 步骤二 TestCallable testCallable = new TestCallable(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(testCallable); // 开启 ft 线程 for (int i = 0; i &lt; 10; i++) &#123; print(Thread.currentThread().getName() + &quot; 的循环变量 i 的值 &quot; + i); // i 为 20 的时候创建 ft线程 if (i == 6) &#123; // 步骤三 new Thread(ft,&quot;有返回值的线程 FutureTask&quot;).start(); &#125; &#125; // ft 线程结束时，获取返回值 try &#123; // 步骤四 // get() 方法会阻塞，直到子线程执行结束才返回 print(&quot;子线程的返回值：&quot; + ft.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125;&#125;private void print(String msg) &#123; Log.d(TAG, msg);&#125; 打印结果： Callable 概述： Callable 类似于 Runnable，但是它有返回值，Runnable 没有。 new Thread(futureTask) 的方式来创建 FutureTask 任务，FutureTask 是一个实现了 Runnable 和 Future 接口的类。 call 方法可以抛出异常，run 方法不可以。 Callable 规定重写的方法是 call()，Runnable 规定重写的方法是 run()。 运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。 二、线程的生命周期 1、新建状态用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用 start 方法进入就绪状态（runnable）。 不能对已经启动的线程再次调用 start() 方法，否则会出现 java.lang.IllegalThreadStateException 异常。 2、就绪状态处于就绪状态的线程已经具备了运行条件，但还没有分配到 CPU，处于线程就绪队列（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为 CPU 的调度不一定是按照先进先出的顺序来调度的），等待系统为其分配 CPU。等待状态并不是执行状态，当系统选定一个等待执行的 Thread 对象后，它就会从等待执行状态进入执行状态，系统挑选的动作称之为“CPU 调度”。一旦获得 CPU，线程就进入运行状态并自动调用自己的 run 方法。 如果希望子线程调用 start() 方法后立即执行，可以使用 Thread.sleep() 方式使主线程睡眠一伙儿，转去执行子线程。 3、运行状态处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。 处于就绪状态的线程，如果获得了 CPU 的调度，就会从就绪状态变为运行状态，执行 run() 方法中的任务。如果该线程失去了 CPU 资源，就会又从运行状态变为就绪状态，重新等待系统分配资源。也可以对在运行状态的线程调用 yield() 方法，它就会让出 CPU 资源，再次变为就绪状态。 当发生如下情况是，线程会从运行状态变为阻塞状态： 线程调用 sleep 方法主动放弃所占用的系统资源。 线程调用一个阻塞式 IO 方法，在该方法返回之前，该线程被阻塞。 线程试图获得一个同步监视器，但更改同步监视器正被其他线程所持有。 线程在等待某个通知（notify）。 程序调用了线程的 suspend 方法将线程挂起。不过该方法容易导致死锁，所以程序应该尽量避免使用该方法。 当线程的 run() 方法执行完，或者被强制性地终止，例如出现异常，或者调用了 stop()、destroy() 方法等等，就会从运行状态转变为死亡状态。 4、阻塞状态处于运行状态的线程在某些情况下，如执行了 sleep 方法，或等待 I/O 设备等资源，将让出 CPU 并暂时停止自己的运行，进入阻塞状态。 在阻塞状态的线程不能进入就绪队列。只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的 I/O 设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行。 5、死亡状态当线程的 run() 方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用 start() 方法，会抛出 java.lang.IllegalThreadStateException 异常。 三、线程管理 JAVA 提供了一些便捷的方法用于会线程状态的控制：线程睡眠、让步、合并，设置优先级，后台（守护）线程，结束线程。 1、线程睡眠（sleep）如果我们需要让当前正在执行的线程暂停一段时间，并进入阻塞状态，则可以通过调用 Thread 的 sleep 方法。 sleep 是静态方法，最好不要用 Thread 的实例对象调用它，因为它睡眠的始终是当前正在运行的线程，而不是调用它的线程对象，它只对正在运行状态的线程对象有效。如下面的例子：12345678910111213141516171819202122232425public void test() &#123; print(Thread.currentThread().getName()); MyThread myThread = new MyThread(); myThread.start(); try &#123; // 这里 sleep 的就是 main 线程，而非 myThread 线程 myThread.sleep(1000); Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; for (int i = 0; i &lt; 100; i++)&#123; print(&quot;main: &quot; + i); &#125;&#125;class MyThread extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++)&#123; print(&quot;MyThread: &quot; + i); &#125; &#125;&#125; JAVA 线程调度是 JAVA 多线程的核心，只有良好的调度，才能充分发挥系统的性能，提高程序的执行效率。但是不管程序员怎么编写调度，只能最大限度的影响线程执行的次序，而不能做到精准控制。因为使用 sleep 方法之后，线程是进入阻塞状态的，只有当睡眠的时间结束，才会重新进入到就绪状态，而就绪状态进入到运行状态，是由系统控制的，我们不可能精准的去干涉它，所以如果调用 Thread.sleep(1000) 使得线程睡眠1秒，可能结果会大于1秒。 2、线程让步（yield）yield() 方法和 sleep() 方法有点相似，它也是 Thread 类提供的一个静态的方法，它也可以让当前正在执行的线程暂停，让出 CPU 资源给其他的线程。但是和 sleep() 方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。yield() 方法只是让当前线程暂停一下，重新进入就绪的线程池中，让系统的线程调度器重新调度器重新调度一次，完全可能出现这样的情况：当某个线程调用 yield() 方法之后，线程调度器又将其调度出来重新进入到运行状态执行。 实际上，当某个线程调用了 yield() 方法暂停之后，优先级与当前线程相同，或者优先级比当前线程更高的就绪状态的线程更有可能获得执行的机会，当然，只是有可能，因为我们不可能精确的干涉 CPU 调度线程。用法如下：12345678910111213141516171819202122public void test() &#123; new MyThread(&quot;低级&quot;, 1).start(); new MyThread(&quot;中级&quot;, 5).start(); new MyThread(&quot;高级&quot;, 10).start();&#125;class MyThread extends Thread &#123; public MyThread(String name, int pro) &#123; super(name); // 设置线程的名称 this.setPriority(pro); // 设置优先级 &#125; @Override public void run() &#123; for (int i = 0; i &lt; 30; i++) &#123; print(this.getName() + &quot;线程第 &quot; + i + &quot; 次执行！&quot;); if (i % 5 == 0) &#123; Thread.yield(); &#125; &#125; &#125;&#125; 关于 sleep() 方法和 yield() 方的区别如下： sleep 方法暂停当前线程后，会进入阻塞状态，只有当睡眠时间到了，才会转入就绪状态。而 yield 方法调用后 ，是直接进入就绪状态，所以有可能刚进入就绪状态，又被调度到运行状态。 sleep 方法声明抛出了 InterruptedException，所以调用 sleep 方法的时候要捕获该异常，或者显示声明抛出该异常。而 yield 方法则没有声明抛出任务异常。 sleep 方法比 yield 方法有更好的可移植性，通常不要依靠 yield 方法来控制并发线程的执行。 3、线程合并（join）线程的合并的含义就是将几个并行线程的线程合并为一个单线程执行，应用场景是当一个线程必须等待另一个线程执行完毕才能执行时，Thread 类提供了 join 方法来完成这个功能。注意，它不是静态方法。 从下面的方法的列表可以看到，它有3个重载的方法：123456789101112// 当前线程等该加入该线程后面，等待该线程终止。 void join() // 当前线程等待该线程终止的时间最长为 millis 毫秒。// 如果在 millis 时间内，该线程没有执行完，// 那么当前线程进入就绪状态，重新等待 CPU 调度 void join(long millis) // 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。// 如果在 millis + nanos 时间内，该线程没有执行完，// 那么当前线程进入就绪状态，重新等待 CPU 调度void join(long millis, int nanos) 4、设置线程的优先级每个线程执行时都有一个优先级的属性，优先级高的线程可以获得较多的执行机会，而优先级低的线程则获得较少的执行机会。与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取 CPU 资源的概率较大，优先级低的也并非没机会执行。 每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main 线程具有普通优先级。 注：Thread 类提供了 setPriority(int newPriority) 和 getPriority() 方法来设置和返回一个指定线程的优先级，其中 setPriority 方法的参数是一个整数，范围是 1~10 之间，也可以使用 Thread 类提供的三个静态常量：123MAX_PRIORITY = 10MIN_PRIORITY = 1NORM_PRIORITY = 5 使用示例代码见上（节：线程让步）。 虽然 Java 提供了 10 个优先级别，但这些优先级别需要操作系统的支持。不同的操作系统的优先级并不相同，而且也不能很好的和 Java 的 10 个优先级别对应。所以我们应该使用 MAX_PRIORITY、MIN_PRIORITY 和 NORM_PRIORITY 三个静态常量来设定优先级，这样才能保证程序最好的可移植性。 5、后台（守护）线程守护线程使用的情况较少，但并非无用，举例来说，JVM 的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。调用线程对象的方法 setDaemon(true)，则可以将其设置为守护线程。守护线程的用途为： 守护线程通常用于执行一些后台作业，例如在你的应用程序运行时播放背景音乐，在文字编辑器里做自动语法检查、自动保存等功能。 Java 的垃圾回收也是一个守护线程。守护线的好处就是你不需要关心它的结束问题。例如你在你的应用程序运行的时候希望播放背景音乐，如果将这个播放背景音乐的线程设定为非守护线程，那么在用户请求退出的时候，不仅要退出主线程，还要通知播放背景音乐的线程退出；如果设定为守护线程则不需要了。 setDaemon 方法的详细说明：1public final void setDaemon(boolean on) 将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。 该方法必须在启动线程前调用。 该方法首先调用该线程的 checkAccess 方法，且不带任何参数。这可能抛出 SecurityException（在当前线程中）。 参数： on - 如果为 true，则将该线程标记为守护线程。 抛出： IllegalThreadStateException - 如果该线程处于活动状态。 SecurityException - 如果当前线程无法修改该线程。 注：JRE 判断程序是否执行结束的标准是所有的前台执线程行完毕了，而不管后台线程的状态，因此，在使用后台线程时候一定要注意这个问题。 6、正确结束线程Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit 这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的。想要安全有效的结束一个线程，可以使用下面的方法： 正常执行完run方法，然后结束掉； 控制循环条件和判断条件的标识符来结束掉线程。 1234567891011121314class MyThread extends Thread &#123; int i = 0; boolean next = true; @Override public void run() &#123; while (next) &#123; if (i == 10) &#123; next = false; &#125; i++; System.out.println(i); &#125; &#125; &#125; 四、线程同步 JAVA 允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。 1、同步方法即有 synchronized 关键字修饰的方法。由于 Java 的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。1public synchronized void save() &#123;&#125; synchronized 关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类。 2、同步代码块即有 synchronized 关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。123456789101112131415161718192021222324252627public class Bank &#123; private int count =0; // 账户余额 // 存钱 public void addMoney(int money) &#123; synchronized (this) &#123; count += money; &#125; System.out.println(System.currentTimeMillis()+&quot;存进：&quot;+money); &#125; // 取钱 public void subMoney(int money) &#123; synchronized (this) &#123; if (count-money &lt; 0) &#123; System.out.println(&quot;余额不足&quot;); return; &#125; count -= money; &#125; System.out.println(+System.currentTimeMillis()+&quot;取出：&quot;+money); &#125; // 查询 public void lookMoney() &#123; System.out.println(&quot;账户余额：&quot;+count); &#125;&#125; 同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用 synchronized 代码块同步关键代码即可。 3、使用特殊域变量（volatile）实现线程同步• volatile 关键字为域变量的访问提供了一种免锁机制；• 使用 volatile 修饰域相当于告诉虚拟机该域可能会被其他线程更新；• 因此每次使用该域就要重新计算，而不是使用寄存器中的值；• volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class SynchronizedThread &#123; class Bank &#123; private volatile int account = 100; public int getAccount() &#123; return account; &#125; /** * 用同步方法实现 * @param money */ public synchronized void save(int money) &#123; account += money; &#125; /** * 用同步代码块实现 * @param money */ public void save1(int money) &#123; synchronized (this) &#123; account += money; &#125; &#125; &#125; class NewThread implements Runnable &#123; private Bank bank; public NewThread(Bank bank) &#123; this.bank = bank; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; // bank.save1(10); bank.save(10); System.out.println(i + &quot;账户余额为：&quot; + bank.getAccount()); &#125; &#125; &#125; /** * 建立线程，调用内部类 */ public void useThread() &#123; Bank bank = new Bank(); NewThread new_thread = new NewThread(bank); System.out.println(&quot;线程1&quot;); Thread thread1 = new Thread(new_thread); thread1.start(); System.out.println(&quot;线程2&quot;); Thread thread2 = new Thread(new_thread); thread2.start(); &#125; public static void main(String[] args) &#123; SynchronizedThread st = new SynchronizedThread(); st.useThread(); &#125;&#125; 多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。用 final 域，有锁保护的域和 volatile 域可以避免非同步的问题。 4、使用重入锁（Lock）实现线程同步在 Java SE5.0 中新增了一个 java.util.concurrent 包来支持同步。ReentrantLock 类是可重入、互斥、实现了 Lock 接口的锁，它与使用 synchronized 方法和快具有相同的基本行为和语义，并且扩展了其能力。ReentrantLock 类的常用方法有：123ReentrantLock() : 创建一个 ReentrantLock 实例 lock() : 获得锁 unlock() : 释放锁 ReentrantLock() 还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用。示例如下：1234567891011121314151617181920// 只给出要修改的代码，其余代码与上同class Bank &#123; private int account = 100; // 需要声明这个锁 private Lock lock = new ReentrantLock(); public int getAccount() &#123; return account; &#125; // 这里不再需要synchronized public void save(int money) &#123; lock.lock(); try &#123; account += money; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 五、线程通信 1、借助于 wait、notify 和 notifyAll 实现通信程执行 wait() 后，就放弃了运行资格，处于冻结状态；线程运行时，内存中会建立一个线程池，冻结状态的线程都存在于线程池中，notify() 执行时唤醒的也是线程池中的线程，线程池中有多个线程时唤醒第一个被冻结的线程；notifyall()，唤醒线程池中所有线程。 • wait()、notify()、notifyall() 都用在同步里面，因为这三个函数是对持有锁的线程进行操作，而只有同步才有锁，所以要使用在同步中；• wait()、notify()、notifyall(), 在使用时必须标识它们所操作的线程持有的锁，因为等待和唤醒必须是同一锁下的线程；而锁可以是任意对象，所以这三个方法都是 Object 类中的方法。 单个消费者生产者例子如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 生产者和消费者都要操作的资源class Resource &#123; private String name; private int count = 1; private boolean flag = false; public synchronized void set(String name) &#123; if (flag) &#123; try &#123; wait(); &#125; catch (Exception e) &#123;&#125; &#125; this.name = name + &quot;---&quot; + count++; print(Thread.currentThread().getName() + &quot;...生产者...&quot; + this.name); flag = true; this.notify(); &#125; public synchronized void out() &#123; if (!flag) &#123; try &#123; wait(); &#125; catch (Exception e) &#123;&#125; &#125; print(Thread.currentThread().getName() + &quot;...消费者...&quot; + name); flag = false; this.notify(); &#125;&#125;class Producer implements Runnable &#123; private Resource res; Producer(Resource res) &#123; this.res = res; &#125; public void run() &#123; while(true) &#123; res.set(&quot;商品&quot;); &#125; &#125;&#125;class Consumer implements Runnable &#123; private Resource res; Consumer(Resource res) &#123; this.res = res; &#125; public void run() &#123; while(true) &#123; res.out(); &#125; &#125;&#125; 测试代码：12345678910// 运行结果正常，生产者生产一个商品，紧接着消费者消费一个商品。public void test() &#123; Resource r = new Resource(); Producer pro = new Producer(r); Consumer con = new Consumer(r); Thread t1 = new Thread(pro); Thread t2 = new Thread(con); t1.start(); t2.start();&#125; 运行结果： 如果有多个生产者和多个消费者，上面的代码是有问题，比如 2 个生产者，2 个消费者，运行结果就可能出现生产的 1 个商品生产了一次而被消费了 2 次，或者连续生产 2 个商品而只有1个被消费，这是因为此时共有 4 个线程在操作 Resource 对象 r, 而 notify() 唤醒的是线程池中第 1 个 wait() 的线程，所以生产者执行 notify() 时，唤醒的线程有可能是另 1 个生产者线程，这个生产者线程从 wait() 中醒来后不会再判断 flag，而是直接向下运行打印出一个新的商品，这样就出现了连续生产 2 个商品。 为了避免这种情况，修改代码如下：1234567891011121314151617181920212223242526272829class Resource &#123; private String name; private int count = 1; private boolean flag = false; public synchronized void set(String name) &#123; /* 原先是if,现在改成while，这样生产者线程从冻结状态醒来时，还会再判断flag. */ while(flag) try &#123; wait();&#125; catch(Exception e) &#123;&#125; this.name = name + &quot;---&quot; + count++; print(Thread.currentThread().getName() + &quot;...生产者...&quot;+ this.name); flag = true; /* 原先是 notify(), 现在改成 notifyAll()，这样生产者线程生产完一个商品后 可以将等待中的消费者线程唤醒，否则只将上面改成 while 后，可能出现所有生产者 和消费者都在 wait() 的情况。*/ this.notifyAll(); &#125; public synchronized void out() &#123; /* 原先是if,现在改成while，这样消费者线程从冻结状态醒来时，还会再判断flag. */ while(!flag) try&#123; wait();&#125; catch(Exception e) &#123;&#125; print(Thread.currentThread().getName() + &quot;...消费者...&quot; + this.name); flag = false; /* 原先是 notify(), 现在改成 notifyAll()，这样消费者线程消费完一个商品后 可以将等待中的生产者线程唤醒，否则只将上面改成 while 后，可能出现所有生产者 和消费者都在 wait() 的情况。*/ this.notifyAll(); &#125;&#125; 测试代码：12345678910111213public void test() &#123; Resource r = new Resource(); Producer pro = new Producer(r); Consumer con = new Consumer(r); Thread t1 = new Thread(pro); Thread t2 = new Thread(con); Thread t3 = new Thread(pro); Thread t4 = new Thread(con); t1.start(); t2.start(); t3.start(); t4.start();&#125; 运行结果部分截图： 2、使用 Condition 控制线程通信JDK 1.5 中，提供了多线程的升级解决方案为： 将同步 synchronized 替换为显式的 Lock 操作； 将 Object 类中的 wait()、notify()、notifyAll() 替换成了 Condition 对象，该对象可以通过 Lock 锁对象获取; 一个 Lock 对象上可以绑定多个 Condition 对象，这样实现了本方线程只唤醒对方线程，而 JDK 1.5 之前，一个同步只能有一个锁，不同的同步只能用锁来区分，且锁嵌套时容易死锁。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Resource &#123; private String name; private int count = 1; private boolean flag = false; /* Lock 是一个接口，ReentrantLock 是该接口的一个直接子类。*/ private Lock lock = new ReentrantLock(); /* 创建代表生产者方面的 Condition 对象*/ private Condition conditionPro = lock.newCondition(); /* 使用同一个锁，创建代表消费者方面的 Condition 对象*/ private Condition conditionCon = lock.newCondition(); public void set(String name) &#123; // 锁住此语句与 lock.unlock() 之间的代码 lock.lock(); try &#123; while(flag) &#123; // 生产者线程在 conditionPro 对象上等待 conditionPro.await(); &#125; this.name = name + &quot;---&quot; + count++; print(Thread.currentThread().getName() + &quot;...生产者...&quot; + this.name); flag = true; conditionCon.signalAll(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // unlock() 要放在 finally 块中。 lock.unlock(); &#125; &#125; public void out() &#123; // 锁住此语句与 lock.unlock() 之间的代码 lock.lock(); try &#123; while(!flag) &#123; // 消费者线程在 conditionCon 对象上等待 conditionCon.await(); &#125; print(Thread.currentThread().getName() + &quot;...消费者...&quot; + this.name); flag = false; /* 唤醒所有在 conditionCon 对象下等待的线程，也就是唤醒所有生产者线程*/ conditionPro.signalAll(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally&#123; lock.unlock(); &#125; &#125;&#125; 3、使用阻塞队列（BlockingQueue）控制线程通信BlockingQueue 是一个接口，也是 Queue 的子接口。BlockingQueue 具有一个特征：当生产者线程试图向 BlockingQueue 中放入元素时，如果该队列已满，则线程被阻塞；但消费者线程试图从 BlockingQueue 中取出元素时，如果队列已空，则该线程阻塞。程序的两个线程通过交替向 BlockingQueue 中放入元素、取出元素，即可很好地控制线程的通信。 BlockingQueue 提供如下两个支持阻塞的方法： put(E e)：尝试把 E e 元素放如 BlockingQueue 中，如果该队列的元素已满，则阻塞该线程。 take()：尝试从 BlockingQueue 的头部取出元素，如果该队列的元素已空，则阻塞该线程。 BlockingQueue 继承了 Queue 接口，当然也可以使用 Queue 接口中的方法，这些方法归纳起来可以分为如下三组： 在队列尾部插入元素，包括 add(E e)、offer(E e)、put(E e) 方法，当该队列已满时，这三个方法分别会抛出异常、返回 false、阻塞队列。 在队列头部删除并返回删除的元素。包括 remove()、poll()、take() 方法，当该队列已空时，这三个方法分别会抛出异常、返回 false、阻塞队列。 在队列头部取出但不删除元素。包括 element() 和 peek() 方法，当队列已空时，这两个方法分别抛出异常、返回 false。 BlockingQueue 接口包含如下 5 个实现类： ArrayBlockingQueue：基于数组实现的 BlockingQueue 队列。 LinkedBlockingQueue：基于链表实现的 BlockingQueue 队列。 PriorityBlockingQueue：它并不是保准的阻塞队列，该队列调用remove()、poll()、take() 等方法提取出元素时，并不是取出队列中存在时间最长的元素，而是队列中最小的元素。它判断元素的大小即可根据元素（实现Comparable接口）的本身大小来自然排序，也可使用 Comparator 进行定制排序。 SynchronousQueue：同步队列。对该队列的存、取操作必须交替进行。 DelayQueue：它是一个特殊的 BlockingQueue，底层基于 PriorityBlockingQueue 实现，不过，DelayQueue 要求集合元素都实现 Delay 接口（该接口里只有一个 long getDelay() 方法），DelayQueue 根据集合元素的 getDelay() 方法的返回值进行排序。 Copy 的一个示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;public class BlockingQueueTest &#123; public static void main(String[] args) throws Exception &#123; //创建一个容量为1的BlockingQueue BlockingQueue&lt;String&gt; b=new ArrayBlockingQueue&lt;&gt;(1); //启动3个生产者线程 new Producer(b).start(); new Producer(b).start(); new Producer(b).start(); //启动一个消费者线程 new Consumer(b).start(); &#125;&#125;class Producer extends Thread&#123; private BlockingQueue&lt;String&gt; b; public Producer(BlockingQueue&lt;String&gt; b)&#123; this.b=b; &#125; public synchronized void run()&#123; String [] str=new String[]&#123; &quot;java&quot;, &quot;struts&quot;, &quot;Spring&quot; &#125;; for(int i=0;i&lt;9999999;i++)&#123; System.out.println(getName()+&quot;生产者准备生产集合元素！&quot;); try&#123; b.put(str[i%3]); sleep(1000); //尝试放入元素，如果队列已满，则线程被阻塞 &#125;catch(Exception e)&#123;System.out.println(e);&#125; System.out.println(getName()+&quot;生产完成：&quot;+b); &#125; &#125;&#125;class Consumer extends Thread&#123; private BlockingQueue&lt;String&gt; b; public Consumer(BlockingQueue&lt;String&gt; b)&#123; this.b=b; &#125; public synchronized void run()&#123; while(true)&#123; System.out.println(getName()+&quot;消费者准备消费集合元素！&quot;); try&#123; sleep(1000); //尝试取出元素，如果队列已空，则线程被阻塞 b.take(); &#125;catch(Exception e)&#123;System.out.println(e);&#125; System.out.println(getName()+&quot;消费完：&quot;+b); &#125; &#125;&#125; 六、线程池 合理利用线程池能够带来三个好处。 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 1、使用 Executors 工厂类产生线程池Executor 线程池框架的最大优点是把任务的提交和执行解耦。客户端将要执行的任务封装成 Task，然后提交即可。而 Task 如何执行客户端则是透明的。具体点讲，提交一个 Callable 对象给 ExecutorService（如最常用的线程池 ThreadPoolExecutor），将得到一个 Future 对象，调用 Future 对象的 get 方法等待执行结果。线程池实现原理类结构图如下： 上图中涉及到的线程池内部实现原理的所有类，不利于我们理解线程池如何使用。我们先从客户端的角度出发，看看客户端使用线程池所涉及到的类结构图。 由上图可知，ExecutorService是 Java 中对线程池定义的一个接口，它 java.util.concurrent 包中。Java API 对 ExecutorService 接口的实现有两个，所以这两个即是 Java 线程池具体实现类如下：12ThreadPoolExecutor ScheduledThreadPoolExecutor 除此之外，ExecutorService 还继承了 Executor接口（注意区分 Executor 接口和 Executors 工厂类），这个接口只有一个 execute() 方法。 使用 Executors 执行多线程任务的步骤如下： 调用 Executors 类的静态工厂方法创建一个 ExecutorService 对象，该对象代表一个线程池； 创建 Runnable 实现类或 Callable 实现类的实例，作为线程执行任务； 调用 ExecutorService 对象的 submit() 方法来提交 Runnable 实例或 Callable 实例； 当不想提交任务时，调用 ExecutorService 对象的 shutdown() 方法来关闭线程池。 1.1、Executors 创建线程池的方法 newFixedThreadPool() ：作用：该方法返回一个固定线程数量的线程池，该线程池中的线程数量始终不变，即不会再创建新的线程，也不会销毁已经创建好的线程，自始自终都是那几个固定的线程在工作，所以该线程池可以控制线程的最大并发数。栗子：假如有一个新任务提交时，线程池中如果有空闲的线程则立即使用空闲线程来处理任务，如果没有，则会把这个新任务存在一个任务队列中，一旦有线程空闲了，则按 FIFO 方式处理任务队列中的任务。 newCachedThreadPool() ：作用：该方法返回一个可以根据实际情况调整线程池中线程的数量的线程池。即该线程池中的线程数量不确定，是根据实际情况动态调整的。栗子：假如该线程池中的所有线程都正在工作，而此时有新任务提交，那么将会创建新的线程去处理该任务，而此时假如之前有一些线程完成了任务，现在又有新任务提交，那么将不会创建新线程去处理，而是复用空闲的线程去处理新任务。那么此时有人有疑问了，那这样来说该线程池的线程岂不是会越集越多？其实并不会，因为线程池中的线程都有一个“保持活动时间”的参数，通过配置它，如果线程池中的空闲线程的空闲时间超过该“保存活动时间”则立刻停止该线程，而该线程池默认的“保持活动时间”为60s。 newSingleThreadExecutor() ：作用：该方法返回一个只有一个线程的线程池，即每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待这一个线程空闲，当这个线程空闲了再按FIFO方式顺序执行任务队列中的任务。 newScheduledThreadPool() ：作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。 newSingleThreadScheduledExecutor() ：作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。只不过和上面的区别是该线程池大小为1，而上面的可以指定线程池的大小。 Executors 只是一个工厂类，它所有的方法返回的都是 ThreadPoolExecutor、ScheduledThreadPoolExecutor 这两个类的实例。 1.2、ExecutorService 方法12345- execute(Runnable)- submit(Runnable)- submit(Callable)- invokeAny(...)- invokeAll(...) execute(Runnable) 这个方法接收一个 Runnable 实例，并且异步的执行，请看下面的示例：1234567ExecutorService executorService = Executors.newSingleThreadExecutor();executorService.execute(new Runnable() &#123; public void run() &#123; System.out.println(&quot;Asynchronous task&quot;); &#125;&#125;);executorService.shutdown(); submit(Runnable) submit(Runnable) 和 execute(Runnable) 区别是前者可以返回一个 Future 对象，通过返回的 Future 对象，我们可以检查提交的任务是否执行完毕，请看下面执行的例子：1234567Future future = executorService.submit(new Runnable() &#123; public void run() &#123; System.out.println(&quot;Asynchronous task&quot;); &#125;&#125;);// returns null if the task has finished correctly.future.get(); 如果任务执行完成，future.get() 方法会返回一个 null。 注意，future.get() 方法会产生阻塞。 submit(Callable) submit(Callable) 和 submit(Runnable) 类似，也会返回一个 Future 对象，但是除此之外，submit(Callable) 接收的是一个 Callable 的实现，Callable 接口中的 call() 方法有一个返回值，可以返回任务的执行结果，而 Runnable 接口中的 run() 方法是 void 的，没有返回值。请看下面实例：1234567Future future = executorService.submit(new Callable()&#123; public Object call() throws Exception &#123; System.out.println(&quot;Asynchronous Callable&quot;); return &quot;Callable Result&quot;; &#125;&#125;);System.out.println(&quot;future.get() = &quot; + future.get()); 如果任务执行完成，future.get() 方法会返回 Callable 任务的执行结果。另外，future.get() 方法会产生阻塞。 invokeAny(…) invokeAny(…) 方法接收的是一个 Callable 的集合，执行这个方法不会返回 Future，但是会返回所有 Callable 任务中其中一个任务的执行结果。这个方法也无法保证返回的是哪个任务的执行结果，反正是其中的某一个。请看下面实例：123456789101112131415161718192021ExecutorService executorService = Executors.newSingleThreadExecutor();Set&lt;Callable&lt;String&gt;&gt; callables = new HashSet&lt;Callable&lt;String&gt;&gt;();callables.add(new Callable&lt;String&gt;() &#123; public String call() throws Exception &#123; return &quot;Task 1&quot;; &#125;&#125;);callables.add(new Callable&lt;String&gt;() &#123; public String call() throws Exception &#123; return &quot;Task 2&quot;; &#125;&#125;);callables.add(new Callable&lt;String&gt;() &#123; public String call() throws Exception &#123; return &quot;Task 3&quot;; &#125;&#125;);String result = executorService.invokeAny(callables);System.out.println(&quot;result = &quot; + result);executorService.shutdown(); 大家可以尝试执行上面代码，每次执行都会返回一个结果，并且返回的结果是变化的，可能会返回“Task2”也可是“Task1”或者其它。 invokeAll(…) invokeAll(…) 与 invokeAny(…) 类似也是接收一个 Callable 集合，但是前者执行之后会返回一个 Future 的 List，其中对应着每个 Callable任务执行后的 Future 对象。情况下面这个实例： 123456789101112131415161718192021222324ExecutorService executorService = Executors.newSingleThreadExecutor();Set&lt;Callable&lt;String&gt;&gt; callables = new HashSet&lt;Callable&lt;String&gt;&gt;();callables.add(new Callable&lt;String&gt;() &#123; public String call() throws Exception &#123; return &quot;Task 1&quot;; &#125;&#125;);callables.add(new Callable&lt;String&gt;() &#123; public String call() throws Exception &#123; return &quot;Task 2&quot;; &#125;&#125;);callables.add(new Callable&lt;String&gt;() &#123; public String call() throws Exception &#123; return &quot;Task 3&quot;; &#125;&#125;);List&lt;Future&lt;String&gt;&gt; futures = executorService.invokeAll(callables);for(Future&lt;String&gt; future : futures)&#123; System.out.println(&quot;future.get = &quot; + future.get());&#125;executorService.shutdown(); 1.3、ExecutorService 关闭方法当我们使用完成 ExecutorService 之后应该关闭它，否则它里面的线程会一直处于运行状态。举个例子，如果的应用程序是通过 main() 方法启动的，在这个 main() 退出之后，如果应用程序中的 ExecutorService 没有关闭，这个应用将一直运行。之所以会出现这种情况，是因为 ExecutorService 中运行的线程会阻止 JVM 关闭。 要关闭 ExecutorService 中执行的线程，我们可以调用 ExecutorService.shutdown() 方法。在调用 shutdown() 方法之后，ExecutorService 不会立即关闭，但是它不再接收新的任务，直到当前所有线程执行完成才会关闭，所有在 shutdown() 执行之前提交的任务都会被执行。 如果想立即关闭 ExecutorService，我们可以调用 ExecutorService.shutdownNow() 方法。这个动作将跳过所有正在执行的任务和被提交还没有执行的任务。但是它并不对正在执行的任务做任何保证，有可能它们都会停止，也有可能执行完成。 2、ForkJoinPool 线程池在 Java 8 中，引入了自动并行化的概念。它能够让一部分 Java 代码自动地以并行的方式执行，前提是使用了 ForkJoinPool。 ForkJoinPool 同 ThreadPoolExecutor 一样，也实现了 Executor 和 ExecutorService 接口。它使用了一个无限队列来保存需要执行的任务，而线程的数量则是通过构造函数传入，如果没有向构造函数中传入希望的线程数量，那么当前计算机可用的CPU数量会被设置为线程数量作为默认值。 ForkJoinPool 主要用来使用分治法（Divide-and-Conquer Algorithm）来解决问题。典型的应用比如快速排序算法。这里的要点在于，ForkJoinPool 需要使用相对少的线程来处理大量的任务。比如要对 1000 万个数据进行排序，那么会将这个任务分割成两个 500 万的排序任务和一个针对这两组 500 万数据的合并任务。以此类推，对于 500 万的数据也会做出同样的分割处理，到最后会设置一个阈值来规定当数据规模到多少时，停止这样的分割处理。比如，当元素的数量小于 10 时，会停止分割，转而使用插入排序对它们进行排序。那么到最后，所有的任务加起来会有大概 2000000+ 个。问题的关键在于，对于一个任务而言，只有当它所有的子任务完成之后，它才能够被执行。所以当使用 ThreadPoolExecutor 时，使用分治法会存在问题，因为 ThreadPoolExecutor中 的线程无法像任务队列中再添加一个任务并且在等待该任务完成之后再继续执行。而使用 ForkJoinPool 时，就能够让其中的线程创建新的任务，并挂起当前的任务，此时线程就能够从队列中选择子任务执行。比如，我们需要统计一个 double 数组中小于 0.5 的元素的个数，那么可以使用 ForkJoinPool 进行实现如下：12345678910111213141516171819202122232425262728293031323334353637public class ForkJoinTest &#123; private double[] d; private class ForkJoinTask extends RecursiveTask &#123; private int first; private int last; public ForkJoinTask(int first, int last) &#123; this.first = first; this.last = last; &#125; protected Integer compute() &#123; int subCount; if (last - first &lt; 10) &#123; subCount = 0; for (int i = first; i &lt;= last; i++) &#123; if (d[i] &lt; 0.5)&#123; subCount++; &#125; &#125; &#125; else &#123; int mid = (first + last) /2; ForkJoinTask left = new ForkJoinTask(first, mid); left.fork(); ForkJoinTask right = new ForkJoinTask(mid + 1, last); right.fork(); subCount = left.join(); subCount += right.join(); &#125; return subCount; &#125; &#125; public static void main(String[] args) &#123; ForkJoinPool pool=new ForkJoinPool(); pool.submit(new ForkJoinTask(0, 9999999)); pool.awaitTermination(2,TimeUnit.SECONDS); System.out.println(&quot;Found &quot; + n + &quot; values&quot;); &#125;&#125; 以上的关键是 fork() 和 join() 方法。在 ForkJoinPool 使用的线程中，会使用一个内部队列来对需要执行的任务以及子任务进行操作来保证它们的执行顺序。 使用 ThreadPoolExecutor 和 ForkJoinPool 的性能差异： 使用 ForkJoinPool 能够使用数量有限的线程来完成非常多的具有父子关系的任务，比如使用 4 个线程来完成超过 200 万个任务。但是，使用 ThreadPoolExecutor 时，是不可能完成的，因为 ThreadPoolExecutor 中的 Thread 无法选择优先执行子任务，需要完成 200 万个具有父子关系的任务时，也需要 200 万个线程，显然这是不可行的。 ForkJoinPool 能够实现工作窃取（Work Stealing），在该线程池的每个线程中会维护一个队列来存放需要被执行的任务。当线程自身队列中的任务都执行完毕后，它会从别的线程中拿到未被执行的任务并帮助它执行。因此，提高了线程的利用率，从而提高了整体性能。 对于 ForkJoinPool，还有一个因素会影响它的性能，就是停止进行任务分割的那个阈值。比如在之前的快速排序中，当剩下的元素数量小于 10 的时候，就会停止子任务的创建。 结论： 当需要处理递归分治算法时，考虑使用ForkJoinPool； 仔细设置不再进行任务划分的阈值，这个阈值对性能有影响； Java 8 中的一些特性会使用到 ForkJoinPool 中的通用线程池。在某些场合下，需要调整该线程池的默认的线程数量。 七、死锁 产生死锁的四个必要条件如下。当下边的四个条件都满足时即产生死锁，即任意一个条件不满足既不会产生死锁。 死锁的四个必要条件 互斥条件：资源不能被共享，只能被同一个进程使用 请求与保持条件：已经得到资源的进程可以申请新的资源 非剥夺条件：已经分配的资源不能从相应的进程中被强制剥夺 循环等待条件：系统中若干进程组成环路，该环路中每个进程都在+ 等待相邻进程占用的资源 举个常见的死锁例子：进程 A 中包含资源 A，进程 B 中包含资源 B，A 的下一步需要资源 B，B 的下一步需要资源 A，所以它们就互相等待对方占有的资源释放，所以也就产生了一个循环等待死锁。 处理死锁的方法 检测死锁并恢复； 资源进行动态分配； 破除上面的四种死锁条件之一； 忽略该问题，也即鸵鸟算法。当发生了什么问题时，不管他，直接跳过，无视它。 八、线程相关类 ThreadLocal ThreadLocal 它并不是一个线程，而是一个可以在每个线程中存储数据的数据存储类，通过它可以在指定的线程中存储数据，数据存储之后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到该线程的数据。 即多个线程通过同一个 ThreadLocal 获取到的东西是不一样的，就算有的时候出现的结果是一样的（偶然性，两个线程里分别存了两份相同的东西），但他们获取的本质是不同的。使用这个工具类可以简化多线程编程时的并发访问，很简洁的隔离多线程程序的竞争资源。 对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而 ThreadLocal 采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。ThreadLocal 类提供了如下的三个public方法：123456789// 创建一个线程本地变量。ThreadLocal()// 返回此线程局部变量的当前线程副本中的值，// 如果这是线程第一次调用该方法，则创建并初始化此副本。T get()// 返回此线程局部变量的当前线程的初始值。 protected T initialValue() 注：ThreadLocal 和其他所有的同步机制一样，都是为了解决多线程中对于同一变量的访问冲突。值普通的同步机制中，通过对象加锁来实现多线程对同一变量的安全访问，且该变量是多线程共享的，所有需要使用这种同步机制来明确分开是在什么时候对变量进行读写，在什么时候需要锁定该对象。此种情况下，系统并没有将这个资源复制多份，而是采取安全机制来控制访问而已。ThreadLocal 只是从另一个角度解决多线程的并发访问，即将需要并发访问的资源复制多份，每个线程拥有一份资源，每个线程都有自己的资源副本。 总结：若多个线程之间需要共享资源，以达到线程间的通信时，就使用同步机制；若仅仅需要隔离多线程之间的关系资源，则可以使用 ThreadLocal。 参考文章：Java 多线程详解]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java IOUtils]]></title>
    <url>%2F1900%2F01%2F04%2F00JAVA%2F04%20Java%20IOUtils%2F</url>
    <content type="text"><![CDATA[参考链接：Apache API：IOUtilsSource Code：IOUtils.java相关博客 方法： copy：拷贝流。 copyLarge：拷贝较大的数据流。 read：从一个流中读取内容。 readFully：读取指定长度的流。 readLines： contentEquals：比较两个流是否相等。 contentEqualsIgnoreEOL：比较两个流，忽略换行符。 skip：跳过指定长度的流。 skipFully：类似skip，如果忽略的长度大于现有的长度，抛出异常。 write：把数据写入到输出流中。 writeLines： toBufferedInputStream: 把流的全部内容放在另一个流中。 toBufferedReader: 返回输入流，。 toByteArray: 返回字节数组。 toCharArray: 返回字符数组。 toInputStream: 返回输入流。 toString: 返回字符串。 ineIterator：读取流，返回迭代器。 close：关闭流。 源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the &quot;License&quot;); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.io;import java.io.BufferedInputStream;import java.io.BufferedReader;import java.io.ByteArrayInputStream;import java.io.CharArrayWriter;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.io.Reader;import java.io.StringWriter;import java.io.Writer;import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;import java.util.List;import org.apache.commons.io.output.ByteArrayOutputStream;/** * General IO stream manipulation utilities. * &lt;p&gt; * This class provides static utility methods for input/output operations. * &lt;ul&gt; * &lt;li&gt;closeQuietly - these methods close a stream ignoring nulls and exceptions * &lt;li&gt;toXxx/read - these methods read data from a stream * &lt;li&gt;write - these methods write data to a stream * &lt;li&gt;copy - these methods copy all the data from one stream to another * &lt;li&gt;contentEquals - these methods compare the content of two streams * &lt;/ul&gt; * &lt;p&gt; * The byte-to-char methods and char-to-byte methods involve a conversion step. * Two methods are provided in each case, one that uses the platform default * encoding and the other which allows you to specify an encoding. You are * encouraged to always specify an encoding because relying on the platform * default can lead to unexpected results, for example when moving from * development to production. * &lt;p&gt; * All the methods in this class that read a stream are buffered internally. * This means that there is no cause to use a &lt;code&gt;BufferedInputStream&lt;/code&gt; * or &lt;code&gt;BufferedReader&lt;/code&gt;. The default buffer size of 4K has been shown * to be efficient in tests. * &lt;p&gt; * Wherever possible, the methods in this class do &lt;em&gt;not&lt;/em&gt; flush or close * the stream. This is to avoid making non-portable assumptions about the * streams&apos; origin and further use. Thus the caller is still responsible for * closing streams after use. * &lt;p&gt; * Origin of code: Excalibur. * * @author Peter Donald * @author Jeff Turner * @author Matthew Hawthorne * @author Stephen Colebourne * @author Gareth Davis * @author Ian Springer * @author Niall Pemberton * @author Sandy McArthur * @version $Id: IOUtils.java 481854 2006-12-03 18:30:07Z scolebourne $ */public class IOUtils &#123; // NOTE: This class is focussed on InputStream, OutputStream, Reader and // Writer. Each method should take at least one of these as a parameter, // or return one of them. /** * The Unix directory separator character. */ public static final char DIR_SEPARATOR_UNIX = &apos;/&apos;; /** * The Windows directory separator character. */ public static final char DIR_SEPARATOR_WINDOWS = &apos;\\&apos;; /** * The system directory separator character. */ public static final char DIR_SEPARATOR = File.separatorChar; /** * The Unix line separator string. */ public static final String LINE_SEPARATOR_UNIX = &quot;\n&quot;; /** * The Windows line separator string. */ public static final String LINE_SEPARATOR_WINDOWS = &quot;\r\n&quot;; /** * The system line separator string. */ public static final String LINE_SEPARATOR; static &#123; // avoid security issues StringWriter buf = new StringWriter(4); PrintWriter out = new PrintWriter(buf); out.println(); LINE_SEPARATOR = buf.toString(); &#125; /** * The default buffer size to use. */ private static final int DEFAULT_BUFFER_SIZE = 1024 * 4; /** * Instances should NOT be constructed in standard programming. */ public IOUtils() &#123; super(); &#125; //----------------------------------------------------------------------- /** * Unconditionally close an &lt;code&gt;Reader&lt;/code&gt;. * &lt;p&gt; * Equivalent to &#123;@link Reader#close()&#125;, except any exceptions will be ignored. * This is typically used in finally blocks. * * @param input the Reader to close, may be null or already closed */ public static void closeQuietly(Reader input) &#123; try &#123; if (input != null) &#123; input.close(); &#125; &#125; catch (IOException ioe) &#123; // ignore &#125; &#125; /** * Unconditionally close a &lt;code&gt;Writer&lt;/code&gt;. * &lt;p&gt; * Equivalent to &#123;@link Writer#close()&#125;, except any exceptions will be ignored. * This is typically used in finally blocks. * * @param output the Writer to close, may be null or already closed */ public static void closeQuietly(Writer output) &#123; try &#123; if (output != null) &#123; output.close(); &#125; &#125; catch (IOException ioe) &#123; // ignore &#125; &#125; /** * Unconditionally close an &lt;code&gt;InputStream&lt;/code&gt;. * &lt;p&gt; * Equivalent to &#123;@link InputStream#close()&#125;, except any exceptions will be ignored. * This is typically used in finally blocks. * * @param input the InputStream to close, may be null or already closed */ public static void closeQuietly(InputStream input) &#123; try &#123; if (input != null) &#123; input.close(); &#125; &#125; catch (IOException ioe) &#123; // ignore &#125; &#125; /** * Unconditionally close an &lt;code&gt;OutputStream&lt;/code&gt;. * &lt;p&gt; * Equivalent to &#123;@link OutputStream#close()&#125;, except any exceptions will be ignored. * This is typically used in finally blocks. * * @param output the OutputStream to close, may be null or already closed */ public static void closeQuietly(OutputStream output) &#123; try &#123; if (output != null) &#123; output.close(); &#125; &#125; catch (IOException ioe) &#123; // ignore &#125; &#125; // read toByteArray //----------------------------------------------------------------------- /** * Get the contents of an &lt;code&gt;InputStream&lt;/code&gt; as a &lt;code&gt;byte[]&lt;/code&gt;. * &lt;p&gt; * This method buffers the input internally, so there is no need to use a * &lt;code&gt;BufferedInputStream&lt;/code&gt;. * * @param input the &lt;code&gt;InputStream&lt;/code&gt; to read from * @return the requested byte array * @throws NullPointerException if the input is null * @throws IOException if an I/O error occurs */ public static byte[] toByteArray(InputStream input) throws IOException &#123; ByteArrayOutputStream output = new ByteArrayOutputStream(); copy(input, output); return output.toByteArray(); &#125; /** * Get the contents of a &lt;code&gt;Reader&lt;/code&gt; as a &lt;code&gt;byte[]&lt;/code&gt; * using the default character encoding of the platform. * &lt;p&gt; * This method buffers the input internally, so there is no need to use a * &lt;code&gt;BufferedReader&lt;/code&gt;. * * @param input the &lt;code&gt;Reader&lt;/code&gt; to read from * @return the requested byte array * @throws NullPointerException if the input is null * @throws IOException if an I/O error occurs */ public static byte[] toByteArray(Reader input) throws IOException &#123; ByteArrayOutputStream output = new ByteArrayOutputStream(); copy(input, output); return output.toByteArray(); &#125; /** * Get the contents of a &lt;code&gt;Reader&lt;/code&gt; as a &lt;code&gt;byte[]&lt;/code&gt; * using the specified character encoding. * &lt;p&gt; * Character encoding names can be found at * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;. * &lt;p&gt; * This method buffers the input internally, so there is no need to use a * &lt;code&gt;BufferedReader&lt;/code&gt;. * * @param input the &lt;code&gt;Reader&lt;/code&gt; to read from * @param encoding the encoding to use, null means platform default * @return the requested byte array * @throws NullPointerException if the input is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static byte[] toByteArray(Reader input, String encoding) throws IOException &#123; ByteArrayOutputStream output = new ByteArrayOutputStream(); copy(input, output, encoding); return output.toByteArray(); &#125; /** * Get the contents of a &lt;code&gt;String&lt;/code&gt; as a &lt;code&gt;byte[]&lt;/code&gt; * using the default character encoding of the platform. * &lt;p&gt; * This is the same as &#123;@link String#getBytes()&#125;. * * @param input the &lt;code&gt;String&lt;/code&gt; to convert * @return the requested byte array * @throws NullPointerException if the input is null * @throws IOException if an I/O error occurs (never occurs) * @deprecated Use &#123;@link String#getBytes()&#125; */ public static byte[] toByteArray(String input) throws IOException &#123; return input.getBytes(); &#125; // read char[] //----------------------------------------------------------------------- /** * Get the contents of an &lt;code&gt;InputStream&lt;/code&gt; as a character array * using the default character encoding of the platform. * &lt;p&gt; * This method buffers the input internally, so there is no need to use a * &lt;code&gt;BufferedInputStream&lt;/code&gt;. * * @param is the &lt;code&gt;InputStream&lt;/code&gt; to read from * @return the requested character array * @throws NullPointerException if the input is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static char[] toCharArray(InputStream is) throws IOException &#123; CharArrayWriter output = new CharArrayWriter(); copy(is, output); return output.toCharArray(); &#125; /** * Get the contents of an &lt;code&gt;InputStream&lt;/code&gt; as a character array * using the specified character encoding. * &lt;p&gt; * Character encoding names can be found at * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;. * &lt;p&gt; * This method buffers the input internally, so there is no need to use a * &lt;code&gt;BufferedInputStream&lt;/code&gt;. * * @param is the &lt;code&gt;InputStream&lt;/code&gt; to read from * @param encoding the encoding to use, null means platform default * @return the requested character array * @throws NullPointerException if the input is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static char[] toCharArray(InputStream is, String encoding) throws IOException &#123; CharArrayWriter output = new CharArrayWriter(); copy(is, output, encoding); return output.toCharArray(); &#125; /** * Get the contents of a &lt;code&gt;Reader&lt;/code&gt; as a character array. * &lt;p&gt; * This method buffers the input internally, so there is no need to use a * &lt;code&gt;BufferedReader&lt;/code&gt;. * * @param input the &lt;code&gt;Reader&lt;/code&gt; to read from * @return the requested character array * @throws NullPointerException if the input is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static char[] toCharArray(Reader input) throws IOException &#123; CharArrayWriter sw = new CharArrayWriter(); copy(input, sw); return sw.toCharArray(); &#125; // read toString //----------------------------------------------------------------------- /** * Get the contents of an &lt;code&gt;InputStream&lt;/code&gt; as a String * using the default character encoding of the platform. * &lt;p&gt; * This method buffers the input internally, so there is no need to use a * &lt;code&gt;BufferedInputStream&lt;/code&gt;. * * @param input the &lt;code&gt;InputStream&lt;/code&gt; to read from * @return the requested String * @throws NullPointerException if the input is null * @throws IOException if an I/O error occurs */ public static String toString(InputStream input) throws IOException &#123; StringWriter sw = new StringWriter(); copy(input, sw); return sw.toString(); &#125; /** * Get the contents of an &lt;code&gt;InputStream&lt;/code&gt; as a String * using the specified character encoding. * &lt;p&gt; * Character encoding names can be found at * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;. * &lt;p&gt; * This method buffers the input internally, so there is no need to use a * &lt;code&gt;BufferedInputStream&lt;/code&gt;. * * @param input the &lt;code&gt;InputStream&lt;/code&gt; to read from * @param encoding the encoding to use, null means platform default * @return the requested String * @throws NullPointerException if the input is null * @throws IOException if an I/O error occurs */ public static String toString(InputStream input, String encoding) throws IOException &#123; StringWriter sw = new StringWriter(); copy(input, sw, encoding); return sw.toString(); &#125; /** * Get the contents of a &lt;code&gt;Reader&lt;/code&gt; as a String. * &lt;p&gt; * This method buffers the input internally, so there is no need to use a * &lt;code&gt;BufferedReader&lt;/code&gt;. * * @param input the &lt;code&gt;Reader&lt;/code&gt; to read from * @return the requested String * @throws NullPointerException if the input is null * @throws IOException if an I/O error occurs */ public static String toString(Reader input) throws IOException &#123; StringWriter sw = new StringWriter(); copy(input, sw); return sw.toString(); &#125; /** * Get the contents of a &lt;code&gt;byte[]&lt;/code&gt; as a String * using the default character encoding of the platform. * * @param input the byte array to read from * @return the requested String * @throws NullPointerException if the input is null * @throws IOException if an I/O error occurs (never occurs) * @deprecated Use &#123;@link String#String(byte[])&#125; */ public static String toString(byte[] input) throws IOException &#123; return new String(input); &#125; /** * Get the contents of a &lt;code&gt;byte[]&lt;/code&gt; as a String * using the specified character encoding. * &lt;p&gt; * Character encoding names can be found at * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;. * * @param input the byte array to read from * @param encoding the encoding to use, null means platform default * @return the requested String * @throws NullPointerException if the input is null * @throws IOException if an I/O error occurs (never occurs) * @deprecated Use &#123;@link String#String(byte[],String)&#125; */ public static String toString(byte[] input, String encoding) throws IOException &#123; if (encoding == null) &#123; return new String(input); &#125; else &#123; return new String(input, encoding); &#125; &#125; // readLines //----------------------------------------------------------------------- /** * Get the contents of an &lt;code&gt;InputStream&lt;/code&gt; as a list of Strings, * one entry per line, using the default character encoding of the platform. * &lt;p&gt; * This method buffers the input internally, so there is no need to use a * &lt;code&gt;BufferedInputStream&lt;/code&gt;. * * @param input the &lt;code&gt;InputStream&lt;/code&gt; to read from, not null * @return the list of Strings, never null * @throws NullPointerException if the input is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static List readLines(InputStream input) throws IOException &#123; InputStreamReader reader = new InputStreamReader(input); return readLines(reader); &#125; /** * Get the contents of an &lt;code&gt;InputStream&lt;/code&gt; as a list of Strings, * one entry per line, using the specified character encoding. * &lt;p&gt; * Character encoding names can be found at * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;. * &lt;p&gt; * This method buffers the input internally, so there is no need to use a * &lt;code&gt;BufferedInputStream&lt;/code&gt;. * * @param input the &lt;code&gt;InputStream&lt;/code&gt; to read from, not null * @param encoding the encoding to use, null means platform default * @return the list of Strings, never null * @throws NullPointerException if the input is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static List readLines(InputStream input, String encoding) throws IOException &#123; if (encoding == null) &#123; return readLines(input); &#125; else &#123; InputStreamReader reader = new InputStreamReader(input, encoding); return readLines(reader); &#125; &#125; /** * Get the contents of a &lt;code&gt;Reader&lt;/code&gt; as a list of Strings, * one entry per line. * &lt;p&gt; * This method buffers the input internally, so there is no need to use a * &lt;code&gt;BufferedReader&lt;/code&gt;. * * @param input the &lt;code&gt;Reader&lt;/code&gt; to read from, not null * @return the list of Strings, never null * @throws NullPointerException if the input is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static List readLines(Reader input) throws IOException &#123; BufferedReader reader = new BufferedReader(input); List list = new ArrayList(); String line = reader.readLine(); while (line != null) &#123; list.add(line); line = reader.readLine(); &#125; return list; &#125; // lineIterator //----------------------------------------------------------------------- /** * Return an Iterator for the lines in a &lt;code&gt;Reader&lt;/code&gt;. * &lt;p&gt; * &lt;code&gt;LineIterator&lt;/code&gt; holds a reference to the open * &lt;code&gt;Reader&lt;/code&gt; specified here. When you have finished with the * iterator you should close the reader to free internal resources. * This can be done by closing the reader directly, or by calling * &#123;@link LineIterator#close()&#125; or &#123;@link LineIterator#closeQuietly(LineIterator)&#125;. * &lt;p&gt; * The recommended usage pattern is: * &lt;pre&gt; * try &#123; * LineIterator it = IOUtils.lineIterator(reader); * while (it.hasNext()) &#123; * String line = it.nextLine(); * /// do something with line * &#125; * &#125; finally &#123; * IOUtils.closeQuietly(reader); * &#125; * &lt;/pre&gt; * * @param reader the &lt;code&gt;Reader&lt;/code&gt; to read from, not null * @return an Iterator of the lines in the reader, never null * @throws IllegalArgumentException if the reader is null * @since Commons IO 1.2 */ public static LineIterator lineIterator(Reader reader) &#123; return new LineIterator(reader); &#125; /** * Return an Iterator for the lines in an &lt;code&gt;InputStream&lt;/code&gt;, using * the character encoding specified (or default encoding if null). * &lt;p&gt; * &lt;code&gt;LineIterator&lt;/code&gt; holds a reference to the open * &lt;code&gt;InputStream&lt;/code&gt; specified here. When you have finished with * the iterator you should close the stream to free internal resources. * This can be done by closing the stream directly, or by calling * &#123;@link LineIterator#close()&#125; or &#123;@link LineIterator#closeQuietly(LineIterator)&#125;. * &lt;p&gt; * The recommended usage pattern is: * &lt;pre&gt; * try &#123; * LineIterator it = IOUtils.lineIterator(stream, &quot;UTF-8&quot;); * while (it.hasNext()) &#123; * String line = it.nextLine(); * /// do something with line * &#125; * &#125; finally &#123; * IOUtils.closeQuietly(stream); * &#125; * &lt;/pre&gt; * * @param input the &lt;code&gt;InputStream&lt;/code&gt; to read from, not null * @param encoding the encoding to use, null means platform default * @return an Iterator of the lines in the reader, never null * @throws IllegalArgumentException if the input is null * @throws IOException if an I/O error occurs, such as if the encoding is invalid * @since Commons IO 1.2 */ public static LineIterator lineIterator(InputStream input, String encoding) throws IOException &#123; Reader reader = null; if (encoding == null) &#123; reader = new InputStreamReader(input); &#125; else &#123; reader = new InputStreamReader(input, encoding); &#125; return new LineIterator(reader); &#125; //----------------------------------------------------------------------- /** * Convert the specified string to an input stream, encoded as bytes * using the default character encoding of the platform. * * @param input the string to convert * @return an input stream * @since Commons IO 1.1 */ public static InputStream toInputStream(String input) &#123; byte[] bytes = input.getBytes(); return new ByteArrayInputStream(bytes); &#125; /** * Convert the specified string to an input stream, encoded as bytes * using the specified character encoding. * &lt;p&gt; * Character encoding names can be found at * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;. * * @param input the string to convert * @param encoding the encoding to use, null means platform default * @throws IOException if the encoding is invalid * @return an input stream * @since Commons IO 1.1 */ public static InputStream toInputStream(String input, String encoding) throws IOException &#123; byte[] bytes = encoding != null ? input.getBytes(encoding) : input.getBytes(); return new ByteArrayInputStream(bytes); &#125; // write byte[] //----------------------------------------------------------------------- /** * Writes bytes from a &lt;code&gt;byte[]&lt;/code&gt; to an &lt;code&gt;OutputStream&lt;/code&gt;. * * @param data the byte array to write, do not modify during output, * null ignored * @param output the &lt;code&gt;OutputStream&lt;/code&gt; to write to * @throws NullPointerException if output is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static void write(byte[] data, OutputStream output) throws IOException &#123; if (data != null) &#123; output.write(data); &#125; &#125; /** * Writes bytes from a &lt;code&gt;byte[]&lt;/code&gt; to chars on a &lt;code&gt;Writer&lt;/code&gt; * using the default character encoding of the platform. * &lt;p&gt; * This method uses &#123;@link String#String(byte[])&#125;. * * @param data the byte array to write, do not modify during output, * null ignored * @param output the &lt;code&gt;Writer&lt;/code&gt; to write to * @throws NullPointerException if output is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static void write(byte[] data, Writer output) throws IOException &#123; if (data != null) &#123; output.write(new String(data)); &#125; &#125; /** * Writes bytes from a &lt;code&gt;byte[]&lt;/code&gt; to chars on a &lt;code&gt;Writer&lt;/code&gt; * using the specified character encoding. * &lt;p&gt; * Character encoding names can be found at * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;. * &lt;p&gt; * This method uses &#123;@link String#String(byte[], String)&#125;. * * @param data the byte array to write, do not modify during output, * null ignored * @param output the &lt;code&gt;Writer&lt;/code&gt; to write to * @param encoding the encoding to use, null means platform default * @throws NullPointerException if output is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static void write(byte[] data, Writer output, String encoding) throws IOException &#123; if (data != null) &#123; if (encoding == null) &#123; write(data, output); &#125; else &#123; output.write(new String(data, encoding)); &#125; &#125; &#125; // write char[] //----------------------------------------------------------------------- /** * Writes chars from a &lt;code&gt;char[]&lt;/code&gt; to a &lt;code&gt;Writer&lt;/code&gt; * using the default character encoding of the platform. * * @param data the char array to write, do not modify during output, * null ignored * @param output the &lt;code&gt;Writer&lt;/code&gt; to write to * @throws NullPointerException if output is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static void write(char[] data, Writer output) throws IOException &#123; if (data != null) &#123; output.write(data); &#125; &#125; /** * Writes chars from a &lt;code&gt;char[]&lt;/code&gt; to bytes on an * &lt;code&gt;OutputStream&lt;/code&gt;. * &lt;p&gt; * This method uses &#123;@link String#String(char[])&#125; and * &#123;@link String#getBytes()&#125;. * * @param data the char array to write, do not modify during output, * null ignored * @param output the &lt;code&gt;OutputStream&lt;/code&gt; to write to * @throws NullPointerException if output is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static void write(char[] data, OutputStream output) throws IOException &#123; if (data != null) &#123; output.write(new String(data).getBytes()); &#125; &#125; /** * Writes chars from a &lt;code&gt;char[]&lt;/code&gt; to bytes on an * &lt;code&gt;OutputStream&lt;/code&gt; using the specified character encoding. * &lt;p&gt; * Character encoding names can be found at * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;. * &lt;p&gt; * This method uses &#123;@link String#String(char[])&#125; and * &#123;@link String#getBytes(String)&#125;. * * @param data the char array to write, do not modify during output, * null ignored * @param output the &lt;code&gt;OutputStream&lt;/code&gt; to write to * @param encoding the encoding to use, null means platform default * @throws NullPointerException if output is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static void write(char[] data, OutputStream output, String encoding) throws IOException &#123; if (data != null) &#123; if (encoding == null) &#123; write(data, output); &#125; else &#123; output.write(new String(data).getBytes(encoding)); &#125; &#125; &#125; // write String //----------------------------------------------------------------------- /** * Writes chars from a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;Writer&lt;/code&gt;. * * @param data the &lt;code&gt;String&lt;/code&gt; to write, null ignored * @param output the &lt;code&gt;Writer&lt;/code&gt; to write to * @throws NullPointerException if output is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static void write(String data, Writer output) throws IOException &#123; if (data != null) &#123; output.write(data); &#125; &#125; /** * Writes chars from a &lt;code&gt;String&lt;/code&gt; to bytes on an * &lt;code&gt;OutputStream&lt;/code&gt; using the default character encoding of the * platform. * &lt;p&gt; * This method uses &#123;@link String#getBytes()&#125;. * * @param data the &lt;code&gt;String&lt;/code&gt; to write, null ignored * @param output the &lt;code&gt;OutputStream&lt;/code&gt; to write to * @throws NullPointerException if output is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static void write(String data, OutputStream output) throws IOException &#123; if (data != null) &#123; output.write(data.getBytes()); &#125; &#125; /** * Writes chars from a &lt;code&gt;String&lt;/code&gt; to bytes on an * &lt;code&gt;OutputStream&lt;/code&gt; using the specified character encoding. * &lt;p&gt; * Character encoding names can be found at * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;. * &lt;p&gt; * This method uses &#123;@link String#getBytes(String)&#125;. * * @param data the &lt;code&gt;String&lt;/code&gt; to write, null ignored * @param output the &lt;code&gt;OutputStream&lt;/code&gt; to write to * @param encoding the encoding to use, null means platform default * @throws NullPointerException if output is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static void write(String data, OutputStream output, String encoding) throws IOException &#123; if (data != null) &#123; if (encoding == null) &#123; write(data, output); &#125; else &#123; output.write(data.getBytes(encoding)); &#125; &#125; &#125; // write StringBuffer //----------------------------------------------------------------------- /** * Writes chars from a &lt;code&gt;StringBuffer&lt;/code&gt; to a &lt;code&gt;Writer&lt;/code&gt;. * * @param data the &lt;code&gt;StringBuffer&lt;/code&gt; to write, null ignored * @param output the &lt;code&gt;Writer&lt;/code&gt; to write to * @throws NullPointerException if output is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static void write(StringBuffer data, Writer output) throws IOException &#123; if (data != null) &#123; output.write(data.toString()); &#125; &#125; /** * Writes chars from a &lt;code&gt;StringBuffer&lt;/code&gt; to bytes on an * &lt;code&gt;OutputStream&lt;/code&gt; using the default character encoding of the * platform. * &lt;p&gt; * This method uses &#123;@link String#getBytes()&#125;. * * @param data the &lt;code&gt;StringBuffer&lt;/code&gt; to write, null ignored * @param output the &lt;code&gt;OutputStream&lt;/code&gt; to write to * @throws NullPointerException if output is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static void write(StringBuffer data, OutputStream output) throws IOException &#123; if (data != null) &#123; output.write(data.toString().getBytes()); &#125; &#125; /** * Writes chars from a &lt;code&gt;StringBuffer&lt;/code&gt; to bytes on an * &lt;code&gt;OutputStream&lt;/code&gt; using the specified character encoding. * &lt;p&gt; * Character encoding names can be found at * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;. * &lt;p&gt; * This method uses &#123;@link String#getBytes(String)&#125;. * * @param data the &lt;code&gt;StringBuffer&lt;/code&gt; to write, null ignored * @param output the &lt;code&gt;OutputStream&lt;/code&gt; to write to * @param encoding the encoding to use, null means platform default * @throws NullPointerException if output is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static void write(StringBuffer data, OutputStream output, String encoding) throws IOException &#123; if (data != null) &#123; if (encoding == null) &#123; write(data, output); &#125; else &#123; output.write(data.toString().getBytes(encoding)); &#125; &#125; &#125; // writeLines //----------------------------------------------------------------------- /** * Writes the &lt;code&gt;toString()&lt;/code&gt; value of each item in a collection to * an &lt;code&gt;OutputStream&lt;/code&gt; line by line, using the default character * encoding of the platform and the specified line ending. * * @param lines the lines to write, null entries produce blank lines * @param lineEnding the line separator to use, null is system default * @param output the &lt;code&gt;OutputStream&lt;/code&gt; to write to, not null, not closed * @throws NullPointerException if the output is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static void writeLines(Collection lines, String lineEnding, OutputStream output) throws IOException &#123; if (lines == null) &#123; return; &#125; if (lineEnding == null) &#123; lineEnding = LINE_SEPARATOR; &#125; for (Iterator it = lines.iterator(); it.hasNext(); ) &#123; Object line = it.next(); if (line != null) &#123; output.write(line.toString().getBytes()); &#125; output.write(lineEnding.getBytes()); &#125; &#125; /** * Writes the &lt;code&gt;toString()&lt;/code&gt; value of each item in a collection to * an &lt;code&gt;OutputStream&lt;/code&gt; line by line, using the specified character * encoding and the specified line ending. * &lt;p&gt; * Character encoding names can be found at * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;. * * @param lines the lines to write, null entries produce blank lines * @param lineEnding the line separator to use, null is system default * @param output the &lt;code&gt;OutputStream&lt;/code&gt; to write to, not null, not closed * @param encoding the encoding to use, null means platform default * @throws NullPointerException if the output is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static void writeLines(Collection lines, String lineEnding, OutputStream output, String encoding) throws IOException &#123; if (encoding == null) &#123; writeLines(lines, lineEnding, output); &#125; else &#123; if (lines == null) &#123; return; &#125; if (lineEnding == null) &#123; lineEnding = LINE_SEPARATOR; &#125; for (Iterator it = lines.iterator(); it.hasNext(); ) &#123; Object line = it.next(); if (line != null) &#123; output.write(line.toString().getBytes(encoding)); &#125; output.write(lineEnding.getBytes(encoding)); &#125; &#125; &#125; /** * Writes the &lt;code&gt;toString()&lt;/code&gt; value of each item in a collection to * a &lt;code&gt;Writer&lt;/code&gt; line by line, using the specified line ending. * * @param lines the lines to write, null entries produce blank lines * @param lineEnding the line separator to use, null is system default * @param writer the &lt;code&gt;Writer&lt;/code&gt; to write to, not null, not closed * @throws NullPointerException if the input is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static void writeLines(Collection lines, String lineEnding, Writer writer) throws IOException &#123; if (lines == null) &#123; return; &#125; if (lineEnding == null) &#123; lineEnding = LINE_SEPARATOR; &#125; for (Iterator it = lines.iterator(); it.hasNext(); ) &#123; Object line = it.next(); if (line != null) &#123; writer.write(line.toString()); &#125; writer.write(lineEnding); &#125; &#125; // copy from InputStream //----------------------------------------------------------------------- /** * Copy bytes from an &lt;code&gt;InputStream&lt;/code&gt; to an * &lt;code&gt;OutputStream&lt;/code&gt;. * &lt;p&gt; * This method buffers the input internally, so there is no need to use a * &lt;code&gt;BufferedInputStream&lt;/code&gt;. * &lt;p&gt; * Large streams (over 2GB) will return a bytes copied value of * &lt;code&gt;-1&lt;/code&gt; after the copy has completed since the correct * number of bytes cannot be returned as an int. For large streams * use the &lt;code&gt;copyLarge(InputStream, OutputStream)&lt;/code&gt; method. * * @param input the &lt;code&gt;InputStream&lt;/code&gt; to read from * @param output the &lt;code&gt;OutputStream&lt;/code&gt; to write to * @return the number of bytes copied * @throws NullPointerException if the input or output is null * @throws IOException if an I/O error occurs * @throws ArithmeticException if the byte count is too large * @since Commons IO 1.1 */ public static int copy(InputStream input, OutputStream output) throws IOException &#123; long count = copyLarge(input, output); if (count &gt; Integer.MAX_VALUE) &#123; return -1; &#125; return (int) count; &#125; /** * Copy bytes from a large (over 2GB) &lt;code&gt;InputStream&lt;/code&gt; to an * &lt;code&gt;OutputStream&lt;/code&gt;. * &lt;p&gt; * This method buffers the input internally, so there is no need to use a * &lt;code&gt;BufferedInputStream&lt;/code&gt;. * * @param input the &lt;code&gt;InputStream&lt;/code&gt; to read from * @param output the &lt;code&gt;OutputStream&lt;/code&gt; to write to * @return the number of bytes copied * @throws NullPointerException if the input or output is null * @throws IOException if an I/O error occurs * @since Commons IO 1.3 */ public static long copyLarge(InputStream input, OutputStream output) throws IOException &#123; byte[] buffer = new byte[DEFAULT_BUFFER_SIZE]; long count = 0; int n = 0; while (-1 != (n = input.read(buffer))) &#123; output.write(buffer, 0, n); count += n; &#125; return count; &#125; /** * Copy bytes from an &lt;code&gt;InputStream&lt;/code&gt; to chars on a * &lt;code&gt;Writer&lt;/code&gt; using the default character encoding of the platform. * &lt;p&gt; * This method buffers the input internally, so there is no need to use a * &lt;code&gt;BufferedInputStream&lt;/code&gt;. * &lt;p&gt; * This method uses &#123;@link InputStreamReader&#125;. * * @param input the &lt;code&gt;InputStream&lt;/code&gt; to read from * @param output the &lt;code&gt;Writer&lt;/code&gt; to write to * @throws NullPointerException if the input or output is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static void copy(InputStream input, Writer output) throws IOException &#123; InputStreamReader in = new InputStreamReader(input); copy(in, output); &#125; /** * Copy bytes from an &lt;code&gt;InputStream&lt;/code&gt; to chars on a * &lt;code&gt;Writer&lt;/code&gt; using the specified character encoding. * &lt;p&gt; * This method buffers the input internally, so there is no need to use a * &lt;code&gt;BufferedInputStream&lt;/code&gt;. * &lt;p&gt; * Character encoding names can be found at * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;. * &lt;p&gt; * This method uses &#123;@link InputStreamReader&#125;. * * @param input the &lt;code&gt;InputStream&lt;/code&gt; to read from * @param output the &lt;code&gt;Writer&lt;/code&gt; to write to * @param encoding the encoding to use, null means platform default * @throws NullPointerException if the input or output is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static void copy(InputStream input, Writer output, String encoding) throws IOException &#123; if (encoding == null) &#123; copy(input, output); &#125; else &#123; InputStreamReader in = new InputStreamReader(input, encoding); copy(in, output); &#125; &#125; // copy from Reader //----------------------------------------------------------------------- /** * Copy chars from a &lt;code&gt;Reader&lt;/code&gt; to a &lt;code&gt;Writer&lt;/code&gt;. * &lt;p&gt; * This method buffers the input internally, so there is no need to use a * &lt;code&gt;BufferedReader&lt;/code&gt;. * &lt;p&gt; * Large streams (over 2GB) will return a chars copied value of * &lt;code&gt;-1&lt;/code&gt; after the copy has completed since the correct * number of chars cannot be returned as an int. For large streams * use the &lt;code&gt;copyLarge(Reader, Writer)&lt;/code&gt; method. * * @param input the &lt;code&gt;Reader&lt;/code&gt; to read from * @param output the &lt;code&gt;Writer&lt;/code&gt; to write to * @return the number of characters copied * @throws NullPointerException if the input or output is null * @throws IOException if an I/O error occurs * @throws ArithmeticException if the character count is too large * @since Commons IO 1.1 */ public static int copy(Reader input, Writer output) throws IOException &#123; long count = copyLarge(input, output); if (count &gt; Integer.MAX_VALUE) &#123; return -1; &#125; return (int) count; &#125; /** * Copy chars from a large (over 2GB) &lt;code&gt;Reader&lt;/code&gt; to a &lt;code&gt;Writer&lt;/code&gt;. * &lt;p&gt; * This method buffers the input internally, so there is no need to use a * &lt;code&gt;BufferedReader&lt;/code&gt;. * * @param input the &lt;code&gt;Reader&lt;/code&gt; to read from * @param output the &lt;code&gt;Writer&lt;/code&gt; to write to * @return the number of characters copied * @throws NullPointerException if the input or output is null * @throws IOException if an I/O error occurs * @since Commons IO 1.3 */ public static long copyLarge(Reader input, Writer output) throws IOException &#123; char[] buffer = new char[DEFAULT_BUFFER_SIZE]; long count = 0; int n = 0; while (-1 != (n = input.read(buffer))) &#123; output.write(buffer, 0, n); count += n; &#125; return count; &#125; /** * Copy chars from a &lt;code&gt;Reader&lt;/code&gt; to bytes on an * &lt;code&gt;OutputStream&lt;/code&gt; using the default character encoding of the * platform, and calling flush. * &lt;p&gt; * This method buffers the input internally, so there is no need to use a * &lt;code&gt;BufferedReader&lt;/code&gt;. * &lt;p&gt; * Due to the implementation of OutputStreamWriter, this method performs a * flush. * &lt;p&gt; * This method uses &#123;@link OutputStreamWriter&#125;. * * @param input the &lt;code&gt;Reader&lt;/code&gt; to read from * @param output the &lt;code&gt;OutputStream&lt;/code&gt; to write to * @throws NullPointerException if the input or output is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static void copy(Reader input, OutputStream output) throws IOException &#123; OutputStreamWriter out = new OutputStreamWriter(output); copy(input, out); // XXX Unless anyone is planning on rewriting OutputStreamWriter, we // have to flush here. out.flush(); &#125; /** * Copy chars from a &lt;code&gt;Reader&lt;/code&gt; to bytes on an * &lt;code&gt;OutputStream&lt;/code&gt; using the specified character encoding, and * calling flush. * &lt;p&gt; * This method buffers the input internally, so there is no need to use a * &lt;code&gt;BufferedReader&lt;/code&gt;. * &lt;p&gt; * Character encoding names can be found at * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;. * &lt;p&gt; * Due to the implementation of OutputStreamWriter, this method performs a * flush. * &lt;p&gt; * This method uses &#123;@link OutputStreamWriter&#125;. * * @param input the &lt;code&gt;Reader&lt;/code&gt; to read from * @param output the &lt;code&gt;OutputStream&lt;/code&gt; to write to * @param encoding the encoding to use, null means platform default * @throws NullPointerException if the input or output is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static void copy(Reader input, OutputStream output, String encoding) throws IOException &#123; if (encoding == null) &#123; copy(input, output); &#125; else &#123; OutputStreamWriter out = new OutputStreamWriter(output, encoding); copy(input, out); // XXX Unless anyone is planning on rewriting OutputStreamWriter, // we have to flush here. out.flush(); &#125; &#125; // content equals //----------------------------------------------------------------------- /** * Compare the contents of two Streams to determine if they are equal or * not. * &lt;p&gt; * This method buffers the input internally using * &lt;code&gt;BufferedInputStream&lt;/code&gt; if they are not already buffered. * * @param input1 the first stream * @param input2 the second stream * @return true if the content of the streams are equal or they both don&apos;t * exist, false otherwise * @throws NullPointerException if either input is null * @throws IOException if an I/O error occurs */ public static boolean contentEquals(InputStream input1, InputStream input2) throws IOException &#123; if (!(input1 instanceof BufferedInputStream)) &#123; input1 = new BufferedInputStream(input1); &#125; if (!(input2 instanceof BufferedInputStream)) &#123; input2 = new BufferedInputStream(input2); &#125; int ch = input1.read(); while (-1 != ch) &#123; int ch2 = input2.read(); if (ch != ch2) &#123; return false; &#125; ch = input1.read(); &#125; int ch2 = input2.read(); return (ch2 == -1); &#125; /** * Compare the contents of two Readers to determine if they are equal or * not. * &lt;p&gt; * This method buffers the input internally using * &lt;code&gt;BufferedReader&lt;/code&gt; if they are not already buffered. * * @param input1 the first reader * @param input2 the second reader * @return true if the content of the readers are equal or they both don&apos;t * exist, false otherwise * @throws NullPointerException if either input is null * @throws IOException if an I/O error occurs * @since Commons IO 1.1 */ public static boolean contentEquals(Reader input1, Reader input2) throws IOException &#123; if (!(input1 instanceof BufferedReader)) &#123; input1 = new BufferedReader(input1); &#125; if (!(input2 instanceof BufferedReader)) &#123; input2 = new BufferedReader(input2); &#125; int ch = input1.read(); while (-1 != ch) &#123; int ch2 = input2.read(); if (ch != ch2) &#123; return false; &#125; ch = input1.read(); &#125; int ch2 = input2.read(); return (ch2 == -1); &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java IO Stream]]></title>
    <url>%2F1900%2F01%2F03%2F00JAVA%2F03%20Java%20IO%20Stream%2F</url>
    <content type="text"><![CDATA[参考链接：Java IO流详解最完整的javaIO流总结Java IO流详解 一、IO 流概述 流（Stream）的概念源于 UNIX 中管道（pipe）的概念。在 UNIX中，管道是一条不间断的字节流，用来实现程序或进程间的通信，或读写外围设备、外部文件等。一个流，必有源端和目的端，它们可以是计算机内存的某些区域，也可以是磁盘文件，甚至可以是Internet上的某个URL。实际上，流的源端和目的端可简单地看成是字节的生产者和消费者，对输入流，可不必关心它的源端是什么，只要简单地从流中读数据，而对输出流，也可不知道它的目的端，只是简单地往流中写数据。 定义流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 分类 根据数据流向不同分为：输入流和输出流。注意输入流和输出流是相对于程序而言的。把程序（内存）中的内容输出到磁盘、光盘等存储设备中是为输出；读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。 根据处理数据类型分为：字符流和字节流。数据流中最小的数据单元是字节的流为字节流；数据流中最小的数据单元是字符的流为字符流。Java 中的字符是 Unicode 编码，一个字符占用两个字节（无论中文还是英文都是两个字节）。 根据功能不同分为：节点流和包装流。1）节点流：可以从或向一个特定的地方(节点)读写数据，直接连接数据源。如最常见的是文件的 FileReader，还可以是数组、管道、字符串，关键字分别为 ByteArray/CharArray，Piped，String。2）处理流（包装流）：并不直接连接数据源，是对一个已存在的流的连接和封装，是一种典型的装饰器设计模式，使用处理流主要是为了更方便的执行输入输出工作，如PrintStream，输出功能很强大，又如BufferedReader提供缓存机制，推荐输出时都使用处理流包装。 注意：一个 IO 流可以即是输入流又是字节流又或是以其他方式分类的流类型，是不冲突的。比如 FileInputStream，它既是输入流又是字节流还是文件节点流。 一些特别的的流类型1）转换流：转换流只有字节流转换为字符流，因为字符流使用起来更方便，我们只会向更方便使用的方向转化。如：InputStreamReader 与 OutputStreamWriter。2）缓冲流：有关键字 Buffered，也是一种处理流，为其包装的流增加了缓存功能，提高了输入输出的效率，增加缓冲功能后需要使用 flush() 才能将缓冲区中内容写入到实际的物理节点。但是，在现在版本的 Java 中，只需记得关闭输出流（调用 close() 方法），就会自动执行输出流的 flush() 方法，可以保证将缓冲区中内容写入。3）对象流：有关键字Object，主要用于将目标对象保存到磁盘中或允许在网络中直接传输对象时使用（对象序列化）。 操作 IO 流的模板第一步：创建源或目标对象输入：把文件中的数据流向到程序中，此时文件是源，程序是目标；输出：把程序中的数据流向到文件中，此时文件是目标，程序是源。 第二步：创建 IO 流对象输入：创建输入流对象；输出：创建输出流对象； 第三步：具体的 IO 操作 第四步：关闭资源输入：输入流的 close() 方法；输出：输出流的 close() 方法。 复制文件示例代码：12345678910111213141516171819public static void copy(File srcFile, File dstFile) &#123; FileInputStream in = null; FileOutputStream out = null; try &#123; // 第一、二步 in = new FileInputStream(srcFile); out = new FileOutputStream(dstFile); // 第三步 int b; while ((b = in.read()) != -1) &#123; out.write(b); &#125; &#125; catch(IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 第四步 CloseUtils.closeIO(in, out); &#125;&#125; 注意：程序中打开的文件 IO 资源不属于内存里的资源，垃圾回收机制无法回收该资源。如果不关闭该资源，那么磁盘的文件将一直被程序引用着，不能删除也不能更改，所以应该手动调用 close() 方法关闭流资源。 二、整体架构 JAVA 流操作相关的类和接口 类 说明 File 文件类 RandomAccessFile 随机存取文件类 InputStream 字节输入流 OutStream 字节输出流 Reader 字符输入流 Writer 字符输出流 Java IO 流的整体架构 从图中可以看出四大基类流，如下表所示。这四大基流都是抽象类，其他流都是继承于这四大基流的。 字节流 字符流 输入流 InputStream Reader 输出流 OutStream Writer 用法分析 按数据来源（去向）使用是文件： FileInputStream, FileOutputStream, FileReader, FileWriter是 byte[]：ByteArrayInputStream, ByteArrayOutputStream是 char[]：CharArrayReader, CharArrayWriter是 String：StringBufferInputStream, StringReader, StringWriter网络数据流：InputStream, OutputStream, Reader, Writer 按是否格式化输出使用要格式化输出：PrintStream, PrintWriter 按是否要缓冲使用要缓冲：BufferedInputStream, BufferedOutputStream, BufferedReader, BufferedWriter。 按数据格式使用二进制格式（只要不能确定是纯文本的）: InputStream, OutputStream 及其所有带 Stream 结尾的子类；纯文本格式（含纯英文与汉字或其他编码方式）；Reader, Writer 及其所有带 eader, Writer 的子类 。 按输入输出使用输入：Reader, InputStream 类型的子类；输出：Writer, OutputStream 类型的子类。 特殊需要从 Stream 到 Reader、Writer 的转换类：InputStreamReader, OutputStreamWriter；对象输入输出：ObjectInputStream, ObjectOutputStream；进程间通信：PipeInputStream, PipeOutputStream, PipeReader, PipeWriter ；合并输入：SequenceInputStream；更特殊的需要：PushbackInputStream, PushbackReader, LineNumberInputStream, LineNumberReader。 虽然四大基类流的实现类很多，功能繁杂，但是他们的命名非常有规律，可以“顾名思义”。如字节流的输入与输出的对应： 图中蓝色的为主要的对应部分，红色的部分就是不对应部分。紫色的虚线部分代表这些流一般要搭配使用。 三、IO 流文件操作 读取文件内容：12345678910111213public void test() throws IOException &#123; String fileName = &quot;D:&quot;+File.separator+&quot;hello.txt&quot;; File f = new File(fileName); InputStream in = new FileInputStream(f); byte[] b = new byte[1024]; int count = 0; int temp; while((temp = in.read()) != -1)&#123; b[count++] = (byte)temp; &#125; in.close(); System.out.println(new String(b));&#125; 向文件中写入字符串：123456789public void test() throws IOException &#123; String fileName = &quot;D:&quot; + File.separator + &quot;hello.txt&quot;; File file = new File(fileName); OutputStream out =new FileOutputStream(file); String str = &quot;你好&quot;; byte[] bytes = str.getBytes(); out.write(bytes); out.close();&#125; 向文件中追加新内容：123456789101112public void test() throws IOException &#123; String fileName = &quot;D:&quot; + File.separator + &quot;hello.txt&quot;; File f = new File(fileName); OutputStream out = new FileOutputStream(f,true); String str = &quot;Xian&quot;; // String str = &quot;\r\nXian&quot;; // 可以换行 byte[] b = str.getBytes(); for (int i = 0; i &lt; b.length; i++) &#123; out.write(b[i]); &#125; out.close();&#125; 使用 RandomAccessFile 写入文件：123456789101112public void test() throws IOException &#123; String fileName = &quot;D:&quot;+File.separator+&quot;hello.txt&quot;; File f = new File(fileName); RandomAccessFile raf = new RandomAccessFile(f,&quot;rw&quot;); raf.writeBytes(&quot;xian&quot;); raf.writeInt(12); raf.writeBoolean(true); raf.writeChar(&apos;A&apos;); raf.writeFloat(1.21f); raf.writeDouble(12.123); raf.close();&#125; 四、字节流 InputStreamInputStream 是所有字节输入流的父类，是一个抽象类。 子类： ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从 Byte 数组、StringBuffer 和本地文件中读取数据。PipedInputStream 是从与其它线程共用的管道中读取数据。ObjectInputStream 和所有 FilterInputStream 的子类都是装饰流（装饰器模式的主角）。 方法：123456789101112131415161718// 返回此输入流下一个方法调用可以不受阻塞地从此输入流读取（或跳过）的估计字节数。int available() // 关闭此输入流并释放与该流关联的所有系统资源。void close() // 在此输入流中标记当前的位置。void mark(int readLimit) // 测试此输入流是否支持 mark 和 reset 方法。boolean markSupported() // 从输入流中读取数据的下一个字节。abstract int read() // 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。int read(byte[] b) // 将输入流中最多 len 个数据字节读入 byte 数组。int read(byte[] b, int off, int len) // 将此流重新定位到最后一次对此输入流调用 mark 方法时的位置。void reset() // 跳过和丢弃此输入流中数据的 n 个字节。long skip(long n) 示例：12345678910111213public void test() throws Exception &#123; // 异常抛出，不处理 // 第1步、使用File类找到一个文件 File f = new File(&quot;d:&quot; + File.separator + &quot;test.txt&quot;) ; // 第2步、通过子类实例化父类对象 InputStream input = null ; // 准备好一个输入的对象 input = new FileInputStream(f); // 通过对象多态性，进行实例化 // 第3步、进行读操作 byte b[] = new byte[1024] ; // 所有的内容都读到此数组之中 input.read(b) ; // 读取内容 网络编程中 read 方法会阻塞 // 第4步、关闭输出流 input.close() ; // 关闭输出流 System.out.println(new String(b)); // 把 byte 数组变为字符串输出&#125; OutputStreamOutputStream 是所有的输出字节流的父类，它是一个抽象类。 子类：（1）OutputStream是以字节为单位的输出流的超类，提供了write()函数从输出流中读取字节数据。（2）ByteArrayOutputStream是字节数组输出流，写入ByteArrayOutputStream的数据被写入到一个byte数组，缓冲区会随着数据的不断写入而自动增长，可使用toByteArray()和toString()获取数据。（3）PipedOutputStream是管道输出流，和PipedInputStream一起使用，能实现多线程间的管道通信。（4）FilterOutputStream是过滤输出流，是DataOutputStream，BufferedOutputStream和PrintStream的超类（5）DataOutputStream是数据输出流，用来装饰其他的输出流，允许应用程序以与机器无关方式向底层写入基本Java数据类型。（6）BufferedOutputStream是缓冲输出流，它的作用是为另一个输出流添加缓冲功能。（7）PrintStream是打印输出流，用来装饰其他输出流，为其他输出流添加功能，方便的打印各种数据值（8）FileOutputStream是文件输出流，通常用于向文件进行写入操作。（9）ObjectOutputStream是对象输出流，它和ObjectInputStream一起对基本数据或者对象的持久存储。 方法：12345678910111213// Writes the specified byte to this output stream.public abstract void write(int b) throws IOException// Writes b.length bytes from the specified byte array to this output stream.public void write(byte[] data) throws IOException// Writes length bytes from the specified byte array starting at offset // off to this output stream.public void write(byte[] data, int offset, int length) throws IOException// Flushes this output stream and forces any buffered output bytes// to be written out.public void flush() throws IOException// Closes this output stream and releases any system resources // associated with this stream.public void close() throws IOException 示例：1234567891011121314public void test() throws Exception &#123; // 异常抛出，不处理 // 第1步、使用File类找到一个文件 File f = new File(&quot;d:&quot; + File.separator + &quot;test.txt&quot;); // 第2步、通过子类实例化父类对象 OutputStream out = null ; // 准备好一个输出的对象 out = new FileOutputStream(f); // 通过对象多态性，进行实例化 // 第3步、进行写操作 String str = &quot;Hello World!!!&quot;; // 准备一个字符串 byte b[] = str.getBytes() ; // 只能输出byte数组，将字符串变为byte数组 out.write(b) ; // 将内容输出，保存文件 // 第4步、关闭输出流 out.close() ; // 关闭输出流 // 文件不存在会自动创建&#125; 示例：复制文件内容123456789101112131415161718192021222324/** * 将 a.txt 文件 复制到 b.txt 中 */public void copy() throws IOException &#123; // 1、创建源和目标 File srcFile = new File(&quot;io&quot;+File.separator+&quot;a.txt&quot;); File descFile = new File(&quot;io&quot;+File.separator+&quot;b.txt&quot;); // 2、创建输入输出流对象 InputStream in = new FileInputStream(srcFile); OutputStream out = new FileOutputStream(descFile); // 3、读取和写入操作 byte[] buffer = new byte[1024]; // 表示已经读取了多少个字节，-1 表示已经读取到文件的末尾 int len = -1; while((len = in.read(buffer))!= -1) &#123; // 打印读取的数据 System.out.println(new String(buffer,0,len)); // 将 buffer 数组中从 0 开始，长度为 len 的数据读取到 b.txt 文件中 out.write(buffer, 0, len); &#125; // 4、关闭流资源 out.close(); in.close();&#125; 五、字符流 使用字节流操作汉字或特殊符号语言的时候容易乱码，因为汉字不止一个字节，为了解决这个问题，建议使用字符流。一般可以用记事本打开的文件，我们可以看到内容不乱码的。就是文本文件，可以使用字符流。而操作二进制文件（比如图片、音频、视频）必须使用字节流。 ReaderReader 是所有的输入字符流的父类，它是一个抽象类。 子类：CharReader、StringReader 是两种基本的介质流，它们分别将Char 数组、String中读取数据。PipedReader 是从与其它线程共用的管道中读取数据。BufferedReader 很明显就是一个装饰器，它和其子类负责装饰其它Reader 对象。FilterReader 是所有自定义具体装饰流的父类，其子类PushbackReader 对Reader 对象进行装饰，会增加一个行号。InputStreamReader 是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。FileReader 可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将 FileInputStream 转变为 Reader 的方法。我们可以从这个类中得到一定的技巧。 Reader 中各个类的用途和使用方法基本和 InputStream 中的类使用一致。 方法：1234567891011121314151617181920// 关闭该流并释放与之关联的所有资源。abstract void close() // 标记流中的当前位置。void mark(int readAheadLimit) // 判断此流是否支持 mark() 操作。boolean markSupported() // 读取单个字符。int read()// 将字符读入数组。int read(char[] cbuf)// 将字符读入数组的某一部分。abstract int read(char[] cbuf, int off, int len) // 试图将字符读入指定的字符缓冲区。int read(CharBuffer target) // 判断是否准备读取此流。boolean ready() // 重置该流。void reset() // 跳过字符。long skip(long n) 示例：123456789101112public void test() throws IOException &#123; //创建一个文件读取流对象，和指定名称的文件相关联起来。 //要保证该文件是已经存在的。如果不存在，会发生异常，即FileNotFoundException FileReader reader = new FileReader(&quot;F:\\myFile\\test.txt&quot;); //调用读取流对象的read方法。 //read方法：一次读取一次字符，而且会自动往后面读取字符。 int ch = 0; while((ch = reader.read()) != -1) &#123; System.out.print((char)ch); &#125; fr.close();&#125; WriterWriter 是所有的输出字符流的父类，它是一个抽象类。 子类：CharArrayWriter、StringWriter 是两种基本的介质流，它们分别向Char 数组、String 中写入数据。PipedWriter 是向与其它线程共用的管道中写入数据，BufferedWriter 是一个装饰器为 Writer 提供缓冲功能。PrintWriter 和 PrintStream 极其类似，功能和使用也非常相似。OutputStreamWriter 是 OutputStream 到 Writer 转换的桥梁，它的子类 FileWriter，功能和使用和 OutputStream 极其类似。 方法：1234567891011121314151617181920// 将指定字符添加到此 writer。Writer append(char c) // 将指定字符序列添加到此 writer。Writer append(CharSequence csq) // 将指定字符序列的子序列添加到此 writer.Appendable。Writer append(CharSequence csq, int start, int end) // 关闭此流，但要先刷新它。abstract void close() // 刷新该流的缓冲。abstract void flush() // 写入字符数组。void write(char[] cbuf) // 写入字符数组的某一部分。abstract void write(char[] cbuf, int off, int len) // 写入单个字符。void write(int c) // 写入字符串。void write(String str) // 写入字符串的某一部分。void write(String str, int off, int len) 示例代码：123456789101112public void test() throws IOException &#123; // 第1步、使用File类找到一个文件 File f = new File(&quot;d:&quot; + File.separator + &quot;test.txt&quot;); // 第2步、通过子类实例化父类对象 Writer out = null; // 准备好一个输出的对象 out = new FileWriter(f); // 通过对象多态性，进行实例化 // 第3步、进行写操作 String str = &quot;Hello World!!!&quot;; // 准备一个字符串 out.write(str) ; // 将内容输出，保存文件 // 第4步、关闭输出流 out.close() ; // 关闭输出流&#125; 示例用字符流完成文件的复制。123456789101112131415161718192021/** * 将 a.txt 文件 复制到 b.txt 中 */public void copy() throws IOException &#123; // 1、创建源和目标 File srcFile = new File(&quot;io&quot;+File.separator+&quot;a.txt&quot;); File descFile = new File(&quot;io&quot;+File.separator+&quot;b.txt&quot;); // 2、创建字符输入输出流对象 Reader in = new FileReader(srcFile); Writer out = new FileWriter(descFile); // 3、读取和写入操作 char[] buffer = new char[1024]; // 表示已经读取了多少个字节，-1 表示已经读取到文件的末尾 int len; while((len=in.read(buffer))!=-1)&#123; out.write(buffer, 0, len); &#125; // 4、关闭流资源 out.close(); in.close();&#125; 六、包装流 包含缓冲流，转换流对象流等等。①、包装流隐藏了底层节点流的差异，并对外提供了更方便的输入\输出功能，让我们只关心这个高级流的操作。②、使用包装流包装了节点流，程序直接操作包装流，而底层还是节点流和IO设备操作。③、关闭包装流的时候，只需要关闭包装流即可。 缓冲流缓冲流：是一个包装流，目的是缓存作用，加快读取和写入数据的速度。字节缓冲流：BufferedInputStream、BufferedOutputStream字符缓冲流：BufferedReader、BufferedWriter 示例：1234567891011121314151617181920public void test() throws Exception &#123; //字节缓冲输入流 BufferedInputStream bis = new BufferedInputStream( new FileInputStream(&quot;io&quot;+File.separator+&quot;a.txt&quot;)); //定义一个字节数组，用来存储数据 byte[] buffer = new byte[1024]; //定义一个整数，表示读取的字节数 int len = -1; while((len=bis.read(buffer))!=-1)&#123; System.out.println(new String(buffer,0,len)); &#125; //关闭流资源 bis.close(); //字节缓冲输出流 BufferedOutputStream bos = new BufferedOutputStream( new FileOutputStream(&quot;io&quot;+File.separator+&quot;a.txt&quot;)); bos.write(&quot;Hello，先小涛&quot;.getBytes()); bos.close();&#125; 字符缓冲流使用与字节缓冲流非常像，直接替换上例中对应的类即可。 转换流把字节流转换为字符流。InputStreamReader：把字节输入流转换为字符输入流OutputStreamWriter：把字节输出流转换为字符输出流 示例：用转换流进行文件的复制1234567891011121314151617181920public void copy() throws IOException &#123; //1、创建源和目标 File srcFile = new File(&quot;io&quot;+File.separator+&quot;a.txt&quot;); File descFile = new File(&quot;io&quot;+File.separator+&quot;b.txt&quot;); //2、创建字节输入输出流对象 InputStream in = new FileInputStream(srcFile); OutputStream out = new FileOutputStream(descFile); //3、创建转换输入输出对象 Reader rd = new InputStreamReader(in); Writer wt = new OutputStreamWriter(out); //3、读取和写入操作 char[] buffer = new char[1024]; int len = -1; while((len=rd.read(buffer))!=-1)&#123; wt.write(buffer, 0, len); &#125; //4、关闭流资源 rd.close(); wt.close();&#125; OutputStreamWriter 和 InputStreamReader 是字符和字节的桥梁：也可以称之为字符转换流。字符转换流原理：字节流+编码表。 FileWriter 和 FileReader：作为子类，仅作为操作字符文件的便捷类存在。当操作的字符文件，使用的是默认编码表时可以不用父类，而直接用子类就完成操作了，简化了代码。 123456//默认字符集。InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;a.txt&quot;));//指定GBK字符集。InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;a.txt&quot;),&quot;GBK&quot;);FileReader fr = new FileReader(&quot;a.txt&quot;); 这三句代码的功能是一样的，其中第三句最为便捷。 注意：一旦要指定其他编码时，绝对不能用子类，必须使用字符转换流。 内存流把数据先临时存在数组中，也就是内存中。所以关闭内存流是无效的，关闭后还是可以调用这个类的方法。底层源码的 close() 是一个空方法。 字节内存流：ByteArrayOutputStream 、ByteArrayInputStream字符内存流：CharArrayReader、CharArrayWriter字符串流：StringReader,StringWriter（把数据临时存储到字符串中） 示例：1234567891011121314151617181920212223public void test() throws Exception &#123; // 字节数组输出流：程序---》内存 ByteArrayOutputStream bos = new ByteArrayOutputStream(); // 将数据写入到内存中 bos.write(&quot;hello&quot;.getBytes()); // 创建一个新分配的字节数组。 其大小是此输出流的当前大小， // 缓冲区的有效内容已被复制到其中。 byte[] temp = bos.toByteArray(); System.out.println(new String(temp,0,temp.length)); byte[] buffer = new byte[10]; // 字节数组输入流：内存---》程序 ByteArrayInputStream bis = new ByteArrayInputStream(temp); int len = -1; while((len=bis.read(buffer))!=-1)&#123; System.out.println(new String(buffer,0,len)); &#125; // 这里不写也没事，因为源码中的 close()是一个空的方法体 bos.close(); bis.close();&#125; 合并流把多个输入流合并为一个流，也叫顺序流，因为在读取的时候是先读第一个，读完了在读下面一个流。12345678910111213public void test() throws Exception &#123; //定义字节输入合并流 SequenceInputStream seinput = new SequenceInputStream( new FileInputStream(&quot;io/a.txt&quot;), new FileInputStream(&quot;io/b.txt&quot;)); byte[] buffer = new byte[10]; int len = -1; while((len=seinput.read(buffer)) != -1)&#123; System.out.println(new String(buffer,0,len)); &#125; seinput.close();&#125; 七、序列化与反序列化（对象流）what序列化：指把堆内存中的 Java 对象数据，通过某种方式把对象存储到磁盘文件中或者传递给其他网络节点（在网络上传输）。这个过程称为序列化。通俗来说就是将数据结构或对象转换成二进制串的过程。反序列化：把磁盘文件中的对象数据或者把网络节点上的对象数据，恢复成Java对象模型的过程。也就是将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。 why①、在分布式系统中，此时需要把对象在网络上传输，就得把对象数据转换为二进制形式，需要共享的数据的 JavaBean 对象，都得做序列化。②、服务器钝化：如果服务器发现某些对象好久没活动了，那么服务器就会把这些内存中的对象持久化在本地磁盘文件中（Java对象转换为二进制文件）；如果服务器发现某些对象需要活动时，先去内存中寻找，找不到再去磁盘文件中反序列化我们的对象数据，恢复成 Java 对象。这样能节省服务器内存。 how①、需要做序列化的对象的类，必须实现序列化接口：Java.lang.Serializable 接口（这是一个标志接口，没有任何抽象方法），Java 中大多数类都实现了该接口，比如：String，Integer。②、底层会判断，如果当前对象是 Serializable 的实例，才允许做序列化，Java对象 instanceof Serializable 来判断。③、在 Java 中使用对象流来完成序列化和反序列化。ObjectOutputStream：通过 writeObject()方法做序列化操作ObjectInputStream：通过 readObject() 方法做反序列化操作 demo第一步：创建一个 JavaBean 对象12345678910111213141516171819202122232425public class Person implements Serializable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125;&#125; 第二步：使用 ObjectOutputStream 对象实现序列化12345// 在根目录下新建一个 io 的文件夹OutputStream op = new FileOutputStream(&quot;io&quot;+File.separator+&quot;a.txt&quot;);ObjectOutputStream ops = new ObjectOutputStream(op);ops.writeObject(new Person(&quot;vae&quot;,1));ops.close(); 第三步：使用ObjectInputStream 对象实现反序列化1234567InputStream in = new FileInputStream(&quot;io&quot;+File.separator+&quot;a.txt&quot;);ObjectInputStream os = new ObjectInputStream(in);byte[] buffer = new byte[10];int len = -1;Person p = (Person) os.readObject();System.out.println(p); //Person [name=vae, age=1]os.close(); question问题1：如果某些数据不需要做序列化，比如密码，比如上面的年龄？解决办法：在字段面前加上 transient。12private String name;//需要序列化transient private int age;//不需要序列化 那么我们在反序列化的时候，打印出来的就是Person [name=vae, age=0]，整型数据默认值为 0。 问题2：序列化版本问题，在完成序列化操作后，由于项目的升级或修改，可能我们会对序列化对象进行修改，比如增加某个字段，那么我们在进行反序列化就会报错，怎么办？解决办法：在 JavaBean 对象中增加一个 serialVersionUID 字段，用来固定这个版本，无论我们怎么修改，版本都是一致的，就能进行反序列化了。1private static final long serialVersionUID = 8656128222714547171L;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java FileUtils]]></title>
    <url>%2F1900%2F01%2F02%2F00JAVA%2F02%20Java%20FileUtils%2F</url>
    <content type="text"><![CDATA[参考链接：ANDROID-FILEUTILS工具类 文件/文件夹工具类，是对文件操作处理的方法进行了封装，提供了公共的方法。其中 closeIO()、writeFileFromIS() 两个方法是从其他工具类中移植过来的，这样保证代码可以编译通过。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356package com.xxt.xtest;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.Closeable;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.FilenameFilter;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.security.DigestInputStream;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.List;/** * @Author XianXiaoTao * @Describe：文件相关工具类 */public final class FileUtils &#123; private FileUtils() &#123; throw new UnsupportedOperationException(&quot;u can&apos;t instantiate me...&quot;); &#125; private static final String LINE_SEP = System.getProperty(&quot;line.separator&quot;); /** * 根据文件路径获取文件 * * @param filePath 文件路径 * @return 文件 */ public static File getFileByPath(final String filePath) &#123; return isSpace(filePath) ? null : new File(filePath); &#125; /** * 根据文件目录路径获取子目录名称（不获取二级子目录） * @param dirPath 文件路径 * @return 文件目录名称 */ public static List&lt;String&gt; getFiledirList(String dirPath)&#123; if (dirPath == null || !isDir(dirPath)) return null; List&lt;String&gt; stringList = new ArrayList&lt;&gt;(); File f = new File(dirPath); File[] files = f.listFiles(); if(files != null&amp;&amp; files.length != 0)&#123; for (File file : files) &#123; if (file.isDirectory()) &#123; stringList.add(file.getName()); &#125; &#125; &#125; return stringList; &#125; /** * 判断文件是否存在 * * @param filePath 文件路径 * @return &#123;@code true&#125;: 存在&lt;br&gt;&#123;@code false&#125;: 不存在 */ public static boolean isFileExists(final String filePath) &#123; return isFileExists(getFileByPath(filePath)); &#125; /** * 判断文件是否存在 * * @param file 文件 * @return &#123;@code true&#125;: 存在&lt;br&gt;&#123;@code false&#125;: 不存在 */ public static boolean isFileExists(final File file) &#123; return file != null &amp;&amp; file.exists(); &#125; /** * 重命名文件 * * @param filePath 文件路径 * @param newName 新名称 * @return &#123;@code true&#125;: 重命名成功&lt;br&gt;&#123;@code false&#125;: 重命名失败 */ public static boolean rename(final String filePath, final String newName) &#123; return rename(getFileByPath(filePath), newName); &#125; /** * 重命名文件 * * @param file 文件 * @param newName 新名称 * @return &#123;@code true&#125;: 重命名成功&lt;br&gt;&#123;@code false&#125;: 重命名失败 */ public static boolean rename(final File file, final String newName) &#123; // 文件为空返回false if (file == null) return false; // 文件不存在返回false if (!file.exists()) return false; // 新的文件名为空返回false if (isSpace(newName)) return false; // 如果文件名没有改变返回true if (newName.equals(file.getName())) return true; File newFile = new File(file.getParent() + File.separator + newName); // 如果重命名的文件已存在返回false return !newFile.exists() &amp;&amp; file.renameTo(newFile); &#125; /** * 判断是否是目录 * * @param dirPath 目录路径 * @return &#123;@code true&#125;: 是&lt;br&gt;&#123;@code false&#125;: 否 */ public static boolean isDir(final String dirPath) &#123; return isDir(getFileByPath(dirPath)); &#125; /** * 判断是否是目录 * * @param file 文件 * @return &#123;@code true&#125;: 是&lt;br&gt;&#123;@code false&#125;: 否 */ public static boolean isDir(final File file) &#123; return isFileExists(file) &amp;&amp; file.isDirectory(); &#125; /** * 判断是否是文件 * * @param filePath 文件路径 * @return &#123;@code true&#125;: 是&lt;br&gt;&#123;@code false&#125;: 否 */ public static boolean isFile(final String filePath) &#123; return isFile(getFileByPath(filePath)); &#125; /** * 判断是否是文件 * * @param file 文件 * @return &#123;@code true&#125;: 是&lt;br&gt;&#123;@code false&#125;: 否 */ public static boolean isFile(final File file) &#123; return isFileExists(file) &amp;&amp; file.isFile(); &#125; /** * 判断目录是否存在，不存在则判断是否创建成功 * * @param dirPath 目录路径 * @return &#123;@code true&#125;: 存在或创建成功&lt;br&gt;&#123;@code false&#125;: 不存在或创建失败 */ public static boolean createOrExistsDir(final String dirPath) &#123; return createOrExistsDir(getFileByPath(dirPath)); &#125; /** * 判断目录是否存在，不存在则判断是否创建成功 * * @param file 文件 * @return &#123;@code true&#125;: 存在或创建成功&lt;br&gt;&#123;@code false&#125;: 不存在或创建失败 */ public static boolean createOrExistsDir(final File file) &#123; // 如果存在，是目录则返回true，是文件则返回false，不存在则返回是否创建成功 return file != null &amp;&amp; (file.exists() ? file.isDirectory() : file.mkdirs()); &#125; /** * 判断文件是否存在，不存在则判断是否创建成功 * * @param filePath 文件路径 * @return &#123;@code true&#125;: 存在或创建成功&lt;br&gt;&#123;@code false&#125;: 不存在或创建失败 */ public static boolean createOrExistsFile(final String filePath) &#123; return createOrExistsFile(getFileByPath(filePath)); &#125; /** * 判断文件是否存在，不存在则判断是否创建成功 * * @param file 文件 * @return &#123;@code true&#125;: 存在或创建成功&lt;br&gt;&#123;@code false&#125;: 不存在或创建失败 */ public static boolean createOrExistsFile(final File file) &#123; if (file == null) return false; // 如果存在，是文件则返回true，是目录则返回false if (file.exists()) return file.isFile(); if (!createOrExistsDir(file.getParentFile())) return false; try &#123; return file.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 判断文件是否存在，存在则在创建之前删除 * * @param file 文件 * @return &#123;@code true&#125;: 创建成功&lt;br&gt;&#123;@code false&#125;: 创建失败 */ public static boolean createFileByDeleteOldFile(final File file) &#123; if (file == null) return false; // 文件存在并且删除失败返回false if (file.exists() &amp;&amp; !file.delete()) return false; // 创建目录失败返回false if (!createOrExistsDir(file.getParentFile())) return false; try &#123; return file.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 复制或移动目录 * * @param srcDirPath 源目录路径 * @param destDirPath 目标目录路径 * @param isMove 是否移动 * @return &#123;@code true&#125;: 复制或移动成功&lt;br&gt;&#123;@code false&#125;: 复制或移动失败 */ private static boolean copyOrMoveDir(final String srcDirPath, final String destDirPath, final boolean isMove) &#123; return copyOrMoveDir(getFileByPath(srcDirPath), getFileByPath(destDirPath), isMove); &#125; /** * 复制或移动目录 * * @param srcDir 源目录 * @param destDir 目标目录 * @param isMove 是否移动 * @return &#123;@code true&#125;: 复制或移动成功&lt;br&gt;&#123;@code false&#125;: 复制或移动失败 */ private static boolean copyOrMoveDir(final File srcDir, final File destDir, final boolean isMove) &#123; if (srcDir == null || destDir == null) return false; // 如果目标目录在源目录中则返回false，看不懂的话好好想想递归怎么结束 // srcPath : F:\\MyGithub\\AndroidUtilCode\\utilcode\\src\\test\\res // destPath: F:\\MyGithub\\AndroidUtilCode\\utilcode\\src\\test\\res1 // 为防止以上这种情况出现出现误判，须分别在后面加个路径分隔符 String srcPath = srcDir.getPath() + File.separator; String destPath = destDir.getPath() + File.separator; if (destPath.contains(srcPath)) return false; // 源文件不存在或者不是目录则返回false if (!srcDir.exists() || !srcDir.isDirectory()) return false; // 目标目录不存在返回false if (!createOrExistsDir(destDir)) return false; File[] files = srcDir.listFiles(); for (File file : files) &#123; File oneDestFile = new File(destPath + file.getName()); if (file.isFile()) &#123; // 如果操作失败返回false if (!copyOrMoveFile(file, oneDestFile, isMove)) return false; &#125; else if (file.isDirectory()) &#123; // 如果操作失败返回false if (!copyOrMoveDir(file, oneDestFile, isMove)) return false; &#125; &#125; return !isMove || deleteDir(srcDir); &#125; /** * 复制或移动文件 * * @param srcFilePath 源文件路径 * @param destFilePath 目标文件路径 * @param isMove 是否移动 * @return &#123;@code true&#125;: 复制或移动成功&lt;br&gt;&#123;@code false&#125;: 复制或移动失败 */ private static boolean copyOrMoveFile(final String srcFilePath, final String destFilePath, final boolean isMove) &#123; return copyOrMoveFile(getFileByPath(srcFilePath), getFileByPath(destFilePath), isMove); &#125; /** * 复制或移动文件 * * @param srcFile 源文件 * @param destFile 目标文件 * @param isMove 是否移动 * @return &#123;@code true&#125;: 复制或移动成功&lt;br&gt;&#123;@code false&#125;: 复制或移动失败 */ private static boolean copyOrMoveFile(final File srcFile, final File destFile, final boolean isMove) &#123; if (srcFile == null || destFile == null) return false; // 源文件不存在或者不是文件则返回false if (!srcFile.exists() || !srcFile.isFile()) return false; // 目标文件存在且是文件则返回false if (destFile.exists() &amp;&amp; destFile.isFile()) return false; // 目标目录不存在返回false if (!createOrExistsDir(destFile.getParentFile())) return false; try &#123; return writeFileFromIS(destFile, new FileInputStream(srcFile)) &amp;&amp; !(isMove &amp;&amp; !deleteFile(srcFile)); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 复制目录 * * @param srcDirPath 源目录路径 * @param destDirPath 目标目录路径 * @return &#123;@code true&#125;: 复制成功&lt;br&gt;&#123;@code false&#125;: 复制失败 */ public static boolean copyDir(final String srcDirPath, final String destDirPath) &#123; return copyDir(getFileByPath(srcDirPath), getFileByPath(destDirPath)); &#125; /** * 复制目录 * * @param srcDir 源目录 * @param destDir 目标目录 * @return &#123;@code true&#125;: 复制成功&lt;br&gt;&#123;@code false&#125;: 复制失败 */ public static boolean copyDir(final File srcDir, final File destDir) &#123; return copyOrMoveDir(srcDir, destDir, false); &#125; /** * 复制文件 * * @param srcFilePath 源文件路径 * @param destFilePath 目标文件路径 * @return &#123;@code true&#125;: 复制成功&lt;br&gt;&#123;@code false&#125;: 复制失败 */ public static boolean copyFile(final String srcFilePath, final String destFilePath) &#123; return copyFile(getFileByPath(srcFilePath), getFileByPath(destFilePath)); &#125; /** * 复制文件 * * @param srcFile 源文件 * @param destFile 目标文件 * @return &#123;@code true&#125;: 复制成功&lt;br&gt;&#123;@code false&#125;: 复制失败 */ public static boolean copyFile(final File srcFile, final File destFile) &#123; return copyOrMoveFile(srcFile, destFile, false); &#125; /** * 移动目录 * * @param srcDirPath 源目录路径 * @param destDirPath 目标目录路径 * @return &#123;@code true&#125;: 移动成功&lt;br&gt;&#123;@code false&#125;: 移动失败 */ public static boolean moveDir(final String srcDirPath, final String destDirPath) &#123; return moveDir(getFileByPath(srcDirPath), getFileByPath(destDirPath)); &#125; /** * 移动目录 * * @param srcDir 源目录 * @param destDir 目标目录 * @return &#123;@code true&#125;: 移动成功&lt;br&gt;&#123;@code false&#125;: 移动失败 */ public static boolean moveDir(final File srcDir, final File destDir) &#123; return copyOrMoveDir(srcDir, destDir, true); &#125; /** * 移动文件 * * @param srcFilePath 源文件路径 * @param destFilePath 目标文件路径 * @return &#123;@code true&#125;: 移动成功&lt;br&gt;&#123;@code false&#125;: 移动失败 */ public static boolean moveFile(final String srcFilePath, final String destFilePath) &#123; return moveFile(getFileByPath(srcFilePath), getFileByPath(destFilePath)); &#125; /** * 移动文件 * * @param srcFile 源文件 * @param destFile 目标文件 * @return &#123;@code true&#125;: 移动成功&lt;br&gt;&#123;@code false&#125;: 移动失败 */ public static boolean moveFile(final File srcFile, final File destFile) &#123; return copyOrMoveFile(srcFile, destFile, true); &#125; /** * 删除目录 * * @param dirPath 目录路径 * @return &#123;@code true&#125;: 删除成功&lt;br&gt;&#123;@code false&#125;: 删除失败 */ public static boolean deleteDir(final String dirPath) &#123; return deleteDir(getFileByPath(dirPath)); &#125; /** * 删除文件或目录 * @param file * @return */ public static boolean deleteDirOrFile(File file)&#123; if (file == null) return false; if (!file.exists()) return false; if(file.isFile())&#123; return deleteFile(file); &#125;else&#123; return deleteDir(file); &#125; &#125; /** * 删除文件或目录 * @param path * @return */ public static boolean deleteDirOrFile(String path)&#123; return deleteDirOrFile(getFileByPath(path)); &#125; /** * 删除目录 * * @param dir 目录 * @return &#123;@code true&#125;: 删除成功&lt;br&gt;&#123;@code false&#125;: 删除失败 */ public static boolean deleteDir(final File dir) &#123; if (dir == null) return false; // 目录不存在返回true if (!dir.exists()) return true; // 不是目录返回false if (!dir.isDirectory()) return false; // 现在文件存在且是文件夹 File[] files = dir.listFiles(); if (files != null &amp;&amp; files.length != 0) &#123; for (File file : files) &#123; if (file.isFile()) &#123; if (!file.delete()) return false; &#125; else if (file.isDirectory()) &#123; if (!deleteDir(file)) return false; &#125; &#125; &#125; return dir.delete(); &#125; /** * 删除Luban文件集合 以“|” 分割 * @param srcFilePaths */ public static void deleteFiles(String srcFilePaths)&#123; if (srcFilePaths == null || srcFilePaths.length() == 0) return; List&lt;String&gt; list = Arrays.asList(srcFilePaths.split(&quot;\\|&quot;)); for(String path : list)&#123; if(path.contains(&quot;luban&quot;))&#123; deleteFile(path); &#125; &#125; &#125; /** * 删除文件 * * @param srcFilePath 文件路径 * @return &#123;@code true&#125;: 删除成功&lt;br&gt;&#123;@code false&#125;: 删除失败 */ public static boolean deleteFile(final String srcFilePath) &#123; return deleteFile(getFileByPath(srcFilePath)); &#125; /** * 删除文件 * * @param file 文件 * @return &#123;@code true&#125;: 删除成功&lt;br&gt;&#123;@code false&#125;: 删除失败 */ public static boolean deleteFile(final File file) &#123; return file != null &amp;&amp; (!file.exists() || file.isFile() &amp;&amp; file.delete()); &#125; /** * 删除目录下的所有文件 * * @param dirPath 目录路径 * @return &#123;@code true&#125;: 删除成功&lt;br&gt;&#123;@code false&#125;: 删除失败 */ public static boolean deleteFilesInDir(final String dirPath) &#123; return deleteFilesInDir(getFileByPath(dirPath)); &#125; /** * 删除目录下的所有文件 * * @param dir 目录 * @return &#123;@code true&#125;: 删除成功&lt;br&gt;&#123;@code false&#125;: 删除失败 */ public static boolean deleteFilesInDir(final File dir) &#123; if (dir == null) return false; // 目录不存在返回true if (!dir.exists()) return true; // 不是目录返回false if (!dir.isDirectory()) return false; // 现在文件存在且是文件夹 File[] files = dir.listFiles(); if (files != null &amp;&amp; files.length != 0) &#123; for (File file : files) &#123; if (file.isFile()) &#123; if (!file.delete()) return false; &#125; else if (file.isDirectory()) &#123; if (!deleteDir(file)) return false; &#125; &#125; &#125; return true; &#125; /** * 获取目录下所有文件 * * @param dirPath 目录路径 * @param isRecursive 是否递归进子目录 * @return 文件链表 */ public static List&lt;File&gt; listFilesInDir(final String dirPath, final boolean isRecursive) &#123; return listFilesInDir(getFileByPath(dirPath), isRecursive); &#125; /** * 获取目录下所有文件 * * @param dir 目录 * @param isRecursive 是否递归进子目录 * @return 文件链表 */ public static List&lt;File&gt; listFilesInDir(final File dir, final boolean isRecursive) &#123; if (!isDir(dir)) return null; if (isRecursive) return listFilesInDir(dir); List&lt;File&gt; list = new ArrayList&lt;&gt;(); File[] files = dir.listFiles(); if (files != null &amp;&amp; files.length != 0) &#123; Collections.addAll(list, files); &#125; return list; &#125; /** * 获取目录下所有文件包括子目录 * * @param dirPath 目录路径 * @return 文件链表 */ public static List&lt;File&gt; listFilesInDir(final String dirPath) &#123; return listFilesInDir(getFileByPath(dirPath)); &#125; /** * 获取目录下所有文件包括子目录 * * @param dir 目录 * @return 文件链表 */ public static List&lt;File&gt; listFilesInDir(final File dir) &#123; if (!isDir(dir)) return null; List&lt;File&gt; list = new ArrayList&lt;&gt;(); File[] files = dir.listFiles(); if (files != null &amp;&amp; files.length != 0) &#123; for (File file : files) &#123; list.add(file); if (file.isDirectory()) &#123; List&lt;File&gt; fileList = listFilesInDir(file); if (fileList != null) &#123; list.addAll(fileList); &#125; &#125; &#125; &#125; return list; &#125; /** * 获取目录下所有后缀名为suffix的文件 * &lt;p&gt;大小写忽略&lt;/p&gt; * * @param dirPath 目录路径 * @param suffix 后缀名 * @param isRecursive 是否递归进子目录 * @return 文件链表 */ public static List&lt;File&gt; listFilesInDirWithFilter(final String dirPath, final String suffix, final boolean isRecursive) &#123; return listFilesInDirWithFilter(getFileByPath(dirPath), suffix, isRecursive); &#125; /** * 获取目录下所有后缀名为suffix的文件 * &lt;p&gt;大小写忽略&lt;/p&gt; * * @param dir 目录 * @param suffix 后缀名 * @param isRecursive 是否递归进子目录 * @return 文件链表 */ public static List&lt;File&gt; listFilesInDirWithFilter(final File dir, final String suffix, final boolean isRecursive) &#123; if (isRecursive) return listFilesInDirWithFilter(dir, suffix); if (dir == null || !isDir(dir)) return null; List&lt;File&gt; list = new ArrayList&lt;&gt;(); File[] files = dir.listFiles(); if (files != null &amp;&amp; files.length != 0) &#123; for (File file : files) &#123; if(file.length()&gt;10)&#123; if (file.getName().toUpperCase().endsWith(suffix.toUpperCase())) &#123; list.add(file); &#125; &#125; &#125; &#125; return list; &#125; /** * 获取目录下所有后缀名为suffix的文件包括子目录 * &lt;p&gt;大小写忽略&lt;/p&gt; * * @param dirPath 目录路径 * @param suffix 后缀名 * @return 文件链表 */ public static List&lt;File&gt; listFilesInDirWithFilter(final String dirPath, final String suffix) &#123; return listFilesInDirWithFilter(getFileByPath(dirPath), suffix); &#125; /** * 获取目录下所有后缀名为suffix的文件包括子目录 * &lt;p&gt;大小写忽略&lt;/p&gt; * * @param dir 目录 * @param suffix 后缀名 * @return 文件链表 */ public static List&lt;File&gt; listFilesInDirWithFilter(final File dir, final String suffix) &#123; if (dir == null || !isDir(dir)) return null; List&lt;File&gt; list = new ArrayList&lt;&gt;(); File[] files = dir.listFiles(); if (files != null &amp;&amp; files.length != 0) &#123; for (File file : files) &#123; if (file.getName().toUpperCase().endsWith(suffix.toUpperCase())) &#123; list.add(file); &#125; if (file.isDirectory()) &#123; list.addAll(listFilesInDirWithFilter(file, suffix)); &#125; &#125; &#125; return list; &#125; /** * 获取目录下所有符合filter的文件 * * @param dirPath 目录路径 * @param filter 过滤器 * @param isRecursive 是否递归进子目录 * @return 文件链表 */ public static List&lt;File&gt; listFilesInDirWithFilter(final String dirPath, final FilenameFilter filter, final boolean isRecursive) &#123; return listFilesInDirWithFilter(getFileByPath(dirPath), filter, isRecursive); &#125; /** * 获取目录下所有符合filter的文件 * * @param dir 目录 * @param filter 过滤器 * @param isRecursive 是否递归进子目录 * @return 文件链表 */ public static List&lt;File&gt; listFilesInDirWithFilter(final File dir, final FilenameFilter filter, final boolean isRecursive) &#123; if (isRecursive) return listFilesInDirWithFilter(dir, filter); if (dir == null || !isDir(dir)) return null; List&lt;File&gt; list = new ArrayList&lt;&gt;(); File[] files = dir.listFiles(); if (files != null &amp;&amp; files.length != 0) &#123; for (File file : files) &#123; if (filter.accept(file.getParentFile(), file.getName())) &#123; list.add(file); &#125; &#125; &#125; return list; &#125; /** * 获取目录下所有符合filter的文件包括子目录 * * @param dirPath 目录路径 * @param filter 过滤器 * @return 文件链表 */ public static List&lt;File&gt; listFilesInDirWithFilter(final String dirPath, final FilenameFilter filter) &#123; return listFilesInDirWithFilter(getFileByPath(dirPath), filter); &#125; /** * 获取目录下所有符合filter的文件包括子目录 * * @param dir 目录 * @param filter 过滤器 * @return 文件链表 */ public static List&lt;File&gt; listFilesInDirWithFilter(final File dir, final FilenameFilter filter) &#123; if (dir == null || !isDir(dir)) return null; List&lt;File&gt; list = new ArrayList&lt;&gt;(); File[] files = dir.listFiles(); if (files != null &amp;&amp; files.length != 0) &#123; for (File file : files) &#123; if (filter.accept(file.getParentFile(), file.getName())) &#123; list.add(file); &#125; if (file.isDirectory()) &#123; list.addAll(listFilesInDirWithFilter(file, filter)); &#125; &#125; &#125; return list; &#125; /** * 获取目录下指定文件名的文件包括子目录 * &lt;p&gt;大小写忽略&lt;/p&gt; * * @param dirPath 目录路径 * @param fileName 文件名 * @return 文件链表 */ public static List&lt;File&gt; searchFileInDir(final String dirPath, final String fileName) &#123; return searchFileInDir(getFileByPath(dirPath), fileName); &#125; /** * 获取目录下指定文件名的文件包括子目录 * &lt;p&gt;大小写忽略&lt;/p&gt; * * @param dir 目录 * @param fileName 文件名 * @return 文件链表 */ public static List&lt;File&gt; searchFileInDir(final File dir, final String fileName) &#123; if (dir == null || !isDir(dir)) return null; List&lt;File&gt; list = new ArrayList&lt;&gt;(); File[] files = dir.listFiles(); if (files != null &amp;&amp; files.length != 0) &#123; for (File file : files) &#123; if (file.getName().toUpperCase().equals(fileName.toUpperCase())) &#123; list.add(file); &#125; if (file.isDirectory()) &#123; list.addAll(searchFileInDir(file, fileName)); &#125; &#125; &#125; return list; &#125; /** * 获取文件最后修改的毫秒时间戳 * * @param filePath 文件路径 * @return 文件最后修改的毫秒时间戳 */ public static long getFileLastModified(final String filePath) &#123; return getFileLastModified(getFileByPath(filePath)); &#125; /** * 获取文件最后修改的毫秒时间戳 * * @param file 文件 * @return 文件最后修改的毫秒时间戳 */ public static long getFileLastModified(final File file) &#123; if (file == null) return -1; return file.lastModified(); &#125; /** * 简单获取文件编码格式 * * @param filePath 文件路径 * @return 文件编码 */ public static String getFileCharsetSimple(final String filePath) &#123; return getFileCharsetSimple(getFileByPath(filePath)); &#125; /** * 简单获取文件编码格式 * * @param file 文件 * @return 文件编码 */ public static String getFileCharsetSimple(final File file) &#123; int p = 0; InputStream is = null; try &#123; is = new BufferedInputStream(new FileInputStream(file)); p = (is.read() &lt;&lt; 8) + is.read(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; closeIO(is); &#125; switch (p) &#123; case 0xefbb: return &quot;UTF-8&quot;; case 0xfffe: return &quot;Unicode&quot;; case 0xfeff: return &quot;UTF-16BE&quot;; default: return &quot;GBK&quot;; &#125; &#125; /** * 获取文件行数 * * @param filePath 文件路径 * @return 文件行数 */ public static int getFileLines(final String filePath) &#123; return getFileLines(getFileByPath(filePath)); &#125; /** * 获取文件行数 * &lt;p&gt;比readLine要快很多&lt;/p&gt; * * @param file 文件 * @return 文件行数 */ public static int getFileLines(final File file) &#123; int count = 1; InputStream is = null; try &#123; is = new BufferedInputStream(new FileInputStream(file)); byte[] buffer = new byte[1024]; int readChars; if (LINE_SEP.endsWith(&quot;\n&quot;)) &#123; while ((readChars = is.read(buffer, 0, 1024)) != -1) &#123; for (int i = 0; i &lt; readChars; ++i) &#123; if (buffer[i] == &apos;\n&apos;) ++count; &#125; &#125; &#125; else &#123; while ((readChars = is.read(buffer, 0, 1024)) != -1) &#123; for (int i = 0; i &lt; readChars; ++i) &#123; if (buffer[i] == &apos;\r&apos;) ++count; &#125; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; closeIO(is); &#125; return count; &#125; /** * 获取目录大小 * * @param dirPath 目录路径 * @return 文件大小 */ public static String getDirSize(final String dirPath) &#123; return getDirSize(getFileByPath(dirPath)); &#125; /** * 获取目录大小 * * @param dir 目录 * @return 文件大小 */ public static String getDirSize(final File dir) &#123; long len = getDirLength(dir); return len == -1 ? &quot;&quot; : byte2FitMemorySize(len); &#125; /** * 获取文件大小 * * @param filePath 文件路径 * @return 文件大小 */ public static String getFileSize(final String filePath) &#123; return getFileSize(getFileByPath(filePath)); &#125; /** * 获取文件大小 * * @param file 文件 * @return 文件大小 */ public static String getFileSize(final File file) &#123; long len = getFileLength(file); return len == -1 ? &quot;&quot; : byte2FitMemorySize(len); &#125; /** * 获取目录长度 * * @param dirPath 目录路径 * @return 目录长度 */ public static long getDirLength(final String dirPath) &#123; return getDirLength(getFileByPath(dirPath)); &#125; /** * 获取目录长度 * * @param dir 目录 * @return 目录长度 */ public static long getDirLength(final File dir) &#123; if (!isDir(dir)) return -1; long len = 0; File[] files = dir.listFiles(); if (files != null &amp;&amp; files.length != 0) &#123; for (File file : files) &#123; if (file.isDirectory()) &#123; len += getDirLength(file); &#125; else &#123; len += file.length(); &#125; &#125; &#125; return len; &#125; /** * 获取文件长度 * * @param filePath 文件路径 * @return 文件长度 */ public static long getFileLength(final String filePath) &#123; return getFileLength(getFileByPath(filePath)); &#125; /** * 获取文件长度 * * @param file 文件 * @return 文件长度 */ public static long getFileLength(final File file) &#123; if (!isFile(file)) return -1; return file.length(); &#125; /** * 获取文件的MD5校验码 * * @param filePath 文件路径 * @return 文件的MD5校验码 */ public static String getFileMD5ToString(final String filePath) &#123; File file = isSpace(filePath) ? null : new File(filePath); return getFileMD5ToString(file); &#125; /** * 获取文件的MD5校验码 * * @param filePath 文件路径 * @return 文件的MD5校验码 */ public static byte[] getFileMD5(final String filePath) &#123; File file = isSpace(filePath) ? null : new File(filePath); return getFileMD5(file); &#125; /** * 获取文件的MD5校验码 * * @param file 文件 * @return 文件的MD5校验码 */ public static String getFileMD5ToString(final File file) &#123; return bytes2HexString(getFileMD5(file)); &#125; /** * 获取文件的MD5校验码 * * @param file 文件 * @return 文件的MD5校验码 */ public static byte[] getFileMD5(final File file) &#123; if (file == null) return null; DigestInputStream dis = null; try &#123; FileInputStream fis = new FileInputStream(file); MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;); dis = new DigestInputStream(fis, md); byte[] buffer = new byte[1024 * 256]; while (true) &#123; if (!(dis.read(buffer) &gt; 0)) break; &#125; md = dis.getMessageDigest(); return md.digest(); &#125; catch (NoSuchAlgorithmException | IOException e) &#123; e.printStackTrace(); &#125; finally &#123; closeIO(dis); &#125; return null; &#125; /** * 获取全路径中的最长目录 * * @param file 文件 * @return filePath最长目录 */ public static String getDirName(final File file) &#123; if (file == null) return null; return getDirName(file.getPath()); &#125; /** * 获取全路径中的最长目录 * * @param filePath 文件路径 * @return filePath最长目录 */ public static String getDirName(final String filePath) &#123; if (isSpace(filePath)) return filePath; int lastSep = filePath.lastIndexOf(File.separator); return lastSep == -1 ? &quot;&quot; : filePath.substring(0, lastSep + 1); &#125; /** * 获取全路径中的文件名 * * @param file 文件 * @return 文件名 */ public static String getFileName(final File file) &#123; if (file == null) return null; return getFileName(file.getPath()); &#125; /** * 获取全路径中的文件名 * * @param filePath 文件路径 * @return 文件名 */ public static String getFileName(final String filePath) &#123; if (isSpace(filePath)) return filePath; int lastSep = filePath.lastIndexOf(File.separator); return lastSep == -1 ? filePath : filePath.substring(lastSep + 1); &#125; /** * 获取全路径中的不带拓展名的文件名 * * @param file 文件 * @return 不带拓展名的文件名 */ public static String getFileNameNoExtension(final File file) &#123; if (file == null) return null; return getFileNameNoExtension(file.getPath()); &#125; /** * 获取全路径中的不带拓展名的文件名 * * @param filePath 文件路径 * @return 不带拓展名的文件名 */ public static String getFileNameNoExtension(final String filePath) &#123; if (isSpace(filePath)) return filePath; int lastPoi = filePath.lastIndexOf(&apos;.&apos;); int lastSep = filePath.lastIndexOf(File.separator); if (lastSep == -1) &#123; return (lastPoi == -1 ? filePath : filePath.substring(0, lastPoi)); &#125; if (lastPoi == -1 || lastSep &gt; lastPoi) &#123; return filePath.substring(lastSep + 1); &#125; return filePath.substring(lastSep + 1, lastPoi); &#125; /** * 获取全路径中的文件拓展名 * * @param file 文件 * @return 文件拓展名 */ public static String getFileExtension(final File file) &#123; if (file == null) return null; return getFileExtension(file.getPath()); &#125; /** * 获取全路径中的文件拓展名 * * @param filePath 文件路径 * @return 文件拓展名 */ public static String getFileExtension(final String filePath) &#123; if (isSpace(filePath)) return filePath; int lastPoi = filePath.lastIndexOf(&apos;.&apos;); int lastSep = filePath.lastIndexOf(File.separator); if (lastPoi == -1 || lastSep &gt;= lastPoi) return &quot;&quot;; return filePath.substring(lastPoi + 1); &#125; /////////////////////////////////////////////////////////////////////////// // copy from ConvertUtils /////////////////////////////////////////////////////////////////////////// private static final char hexDigits[] = &#123;&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;&#125;; /** * byteArr转hexString * &lt;p&gt;例如：&lt;/p&gt; * bytes2HexString(new byte[] &#123; 0, (byte) 0xa8 &#125;) returns 00A8 * * @param bytes 字节数组 * @return 16进制大写字符串 */ private static String bytes2HexString(final byte[] bytes) &#123; if (bytes == null) return null; int len = bytes.length; if (len &lt;= 0) return null; char[] ret = new char[len &lt;&lt; 1]; for (int i = 0, j = 0; i &lt; len; i++) &#123; ret[j++] = hexDigits[bytes[i] &gt;&gt;&gt; 4 &amp; 0x0f]; ret[j++] = hexDigits[bytes[i] &amp; 0x0f]; &#125; return new String(ret); &#125; /** * 字节数转合适内存大小 * &lt;p&gt;保留3位小数&lt;/p&gt; * * @param byteNum 字节数 * @return 合适内存大小 */ private static String byte2FitMemorySize(final long byteNum) &#123; if (byteNum &lt; 0) &#123; return &quot;shouldn&apos;t be less than zero!&quot;; &#125; else if (byteNum &lt; 1024) &#123; return String.format(&quot;%.3fB&quot;, (double) byteNum + 0.0005); &#125; else if (byteNum &lt; 1048576) &#123; return String.format(&quot;%.3fKB&quot;, (double) byteNum / 1024 + 0.0005); &#125; else if (byteNum &lt; 1073741824) &#123; return String.format(&quot;%.3fMB&quot;, (double) byteNum / 1048576 + 0.0005); &#125; else &#123; return String.format(&quot;%.3fGB&quot;, (double) byteNum / 1073741824 + 0.0005); &#125; &#125; private static boolean isSpace(final String s) &#123; if (s == null) return true; for (int i = 0, len = s.length(); i &lt; len; ++i) &#123; if (!Character.isWhitespace(s.charAt(i))) &#123; return false; &#125; &#125; return true; &#125; // --------------- /** * 在指定的位置创建指定的文件 * @param filePath 完整的文件路径 * @param mkdir 是否创建相关的文件夹 * @throws IOException */ public static void mkFile(String filePath, boolean mkdir) throws IOException&#123; File file = new File(filePath); /** * mkdirs()创建多层目录，mkdir()创建单层目录 * writeObject时才创建磁盘文件。 * 若不创建文件，readObject出错。 */ file.getParentFile().mkdirs(); file.createNewFile(); file = null; &#125; /** * 在指定的位置创建文件夹 * @param dirPath 文件夹路径 * @return 若创建成功，则返回True；反之，则返回False */ public static boolean mkDir(String dirPath) &#123; return new File(dirPath).mkdirs(); &#125; /** * 删除指定的文件 * @param filePath 文件路径 * @return 若删除成功，则返回True；反之，则返回False */ public static boolean delFile(String filePath) &#123; return new File(filePath).delete(); &#125; /** * 删除指定的文件夹 * @param dirPath 文件夹路径 * @param delFile 文件夹中是否包含文件 * @return 若删除成功，则返回True；反之，则返回False */ public static boolean delDir(String dirPath, boolean delFile) &#123; if (delFile) &#123; File file = new File(dirPath); if (file.isFile()) &#123; return file.delete(); &#125; else if (file.isDirectory()) &#123; if (file.listFiles().length == 0) &#123; return file.delete(); &#125; else &#123; int zFiles = file.listFiles().length; File[] delfile = file.listFiles(); for (int i = 0; i &lt; zFiles; i++) &#123; if (delfile[i].isDirectory()) &#123; delDir(delfile[i].getAbsolutePath(), true); &#125; delfile[i].delete(); &#125; return file.delete(); &#125; &#125; else &#123; return false; &#125; &#125; else &#123; return new File(dirPath).delete(); &#125; &#125; /** * 复制文件/文件夹 若要进行文件夹复制，请勿将目标文件夹置于源文件夹中 * @param source 源文件（夹） * @param target 目标文件（夹） * @param isFolder 若进行文件夹复制，则为True；反之为False * @throws IOException */ public static void copy(String source, String target, boolean isFolder) throws IOException&#123; if (isFolder) &#123; new File(target).mkdirs(); File a = new File(source); String[] file = a.list(); File temp = null; for (int i = 0; i &lt; file.length; i++) &#123; if (source.endsWith(File.separator)) &#123; temp = new File(source + file[i]); &#125; else &#123; temp = new File(source + File.separator + file[i]); &#125; if (temp.isFile()) &#123; FileInputStream input = new FileInputStream(temp); FileOutputStream output = new FileOutputStream(target + File.separator + temp.getName().toString()); byte[] b = new byte[1024]; int len; while ((len = input.read(b)) != -1) &#123; output.write(b, 0, len); &#125; output.flush(); output.close(); input.close(); &#125; if (temp.isDirectory()) &#123; copy(source + File.separator + file[i], target + File.separator + file[i], true); &#125; &#125; &#125; else &#123; int byteread = 0; File oldFile = new File(source); if (oldFile.exists()) &#123; InputStream inputStream = new FileInputStream(source); File file = new File(target); file.getParentFile().mkdirs(); file.createNewFile(); FileOutputStream outputStream = new FileOutputStream(file); byte[] buffer = new byte[1024]; while ((byteread = inputStream.read(buffer)) != -1)&#123; outputStream.write(buffer, 0, byteread); &#125; inputStream.close(); outputStream.close(); &#125; &#125; &#125; /** * 关闭IO，从 CloseUtils 中移植过来的 * @param closeables closeables */ private static void closeIO(Closeable... closeables) &#123; if (closeables == null) return; for (Closeable closeable : closeables) &#123; if (closeable != null) &#123; try &#123; closeable.close(); &#125; catch (IOException e) &#123;&#125; &#125; &#125; &#125; /** * 将输入流写入文件，从 FileIOUtils 中移植过来的 * * @param file 文件 * @param is 输入流 * @return &#123;@code true&#125;: 写入成功&lt;br&gt;&#123;@code false&#125;: 写入失败 */ private static boolean writeFileFromIS(final File file, final InputStream is) &#123; if (!createOrExistsFile(file) || is == null) return false; OutputStream os = null; try &#123; os = new BufferedOutputStream(new FileOutputStream(file)); byte data[] = new byte[8192]; int len; while ((len = is.read(data, 0, 8192)) != -1) &#123; os.write(data, 0, len); &#125; return true; &#125; catch (IOException e) &#123; e.printStackTrace(); return false; &#125; finally &#123; CloseUtils.closeIO(is, os); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java File]]></title>
    <url>%2F1900%2F01%2F01%2F00JAVA%2F01%20Java%20File%2F</url>
    <content type="text"><![CDATA[参考链接：Java File 类 一、File 类 File 是“文件”和“目录路径名”的抽象表示形式，它直接继承于 Object，实现了 Serializable 接口和 Comparable 接口。实现 Serializable 接口，意味着 File 对象支持序列化操作。而实现 Comparable 接口，意味着 File 对象之间可以比较大小；File 能直接被存储在有序集合(如 TreeSet、TreeMap 中)。 定义1public class File extends Object implements Serializable, Comparable&lt;File&gt; File 类的实例是不可变的；也就是说，一旦创建，File 对象表示的抽象路径名将永不改变。 构造函数12345678910111213141516171819202122232425262728293031// 通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例。// 如果给定字符串是空字符串，那么结果是空抽象路径名。File(String pathname)// 根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。// 如果 parent 为 null，则创建一个新的 File 实例，// 这与调用给定 child 路径名字符串的单参数 File 构造方法的效果一样。// 否则，parent 抽象路径名用于表示目录，child 路径名字符串用于表示目录或文件。// 如果 child 路径名字符串是绝对路径名，则用与系统有关的方式将它转换为一个相对路径名。// 如果 parent 是空抽象路径名，则通过将 child 转换为抽象路径名，// 并根据与系统有关的默认目录解析结果来创建新的 File 实例。// 否则，将每个路径名字符串转换为一个抽象路径名，并根据父抽象路径名解析子抽象路径名。File(File parent, String child)// 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。// 如果 parent 为 null，则创建一个新的 File 实例，// 这与调用以给定 child 路径名字符串作为参数的单参数 File 构造方法效果一样。// 否则，parent 路径名字符串用于表示目录，child 路径名字符串用于表示目录或文件。// 如果 child 路径名字符串是绝对路径名，则用与系统有关的方式将它转换为一个相对路径名。// 如果 parent 是空字符串，则通过将 child 转换为抽象路径名，// 并根据与系统有关的默认目录解析结果来创建新的 File 实例。// 否则，将每个路径名字符串转换为一个抽象路径名，并根据父抽象路径名解析子抽象路径名。File(String parent, String child)// 通过将给定的 file: URI转换为一个抽象路径名来创建一个新的 File 实例。// file: URI 的具体形式与系统有关，因此，由此构造方法执行的转换也与系统有关。// 对于某个给定抽象路径名 f，可以保证：new File( f.toURI()).equals(f.getAbsoluteFile()) // 只要原始抽象路径名、URI 和新抽象路径名都是在同一 Java 虚拟机（或者它的不同调用）中创建的。// 但是，当在某一操作系统上的虚拟机中创建的 file: URI // 在不同操作系统上的虚拟机中被转换为抽象路径名时，这种关系通常是不成立的。File(URI uri) 利用构造方法，指定路径名、文件名等来构造 File 类的对象，之后调用该对象的 createNewFile() 方法就可以创建出相应的文件。 parent 指定路径（父目录），可以是 File 类对象也可以是字符串， child 中也可以加入路径层级，但要注意，所用的路径必须存在，不存在的路径不会新建。 静态成员1234567891011// 路径分割符&quot;:&quot;,此字段被初始化为包含系统属性 file.separator 值的第一个字符。// 在 UNIX 系统上，此字段的值为 &apos;/&apos;；在 Microsoft Windows 系统上，它为 &apos;\\&apos;。public static final String pathSeparator// 路径分割符&apos;:&apos;,此字段被初始为包含系统属性 path.separator 值的第一个字符。// 此字符用于分隔以路径列表 形式给定的文件序列中的文件名。// 在 UNIX 系统上，此字段为 &apos;:&apos;；在Microsoft Windows 系统上，它为 &apos;;&apos;。public static final char pathSeparatorChar// 分隔符&quot;/&quot;public static final String separator // 分隔符&apos;/&apos; public static final char separatorChar 方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// 按字母顺序比较两个抽象路径名。int compareTo(File pathname)// 计算此抽象路径名的哈希码。int hashCode()// 构造一个表示此抽象路径名的 file: URI。URI toURI()// 已过时。 此方法不会自动转义 URL 中的非法字符。// 建议新的代码使用以下方式将抽象路径名转换为 URL：// 首先通过 toURI 方法将其转换为 URI，然后通过 URI.toURL 方法将 URI 装换为 URL。URL toURL() // 返回此抽象路径名表示的文件最后一次被修改的时间。long lastModified()// 返回由此抽象路径名表示的文件的长度。long length()// 返回此抽象路径名指定的分区中未分配的字节数。long getFreeSpace()// 返回此抽象路径名指定的分区大小。long getTotalSpace() // 返回此抽象路径名指定的分区上可用于此虚拟机的字节数。long getUsableSpace()// 在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。void deleteOnExit()// 返回此抽象路径名的绝对路径名形式。File getAbsoluteFile() // 返回此抽象路径名的规范形式。File getCanonicalFile() // 返回此抽象路径名父目录的抽象路径名；如果此路径名没有指定父目录，则返回 null。File getParentFile() // 返回此抽象路径名的路径名字符串。String toString()// 返回此抽象路径名的绝对路径名字符串。String getAbsolutePath()// 返回此抽象路径名的规范路径名字符串。String getCanonicalPath() // 返回由此抽象路径名表示的文件或目录的名称。String getName()// 返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 null。String getParent()// 将此抽象路径名转换为一个路径名字符串。String getPath() // 测试应用程序是否可以执行此抽象路径名表示的文件。boolean canExecute()// 测试应用程序是否可以读取此抽象路径名表示的文件。boolean canRead()// 测试应用程序是否可以修改此抽象路径名表示的文件。boolean canWrite()// 当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。boolean createNewFile() // 删除此抽象路径名表示的文件或目录。boolean delete()// 测试此抽象路径名与给定对象是否相等。boolean equals(Object obj) // 测试此抽象路径名表示的文件或目录是否存在。boolean exists() // 测试此抽象路径名是否为绝对路径名。boolean isAbsolute()// 测试此抽象路径名表示的文件是否是一个目录。boolean isDirectory()// 测试此抽象路径名表示的文件是否是一个标准文件。boolean isFile()// 测试此抽象路径名指定的文件是否是一个隐藏文件。boolean isHidden()// 创建此抽象路径名指定的目录。boolean mkdir()// 创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。boolean mkdirs()// 重新命名此抽象路径名表示的文件。boolean renameTo(File dest)// 设置此抽象路径名所有者执行权限的一个便捷方法。boolean setExecutable(boolean executable)// 设置此抽象路径名的所有者或所有用户的执行权限。boolean setExecutable(boolean executable, boolean ownerOnly)// 设置此抽象路径名指定的文件或目录的最后一次修改时间。boolean setLastModified(long time)// 设置此抽象路径名所有者读权限的一个便捷方法。boolean setReadable(boolean readable)// 设置此抽象路径名的所有者或所有用户的读权限。boolean setReadable(boolean readable, boolean ownerOnly)// 标记此抽象路径名指定的文件或目录，从而只能对其进行读操作。boolean setReadOnly()// 设置此抽象路径名所有者写权限的一个便捷方法。boolean setWritable(boolean writable)// 设置此抽象路径名的所有者或所有用户的写权限。boolean setWritable(boolean writable, boolean ownerOnly)// 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。String[] list()// 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录。String[] list(FilenameFilter filter)// 返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。File[] listFiles()// 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。File[] listFiles(FileFilter filter)// 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。File[] listFiles(FilenameFilter filter)// 列出可用的文件系统根。static File[] listRoots()// 在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。static File createTempFile(String prefix, String suffix)// 在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。static File createTempFile(String prefix, String suffix, File directory) 二、创建文件 File 创建文件使用 file.createNewFile() 函数，因为有四种构造函数，所以有 4 种创建文件的情形。举例：在“dir”目录(相对路径)下新建文件“file1.txt”。12345678910111213141516171819202122232425262728293031323334// 第一种try &#123; File dir = new File(&quot;dir&quot;); // 获取目录“dir”对应的File对象 File file1 = new File(dir, &quot;file1.txt&quot;); file1.createNewFile();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;// 第二种try &#123; File file2 = new File(&quot;dir&quot;, &quot;file2.txt&quot;); file2.createNewFile();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;// 第三种try &#123; File file3 = new File(&quot;/home/sky/dir/file3.txt&quot;); //linux创建文件 //File file3 = new File(&quot;D:/dir/file4.txt&quot;); // windows创建文件 file3.createNewFile();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;// 第四种try &#123; URI uri = new URI(&quot;file:/home/skywang/dir/file4.txt&quot;); File file4 = new File(uri); file4.createNewFile();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 三、创建目录 根据相对路径创建目录12File dir = new File(&quot;dir&quot;);dir.mkdir(); 在当前路径下新建目录“dir”。 根据绝对路径新建目录123File dir = new File(&quot;/home/sky/dir&quot;); linux创建//File dir = new File(&quot;D:/dir&quot;); windows创建dir.mkdirs(); 新建目录“/home/sky/dir”。 创建目录第三种方式123URI uri = new URI(&quot;file:/home/sky/dir&quot;); File dir = new File(uri);sub.mkdir(); 四、创建子目录 123456789101112131415161718192021222324252627282930// 方法一// 在dir目录下新建sub1目录，并且在当前目录下 &quot;dir/sub1&quot;。// 它能正常运行的前提是“sub1”的父目录“dir”已经存在！File sub1 = new File(&quot;dir&quot;, &quot;sub1&quot;);sub1.mkdir();// 方法二// 在dir目录下新建sub2目录，并且在当前目录下 &quot;dir/sub2&quot;。// 它能正常运行的前提是“sub2”的父目录“dir”已经存在！File sub2 = new File(dir, &quot;sub2&quot;);sub2.mkdir();// 方法三// 在dir目录下新建sub3目录，并且在当前目录下 &quot;dir/sub3&quot;。// 它不需要dir已经存在，也能正常运行；若“sub3”的父母路不存在，// mkdirs()方法会自动创建父目录。File sub3 = new File(&quot;dir/sub3&quot;);sub3.mkdirs();// 方法四// 新建目录&quot;/home/skywang/dir/sub3&quot;。它不需要dir已经存在，// 也能正常运行；若“sub4”的父母路不存在，// mkdirs()方法会自动创建父目录。File sub4 = new File(&quot;/home/skywang/dir/sub4&quot;);sub4.mkdirs();// 方法五URI uri = new URI(&quot;file:/home/skywang/dir/sub5&quot;); File sub5 = new File(uri);sub5.mkdirs(); 五、目录操作示例 返回文件名数组String[] list()String[] list(FilenameFilter filter) 返回 File 数组File[] listFiles()File[] listFiles(FileFilter filter)File[] listFiles(FilenameFilter filter) 示例代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/** * File 类有一个 listFiles(FileNameFilter filter). * 只需要实现一个简单的 filter 就可以找到满足 filter 条件的所有文件。 * 例如我要在 E:\data\file_selector_test 目录下面查找以 .txt 结尾的文件 * * @author 先小涛 */class FileNameSelector implements FilenameFilter &#123; private String extension = &quot;.&quot;; public FileNameSelector(String fileExtensionNoDot) &#123; extension += fileExtensionNoDot; &#125; @Override public boolean accept(File dir, String name) &#123; return name.endsWith(extension); &#125; // 删除文件夹下的所有文件以及该文件夹 public static void deleteDirectory(File file) &#123; File[] fileArray = file.listFiles(); if (fileArray.length &gt; 0) &#123; for (File f : fileArray) &#123; if (f.isFile()) &#123; if (f.delete()) &#123; System.out.println(f + &quot;文件删除成功&quot;); &#125; else &#123; System.out.println(f + &quot;文件删除失败&quot;); &#125; &#125; else &#123; deleteDirectory(f); &#125; &#125; &#125; // 删除文件夹 if (file.delete()) &#123; System.out.println(file + &quot;文件夹删除成功&quot;); &#125; else &#123; System.out.println(file + &quot;文件夹删除失败&quot;); &#125; &#125; // 扫描指定文件夹下的所有文件，并输出 public static void findAllFiles(File f) &#123; // 判断给定的路径是否是目录 if (f.isDirectory()) &#123; File[] files = f.listFiles(); // 再依次循环进行判断 for (File file : files) &#123; // 继续把内容传入到 findAllFiles 方法之中进行验证 findAllFiles(file); &#125; &#125; else &#123; System.out.println(f); &#125; &#125; public static void main(String[] args) &#123; File directory = new File(&quot;E:\\test\\file_selector_test&quot;); // listFiles() 列出所有文件 File[] files = directory.listFiles(); System.out.println(&quot;\n目录&quot; + directory.getName() + &quot;下的所有文件&quot;); for (File file : files) &#123; System.out.print(&quot; &quot; + file.getName()); &#125; // listFiles(FileNameFilter filter) 列出所有.txt文件 File[] txtFiles = directory.listFiles(new FileNameSelector(&quot;txt&quot;)); System.out.println(&quot;\n目录&quot; + directory.getName() + &quot;下的.txt文件&quot;); for (File file : txtFiles) &#123; System.out.print(&quot; &quot; + file.getName()); &#125; // isDirectory() 判断是否为文件目录 if(directory.isDirectory()) &#123; System.out.println(directory.getPath() + &quot; is Directory&quot;); &#125; // isFile() 判断是否为文件 if(directory.isFile()) &#123; System.out.println(directory.getPath() + &quot; is File&quot;); &#125; // File.separator输出不同的系统中斜杠的方向 // 在windows中斜杠的方向是向右斜的\\ // 在Linux 中斜杠的方向是向左斜的// System.out.println(&quot;File.separator:&quot; + File.separator); String pathName = &quot;e:&quot; + File.separator + &quot;test&quot; + File.separator + &quot;file_selector_test&quot; + File.separator + &quot;io.txt&quot;; File f = new File(pathName); try &#123; // createNewFile() 方法：创建指定文件夹下的文件，如果文件夹不存在 // 会报&quot;找不到指定路径&quot;错误，应该首先手动创建该文件夹。返回值为 boolean // 若没有该文件，创建成功返回 true；若又该文件则创建失败返回 false System.out.println(f.createNewFile()); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; // delete() 方法：删除一个文件或者整个文件夹，返回值为布尔类型 // 如果删除的是文件夹，必须保证是一个空文件夹，否则删除失败 File f0 = new File(&quot;E:\\test\\file_selector_test\\io.txt&quot;); boolean boo = f0.delete(); if (boo) &#123; System.out.println(&quot;成功删除文件&quot;); &#125; else &#123; System.out.println(&quot;删除失败&quot;); &#125; // 调用创建的方法进行删除文件夹以及该文件夹下的所有文件 deleteDirectory(new File(&quot;E:\\test\\file_selector_test2&quot;)); File f1 = new File(&quot;e:&quot; + File.separator + &quot;test&quot;+File.separator+&quot;io.txt&quot;); // getPath() 方法：将此抽象路径名转换为一个路径名字符串 System.out.println(f1.getPath()); // getParent() 方法：返回此抽象路径名父目录的路径名字符串； // 如果此路径名没有指定父目录，则返回 nul System.out.println(f1.getParent()); if (f1.exists()) &#123; f1.delete(); &#125; else &#123; try &#123; System.out.println(f1.createNewFile()); &#125; catch(Exception e)&#123;&#125; &#125; // list()方法：返回一个字符串数组，这些字符串指定此抽象路径名 // 表示的目录中的文件和目录，列出的仅是名称。 File f2 = new File(&quot;E:\\test\\file_selector_test&quot;); String[] str = f2.list(); for(int i=0; i&lt;str.length; i++)&#123; System.out.println(str[i]); &#125; // 扫描某个路径下的所有文件 findAllFiles(new File(&quot;E:\\&quot;)); &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
