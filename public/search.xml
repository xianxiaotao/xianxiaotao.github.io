<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ANDROID 博客总目录</title>
      <link href="/9999/01/01/0%20ANDROID%20%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/"/>
      <url>/9999/01/01/0%20ANDROID%20%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e8b96a02e3716c3d.gif?imageMogr2/auto-orient/strip" alt="DESIGN PATTERN" width="100%"></p><blockquote><p>ANDROID 博客总目录<br>JAVA、DESIGN PATTERN、ANDROID、CUSTOM VIEW …</p></blockquote><details><summary>**06 THIRD PARY FRAMEWORK**</summary></details><details><summary>**05 CUSTOM VIEW**</summary>本篇从自定义控件的动画、绘图、视图三方面入手，分别讲解与自定义控件相关的各种知识，给大家系统的梳理相关知识。不仅适合 Android 初、中级水平从业者，也适合高水平从业者查漏补缺使用。内容摘自启舰所著的书籍[《Android 自定义控件开发入门与实践》](http://www.broadview.com.cn/book/93)。第1章  绘图基础[1.1 基本图形绘制](https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/)[1.2 路径](https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/)[1.3 文字](https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/)[1.4 Region](https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Region/)[1.5 Canvas(画布)](https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Canvas/)[1.6 控件的使用方法](https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/)第2章 视图动画[2.1 视图动画标签](https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/)[2.2 视图动画的代码实现](https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/)[2.3 插值器初探](https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/)[2.4 动画示例](https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E5%8A%A8%E7%94%BB%E7%A4%BA%E4%BE%8B/)[2.5 逐帧动画](https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E9%80%90%E5%B8%A7%E5%8A%A8%E7%94%BB/)第3章 属性动画[3.1 ValueAnimator 的基本使用](https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ValueAnimator%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/)[3.2 自定义插值器与 Evaluator](https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E5%80%BC%E5%99%A8%E4%B8%8E%20Evaluator/)[3.3 ValueAnimator 进阶——ofObject](https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ofObject/)[3.4 ObjectAnimator](https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ObjectAnimator/)[3.5 组合动画——AnimatorSet](https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94AnimatorSet/)[3.6 Animator 动画的 XML 实现](https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94Animator%20%E5%8A%A8%E7%94%BB%E7%9A%84%20XML%20%E5%AE%9E%E7%8E%B0/)第4章 属性动画进阶[4.1 PropertyValuesHolder 与 Keyframe](https://xianxiaotao.github.io/2019/07/04/05%20CUSTOM%20VIEW/04.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94PropertyValuesHolder%20%E4%B8%8E%20Keyframe/)[4.2 ViewPropertyAnimator](https://xianxiaotao.github.io/2019/07/04/05%20CUSTOM%20VIEW/04.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94ViewPropertyAnimator/)[4.3 为 ViewGroup 内的组件添加动画](https://xianxiaotao.github.io/2019/07/04/05%20CUSTOM%20VIEW/04.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E4%B8%BA%20ViewGroup%20%E5%86%85%E7%9A%84%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB/)[4.4 开源动画库 NineOldAndroids](https://xianxiaotao.github.io/2019/07/04/05%20CUSTOM%20VIEW/04.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94NineOldAndroids/)第5章 动画进阶[5.1 利用 PathMeasure 实现路径动画](https://xianxiaotao.github.io/2019/07/05/05%20CUSTOM%20VIEW/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/)[5.2 SVG 动画](https://xianxiaotao.github.io/2019/07/05/05%20CUSTOM%20VIEW/05.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94SVG%20%E5%8A%A8%E7%94%BB/)第6章 Paint 基本使用[6.1 硬件加速](https://xianxiaotao.github.io/2019/07/06/05%20CUSTOM%20VIEW/06.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/)[6.2 文字](https://xianxiaotao.github.io/2019/07/06/05%20CUSTOM%20VIEW/06.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/)[6.3 Paint 常用函数](https://xianxiaotao.github.io/2019/07/06/05%20CUSTOM%20VIEW/06.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/)第7章 绘图进阶[7.1 贝济埃曲线](https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E8%B4%9D%E6%B5%8E%E5%9F%83%E6%9B%B2%E7%BA%BF/)[7.2 setShadowLayer 与阴影效果](https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94setShadowLayer%20%E4%B8%8E%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/)[7.3 BlurMaskFilter 发光效果和图片阴影](https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94BlurMaskFilter%20%E5%8F%91%E5%85%89%E6%95%88%E6%9E%9C%E4%B8%8E%E5%9B%BE%E7%89%87%E9%98%B4%E5%BD%B1/)[7.4 Shader 与 BitmapShader](https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B8%8E%20BitmapShader/)[7.5 Shader 之 LinearGradient](https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20LinearGradient/)[7.6 Shader 之 RadialGradient](https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20RadialGradient/)第8章 混合模式[8.1 混合模式之 AvoidXfermode](https://xianxiaotao.github.io/2019/07/08/05%20CUSTOM%20VIEW/08.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AvoidXfermode/)[8.2 混合模式之 PorterDuffXfermode](https://xianxiaotao.github.io/2019/07/08/05%20CUSTOM%20VIEW/08.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode/)[8.3 PorterDuffXfermode 之源图像模式](https://xianxiaotao.github.io/2019/07/08/05%20CUSTOM%20VIEW/08.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode%20%E4%B9%8B%E6%BA%90%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F/)[8.4 目标图像模式与其他模式](https://xianxiaotao.github.io/2019/07/08/05%20CUSTOM%20VIEW/08.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%9B%AE%E6%A0%87%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F/)第9章 Canvas 与图层[9.1 获取 Canvas 对象的方法](https://xianxiaotao.github.io/2019/07/09/05%20CUSTOM%20VIEW/09.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96%20Canvas%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/)[9.2 图层与画布](https://xianxiaotao.github.io/2019/07/09/05%20CUSTOM%20VIEW/09.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E5%9B%BE%E5%B1%82%E4%B8%8E%E7%94%BB%E5%B8%83/)[9.3 Flag 的具体含义 已过时](https://xianxiaotao.github.io/2019/07/09/05%20CUSTOM%20VIEW/09.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94Flag%20%E7%9A%84%E5%85%B7%E4%BD%93%E5%90%AB%E4%B9%89/)[9.4 恢复画布](https://xianxiaotao.github.io/2019/07/09/05%20CUSTOM%20VIEW/09.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E6%81%A2%E5%A4%8D%E7%94%BB%E5%B8%83/)第10章 Android 画布[10.1 ShapeDrawable](https://xianxiaotao.github.io/2019/07/10/05%20CUSTOM%20VIEW/10.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94ShapeDrawable/)[10.2 Bitmap](https://xianxiaotao.github.io/2019/07/10/05%20CUSTOM%20VIEW/10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap/)[10.3 SurfaceView](https://xianxiaotao.github.io/2019/07/10/05%20CUSTOM%20VIEW/10.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94SurfaceView/)第11章 Matrix 与坐标变换[11.1 矩阵运算](https://xianxiaotao.github.io/2019/07/11/05%20CUSTOM%20VIEW/11.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/)[11.2 ColorMatrix 色彩变换](https://xianxiaotao.github.io/2019/07/11/05%20CUSTOM%20VIEW/11.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94ColorMatrix%20%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2/)第12章 封装控件[12.1 自定义属性与自定义 Style](https://xianxiaotao.github.io/2019/07/12/05%20CUSTOM%20VIEW/12.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%20Style/)[12.2 测量与布局](https://xianxiaotao.github.io/2019/07/12/05%20CUSTOM%20VIEW/12.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E6%B5%8B%E9%87%8F%E5%92%8C%E5%B8%83%E5%B1%80/)[12.3 实现 FlowLayout 容器](https://xianxiaotao.github.io/2019/07/12/05%20CUSTOM%20VIEW/12.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%20FlowLayout%20%E5%AE%B9%E5%99%A8/)第13章 控件高级属性[13.1 GestureDetector 手势检测](https://xianxiaotao.github.io/2019/07/13/05%20CUSTOM%20VIEW/13.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94GestureDetector%20%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B/)[13.2 Window 与 WindowManager](https://xianxiaotao.github.io/2019/07/13/05%20CUSTOM%20VIEW/13.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94Window%20%E4%B8%8E%20WindowManager/)</details><details><summary>**4 MVP**</summary></details><details><summary>**03 ANDROID**</summary></details><details><summary>**02 DESIGN PATTERN**</summary>[《ANDROID 源码设计模式解析与实战 第2版》](http://product.dangdang.com/25102876.html)，业界第 1 本 ANDROID 源码讲解设计模式的书，本书不仅分析了 ANDROID 源代码的设计模式，更结合实例演示了如何使用这些设计模式。有经济能力的请点击链接购买正版书，支持一下作者。概述：[00 设计模式概述](https://xianxiaotao.github.io/1901/01/02/02%20DESIGN%20PATTERN/00%20设计模式概述/)原则：[00.1 ANDROID 面向对象的六大原则——单一职责原则](https://xianxiaotao.github.io/1901/01/03/02%20DESIGN%20PATTERN/00.1%20ANDROID%20面向对象的六大原则——单一职责原则/)[00.2 ANDROID 面向对象的六大原则——开闭原则](https://xianxiaotao.github.io/1901/01/04/02%20DESIGN%20PATTERN/00.2%20ANDROID%20面向对象的六大原则——开闭原则/)[00.3 ANDROID 面向对象的六大原则——里氏替换原则](https://xianxiaotao.github.io/1901/01/05/02%20DESIGN%20PATTERN/00.3%20ANDROID%20面向对象的六大原则——里氏替换原则/)[00.4 ANDROID 面向对象的六大原则——依赖倒置原则](https://xianxiaotao.github.io/1901/01/06/02%20DESIGN%20PATTERN/00.4%20ANDROID%20面向对象的六大原则——依赖倒置原则/)[00.5 ANDROID 面向对象的六大原则——接口隔离原则](https://xianxiaotao.github.io/1901/01/07/02%20DESIGN%20PATTERN/00.5%20ANDROID%20面向对象的六大原则——接口隔离原则/)[00.6 ANDROID 面向对象的六大原则——迪米特原则](https://xianxiaotao.github.io/1901/01/08/02%20DESIGN%20PATTERN/00.6%20ANDROID%20面向对象的六大原则——迪米特原则/)目录：[01 设计模式——单例模式](https://xianxiaotao.github.io/1901/01/09/02%20DESIGN%20PATTERN/01%20设计模式——单例模式/)[02 设计模式——建造者模式](https://xianxiaotao.github.io/1901/01/10/02%20DESIGN%20PATTERN/02%20设计模式——建造者模式/)[03 设计模式——原型模式](https://xianxiaotao.github.io/1901/01/11/02%20DESIGN%20PATTERN/03%20设计模式——原型模式)[04 设计模式——工厂方法模式](https://xianxiaotao.github.io/1901/01/12/02%20DESIGN%20PATTERN/04%20设计模式——工厂方法模式/)[05 设计模式——抽象工厂模式](https://xianxiaotao.github.io/1901/01/13/02%20DESIGN%20PATTERN/05%20设计模式——抽象工厂模式/)[06 设计模式——策略模式](https://xianxiaotao.github.io/1901/01/14/02%20DESIGN%20PATTERN/06%20设计模式——策略模式/)[07 设计模式——状态模式](https://xianxiaotao.github.io/1901/01/15/02%20DESIGN%20PATTERN/07%20设计模式——状态模式/)[08 设计模式——责任链模式](https://xianxiaotao.github.io/1901/01/16/02%20DESIGN%20PATTERN/08%20设计模式——责任链模式/)[09 设计模式——解释器模式](https://xianxiaotao.github.io/1901/01/17/02%20DESIGN%20PATTERN/09%20设计模式——解释器模式/)[10 设计模式——命令模式](https://xianxiaotao.github.io/1901/01/18/02%20DESIGN%20PATTERN/10%20设计模式——命令模式/)[11 设计模式——观察者模式](https://xianxiaotao.github.io/1901/01/19/02%20DESIGN%20PATTERN/11%20设计模式——观察者模式/)[12 设计模式——备忘录模式](https://xianxiaotao.github.io/1901/01/20/02%20DESIGN%20PATTERN/12%20设计模式——备忘录模式/)[13 设计模式——迭代器模式](https://xianxiaotao.github.io/1901/01/21/02%20DESIGN%20PATTERN/13%20设计模式——迭代器模式/)[14 设计模式——模板方法模式](https://xianxiaotao.github.io/1901/01/22/02%20DESIGN%20PATTERN/14%20设计模式——模板方法模式/)[15 设计模式——访问者模式](https://xianxiaotao.github.io/1901/01/23/02%20DESIGN%20PATTERN/15%20设计模式——访问者模式/)[16 设计模式——中介者模式](https://xianxiaotao.github.io/1901/01/24/02%20DESIGN%20PATTERN/16%20设计模式——中介者模式/)[17 设计模式——代理模式](https://xianxiaotao.github.io/1901/01/25/02%20DESIGN%20PATTERN/17%20设计模式——代理模式/)[18 设计模式——组合模式](https://xianxiaotao.github.io/1901/01/26/02%20DESIGN%20PATTERN/18%20设计模式——组合模式/)[19 设计模式——适配器模式](https://xianxiaotao.github.io/1901/01/27/02%20DESIGN%20PATTERN/19%20设计模式——适配器模式/)[20 设计模式——装饰模式](https://xianxiaotao.github.io/1901/01/28/02%20DESIGN%20PATTERN/20%20设计模式——装饰模式/)[21 设计模式——享元模式](https://xianxiaotao.github.io/1901/02/01/02%20DESIGN%20PATTERN/21%20设计模式——享元模式/)[22 设计模式——外观模式](https://xianxiaotao.github.io/1901/02/02/02%20DESIGN%20PATTERN/22%20设计模式——外观模式/)[23 设计模式——桥接模式](https://xianxiaotao.github.io/1901/01/02/03/02%20DESIGN%20PATTERN/23%20设计模式——桥接模式/)应用：[31 设计模式实际应用一](https://xianxiaotao.github.io/1901/03/01/02%20DESIGN%20PATTERN/31%20设计模式实际应用一/)</details><details><summary>**01 JAVA**</summary>第 1 ~ 15 篇文章详细介绍了 Java 相关技术：文件、流、多线程、泛型、注解、反射和网络编程。夯实 Java 基础后，可大步奔向 ANDROID 端或 WEB 端开发。[01 Java File](https://xianxiaotao.github.io/1900/01/01/01%20JAVA/01%20Java%20File/)[02 Java FileUtils](https://xianxiaotao.github.io/1900/01/02/01%20JAVA/02%20Java%20FileUtils/)[03 Java IO Stream](https://xianxiaotao.github.io/1900/01/03/01%20JAVA/03%20Java%20IO%20Stream/)[04 Java IOUtils](https://xianxiaotao.github.io/1900/01/04/01%20JAVA/04%20Java%20IOUtils/)[05 Java Thread](https://xianxiaotao.github.io/1900/01/05/01%20JAVA/05%20Java%20Thread/)[06 Java Generic](https://xianxiaotao.github.io/1900/01/06/01%20JAVA/06%20Java%20Generic/)[07 Java Annotation](https://xianxiaotao.github.io/1900/01/07/01%20JAVA/07%20Java%20Annotation/)[08 Java Relfect](https://xianxiaotao.github.io/1900/01/08/01%20JAVA/08%20Java%20Relfect/)[09 Java RelfectUtils](https://xianxiaotao.github.io/1900/01/09/01%20JAVA/09%20Java%20RelfectUtils/)[10 反射一：基本类周边信息获取](https://xianxiaotao.github.io/1900/01/10/01%20JAVA/10%20%E5%8F%8D%E5%B0%84%E4%B8%80%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%91%A8%E8%BE%B9%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/)[11 反射二：泛型相关周边信息获取](https://xianxiaotao.github.io/1900/01/11/01%20JAVA/11%20%E5%8F%8D%E5%B0%84%E4%BA%8C%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%91%A8%E8%BE%B9%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/)[12 反射三：类内部信息获取](https://xianxiaotao.github.io/1900/01/12/01%20JAVA/12%20%E5%8F%8D%E5%B0%84%E4%B8%89%EF%BC%9A%E7%B1%BB%E5%86%85%E9%83%A8%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/)[13 Java Socket](https://xianxiaotao.github.io/1900/01/13/01%20JAVA/13%20Java%20Socket/)[14 Java Socket 聊天室原理](https://xianxiaotao.github.io/1900/01/14/01%20JAVA/14%20Java%20Socket%20%E8%81%8A%E5%A4%A9%E5%AE%A4%E5%8E%9F%E7%90%86/)[15 Java Socket 如何演化成 Tomcat](https://xianxiaotao.github.io/1900/01/15/01%20JAVA/15%20Java%20Socket%20%E5%A6%82%E4%BD%95%E6%BC%94%E5%8C%96%E6%88%90%20Tomcat/)[JAVA 8 Interface](https://xianxiaotao.github.io/1900/02/01/01%20JAVA/JAVA%208%20Interface/)[JAVA 8 Lambda](https://xianxiaotao.github.io/1900/02/02/01%20JAVA/JAVA%208%20LocalDate/)[JAVA 8 LocalDate](https://xianxiaotao.github.io/1900/02/03/01%20JAVA/JAVA%208%20Lambda/)[JAVA | 使用克隆防止破坏封装性](https://xianxiaotao.github.io/1900/03/01/01%20JAVA/JAVA%20%7C%20%E4%BD%BF%E7%94%A8%E5%85%8B%E9%9A%86%E9%98%B2%E6%AD%A2%E7%A0%B4%E5%9D%8F%E5%B0%81%E8%A3%85%E6%80%A7/)[JAVA | equals 的正确姿势](https://xianxiaotao.github.io/1900/03/02/01%20JAVA/JAVA%20%7C%20equals%20%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/)[JAVA | 多线程断点下载](https://xianxiaotao.github.io/1900/03/03/01%20JAVA/JAVA%20%7C%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%AD%E7%82%B9%E4%B8%8B%E8%BD%BD/)</details>]]></content>
      
      
      <categories>
          
          <category> CATALOG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CATALOG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>精通 Android 自定义 View 目录</title>
      <link href="/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E7%9B%AE%E5%BD%95/"/>
      <url>/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ac4e9e183c556a9a.gif?imageMogr2/auto-orient/strip" width="100%"></p><p>本篇从自定义控件的动画、绘图、视图三方面入手，分别讲解与自定义控件相关的各种知识，给大家系统的梳理相关知识。不仅适合 Android 初、中级水平从业者，也适合高水平从业者查漏补缺使用。</p><p>内容摘自启舰所著的书籍<a href="http://www.broadview.com.cn/book/93" target="_blank" rel="external">《Android 自定义控件开发入门与实践》</a>。</p><h2 id="第1章-绘图基础"><a href="#第1章-绘图基础" class="headerlink" title="第1章  绘图基础"></a>第1章  绘图基础</h2><h3 id="1-1-基本图形绘制"><a href="#1-1-基本图形绘制" class="headerlink" title="1.1 基本图形绘制"></a><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/" target="_blank" rel="external">1.1 基本图形绘制</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/#jump1" target="_blank" rel="external">1.1.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/#jump2" target="_blank" rel="external">1.1.2 画笔的基本设置</a><br><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/#jump3" target="_blank" rel="external">1.1.3 Canvas使用基础</a><br><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/#jump4" target="_blank" rel="external">1.1.4 Rect与RectF</a><br><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/#jump5" target="_blank" rel="external">1.1.5 Color</a></p><h3 id="1-2-路径"><a href="#1-2-路径" class="headerlink" title="1.2 路径"></a><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/" target="_blank" rel="external">1.2 路径</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/#jump1" target="_blank" rel="external">1.2.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/#jump2" target="_blank" rel="external">1.2.2 直线路径</a><br><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/#jump3" target="_blank" rel="external">1.2.3 弧线路径</a><br><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/#jump4" target="_blank" rel="external">1.2.4 addXXX系列函数</a><br><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/#jump5" target="_blank" rel="external">1.2.5 填充模式</a><br><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/#jump6" target="_blank" rel="external">1.2.6 重置路径</a><br><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/#jump7" target="_blank" rel="external">1.2.7 示例:蜘蛛网状图</a></p><h3 id="1-3-文字"><a href="#1-3-文字" class="headerlink" title="1.3 文字"></a><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/" target="_blank" rel="external">1.3 文字</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/#jump1" target="_blank" rel="external">1.3.1 Paint设置</a><br><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/#jump2" target="_blank" rel="external">1.3.2 Canvas绘制文本</a><br><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/#jump3" target="_blank" rel="external">1.3.3 设置字体样式</a></p><h3 id="1-4-Region"><a href="#1-4-Region" class="headerlink" title="1.4 Region"></a><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Region/" target="_blank" rel="external">1.4 Region</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Region/#jump1" target="_blank" rel="external">1.4.1 构造Region</a><br><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Region/#jump2" target="_blank" rel="external">1.4.2 枚举区域——RegionIterator类</a><br><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Region/#jump3" target="_blank" rel="external">1.4.3 区域相交</a><br><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Region/#jump4" target="_blank" rel="external">1.4.4 其他函数</a></p><h3 id="1-5-Canvas-画布"><a href="#1-5-Canvas-画布" class="headerlink" title="1.5 Canvas(画布)"></a><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Canvas/" target="_blank" rel="external">1.5 Canvas(画布)</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Canvas/#jump1" target="_blank" rel="external">1.5.1 Canvas变换</a><br><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Canvas/#jump2" target="_blank" rel="external">1.5.2 画布的保存与恢复</a><br><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Canvas/#jump3" target="_blank" rel="external">1.5.3 示例一:圆形头像</a><br><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Canvas/#jump4" target="_blank" rel="external">1.5.4 示例二:裁剪动画</a></p><h3 id="1-6-控件的使用方法"><a href="#1-6-控件的使用方法" class="headerlink" title="1.6 控件的使用方法"></a><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/" target="_blank" rel="external">1.6 控件的使用方法</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#jump1" target="_blank" rel="external">1.6.1 控件概述</a><br><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#jump2" target="_blank" rel="external">1.6.2 通过XML引入控件</a><br><a href="https://xianxiaotao.github.io/2019/07/01/05%20CUSTOM%20VIEW/01.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#jump3" target="_blank" rel="external">1.6.3 动态添加控件</a></p><h2 id="第2章-视图动画"><a href="#第2章-视图动画" class="headerlink" title="第2章 视图动画"></a>第2章 视图动画</h2><h3 id="2-1-视图动画标签"><a href="#2-1-视图动画标签" class="headerlink" title="2.1 视图动画标签"></a><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/" target="_blank" rel="external">2.1 视图动画标签</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/#jump1" target="_blank" rel="external">2.1.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/#jump2" target="_blank" rel="external">2.1.2 scale 标签</a><br><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/#jump3" target="_blank" rel="external">2.1.3 Animation 继承属性</a><br><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/#jump4" target="_blank" rel="external">2.1.4 alpha 标签</a><br><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/#jump5" target="_blank" rel="external">2.1.5 rotate 标签</a><br><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/#jump6" target="_blank" rel="external">2.1.6 translate 标签</a><br><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/#jump7" target="_blank" rel="external">2.1.7 set 标签</a></p><h3 id="2-2-视图动画的代码实现"><a href="#2-2-视图动画的代码实现" class="headerlink" title="2.2 视图动画的代码实现"></a><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/" target="_blank" rel="external">2.2 视图动画的代码实现</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/#jump1" target="_blank" rel="external">2.2.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/#jump2" target="_blank" rel="external">2.2.2 ScaleAnimation</a><br><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/#jump3" target="_blank" rel="external">2.2.3 AlphaAnimation</a><br><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/#jump4" target="_blank" rel="external">2.2.4 RotateAnimation</a><br><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/#jump5" target="_blank" rel="external">2.2.5 TranslateAnimation</a><br><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/#jump6" target="_blank" rel="external">2.2.6 AnimationSet</a><br><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/#jump7" target="_blank" rel="external">2.2.7 Animation</a></p><h3 id="2-3-插值器初探"><a href="#2-3-插值器初探" class="headerlink" title="2.3 插值器初探"></a><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/" target="_blank" rel="external">2.3 插值器初探</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump1" target="_blank" rel="external">2.3.1 AccelerateDecelerateInterpolator</a><br><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump2" target="_blank" rel="external">2.3.2 AccelerateInterpolator</a><br><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump3" target="_blank" rel="external">2.3.3 DecelerateInterpolator</a><br><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump4" target="_blank" rel="external">2.3.4 LinearInterpolator</a><br><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump5" target="_blank" rel="external">2.3.5 BounceInterpolator</a><br><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump6" target="_blank" rel="external">2.3.6 AnticipateInterpolator</a><br><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump7" target="_blank" rel="external">2.3.7 OvershootInterpolator</a><br><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump8" target="_blank" rel="external">2.3.8 AnticipateOvershootInterpolator</a><br><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump9" target="_blank" rel="external">2.3.9 CycleInterpolator</a></p><h3 id="2-4-动画示例"><a href="#2-4-动画示例" class="headerlink" title="2.4 动画示例"></a><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E5%8A%A8%E7%94%BB%E7%A4%BA%E4%BE%8B/" target="_blank" rel="external">2.4 动画示例</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E5%8A%A8%E7%94%BB%E7%A4%BA%E4%BE%8B/#jump1" target="_blank" rel="external">2.4.1 镜头由远及近效果</a><br><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E5%8A%A8%E7%94%BB%E7%A4%BA%E4%BE%8B/#jump2" target="_blank" rel="external">2.4.2 加载框效果</a><br><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E5%8A%A8%E7%94%BB%E7%A4%BA%E4%BE%8B/#jump3" target="_blank" rel="external">2.4.3 扫描动画</a></p><h3 id="2-5-逐帧动画"><a href="#2-5-逐帧动画" class="headerlink" title="2.5 逐帧动画"></a><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E9%80%90%E5%B8%A7%E5%8A%A8%E7%94%BB/" target="_blank" rel="external">2.5 逐帧动画</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E9%80%90%E5%B8%A7%E5%8A%A8%E7%94%BB/#jump1" target="_blank" rel="external">2.5.1 XML 实现</a><br><a href="https://xianxiaotao.github.io/2019/07/02/05%20CUSTOM%20VIEW/02.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E9%80%90%E5%B8%A7%E5%8A%A8%E7%94%BB/#jump2" target="_blank" rel="external">2.5.2 代码实现</a></p><h2 id="第3章-属性动画"><a href="#第3章-属性动画" class="headerlink" title="第3章 属性动画"></a>第3章 属性动画</h2><h3 id="3-1-ValueAnimator-的基本使用"><a href="#3-1-ValueAnimator-的基本使用" class="headerlink" title="3.1 ValueAnimator 的基本使用"></a><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ValueAnimator%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">3.1 ValueAnimator 的基本使用</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ValueAnimator%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#jump1" target="_blank" rel="external">3.1.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ValueAnimator%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#jump2" target="_blank" rel="external">3.1.2 ValueAnimator 的简单使用</a><br><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ValueAnimator%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#jump3" target="_blank" rel="external">3.1.3 常用函数</a><br><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ValueAnimator%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#jump4" target="_blank" rel="external">3.1.4 示例：弹跳加载中效果</a></p><h3 id="3-2-自定义插值器与-Evaluator"><a href="#3-2-自定义插值器与-Evaluator" class="headerlink" title="3.2 自定义插值器与 Evaluator"></a><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E5%80%BC%E5%99%A8%E4%B8%8E%20Evaluator/" target="_blank" rel="external">3.2 自定义插值器与 Evaluator</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E5%80%BC%E5%99%A8%E4%B8%8E%20Evaluator/#jump1" target="_blank" rel="external">3.2.1 自定义插值器</a><br><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E5%80%BC%E5%99%A8%E4%B8%8E%20Evaluator/#jump2" target="_blank" rel="external">3.2.2 Evaluator</a></p><h3 id="3-3-ValueAnimator-进阶——ofObject"><a href="#3-3-ValueAnimator-进阶——ofObject" class="headerlink" title="3.3 ValueAnimator 进阶——ofObject"></a><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ofObject/" target="_blank" rel="external">3.3 ValueAnimator 进阶——ofObject</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ofObject/#jump1" target="_blank" rel="external">3.3.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ofObject/#jump2" target="_blank" rel="external">3.3.2 示例：抛物动画</a></p><h3 id="3-4-ObjectAnimator"><a href="#3-4-ObjectAnimator" class="headerlink" title="3.4 ObjectAnimator"></a><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ObjectAnimator/" target="_blank" rel="external">3.4 ObjectAnimator</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ObjectAnimator/#jump1" target="_blank" rel="external">3.4.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ObjectAnimator/#jump2" target="_blank" rel="external">3.4.2 ObjectAnimator 动画原理</a><br><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ObjectAnimator/#jump3" target="_blank" rel="external">3.4.3 自定义 ObjectAnimator 属性</a><br><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ObjectAnimator/#jump4" target="_blank" rel="external">3.4.4 何时需要实现对应的 get 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ObjectAnimator/#jump5" target="_blank" rel="external">3.4.5 常用函数</a></p><h3 id="3-5-组合动画——AnimatorSet"><a href="#3-5-组合动画——AnimatorSet" class="headerlink" title="3.5 组合动画——AnimatorSet"></a><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94AnimatorSet/" target="_blank" rel="external">3.5 组合动画——AnimatorSet</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94AnimatorSet/#jump1" target="_blank" rel="external">3.5.1 playSequentially() 与 playTogether() 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94AnimatorSet/#jump2" target="_blank" rel="external">3.5.2 AnimatorSet.Builder</a><br><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94AnimatorSet/#jump3" target="_blank" rel="external">3.5.3 AnimatorSet 监听器</a><br><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94AnimatorSet/#jump4" target="_blank" rel="external">3.5.4 常用函数</a><br><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94AnimatorSet/#jump5" target="_blank" rel="external">3.5.5 示例：路径动画</a></p><h3 id="3-6-Animator-动画的-XML-实现"><a href="#3-6-Animator-动画的-XML-实现" class="headerlink" title="3.6 Animator 动画的 XML 实现"></a><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94Animator%20%E5%8A%A8%E7%94%BB%E7%9A%84%20XML%20%E5%AE%9E%E7%8E%B0/" target="_blank" rel="external">3.6 Animator 动画的 XML 实现</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94Animator%20%E5%8A%A8%E7%94%BB%E7%9A%84%20XML%20%E5%AE%9E%E7%8E%B0/#jump1" target="_blank" rel="external">3.6.1 animator 标签</a><br><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94Animator%20%E5%8A%A8%E7%94%BB%E7%9A%84%20XML%20%E5%AE%9E%E7%8E%B0/#jump2" target="_blank" rel="external">3.6.2 objectAnimator 标签</a><br><a href="https://xianxiaotao.github.io/2019/07/03/05%20CUSTOM%20VIEW/03.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94Animator%20%E5%8A%A8%E7%94%BB%E7%9A%84%20XML%20%E5%AE%9E%E7%8E%B0/#jump3" target="_blank" rel="external">3.6.3 set 标签</a></p><h2 id="第4章-属性动画进阶"><a href="#第4章-属性动画进阶" class="headerlink" title="第4章 属性动画进阶"></a>第4章 属性动画进阶</h2><h3 id="4-1-PropertyValuesHolder-与-Keyframe"><a href="#4-1-PropertyValuesHolder-与-Keyframe" class="headerlink" title="4.1 PropertyValuesHolder 与 Keyframe"></a><a href="https://xianxiaotao.github.io/2019/07/04/05%20CUSTOM%20VIEW/04.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94PropertyValuesHolder%20%E4%B8%8E%20Keyframe/" target="_blank" rel="external">4.1 PropertyValuesHolder 与 Keyframe</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/04/05%20CUSTOM%20VIEW/04.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94PropertyValuesHolder%20%E4%B8%8E%20Keyframe/#jump1" target="_blank" rel="external">4.1.1 PropertyValuesHolder</a><br><a href="https://xianxiaotao.github.io/2019/07/04/05%20CUSTOM%20VIEW/04.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94PropertyValuesHolder%20%E4%B8%8E%20Keyframe/#jump2" target="_blank" rel="external">4.1.2 Keyframe</a><br><a href="https://xianxiaotao.github.io/2019/07/04/05%20CUSTOM%20VIEW/04.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94PropertyValuesHolder%20%E4%B8%8E%20Keyframe/#jump3" target="_blank" rel="external">4.1.3 PropertyValuesHolder 其他函数</a><br><a href="https://xianxiaotao.github.io/2019/07/04/05%20CUSTOM%20VIEW/04.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94PropertyValuesHolder%20%E4%B8%8E%20Keyframe/#jump4" target="_blank" rel="external">4.1.4 示例：电话响铃效果</a></p><h3 id="4-2-ViewPropertyAnimator"><a href="#4-2-ViewPropertyAnimator" class="headerlink" title="4.2 ViewPropertyAnimator"></a><a href="https://xianxiaotao.github.io/2019/07/04/05%20CUSTOM%20VIEW/04.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94ViewPropertyAnimator/" target="_blank" rel="external">4.2 ViewPropertyAnimator</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/04/05%20CUSTOM%20VIEW/04.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94ViewPropertyAnimator/#jump1" target="_blank" rel="external">4.2.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/04/05%20CUSTOM%20VIEW/04.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94ViewPropertyAnimator/#jump2" target="_blank" rel="external">4.2.2 常用函数</a></p><h3 id="4-3-为-ViewGroup-内的组件添加动画"><a href="#4-3-为-ViewGroup-内的组件添加动画" class="headerlink" title="4.3 为 ViewGroup 内的组件添加动画"></a><a href="https://xianxiaotao.github.io/2019/07/04/05%20CUSTOM%20VIEW/04.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E4%B8%BA%20ViewGroup%20%E5%86%85%E7%9A%84%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB/" target="_blank" rel="external">4.3 为 ViewGroup 内的组件添加动画</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/04/05%20CUSTOM%20VIEW/04.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E4%B8%BA%20ViewGroup%20%E5%86%85%E7%9A%84%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB/#jump1" target="_blank" rel="external">4.3.1 animateLayoutChanges 属性</a><br><a href="https://xianxiaotao.github.io/2019/07/04/05%20CUSTOM%20VIEW/04.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E4%B8%BA%20ViewGroup%20%E5%86%85%E7%9A%84%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB/#jump2" target="_blank" rel="external">4.3.2 LayoutTransition</a><br><a href="https://xianxiaotao.github.io/2019/07/04/05%20CUSTOM%20VIEW/04.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E4%B8%BA%20ViewGroup%20%E5%86%85%E7%9A%84%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB/#jump3" target="_blank" rel="external">4.3.3 其他函数</a></p><h3 id="4-4-开源动画库-NineOldAndroids"><a href="#4-4-开源动画库-NineOldAndroids" class="headerlink" title="4.4 开源动画库 NineOldAndroids"></a><a href="https://xianxiaotao.github.io/2019/07/04/05%20CUSTOM%20VIEW/04.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94NineOldAndroids/" target="_blank" rel="external">4.4 开源动画库 NineOldAndroids</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/04/05%20CUSTOM%20VIEW/04.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94NineOldAndroids/#jump1" target="_blank" rel="external">4.4.1 NineOldAndroids 中的 ViewPropertyAnimator</a><br><a href="https://xianxiaotao.github.io/2019/07/04/05%20CUSTOM%20VIEW/04.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94NineOldAndroids/#jump2" target="_blank" rel="external">4.4.2 NineOldAndroids 中的 ViewHelper</a></p><h2 id="第5章-动画进阶"><a href="#第5章-动画进阶" class="headerlink" title="第5章 动画进阶"></a>第5章 动画进阶</h2><h3 id="5-1-利用-PathMeasure-实现路径动画"><a href="#5-1-利用-PathMeasure-实现路径动画" class="headerlink" title="5.1 利用 PathMeasure 实现路径动画"></a><a href="https://xianxiaotao.github.io/2019/07/05/05%20CUSTOM%20VIEW/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/" target="_blank" rel="external">5.1 利用 PathMeasure 实现路径动画</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/05/05%20CUSTOM%20VIEW/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/#jump1" target="_blank" rel="external">5.1.1 初始化</a><br><a href="https://xianxiaotao.github.io/2019/07/05/05%20CUSTOM%20VIEW/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/#jump2" target="_blank" rel="external">5.1.2 简单函数使用</a><br><a href="https://xianxiaotao.github.io/2019/07/05/05%20CUSTOM%20VIEW/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/#jump3" target="_blank" rel="external">5.1.3 getSegment() 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/05/05%20CUSTOM%20VIEW/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/#jump4" target="_blank" rel="external">5.1.4 getPosTan() 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/05/05%20CUSTOM%20VIEW/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/#jump5" target="_blank" rel="external">5.1.5 getMatrix() 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/05/05%20CUSTOM%20VIEW/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/#jump6" target="_blank" rel="external">5.1.6 示例：支付宝支付成功动画</a></p><h3 id="5-2-SVG-动画"><a href="#5-2-SVG-动画" class="headerlink" title="5.2 SVG 动画"></a><a href="https://xianxiaotao.github.io/2019/07/05/05%20CUSTOM%20VIEW/05.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94SVG%20%E5%8A%A8%E7%94%BB/" target="_blank" rel="external">5.2 SVG 动画</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/05/05%20CUSTOM%20VIEW/05.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94SVG%20%E5%8A%A8%E7%94%BB/#jump1" target="_blank" rel="external">5.2.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/05/05%20CUSTOM%20VIEW/05.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94SVG%20%E5%8A%A8%E7%94%BB/#jump2" target="_blank" rel="external">5.2.2 vector 标签与图像显示</a><br><a href="https://xianxiaotao.github.io/2019/07/05/05%20CUSTOM%20VIEW/05.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94SVG%20%E5%8A%A8%E7%94%BB/#jump3" target="_blank" rel="external">5.2.3 动态 Vector</a><br><a href="https://xianxiaotao.github.io/2019/07/05/05%20CUSTOM%20VIEW/05.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94SVG%20%E5%8A%A8%E7%94%BB/#jump4" target="_blank" rel="external">5.2.4 示例：输入搜索动画</a></p><h2 id="第6章-Paint-基本使用"><a href="#第6章-Paint-基本使用" class="headerlink" title="第6章 Paint 基本使用"></a>第6章 Paint 基本使用</h2><h3 id="6-1-硬件加速"><a href="#6-1-硬件加速" class="headerlink" title="6.1 硬件加速"></a><a href="https://xianxiaotao.github.io/2019/07/06/05%20CUSTOM%20VIEW/06.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/" target="_blank" rel="external">6.1 硬件加速</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/06/05%20CUSTOM%20VIEW/06.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/#jump1" target="_blank" rel="external">6.1.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/06/05%20CUSTOM%20VIEW/06.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/#jump2" target="_blank" rel="external">6.1.2 软件绘制与硬件加速的区别</a><br><a href="https://xianxiaotao.github.io/2019/07/06/05%20CUSTOM%20VIEW/06.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/#jump3" target="_blank" rel="external">6.1.3 禁用 GPU 硬件加速的方法</a></p><h3 id="6-2-文字"><a href="#6-2-文字" class="headerlink" title="6.2 文字"></a><a href="https://xianxiaotao.github.io/2019/07/06/05%20CUSTOM%20VIEW/06.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/" target="_blank" rel="external">6.2 文字</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/06/05%20CUSTOM%20VIEW/06.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/#jump1" target="_blank" rel="external">6.2.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/06/05%20CUSTOM%20VIEW/06.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/#jump2" target="_blank" rel="external">6.2.2 绘图四格线与 FontMetrics</a><br><a href="https://xianxiaotao.github.io/2019/07/06/05%20CUSTOM%20VIEW/06.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/#jump3" target="_blank" rel="external">6.2.3 常用函数</a><br><a href="https://xianxiaotao.github.io/2019/07/06/05%20CUSTOM%20VIEW/06.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/#jump4" target="_blank" rel="external">6.2.4 示例：定点写字</a></p><h3 id="6-3-Paint-常用函数"><a href="#6-3-Paint-常用函数" class="headerlink" title="6.3 Paint 常用函数"></a><a href="https://xianxiaotao.github.io/2019/07/06/05%20CUSTOM%20VIEW/06.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" target="_blank" rel="external">6.3 Paint 常用函数</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/06/05%20CUSTOM%20VIEW/06.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/#jump1" target="_blank" rel="external">6.3.1 基本设置函数</a><br><a href="https://xianxiaotao.github.io/2019/07/06/05%20CUSTOM%20VIEW/06.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/#jump2" target="_blank" rel="external">6.3.2 字体相关函数</a></p><h2 id="第7章-绘图进阶"><a href="#第7章-绘图进阶" class="headerlink" title="第7章 绘图进阶"></a>第7章 绘图进阶</h2><h3 id="7-1-贝济埃曲线"><a href="#7-1-贝济埃曲线" class="headerlink" title="7.1 贝济埃曲线"></a><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E8%B4%9D%E6%B5%8E%E5%9F%83%E6%9B%B2%E7%BA%BF/" target="_blank" rel="external">7.1 贝济埃曲线</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E8%B4%9D%E6%B5%8E%E5%9F%83%E6%9B%B2%E7%BA%BF/#jump1" target="_blank" rel="external">7.1.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E8%B4%9D%E6%B5%8E%E5%9F%83%E6%9B%B2%E7%BA%BF/#jump2" target="_blank" rel="external">7.1.2 贝济埃曲线之 quadTo</a><br><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E8%B4%9D%E6%B5%8E%E5%9F%83%E6%9B%B2%E7%BA%BF/#jump3" target="_blank" rel="external">7.1.3 贝济埃曲线之 rQuadTo</a><br><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E8%B4%9D%E6%B5%8E%E5%9F%83%E6%9B%B2%E7%BA%BF/#jump4" target="_blank" rel="external">7.1.4 示例：波浪效果</a></p><h3 id="7-2-setShadowLayer-与阴影效果"><a href="#7-2-setShadowLayer-与阴影效果" class="headerlink" title="7.2 setShadowLayer 与阴影效果"></a><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94setShadowLayer%20%E4%B8%8E%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/" target="_blank" rel="external">7.2 setShadowLayer 与阴影效果</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94setShadowLayer%20%E4%B8%8E%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/#jump1" target="_blank" rel="external">7.2.1 构造函数</a><br><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94setShadowLayer%20%E4%B8%8E%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/#jump2" target="_blank" rel="external">7.2.2 清除阴影</a><br><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94setShadowLayer%20%E4%B8%8E%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/#jump3" target="_blank" rel="external">7.2.3 示例：给文字添加阴影</a></p><h3 id="7-3-BlurMaskFilter-发光效果和图片阴影"><a href="#7-3-BlurMaskFilter-发光效果和图片阴影" class="headerlink" title="7.3 BlurMaskFilter 发光效果和图片阴影"></a><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94BlurMaskFilter%20%E5%8F%91%E5%85%89%E6%95%88%E6%9E%9C%E4%B8%8E%E5%9B%BE%E7%89%87%E9%98%B4%E5%BD%B1/" target="_blank" rel="external">7.3 BlurMaskFilter 发光效果和图片阴影</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94BlurMaskFilter%20%E5%8F%91%E5%85%89%E6%95%88%E6%9E%9C%E4%B8%8E%E5%9B%BE%E7%89%87%E9%98%B4%E5%BD%B1/#jump1" target="_blank" rel="external">7.3.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94BlurMaskFilter%20%E5%8F%91%E5%85%89%E6%95%88%E6%9E%9C%E4%B8%8E%E5%9B%BE%E7%89%87%E9%98%B4%E5%BD%B1/#jump2" target="_blank" rel="external">7.3.2 给图片添加纯色阴影</a><br><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94BlurMaskFilter%20%E5%8F%91%E5%85%89%E6%95%88%E6%9E%9C%E4%B8%8E%E5%9B%BE%E7%89%87%E9%98%B4%E5%BD%B1/#jump3" target="_blank" rel="external">7.3.3 封装控件</a></p><h3 id="7-4-Shader-与-BitmapShader"><a href="#7-4-Shader-与-BitmapShader" class="headerlink" title="7.4 Shader 与 BitmapShader"></a><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B8%8E%20BitmapShader/" target="_blank" rel="external">7.4 Shader 与 BitmapShader</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B8%8E%20BitmapShader/#jump1" target="_blank" rel="external">7.4.1 Shader 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B8%8E%20BitmapShader/#jump2" target="_blank" rel="external">7.4.2 BitmapShader 的基本用法</a><br><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B8%8E%20BitmapShader/#jump3" target="_blank" rel="external">7.4.3 示例一：望远镜效果</a><br><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B8%8E%20BitmapShader/#jump4" target="_blank" rel="external">7.4.4 示例二：生成不规则头像</a></p><h3 id="7-5-Shader-之-LinearGradient"><a href="#7-5-Shader-之-LinearGradient" class="headerlink" title="7.5 Shader 之 LinearGradient"></a><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20LinearGradient/" target="_blank" rel="external">7.5 Shader 之 LinearGradient</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20LinearGradient/#jump1" target="_blank" rel="external">7.5.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20LinearGradient/#jump2" target="_blank" rel="external">7.5.2 示例：闪光文字效果</a></p><h3 id="7-6-Shader-之-RadialGradient"><a href="#7-6-Shader-之-RadialGradient" class="headerlink" title="7.6 Shader 之 RadialGradient"></a><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20RadialGradient/" target="_blank" rel="external">7.6 Shader 之 RadialGradient</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20RadialGradient/#jump1" target="_blank" rel="external">7.6.1 双色渐变</a><br><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20RadialGradient/#jump2" target="_blank" rel="external">7.6.2 多色渐变</a><br><a href="https://xianxiaotao.github.io/2019/07/07/05%20CUSTOM%20VIEW/07.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20RadialGradient/#jump3" target="_blank" rel="external">7.6.3 TileMode 填充模式</a></p><h2 id="第8章-混合模式"><a href="#第8章-混合模式" class="headerlink" title="第8章 混合模式"></a>第8章 混合模式</h2><h3 id="8-1-混合模式之-AvoidXfermode"><a href="#8-1-混合模式之-AvoidXfermode" class="headerlink" title="8.1 混合模式之 AvoidXfermode"></a><a href="https://xianxiaotao.github.io/2019/07/08/05%20CUSTOM%20VIEW/08.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AvoidXfermode/" target="_blank" rel="external">8.1 混合模式之 AvoidXfermode</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/08/05%20CUSTOM%20VIEW/08.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AvoidXfermode/#jump1" target="_blank" rel="external">8.1.1 混合模式概述</a><br><a href="https://xianxiaotao.github.io/2019/07/08/05%20CUSTOM%20VIEW/08.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AvoidXfermode/#jump2" target="_blank" rel="external">8.1.2 AvoidXfermode</a><br><a href="https://xianxiaotao.github.io/2019/07/08/05%20CUSTOM%20VIEW/08.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AvoidXfermode/#jump3" target="_blank" rel="external">8.1.3 AvoidXfermode 绘制原理</a><br><a href="https://xianxiaotao.github.io/2019/07/08/05%20CUSTOM%20VIEW/08.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AvoidXfermode/#jump4" target="_blank" rel="external">8.1.4 AvoidXfermode 之 Mode.AVOID</a></p><h3 id="8-2-混合模式之-PorterDuffXfermode"><a href="#8-2-混合模式之-PorterDuffXfermode" class="headerlink" title="8.2 混合模式之 PorterDuffXfermode"></a><a href="https://xianxiaotao.github.io/2019/07/08/05%20CUSTOM%20VIEW/08.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode/" target="_blank" rel="external">8.2 混合模式之 PorterDuffXfermode</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/08/05%20CUSTOM%20VIEW/08.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode/#jump1" target="_blank" rel="external">8.2.1 PorterDuffXfermode 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/08/05%20CUSTOM%20VIEW/08.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode/#jump2" target="_blank" rel="external">8.2.2 颜色叠加相关模式</a></p><h3 id="8-3-PorterDuffXfermode-之源图像模式"><a href="#8-3-PorterDuffXfermode-之源图像模式" class="headerlink" title="8.3 PorterDuffXfermode 之源图像模式"></a><a href="https://xianxiaotao.github.io/2019/07/08/05%20CUSTOM%20VIEW/08.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode%20%E4%B9%8B%E6%BA%90%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">8.3 PorterDuffXfermode 之源图像模式</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/08/05%20CUSTOM%20VIEW/08.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode%20%E4%B9%8B%E6%BA%90%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F/#jump1" target="_blank" rel="external">8.3.1 Mode.SRC</a><br><a href="https://xianxiaotao.github.io/2019/07/08/05%20CUSTOM%20VIEW/08.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode%20%E4%B9%8B%E6%BA%90%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F/#jump2" target="_blank" rel="external">8.3.2 Mode.SRC_IN</a><br><a href="https://xianxiaotao.github.io/2019/07/08/05%20CUSTOM%20VIEW/08.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode%20%E4%B9%8B%E6%BA%90%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F/#jump3" target="_blank" rel="external">8.3.3 Mode.SRC_OUT</a><br><a href="https://xianxiaotao.github.io/2019/07/08/05%20CUSTOM%20VIEW/08.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode%20%E4%B9%8B%E6%BA%90%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F/#jump4" target="_blank" rel="external">8.3.4 Mode.SRC_OVER</a><br><a href="https://xianxiaotao.github.io/2019/07/08/05%20CUSTOM%20VIEW/08.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode%20%E4%B9%8B%E6%BA%90%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F/#jump5" target="_blank" rel="external">8.3.5 Mode.SRC_ATOP</a></p><h3 id="8-4-目标图像模式与其他模式"><a href="#8-4-目标图像模式与其他模式" class="headerlink" title="8.4 目标图像模式与其他模式"></a><a href="https://xianxiaotao.github.io/2019/07/08/05%20CUSTOM%20VIEW/08.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%9B%AE%E6%A0%87%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">8.4 目标图像模式与其他模式</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/08/05%20CUSTOM%20VIEW/08.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%9B%AE%E6%A0%87%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F/#jump1" target="_blank" rel="external">8.4.1 目标图像模式</a><br><a href="https://xianxiaotao.github.io/2019/07/08/05%20CUSTOM%20VIEW/08.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%9B%AE%E6%A0%87%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F/#jump2" target="_blank" rel="external">8.4.2 其他模式——Mode.CLEAR</a><br><a href="https://xianxiaotao.github.io/2019/07/08/05%20CUSTOM%20VIEW/08.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%9B%AE%E6%A0%87%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F/#jump3" target="_blank" rel="external">8.4.3 模式总结</a></p><h2 id="第9章-Canvas-与图层"><a href="#第9章-Canvas-与图层" class="headerlink" title="第9章 Canvas 与图层"></a>第9章 Canvas 与图层</h2><h3 id="9-1-获取-Canvas-对象的方法"><a href="#9-1-获取-Canvas-对象的方法" class="headerlink" title="9.1 获取 Canvas 对象的方法"></a><a href="https://xianxiaotao.github.io/2019/07/09/05%20CUSTOM%20VIEW/09.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96%20Canvas%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/" target="_blank" rel="external">9.1 获取 Canvas 对象的方法</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/09/05%20CUSTOM%20VIEW/09.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96%20Canvas%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/#jump1" target="_blank" rel="external">9.1.1 方法一：重写 onDraw()、dispatchDraw() 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/09/05%20CUSTOM%20VIEW/09.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96%20Canvas%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/#jump2" target="_blank" rel="external">9.1.2 方法二：使用 Bitmap 创建</a><br><a href="https://xianxiaotao.github.io/2019/07/09/05%20CUSTOM%20VIEW/09.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96%20Canvas%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/#jump3" target="_blank" rel="external">9.1.3 方法三：调用 SurfaceHolder.lockCanvas() 函数</a></p><h3 id="9-2-图层与画布"><a href="#9-2-图层与画布" class="headerlink" title="9.2 图层与画布"></a><a href="https://xianxiaotao.github.io/2019/07/09/05%20CUSTOM%20VIEW/09.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E5%9B%BE%E5%B1%82%E4%B8%8E%E7%94%BB%E5%B8%83/" target="_blank" rel="external">9.2 图层与画布</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/09/05%20CUSTOM%20VIEW/09.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E5%9B%BE%E5%B1%82%E4%B8%8E%E7%94%BB%E5%B8%83/#jump1" target="_blank" rel="external">9.2.1 saveLayer() 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/09/05%20CUSTOM%20VIEW/09.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E5%9B%BE%E5%B1%82%E4%B8%8E%E7%94%BB%E5%B8%83/#jump2" target="_blank" rel="external">9.2.2 画布与图层</a><br><a href="https://xianxiaotao.github.io/2019/07/09/05%20CUSTOM%20VIEW/09.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E5%9B%BE%E5%B1%82%E4%B8%8E%E7%94%BB%E5%B8%83/#jump3" target="_blank" rel="external">9.2.3 saveLayer() &amp; saveLayerAlpha()</a></p><h3 id="9-3-Flag-的具体含义-已过时"><a href="#9-3-Flag-的具体含义-已过时" class="headerlink" title="9.3 Flag 的具体含义 已过时"></a><a href="https://xianxiaotao.github.io/2019/07/09/05%20CUSTOM%20VIEW/09.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94Flag%20%E7%9A%84%E5%85%B7%E4%BD%93%E5%90%AB%E4%B9%89/" target="_blank" rel="external">9.3 Flag 的具体含义 已过时</a></h3><h3 id="9-4-恢复画布"><a href="#9-4-恢复画布" class="headerlink" title="9.4 恢复画布"></a><a href="https://xianxiaotao.github.io/2019/07/09/05%20CUSTOM%20VIEW/09.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E6%81%A2%E5%A4%8D%E7%94%BB%E5%B8%83/" target="_blank" rel="external">9.4 恢复画布</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/09/05%20CUSTOM%20VIEW/09.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E6%81%A2%E5%A4%8D%E7%94%BB%E5%B8%83/#jump1" target="_blank" rel="external">9.4.1 restoreToCount(int count)</a><br><a href="https://xianxiaotao.github.io/2019/07/09/05%20CUSTOM%20VIEW/09.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E6%81%A2%E5%A4%8D%E7%94%BB%E5%B8%83/#jump2" target="_blank" rel="external">9.4.2 restore() &amp; restoreToCount(int count) 的关系</a></p><h2 id="第10章-Android-画布"><a href="#第10章-Android-画布" class="headerlink" title="第10章 Android 画布"></a>第10章 Android 画布</h2><h3 id="10-1-ShapeDrawable"><a href="#10-1-ShapeDrawable" class="headerlink" title="10.1 ShapeDrawable"></a><a href="https://xianxiaotao.github.io/2019/07/10/05%20CUSTOM%20VIEW/10.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94ShapeDrawable/" target="_blank" rel="external">10.1 ShapeDrawable</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/10/05%20CUSTOM%20VIEW/10.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94ShapeDrawable/#jump1" target="_blank" rel="external">10.1.1 shape 标签与 GradientDrawable</a><br><a href="https://xianxiaotao.github.io/2019/07/10/05%20CUSTOM%20VIEW/10.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94ShapeDrawable/#jump2" target="_blank" rel="external">10.1.2 ShapDrawable 的构造函数</a><br><a href="https://xianxiaotao.github.io/2019/07/10/05%20CUSTOM%20VIEW/10.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94ShapeDrawable/#jump3" target="_blank" rel="external">10.1.3 常用函数</a><br><a href="https://xianxiaotao.github.io/2019/07/10/05%20CUSTOM%20VIEW/10.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94ShapeDrawable/#jump4" target="_blank" rel="external">10.1.4 自定义 Drawable</a><br><a href="https://xianxiaotao.github.io/2019/07/10/05%20CUSTOM%20VIEW/10.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94ShapeDrawable/#jump5" target="_blank" rel="external">10.1.5 Drawable 与 Bitmap 对比</a></p><h3 id="10-2-Bitmap"><a href="#10-2-Bitmap" class="headerlink" title="10.2 Bitmap"></a><a href="https://xianxiaotao.github.io/2019/07/10/05%20CUSTOM%20VIEW/10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap/" target="_blank" rel="external">10.2 Bitmap</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/10/05%20CUSTOM%20VIEW/10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap/#jump1" target="_blank" rel="external">10.2.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/10/05%20CUSTOM%20VIEW/10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap/#jump2" target="_blank" rel="external">10.2.2 创建 Bitmap 方法一：BitmapFactory</a><br><a href="https://xianxiaotao.github.io/2019/07/10/05%20CUSTOM%20VIEW/10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap/#jump3" target="_blank" rel="external">10.2.3 BitmapFactory.Options</a><br><a href="https://xianxiaotao.github.io/2019/07/10/05%20CUSTOM%20VIEW/10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap/#jump4" target="_blank" rel="external">10.2.4 创建 Bitmap 方法二：Bitmap 静态方法</a><br><a href="https://xianxiaotao.github.io/2019/07/10/05%20CUSTOM%20VIEW/10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap/#jump5" target="_blank" rel="external">10.2.5 常用函数</a><br><a href="https://xianxiaotao.github.io/2019/07/10/05%20CUSTOM%20VIEW/10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap/#jump6" target="_blank" rel="external">10.2.6 常见问题</a></p><h3 id="10-3-SurfaceView"><a href="#10-3-SurfaceView" class="headerlink" title="10.3 SurfaceView"></a><a href="https://xianxiaotao.github.io/2019/07/10/05%20CUSTOM%20VIEW/10.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94SurfaceView/" target="_blank" rel="external">10.3 SurfaceView</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/10/05%20CUSTOM%20VIEW/10.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94SurfaceView/#jump1" target="_blank" rel="external">10.3.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/10/05%20CUSTOM%20VIEW/10.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94SurfaceView/#jump2" target="_blank" rel="external">10.3.2 基本用法</a><br><a href="https://xianxiaotao.github.io/2019/07/10/05%20CUSTOM%20VIEW/10.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94SurfaceView/#jump3" target="_blank" rel="external">10.3.3 双缓冲技术</a></p><h2 id="第11章-Matrix-与坐标变换"><a href="#第11章-Matrix-与坐标变换" class="headerlink" title="第11章 Matrix 与坐标变换"></a>第11章 Matrix 与坐标变换</h2><h3 id="11-1-矩阵运算"><a href="#11-1-矩阵运算" class="headerlink" title="11.1 矩阵运算"></a><a href="https://xianxiaotao.github.io/2019/07/11/05%20CUSTOM%20VIEW/11.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/" target="_blank" rel="external">11.1 矩阵运算</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/11/05%20CUSTOM%20VIEW/11.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/#jump1" target="_blank" rel="external">11.1.1 矩阵的加法与减法</a><br><a href="https://xianxiaotao.github.io/2019/07/11/05%20CUSTOM%20VIEW/11.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/#jump2" target="_blank" rel="external">11.1.2 矩阵与数的乘法</a><br><a href="https://xianxiaotao.github.io/2019/07/11/05%20CUSTOM%20VIEW/11.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/#jump3" target="_blank" rel="external">11.1.3 矩阵与矩阵的乘法</a></p><h3 id="11-2-ColorMatrix-色彩变换"><a href="#11-2-ColorMatrix-色彩变换" class="headerlink" title="11.2 ColorMatrix 色彩变换"></a><a href="https://xianxiaotao.github.io/2019/07/11/05%20CUSTOM%20VIEW/11.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94ColorMatrix%20%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2/" target="_blank" rel="external">11.2 ColorMatrix 色彩变换</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/11/05%20CUSTOM%20VIEW/11.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94ColorMatrix%20%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2/#jump1" target="_blank" rel="external">11.2.1 色彩变换矩阵</a><br><a href="https://xianxiaotao.github.io/2019/07/11/05%20CUSTOM%20VIEW/11.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94ColorMatrix%20%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2/#jump2" target="_blank" rel="external">11.2.2 色彩的几种运算方式</a><br><a href="https://xianxiaotao.github.io/2019/07/11/05%20CUSTOM%20VIEW/11.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94ColorMatrix%20%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2/#jump3" target="_blank" rel="external">11.2.3 ColorMatrix 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/11/05%20CUSTOM%20VIEW/11.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94ColorMatrix%20%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2/#jump4" target="_blank" rel="external">11.2.4 ColorMatrix 相乘</a></p><h2 id="第12章-封装控件"><a href="#第12章-封装控件" class="headerlink" title="第12章 封装控件"></a>第12章 封装控件</h2><h3 id="12-1-自定义属性与自定义-Style"><a href="#12-1-自定义属性与自定义-Style" class="headerlink" title="12.1 自定义属性与自定义 Style"></a><a href="https://xianxiaotao.github.io/2019/07/12/05%20CUSTOM%20VIEW/12.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%20Style/" target="_blank" rel="external">12.1 自定义属性与自定义 Style</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/12/05%20CUSTOM%20VIEW/12.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%20Style/#jump1" target="_blank" rel="external">12.1.1 示例</a><br><a href="https://xianxiaotao.github.io/2019/07/12/05%20CUSTOM%20VIEW/12.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%20Style/#jump2" target="_blank" rel="external">12.1.2 在 XML 中使用自定义的属性</a><br><a href="https://xianxiaotao.github.io/2019/07/12/05%20CUSTOM%20VIEW/12.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%20Style/#jump3" target="_blank" rel="external">12.1.3 在代码中获取自定义属性的值</a><br><a href="https://xianxiaotao.github.io/2019/07/12/05%20CUSTOM%20VIEW/12.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%20Style/#jump4" target="_blank" rel="external">12.1.4 declare-styleable 标签其他属性的用法</a></p><h3 id="12-2-测量与布局"><a href="#12-2-测量与布局" class="headerlink" title="12.2 测量与布局"></a><a href="https://xianxiaotao.github.io/2019/07/12/05%20CUSTOM%20VIEW/12.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E6%B5%8B%E9%87%8F%E5%92%8C%E5%B8%83%E5%B1%80/" target="_blank" rel="external">12.2 测量与布局</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/12/05%20CUSTOM%20VIEW/12.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E6%B5%8B%E9%87%8F%E5%92%8C%E5%B8%83%E5%B1%80/#jump1" target="_blank" rel="external">12.2.1 ViewGroup 绘制流程</a><br><a href="https://xianxiaotao.github.io/2019/07/12/05%20CUSTOM%20VIEW/12.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E6%B5%8B%E9%87%8F%E5%92%8C%E5%B8%83%E5%B1%80/#jump2" target="_blank" rel="external">12.2.2 onMeasure() 函数与 MeasureSpec</a><br><a href="https://xianxiaotao.github.io/2019/07/12/05%20CUSTOM%20VIEW/12.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E6%B5%8B%E9%87%8F%E5%92%8C%E5%B8%83%E5%B1%80/#jump3" target="_blank" rel="external">12.2.3 onLayout() 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/12/05%20CUSTOM%20VIEW/12.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E6%B5%8B%E9%87%8F%E5%92%8C%E5%B8%83%E5%B1%80/#jump4" target="_blank" rel="external">12.2.4 获取子控件 margin 值的方法</a></p><h3 id="12-3-实现-FlowLayout-容器"><a href="#12-3-实现-FlowLayout-容器" class="headerlink" title="12.3 实现 FlowLayout 容器"></a><a href="https://xianxiaotao.github.io/2019/07/12/05%20CUSTOM%20VIEW/12.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%20FlowLayout%20%E5%AE%B9%E5%99%A8/" target="_blank" rel="external">12.3 实现 FlowLayout 容器</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/12/05%20CUSTOM%20VIEW/12.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%20FlowLayout%20%E5%AE%B9%E5%99%A8/#jump1" target="_blank" rel="external">12.3.1 XML 布局</a><br><a href="https://xianxiaotao.github.io/2019/07/12/05%20CUSTOM%20VIEW/12.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%20FlowLayout%20%E5%AE%B9%E5%99%A8/#jump2" target="_blank" rel="external">12.3.2 提取 margin 值与重写 onMeasure() 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/12/05%20CUSTOM%20VIEW/12.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%20FlowLayout%20%E5%AE%B9%E5%99%A8/#jump3" target="_blank" rel="external">12.3.3 完整代码</a></p><h2 id="第13章-控件高级属性"><a href="#第13章-控件高级属性" class="headerlink" title="第13章 控件高级属性"></a>第13章 控件高级属性</h2><h3 id="13-1-GestureDetector-手势检测"><a href="#13-1-GestureDetector-手势检测" class="headerlink" title="13.1 GestureDetector 手势检测"></a><a href="https://xianxiaotao.github.io/2019/07/13/05%20CUSTOM%20VIEW/13.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94GestureDetector%20%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B/" target="_blank" rel="external">13.1 GestureDetector 手势检测</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/13/05%20CUSTOM%20VIEW/13.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94GestureDetector%20%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B/#jump1" target="_blank" rel="external">13.1.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/13/05%20CUSTOM%20VIEW/13.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94GestureDetector%20%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B/#jump2" target="_blank" rel="external">13.1.2 GestureDetector.OnGestureListener</a><br><a href="https://xianxiaotao.github.io/2019/07/13/05%20CUSTOM%20VIEW/13.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94GestureDetector%20%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B/#jump3" target="_blank" rel="external">13.1.3 GestureDetector.OnDoubleTapListener</a><br><a href="https://xianxiaotao.github.io/2019/07/13/05%20CUSTOM%20VIEW/13.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94GestureDetector%20%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B/#jump4" target="_blank" rel="external">13.1.4 GestureDetector.SimpleOnGestureListener</a><br><a href="https://xianxiaotao.github.io/2019/07/13/05%20CUSTOM%20VIEW/13.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94GestureDetector%20%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B/#jump5" target="_blank" rel="external">13.1.5 onFling() 函数的应用</a></p><h3 id="13-2-Window-与-WindowManager"><a href="#13-2-Window-与-WindowManager" class="headerlink" title="13.2 Window 与 WindowManager"></a><a href="https://xianxiaotao.github.io/2019/07/13/05%20CUSTOM%20VIEW/13.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94Window%20%E4%B8%8E%20WindowManager/" target="_blank" rel="external">13.2 Window 与 WindowManager</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/13/05%20CUSTOM%20VIEW/13.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94Window%20%E4%B8%8E%20WindowManager/#jump1" target="_blank" rel="external">13.2.1 Window 与 WindowManager 的关系</a><br><a href="https://xianxiaotao.github.io/2019/07/13/05%20CUSTOM%20VIEW/13.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94Window%20%E4%B8%8E%20WindowManager/#jump2" target="_blank" rel="external">13.2.2 示例：腾讯手机管家悬浮窗的小火箭效果</a></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CATALOG </tag>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>X001 圆角圆形 ImageView</title>
      <link href="/2019/09/01/05%20CUSTOM%20VIEW/X001%20%E5%9C%86%E8%A7%92%E5%9C%86%E5%BD%A2%20ImageView/"/>
      <url>/2019/09/01/05%20CUSTOM%20VIEW/X001%20%E5%9C%86%E8%A7%92%E5%9C%86%E5%BD%A2%20ImageView/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-99c14f4dff5bc857.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>鉴于 Android 提供的 ImageView 控件已经非常完善，不仅处理好了各种缩放问题，而且有着很好的兼容性，还实现了显示图片等一系列的任务，我们只要在它的基础上添加一个显示圆角圆形的功能即可。</p><h3 id="一、属性配置"><a href="#一、属性配置" class="headerlink" title="一、属性配置"></a>一、属性配置</h3><p>首先创建一个 res/values/attrs.xml 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">    &lt;declare-styleable name=&quot;RoundImageView&quot;&gt;</div><div class="line">        &lt;attr name=&quot;type&quot; format=&quot;enum&quot;&gt;</div><div class="line">            &lt;enum name=&quot;circle&quot; value=&quot;1&quot;/&gt;</div><div class="line">            &lt;enum name=&quot;round&quot; value=&quot;2&quot;/&gt;</div><div class="line">        &lt;/attr&gt;</div><div class="line">        &lt;attr name=&quot;radius&quot; format=&quot;dimension&quot;/&gt;</div><div class="line">    &lt;/declare-styleable&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure></p><h3 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h3><h4 id="1-思路"><a href="#1-思路" class="headerlink" title="1. 思路"></a>1. 思路</h4><ul><li>定义一个 Java 类 RoundImageView，继承自 ImageView，重写其构造方法，获取配置属性进行初始化。</li><li>重写 onMeasure 方法，当模式为圆形的时候使其控件的宽高一致。</li><li>重写 onDraw 方法，增加两种模式处理逻辑。</li></ul><h4 id="2-完整代码"><a href="#2-完整代码" class="headerlink" title="2. 完整代码"></a>2. 完整代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.content.Context;</div><div class="line">import android.content.res.TypedArray;</div><div class="line">import android.graphics.Bitmap;</div><div class="line">import android.graphics.BitmapShader;</div><div class="line">import android.graphics.Canvas;</div><div class="line">import android.graphics.Matrix;</div><div class="line">import android.graphics.Paint;</div><div class="line">import android.graphics.RectF;</div><div class="line">import android.graphics.Shader;</div><div class="line">import android.graphics.drawable.Drawable;</div><div class="line">import android.os.Build;</div><div class="line">import android.util.AttributeSet;</div><div class="line">import android.util.TypedValue;</div><div class="line"></div><div class="line">import androidx.appcompat.widget.AppCompatImageView;</div><div class="line"></div><div class="line">public class RoundImageView extends AppCompatImageView &#123;</div><div class="line"></div><div class="line">    private static final int MODE_NONE = 0;         // 普通模式，默认</div><div class="line">    private static final int MODE_CIRCLE = 1;       // 圆形模式</div><div class="line">    private static final int MODE_ROUND = 2;        // 圆角矩形模式</div><div class="line"></div><div class="line">    private int currMode = MODE_NONE;</div><div class="line">    private int currRound = dp2px(10);              // 圆角半径</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private RectF mRectF = null;</div><div class="line">    private Drawable mPreDrawable = null;</div><div class="line"></div><div class="line">    public RoundImageView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        initViews();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public RoundImageView(Context context, AttributeSet attrs) &#123;</div><div class="line">        this(context, attrs, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public RoundImageView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">        obtainStyledAttrs(context, attrs, defStyleAttr);</div><div class="line">        initViews();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void obtainStyledAttrs(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.RoundImageView,</div><div class="line">                defStyleAttr, 0);</div><div class="line">        currMode = a.getInt(R.styleable.RoundImageView_type, MODE_NONE);</div><div class="line">        currRound = a.getDimensionPixelSize(R.styleable.RoundImageView_radius, currRound);</div><div class="line">        a.recycle();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initViews() &#123;</div><div class="line">        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);</div><div class="line">        mRectF = new RectF();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">        if (currMode == MODE_CIRCLE) &#123;</div><div class="line">            int result = Math.min(getMeasuredWidth(), getMeasuredHeight());</div><div class="line">            setMeasuredDimension(result, result);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        Drawable drawable = getDrawable();</div><div class="line">        Matrix drawMatrix = getImageMatrix();</div><div class="line">        if (drawable == null) &#123;</div><div class="line">            return; // couldn&apos;t resolve the URI</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (drawable.getIntrinsicWidth() == 0 || drawable.getIntrinsicHeight() == 0) &#123;</div><div class="line">            return; // nothing to draw (empty bounds)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (drawMatrix == null &amp;&amp; getPaddingTop() == 0 &amp;&amp; getPaddingLeft() == 0) &#123;</div><div class="line">            drawable.draw(canvas);</div><div class="line">        &#125; else &#123;</div><div class="line">            final int saveCount = canvas.getSaveCount();</div><div class="line">            canvas.save();</div><div class="line"></div><div class="line">            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123;</div><div class="line">                if (getCropToPadding()) &#123;</div><div class="line">                    final int scrollX = getScrollX();</div><div class="line">                    final int scrollY = getScrollY();</div><div class="line">                    canvas.clipRect(scrollX + getPaddingLeft(), scrollY + getPaddingTop(),</div><div class="line">                            scrollX + getRight() - getLeft() - getPaddingRight(),</div><div class="line">                            scrollY + getBottom() - getTop() - getPaddingBottom());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            canvas.translate(getPaddingLeft(), getPaddingTop());</div><div class="line">            // 当为圆形模式的时候</div><div class="line">            if (currMode == MODE_CIRCLE) &#123;</div><div class="line">                setBitmapShader(drawable);</div><div class="line">                canvas.drawCircle(getWidth() / 2f, getHeight() / 2f, getWidth() / 2f, mPaint);</div><div class="line">            &#125;</div><div class="line">            // 当为圆角模式的时候</div><div class="line">            else if (currMode == MODE_ROUND) &#123;</div><div class="line">                setBitmapShader(drawable);</div><div class="line">                mRectF.set(getPaddingLeft(), getPaddingTop(), getWidth() - getPaddingRight(), getHeight() - getPaddingBottom());</div><div class="line">                canvas.drawRoundRect(mRectF, currRound, currRound, mPaint);</div><div class="line">            &#125; else &#123;</div><div class="line">                if (drawMatrix != null) &#123;</div><div class="line">                    canvas.concat(drawMatrix);</div><div class="line">                &#125;</div><div class="line">                drawable.draw(canvas);</div><div class="line">            &#125;</div><div class="line">            canvas.restoreToCount(saveCount);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void setBitmapShader(Drawable drawable) &#123;</div><div class="line">        // 防止多次重 new 对象</div><div class="line">        if (drawable != null &amp;&amp; drawable != mPreDrawable) &#123;</div><div class="line">            Bitmap bitmap = drawable2Bitmap(drawable);</div><div class="line">            mPaint.setShader(new BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP));</div><div class="line">            mPreDrawable = drawable;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * drawable 转换成 bitmap</div><div class="line">     */</div><div class="line">    private Bitmap drawable2Bitmap(Drawable drawable) &#123;</div><div class="line">        if (drawable == null) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        Bitmap bitmap = Bitmap.createBitmap(getWidth(), getHeight(), Bitmap.Config.ARGB_8888);</div><div class="line">        Canvas canvas = new Canvas(bitmap);</div><div class="line">        // 根据传递的 scaleType 获取 matrix 对象，设置给 bitmap</div><div class="line">        Matrix matrix = getImageMatrix();</div><div class="line">        if (matrix != null) &#123;</div><div class="line">            canvas.concat(matrix);</div><div class="line">        &#125;</div><div class="line">        drawable.draw(canvas);</div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private int dp2px(float value) &#123;</div><div class="line">        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, value,</div><div class="line">                getResources().getDisplayMetrics());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 onDraw 方法中，以下代码是我们添加的逻辑，其余代码为 ImageView 源代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Drawable drawable = getDrawable();</div><div class="line">Matrix drawMatrix = getImageMatrix();</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">// 当为圆形模式的时候</div><div class="line">if (currMode == MODE_CIRCLE) &#123;</div><div class="line">    setBitmapShader(drawable);</div><div class="line">    canvas.drawCircle(getWidth() / 2f, getHeight() / 2f, getWidth() / 2f, mPaint);</div><div class="line">&#125;</div><div class="line">// 当为圆角模式的时候</div><div class="line">else if (currMode == MODE_ROUND) &#123;</div><div class="line">    setBitmapShader(drawable);</div><div class="line">    mRectF.set(getPaddingLeft(), getPaddingTop(), getWidth() - getPaddingRight(), getHeight() - getPaddingBottom());</div><div class="line">    canvas.drawRoundRect(mRectF, currRound, currRound, mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="3-在布局文件中使用"><a href="#3-在布局文件中使用" class="headerlink" title="3. 在布局文件中使用"></a>3. 在布局文件中使用</h4><p>效果如首图所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line"></div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;/&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot; /&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;</div><div class="line">            android:scaleType=&quot;centerCrop&quot; /&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line"></div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;</div><div class="line">            app:type=&quot;round&quot;/&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            app:type=&quot;round&quot;/&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;</div><div class="line">            android:scaleType=&quot;centerCrop&quot;</div><div class="line">            app:type=&quot;round&quot;/&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line"></div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;</div><div class="line">            app:type=&quot;circle&quot;/&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            app:type=&quot;circle&quot;/&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;</div><div class="line">            android:scaleType=&quot;centerCrop&quot;</div><div class="line">            app:type=&quot;circle&quot;/&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line"></div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;</div><div class="line">        android:layout_marginTop=&quot;10dp&quot;&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_margin=&quot;10dp&quot;</div><div class="line">            android:layout_width=&quot;50dp&quot;</div><div class="line">            android:layout_height=&quot;50dp&quot;</div><div class="line">            android:src=&quot;@color/colorAccent&quot; /&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_margin=&quot;10dp&quot;</div><div class="line">            android:layout_width=&quot;50dp&quot;</div><div class="line">            android:layout_height=&quot;50dp&quot;</div><div class="line">            android:src=&quot;@color/colorAccent&quot;</div><div class="line">            app:type=&quot;round&quot; /&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_margin=&quot;10dp&quot;</div><div class="line">            android:layout_width=&quot;50dp&quot;</div><div class="line">            android:layout_height=&quot;50dp&quot;</div><div class="line">            android:src=&quot;@color/colorAccent&quot;</div><div class="line">            app:type=&quot;circle&quot; /&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>T007 自定义控件 图文弹跳加载中效果</title>
      <link href="/2019/07/20/05%20CUSTOM%20VIEW/T007%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E5%9B%BE%E6%96%87%E5%BC%B9%E8%B7%B3%E5%8A%A0%E8%BD%BD%E4%B8%AD%E6%95%88%E6%9E%9C/"/>
      <url>/2019/07/20/05%20CUSTOM%20VIEW/T007%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E5%9B%BE%E6%96%87%E5%BC%B9%E8%B7%B3%E5%8A%A0%E8%BD%BD%E4%B8%AD%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-03b7334fbf14edfb.gif?imageMogr2/auto-orient/strip" alt=""></p><p>要想实现上述效果，需要准备三张图：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ca8cac0e6e5cd734.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading_text_1.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b525f50422a24b09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading_text_2.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a452b33c2f107f50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading_text_3.png"></p><p>然后让控件派生自 ImageView 类，这样才能方便地更改它的源文件内容。</p><p>想让图片上下跳动，可以利用 ValueAnimator 实时产生一个 0~200 的数值，然后让当前图片的位置实时向上移动 ValueAnimator 的动态值的高度即可。要让图片的位置实时向上移动，就需要先拿到初始状态下图片的位置。重写 onLayout(boolean changed, int left, int top, int right, int bottom) 函数，就可以拿到控件的初始高度 mTop，之后在每次 ValueAnimator 的动态值到来时，计算出当前控件的 top 位置，并将控件移动到这个位置就可以了。</p><p>即：自定义一个控件 LoadingImageView， 派生自 ImageView，然后重写 onLayout() 函数，拿到控件的初始 top 值。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class LoadingImageView extends AppCompatImageView &#123;</div><div class="line"></div><div class="line">    // 初始 top</div><div class="line">    private int mTop;</div><div class="line">    // 当前动画图片索引</div><div class="line">    private int mCurImgIndex = 0;</div><div class="line">    // 动画图片总张数</div><div class="line">    private static int mImgCount = 3;</div><div class="line"></div><div class="line">    public LoadingImageView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public LoadingImageView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public LoadingImageView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</div><div class="line">        super.onLayout(changed, left, top, right, bottom);</div><div class="line">        mTop = top;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>由于我们需要在刚展示图片时就开始动画，所以将动画的操作全部写在 init() 函数中。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private void init() &#123;</div><div class="line">    ValueAnimator valueAnimator = ValueAnimator.ofInt(0, 200, 0);</div><div class="line">    valueAnimator.setRepeatMode(ValueAnimator.RESTART);</div><div class="line">    valueAnimator.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">    valueAnimator.setDuration(1000);</div><div class="line">    valueAnimator.setInterpolator(new AccelerateInterpolator());</div><div class="line">    valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">            Integer dx = (Integer) animation.getAnimatedValue();</div><div class="line">            setTop(mTop - dx);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通过 (mTop - dx) 得到当前控件相对初始坐标上移 dx 距离后的最新坐标点，然后调用 setTop(int top) 函数将控件移动到当前位置。</p><p>接下来需要监听动画的开始和重复。当动画开始时，图片应该设置为 loading_text_1.png；在重复时，每重复一次应该更换一张图片。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">// 当前动画图片索引</div><div class="line">private int mCurImgIndex = 0;</div><div class="line">// 动画图片总张数</div><div class="line">private static int mImgCount = 3;</div><div class="line"></div><div class="line">private void init() &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    valueAnimator.addListener(new Animator.AnimatorListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onAnimationStart(Animator animation) &#123;</div><div class="line">            setImageDrawable(getResources().getDrawable(R.drawable.loading_text_1));</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void onAnimationEnd(Animator animation) &#123;&#125;</div><div class="line">        @Override</div><div class="line">        public void onAnimationCancel(Animator animation) &#123;&#125;</div><div class="line">        @Override</div><div class="line">        public void onAnimationRepeat(Animator animation) &#123;</div><div class="line">            mCurImgIndex++;</div><div class="line">            switch (mCurImgIndex % mImgCount) &#123;</div><div class="line">                case 0:</div><div class="line">                    setImageDrawable(getResources().getDrawable(R.drawable.loading_text_1));</div><div class="line">                    break;</div><div class="line">                case 1:</div><div class="line">                    setImageDrawable(getResources().getDrawable(R.drawable.loading_text_2));</div><div class="line">                    break;</div><div class="line">                case 2:</div><div class="line">                    setImageDrawable(getResources().getDrawable(R.drawable.loading_text_3));</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    valueAnimator.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在更改图片时，我们使用 mCurImgIndex 来累加当前重复的次数，通过与图片总张数 (mImgCount) 取余数，来决定这次重复使用的是哪张图片。</p><p>使用控件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.xxt.xtest.LoadingImageView</div><div class="line">        android:layout_width=&quot;50dp&quot;</div><div class="line">        android:layout_height=&quot;50dp&quot;</div><div class="line">        android:layout_margin=&quot;50dp&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>LoadingImageView 的完整代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.animation.Animator;</div><div class="line">import android.animation.ValueAnimator;</div><div class="line">import android.content.Context;</div><div class="line">import android.util.AttributeSet;</div><div class="line">import android.view.animation.AccelerateInterpolator;</div><div class="line"></div><div class="line">import androidx.appcompat.widget.AppCompatImageView;</div><div class="line"></div><div class="line">public class LoadingImageView extends AppCompatImageView &#123;</div><div class="line"></div><div class="line">    private int mTop;</div><div class="line">    // 当前动画图片索引</div><div class="line">    private int mCurImgIndex = 0;</div><div class="line">    // 动画图片总张数</div><div class="line">    private static int mImgCount = 3;</div><div class="line"></div><div class="line">    public LoadingImageView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public LoadingImageView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public LoadingImageView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        ValueAnimator valueAnimator = ValueAnimator.ofInt(0, 200, 0);</div><div class="line">        valueAnimator.setRepeatMode(ValueAnimator.RESTART);</div><div class="line">        valueAnimator.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">        valueAnimator.setDuration(1000);</div><div class="line">        valueAnimator.setInterpolator(new AccelerateInterpolator());</div><div class="line">        valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">                Integer dx = (Integer) animation.getAnimatedValue();</div><div class="line">                setTop(mTop - dx);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        valueAnimator.addListener(new Animator.AnimatorListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationStart(Animator animation) &#123;</div><div class="line">                setImageDrawable(getResources().getDrawable(R.drawable.loading_text_1));</div><div class="line">            &#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationEnd(Animator animation) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationCancel(Animator animation) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationRepeat(Animator animation) &#123;</div><div class="line">                mCurImgIndex++;</div><div class="line">                switch (mCurImgIndex % mImgCount) &#123;</div><div class="line">                    case 0:</div><div class="line">                        setImageDrawable(getResources().getDrawable(R.drawable.loading_text_1));</div><div class="line">                        break;</div><div class="line">                    case 1:</div><div class="line">                        setImageDrawable(getResources().getDrawable(R.drawable.loading_text_2));</div><div class="line">                        break;</div><div class="line">                    case 2:</div><div class="line">                        setImageDrawable(getResources().getDrawable(R.drawable.loading_text_3));</div><div class="line">                        break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        valueAnimator.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</div><div class="line">        super.onLayout(changed, left, top, right, bottom);</div><div class="line">        mTop = top;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>T006 自定义控件 扫描雷达动画</title>
      <link href="/2019/07/19/05%20CUSTOM%20VIEW/T006%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E6%89%AB%E6%8F%8F%E9%9B%B7%E8%BE%BE%E5%8A%A8%E7%94%BB/"/>
      <url>/2019/07/19/05%20CUSTOM%20VIEW/T006%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E6%89%AB%E6%8F%8F%E9%9B%B7%E8%BE%BE%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d200aff4a7b219d9.gif?imageMogr2/auto-orient/strip" alt=""></p><h3 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h3><ul><li>表层是一张指针图，增加旋转动画，每旋转一周，增加一个波纹扩散动画效果。</li><li>波纹扩散动画效果是在底层的波纹图上实现缩放和透明度变化的组合动画。</li><li>使用容器来保存波纹扩散动画，便于复用。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c358aabf4dcd605b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="指针原图"></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1478d5d2bd1083fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="波纹原图"></p><h3 id="二、完整代码"><a href="#二、完整代码" class="headerlink" title="二、完整代码"></a>二、完整代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.animation.Animator;</div><div class="line">import android.animation.AnimatorSet;</div><div class="line">import android.animation.ObjectAnimator;</div><div class="line">import android.animation.ValueAnimator;</div><div class="line">import android.content.Context;</div><div class="line">import android.util.AttributeSet;</div><div class="line">import android.view.Gravity;</div><div class="line">import android.view.LayoutInflater;</div><div class="line">import android.view.View;</div><div class="line">import android.view.animation.LinearInterpolator;</div><div class="line">import android.widget.FrameLayout;</div><div class="line">import android.widget.ImageView;</div><div class="line">import android.widget.TextView;</div><div class="line"></div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class ScanningView extends FrameLayout &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 指针</div><div class="line">     */</div><div class="line">    private ImageView ivNeedle;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 波纹</div><div class="line">     */</div><div class="line">    private ImageView ivRipple;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 中间文字</div><div class="line">     */</div><div class="line">    private TextView tvTitle;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 装波纹的容器</div><div class="line">     */</div><div class="line">    private FrameLayout fl_move_circle;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 匀速插值器</div><div class="line">     */</div><div class="line">    private LinearInterpolator interpolator = new LinearInterpolator();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 准备动画</div><div class="line">     */</div><div class="line">    private AnimatorSet prepareAnim;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 指针旋转动画</div><div class="line">     */</div><div class="line">    private ObjectAnimator needleRotateAnim;</div><div class="line"></div><div class="line">    private List&lt;AnimatorSet&gt; animList = new ArrayList&lt;&gt;();</div><div class="line">    private int animCount = 3;</div><div class="line">    private int index = 0;</div><div class="line"></div><div class="line">    public ScanningView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        initView();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ScanningView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        initView();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initView()&#123;</div><div class="line">        View v = LayoutInflater.from(getContext()).inflate(R.layout.rotate_view,null);</div><div class="line">        ivNeedle = v.findViewById(R.id.iv_btn);</div><div class="line">        ivRipple = v.findViewById(R.id.iv_out_circle);</div><div class="line">        tvTitle = v.findViewById(R.id.tv_title);</div><div class="line">        fl_move_circle = v.findViewById(R.id.fl_move_circle);</div><div class="line">        addView(v, LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);</div><div class="line"></div><div class="line">        initAnim();</div><div class="line"></div><div class="line">        prepareAnim.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 初始化动画</div><div class="line">     * 准备动画 prepareAnim</div><div class="line">     * 扫描动画 scanningAnim</div><div class="line">     */</div><div class="line">    private void initAnim() &#123;</div><div class="line">        initPrepareAnim();</div><div class="line">        initScanningAnim();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initPrepareAnim() &#123;</div><div class="line">        // 开始循环的放大缩小波纹</div><div class="line">        ObjectAnimator outCircleAlpha = ObjectAnimator.ofFloat(ivRipple, &quot;alpha&quot;, 0.2f, 0.6f);</div><div class="line">        outCircleAlpha.setDuration(1000);</div><div class="line">        ObjectAnimator outCircleAnimX = ObjectAnimator.ofFloat(ivRipple, &quot;scaleX&quot;, 1f, 1.18f, 1f);</div><div class="line">        outCircleAnimX.setDuration(2000);</div><div class="line">        outCircleAnimX.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">        outCircleAnimX.setInterpolator(interpolator);</div><div class="line">        ObjectAnimator outCircleAnimY = ObjectAnimator.ofFloat(ivRipple, &quot;scaleY&quot;, 1f, 1.18f, 1f);</div><div class="line">        outCircleAnimY.setDuration(2000);</div><div class="line">        outCircleAnimY.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">        outCircleAnimY.setInterpolator(interpolator);</div><div class="line">        prepareAnim = new AnimatorSet();</div><div class="line">        prepareAnim.playTogether(outCircleAnimX, outCircleAnimY, outCircleAlpha);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initScanningAnim() &#123;</div><div class="line">        // 指针转动动画</div><div class="line">        needleRotateAnim = ObjectAnimator.ofFloat(ivNeedle, &quot;rotation&quot;, 0f, 360f);</div><div class="line">        needleRotateAnim.setDuration(1800);</div><div class="line">        needleRotateAnim.setInterpolator(interpolator);</div><div class="line">        needleRotateAnim.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">        needleRotateAnim.addListener(new Animator.AnimatorListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationStart(Animator animation) &#123;</div><div class="line">                playRippleAnim();</div><div class="line">            &#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationEnd(Animator animation) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationCancel(Animator animation) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationRepeat(Animator animation) &#123;</div><div class="line">                playRippleAnim();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initRippleAnim() &#123;</div><div class="line">        final ImageView imageView = new ImageView(getContext());</div><div class="line">        LayoutParams lp = new LayoutParams(dip2px(getContext(), 110), dip2px(getContext(), 110));</div><div class="line">        lp.gravity = Gravity.CENTER;</div><div class="line">        imageView.setLayoutParams(lp);</div><div class="line">        imageView.setImageResource(R.drawable.ripple);</div><div class="line">        fl_move_circle.addView(imageView);</div><div class="line">        ObjectAnimator outCircleAnimX = ObjectAnimator.ofFloat(imageView, &quot;scaleX&quot;, 1f, 5f);</div><div class="line">        ObjectAnimator outCircleAnimY = ObjectAnimator.ofFloat(imageView, &quot;scaleY&quot;, 1f, 5f);</div><div class="line">        ObjectAnimator alphaAnim = ObjectAnimator.ofFloat(imageView, &quot;alpha&quot;, 0.6f, 0);</div><div class="line">        outCircleAnimX.setDuration(5000);</div><div class="line">        outCircleAnimY.setDuration(5000);</div><div class="line">        alphaAnim.setDuration(5000);</div><div class="line">        final AnimatorSet animatorSet = new AnimatorSet();</div><div class="line">        animatorSet.playTogether(outCircleAnimX, outCircleAnimY, alphaAnim);</div><div class="line"></div><div class="line">        animList.add(animatorSet);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void playRippleAnim() &#123;</div><div class="line">        if (animList.size() &lt; animCount) &#123;</div><div class="line">            initRippleAnim();</div><div class="line">        &#125;</div><div class="line">        animList.get(index).start();</div><div class="line">        index++;</div><div class="line">        if (index == animCount) index = 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 模拟开始</div><div class="line">     */</div><div class="line">    public void onceClick()&#123;</div><div class="line">        // 取消掉循环的波纹</div><div class="line">        prepareAnim.cancel();</div><div class="line">        ivRipple.setVisibility(GONE);</div><div class="line"></div><div class="line">        needleRotateAnim.start();</div><div class="line">        tvTitle.setText(&quot;扫描中&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 根据手机的分辨率从 dip 的单位 转成为 px(像素)</div><div class="line">     */</div><div class="line">    public static int dip2px(Context context, float dpValue) &#123;</div><div class="line">        final float scale = context.getResources().getDisplayMetrics().density;</div><div class="line">        return (int) (dpValue * scale + 0.5f);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其布局文件 res/layout/scanning_view.xml 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:background=&quot;#69C8FA&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line"></div><div class="line">    &lt;FrameLayout</div><div class="line">        android:id=&quot;@+id/fl_move_circle&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/iv_out_circle&quot;</div><div class="line">        android:layout_width=&quot;110dp&quot;</div><div class="line">        android:layout_height=&quot;110dp&quot;</div><div class="line">        android:layout_gravity=&quot;center&quot;</div><div class="line">        android:alpha=&quot;0.6&quot;</div><div class="line">        android:src=&quot;@drawable/ripple&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/iv_btn&quot;</div><div class="line">        android:layout_width=&quot;110dp&quot;</div><div class="line">        android:layout_height=&quot;110dp&quot;</div><div class="line">        android:layout_gravity=&quot;center&quot;</div><div class="line">        android:src=&quot;@drawable/needle&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;TextView</div><div class="line">        android:id=&quot;@+id/tv_title&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:textColor=&quot;#ffffff&quot;</div><div class="line">        android:layout_gravity=&quot;center&quot;</div><div class="line">        android:text=&quot;点击扫描&quot;</div><div class="line">        android:textSize=&quot;10sp&quot;</div><div class="line">        android:layout_marginTop=&quot;13dp&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot; /&gt;</div><div class="line"></div><div class="line">&lt;/FrameLayout&gt;</div></pre></td></tr></table></figure></p><h3 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class DemoActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_demo);</div><div class="line"></div><div class="line">        final ScanningView view = findViewById(R.id.scanning);</div><div class="line">        view.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                view.onceClick();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.xxt.xtest.ScanningView</div><div class="line">        android:id=&quot;@+id/scanning&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>T005 自定义控件 可配置加载 ImageView</title>
      <link href="/2019/07/18/05%20CUSTOM%20VIEW/T005%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E5%8F%AF%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%20ImageView/"/>
      <url>/2019/07/18/05%20CUSTOM%20VIEW/T005%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E5%8F%AF%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%20ImageView/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-dd9b1010d91ba48c.gif?imageMogr2/auto-orient/strip" alt=""></p><p>原理很简单，使一张图围绕自己的中心点匀速旋转。完整代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.content.Context;</div><div class="line">import android.util.AttributeSet;</div><div class="line">import android.view.animation.Animation;</div><div class="line">import android.view.animation.LinearInterpolator;</div><div class="line">import android.view.animation.RotateAnimation;</div><div class="line"></div><div class="line">import androidx.annotation.Nullable;</div><div class="line">import androidx.appcompat.widget.AppCompatImageView;</div><div class="line"></div><div class="line">public class LoadingImageView extends AppCompatImageView &#123;</div><div class="line"></div><div class="line">    public LoadingImageView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public LoadingImageView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public LoadingImageView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        RotateAnimation rotateAnim = new RotateAnimation(0, 360,</div><div class="line">                Animation.RELATIVE_TO_SELF, 0.5f,</div><div class="line">                Animation.RELATIVE_TO_SELF, 0.5f);</div><div class="line">        rotateAnim.setRepeatCount(Animation.INFINITE);</div><div class="line">        rotateAnim.setDuration(1000);</div><div class="line">        rotateAnim.setInterpolator(new LinearInterpolator());</div><div class="line">        this.startAnimation(rotateAnim);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.xxt.xtest.LoadingImageView</div><div class="line">        android:layout_width=&quot;50dp&quot;</div><div class="line">        android:layout_height=&quot;50dp&quot;</div><div class="line">        android:layout_margin=&quot;50dp&quot;</div><div class="line">        android:src=&quot;@drawable/taiji&quot;/&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>T004 自定义控件 由远及近 ImageView</title>
      <link href="/2019/07/17/05%20CUSTOM%20VIEW/T004%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E7%94%B1%E8%BF%9C%E5%8F%8A%E8%BF%91%20ImageView/"/>
      <url>/2019/07/17/05%20CUSTOM%20VIEW/T004%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E7%94%B1%E8%BF%9C%E5%8F%8A%E8%BF%91%20ImageView/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-817072fe0e22d8fd.gif?imageMogr2/auto-orient/strip" alt=""></p><p>参考知识点：<a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/#jump2" target="_blank" rel="external">ScaleAnimation</a>、<a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump5" target="_blank" rel="external">BounceInterpolator</a></p><p>借助 ScaleAnimation 实现由远及近效果，首先需要让动画从控件某点（触屏点）为中心开始缩放；其次需要在动画结束后，将控件固定在放大后的状态；并使用回弹插值器。</p><p>上述效果图完整代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.content.Context;</div><div class="line">import android.util.AttributeSet;</div><div class="line">import android.view.MotionEvent;</div><div class="line">import android.view.animation.Animation;</div><div class="line">import android.view.animation.BounceInterpolator;</div><div class="line">import android.view.animation.ScaleAnimation;</div><div class="line"></div><div class="line">import androidx.annotation.Nullable;</div><div class="line">import androidx.appcompat.widget.AppCompatImageView;</div><div class="line"></div><div class="line">public class TouchImageView extends AppCompatImageView &#123;</div><div class="line"></div><div class="line">    private boolean isPlay = false;</div><div class="line"></div><div class="line">    public TouchImageView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TouchImageView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TouchImageView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        if (!isPlay) &#123;</div><div class="line">            isPlay = true;</div><div class="line"></div><div class="line">            float pivotXValue = (event.getX() - getLeft()) / getWidth();</div><div class="line">            float pivotYValue = (event.getY() - getTop()) / getHeight();</div><div class="line"></div><div class="line">            ScaleAnimation scaleAnim = new ScaleAnimation(1.0f, 3f, 1.0f, 3f,</div><div class="line">                    Animation.RELATIVE_TO_SELF, pivotXValue,</div><div class="line">                    Animation.RELATIVE_TO_SELF, pivotYValue);</div><div class="line">            scaleAnim.setDuration(3000);</div><div class="line">            scaleAnim.setFillAfter(true);</div><div class="line">            scaleAnim.setInterpolator(new BounceInterpolator());</div><div class="line">            this.startAnimation(scaleAnim);</div><div class="line">        &#125; else &#123;</div><div class="line">            this.clearAnimation();</div><div class="line">            isPlay = false;</div><div class="line">        &#125;</div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>之所以继承 ImageView，是为了复用其完善的图片显示功能。</p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>T003 自定义控件 裁剪动画</title>
      <link href="/2019/07/16/05%20CUSTOM%20VIEW/T003%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E8%A3%81%E5%89%AA%E5%8A%A8%E7%94%BB/"/>
      <url>/2019/07/16/05%20CUSTOM%20VIEW/T003%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E8%A3%81%E5%89%AA%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2cc64f1f2b5f86f5.gif?imageMogr2/auto-orient/strip" alt=""></p><p>参考知识点：<a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Canvas" target="_blank" rel="external">01.5 精通自定义 View 之绘图基础——Canvas</a></p><h3 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h3><p>这个动画的原理很简单，就是每次将裁剪区域变大，在裁剪区域内的图像就会显示出来，而裁剪区域之外的图像不会显示。而关键问题在于如何计算裁剪区域。</p><p>再来看一下动画截图，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1c8c6731e193d120.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从图示中可以看出，有两个裁剪区域。</p><p>裁剪区域一：从左向右，逐渐变大。假设宽度是 clipWidth，高度是 CLIP_HEIGHT，那么裁剪区域一所对应的 Rect 对象如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Rect(0, 0, clipWidth, CLIP_HEIGHT);</div></pre></td></tr></table></figure></p><p>裁剪区域二：从右向左，同样逐渐变大，它的宽度、高度都与裁剪区域一相同。但它是从右向左变化的，假设图片的宽度是 width，那么裁剪区域二所对应的 Rect 对象如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Rect(width - clipWidth, CLIP_HEIGHT, width, 2* CLIP_HEIGHT);</div></pre></td></tr></table></figure></p><h3 id="二、示例代码"><a href="#二、示例代码" class="headerlink" title="二、示例代码"></a>二、示例代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">public class ClipRegionView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap mBitmap;</div><div class="line">    private int clipWidth = 0;</div><div class="line">    private int width;</div><div class="line">    private int height;</div><div class="line">    private static final int CLIP_HEIGHT = 50;</div><div class="line">    private Path mPath;</div><div class="line">    private RectF mRect;</div><div class="line"></div><div class="line">    public ClipRegionView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.meinv);</div><div class="line">        width = mBitmap.getWidth();</div><div class="line">        height = mBitmap.getHeight();</div><div class="line">        mPath = new Path();</div><div class="line">        mRect = new RectF();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onSizeChanged(int w, int h, int oldW, int oldH) &#123;</div><div class="line">        super.onSizeChanged(w, h, oldW, oldH);</div><div class="line"></div><div class="line">        // 原图宽高超过控件自身宽高，进行缩放</div><div class="line">        if (width &gt; w || height &gt; h) &#123;</div><div class="line">            float scaleW = w * 1f / width;</div><div class="line">            float scaleH = h * 1f / height;</div><div class="line">            float scale = Math.min(scaleW, scaleH);</div><div class="line">            // 按比例重置参数</div><div class="line">            mBitmap = scaleBitmap(mBitmap, scale);</div><div class="line">            width = (int) (width * scale);</div><div class="line">            height = (int) (height * scale);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        mPath.reset();</div><div class="line">        int i = 0;</div><div class="line">        while (i * CLIP_HEIGHT &lt;= height) &#123;</div><div class="line">            if (i % 2 == 0) &#123;</div><div class="line">                mRect.set(0, i * CLIP_HEIGHT, clipWidth, (i+1) * CLIP_HEIGHT);</div><div class="line">            &#125; else &#123;</div><div class="line">                mRect.set(width - clipWidth, i * CLIP_HEIGHT, width, (i+1) * CLIP_HEIGHT);</div><div class="line">            &#125;</div><div class="line">            // 替换 Region.union 方法</div><div class="line">            mPath.addRect(mRect, Path.Direction.CCW);</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        // 因 canvas.clipRegion 方法过时，所以替换成 Path 相关 Api</div><div class="line">        canvas.clipPath(mPath);</div><div class="line">        canvas.drawBitmap(mBitmap, 0, 0, mPaint);</div><div class="line">        if (clipWidth &gt; width) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        clipWidth += 5;</div><div class="line">        invalidate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 按比例缩放图片</div><div class="line">     *</div><div class="line">     * @param origin 原图</div><div class="line">     * @param ratio  比例</div><div class="line">     * @return 新的bitmap</div><div class="line">     */</div><div class="line">    private Bitmap scaleBitmap(Bitmap origin, float ratio) &#123;</div><div class="line">        if (origin == null) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        int width = origin.getWidth();</div><div class="line">        int height = origin.getHeight();</div><div class="line">        Matrix matrix = new Matrix();</div><div class="line">        matrix.preScale(ratio, ratio);</div><div class="line">        Bitmap newBM = Bitmap.createBitmap(origin, 0, 0, width, height, matrix, false);</div><div class="line">        if (newBM.equals(origin)) &#123;</div><div class="line">            return newBM;</div><div class="line">        &#125;</div><div class="line">        origin.recycle();</div><div class="line">        return newBM;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过调用 invalidate() 函数的方式来重复触发 onDraw() 函数，然后在 onDraw() 函数中计算需要裁剪的画布。</p><p>在上述代码中，首先，由于 mPath 对象是每次都复用的，所以，在每次计算裁剪区域前, 都需要调用 mPath.reset() 函数将区域置空。</p><p>其次，根据计算裁剪区域的原理循环计算图片中每条间隔的裁剪区域并添加到 mPath 对象中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">while (i * CLIP_HEIGHT &lt;= height) &#123;</div><div class="line">    if (i % 2 == 0) &#123;</div><div class="line">        mRect.set(0, i * CLIP_HEIGHT, clipWidth, (i+1) * CLIP_HEIGHT);</div><div class="line">    &#125; else &#123;</div><div class="line">        mRect.set(width - clipWidth, i * CLIP_HEIGHT, width, (i+1) * CLIP_HEIGHT);</div><div class="line">    &#125;</div><div class="line">    // 替换 Region.union 方法</div><div class="line">    mPath.addRect(mRect, Path.Direction.CCW);</div><div class="line">    i++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>最后，将图片绘制在裁剪过的画布上，并渐变增大裁剪区域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">canvas.clipPath(mPath);</div><div class="line">canvas.drawBitmap(mBitmap, 0, 0, mPaint);</div><div class="line">clipWidth += 5;</div></pre></td></tr></table></figure></p><p>需要注意的是，当裁剪区域超过图像大小时，表示当前图像已经完全被绘制出来，可以暂停当前的绘制，以免浪费 CPU 资源。</p><p>当图片宽高超过控件自身大小时，裁剪动画效果很差，因此对原图进行缩放并重置参数。其效果图如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-64334c040329d581.gif?imageMogr2/auto-orient/strip" alt="有瑕疵的裁剪动画"></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>T002 自定义控件 裁剪圆形和圆角头像</title>
      <link href="/2019/07/15/05%20CUSTOM%20VIEW/T002%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E8%A3%81%E5%89%AA%E5%9C%86%E5%BD%A2%E5%92%8C%E5%9C%86%E8%A7%92%E5%A4%B4%E5%83%8F/"/>
      <url>/2019/07/15/05%20CUSTOM%20VIEW/T002%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E8%A3%81%E5%89%AA%E5%9C%86%E5%BD%A2%E5%92%8C%E5%9C%86%E8%A7%92%E5%A4%B4%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e55de3cecdfd0cbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>参考知识点：<a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Canvas" target="_blank" rel="external">01.5 精通自定义 View 之绘图基础——Canvas</a></p><h3 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h3><p>利用 clip 系列函数，通过与 Rect、Path、Region 取交、并、差等集合运算来获得最新的画布形状。此处只需要裁处圆形和圆角矩形，使用 Path 类构建即可，并用 clipPath 裁剪画布。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Path path = new Path();</div><div class="line">RectF rect = new RectF(50, 50, 240, 200);</div><div class="line">path.addRoundRect(rect, 10, 10, Path.Direction.CCW);</div><div class="line">// float[] radii = &#123;10,15,20,25,30,35,40,45&#125;;</div><div class="line">// path.addRoundRect(rect, radii, Path.Direction.CW);</div><div class="line"></div><div class="line">canvas.clipPath(path);</div></pre></td></tr></table></figure></p><h3 id="二、步骤"><a href="#二、步骤" class="headerlink" title="二、步骤"></a>二、步骤</h3><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class RoundImageView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line">    private Bitmap mBmp;</div><div class="line"></div><div class="line">    public RoundImageView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        // 禁用硬件加速</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPath = new Path();</div><div class="line">        mBmp = BitmapFactory.decodeResource(getResources(), R.drawable.meinv);</div><div class="line">        int x = mBmp.getWidth() / 2;</div><div class="line">        int y = mBmp.getHeight() / 2;</div><div class="line">        int r = Math.min(x, y);</div><div class="line">        mPath.addCircle(x, y, r, Path.Direction.CCW);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在使用 clip 系列函数时，要禁用硬件加速功能。然后利用 BitmapFactory.decodeResource() 函数从本地 res 文件夹中提取一个 Bitmap 文件。接着根据位图文件的大小，构造一条与图像大小相同的圆形路径。</p><h4 id="2-绘制圆形图像"><a href="#2-绘制圆形图像" class="headerlink" title="2. 绘制圆形图像"></a>2. 绘制圆形图像</h4><p>在绘图时，先将画布裁剪成圆形，再将位图画上去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line"></div><div class="line">    canvas.save();</div><div class="line">    canvas.clipPath(mPath);</div><div class="line">    canvas.drawBitmap(mBmp, 0, 0, mPaint);</div><div class="line">    canvas.restore();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4c70e591d12eea7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p><h4 id="4-绘制圆角图像"><a href="#4-绘制圆角图像" class="headerlink" title="4. 绘制圆角图像"></a>4. 绘制圆角图像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class RoundImageView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line">    private Bitmap mBmp;</div><div class="line">    private boolean isCircle = false;   // true：圆形图像；false：圆角矩形</div><div class="line"></div><div class="line">    public RoundImageView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        // 禁用硬件加速</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPath = new Path();</div><div class="line">        mBmp = BitmapFactory.decodeResource(getResources(), R.drawable.head);</div><div class="line">        if (isCircle) &#123;</div><div class="line">            int x = mBmp.getWidth() / 2;</div><div class="line">            int y = mBmp.getHeight() / 2;</div><div class="line">            int r = Math.min(x, y);</div><div class="line">            mPath.addCircle(x, y, r, Path.Direction.CCW);</div><div class="line">        &#125; else &#123;</div><div class="line">            RectF rectF = new RectF();</div><div class="line">            rectF.set(0, 0, mBmp.getWidth(), mBmp.getHeight());</div><div class="line">            mPath.addRoundRect(rectF, 20, 20, Path.Direction.CW);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        canvas.save();</div><div class="line">        canvas.clipPath(mPath);</div><div class="line">        canvas.drawBitmap(mBmp, 0, 0, mPaint);</div><div class="line">        canvas.restore();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14186083-51064ec4951773ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="圆角图像"></p><h3 id="三、优化"><a href="#三、优化" class="headerlink" title="三、优化"></a>三、优化</h3><p>对上述代码可以进行以下几个方面优化：</p><ul><li>参数可配置：圆形与圆角矩形切换、圆角大小、图片资源等。</li><li>图片缩放至控件大小。</li></ul><p>由于 Android 提供的 ImageView 已经处理好了各种缩放问题，我们可以在它的基础上添加一个显示圆角圆形的功能。<a href="https://xianxiaotao.github.io/2019/07/16/Custom%20View/X001%20%E5%9C%86%E8%A7%92%E5%9C%86%E5%BD%A2%20ImageView/" target="_blank" rel="external">详见博客：圆角圆形ImageView。</a></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>T001 自定义控件 蜘蛛网状图</title>
      <link href="/2019/07/14/05%20CUSTOM%20VIEW/T001%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E8%9C%98%E8%9B%9B%E7%BD%91%E7%8A%B6%E5%9B%BE/"/>
      <url>/2019/07/14/05%20CUSTOM%20VIEW/T001%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E8%9C%98%E8%9B%9B%E7%BD%91%E7%8A%B6%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-69b3cadcd1005e2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>参考知识点：<a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/" target="_blank" rel="external">01.2 精通自定义 View 之绘图基础——路径</a></p><p>从效果图中可以看出，我们要先画出一个网格，默认网格数和边角数都是 6。在代码中，为了简化逻辑，我们会将所有可变的内容，比如画笔颜色、网格数、边角数设为固定值。其实这些值都应该在初始化的时候通过对应的 set 函数设置到自定义控件内部，大家可以自行补充。</p><h3 id="一、初始化"><a href="#一、初始化" class="headerlink" title="一、初始化"></a>一、初始化</h3><p>不要在 onDraw() 函数中创建变量，所以必然会有一个初始化函数，用于在创建控件的时候初始化画笔等参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class SpiderView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mRadarPaint;                  // 蜘蛛网</div><div class="line">    private Paint mRadarLinePaint;              // 蜘蛛网辐射的六根线</div><div class="line">    private Paint mValuePaint;                  // 数据</div><div class="line"></div><div class="line">    private int mRadarPaintColor = 0xFF0099CC;  // 网格默认颜色</div><div class="line">    private Path mPath;</div><div class="line"></div><div class="line">    public SpiderView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * init view</div><div class="line">     * Paint、Path</div><div class="line">     */</div><div class="line">    private void init() &#123;</div><div class="line">        mRadarPaint = generatePaint(mRadarPaintColor, Paint.Style.FILL);</div><div class="line">        mRadarLinePaint = generatePaint(Color.WHITE, Paint.Style.STROKE);</div><div class="line">        mValuePaint = generatePaint(0xAFFF0000, Paint.Style.FILL);</div><div class="line"></div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 初始化画笔</div><div class="line">     * @param color 画笔颜色</div><div class="line">     * @param style 画笔样式</div><div class="line">     * @return Paint</div><div class="line">     */</div><div class="line">    private Paint generatePaint(int color, Paint.Style style) &#123;</div><div class="line">        Paint paint = new Paint();</div><div class="line">        paint.setColor(color);</div><div class="line">        paint.setStyle(style);</div><div class="line">        paint.setAntiAlias(true);</div><div class="line">        return paint;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里初始化了三个画笔，其中 mRadarPaint 是用来绘制蜘蛛网格的，类型设置为填充 (也可以设置为描边)；mRadarLinePaint 是用来绘制蜘蛛网格辐射的六根线，白色描边；而 mValuePaint 是用来绘制结果图的，所以设置成带透明的红色画笔，样式为填充。</p><h3 id="二、获得布局中心"><a href="#二、获得布局中心" class="headerlink" title="二、获得布局中心"></a>二、获得布局中心</h3><p>在 onSizeChanged(int w, int h, int oldW, int oldH) 函数中，根据 View 的长、宽，获取整个布局的中心坐标，因为整个雷达都是从这个中心坐标开始绘制的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private float radius;                       // 网格最大半径</div><div class="line">private int centerX;                        // 中心 X</div><div class="line">private int centerY;                        // 中心 Y</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void onSizeChanged(int w, int h, int oldW, int oldH) &#123;</div><div class="line">    // 获得布局中心</div><div class="line">    centerX = w / 2;</div><div class="line">    centerY = h / 2;</div><div class="line">    radius = Math.min(w, h) / 2f * 0.8f;</div><div class="line">    postInvalidate();</div><div class="line">    super.onSizeChanged(w, h, oldW, oldH);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们知道，在控件大小发生变化时，都会通过 onSizeChanged() 函数通知我们当前控件的大小。所以，我们只需要重写 onSizeChanged() 函数，即可得知当前控件的最新大小。</p><p>为了不顶边，将蜘蛛网的半径设置为 Math.min(w, h) / 2f * 0.8f 。</p><p>然后依据绘图中心，分别绘制蜘蛛网格、网格中线、数据图，即可完成整个效果图的绘制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line">    // 绘制蜘蛛网格</div><div class="line">    drawPolygon(canvas);</div><div class="line">    // 绘制中线</div><div class="line">    drawLines(canvas);</div><div class="line">    // 画数据图</div><div class="line">    drawRegion(canvas);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="三、绘制蜘蛛网格"><a href="#三、绘制蜘蛛网格" class="headerlink" title="三、绘制蜘蛛网格"></a>三、绘制蜘蛛网格</h3><p>下面我们就要绘制蜘蛛网格了，效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c1605cd5fc5aca77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p><p>很显然，蜘蛛网格是利用 Path 的 moveTo() 和 lineTo() 函数一圈圈画出来的，我们需要计算出每个转折点的位置。比如，计算下图中所标记点的 x, y 坐标。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1ccb35d364a464c5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>很明显，标记点在半径的 3/4 位置，而标记点与中心点的连线与 X 轴的夹角为 a，所以由图可得:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x = centX + 3/4 * radius * sina;</div><div class="line">y = centY + 3/4 * radius * cosa;</div></pre></td></tr></table></figure></p><p>因为我们共画了 6 个角，所以每个角的度数应该是 360°/6 = 60°。<br>依据上面的原理，列出画蜘蛛网格的代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">private int count = 6;                      // 多边形，默认值为 6</div><div class="line">private double angle = 2 * Math.PI / count; // 角度，值为 2π / count，默认</div><div class="line">private int maxValue = 4;                   // 最大值</div><div class="line"></div><div class="line">private void drawPolygon(Canvas canvas) &#123;</div><div class="line">    float r = radius / maxValue;            // r是蜘蛛丝之间的间距</div><div class="line">    for (int i = 1; i &lt;= maxValue; i++) &#123;   // 中心点不用绘制</div><div class="line">        float curR = r * i;                 // 当前半径</div><div class="line">        mPath.reset();</div><div class="line">        for (int j = 0; j &lt; count; j++) &#123;</div><div class="line">            if (j == 0) &#123;</div><div class="line">                mPath.moveTo(centerX + curR, centerY);</div><div class="line">            &#125; else &#123;</div><div class="line">                // 根据半径，计算出蜘蛛丝上每个点的坐标</div><div class="line">                float x = (float) (centerX + curR * Math.cos(angle * j));</div><div class="line">                float y = (float) (centerY + curR * Math.sin(angle * j));</div><div class="line">                mPath.lineTo(x, y);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        mPath.close();                      // 闭合路径</div><div class="line">        mRadarPaint.setAlpha(getRadarPaintColor(i));</div><div class="line">        canvas.drawPath(mPath, mRadarPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="四、画网格中线"><a href="#四、画网格中线" class="headerlink" title="四、画网格中线"></a>四、画网格中线</h3><p>在画完蜘蛛网格以后，我们需要画从网格中心到末端的直线，代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private void drawLines(Canvas canvas) &#123;</div><div class="line">    for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">        mPath.reset();</div><div class="line">        mPath.moveTo(centerX, centerY);</div><div class="line">        float x = (float) (centerX + radius * Math.cos(angle * i));</div><div class="line">        float y = (float) (centerY + radius * Math.sin(angle * i));</div><div class="line">        mPath.lineTo(x, y);</div><div class="line">        canvas.drawPath(mPath, mRadarLinePaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1b4ac177fa2e347f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网格中线效果图"></p><p>绘制原理与绘制蜘蛛网格是一样的，先找到各个末端点的坐标，然后画一条从中心点到末端点的连线即可。</p><h3 id="五、画数据图"><a href="#五、画数据图" class="headerlink" title="五、画数据图"></a>五、画数据图</h3><p>绘制数据区域其实也很简单，首先要确定每个数据点的位置。当然，网格线中的每一层网格都应该对应一个数值，在这里为了方便起见，将网格的最大值设为 4，即每一层数值是按 1,2,3,4 分布的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private int maxValue = 4;                   // 最大值</div><div class="line">private double[] data = &#123;2,3,1,3,4,3&#125;;      // 数据</div><div class="line"></div><div class="line">private void drawRegion(Canvas canvas) &#123;</div><div class="line">    mPath.reset();</div><div class="line">    for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">        double percent = data[i] / maxValue;</div><div class="line">        float x = (float) (centerX + radius * Math.cos(angle * i) * percent);</div><div class="line">        float y = (float) (centerY + radius * Math.sin(angle * i) * percent);</div><div class="line">        if (i == 0) &#123;</div><div class="line">            mPath.moveTo(x, centerY);</div><div class="line">        &#125; else &#123;</div><div class="line">            mPath.lineTo(x, y);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    canvas.drawPath(mPath, mValuePaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1b41b211cf4a3646.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p><h3 id="六、完整代码"><a href="#六、完整代码" class="headerlink" title="六、完整代码"></a>六、完整代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.content.Context;</div><div class="line">import android.graphics.Canvas;</div><div class="line">import android.graphics.Color;</div><div class="line">import android.graphics.Paint;</div><div class="line">import android.graphics.Path;</div><div class="line">import android.util.AttributeSet;</div><div class="line">import android.view.View;</div><div class="line"></div><div class="line">import androidx.annotation.Nullable;</div><div class="line"></div><div class="line">public class SpiderView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mRadarPaint;                  // 蜘蛛网</div><div class="line">    private Paint mRadarLinePaint;              // 蜘蛛网辐射的六根线</div><div class="line">    private Paint mValuePaint;                  // 数据</div><div class="line"></div><div class="line">    private int mRadarPaintColor = 0xFF0099CC;  // 网格默认颜色</div><div class="line">    private Path mPath;</div><div class="line"></div><div class="line">    private float radius;                       // 网格最大半径</div><div class="line">    private int centerX;                        // 中心 X</div><div class="line">    private int centerY;                        // 中心 Y</div><div class="line"></div><div class="line">    private int count = 6;                      // 多边形，默认值为 6</div><div class="line">    private double angle = 2 * Math.PI / count; // 角度，值为 2π / count，默认</div><div class="line">    private int maxValue = 4;                   // 最大值</div><div class="line">    private double[] data = &#123;2,3,1,3,4,3&#125;;      // 数据</div><div class="line"></div><div class="line">    public SpiderView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * init view</div><div class="line">     * Paint、Path</div><div class="line">     */</div><div class="line">    private void init() &#123;</div><div class="line">        mRadarPaint = generatePaint(mRadarPaintColor, Paint.Style.FILL);</div><div class="line">        mRadarLinePaint = generatePaint(Color.WHITE, Paint.Style.STROKE);</div><div class="line">        mValuePaint = generatePaint(0xAFFF0000, Paint.Style.FILL);</div><div class="line"></div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onSizeChanged(int w, int h, int oldW, int oldH) &#123;</div><div class="line">        // 获得布局中心</div><div class="line">        centerX = w / 2;</div><div class="line">        centerY = h / 2;</div><div class="line">        radius = Math.min(w, h) / 2f * 0.8f;</div><div class="line">        postInvalidate();</div><div class="line">        super.onSizeChanged(w, h, oldW, oldH);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        // 绘制蜘蛛网格</div><div class="line">        drawPolygon(canvas);</div><div class="line">        // 绘制中线</div><div class="line">        drawLines(canvas);</div><div class="line">        // 画数据图</div><div class="line">        drawRegion(canvas);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void drawPolygon(Canvas canvas) &#123;</div><div class="line">        float r = radius / maxValue;            // r是蜘蛛丝之间的间距</div><div class="line">        for (int i = 1; i &lt;= maxValue; i++) &#123;   // 中心点不用绘制</div><div class="line">            float curR = r * i;                 // 当前半径</div><div class="line">            mPath.reset();</div><div class="line">            for (int j = 0; j &lt; count; j++) &#123;</div><div class="line">                if (j == 0) &#123;</div><div class="line">                    mPath.moveTo(centerX + curR, centerY);</div><div class="line">                &#125; else &#123;</div><div class="line">                    // 根据半径，计算出蜘蛛丝上每个点的坐标</div><div class="line">                    float x = (float) (centerX + curR * Math.cos(angle * j));</div><div class="line">                    float y = (float) (centerY + curR * Math.sin(angle * j));</div><div class="line">                    mPath.lineTo(x, y);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            mPath.close();                      // 闭合路径</div><div class="line">            mRadarPaint.setAlpha(getRadarPaintColor(i));</div><div class="line">            canvas.drawPath(mPath, mRadarPaint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void drawLines(Canvas canvas) &#123;</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            mPath.reset();</div><div class="line">            mPath.moveTo(centerX, centerY);</div><div class="line">            float x = (float) (centerX + radius * Math.cos(angle * i));</div><div class="line">            float y = (float) (centerY + radius * Math.sin(angle * i));</div><div class="line">            mPath.lineTo(x, y);</div><div class="line">            canvas.drawPath(mPath, mRadarLinePaint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void drawRegion(Canvas canvas) &#123;</div><div class="line">        mPath.reset();</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            double percent = data[i] / maxValue;</div><div class="line">            float x = (float) (centerX + radius * Math.cos(angle * i) * percent);</div><div class="line">            float y = (float) (centerY + radius * Math.sin(angle * i) * percent);</div><div class="line">            if (i == 0) &#123;</div><div class="line">                mPath.moveTo(x, centerY);</div><div class="line">            &#125; else &#123;</div><div class="line">                mPath.lineTo(x, y);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        canvas.drawPath(mPath, mValuePaint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 初始化画笔</div><div class="line">     * @param color 画笔颜色</div><div class="line">     * @param style 画笔样式</div><div class="line">     * @return Paint</div><div class="line">     */</div><div class="line">    private Paint generatePaint(int color, Paint.Style style) &#123;</div><div class="line">        Paint paint = new Paint();</div><div class="line">        paint.setColor(color);</div><div class="line">        paint.setStyle(style);</div><div class="line">        paint.setAntiAlias(true);</div><div class="line">        return paint;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 由内到外，增加透明度</div><div class="line">     * @param i 第几个网格，从中心点算起</div><div class="line">     * @return int alpha 值</div><div class="line">     */</div><div class="line">    private int getRadarPaintColor(int i) &#123;</div><div class="line">        if (i &gt; count || i &lt; 1) &#123;</div><div class="line">            return 0xFF;</div><div class="line">        &#125;</div><div class="line">        int alpha = Color.alpha(mRadarPaintColor);</div><div class="line">        int colorStep = alpha / (maxValue - 1) - 10;</div><div class="line">        alpha = alpha - colorStep * (i - 1);</div><div class="line">        return alpha;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.2 精通自定义 View 之控件高级属性——Window 与 WindowManager</title>
      <link href="/2019/07/13/05%20CUSTOM%20VIEW/13.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94Window%20%E4%B8%8E%20WindowManager/"/>
      <url>/2019/07/13/05%20CUSTOM%20VIEW/13.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94Window%20%E4%B8%8E%20WindowManager/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-57876f3181a1bfeb.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p>Window 表示窗口，在某些特殊的时候，比如需要在桌面或者锁屏上显示一些类似悬浮窗的效果，就需要用到 Window。Android 中所有的视图都是通过 Window 来呈现的，不管是 Activity、Dialog 还是 Toast，它们的视图实际上都是附加在 Window 上的。而 WindowManager 则提供了对这些 Window 的统一管理功能。</p><p><div id="jump1"></div></p><h3 id="13-2-1-Window-与-WindowManager-的联系"><a href="#13-2-1-Window-与-WindowManager-的联系" class="headerlink" title="13.2.1 Window 与 WindowManager 的联系"></a>13.2.1 Window 与 WindowManager 的联系</h3><p>为了分析 Window 的工作机制，我们需要了解如何使用 WindowManager 来添加一个 Window。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">WindowManager manager = (WindowManager) getSystemService(Context.WINDOW_SERVICE);</div><div class="line">WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams(width, height, type, flags, format);</div><div class="line">manager.addView(btn, layoutParams);</div></pre></td></tr></table></figure></p><p>上面的伪代码看起来非常简单，在构建 WindowManager.LayoutParams 时，其中的 type 和 flags 参数比较重要。</p><p>flags 参数有很多选项，用来控制 Window 的显示特性。我们来看几个常用的选项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static final int FLAG_NOT_FOCUSABLE = 0x00000008;</div></pre></td></tr></table></figure></p><p>表示此 Window 不需要获取焦点，不接收各种输入时间，此标记会同时启用 FLAG_NOT_TOUCH_MODEL，最终事件会直接传递给下层具有焦点的 Window。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static final int FLAG_NOT_TOUCH_MODEL = 0x00000020;</div></pre></td></tr></table></figure></p><p>自己 Window 区域内的事件自己处理；自己 Window 区域外的事件传递给底层 Window 处理。一般这个选项会默认开启，否则其他 Window 无法接收事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static final int FLAG_SHOW_WHEN_LOCKED = 0x00080000;</div></pre></td></tr></table></figure></p><p>可以让此 Window 显示在锁屏上。</p><p>type 参数是 int 类型的，表示 Window 的类型。Window 有三种类型：应用 Window、子 Window 和系统 Window。应用 Window 对应着一个 Activity。子 Window 不能独立存在，它需要附属在特定的父 Window 中，比如 Dialog 就是一个子 Window。系统 Window 是需要声明权限才能创建的，比如 Toast 和系统状态栏都是系统 Window。</p><p>Window 是分层的，层级大的 Window 会覆盖在层级小的 Window 上面。</p><ul><li>应用 Window 的层级范围：1 ~ 99。</li><li>子 Window 的层级范围：1000 ~ 1999。</li><li>系统 Window 的层级范围：2000 ~ 2999。</li></ul><p>type 参数就对应这些数字。如果想让 Window 置于顶层，则采用较大的层级即可；如果是系统类型的 Window，则需要在 AndroidMenifest.xml 中配置如下权限声明，否则会报权限不足的错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;</div></pre></td></tr></table></figure></p><p>WindowManager 提供的功能很简单，常用的只有三个方法，即添加 View、更新 View 和删除 View。这三个方法定义在 ViewManager 中，而 WindowManager 继承自 ViewManager。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@SystemService(Context.WINDOW_SERVICE)</div><div class="line">public interface WindowManager extends ViewManager &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public interface ViewManager &#123;</div><div class="line">    public void addView(View view, ViewGroup.LayoutParams params);</div><div class="line">    public void updateViewLayout(View view, ViewGroup.LayoutParams params);</div><div class="line">    public void removeView(View view);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><div id="jump2"></div></p><h3 id="13-2-2-示例：悬浮窗"><a href="#13-2-2-示例：悬浮窗" class="headerlink" title="13.2.2 示例：悬浮窗"></a>13.2.2 示例：悬浮窗</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4cd1f019e2f0d37f.gif?imageMogr2/auto-orient/strip" alt=""></p><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity implements View.OnTouchListener, View.OnClickListener &#123;</div><div class="line"></div><div class="line">    private ImageView mImageView;</div><div class="line">    private WindowManager.LayoutParams mLayoutParams;</div><div class="line">    private WindowManager mWindowManager;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</div><div class="line">            Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);</div><div class="line">            startActivityForResult(intent, 100);</div><div class="line">        &#125;</div><div class="line">        initView();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initView() &#123;</div><div class="line">        findViewById(R.id.add_btn).setOnClickListener(this);</div><div class="line">        findViewById(R.id.rmv_btn).setOnClickListener(this);</div><div class="line">        mWindowManager = (WindowManager) getApplicationContext().getSystemService(Context.WINDOW_SERVICE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onClick(View v) &#123;</div><div class="line">        if (v.getId() == R.id.add_btn) &#123;</div><div class="line">            mImageView = new ImageView(this);</div><div class="line">            mImageView.setBackgroundResource(R.mipmap.ic_launcher_round);</div><div class="line">            mLayoutParams = new WindowManager.LayoutParams(</div><div class="line">                    WindowManager.LayoutParams.WRAP_CONTENT,</div><div class="line">                    WindowManager.LayoutParams.WRAP_CONTENT,</div><div class="line">                    2099,</div><div class="line">                    WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL</div><div class="line">                    | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE</div><div class="line">                    | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED,</div><div class="line">                    PixelFormat.TRANSPARENT );</div><div class="line">            mLayoutParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_ERROR;</div><div class="line">            mLayoutParams.gravity = Gravity.TOP | Gravity.LEFT;</div><div class="line">            mLayoutParams.x = 0;</div><div class="line">            mLayoutParams.y = 300;</div><div class="line">            mImageView.setOnTouchListener(this);</div><div class="line">            mWindowManager.addView(mImageView, mLayoutParams);</div><div class="line">        &#125; else if (v.getId() == R.id.rmv_btn) &#123;</div><div class="line">            if (mWindowManager != null &amp;&amp; mImageView != null) &#123;</div><div class="line">                mWindowManager.removeViewImmediate(mImageView);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouch(View v, MotionEvent event) &#123;</div><div class="line">        int rawX = (int) event.getRawX();</div><div class="line">        int rawY = (int) event.getRawY();</div><div class="line"></div><div class="line">        if (event.getAction() == MotionEvent.ACTION_MOVE) &#123;</div><div class="line">            mLayoutParams.x = rawX;</div><div class="line">            mLayoutParams.y = rawY;</div><div class="line">            mWindowManager.updateViewLayout(mImageView, mLayoutParams);</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123;</div><div class="line">        super.onActivityResult(requestCode, resultCode, data);</div><div class="line">        if (requestCode == 100) &#123;</div><div class="line">            initView();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1ffdbe1e1ce48122.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.1 精通自定义 View 之控件高级属性——GestureDetector 手势检测</title>
      <link href="/2019/07/13/05%20CUSTOM%20VIEW/13.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94GestureDetector%20%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B/"/>
      <url>/2019/07/13/05%20CUSTOM%20VIEW/13.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94GestureDetector%20%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-fe74915388b1db8c.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="13-1-1-概述"><a href="#13-1-1-概述" class="headerlink" title="13.1.1 概述"></a>13.1.1 概述</h3><p>GestureDetector，手势检测类，通过这个类可以识别很多手势。在识别出手势之后，具体的事物处理则交由程序员自己来实现。</p><p>此类提供了两个接口（OnGestureListener、OnDoubleTapListener）和一个外部类（SimpleOnGestureListener）。这个外部类其实是两个接口中所有函数的集成，它包含了这两个接口里所有必须实现的函数，而且都已经被重写，但所有函数体都是空的。该类是一个静态类，程序员可以在外部继承这个类，重写里面的手势处理函数。</p><p><div id="jump2"></div></p><h3 id="13-1-2-GestureDetector-OnGestureListener-接口"><a href="#13-1-2-GestureDetector-OnGestureListener-接口" class="headerlink" title="13.1.2 GestureDetector.OnGestureListener 接口"></a>13.1.2 GestureDetector.OnGestureListener 接口</h3><h4 id="1-基本讲解"><a href="#1-基本讲解" class="headerlink" title="1. 基本讲解"></a>1. 基本讲解</h4><p>如果我们写一个类并继承自 OnGestureListener，则会提示有几个必须重写的函数。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">private class GestureListener implements GestureDetector.OnGestureListener &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onDown(MotionEvent e) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onShowPress(MotionEvent e) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onSingleTapUp(MotionEvent e) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onLongPress(MotionEvent e) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这些函数在什么情况下才会被触发呢？</p><ul><li>onDown(MotionEvent e)：用户按下屏幕就会触发该函数。</li><li>onShowPress(MotionEvent e)：如果按下的时间超过瞬间，而且在按下的时候没有松开或者是拖动的，该函数就会被触发。</li><li>onLongPress(MotionEvent e)：长按触摸屏，超过一定时长，就会触发这个函数。</li></ul><p>触发顺序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onDown —&gt; onShowPress —&gt; onLongPress</div></pre></td></tr></table></figure></p><ul><li>onSingleTapUp(MotionEvent e)：一次单独的轻击抬起操作，也就是轻击一下屏幕，立刻抬起来，才会触发这个函数。当然，如果除 down 以外还有其他操作，就不再算是单独操作了，也就不会触发这个函数。</li></ul><p>单击一下非常快的（不滑动）Touchup，触发顺序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onDown —&gt; onSingleTapUp —&gt; onSingleTapConfirmed</div></pre></td></tr></table></figure></p><p>单击一下稍微慢一点的（不滑动）Touchup，触发顺序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onDown —&gt; onShowPress —&gt; onSingleTapUp —&gt; onSingleTapConfirmed</div></pre></td></tr></table></figure></p><ul><li>onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY)：滑屏，用户按下触摸屏、快速移动后松开，由一个 MotionEvent ACTION_DOWN、多个 ACTION_MOVE、一个 ACTION_UP 触发。</li><li>onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY)：在屏幕上拖动事件。无论是用手拖动 View，还是以抛的动作滚动，都会多次触发这个函数，在 ACTION_MOVE 动作发生时就会触发该函数。</li></ul><p>滑屏，即手指出动屏幕后，稍微滑动后立即松开，触发顺序为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onDown —&gt; onScroll —&gt; onScroll —&gt; onScroll —&gt; ... —&gt; onFling</div></pre></td></tr></table></figure></p><p>拖动，触发顺序为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onDown —&gt; onScroll —&gt; onScroll —&gt; onFling</div></pre></td></tr></table></figure></p><p>可见，无论是滑屏还是拖动，影响的只是中间 onScroll 被触发的数量而已，最终都会触发 onFling 事件。</p><h4 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h4><p>要使用 GestureDetector，有四步要走。<br>1）创建 OnGestureListener() 监听函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 可以构造实例</div><div class="line">GestureDetector.OnGestureListener listener = new GestureDetector.OnGestureListener() &#123;&#125;;</div><div class="line"></div><div class="line">// 也可以构造类</div><div class="line">private class GestureListener implements GestureDetector.OnGestureListener &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>2）创建 GestureDetector 实例 mGestureDetector。<br>构造函数有以下几个，根据需要选择即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GestureDetector(OnGestureListener listener)</div><div class="line">GestureDetector(Context context, OnGestureListener listener)</div><div class="line">GestureDetector(Context context, OnGestureListener listener, Handler handler)</div><div class="line">GestureDetector(Context context, OnGestureListener listener, Handler handler, boolean unused)</div></pre></td></tr></table></figure></p><p>3）在 onTouch(View v, MotionEvent event) 中进行拦截。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean onTouch(View v, MotionEvent event) &#123;</div><div class="line">    return mGestureDetector.onTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>4）绑定控件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TextView tv = findViewById(R.id.tv);</div><div class="line">tv.setOnTouchListener(this);</div></pre></td></tr></table></figure></p><p>完整代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity implements View.OnTouchListener &#123;</div><div class="line"></div><div class="line">    private GestureDetector mGestureDetector;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        mGestureDetector = new GestureDetector(new GestureListener());</div><div class="line"></div><div class="line">        TextView tv = findViewById(R.id.tv);</div><div class="line">        tv.setOnTouchListener(this);</div><div class="line">        tv.setFocusable(true);</div><div class="line">        tv.setClickable(true);</div><div class="line">        tv.setLongClickable(true);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouch(View v, MotionEvent event) &#123;</div><div class="line">        return mGestureDetector.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class GestureListener implements GestureDetector.OnGestureListener &#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public boolean onDown(MotionEvent e) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onDown&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onShowPress(MotionEvent e) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onShowPress&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public boolean onSingleTapUp(MotionEvent e) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onSingleTapUp&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onScroll&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onLongPress(MotionEvent e) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onLongPress&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onFling&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><div id="jump3"></div></p><h3 id="13-1-3-GestureDetector-OnDoubleTapListener-接口"><a href="#13-1-3-GestureDetector-OnDoubleTapListener-接口" class="headerlink" title="13.1.3 GestureDetector.OnDoubleTapListener 接口"></a>13.1.3 GestureDetector.OnDoubleTapListener 接口</h3><h4 id="1-构建"><a href="#1-构建" class="headerlink" title="1. 构建"></a>1. 构建</h4><p>有两种方式设置双击监听。<br>方法一：新建一个类，同时派生自 OnGestureListener 和 OnDoubleTapListener。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private class GestureListener implements GestureDetector.OnGestureListener,  </div><div class="line">        GestureDetector.OnDoubleTapListener &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>方法二：<br>使用 GestureDetector.setOnDoubleTapListener() 函数设置双击监听。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 构建 GestureDetector 实例</div><div class="line">mGestureDetector = new GestureDetector(new GestureListener());</div><div class="line"></div><div class="line">private class GestureListener implements GestureDetector.OnGestureListener &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 设置双击监听</div><div class="line">mGestureDetector.setOnDoubleTapListener(new DoubleTapListener());</div><div class="line">private class DoubleTapListener implements GestureDetector.OnDoubleTapListener &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>无论方法一还是方法二，都需要派生自 GestureDetector.OnGestureListener。</p><h4 id="2-函数讲解"><a href="#2-函数讲解" class="headerlink" title="2. 函数讲解"></a>2. 函数讲解</h4><p>先来看下 OnDoubleTapListener 接口必须重写的三个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private class DoubleTapListener implements GestureDetector.OnDoubleTapListener &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onSingleTapConfirmed(MotionEvent e) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onDoubleTap(MotionEvent e) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onDoubleTapEvent(MotionEvent e) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>onSingleTapConfirmed(MotionEvent e)：单击事件，用来判定该次单击是 SingleTap，而不是 DoubleTap。如果连续单击两次，就是 DoubleTap 手势；如果只单击一次，系统等待一段时间后没有收到第二次单击，则判定该次单击为 SingleTap，而不是 DoubleTap，然后触发 SingleTapConfirm 事件。触发顺序是：onDown —&gt; onSingleTapUp —&gt; onSingleTapConfirmed。有这样一个函数 onSingleTapUp()，它和 onSingleTapConfirmed() 函数容易混淆。二者的区别是：对于 onSingleTapUp() 函数来说，只要手抬起就会被触发；而对于 onSingleTapConfirmed() 函数来说，如果双击，则该函数就不会被触发。</li><li>onDoubleTap(MotionEvent e)：双击事件。</li><li>onDoubleTapEvent(MotionEvent e)：双击间隔中发生的动作。指在触发 onDoubleTap 以后，在双击之间发生的其他动作，包含 down、up 和 move 事件。</li></ul><p>在 13.1.2 节例子的基础上，添加双击监听，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity implements View.OnTouchListener &#123;</div><div class="line"></div><div class="line">    private GestureDetector mGestureDetector;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        mGestureDetector = new GestureDetector(new GestureListener());</div><div class="line">        mGestureDetector.setOnDoubleTapListener(new DoubleTapListener());</div><div class="line"></div><div class="line">        TextView tv = findViewById(R.id.tv);</div><div class="line">        tv.setOnTouchListener(this);</div><div class="line">        tv.setFocusable(true);</div><div class="line">        tv.setClickable(true);</div><div class="line">        tv.setLongClickable(true);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouch(View v, MotionEvent event) &#123;</div><div class="line">        return mGestureDetector.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class GestureListener implements GestureDetector.OnGestureListener &#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public boolean onDown(MotionEvent e) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onDown&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onShowPress(MotionEvent e) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onShowPress&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public boolean onSingleTapUp(MotionEvent e) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onSingleTapUp&quot;);</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onScroll&quot;);</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onLongPress(MotionEvent e) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onLongPress&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onFling&quot;);</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class DoubleTapListener implements GestureDetector.OnDoubleTapListener &#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public boolean onSingleTapConfirmed(MotionEvent e) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onSingleTapConfirmed&quot;);</div><div class="line">            Toast.makeText(MainActivity.this, &quot;onSingleTapConfirmed&quot;, Toast.LENGTH_LONG).show();</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public boolean onDoubleTap(MotionEvent e) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onDoubleTap&quot;);</div><div class="line">            Toast.makeText(MainActivity.this, &quot;onDoubleTap&quot;, Toast.LENGTH_LONG).show();</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public boolean onDoubleTapEvent(MotionEvent e) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onDoubleTapEvent:&quot; + e.getAction());</div><div class="line">            Toast.makeText(MainActivity.this, &quot;onDoubleTapEvent&quot;, Toast.LENGTH_LONG).show();</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>双击所对应的事件触发顺序如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d8ed3d75951e7a32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>第二次单击时，先触发 onDoubleTap，再触发 onDown。</li><li>在触发 onDoubleTap 以后，就开始触发 onDoubleTapEvent。onDoubleTapEvent 后面的数字代表当前的事件，0 代表 ACTION_DOWN，1 代表 ACTION_UP，2 代表 ACTION_MOVE。</li></ul><p>轻轻单击一下，对应的事件触发顺序如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-6662fcd81e5a2fa5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><div id="jump4"></div></p><h3 id="13-1-4-GestureDetector-SimpleOnGestureListener-类"><a href="#13-1-4-GestureDetector-SimpleOnGestureListener-类" class="headerlink" title="13.1.4 GestureDetector.SimpleOnGestureListener 类"></a>13.1.4 GestureDetector.SimpleOnGestureListener 类</h3><p>SimpleOnGestureListener 类与 OnGestureListener 和 OnDoubleTapListener 接口的不同之处在于：<br>1）这是一个类，在它的基础上新建类，要用 extends 派生，而不能用 implements 继承。<br>2）OnGestureListener 和 OnDoubleTapListener 接口里的函数都是被强制重写的，即使用不到也要重写出来一个空函数；而在 SimpleOnGestureListener 类的实例或派生类中不必如此，可以根据情况，用到哪个函数就重写哪个函数，因为 SimpleOnGestureListener 类本身已经实现了这两个接口中的所有函数，只是里面全是空的而已。</p><p>下面利用 SimpleOnGestureListener 类来重新实现前面的几个效果，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity implements View.OnTouchListener &#123;</div><div class="line"></div><div class="line">    private GestureDetector mGestureDetector;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        mGestureDetector = new GestureDetector(new XSimpleGestureListener());</div><div class="line"></div><div class="line">        TextView tv = findViewById(R.id.tv);</div><div class="line">        tv.setOnTouchListener(this);</div><div class="line">        tv.setFocusable(true);</div><div class="line">        tv.setClickable(true);</div><div class="line">        tv.setLongClickable(true);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouch(View v, MotionEvent event) &#123;</div><div class="line">        return mGestureDetector.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class XSimpleGestureListener extends GestureDetector.SimpleOnGestureListener &#123;</div><div class="line"></div><div class="line">        /***** OnGestureListener 的函数 *****/</div><div class="line">        public boolean onDown(MotionEvent e) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void onShowPress(MotionEvent e) &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public boolean onSingleTapUp(MotionEvent e) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void onLongPress(MotionEvent e) &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /***** OnDoubleTapListener 的函数 *****/</div><div class="line">        public boolean onDoubleTap(MotionEvent e) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public boolean onDoubleTapEvent(MotionEvent e) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public boolean onSingleTapConfirmed(MotionEvent e) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><div id="jump5"></div></p><h3 id="13-1-5-onFling-函数的应用"><a href="#13-1-5-onFling-函数的应用" class="headerlink" title="13.1.5 onFling() 函数的应用"></a>13.1.5 onFling() 函数的应用</h3><p>可以利用 onFling() 函数来识别当前用户是在左滑还是在右滑。先来看一下 onFling() 函数的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY)</div></pre></td></tr></table></figure></p><p>参数：</p><ul><li>e1：第一个 ACTION_DOWN MotionEvent。</li><li>e2：最后一个 ACTION_DOWN MotionEvent。</li><li>velocityX：X 轴上的移动速度，单位为像素/秒。</li><li>velocityY：Y 轴上的移动速度，单位为像素/秒。</li></ul><p>实现的功能：当用户向左滑动距离超过 100 像素，且滑动速度超过 100 像素/秒时，即判断为向左滑动；向右同理。核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private class XSimpleGestureListener extends GestureDetector.SimpleOnGestureListener &#123;</div><div class="line"></div><div class="line">    final int FLING_MIN_DISTANCE = 100;</div><div class="line">    final int FLING_MIN_VELOCITY = 100;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123;</div><div class="line">        // 向左滑</div><div class="line">        if (e1.getX() - e2.getX() &gt; FLING_MIN_DISTANCE</div><div class="line">                &amp;&amp; Math.abs(velocityX) &gt; FLING_MIN_VELOCITY) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;Fling left&quot;);</div><div class="line">        &#125;</div><div class="line">        // 向右滑</div><div class="line">        else if (e2.getX() - e1.getX() &gt; FLING_MIN_DISTANCE</div><div class="line">                &amp;&amp; Math.abs(velocityX) &gt; FLING_MIN_VELOCITY) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;Fling right&quot;);</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a39b0276684018e4.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12.3 精通自定义 View 之封装控件——实现 FlowLayout 容器</title>
      <link href="/2019/07/12/05%20CUSTOM%20VIEW/12.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%20FlowLayout%20%E5%AE%B9%E5%99%A8/"/>
      <url>/2019/07/12/05%20CUSTOM%20VIEW/12.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%20FlowLayout%20%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-8635a9758921431d.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p>FlowLayout 容器效果图如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-3322140af46dbd6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="FlowLayout 容器效果图"></p><p><div id="jump1"></div></p><h3 id="12-3-1-XML-布局"><a href="#12-3-1-XML-布局" class="headerlink" title="12.3.1 XML 布局"></a>12.3.1 XML 布局</h3><p>先定义一个 style 标签，这是为 FlowLayout 中的 TextView 定义的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;resources&gt;</div><div class="line">    ...</div><div class="line">    &lt;style name=&quot;text_flag&quot;&gt;</div><div class="line">        &lt;item name=&quot;android:layout_width&quot;&gt;wrap_content&lt;/item&gt;</div><div class="line">        &lt;item name=&quot;android:layout_height&quot;&gt;wrap_content&lt;/item&gt;</div><div class="line">        &lt;item name=&quot;android:layout_margin&quot;&gt;4dp&lt;/item&gt;</div><div class="line">        &lt;item name=&quot;android:background&quot;&gt;@drawable/flag&lt;/item&gt;</div><div class="line">        &lt;item name=&quot;android:textColor&quot;&gt;#FFFFFF&lt;/item&gt;</div><div class="line">    &lt;/style&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure></p><p>/res/drawable/flag.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;shape</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:shape=&quot;rectangle&quot;&gt;</div><div class="line">    &lt;solid android:color=&quot;@color/colorAccent&quot;/&gt;</div><div class="line">    &lt;padding</div><div class="line">        android:top=&quot;5dp&quot;</div><div class="line">        android:bottom=&quot;5dp&quot;</div><div class="line">        android:left=&quot;10dp&quot;</div><div class="line">        android:right=&quot;10dp&quot;/&gt;</div><div class="line">    &lt;corners android:radius=&quot;30dp&quot;/&gt;</div><div class="line">&lt;/shape&gt;</div></pre></td></tr></table></figure></p><p>act_main.xml 的布局代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line">    &lt;com.xxt.xtest.FlowLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;&gt;</div><div class="line">        &lt;TextView</div><div class="line">            style=&quot;@style/text_flag&quot;</div><div class="line">            android:text=&quot;Welcome&quot;/&gt;</div><div class="line">        &lt;TextView</div><div class="line">            style=&quot;@style/text_flag&quot;</div><div class="line">            android:text=&quot;IT 工程师&quot;/&gt;</div><div class="line">        &lt;TextView</div><div class="line">            style=&quot;@style/text_flag&quot;</div><div class="line">            android:text=&quot;我真是可以的&quot;/&gt;</div><div class="line">        &lt;TextView</div><div class="line">            style=&quot;@style/text_flag&quot;</div><div class="line">            android:text=&quot;你觉得呢&quot;/&gt;</div><div class="line">        &lt;TextView</div><div class="line">            style=&quot;@style/text_flag&quot;</div><div class="line">            android:text=&quot;不要只知道挣钱&quot;/&gt;</div><div class="line">        &lt;TextView</div><div class="line">            style=&quot;@style/text_flag&quot;</div><div class="line">            android:text=&quot;努力 ing&quot;/&gt;</div><div class="line">        &lt;TextView</div><div class="line">            style=&quot;@style/text_flag&quot;</div><div class="line">            android:text=&quot;I thick i can&quot;/&gt;</div><div class="line">    &lt;/com.xxt.xtest.FlowLayout&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p><div id="jump2"></div></p><h3 id="12-3-2-提取-margin-值与重写-onMeasure-函数"><a href="#12-3-2-提取-margin-值与重写-onMeasure-函数" class="headerlink" title="12.3.2 提取 margin 值与重写 onMeasure() 函数"></a>12.3.2 提取 margin 值与重写 onMeasure() 函数</h3><h4 id="1-提取-margin-值"><a href="#1-提取-margin-值" class="headerlink" title="1. 提取 margin 值"></a>1. 提取 margin 值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class FlowLayout extends ViewGroup &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected LayoutParams generateLayoutParams(LayoutParams p) &#123;</div><div class="line">        return new MarginLayoutParams(p);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public LayoutParams generateLayoutParams(AttributeSet attrs) &#123;</div><div class="line">        return new MarginLayoutParams(getContext(), attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected LayoutParams generateDefaultLayoutParams() &#123;</div><div class="line">        return new MarginLayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2-重写-onMeasure-函数"><a href="#2-重写-onMeasure-函数" class="headerlink" title="2. 重写 onMeasure() 函数"></a>2. 重写 onMeasure() 函数</h4><p>要实现 FlowLayout，必然涉及下面几个问题。<br><strong>1）何时换行</strong><br>从效果图中可以看到，FlowLayout 的布局是一行行的，如果当期已经放不下一个控件了，就把这个控件移到下一行显示。所以需要一个变量来计算当前行已经占据的宽度，以判断剩下的空间是否还能容得下下一个控件。<br><strong>2）如何得到 FlowLayout 的宽度</strong><br>FlowLayout 的宽度是所有行宽度的最大值，所以我们要记录每一行所占据的宽度值，进而找到所有值中的最大值。<br><strong>3）如何得到 FlowLayout 的高度</strong><br>FlowLayout 的高度是每一行高度的总和，而每一行的高度则取该行中所有控件高度的最大值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">    super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">    int measureWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">    int measureHeight = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">    int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">    int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"></div><div class="line">    int lineWidth = 0;      // 记录每一行的宽度</div><div class="line">    int lineHeight = 0;     // 记录每一行的高度</div><div class="line">    int width = 0;          // 记录整个 FlowLayout 的宽度</div><div class="line">    int height = 0;         // 记录整个 FlowLayout 的高度</div><div class="line"></div><div class="line">    int count = getChildCount();</div><div class="line">    for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">        View child = getChildAt(i);</div><div class="line">        measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">        // 计算控件的宽高时，要加上上下左右的 margin 值</div><div class="line">        MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">        int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;</div><div class="line">        int childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;</div><div class="line"></div><div class="line">        if (lineWidth + childWidth &gt; measureWidth) &#123;</div><div class="line">            // 需要换行</div><div class="line">            width = Math.max(lineWidth, childWidth);</div><div class="line">            height += lineHeight;</div><div class="line">            // 当前行放不下当前控件，而将此控件调到下一行</div><div class="line">            // 所以将此控件的高度和宽度初始化给 lineWidth、lineHeight</div><div class="line">            lineWidth = childWidth;</div><div class="line">            lineHeight = childHeight;</div><div class="line">        &#125; else &#123;</div><div class="line">            // 否则累加值 lineWidth，lineHeight 并取最大高度</div><div class="line">            lineWidth += childWidth;</div><div class="line">            lineHeight = Math.max(lineHeight, childHeight);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 因为最后一行是不会超出 width 范围的，所以需要单独处理</div><div class="line">        if (i == count - 1) &#123;</div><div class="line">            width = Math.max(width, lineWidth);</div><div class="line">            height += lineHeight;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    setMeasuredDimension((measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth : width,</div><div class="line">            (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight : height);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="3-重写-onLayout-函数——布局所有子控件"><a href="#3-重写-onLayout-函数——布局所有子控件" class="headerlink" title="3. 重写 onLayout() 函数——布局所有子控件"></a>3. 重写 onLayout() 函数——布局所有子控件</h4><p>在 onLayout() 函数中需要一个个布局子控件。由于控件要后移和换行，所以我们要标记当前控件的 top 坐标和 left 坐标。然后计算每个控件的 top 坐标和 left 坐标，再调用 layout(int left, int top, int right, int bottom)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">    int count = getChildCount();</div><div class="line">    int lineWidth = 0;      // 累加当前行的行宽</div><div class="line">    int lineHeight = 0;     // 当前行的行高</div><div class="line">    int top = 0, left = 0;  // 当前控件的 top 坐标和 left 坐标</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">        View child = getChildAt(i);</div><div class="line">        MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">        int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;</div><div class="line">        int childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;</div><div class="line">        if (childWidth + lineWidth &gt; getMeasuredWidth()) &#123;</div><div class="line">            // 如果换行，则当前控件将放到下一行，从最左边开始，所以 left 就是 0；</div><div class="line">            // 而 top 则需要加上上一行的行高，才是这个控件的 top 坐标</div><div class="line">            top += lineHeight;</div><div class="line">            left = 0;</div><div class="line">            lineHeight = childHeight;</div><div class="line">            lineWidth = childWidth;</div><div class="line">        &#125; else &#123;</div><div class="line">            lineHeight = Math.max(lineHeight, childHeight);</div><div class="line">            lineWidth += childWidth;</div><div class="line">        &#125;</div><div class="line">        // 计算 childView 的 left、top、right、bottom</div><div class="line">        int lc = left + lp.leftMargin;</div><div class="line">        int tc = top + lp.topMargin;</div><div class="line">        int rc = lc + child.getMeasuredWidth();</div><div class="line">        int bc = tc + child.getMeasuredHeight();</div><div class="line">        child.layout(lc, tc, rc, bc);</div><div class="line">        // 将 left 置为下一个子控件的起始点</div><div class="line">        left += childWidth;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><div id="jump3"></div></p><h3 id="12-3-3-完整代码"><a href="#12-3-3-完整代码" class="headerlink" title="12.3.3 完整代码"></a>12.3.3 完整代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line">public class FlowLayout extends ViewGroup &#123;</div><div class="line"></div><div class="line">    public FlowLayout(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">        int measureWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        int measureHeight = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">        int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">        int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"></div><div class="line">        int lineWidth = 0;      // 记录每一行的宽度</div><div class="line">        int lineHeight = 0;     // 记录每一行的高度</div><div class="line">        int width = 0;          // 记录整个 FlowLayout 的宽度</div><div class="line">        int height = 0;         // 记录整个 FlowLayout 的高度</div><div class="line"></div><div class="line">        int count = getChildCount();</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            View child = getChildAt(i);</div><div class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">            // 计算控件的宽高时，要加上上下左右的 margin 值</div><div class="line">            MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">            int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;</div><div class="line">            int childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;</div><div class="line"></div><div class="line">            if (lineWidth + childWidth &gt; measureWidth) &#123;</div><div class="line">                // 需要换行</div><div class="line">                width = Math.max(lineWidth, childWidth);</div><div class="line">                height += lineHeight;</div><div class="line">                // 当前行放不下当前控件，而将此控件调到下一行</div><div class="line">                // 所以将此控件的高度和宽度初始化给 lineWidth、lineHeight</div><div class="line">                lineWidth = childWidth;</div><div class="line">                lineHeight = childHeight;</div><div class="line">            &#125; else &#123;</div><div class="line">                // 否则累加值 lineWidth，lineHeight 并取最大高度</div><div class="line">                lineWidth += childWidth;</div><div class="line">                lineHeight = Math.max(lineHeight, childHeight);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // 因为最后一行是不会超出 width 范围的，所以需要单独处理</div><div class="line">            if (i == count - 1) &#123;</div><div class="line">                width = Math.max(width, lineWidth);</div><div class="line">                height += lineHeight;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setMeasuredDimension((measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth : width,</div><div class="line">                (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight : height);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">        int count = getChildCount();</div><div class="line">        int lineWidth = 0;      // 累加当前行的行宽</div><div class="line">        int lineHeight = 0;     // 当前行的行高</div><div class="line">        int top = 0, left = 0;  // 当前控件的 top 坐标和 left 坐标</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            View child = getChildAt(i);</div><div class="line">            MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">            int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;</div><div class="line">            int childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;</div><div class="line">            if (childWidth + lineWidth &gt; getMeasuredWidth()) &#123;</div><div class="line">                // 如果换行，则当前控件将放到下一行，从最左边开始，所以 left 就是 0；</div><div class="line">                // 而 top 则需要加上上一行的行高，才是这个控件的 top 坐标</div><div class="line">                top += lineHeight;</div><div class="line">                left = 0;</div><div class="line">                lineHeight = childHeight;</div><div class="line">                lineWidth = childWidth;</div><div class="line">            &#125; else &#123;</div><div class="line">                lineHeight = Math.max(lineHeight, childHeight);</div><div class="line">                lineWidth += childWidth;</div><div class="line">            &#125;</div><div class="line">            // 计算 childView 的 left、top、right、bottom</div><div class="line">            int lc = left + lp.leftMargin;</div><div class="line">            int tc = top + lp.topMargin;</div><div class="line">            int rc = lc + child.getMeasuredWidth();</div><div class="line">            int bc = tc + child.getMeasuredHeight();</div><div class="line">            child.layout(lc, tc, rc, bc);</div><div class="line">            // 将 left 置为下一个子控件的起始点</div><div class="line">            left += childWidth;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected LayoutParams generateLayoutParams(LayoutParams p) &#123;</div><div class="line">        return new MarginLayoutParams(p);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public LayoutParams generateLayoutParams(AttributeSet attrs) &#123;</div><div class="line">        return new MarginLayoutParams(getContext(), attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected LayoutParams generateDefaultLayoutParams() &#123;</div><div class="line">        return new MarginLayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f2691969eacfe1e4.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12.2 精通自定义 View 之封装控件——测量和布局</title>
      <link href="/2019/07/12/05%20CUSTOM%20VIEW/12.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E6%B5%8B%E9%87%8F%E5%92%8C%E5%B8%83%E5%B1%80/"/>
      <url>/2019/07/12/05%20CUSTOM%20VIEW/12.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E6%B5%8B%E9%87%8F%E5%92%8C%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-dcaf8c34cbe11ecb.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="12-2-1-ViewGroup-绘制流程"><a href="#12-2-1-ViewGroup-绘制流程" class="headerlink" title="12.2.1 ViewGroup 绘制流程"></a>12.2.1 ViewGroup 绘制流程</h3><p>View 和 ViewGroup 的绘制流程基本相同，只是在 ViewGroup 中不仅要绘制自己，还要绘制其中的子控件，而 View 只需要绘制自己就可以了。</p><p>绘制流程分为三步：测量、布局、绘制，分别对应 onMeasure()、onLayout()、onDraw() 函数。</p><ul><li>onMeasure()：测量当前控件的大小，为正式布局提供建议（注意：只是建议，至于用不用，要看 onLayout() 函数）。</li><li>onLayout()：使用 layout() 函数对所有字控件进行布局。</li><li>onDraw()：根据布局的位置绘图。</li></ul><p><div id="jump2"></div></p><h3 id="12-2-2-onMeasure-函数与-MeasureSpec"><a href="#12-2-2-onMeasure-函数与-MeasureSpec" class="headerlink" title="12.2.2 onMeasure() 函数与 MeasureSpec"></a>12.2.2 onMeasure() 函数与 MeasureSpec</h3><p>布局绘画涉及两个过程：测量过程和布局过程。测量过程通过 measure() 函数来实现，是 View 树自顶向下的遍历，每个 View 在循环过程中将尺寸细节往下传递，当测量过程完成以后，所有的 View 都存储了自己的尺寸。布局过程则通过 layout() 函数来实现，也是自顶向下的，在这个过程中，每个父 View 负责通过计算好的尺寸放置它的子 View。</p><p>onMeasure() 函数是用来测量当前控件大小的，给 onLayout() 函数提供数值参考。需要特别注意的是，测量完成以后，要通过 setMeasuredDimension(int, int) 函数设置给系统。</p><h4 id="1-onMeasure-函数"><a href="#1-onMeasure-函数" class="headerlink" title="1. onMeasure() 函数"></a>1. onMeasure() 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)</div></pre></td></tr></table></figure><p>参数 widthMeasureSpec 和 heightMeasureSpec 是父类传递给当前 View 的一个建议值，即想把当前 View 的尺寸设置为宽 widthMeasureSpec、高 heightMeasureSpec。</p><h4 id="2-MeasureSpec-的组成"><a href="#2-MeasureSpec-的组成" class="headerlink" title="2. MeasureSpec 的组成"></a>2. MeasureSpec 的组成</h4><p>widthMeasureSpec 和 heightMeasureSpec 转换为二进制数字表示，它们都是 32 位的，前 2 位代表模式（mode），后面 30 位代表数值（size）。</p><h5 id="1）模式分类"><a href="#1）模式分类" class="headerlink" title="1）模式分类"></a>1）模式分类</h5><div class="table-container"><table><thead><tr><th style="text-align:center">模式</th><th style="text-align:center">二进制值</th><th style="text-align:left">含义</th><th style="text-align:left">对应 XML</th></tr></thead><tbody><tr><td style="text-align:center">UNSPECIFIED</td><td style="text-align:center">00000000…00000000</td><td style="text-align:left">父元素不对子元素的确切大小，子元素可以得到任意想要的大小</td><td style="text-align:left">不常用</td></tr><tr><td style="text-align:center">EXACTLY</td><td style="text-align:center">01000000…00000000</td><td style="text-align:left">父元素决定子元素的确切大小，子元素将被限定在给定的边界里而忽略它本身的大小</td><td style="text-align:left">match_parent、具体数值</td></tr><tr><td style="text-align:center">AT_MOST</td><td style="text-align:center">10000000…00000000</td><td style="text-align:left">子元素至多达到指定大小的值</td><td style="text-align:left">wrap_content</td></tr></tbody></table></div><h5 id="2）模式提取"><a href="#2）模式提取" class="headerlink" title="2）模式提取"></a>2）模式提取</h5><p>使用 &amp; 位运算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private static final int MODE_SHIFT = 30;</div><div class="line">// 对应：11000000 00000000 00000000 00000000</div><div class="line">private static final int MODE_MASK  = 0x3 &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line">// 提取模式</div><div class="line">public static int getMode(int measureSpec) &#123;</div><div class="line">    return (measureSpec &amp; MODE_MASK);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 提取数值</div><div class="line">public static int getSize(int measureSpec) &#123;</div><div class="line">    return (measureSpec &amp; ~MODE_MASK);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h5 id="3）MeasureSpec"><a href="#3）MeasureSpec" class="headerlink" title="3）MeasureSpec"></a>3）MeasureSpec</h5><p>Android 已经为我们提供了 MeasureSpec 类来实现模式和数值的提取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MeasureSpec.getMode(int spec)  // 获取模式</div><div class="line">MeasureSpec.getSize(int spec)  // 获取数值</div></pre></td></tr></table></figure></p><p>另外，模式的取值为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MeasureSpec.UNSPECIFIED</div><div class="line">MeasureSpec.EXACTLY</div><div class="line">MeasureSpec.AT_MOST</div></pre></td></tr></table></figure></p><p>实际运用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">    super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">    int measureWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">    int measureHeight = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">    int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">    int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"></div><div class="line">    // 计算过程</div><div class="line">    ...</div><div class="line"></div><div class="line">    setMeasuredDimension(</div><div class="line">            (measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth : width,</div><div class="line">            (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight : height);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><div id="jump3"></div></p><h3 id="12-2-3-onLayout-函数"><a href="#12-2-3-onLayout-函数" class="headerlink" title="12.2.3 onLayout() 函数"></a>12.2.3 onLayout() 函数</h3><p>onLayout() 是实现所有子控件布局的函数。那关于它自己的布局怎么办呢？是在父控件中由它的父控件完成的。就这样一层一层地向上由各自的父控件完成对自己的布局，直到所有控件的顶层节点。在所有的控件的顶部有一个 ViewRoot，它才是所有控件的祖先节点。</p><p>ViewRoot 使用 setFrame(l, t, r, b) 函数中设置自己的位置，设置结束以后才会调用 onLayout(changed, l, t, r, b) 函数来设置内部所有子控件的位置。</p><p>示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-20a27ee32d8e2121.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public class MyLinLayout extends ViewGroup &#123;</div><div class="line"></div><div class="line">    public MyLinLayout(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">        int measureWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        int measureHeight = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">        int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">        int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"></div><div class="line">        int height = 0;</div><div class="line">        int width = 0;</div><div class="line">        int count = getChildCount();</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            // 测量子控件</div><div class="line">            View child = getChildAt(i);</div><div class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">            // 获得子控件的宽高</div><div class="line">            int childWidth = child.getMeasuredWidth();</div><div class="line">            int childHeight = child.getMeasuredHeight();</div><div class="line">            // 得到最大宽度，并且累加高度</div><div class="line">            height += childHeight;</div><div class="line">            width = Math.max(childWidth, width);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setMeasuredDimension(</div><div class="line">                (measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth : width,</div><div class="line">                (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight : height);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">        int top = 0;</div><div class="line">        int count = getChildCount();</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            View child = getChildAt(i);</div><div class="line">            int childWidth = child.getMeasuredWidth();</div><div class="line">            int childHeight = child.getMeasuredHeight();</div><div class="line"></div><div class="line">            child.layout(0, top, childWidth, top + childHeight);</div><div class="line">            top += childHeight;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>res/layout/act_main.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;com.xxt.xtest.MyLinLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:background=&quot;#FF00FF&quot;&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;first view&quot;</div><div class="line">        android:background=&quot;#FF0000&quot;/&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;second view&quot;</div><div class="line">        android:background=&quot;#00FF00&quot;/&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;third view&quot;</div><div class="line">        android:background=&quot;#0000FF&quot;/&gt;</div><div class="line">&lt;/com.xxt.xtest.MyLinLayout&gt;</div></pre></td></tr></table></figure></p><blockquote><p>注意：getMeasuredWidth() 与 getWidth() 获得的值大部分时候是相同的，但含义却是根本不一样的。前者是在 measure() 过程结束后就可以获取到宽度值，而后者是要在 layout() 过程结束后才能获取到宽度值；前者的值是通过 setMeasuredDimension() 函数来进行设置的，而后者的值是通过 layout(left, top, right, bottom) 函数来进行设置的。</p></blockquote><p><div id="jump4"></div></p><h3 id="12-2-4-获取子控件-margin-值的方法"><a href="#12-2-4-获取子控件-margin-值的方法" class="headerlink" title="12.2.4 获取子控件 margin 值的方法"></a>12.2.4 获取子控件 margin 值的方法</h3><h4 id="1-获取方法及示例"><a href="#1-获取方法及示例" class="headerlink" title="1. 获取方法及示例"></a>1. 获取方法及示例</h4><p>在上面 MyLinLayout 例子的基础上，添加 layout_margin 参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;com.xxt.xtest.MyLinLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;wrap_content&quot;</div><div class="line">    android:background=&quot;#FF00FF&quot;&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_marginTop=&quot;10dp&quot;</div><div class="line">        android:text=&quot;first view&quot;</div><div class="line">        android:background=&quot;#FF0000&quot;/&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_marginTop=&quot;20dp&quot;</div><div class="line">        android:text=&quot;second view&quot;</div><div class="line">        android:background=&quot;#00FF00&quot;/&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_marginTop=&quot;30dp&quot;</div><div class="line">        android:text=&quot;third view&quot;</div><div class="line">        android:background=&quot;#0000FF&quot;/&gt;</div><div class="line">&lt;/com.xxt.xtest.MyLinLayout&gt;</div></pre></td></tr></table></figure></p><p>重写 generateLayoutParams() 和 generateDefaultLayoutParams()，返回对应的 MarginLayoutParams() 函数的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected LayoutParams generateLayoutParams(LayoutParams p) &#123;</div><div class="line">    return new MarginLayoutParams(p);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public LayoutParams generateLayoutParams(AttributeSet attrs) &#123;</div><div class="line">    return new MarginLayoutParams(getContext(), attrs);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">protected LayoutParams generateDefaultLayoutParams() &#123;</div><div class="line">    return new MarginLayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>重写 onMeasure() 和 onLayout() 函数，修正获取子控件的宽高逻辑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">    View child = getChildAt(i);</div><div class="line">    // 获得子控件的宽高</div><div class="line">    MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">    int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;</div><div class="line">    int childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>最终效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4a0a7e96f37e4116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>完整代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">public class MyLinLayout extends ViewGroup &#123;</div><div class="line"></div><div class="line">    public MyLinLayout(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">        int measureWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        int measureHeight = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">        int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">        int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"></div><div class="line">        int height = 0;</div><div class="line">        int width = 0;</div><div class="line">        int count = getChildCount();</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            // 测量子控件</div><div class="line">            View child = getChildAt(i);</div><div class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">            // 获得子控件的宽高</div><div class="line">            MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">            int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;</div><div class="line">            int childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;</div><div class="line">            // 得到最大宽度，并且累加高度</div><div class="line">            height += childHeight;</div><div class="line">            width = Math.max(childWidth, width);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setMeasuredDimension((measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth : width,</div><div class="line">                (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight : height);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">        int top = 0;</div><div class="line">        int count = getChildCount();</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            View child = getChildAt(i);</div><div class="line">            // 获得子控件的宽高</div><div class="line">            MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">            int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;</div><div class="line">            int childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;</div><div class="line"></div><div class="line">            child.layout(0, top, childWidth, top + childHeight);</div><div class="line">            top += childHeight;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected LayoutParams generateLayoutParams(LayoutParams p) &#123;</div><div class="line">        return new MarginLayoutParams(p);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public LayoutParams generateLayoutParams(AttributeSet attrs) &#123;</div><div class="line">        return new MarginLayoutParams(getContext(), attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected LayoutParams generateDefaultLayoutParams() &#123;</div><div class="line">        return new MarginLayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h4><p>在 container 中初始化子控件时，会调用 LayoutParams generateLayoutParams(LayoutParams p) 函数来为子控件生成对应的布局属性，但默认只生成 layout_width 和 layout_height 所对应的布局参数，即在正常情况下调用 generateLayoutParams() 函数生成的 LayoutParams 实例是不能获取到 margin 值的。所以，如我我们还需要与 margin 相关的参数，就只能重写 generateLayoutParams() 函数，返回派生自 LayoutParams 的子类 MarginLayoutParams，根据类的多态性，可以直接将其强转成 MarginLayoutParams 实例。为了安全起见，也可以利用 instanceof 来进行判断。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2243793f708555ed.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12.1 精通自定义 View 之封装控件——自定义属性与自定义 Style</title>
      <link href="/2019/07/12/05%20CUSTOM%20VIEW/12.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%20Style/"/>
      <url>/2019/07/12/05%20CUSTOM%20VIEW/12.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%20Style/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a4ee41c12c4c9f6b.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="12-1-1-示例"><a href="#12-1-1-示例" class="headerlink" title="12.1.1 示例"></a>12.1.1 示例</h3><h4 id="1-自定义-Style-和属性"><a href="#1-自定义-Style-和属性" class="headerlink" title="1. 自定义 Style 和属性"></a>1. 自定义 Style 和属性</h4><p>1）自定义一个类 MyTextView<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class MyTextView extends AppCompatTextView &#123;</div><div class="line">    public MyTextView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public MyTextView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public MyTextView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>2）新建 res/values/attrs.xml 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">    &lt;declare-styleable name=&quot;MyTextView&quot;&gt;</div><div class="line">        &lt;attr name=&quot;header&quot; format=&quot;reference&quot;/&gt;</div><div class="line">        &lt;attr name=&quot;headerHeight&quot; format=&quot;dimension&quot;/&gt;</div><div class="line">        &lt;attr name=&quot;headerVisibleHeight&quot; format=&quot;dimension&quot;/&gt;</div><div class="line">        &lt;attr name=&quot;age&quot;&gt;</div><div class="line">            &lt;flag name=&quot;child&quot; value=&quot;10&quot;/&gt;</div><div class="line">            &lt;flag name=&quot;young&quot; value=&quot;18&quot;/&gt;</div><div class="line">            &lt;flag name=&quot;old&quot; value=&quot;60&quot;/&gt;</div><div class="line">        &lt;/attr&gt;</div><div class="line">    &lt;/declare-styleable&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure></p><ul><li>reference 指的是从 string.xml、drawable.xml、color.xml 等文件中引用过来的值。</li><li>flag 是自己定义的，类似于 android:gravity=”top”。</li><li>dimension 指的是从 dimensions.xml 文件中引用过来的值。注意，这里如果是 dp，就会进行像素转换。</li></ul><blockquote><p>注意：declare-styleable 的 name 值对应所定义的类名。自定义属性值可以组合使用。比如 &lt;attr name=”border_color” format=”color | reference”/&gt; 表示既可以自定义 color 值 (比如 #ff00ff)，也可以利用 @color/xxx 来引用 colors.xml 中已有的值。</p></blockquote><p><div id="jump2"></div></p><h3 id="12-1-2-在-XML-中使用自定义的属性"><a href="#12-1-2-在-XML-中使用自定义的属性" class="headerlink" title="12.1.2 在 XML 中使用自定义的属性"></a>12.1.2 在 XML 中使用自定义的属性</h3><p>res/layout/act_main.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:attrstest=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line">    &lt;com.xxt.xtest.MyTextView</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        attrstest:header=&quot;@drawable/head&quot;</div><div class="line">        attrstest:headerHeight=&quot;300dp&quot;</div><div class="line">        attrstest:headerVisibleHeight=&quot;100dp&quot;</div><div class="line">        attrstest:age=&quot;young&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>下面代码是导入自定义的属性集，使 XML 能识别我们自定义的属性。attrstest 是自定义的，可随意定义为 xxx，对应的访问自定义控件的方式就是 xxx:headerHeight=”300dp”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xmlns:attrstest=&quot;http://schemas.android.com/apk/res-auto&quot;</div></pre></td></tr></table></figure></p><p><div id="jump3"></div></p><h3 id="12-1-3-在代码中获取自定义属性的值"><a href="#12-1-3-在代码中获取自定义属性的值" class="headerlink" title="12.1.3 在代码中获取自定义属性的值"></a>12.1.3 在代码中获取自定义属性的值</h3><p>使用代码获取用户所定义的某个属性的值，主要使用 TypedArray 类，这个类提供了获取某个属性值的所有方法，如下所示。需要注意的是，在使用完以后必须调用 TypedArray 类的 recycle() 函数来释放资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">typedArray.getInt(int index, float defValue)</div><div class="line">typedArray.getDimension(int index, float defValue)</div><div class="line">typedArray.getBoolean(int index, float defValue)</div><div class="line">typedArray.getColor(int index, float defValue)</div><div class="line">typedArray.getString(int index)</div><div class="line">typedArray.getDrawable(int index)</div><div class="line">typedArray.getResources()</div><div class="line"></div><div class="line">typedArray.recycle()</div></pre></td></tr></table></figure></p><p>使用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class MyTextView extends AppCompatTextView &#123;</div><div class="line"></div><div class="line">    public MyTextView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MyTextView);</div><div class="line">        float headerHeight = typedArray.getDimension(R.styleable.MyTextView_headerHeight, -1);</div><div class="line">        int age = typedArray.getInt(R.styleable.MyTextView_age, -1);</div><div class="line">        Drawable drawable = typedArray.getDrawable(R.styleable.MyTextView_header);</div><div class="line">        typedArray.recycle();</div><div class="line">        String text = &quot;headerHeight:&quot; + headerHeight + &quot; age:&quot; + age;</div><div class="line">        this.setText(text);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0460193d30e7a4eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><div id="jump4"></div></p><h3 id="12-1-4-declare-styleable-标签其他属性的用法"><a href="#12-1-4-declare-styleable-标签其他属性的用法" class="headerlink" title="12.1.4 declare-styleable 标签其他属性的用法"></a>12.1.4 declare-styleable 标签其他属性的用法</h3><h4 id="1-reference：参考某一资源-ID"><a href="#1-reference：参考某一资源-ID" class="headerlink" title="1. reference：参考某一资源 ID"></a>1. reference：参考某一资源 ID</h4><p>属性定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name=&quot;名称&quot;&gt;</div><div class="line">    &lt;attr name=&quot;background&quot; format=&quot;reference&quot;/&gt;</div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure></p><p>属性使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;ImageView</div><div class="line">    android:layout_width=&quot;42dip&quot;</div><div class="line">    android:layout_height=&quot;42dip&quot;</div><div class="line">    android:background=&quot;@drawable/图片 ID&quot;/&gt;</div></pre></td></tr></table></figure></p><h4 id="2-color：颜色值"><a href="#2-color：颜色值" class="headerlink" title="2. color：颜色值"></a>2. color：颜色值</h4><p>属性定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name=&quot;名称&quot;&gt;</div><div class="line">    &lt;attr name=&quot;textColor&quot; format=&quot;color&quot;/&gt;</div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure></p><p>属性使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;TextView</div><div class="line">    android:layout_width=&quot;42dip&quot;</div><div class="line">    android:layout_height=&quot;42dip&quot;</div><div class="line">    android:textColor=&quot;#00FF00&quot;/&gt;</div></pre></td></tr></table></figure></p><h4 id="3-boolean：布尔值"><a href="#3-boolean：布尔值" class="headerlink" title="3. boolean：布尔值"></a>3. boolean：布尔值</h4><p>属性定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name=&quot;名称&quot;&gt;</div><div class="line">    &lt;attr name=&quot;focusable&quot; format=&quot;boolean&quot;/&gt;</div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure></p><p>属性使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Button</div><div class="line">    android:layout_width=&quot;42dip&quot;</div><div class="line">    android:layout_height=&quot;42dip&quot;</div><div class="line">    android:focusable=&quot;true&quot;/&gt;</div></pre></td></tr></table></figure></p><h4 id="4-dimension：尺寸值"><a href="#4-dimension：尺寸值" class="headerlink" title="4. dimension：尺寸值"></a>4. dimension：尺寸值</h4><p>属性定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name=&quot;名称&quot;&gt;</div><div class="line">    &lt;attr name=&quot;layout_width&quot; format=&quot;dimension&quot;/&gt;</div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure></p><p>属性使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Button</div><div class="line">    android:layout_width=&quot;42dip&quot;</div><div class="line">    android:layout_height=&quot;42dip&quot;/&gt;</div></pre></td></tr></table></figure></p><h4 id="5-float：浮点值"><a href="#5-float：浮点值" class="headerlink" title="5. float：浮点值"></a>5. float：浮点值</h4><p>属性定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name=&quot;AlphaAnimation&quot;&gt;</div><div class="line">    &lt;attr name=&quot;fromAlpha&quot; format=&quot;float&quot;/&gt;</div><div class="line">    &lt;attr name=&quot;toAlpha&quot; format=&quot;float&quot;/&gt;</div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure></p><p>属性使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Alpha</div><div class="line">    android:fromAlpha=&quot;1.0&quot;</div><div class="line">    android:toAlpha=&quot;0.7&quot;/&gt;</div></pre></td></tr></table></figure></p><h4 id="6-integer：整型值"><a href="#6-integer：整型值" class="headerlink" title="6. integer：整型值"></a>6. integer：整型值</h4><p>属性定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name=&quot;AnimatedRotateDrawable&quot;&gt;</div><div class="line">    &lt;attr name=&quot;visible&quot;/&gt;</div><div class="line">    &lt;attr name=&quot;frameDuration&quot; format=&quot;integer&quot;/&gt;</div><div class="line">    &lt;attr name=&quot;framesCount&quot; format=&quot;integer&quot;/&gt;</div><div class="line">    &lt;attr name=&quot;pivotX&quot;/&gt;</div><div class="line">    &lt;attr name=&quot;pivotY&quot;/&gt;</div><div class="line">    &lt;attr name=&quot;drawable&quot;/&gt;</div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure></p><p>属性使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;animated-rotate</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:drawable=&quot;@drawable/图片 ID&quot;</div><div class="line">    android:pivotX=&quot;50%&quot;</div><div class="line">    android:pivotY=&quot;50%&quot;</div><div class="line">    android:framesCount=&quot;12&quot;</div><div class="line">    android:frameDuration=&quot;100&quot;/&gt;</div></pre></td></tr></table></figure></p><h4 id="7-string：字符串"><a href="#7-string：字符串" class="headerlink" title="7. string：字符串"></a>7. string：字符串</h4><p>属性定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name=&quot;MapView&quot;&gt;</div><div class="line">    &lt;attr name=&quot;apiKey&quot; format=&quot;string&quot;/&gt;</div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure></p><p>属性使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;com.google.android.maps.MapView</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:apiKey=&quot;FJA802hFS01jhFDA9oAFAoFJAFDA9oAFAo&quot;/&gt;</div></pre></td></tr></table></figure></p><h4 id="8-fraction：百分数"><a href="#8-fraction：百分数" class="headerlink" title="8. fraction：百分数"></a>8. fraction：百分数</h4><p>属性定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name=&quot;RotateDrawable&quot;&gt;</div><div class="line">    &lt;attr name=&quot;visible&quot;/&gt;</div><div class="line">    &lt;attr name=&quot;fromDegrees&quot; format=&quot;float&quot;/&gt;</div><div class="line">    &lt;attr name=&quot;toDegrees&quot; format=&quot;float&quot;/&gt;</div><div class="line">    &lt;attr name=&quot;pivotX&quot; format=&quot;fraction&quot;/&gt;</div><div class="line">    &lt;attr name=&quot;pivotY&quot; format=&quot;fraction&quot;/&gt;</div><div class="line">    &lt;attr name=&quot;drawable&quot;/&gt;</div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure></p><p>属性使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;rotate</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:interpolator=&quot;@anim/动画 ID&quot;</div><div class="line">    android:fromDegrees=&quot;0&quot;</div><div class="line">    android:toDegrees=&quot;360&quot;</div><div class="line">    android:pivotX=&quot;200%&quot;</div><div class="line">    android:pivotY=&quot;300%&quot;</div><div class="line">    android:duration=&quot;5000&quot;</div><div class="line">    android:repeatMode=&quot;restart&quot;</div><div class="line">    android:repeatCount=&quot;infinite&quot;/&gt;</div></pre></td></tr></table></figure></p><h4 id="9-enum：枚举值"><a href="#9-enum：枚举值" class="headerlink" title="9. enum：枚举值"></a>9. enum：枚举值</h4><p>属性定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name=&quot;名称&quot;&gt;</div><div class="line">    &lt;attr name=&quot;orientation&quot;&gt;</div><div class="line">        &lt;enum name=&quot;horizontal&quot; value=&quot;0&quot;/&gt;</div><div class="line">        &lt;enum name=&quot;vertical&quot; value=&quot;1&quot;/&gt;</div><div class="line">    &lt;/attr&gt;</div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure></p><p>属性使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><h4 id="10-flag：位或运算"><a href="#10-flag：位或运算" class="headerlink" title="10. flag：位或运算"></a>10. flag：位或运算</h4><p>属性定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name=&quot;名称&quot;&gt;</div><div class="line">    &lt;attr name=&quot;windowSoftInputMode&quot;&gt;</div><div class="line">        &lt;flag name=&quot;stateUnspecified&quot; value=&quot;0&quot;/&gt;</div><div class="line">        &lt;flag name=&quot;stateUnchanged&quot; value=&quot;1&quot;/&gt;</div><div class="line">        &lt;flag name=&quot;stateHidden&quot; value=&quot;2&quot;/&gt;</div><div class="line">        &lt;flag name=&quot;stateAlwaysHidden&quot; value=&quot;3&quot;/&gt;</div><div class="line">        &lt;flag name=&quot;stateVisible&quot; value=&quot;4&quot;/&gt;</div><div class="line">        &lt;flag name=&quot;stateAlwaysVisible&quot; value=&quot;5&quot;/&gt;</div><div class="line">        &lt;flag name=&quot;adjustUnspecified&quot; value=&quot;0x00&quot;/&gt;</div><div class="line">        &lt;flag name=&quot;adjustResize&quot; value=&quot;0x10&quot;/&gt;</div><div class="line">        &lt;flag name=&quot;adjustPan&quot; value=&quot;0x20&quot;/&gt;</div><div class="line">        &lt;flag name=&quot;adjustNothing&quot; value=&quot;0x30&quot;/&gt;</div><div class="line">    &lt;/attr&gt;</div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure></p><p>属性使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;Activity</div><div class="line">    android:name=&quot;.StyleAndThemeActivity&quot;</div><div class="line">    android:label=&quot;@string/app_name&quot;</div><div class="line">    android:windowSoftInputMode=&quot;stateUnspecified | stateUnchanged | stateHidden&quot;&gt;</div><div class="line">    &lt;intent-filter&gt;</div><div class="line">        &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;</div><div class="line">        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;</div><div class="line">    &lt;/intent-filter&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><blockquote><p>特别注意：属性在定义时可以指定多种类型的值。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name=&quot;名称&quot;&gt;</div><div class="line">    &lt;attr name=&quot;background&quot; format=&quot;reference|color&quot;/&gt;</div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ac03f85b4cdb8dbd.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.2 精通自定义 View 之 Matrix 与坐标变换——ColorMatrix 色彩变换</title>
      <link href="/2019/07/11/05%20CUSTOM%20VIEW/11.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94ColorMatrix%20%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2/"/>
      <url>/2019/07/11/05%20CUSTOM%20VIEW/11.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94ColorMatrix%20%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-8421b40cde3f0a33.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="11-2-1-色彩变换矩阵"><a href="#11-2-1-色彩变换矩阵" class="headerlink" title="11.2.1 色彩变换矩阵"></a>11.2.1 色彩变换矩阵</h3><p>对于色彩的存储，Bitmap 类使用一个 32 位的数值来保存，红、绿、蓝及透明度各占 8 位，每个色彩分量的取值范围是 0~255。透明度为 0 表示完全透明，为 255 时色彩完全可见。</p><h4 id="1-色彩信息的矩阵表示"><a href="#1-色彩信息的矩阵表示" class="headerlink" title="1. 色彩信息的矩阵表示"></a>1. 色彩信息的矩阵表示</h4><p>由于一个色彩信息包含 R、G、B、Alpha 信息,所以,我们必然要使用一个四阶色彩变 换矩阵来修改色彩的每一个分量值。</p><script type="math/tex; mode=display">\left[ \begin{matrix} Red & 0 & 0 & 0 \\ 0 & Green & 0 & 0 \\ 0 & 0 & Blue & 0 \\ 0 & 0 & 0 & Alpha \end{matrix} \right]</script><blockquote><p>注意:对于色彩变换矩阵，这里的色彩顺序是 R、G、B、A，而不是 A、R、G、B。</p></blockquote><p>如果想将色彩 (0,255,0,255) 更改为半透明，则可以使用下面的矩阵运算来表示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-65968173a9ff1c69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上面使用四阶矩阵完全可以改变图片的 RGBA 值，但考虑一种情况：如果我们只想在原有的 R 色上增加一些分量呢?</p><p>这时，我们就得再多加一阶来表示平移变换。所，一个既包含线性变换又包含平移变换的组合变换称为仿射变换。使用四阶色彩变换矩阵来修改色彩，只能对色彩的每个分量值进行乘(除)运算。如果要对这些分量值进行加减法运算(平移变换)，则只能通过五阶矩阵来完成。</p><p>考虑下面这个变换：<br>1）红色分量值更改为原来的 2 倍。<br>2）绿色分量值增加 100。</p><p>这个变换使用四阶矩阵的乘法无法实现。所以，应该在四阶色彩变换矩阵上增加一个“哑元坐标”，来实现所列的矩阵运算。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-53ad1961066a0714.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在这个矩阵中，分量值用的是 100。</p><h4 id="2-Android-中的色彩变换矩阵"><a href="#2-Android-中的色彩变换矩阵" class="headerlink" title="2. Android 中的色彩变换矩阵"></a>2. Android 中的色彩变换矩阵</h4><p>在 Android 中，色彩变换矩阵的表示形式也是五阶的。所以，在默认情况下，色彩变换矩阵的形式如下:</p><script type="math/tex; mode=display">\left[ \begin{matrix} 1 & 0 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 & 0\end{matrix} \right]</script><p>Android 中的色彩变换矩阵是用 ColorMatrix 类来表示的。使用 ColorMatrix 类的方法如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123;</div><div class="line">       1, 0, 0, 0, 0,</div><div class="line">       0, 1, 0, 0, 0,</div><div class="line">       0, 0, 1, 0, 0,</div><div class="line">       0, 0, 0, 0.5, 0,</div><div class="line">&#125;);</div><div class="line">mPaint.setColorFilter(new ColorMatrixColorFilter(colorMatrix));</div></pre></td></tr></table></figure></p><p>有关 setColorFilter() 函数的其他用法，将在本节末尾详细讲解。</p><h4 id="3-示例：彩色图片的蓝色通道输出"><a href="#3-示例：彩色图片的蓝色通道输出" class="headerlink" title="3. 示例：彩色图片的蓝色通道输出"></a>3. 示例：彩色图片的蓝色通道输出</h4><p>下面以为 Bitmap 应用 ColorMatrix 类为例,代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line">    private Paint mPaint = new Paint();</div><div class="line">    private Bitmap bitmap;  // 位图</div><div class="line">    private Rect rect;</div><div class="line">    private ColorMatrixColorFilter colorMatrixColorFilter;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint.setAntiAlias(true);</div><div class="line">        // 获取位图</div><div class="line">        bitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.dog);</div><div class="line">        rect = new Rect();</div><div class="line">        // 生成色彩变换矩阵</div><div class="line">        ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123;</div><div class="line">                0, 0, 0, 0, 0,</div><div class="line">                0, 0, 0, 0, 0,</div><div class="line">                0, 0, 1, 0, 0,</div><div class="line">                0, 0, 0, 1, 0,</div><div class="line">        &#125;);</div><div class="line">        colorMatrixColorFilter = new ColorMatrixColorFilter(colorMatrix);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        rect.set(0, 0, 500, 500 * bitmap.getHeight() / bitmap.getWidth());</div><div class="line">        // 绘制原始位图</div><div class="line">        canvas.drawBitmap(bitmap, null, rect, mPaint);</div><div class="line">        canvas.translate(510, 0);</div><div class="line"></div><div class="line">        mPaint.setColorFilter(colorMatrixColorFilter);</div><div class="line">        canvas.drawBitmap(bitmap, null, rect, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里分两次绘制了一个 Bitmap，先绘制了一个原始图像,然后利用 ColorMatrix 类生成了 一个仅包含蓝色的图像。用过 Photoshop 的读者应该很清楚,这跟 Photoshop 中蓝色通道的效 果是一致的。效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-40bfc3d34d47dc8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><div id="jump2"></div></p><h3 id="11-2-2-色彩的几种运算方式"><a href="#11-2-2-色彩的几种运算方式" class="headerlink" title="11.2.2 色彩的几种运算方式"></a>11.2.2 色彩的几种运算方式</h3><h4 id="1-色彩的平移运算"><a href="#1-色彩的平移运算" class="headerlink" title="1. 色彩的平移运算"></a>1. 色彩的平移运算</h4><p>1）增加色彩饱和度<br>色彩的平移运算实际上就是色彩的加法运算，其实就是在色彩变换矩阵的最后一列加上某个值，这样可以增加特定色彩的饱和度。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-32174d42e4b29379.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>比如，同样是上面的图片，我们给它应用下面的色彩值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123;</div><div class="line">       1, 0, 0, 0, 0,</div><div class="line">       0, 1, 0, 0, 50,</div><div class="line">       0, 0, 1, 0, 0,</div><div class="line">       0, 0, 0, 1, 0,</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>在绿色值上添加增量 50，即增大绿色的饱和度。效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0be65968c5d44c47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>同样，左侧是原图，右侧是增大绿色饱和度后的效果。大家要特别注意的是，由于图片是由一个个像素组成的，所以用每个像素所对应的色彩数组来乘以色彩变换矩阵，结果就是变换后的当前点的颜色值。在应用 ColorMatrix 类后，图片中每个像素的绿色值都增加了 50, 从小狗的脸上也可以看出来。</p><p>2）色彩反转/反相功能<br>色彩平移除增加指定色彩的饱和度以外，另一个应用就是色彩反转，也就是 Photoshop 中的反相功能。色彩反转就是求出每个色彩的补值来作为目标图像的对应颜色值。示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123;</div><div class="line">        -1, 0, 0, 0, 255,</div><div class="line">        0, -1, 0, 0, 255,</div><div class="line">        0, 0, -1, 0, 255,</div><div class="line">        0, 0, 0, 1, 0,</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-45b981d952839f0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="2-色彩的缩放运算"><a href="#2-色彩的缩放运算" class="headerlink" title="2. 色彩的缩放运算"></a>2. 色彩的缩放运算</h4><p>1）调节亮度<br>色彩的缩放运算其实就是色彩的乘法运算。将色彩变换矩阵对角线上分别代表 R、G、B、 A 的几个值分别乘以指定的值，就是所谓的缩放运算，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-bd12812a0945e1a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>我们可以针对某个颜色值进行放大/缩小运算。但是当对 R、G、B、A 同时进行放大/缩小运算时，就是对亮度进行调节。</p><p>看下面将亮度增大 1.2 倍的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123;</div><div class="line">        1.2f, 0, 0, 0, 0,</div><div class="line">        0, 1.2f, 0, 0, 0,</div><div class="line">        0, 0, 1.2f, 0, 0,</div><div class="line">        0, 0, 0, 1, 0,</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-89be53a5c44e1d14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>2）通道输出<br>由于在色彩变换矩阵中对角线上的数的取值范围为 0~1，所以，当取 0 时，这个色彩就完全不显示；当 R、G 都取 0，而独有 B 取 1 时,就只显示蓝色，所形成的图像也就是我们通常所说的蓝色通道。看一下几个通道输出的效果图，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b3ba32645756773a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 红色通道矩阵</div><div class="line">ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123;</div><div class="line">        1, 0, 0, 0, 0,</div><div class="line">        0, 0, 0, 0, 0,</div><div class="line">        0, 0, 0, 0, 0,</div><div class="line">        0, 0, 0, 1, 0,</div><div class="line">&#125;);</div><div class="line">// 绿色通道矩阵</div><div class="line">ColorMatrix colorMatrix2 = new ColorMatrix(new float[]&#123;</div><div class="line">        0, 0, 0, 0, 0,</div><div class="line">        0, 1, 0, 0, 0,</div><div class="line">        0, 0, 0, 0, 0,</div><div class="line">        0, 0, 0, 1, 0,</div><div class="line">&#125;);</div><div class="line">// 蓝色通道矩阵</div><div class="line">ColorMatrix colorMatrix3 = new ColorMatrix(new float[]&#123;</div><div class="line">        0, 0, 0, 0, 0,</div><div class="line">        0, 0, 0, 0, 0,</div><div class="line">        0, 0, 1, 0, 0,</div><div class="line">        0, 0, 0, 1, 0,</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h4 id="3-色彩的旋转运算"><a href="#3-色彩的旋转运算" class="headerlink" title="3. 色彩的旋转运算"></a>3. 色彩的旋转运算</h4><p>RGB 色是如何旋转的呢？首先用 R、G、B 三色建立立体坐标系，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-48b458e1e54db702.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>所以，我们可以把一个色彩值看成三维空间里的一个点，色彩值的三个分量可以看成该点的坐标(三维坐标)。我们先不考虑在三个维度综合情况下是怎么旋转的，来看看将某个轴作为 Z 轴，在另外两个轴形成的平面上旋转的情况。下图分析了将蓝色轴作为 Z 轴，仅在红 — 绿平面上旋转 a 度的情况。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d71bec3124ade35c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到，在旋转后，原 R 在 R 轴上的分量变为原 Rxcosa，原 G 在 R 轴上也有了分量，但分量落在了负轴上，所以要减去这部分分量，最终的结果是最终的 R=原 R×cosa-原 G×sina。 下面来看一下几种旋转计算及结果矩阵(注意：这几张图只标记了原 X 轴色彩分量的旋转，没有把 Y 轴色彩分量的旋转标记出来)。</p><p>1）绕蓝色轴旋转 θ 度</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-16150536456eb83f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对应的色彩变换矩阵如下：</p><script type="math/tex; mode=display">\left[ \begin{matrix} cosθ & sinθ & 0 & 0 & 0\\ -sinθ & cosθ & 0 & 0 & 0\\ 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 & 1\end{matrix} \right]</script><p>2）绕红色轴旋转 θ 度</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ff2dadf5ca618b87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对应的色彩变换矩阵如下：</p><script type="math/tex; mode=display">\left[ \begin{matrix} 1 & 0 & 0 & 0 & 0\\ 0 & cosθ & sinθ & 0 & 0\\ 0 & -sinθ & cosθ & 0 & 0 \\ 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 & 1\end{matrix} \right]</script><p>3）绕绿色轴旋转 θ 度</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7dc283195247047d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对应的色彩变换矩阵如下：</p><script type="math/tex; mode=display">\left[ \begin{matrix} cosθ & 0 & -sinθ & 0 & 0 \\ 0 & 1 & 0 & 0 & 0\\ sinθ & 0 & cosθ & 0 & 0 \\ 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 & 1\end{matrix} \right]</script><p>当围绕红色轴进行色彩旋转时，由于当前红色轴的色彩是不变的,而仅利用三角函数来动态变更绿色和蓝色的颜色值，这种改变就叫作色相调节。当围绕红色轴旋转时，是对图片进行红色色相的调节；当围绕蓝色轴旋转时，是对图片进行蓝色色相的调节；当围绕绿色轴旋转时，是对图片进行绿色色相的调节。</p><p>下面我们会再次讲到 ColorMatrix 的色彩旋转函数，这里先理解原理，代码和效果后面会给出。</p><h4 id="4-色彩的投射运算"><a href="#4-色彩的投射运算" class="headerlink" title="4. 色彩的投射运算"></a>4. 色彩的投射运算</h4><p>我们再回过头来看看色彩变换矩阵运算的公式，如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-06dc50244970cb7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在上式中，把红色运算单独标记出来。在运算中，它们就是利用 G、B、A 的颜色值的分量来增加红色值的。</p><p>来看具体的运算：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-9c329370c6741f14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>注意：最终结果的 220=0.2×100+1×200，可见绿色分量在原有绿色分量的基础上增加了红色分量值的 0.2 倍。利用其他色彩分量的倍数来更改自己色彩分量的值，这种运算就叫作投射运算。</p></blockquote><p>在对下图中阴影部分的值进行修改时，所使用的增加值来自其他色彩分量的信息。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2ab0e18e38b1a69d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>应用一：黑白图片</strong><br>色彩投射的一个最简单的应用就是将彩色图片变为黑白图片。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123;</div><div class="line">        0.213f, 0.715f, 0.072f, 0, 0,</div><div class="line">        0.213f, 0.715f, 0.072f, 0, 0,</div><div class="line">        0.213f, 0.715f, 0.072f, 0, 0,</div><div class="line">        0, 0, 0, 1, 0,</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4432b05b5b2d8427.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>首先了解一下去色原理：只要把 R、G、B 三通道的色彩信息设置成一样，即 R=G=B，图像就变成了灰色。并且，为了保证图像亮度不变，同一个通道中的 R+G+B=1，如 0.213+0.715+0.072=1。</p><p>下面谈一下 0.213、0.715、0.072 这三个数字的由来。</p><p>按理说应该把 R、G、B 平分，都是 0.3333333。三个数字应该是根据色彩光波频率及色彩心理学计算出来的。</p><p>在作用于人眼的光线中，彩色光要明显强于无色光。如果对一张图像按 RGB 平分理论给图像去色，人眼就会明显感觉到图像变暗了(当然可能有心理上的原因，也有光波的科学依据)。另外，在彩色图像中能够识别的一些细节也可能会丢失。</p><p>所以 Google 最终给出的颜色值就是上面的三个数字：0.213、0.715、0.072。我们在给图像去色时保留了大量的 G 通道信息，使得图像不至于变暗或者绿色信息不至于丢失。</p><p><strong>应用二：色彩反色</strong><br>利用色彩变换矩阵将两个颜色反转，这种操作就叫作色彩反色。比如，将红色和绿色反色(红绿反色)，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123;</div><div class="line">        0, 1, 0, 0, 0,</div><div class="line">        1, 0, 0, 0, 0,</div><div class="line">        0, 0, 1, 0, 0,</div><div class="line">        0, 0, 0, 1, 0,</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-56ec63b6df2ee7eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>左侧为原图，右侧为红绿反色以后的效果图。</p><p>从色彩变换矩阵中可以看出，红绿反色的关键在于，第一行用绿色来代替红色，第二行用红色来代替绿色。类似的可以有红蓝反色、绿蓝反色等，对应矩阵难度不大，就不再细讲了。</p><p><strong>应用三：照片变旧</strong><br>投射运算的另一个应用是照片变旧，其对应的矩阵如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123;</div><div class="line">        1/2f, 1/2f, 1/2f, 0, 0,</div><div class="line">        1/3f, 1/3f, 1/3f, 0, 0,</div><div class="line">        1/4f, 1/4f, 1/4f, 0, 0,</div><div class="line">        0, 0, 0, 1, 0,</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-554ef9bc51e003f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><div id="jump3"></div></p><h3 id="11-2-3-ColorMatrix-函数"><a href="#11-2-3-ColorMatrix-函数" class="headerlink" title="11.2.3 ColorMatrix 函数"></a>11.2.3 ColorMatrix 函数</h3><p>上一小节讲述了利用色彩变换矩阵来进行的一些运算，但这些都是需要特定的色彩设计基础的。在 Android 中，ColorMatrix 自带一些函数，用来帮助我们完成调整饱和度、色彩旋转等操作。</p><h4 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1. 构造函数"></a>1. 构造函数</h4><p>ColorMatrix 共有三个构造函数，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ColorMatrix()</div><div class="line">ColorMatrix(float[] src)</div><div class="line">ColorMatrix(ColorMatrix src)</div></pre></td></tr></table></figure></p><p>在这三个构造函数中，我们已经使用过第二个构造函数；至于第三个构造函数，就是利用另一个 ColorMatrix 实例来复制一个一样的 ColorMatrix 对象。</p><h4 id="2-设置和重置函数"><a href="#2-设置和重置函数" class="headerlink" title="2. 设置和重置函数"></a>2. 设置和重置函数</h4><p>第一个构造函数 ColorMatrix() 需要与其他函数共用才行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void set(ColorMatrix src)</div><div class="line">public void set(float[] src)</div><div class="line">public void reset()</div></pre></td></tr></table></figure></p><p>上面的函数是设置和重置函数，重置后，对应的数组如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Set this colormatrix to identity: </div><div class="line"> * [ 1 0 0 0 0   -redvector</div><div class="line"> *   0 1 0 0 0   -greenvector</div><div class="line"> *   0 0 1 0 0   -bluevector</div><div class="line"> *   0 0 0 1 0 ] -alphavector</div><div class="line"> */</div></pre></td></tr></table></figure></p><h4 id="3-setSaturation-函数——设置饱和度"><a href="#3-setSaturation-函数——设置饱和度" class="headerlink" title="3. setSaturation() 函数——设置饱和度"></a>3. setSaturation() 函数——设置饱和度</h4><p>我们可以通过色彩的平移运算单独增强 R、G、B 其中一个分量的饱和度，但当我们需要整体增强色彩饱和度时，需要如何来做呢？ ColorMatrix 提供了一个函数来整体增强色彩饱和度，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 整体增强色彩饱和度，即同时增强 R、G、B 的色彩饱和度 </div><div class="line">public void setSaturation(float sat)</div></pre></td></tr></table></figure></p><p>其中，参数 float sat 表示把当前色彩饱和度放大的倍数。当取值为 0 时，表示完全无色彩，即灰度图像(黑白图像)；当取值为 1 时，表示色彩不变动；;当取值大于 1 时，显示色彩过度饱和。</p><p>举个例子：滑块默认在 1 倍的位置，向左到底是 0，向右到底是 20(饱和度放大 20 倍)。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c05e54e35dba0905.gif?imageMogr2/auto-orient/strip" alt=""></p><p>布局非常简单，下面是一张图片，上面是一个 SeekBar，核心处理代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private SeekBar mSeekBar;</div><div class="line">    private ImageView mImageView;</div><div class="line">    private Bitmap mOriginBmp, mTempBmp;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        mImageView = findViewById(R.id.img);</div><div class="line">        mSeekBar = findViewById(R.id.seek_bar);</div><div class="line">        mOriginBmp = BitmapFactory.decodeResource(getResources(), R.drawable.meinv);</div><div class="line">        mTempBmp = Bitmap.createBitmap(mOriginBmp.getWidth(), mOriginBmp.getHeight(), Bitmap.Config.ARGB_8888);</div><div class="line">        mSeekBar.setMax(20);</div><div class="line">        mSeekBar.setProgress(1);</div><div class="line">        mSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123;</div><div class="line">                Bitmap bitmap = handleColorMatrixBmp(progress);</div><div class="line">                mImageView.setImageBitmap(bitmap);</div><div class="line">            &#125;</div><div class="line">            @Override</div><div class="line">            public void onStartTrackingTouch(SeekBar seekBar) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onStopTrackingTouch(SeekBar seekBar) &#123;&#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Bitmap handleColorMatrixBmp(int progress)&#123;</div><div class="line">        // 创建一个相同尺寸的可变的位图区，用于绘制调色后的图片</div><div class="line">        Canvas canvas = new Canvas(mTempBmp);</div><div class="line">        // 得到画笔对象</div><div class="line">        Paint paint = new Paint();</div><div class="line">        ColorMatrix mSaturationMatrix = new ColorMatrix();</div><div class="line">        mSaturationMatrix.setSaturation(progress);</div><div class="line">        // 设置色彩变换效果</div><div class="line">        paint.setColorFilter(new ColorMatrixColorFilter(mSaturationMatrix));</div><div class="line">        // 将色彩变换后的图片输出到新创建的位图区</div><div class="line">        canvas.drawBitmap(mOriginBmp, 0, 0, paint);</div><div class="line">        // 返回新的位图,即调色处理后的图片</div><div class="line">        return mTempBmp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>布局：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;</div><div class="line">    android:background=&quot;#EEE&quot;&gt;</div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;40dp&quot;</div><div class="line">        android:gravity=&quot;center_vertical&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;&gt;</div><div class="line">        &lt;TextView</div><div class="line">            android:layout_width=&quot;wrap_content&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:text=&quot;饱和度&quot;/&gt;</div><div class="line">        &lt;SeekBar</div><div class="line">            android:id=&quot;@+id/seek_bar&quot;</div><div class="line">            android:layout_width=&quot;match_parent&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot; /&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/img&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:src=&quot;@drawable/meinv&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><h4 id="4-setScale-函数——色彩缩放"><a href="#4-setScale-函数——色彩缩放" class="headerlink" title="4. setScale() 函数——色彩缩放"></a>4. setScale() 函数——色彩缩放</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void setScale(float rScale, float gScale, float bScale,float aScale)</div></pre></td></tr></table></figure><p>这个函数共有 4 个参数，分别对应 R、G、B、A 颜色值的缩放倍数。比如，在小狗图片中,绿色占大部分，所以我们仅将绿色放大 1.3 倍。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-94625175286b6f21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line">    private Paint mPaint = new Paint();</div><div class="line">    private Bitmap bitmap;  // 位图</div><div class="line">    private Rect rect;</div><div class="line">    private ColorMatrixColorFilter colorMatrixColorFilter;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint.setAntiAlias(true);</div><div class="line">        // 获取位图</div><div class="line">        bitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.dog);</div><div class="line">        rect = new Rect();</div><div class="line">        // 生成色彩变换矩阵</div><div class="line">        ColorMatrix colorMatrix = new ColorMatrix();</div><div class="line">        colorMatrix.setScale(1,1.3f,1,1);</div><div class="line">        colorMatrixColorFilter = new ColorMatrixColorFilter(colorMatrix);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        rect.set(0, 0, 500, 500 * bitmap.getHeight() / bitmap.getWidth());</div><div class="line">        // 绘制原始位图</div><div class="line">        canvas.drawBitmap(bitmap, null, rect, mPaint);</div><div class="line">        canvas.translate(510, 0);</div><div class="line">        mPaint.setColorFilter(colorMatrixColorFilter);</div><div class="line">        canvas.drawBitmap(bitmap, null, rect, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="5-setRotate-函数——色彩旋转"><a href="#5-setRotate-函数——色彩旋转" class="headerlink" title="5. setRotate() 函数——色彩旋转"></a>5. setRotate() 函数——色彩旋转</h4><p>上面在讲解色彩旋转运算时，列出了在色彩旋转时的效果和原理。由于涉及正、余弦函数的计算，而且这些公式推导起来具有一定的难度，所以 Android 已经封装好了色彩旋转的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 将旋转围绕某一个颜色轴进行</div><div class="line"> * axis=0 围绕红色轴旋转</div><div class="line"> * axis=1 围绕绿色轴旋转</div><div class="line"> * axis=2 围绕蓝色轴旋转</div><div class="line"> */</div><div class="line">public void setRotate(int axis, float degrees);</div></pre></td></tr></table></figure></p><ul><li>int axis：表示围绕哪个轴旋转，取值为0、1、2。当取值为 0 时，表示围绕红色轴旋转；当取值为 1 时，表示围绕绿色轴旋转；当取值为 2 时，表示围绕蓝色轴旋转。</li><li>float degrees：表示旋转的度数。</li></ul><p>同样利用上面色彩旋转的图像和滑动条的框架，来看一下当围绕某一个颜色轴旋转时色相变化的效果。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-8c23292396f0f991.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private SeekBar mSeekBar;</div><div class="line">    private ImageView mImageView;</div><div class="line">    private Bitmap mOriginBmp, mTempBmp;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        mImageView = findViewById(R.id.img);</div><div class="line">        mSeekBar = findViewById(R.id.seek_bar);</div><div class="line">        mOriginBmp = BitmapFactory.decodeResource(getResources(), R.drawable.meinv);</div><div class="line">        mTempBmp = Bitmap.createBitmap(mOriginBmp.getWidth(), mOriginBmp.getHeight(), Bitmap.Config.ARGB_8888);</div><div class="line">        mSeekBar.setMax(360);</div><div class="line">        mSeekBar.setProgress(180);</div><div class="line">        mSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123;</div><div class="line">                Bitmap bitmap = handleColorMatrixBmp(progress);</div><div class="line">                mImageView.setImageBitmap(bitmap);</div><div class="line">            &#125;</div><div class="line">            @Override</div><div class="line">            public void onStartTrackingTouch(SeekBar seekBar) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onStopTrackingTouch(SeekBar seekBar) &#123;&#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Bitmap handleColorMatrixBmp(int progress) &#123;</div><div class="line">        Canvas canvas = new Canvas(mTempBmp);</div><div class="line">        Paint paint = new Paint();</div><div class="line">        ColorMatrix colorMatrix = new ColorMatrix();</div><div class="line">        colorMatrix.setRotate(0,progress - 180);</div><div class="line">        paint.setColorFilter(new ColorMatrixColorFilter(colorMatrix));</div><div class="line">        canvas.drawBitmap(mOriginBmp, 0, 0, paint);</div><div class="line">        return mTempBmp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>将当前 progress 位置减去 180，即中间位置的数字。所以，中间位置的色彩旋转度数为 0，整个旋转度数的范围是 -180°~180°；360° 正好是正/余弦函数的一个最小正周期。</p><p>上面的效果针对的是红色色相。同理，可以得到围绕绿色轴旋转的效果图。</p><p><div id="jump4"></div></p><h3 id="11-2-4-ColorMatrix-相乘"><a href="#11-2-4-ColorMatrix-相乘" class="headerlink" title="11.2.4 ColorMatrix 相乘"></a>11.2.4 ColorMatrix 相乘</h3><p>矩阵相乘涉及三个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void setConcat(ColorMatrix matA, ColorMatrix matB)</div></pre></td></tr></table></figure></p><p>这个函数接收两个 ColorMatrix 矩阵 matA 和 matB，乘法规则为 matA×matB，然后将结果作为当前 ColorMatrix 的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void preConcat(ColorMatrix preMatrix)</div></pre></td></tr></table></figure></p><p>假设当前矩阵为 A，那么 preConcat() 函数的含义就是将当前的矩阵 A 乘以 preMatrix。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void postConcat(ColorMatrix postMatrix)</div></pre></td></tr></table></figure></p><p>postConcat() 函数的含义就是 postMatrix 乘以当前矩阵 A。</p><p>由于这部分内容基本用不到，有关这几个函数的具体应用这里就不再详细讲述，有兴趣的读者可以参考 <a href="http://blog.csdn.net/harvic880925/article/details/51187277" target="_blank" rel="external">Paint 之 ColorMatrix 与滤镜效果</a>。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2fe244460ff92503.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.1 精通自定义 View 之 Matrix 与坐标变换——矩阵运算</title>
      <link href="/2019/07/11/05%20CUSTOM%20VIEW/11.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/"/>
      <url>/2019/07/11/05%20CUSTOM%20VIEW/11.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a817395b74e8347a.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="11-1-1-矩阵的加法和减法"><a href="#11-1-1-矩阵的加法和减法" class="headerlink" title="11.1.1 矩阵的加法和减法"></a>11.1.1 矩阵的加法和减法</h3><h4 id="1-运算规则"><a href="#1-运算规则" class="headerlink" title="1. 运算规则"></a>1. 运算规则</h4><script type="math/tex; mode=display">设矩阵 A=\left[ \begin{matrix} a~11~ & a~12~ & \cdots & a~1n~ \\ a~21~ & a~22~ & \cdots & a~2n~ \\ \vdots & \vdots & & \vdots \\ a~n1~ & a~n2~ & \cdots & a~nn~ \end{matrix} \right]</script><script type="math/tex; mode=display">设矩阵 B=\left[ \begin{matrix} b~11~ & b~12~ & \cdots & b~1n~ \\ b~21~ & b~22~ & \cdots & b~2n~ \\ \vdots & \vdots & & \vdots \\ b~n1~ & b~n2~ & \cdots & b~nn~ \end{matrix} \right]</script><script type="math/tex; mode=display">则 A±B=\left[ \begin{matrix} a~11~ ± b~11~ & a~12~ ± b~12~ & \cdots & a~1n ± ~b~1n~ \\ a~21~ ± b~21~ & a~22~ ± b~22~ & \cdots & a~2n ± ~b~2n~ \\ \vdots & \vdots & & \vdots \\ a~n1~ ± b~n1~ & a~n2~ ± b~n2~ & \cdots & a~nn ± ~b~nn~ \end{matrix} \right]</script><p>简而言之，两个矩阵相加减，即它们相同位置的元素相加减。</p><blockquote><p>注意：只有对于两个行数、列数分别相等的矩阵(同型矩阵)，加减法运算才有意义,即 加减法运算是可行的。</p></blockquote><h4 id="2-运算性质"><a href="#2-运算性质" class="headerlink" title="2. 运算性质"></a>2. 运算性质</h4><p>满足交换律和结合律。<br>交换律：A+B=B+A。<br>结合律：(A+B)+C= A+(B+C)。</p><p><div id="jump2"></div></p><h3 id="11-1-2-矩阵与数的乘法"><a href="#11-1-2-矩阵与数的乘法" class="headerlink" title="11.1.2 矩阵与数的乘法"></a>11.1.2 矩阵与数的乘法</h3><h4 id="1-运算规则-1"><a href="#1-运算规则-1" class="headerlink" title="1. 运算规则"></a>1. 运算规则</h4><p>数 λ 乘以矩阵 A，就是将数 λ 乘以矩阵 A 中的每一个元素，记为 λA 或 Aλ。<br>特别地，称-A 为 A=(a~ij~)~m×s~ 的负矩阵。</p><h4 id="2-运算性质-1"><a href="#2-运算性质-1" class="headerlink" title="2. 运算性质"></a>2. 运算性质</h4><p>满足结合律和分配律。<br>结合律：(λμ)A=λ(μA)；(λ+μ)A =λA+μA。<br>分配律：λ (A+B)=λA+λB。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-72a55598f7926e58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><div id="jump3"></div></p><h3 id="11-1-3-矩阵与矩阵的乘法"><a href="#11-1-3-矩阵与矩阵的乘法" class="headerlink" title="11.1.3 矩阵与矩阵的乘法"></a>11.1.3 矩阵与矩阵的乘法</h3><h4 id="1-运算规则-2"><a href="#1-运算规则-2" class="headerlink" title="1. 运算规则"></a>1. 运算规则</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-9a3e7c8dee62bf16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>矩阵乘法其实并不难，它的意思就是将第一个矩阵 A 的第一行与第二个矩阵 B 的第一列的数字分别相乘，得到的结果相加，最终的值作为结果矩阵的第(1,1)位置的值(第一行第一列)。</p><p>同样，A 矩阵的第一行与 B 矩阵的第二列的数字分别相乘，然后相加，最终的值作为结果矩阵第(1,2)位置的值(第一行第二列)。</p><p>再如，A 矩阵的第二行与 B 矩阵的第一列的数字分别相乘，然后相加，最终的值作为结果矩阵的第(2,1)位置的值(第二行第一列)。</p><p>这里主要说明两个问题：</p><ul><li>A 矩阵的列数必须与 B 矩阵的行数相同，才能相乘。因为我们需要把 A 矩阵一行中的各个数字与 B 矩阵一列中的各个数字分别相乘，所以 A 矩阵的列数与 B 矩阵的行数必须相同。</li><li>矩阵 A 乘以矩阵 B 和矩阵 B 乘以矩阵 A 的结果必然是不一样的。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/14186083-01b6708b87550939.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="2-运算性质-2"><a href="#2-运算性质-2" class="headerlink" title="2. 运算性质"></a>2. 运算性质</h4><p>1）结合律：(AB)C=A(BC)。<br>2）分配律：A(B±C)=AB±AC(左分配律)；(B±C)A=BA±CA(右分配律)。<br>3）(λA)B=λ(AB)=A(λB)。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-6c0e6164e554a249.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.3 精通自定义 View 之 Android 画布——SurfaceView</title>
      <link href="/2019/07/10/05%20CUSTOM%20VIEW/10.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94SurfaceView/"/>
      <url>/2019/07/10/05%20CUSTOM%20VIEW/10.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94SurfaceView/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b0f5e0bdab469316.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="10-3-1-概述"><a href="#10-3-1-概述" class="headerlink" title="10.3.1 概述"></a>10.3.1 概述</h3><p>Android 屏幕刷新的时间间隔是 16ms，如果 View 能够在 16ms 内完成所需执行的绘图操作，那么在视觉上，界面就是流畅的；否则就会出现卡顿。很多时候，在自定义 View 的日志中，经常会看到如下警告：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Skipped 60 frames! The application may be doing too much work on its main thread</div></pre></td></tr></table></figure></p><p>之所以会出现这些警告，大部分是因为我们在绘制过程中不单单执行了绘图操作，也夹杂了很多逻辑处理，导致在指定的 16ms 内并没有完成绘制，出现界面卡顿和警告。为了解决这个问题，Android 引入了 SurfaceView。它在两个方面改进了 View 的绘图操作：</p><ul><li>使用双缓冲技术。</li><li>自带画布，支持在子线程中更新画布内容。</li></ul><p>所谓双缓冲技术，简单来讲，就是多加一块缓冲画布，当需要执行绘图操作时，现在缓冲画布上绘制，绘制好后直接将缓冲画布上的内容更新到主画布上。这样，在屏幕更新时，只需把换缓冲画布上的内容照样画过来就可以了，就不会存在逻辑处理时间的问题，也就解决了超时绘制的问题。具体详见 10.3.3。</p><p>虽然 SurfaceView 在处理耗时操作时很有用，但正是因为在新的线程中更新画面，所以不会阻塞主线程。但这也带来了另一个问题，就是事件同步。比如，你触摸了屏幕，SurfaceView 就会调用线程来处理，当线程过多时，一般就需要一个线程队列来保存触摸事件，这会稍稍复杂一点，因为涉及线程同步。</p><p>总之，View 和 SurfaceView 都有各自的应用场景：</p><ul><li>当界面需要被动更新时，用 View 较好。比如，与手势交互的场景，因为画面的更新是依赖 onTouch 来完成的，所以可以直接使用 invalidate() 函数。在这种情况下，这一次 Touch 和下一次 Touch 间隔的时间比较长，不会产生影响。</li><li>当界面需要主动更新，用 SurfaceView 较好。比如一个人在一直跑动，这就需要一个单独的线程不停地重绘人的状态，避免阻塞主线程。显然 View 不合适，需要 SurfaceView 来控制。</li><li>当界面绘制需要频繁刷新，或者刷新是数据处理量比较大时，就应该用 SurfaceView 来实现，比如视频播放及 Camera。</li></ul><p><div id="jump2"></div></p><h3 id="10-3-2-SurfaceView-的基本用法"><a href="#10-3-2-SurfaceView-的基本用法" class="headerlink" title="10.3.2 SurfaceView 的基本用法"></a>10.3.2 SurfaceView 的基本用法</h3><h4 id="1-实现-View-功能"><a href="#1-实现-View-功能" class="headerlink" title="1. 实现 View 功能"></a>1. 实现 View 功能</h4><p>SurfaceView 派生自 View，所以 SurfaceView 能使用 View 中的所有方法，但要注意，View 中的所有方法都是在主线程中执行。下面使用 SurfaceView 来实现捕捉用户手势轨迹的自定义控件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public class TestView extends SurfaceView &#123;</div><div class="line"></div><div class="line">    private Path mPath;</div><div class="line">    private Paint mPaint;</div><div class="line"></div><div class="line">    public TestView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs, int defStyle) &#123;</div><div class="line">        super(context, attrs, defStyle);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        // setWillNotDraw(false);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(5);</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        int x = (int) event.getX();</div><div class="line">        int y = (int) event.getY();</div><div class="line">        if (event.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">            mPath.moveTo(x, y);</div><div class="line">            Log.d(&quot;xian&quot;, &quot;ACTION_DOWN&quot;);</div><div class="line">            return true;</div><div class="line">        &#125; else if (event.getAction() == MotionEvent.ACTION_MOVE) &#123;</div><div class="line">            mPath.lineTo(x, y);</div><div class="line">        &#125;</div><div class="line">        postInvalidate();</div><div class="line">        Log.d(&quot;xian&quot;, &quot;invalidate&quot;);</div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        Log.d(&quot;xian&quot;, &quot;onDraw&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然而，效果却是不显示手势轨迹，而一直显示黑屏。查看日志，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-da5c709d3abc8755.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从日志中可以看出，上述代码只调用了 postInavidate() 函数，而没有调用 onDraw() 函数。这是为什么呢？当你把 init() 函数中注释掉的一行代码打开以后，就会发现可以看到手势轨迹了。</p><p><strong>setWillNotDraw(boolean willNotDraw)</strong> 这个函数存在于 View 类中，它主要用在 View 派生子类的初始化中，如果参数 willNotDraw 取 true，则表示当前控件没有绘制内容，当屏幕重绘的时候，这个控件不需要绘制，所以在重绘的时候也就不会调用这个类的 onDraw() 函数。相反，如果参数 willNotDraw 取 false，则表示当前控件在每次重绘时，都需要绘制该控件。可见，setWillNotDraw 其实是一种优化策略，它让控件显示地告诉系统，在重绘屏幕时，哪个控件需要重绘，哪个控件不需要重绘，这样就可以大大提高重绘效率。</p><p>一般而言，想 LinearLayout、RelativeLayout 等布局控件，它们的主要功能是布局其中的控件，它们本身是没有东西需要绘制的，所以它们在构造的时候都会显示设置 setWillNotDraw(true)</p><p>总结：</p><ul><li>原本能够通过派生自 View 实现的控件，依然可以通过 SurfaceView 来实现，因为 SurfaceView 派生自 View。</li><li>当 SurfaceView 需要使用 View 的 onDraw() 函数来重绘控件时，需要在初始化的时候调用 setWillNotDraw(false)，否则 onDraw() 函数不会被调用。</li><li>View 中的所有方法都是在主线程中执行的，所以并不建议使用 SurfaceView 重写 View 的 onDraw() 函数来实现自定义控件，而要使用 SurfaceView 特有的双缓冲机制绘图。</li></ul><h4 id="2-使用缓冲-Canvas-绘图"><a href="#2-使用缓冲-Canvas-绘图" class="headerlink" title="2. 使用缓冲 Canvas 绘图"></a>2. 使用缓冲 Canvas 绘图</h4><p>通过以下方式来获取 SurfaceView 自带的画布。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SurfaceHolder surfaceHolder = getHolder();</div><div class="line">Canvas canvas = surfaceHolder.lockCanvas();</div><div class="line">// TODO 绘图操作</div><div class="line">surfaceHolder.unlockCanvasAndPost(canvas);</div></pre></td></tr></table></figure></p><p>前面说过线程同步问题，所以需要给获取的缓冲画布进行加锁，防止被其他线程更改；当绘图操作完成以后，将缓冲画布释放，并将所画内容更新到主线程的画布上，显示在屏幕上。使用缓冲画布来改造上面的示例代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public class TestView extends SurfaceView &#123;</div><div class="line"></div><div class="line">    private Path mPath;</div><div class="line">    private Paint mPaint;</div><div class="line"></div><div class="line">    public TestView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs, int defStyle) &#123;</div><div class="line">        super(context, attrs, defStyle);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(5);</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        int x = (int) event.getX();</div><div class="line">        int y = (int) event.getY();</div><div class="line">        if (event.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">            mPath.moveTo(x, y);</div><div class="line">            return true;</div><div class="line">        &#125; else if (event.getAction() == MotionEvent.ACTION_MOVE) &#123;</div><div class="line">            mPath.lineTo(x, y);</div><div class="line">        &#125;</div><div class="line">        drawCanvas();</div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void drawCanvas() &#123;</div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                SurfaceHolder surfaceHolder = getHolder();</div><div class="line">                Canvas canvas = surfaceHolder.lockCanvas();</div><div class="line">                if (canvas != null) &#123;</div><div class="line">                    canvas.drawPath(mPath, mPaint);</div><div class="line">                &#125;</div><div class="line">                surfaceHolder.unlockCanvasAndPost(canvas);</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注意，onTouchEvent() 函数是在主线程执行的，所以我们需要开启子线程更新画布。效果图如下。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-14619c98984a1666.gif?imageMogr2/auto-orient/strip" alt=""></p><h4 id="3-监听-Surface-生命周期"><a href="#3-监听-Surface-生命周期" class="headerlink" title="3. 监听 Surface 生命周期"></a>3. 监听 Surface 生命周期</h4><p>与 SurfaceView 相关的有三个概念：Surface、SurfaceView、SurfaceHolder。这三个概念是典型的 MVC 模式 (Model-View-Controller)。Surface 是 Model，保存着缓冲画布和绘图内容相关的各种信息；SurfaceView 是 View，负责将 Surface 中存储的数据展示在 View 上；SurfaceHolder 是 Controller，使用它才能操作 Surface 中的数据。</p><p>生命周期监听函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">SurfaceHolder surfaceHolder = getHolder();</div><div class="line">surfaceHolder.addCallback(new SurfaceHolder.Callback() &#123;</div><div class="line">    @Override</div><div class="line">    public void surfaceCreated(SurfaceHolder holder) &#123;</div><div class="line">        // 当 Surface 对象被创建后，该函数就会被立即调用</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123;</div><div class="line">        // 当 Surface 发生任何结构性的变化时（格式或者大小），该函数就会被立即调用</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void surfaceDestroyed(SurfaceHolder holder) &#123;</div><div class="line">        // 当 Surface 对象将要被销毁时，该函数就会被立即调用</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>示例：动态背景效果</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-bdaa5b67454c3d29.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">public class TestView extends SurfaceView &#123;</div><div class="line"></div><div class="line">    private SurfaceHolder mHolder;</div><div class="line">    private boolean flag = false;                   // 线程标示</div><div class="line">    private Bitmap mBgBitmap;                       // 背景图</div><div class="line"></div><div class="line">    private float mSurfaceWidth, mSurfaceHeight;    // 屏幕宽高</div><div class="line">    private int mBitPosX;                           // 开始绘制的图片的 x 坐标</div><div class="line">    private Canvas mCanvas;</div><div class="line">    private Thread mThread;</div><div class="line"></div><div class="line">    // 背景移动状态</div><div class="line">    private enum State &#123;</div><div class="line">        LEFT, RIGHT</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 默认向左</div><div class="line">    private State state = State.LEFT;</div><div class="line">    private final int BITMAP_STEP = 5;              // 背景画布移动步伐</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mHolder = getHolder();</div><div class="line">        mHolder.addCallback(new SurfaceHolder.Callback() &#123;</div><div class="line">            @Override</div><div class="line">            public void surfaceCreated(SurfaceHolder holder) &#123;</div><div class="line">                flag = true;</div><div class="line">                startAnimation();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void surfaceDestroyed(SurfaceHolder holder) &#123;</div><div class="line">                flag = false;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void startAnimation() &#123;</div><div class="line">        mSurfaceWidth = getWidth();</div><div class="line">        mSurfaceHeight = getHeight();</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            // 按比例缩放图片，是高度充满屏幕</div><div class="line">            Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.qingmingshanghetu);</div><div class="line">            float width = mSurfaceHeight / bitmap.getHeight() * bitmap.getWidth();</div><div class="line">            mBgBitmap = Bitmap.createScaledBitmap(bitmap, (int)width, (int)mSurfaceHeight, true);</div><div class="line">        &#125; catch (OutOfMemoryError error) &#123;</div><div class="line">            error.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mBgBitmap == null) return;</div><div class="line"></div><div class="line">        // 开始绘图</div><div class="line">        mThread = new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                while (flag) &#123;</div><div class="line">                    mCanvas = mHolder.lockCanvas();</div><div class="line">                    drawView();</div><div class="line">                    mHolder.unlockCanvasAndPost(mCanvas);</div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(16);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        mThread.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void drawView() &#123;</div><div class="line">        if (mCanvas == null) return;</div><div class="line"></div><div class="line">        // 清空屏幕</div><div class="line">        mCanvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);</div><div class="line">        // 从 mBitPosX 开始绘制屏幕背景</div><div class="line">        mCanvas.drawBitmap(mBgBitmap, mBitPosX, 0, null);</div><div class="line"></div><div class="line">        // 图片滚动效果</div><div class="line">        switch (state) &#123;</div><div class="line">            case LEFT:</div><div class="line">                mBitPosX -= BITMAP_STEP;    // 画布左移</div><div class="line">                break;</div><div class="line">            case RIGHT:</div><div class="line">                mBitPosX += BITMAP_STEP;    // 画布右移</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        if (mBitPosX &lt;= -mSurfaceWidth / 2) &#123;</div><div class="line">            state = State.RIGHT;</div><div class="line">        &#125;</div><div class="line">        if (mBitPosX &gt;= 0) &#123;</div><div class="line">            state = State.LEFT;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><div id="jump3"></div></p><h3 id="10-3-3-SurfaceView-双缓冲技术"><a href="#10-3-3-SurfaceView-双缓冲技术" class="headerlink" title="10.3.3 SurfaceView 双缓冲技术"></a>10.3.3 SurfaceView 双缓冲技术</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>双缓冲技术需要两个图形缓冲区：前端缓冲区和后端缓冲区。前端缓冲区对应当前屏幕正在显示的内容，而后端缓冲区是接下来要渲染的图形缓冲区。通过 surfaceHolder.lockCanvas() 函数获得的缓冲区是后端缓冲区。当绘图完成以后，调用 surfaceHolder.unlockCanvasAndPost(mCanvas) 函数将后端缓冲区与前端缓冲区交换，后端缓冲区变成前端缓冲区，将内容显示在屏幕上；而原来的前端缓冲区则变成后端缓冲区，等待下一次的 surfaceHolder.lockCanvas() 函数调用返回给用户使用，如此反复。</p><p>正是由于两块画布交替用来绘图，在绘图完成以后相互交换位置，而且在绘图完成以后直接更新到屏幕上，所以才使得绘图效率大大提高。而这样做却造成了一个问题：两块画布上的内容肯定会存在不一致的情况，尤其是在多线程的情况下。比如，我们利用一个线程操作 A、B 两款画布，目前 A 画布是屏幕画布，所以，当线程要绘图时，获得的缓冲画布是 B。在更新以后，B 画布更新到屏幕上，A 画布与 B 画布交换位置。而这时，如果线程再次申请画布，则将获取到 A 画布。如果 A 画布与 B 画布上的内容不一样，那么，在 A 画布上继续作画肯定会与预想的不一样。</p><p>示例：每获取一次画布写一个数字，循环 10 次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class TestView extends SurfaceView &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPaint.setTextSize(30);</div><div class="line"></div><div class="line">        getHolder().addCallback(new SurfaceHolder.Callback() &#123;</div><div class="line">            @Override</div><div class="line">            public void surfaceCreated(SurfaceHolder holder) &#123;</div><div class="line">                drawText(holder);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void surfaceDestroyed(SurfaceHolder holder) &#123;&#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void drawText(SurfaceHolder holder) &#123;</div><div class="line">        for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">            Canvas canvas = holder.lockCanvas();</div><div class="line">            if (canvas != null) &#123;</div><div class="line">                canvas.drawText(i + &quot;&quot;, i * 30, 50, mPaint);</div><div class="line">            &#125;</div><div class="line">            holder.unlockCanvasAndPost(canvas);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-fbeb48f18a692e38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>按照我们的逻辑，如果有两块缓冲画布，那么结果应该是 1 3 5 7 9。因为最后一个更新的数字必然是 9，而往前推，每次间隔使用画布，跟 9 在同一块画布上的必然是 1 3 5 7，其他数字都在另一块画布上。但结果为什么是 0 3 6 9 呢？这是因为这里有三块缓冲画布。</p><p>如果我们在绘图时使用单独的线程，而且每次绘图完成以后，让线程休眠一段时间，就可以明显地看到每次所绘制的数字了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">private void drawText(final SurfaceHolder holder) &#123;</div><div class="line">    new Thread(new Runnable() &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">                Canvas canvas = holder.lockCanvas();</div><div class="line">                if (canvas != null) &#123;</div><div class="line">                    canvas.drawText(i + &quot;&quot;, i * 100, 150, mPaint);</div><div class="line">                &#125;</div><div class="line">                holder.unlockCanvasAndPost(canvas);</div><div class="line"></div><div class="line">                try &#123;</div><div class="line">                    Thread.sleep(600);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c701c355e280c4a5.gif?imageMogr2/auto-orient/strip" alt=""></p><p>从效果图中可以看出每次获取到的画布上所绘制的内容，很明显，0、1、2 这三个数字是分别在三块空白的画布上绘制的，之后的每个数字都是依次在这三块画布上绘制的。</p><p>有关 Surface 中缓冲画布的数量，<a href="https//source.android.com/devices/graphics/arch-sh.html">Google 给出的解释</a> 是：Surface 中缓冲画布的数量是根据需求动态分配的。如果用户获取画布的频率较慢，那么将会分配两块缓冲画布；否则，将分配 3 的倍数缓冲画布，具体分配多少块，视情况而定。</p><h4 id="2-双缓冲技术局部更新原理"><a href="#2-双缓冲技术局部更新原理" class="headerlink" title="2. 双缓冲技术局部更新原理"></a>2. 双缓冲技术局部更新原理</h4><p>SurfaceView 支持局部更新，可以通过 Canvas lockCanvas(Rect dirty) 函数指定获取画布的区域和大小。画布以外的地方会将现在屏幕上的内容复制过来，以保持与屏幕一致；而画布以内的区域则保持原画布内容。</p><ul><li>lockCanvas()：用于获取整屏画布，屏幕内容不会被更新到画布上，画布保持原画布内容。</li><li>lockCanvas(Rect dirty)：用于获取指定区域的画布，画布以外的区域会保持与屏幕内容一致，画布以内的区域依然保持原画布内容。</li></ul><p>示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-eb901bc2d0c506ff.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">public class TestView extends SurfaceView &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.argb(0x1F, 0xFF, 0xFF, 0xFF));</div><div class="line">        mPaint.setTextSize(60);</div><div class="line"></div><div class="line">        getHolder().addCallback(new SurfaceHolder.Callback() &#123;</div><div class="line">            @Override</div><div class="line">            public void surfaceCreated(SurfaceHolder holder) &#123;</div><div class="line">                drawText(holder);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void surfaceDestroyed(SurfaceHolder holder) &#123;&#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void drawText(final SurfaceHolder holder) &#123;</div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                // 先进行清屏操作</div><div class="line">                while (true) &#123;</div><div class="line">                    Rect dirtyRect = new Rect(0, 0, 1, 1);</div><div class="line">                    Canvas canvas = holder.lockCanvas(dirtyRect);</div><div class="line">                    Rect canvasRect = canvas.getClipBounds();</div><div class="line">                    if (getWidth() == canvasRect.width() &amp;&amp; getHeight() == canvasRect.height()) &#123;</div><div class="line">                        canvas.drawColor(Color.BLACK);</div><div class="line">                        holder.unlockCanvasAndPost(canvas);</div><div class="line">                    &#125; else &#123;</div><div class="line">                        holder.unlockCanvasAndPost(canvas);</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                // 画图</div><div class="line">                for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">                    // 画大方</div><div class="line">                    if (i == 0) &#123;</div><div class="line">                        Canvas canvas = holder.lockCanvas(new Rect(10, 10, 600, 600));</div><div class="line">                        canvas.drawColor(Color.RED);</div><div class="line">                        holder.unlockCanvasAndPost(canvas);</div><div class="line">                    &#125;</div><div class="line">                    // 画中方</div><div class="line">                    if (i == 1) &#123;</div><div class="line">                        Canvas canvas = holder.lockCanvas(new Rect(30, 30, 570, 570));</div><div class="line">                        canvas.drawColor(Color.GREEN);</div><div class="line">                        holder.unlockCanvasAndPost(canvas);</div><div class="line">                    &#125;</div><div class="line">                    // 画小方</div><div class="line">                    if (i == 2) &#123;</div><div class="line">                        Canvas canvas = holder.lockCanvas(new Rect(60, 60, 540, 540));</div><div class="line">                        canvas.drawColor(Color.BLUE);</div><div class="line">                        holder.unlockCanvasAndPost(canvas);</div><div class="line">                    &#125;</div><div class="line">                    // 画圆形</div><div class="line">                    if (i == 3) &#123;</div><div class="line">                        Canvas canvas = holder.lockCanvas(new Rect(200, 200, 400, 400));</div><div class="line">                        mPaint.setColor(Color.argb(0x3F, 0xFF, 0xFF, 0xFF));</div><div class="line">                        canvas.drawCircle(300, 300, 100, mPaint);</div><div class="line">                        holder.unlockCanvasAndPost(canvas);</div><div class="line">                    &#125;</div><div class="line">                    // 写数字</div><div class="line">                    if (i == 4) &#123;</div><div class="line">                        Canvas canvas = holder.lockCanvas(new Rect(250, 250, 350, 350));</div><div class="line">                        mPaint.setColor(Color.RED);</div><div class="line">                        canvas.drawText(i + &quot;&quot;, 300, 300, mPaint);</div><div class="line">                        holder.unlockCanvasAndPost(canvas);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(800);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>分析过程略，得出以下几个结论：</p><ul><li>缓冲画布的存取遵循 LRU（先进先出）策略。</li><li>画布以内的区域仍在原缓冲画布上叠加作画，画布以外的区域是从屏幕上直接复制过来的。</li><li>为了防止画布以内的缓冲画布本身的图像与所画内容产生冲突，在对画布以内的区域作画时，建议先清空画布。</li></ul><h4 id="3-局部更新为何要先清屏"><a href="#3-局部更新为何要先清屏" class="headerlink" title="3. 局部更新为何要先清屏"></a>3. 局部更新为何要先清屏</h4><p>因为这里有三块缓冲画布，有一块画布初始化地被显示在屏幕上，已经被默认填充为黑色，而另外两块画布都还没有被画过。虽然我们指定了获取画布的区域范围，但是系统认为，整块画布都是脏区域，都应该被画上，所以会返回屏幕大小的画布。只有将每块画布都画过以后，才会按照我们指定的区域来返回画布大小。</p><h4 id="4-双缓冲技术解决方案"><a href="#4-双缓冲技术解决方案" class="headerlink" title="4. 双缓冲技术解决方案"></a>4. 双缓冲技术解决方案</h4><p><strong>方案一：保存所有要绘制的内容，全屏重绘</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public class TestView extends SurfaceView &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPaint.setTextSize(100);</div><div class="line"></div><div class="line">        getHolder().addCallback(new SurfaceHolder.Callback() &#123;</div><div class="line">            @Override</div><div class="line">            public void surfaceCreated(SurfaceHolder holder) &#123;</div><div class="line">                drawText(holder);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void surfaceDestroyed(SurfaceHolder holder) &#123;&#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private List&lt;Integer&gt; mInts = new ArrayList&lt;&gt;();</div><div class="line">    private void drawText(final SurfaceHolder holder) &#123;</div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">                    Canvas canvas = holder.lockCanvas();</div><div class="line">                    mInts.add(i);</div><div class="line">                    if (canvas != null) &#123;</div><div class="line">                        for (int num : mInts) &#123;</div><div class="line">                            canvas.drawText(num + &quot;&quot;, num * 100, 150, mPaint);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(600);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    holder.unlockCanvasAndPost(canvas);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-61a0cdaa7a0e2c86.gif?imageMogr2/auto-orient/strip" alt=""></p><p><strong>方案二：在内容不交叉时，可以采用增量绘制</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7e353a9c3a6ce7e6.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">private void drawText(final SurfaceHolder holder) &#123;</div><div class="line">    new Thread(new Runnable() &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            // 先进行清屏操作</div><div class="line">            while (true) &#123;</div><div class="line">                Rect dirtyRect = new Rect(0, 0, 1, 1);</div><div class="line">                Canvas canvas = holder.lockCanvas(dirtyRect);</div><div class="line">                Rect canvasRect = canvas.getClipBounds();</div><div class="line">                if (getWidth() == canvasRect.width() &amp;&amp; getHeight() == canvasRect.height()) &#123;</div><div class="line">                    canvas.drawColor(Color.BLACK);</div><div class="line">                    holder.unlockCanvasAndPost(canvas);</div><div class="line">                &#125; else &#123;</div><div class="line">                    holder.unlockCanvasAndPost(canvas);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            // 画图</div><div class="line">            for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">                int itemWidth = 100;</div><div class="line">                int itemHeight = 100;</div><div class="line">                Rect rect = new Rect(i*itemWidth, 0, (i+1)*itemWidth-10, itemHeight);</div><div class="line">                Canvas canvas = holder.lockCanvas(rect);</div><div class="line">                if (canvas != null) &#123;</div><div class="line">                    canvas.drawColor(Color.GREEN);</div><div class="line">                    canvas.drawText(i + &quot;&quot;, i*itemWidth+10, itemHeight/2f, mPaint);</div><div class="line">                &#125;</div><div class="line">                holder.unlockCanvasAndPost(canvas);</div><div class="line"></div><div class="line">                try &#123;</div><div class="line">                    Thread.sleep(600);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>局部更新清屏代码，在每次开始运行程序时，在获取第二缓冲画布时，依然是全屏画布。但是同样的代码，从任务列表恢复程序时，又运行正常。百思不得其解！！！</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/14186083-68f14b45595eafc4.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.2 精通自定义 View 之 Android 画布——Bitmap</title>
      <link href="/2019/07/10/05%20CUSTOM%20VIEW/10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap/"/>
      <url>/2019/07/10/05%20CUSTOM%20VIEW/10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-8756b535aeb29b19.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="10-2-1-概述"><a href="#10-2-1-概述" class="headerlink" title="10.2.1 概述"></a>10.2.1 概述</h3><h4 id="1-Bitmap-在绘图中的使用"><a href="#1-Bitmap-在绘图中的使用" class="headerlink" title="1. Bitmap 在绘图中的使用"></a>1. Bitmap 在绘图中的使用</h4><p>Bitmap 在绘图中相关的使用主要有两种：转换为 BitmapDrawable 对象使用；当做画布使用。</p><h5 id="1）转换为-BitmapDrawable-对象使用"><a href="#1）转换为-BitmapDrawable-对象使用" class="headerlink" title="1）转换为 BitmapDrawable 对象使用"></a>1）转换为 BitmapDrawable 对象使用</h5><p>就是直接将 Bitmap 转换为 BitmapDrawable 对象，然后转换为 Drawable 使用。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.head);</div><div class="line">BitmapDrawable bitmapDrawable = new BitmapDrawable(bitmap);</div><div class="line">ImageView imageView = findViewById(R.id.image_view);</div><div class="line">imageView.setImageDrawable(bitmapDrawable);</div></pre></td></tr></table></figure></p><h5 id="2）当做画布使用"><a href="#2）当做画布使用" class="headerlink" title="2）当做画布使用"></a>2）当做画布使用</h5><p>在前面的章节中，已经不止一次地将 Bitmap 转换为画布。这里有两种使用方式。<br><strong>方式一：使用默认画布</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class TestView extends View &#123;</div><div class="line">    ...</div><div class="line">    public void onDraw(Canvas canvas) &#123;</div><div class="line">        ...</div><div class="line">        RectF rect = new RectF(120, 10, 210, 100);</div><div class="line">        canvas.drawRect(rect, paint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>此处的 Canvas 里保存的就是一个 Bitmap，我们调用 Canvas 的各种绘图函数，最终都是画在这个 Bitmap 上的，而这个 Bitmap 就是默认画布。</p><p><strong>方式二：自建画布</strong><br>有时候我们需要在特定的 Bitmap 上作画，比如给照片加水印；或者我们只需要一块空白画布。在这些情况下，我们就需要自己来创建 Canvas 对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Bitmap bitmap = Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_8888);</div><div class="line">Canvas canvas = new Canvas(bitmap);</div><div class="line">canvas.drawColor(Color.BLACK);</div></pre></td></tr></table></figure></p><p>在上面的代码中，我们先创建一个空白的 Bitmap，然后再利用这个 Bitmap 创建一个 Canvas 对象，那么，调用 Canvas 的任何绘图函数最终都将画在这个 Bitmap 上。最后，我们可以将这个 Bitmap 保存到本地，也可以画到 View 上。</p><h4 id="2-Bitmap-格式"><a href="#2-Bitmap-格式" class="headerlink" title="2. Bitmap 格式"></a>2. Bitmap 格式</h4><p>我们都知道 Bitmap 是位图，也就是由一个个像素点组成的。所以，它肯定涉及两个问题：第一，如何存储每个像素点；第二，相关的像素点之间是否能够压缩，这也就涉及压缩算法的问题。</p><h5 id="1）如何存储每个像素点"><a href="#1）如何存储每个像素点" class="headerlink" title="1）如何存储每个像素点"></a>1）如何存储每个像素点</h5><p>一张位图所占用的内存 = 图片长度(px) x 图片宽度(px) x 一个像素点占用的字节数。在 Android 中，存储一个像素点所使用的字节数是用枚举类型 Bitmap.Config 中的各个参数来表示的，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1a2a0c3b1c53c9b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>其中，A 代表透明度；R 代表红色；G 代表绿色；B 代表蓝色。</p><ul><li>ALPHA_8：表示 8 位 Alpha 位图，即 A = 8，表示只存储 Alpha 位，不存储颜色值。一个像素点占用 1 字节。它没有颜色，只有透明度。</li><li>ARGB_4444：表示 16 位 ARGB 位图，即 A、R、G、B 各占 4 位，一个像素点占 4 + 4 + 4 + 4 = 16 位，2 字节。</li><li>ARGB_8888：表示 32 位 ARGB 位图，即 A、R、G、B 各占 8 位，一个像素点占 8 + 8 + 8 + 8 = 32 位，4 字节。</li><li>RGBA_F16：表示 64 位 RGBA 位图，8 字节，Android 8.0 新增。</li><li>RGB_565：表示 16 位 RGB 位图，即 R 占 5 位，G 占 6 位，B 占 5 位，它没有透明度，一个像素点占 5 + 6 + 5 = 16 位，2 字节。</li></ul><p>大家应该都知道，每个色值所占得位数越大，颜色越艳丽。为什么呢？</p><p>假设表示透明度的 A 占 4 位，我们来算一下，4 位的透明度有多少种取值？很明显，每位要么是 0，要么是 1，所以共有 $2^4$，也就是 16 种取值。假设透明度占 8 位呢？那么这个透明度就有 $2^8$，也就是 256 种取值。表示颜色值的 R、G、B 所占位数与颜色取值数的计算方式是一样的。很明显，取值数越多，所能表示的颜色就越多，颜色就越艳丽。</p><p>以上 5 种格式各自表示了以何种状态存储 Bitmap。ALPHA_8 格式只存储透明度，而不存储颜色值，由于所表示的内容太过简单，所以我们一般不用；RGB_565 格式只存储颜色值，而不存储透明度，透明度全部是 FF，假如对图片没有透明度要求，相比 ARGB_8888 格式将节省一半的内存开销；其他三种格式都是既存储透明度又存储颜色值，但 ARGB_4444 格式的画质惨不忍睹，在 API 13 中已经被弃用了。RGBA_F16 格式是最占内存的，同时也是画质最高的。如果对画质没那么高的要求，一般用 ARGB_8888 格式。</p><p>下面我们来看一下如何计算 Bitmap 所占的内存大小。</p><p>在讲解 Bitmap 所占内存大小之前，我们先明确一个概念：内存中存储的 Bitmap 对象与文件中存储的 Bitmap 图片不是一个概念。文件中存储的 Bitmap 图片是经过我们在后面降到的压缩算法压缩过得；而内存中存储的 Bitmap 对象是通过 BitmapFactory 或者 Bitmap 的 Create 方法创建的，它保存在内存中，而且具有明确的宽和高。所以，很明显，内存中存储的一个 Bitmap 对象，它所占的内存大小 = Bitmap 的宽 x Bitmap 的高 x 每个像素所占内存大小。</p><p>很多读者一旦需要画布，就会创建一个全屏幕大小的 Bitmap 作为画布。我们现在就来算一下在一个分辨率是 1024 像素 x 768 像素的屏幕上，创建一个与屏幕同样大小的 Bitmap，到底需要多少内存？也就是说，这个屏幕长度上有 1024 个像素，宽度上有 768 个像素。我们假设每个像素使用 ARGB_8888 格式来存储，也就是一个像素占 32 位，那么要全屏显示这张图片所占的内存大小 = 1024 x 768 x 32B = 25 165 824B = 24MB。全屏显示一张图片要用 24MB。而且更恐怖的是，有些人还会循环创建。这也是在有些人自定义的控件中经常出现 OOM 的原因。所以，我们在创建画布时，应尽量根据需要的大小来创建。</p><h5 id="2）Bitmap-压缩格式"><a href="#2）Bitmap-压缩格式" class="headerlink" title="2）Bitmap 压缩格式"></a>2）Bitmap 压缩格式</h5><p>在 Android 中，压缩格式使用枚举类 Bitmap.CompressFormat 中的成员变量表示，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-840395c947ec0be4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>其实这个参数很简单，就是指定 Bitmap 是以 JPEG、PNG 还是 WEBP 格式来压缩的，每种格式对应一种压缩算法。有关各种压缩算法的具体效果，我们会在 10.2.5 节中具体讲解。</p><p><div id="jump2"></div></p><h3 id="10-2-2-创建-Bitmap-方法之一：BitmapFactory"><a href="#10-2-2-创建-Bitmap-方法之一：BitmapFactory" class="headerlink" title="10.2.2 创建 Bitmap 方法之一：BitmapFactory"></a>10.2.2 创建 Bitmap 方法之一：BitmapFactory</h3><p>BitmapFactory 用于从各种资源、文件、数据流和字节数组中创建 Bitmap（位图）对象。BitmapFactory 类是一个工具类，提供了大量的函数，这些函数可用于从不同的数据源中解析、创建 Bitmap（位图）对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public static Bitmap decodeResource(Resources res, int id)</div><div class="line">public static Bitmap decodeResource(Resources res, int id, Options opts)</div><div class="line"></div><div class="line">public static Bitmap decodeFile(String pathName)</div><div class="line">public static Bitmap decodeFile(String pathName, Options opts)</div><div class="line"></div><div class="line">public static Bitmap decodeByteArray(byte[] data, int offset, int length)</div><div class="line">public static Bitmap decodeByteArray(byte[] data, int offset, int length, Options opts)</div><div class="line"></div><div class="line">public static Bitmap decodeFileDescriptor(FileDescriptor fd)</div><div class="line">public static Bitmap decodeFileDescriptor(FileDescriptor fd, Rect outPadding, Options opts)</div><div class="line"></div><div class="line">public static Bitmap decodeStream(InputStream is)</div><div class="line">public static Bitmap decodeStream(InputStream is, Rect outPadding, Options opts)</div><div class="line"></div><div class="line">public static Bitmap decodeResourceStream(Resources res, TypedValue value, InputStream is, Rect pad, Options opts)</div></pre></td></tr></table></figure></p><p>单从这些函数中就可以看出，BitmapFactory 的功能很强大，可以针对资源、文件、字节数组、FileDescriptor 和 InputStream 数据流解析出对应的 Bitmap 对象，如果解析不出来，则返回 null。而且每个函数都有两个实现，两个实现之间只差一个 Options opts 参数（详见 10.2.3 节中讲述）。</p><h4 id="1-decodeResource-Resources-res-int-id"><a href="#1-decodeResource-Resources-res-int-id" class="headerlink" title="1. decodeResource(Resources res, int id)"></a>1. decodeResource(Resources res, int id)</h4><p>这个函数表示从资源中解码一张位图，主要以 R.drawable.xxx 形式从本地资源中加载。</p><ul><li>Resources res：包含图像数据的资源对象，一般通过 Context.getResource() 函数获得。</li><li>int id：包含图像数据的资源 id。</li></ul><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Bitmap bitmap = BitmapFactory.decodeResource(getResources(), </div><div class="line">        R.drawable.head_icon);</div><div class="line">ImageView iv = findViewById(R.id.img);</div><div class="line">iv.setImageBitmap(bitmap);</div></pre></td></tr></table></figure></p><h4 id="2-decodeFile-String-pathName"><a href="#2-decodeFile-String-pathName" class="headerlink" title="2. decodeFile(String pathName)"></a>2. decodeFile(String pathName)</h4><p>这个函数的主要作用是通过文件路径来加载图片。在实际中，一般在从相册中加载图片或者拍照使用，首先通过 intent 打开相册或摄像头，然后通过 onActivityResult() 函数获取图片 URI，再根据 URI 获取图片路径，最后根据路径解析出图片。其过程详见 <a href="https://blog.csdn.net/harvic880925/article/details/43163175" target="_blank" rel="external">拍照、相册及裁剪的终极实现系列</a>。</p><ul><li>String pathName：解码文件的全路径名。必须是全路径名。</li></ul><p>使用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String fileName = &quot;/data/data/demo.jpg&quot;;</div><div class="line">Bitmap bmp = BitmapFactory.decodeFile(fileName);</div><div class="line">if (bmp == null) &#123;</div><div class="line">    // TODO 文件不存在</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="3-decodeByteArray-byte-data-int-offset-int-length"><a href="#3-decodeByteArray-byte-data-int-offset-int-length" class="headerlink" title="3. decodeByteArray(byte[] data, int offset, int length)"></a>3. decodeByteArray(byte[] data, int offset, int length)</h4><p>根据 Byte 数组来解析出 Bitmap。</p><ul><li>byte[] data：压缩图像数据的字节数组。</li><li>int offset：图像数据偏移量，用于解码器定位从哪里开始解析。</li><li>int length：字节数，从偏移量开始，指定取多少字节进行解析。</li></ul><p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">final ImageView iv = findViewById(R.id.img);</div><div class="line">// 1. 开启异步线程去获取网络图片</div><div class="line">new Thread(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        try &#123;</div><div class="line">            // 2. 将网络返回的 InputStream 转换成 byte[]</div><div class="line">            byte[] data = getImage(path);</div><div class="line">            int length = data.length;</div><div class="line">            // 3. 解析</div><div class="line">            final Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, length);</div><div class="line">            iv.post(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    iv.setImageBitmap(bitmap);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div><div class="line"></div><div class="line">public static byte[] getImage(String path) throws Exception &#123;</div><div class="line">    URL url = new URL(path);</div><div class="line">    HttpURLConnection connection = (HttpURLConnection) url.openConnection();</div><div class="line">    connection.setRequestMethod(&quot;GET&quot;);</div><div class="line">    connection.setReadTimeout(6 * 1000);</div><div class="line">    InputStream in = null;</div><div class="line">    if (connection.getResponseCode() == 200) &#123;</div><div class="line">        in = connection.getInputStream();</div><div class="line">        byte[] result = readStream(in);</div><div class="line">        in.close();</div><div class="line">        return  result;</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static byte[] readStream(InputStream in) throws Exception &#123;</div><div class="line">    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();</div><div class="line">    byte[] buffer = new byte[1024];</div><div class="line">    int len = -1;</div><div class="line">    while ((len = in.read(buffer)) != -1) &#123;</div><div class="line">        outputStream.write(buffer, 0, len);</div><div class="line">    &#125;</div><div class="line">    outputStream.close();</div><div class="line">    in.close();</div><div class="line">    return outputStream.toByteArray();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>因为 BitmapFactory.decodeByteArray() 函数所需的 data 字节数组并不是想象中的数组，而是把输入流转换成字节内存输出流的字节数组格式。如果不经过 OutputStream 转换，直接返回从 InputStream 中读取到的 byte 数组，那么 decodeByteArray() 函数将一直返回 null。</p><h4 id="4-decodeFileDescriptor"><a href="#4-decodeFileDescriptor" class="headerlink" title="4. decodeFileDescriptor"></a>4. decodeFileDescriptor</h4><p>有两个构造函数，其参数：</p><ul><li>FileDescriptor fd：包含解码位图数据的文件路径。</li><li>Rect outPadding：用于返回矩形的内边距。如果 Bitmap 没有被解析成功，则返回 (-1, -1, -1, -1)；如果不需要，则可以传入 null。这个参数一般不使用。</li></ul><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">String path = &quot;/data/data/demo.jpg&quot;;</div><div class="line">FileInputStream is = new FileInputStream(path);</div><div class="line">bmp = BitmapFactory.decodeFileDescriptor(is.getFD());</div><div class="line">if (bmp == null) &#123;</div><div class="line">    // TODO 文件不存在</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 Android 老版本中，BitmapFactory.decodeFileDescriptor() 解析方法比使用 BitmapFactory.decodeFile(path) 更节省内存。对比源码发现，前者是直接调用 nativeDecodeFileDescriptor() 函数，它是 Android Native 里的函数，被封装在 SO 里；而追踪 decodeFile() 函数发现，在最终调用 nativeDecodeStream() 函数之前，最多可能会申请两次空间。在 API 28 中源码没有发现多处申请内存空间的问题。</p><h4 id="5-decodeStream"><a href="#5-decodeStream" class="headerlink" title="5. decodeStream"></a>5. decodeStream</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static Bitmap decodeStream(InputStream is)</div><div class="line">public static Bitmap decodeStream(InputStream is, Rect outPadding, Options opts)</div></pre></td></tr></table></figure><ul><li>InputStream is：用于解码位图的原始输入流。</li><li>Rect outPadding：用于返回矩形的内边距。如果 Bitmap 没有被解析成功，则返回 (-1, -1, -1, -1)；如果不需要，则可以传入 null。这个参数一般不使用。</li></ul><p>对前面 decodeByteArray 示例代码进行改造：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">new Thread(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        try &#123;</div><div class="line">            InputStream inputStream = getImage(path);</div><div class="line">            final Bitmap bitmap = BitmapFactory.decodeStream(inputStream);</div><div class="line">            iv.post(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    iv.setImageBitmap(bitmap);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div><div class="line"></div><div class="line">public static InputStream getImage(String path) throws Exception &#123;</div><div class="line">    URL url = new URL(path);</div><div class="line">    HttpURLConnection connection = (HttpURLConnection) url.openConnection();</div><div class="line">    connection.setRequestMethod(&quot;GET&quot;);</div><div class="line">    connection.setReadTimeout(6 * 1000);</div><div class="line">    InputStream in = null;</div><div class="line">    if (connection.getResponseCode() == 200) &#123;</div><div class="line">        return connection.getInputStream();</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><div id="jump3"></div></p><h3 id="10-2-3-BitmapFactory-Options"><a href="#10-2-3-BitmapFactory-Options" class="headerlink" title="10.2.3 BitmapFactory.Options"></a>10.2.3 BitmapFactory.Options</h3><p>这个参数的作用非常大，它可以设置 Bitmap 的采样率，通过改变图片的宽度、高度、缩放比例等，以减少图片的像素的目的。总的来说，通过设置这个值，可以更好地控制、显示、使用 Bitmap。在实际开发中可以灵活使用该值，以降低 OOM 的发生概率。</p><p>下面列出常用的部分成员变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public boolean inJustDecodeBounds;</div><div class="line">public int inSampleSize;</div><div class="line">public int inDensity;</div><div class="line">public int inTargetDensity;</div><div class="line">public int inScreenDensity;</div><div class="line">public Bitmap.Config inPreferredConfig;</div><div class="line"></div><div class="line">public int outWidth;</div><div class="line">public int outHeight;</div><div class="line">public String outMimeType;</div></pre></td></tr></table></figure></p><p>以 in 开头的代表的就是设置某某参数；以 out 开头的代表的就是获取某某参数。比如，inSampleSize 就是设置 Bitmap 的缩放比例，outWidth 就是获取 Bitmap 的高度。</p><h4 id="1-inJustDecodeBounds-获取图片信息"><a href="#1-inJustDecodeBounds-获取图片信息" class="headerlink" title="1. inJustDecodeBounds 获取图片信息"></a>1. inJustDecodeBounds 获取图片信息</h4><p>将这个字段设置为 true，则表示只解析图片信息，不获取图片，不分配内存。能获取的信息有图片的宽度、高度和图片的 MIME 类型。图片的宽度、高度通过 options.outWidth (图片的原始宽度) 和 options.outHeight (图片的原始高度) 返回；图片的 MIME 类型通过 options.outMimeType 返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BitmapFactory.Options options = new BitmapFactory.Options();</div><div class="line">options.inJustDecodeBounds = true;</div><div class="line">Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.head, options);</div><div class="line">Log.d(&quot;xian&quot;, &quot;bitmap: &quot; + bitmap);</div><div class="line">Log.d(&quot;xian&quot;, &quot;realWidth: &quot; + options.outWidth + </div><div class="line">        &quot;, realHeight: &quot; + options.outHeight + </div><div class="line">        &quot;, mimeType: &quot; + options.outMimeType);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-395cffe4b6499d7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从结果中看可以看出，返回的 Bitmap 是 null，而获取到的 width 和 height 都是有值的。这就证明了我们的结论：inJustDecodeBounds 只会解析 Bitmap 的宽/高参数，而不会解析 Bitmap，整个过程是不占内存的。</p><h4 id="2-inSampleSize-压缩图片"><a href="#2-inSampleSize-压缩图片" class="headerlink" title="2. inSampleSize 压缩图片"></a>2. inSampleSize 压缩图片</h4><p>这个字段表示采样频率，简称采样率，是指每隔多少个样本采样一次作为结果。比如，将这个字段设置为 4，意思就是从原本图片的 4 个像素中取一个像素作为结果返回，其余的都丢弃，这样，结果图片的宽和高都为原来的 1/4。同样，如果将这个字段设置为 16，意思就是从每 16 个像素中取一个像素返回，同样，宽和高都为原来的 1/16。很明显，采样率越大，图片越小，同时图片越失真。</p><p>针对 inSampleSize 的值，官方建议取 2 的冥数，比如 1、2、4、8、16 等，否则会被系统向下取整并找到一个最接近的值。不能去小于 1 的值，否则系统将一直使用 1 来作为采样率。</p><p>所以，这个参数主要用来对图像进行压缩。那如何确定一张图片的采样率呢？那就是使得缩放后的图片尺寸尽量大于等于相应的 ImageView 大小。一般计算 inSampleSize 的步骤如下。</p><p>第一步，获取图片的原始宽高。通过将 Options 对象的 inJustDecodeBounds 属性设置为 true 后调用 decodeResource() 函数，可以实现不真正加载图片而只获取图片的尺寸信息。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BitmapFactory.Options options = new BitmapFactory.Options();</div><div class="line">options.inJustDecodeBounds = true;</div><div class="line">BitmapFactory.decodeResource(getResources(), resId, options);</div><div class="line">// 现在原始宽高存储在 Options 对象的 outWidth 和 outHeight 实例域中</div></pre></td></tr></table></figure></p><p>第二步，根据原始宽高和目标宽高计算出 inSampleSize。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// dstWidth 和 dstHeight 分为被目标 ImageView 的宽和高</div><div class="line">public static int calSampleSize(BitmapFactory.Options options, int dstWidth, int dstHeight) &#123;</div><div class="line">    int rawWidth = options.outWidth;</div><div class="line">    int rawHeight = options.outHeight;</div><div class="line">    int inSampleSize = 1;</div><div class="line">    if (rawWidth &gt; dstWidth || rawHeight &gt; dstHeight) &#123;</div><div class="line">        float ratioWidth = (float) rawWidth / dstWidth;</div><div class="line">        float ratioHeight = (float) rawHeight / dstHeight;</div><div class="line">        inSampleSize = (int) Math.min(ratioWidth, ratioHeight);</div><div class="line">    &#125;</div><div class="line">    return inSampleSize;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>第三步，根据采样率解析出压缩后的 Bitmap。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">BitmapFactory.Options options2 = new BitmapFactory.Options();</div><div class="line">options2.inSampleSize = sampleSize;</div><div class="line">try &#123;</div><div class="line">    Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.scenery, options2);</div><div class="line">    iv.setImageBitmap(bmp);</div><div class="line">&#125; catch (OutOfMemoryError err) &#123;</div><div class="line">    // TODO OOM</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="3-加载一个-Bitmap-文件究竟要占多少空间"><a href="#3-加载一个-Bitmap-文件究竟要占多少空间" class="headerlink" title="3. 加载一个 Bitmap 文件究竟要占多少空间"></a>3. 加载一个 Bitmap 文件究竟要占多少空间</h4><p>为了适配不同的屏幕，Android 系统预先准备了几个资源文件夹。</p><div class="table-container"><table><thead><tr><th style="text-align:left">文件夹</th><th style="text-align:left">drawable-ldpi</th><th style="text-align:left">drawable-mdpi</th><th style="text-align:left">drawable-hdpi</th><th style="text-align:left">drawable-xhdpi</th><th style="text-align:left">drawable-xxhdpi</th><th style="text-align:left">drawable-xxxhdpi</th></tr></thead><tbody><tr><td style="text-align:left">density</td><td style="text-align:left">1</td><td style="text-align:left">1.5</td><td style="text-align:left">2</td><td style="text-align:left">3</td><td style="text-align:left">3.5</td><td style="text-align:left">4</td></tr><tr><td style="text-align:left">densityDpi</td><td style="text-align:left">160</td><td style="text-align:left">240</td><td style="text-align:left">320</td><td style="text-align:left">480</td><td style="text-align:left">560</td><td style="text-align:left">640</td></tr></tbody></table></div><ul><li>density：表示 dpi 与 px 的换算比例。</li><li>densityDpi：表示在对应的分辨率下每英寸有多少个 dpi。</li></ul><p>即：屏幕上 1 英寸长所对应的 px 数 = density × densityDpi。Android 系统在加载图片时会根据需要动态缩放图片所占的像素数，也就是会动态缩放图片的尺寸。</p><p>比如，有一张 640px × 800px 的图片存放在 xhdpi 文件夹下，这个文件夹所对应的屏幕分辨率是 480dpi，而当真实的屏幕分辨率是 720dpi 的时候，就需要放大此图，以适配这个屏幕，放大倍数就是 720 / 480 = 1.5。加载到内存时，Bitmap 对象的尺寸是 960px × 1200px。因为 Bitmap 默认使用 ARGB_8888格式来存储，也就是每个像素占 4 个字节，所以实际所占得内存字节数为 640px × 1.5 × 800px × 1.5 × 4 = 4608000。但是从 SD 卡加载同样的图片，就不会进行缩放，所占的内存为 640px × 800px × 4 = 2048000。</p><ul><li>不同名称的资源文件夹是为了适配不同的屏幕分辨率的，当屏幕分辨率与文件所在资源文件夹对应的分辨率相同时，直接使用图片，不会对图片进行缩放。</li><li>当屏幕分辨率与图片所在文件夹所对应的分辨率不同时，会进行缩放，缩放比例是：屏幕分辨率 / 文件夹所对应的分辨率。</li><li>当从本地文件夹中加载图片时，不会对图片进行缩放。</li></ul><h4 id="4-inScaled、inDensity、inTargetDensity、inScreenDensity"><a href="#4-inScaled、inDensity、inTargetDensity、inScreenDensity" class="headerlink" title="4. inScaled、inDensity、inTargetDensity、inScreenDensity"></a>4. inScaled、inDensity、inTargetDensity、inScreenDensity</h4><ul><li>inScaled：在需要缩放时，是否对当前文件进行缩放。值为 false 表示不缩放；值为 true 或者不设置，则会根据文件夹分辨率和屏幕分辨率动态缩放。默认为 true。</li><li>inDensity：用于设置文件所在资源文件夹的屏幕分辨率。</li><li>inTargetDensity：表示真实显示的屏幕分辨率。</li><li>inScreenDensity：在源码中没有用到此参数，不表。</li></ul><p>一张图片的缩放比例是通过屏幕真实的分辨率 / 所在资源文件夹所对应的分辨率得出来的，在这里，也就是缩放比例 scale = inTargetDensity / inDensity。这俩个参数的作用就是：可以通过手动设置文件所在资源文件夹的分辨率和真实显示的屏幕分辨率来指定图片的缩放比例。</p><h4 id="5-inPreferredConfig"><a href="#5-inPreferredConfig" class="headerlink" title="5. inPreferredConfig"></a>5. inPreferredConfig</h4><p>这个参数用来设置像素的存储格式的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">options.inPreferredConfig = Bitmap.Config.RGB_565;</div></pre></td></tr></table></figure></p><p><div id="jump4"></div></p><h3 id="10-2-4-创建-Bitmap-方法之二：Bitmap-静态方法"><a href="#10-2-4-创建-Bitmap-方法之二：Bitmap-静态方法" class="headerlink" title="10.2.4 创建 Bitmap 方法之二：Bitmap 静态方法"></a>10.2.4 创建 Bitmap 方法之二：Bitmap 静态方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">static Bitmap createBitmap(int width, int height, Bitmap.Config config)</div><div class="line">static Bitmap createBitmap(int[] colors, int width, int height, Bitmap.Config config)</div><div class="line">static Bitmap createBitmap(int[] colors, int offset, int stride, int width, int height, Bitmap.Config config)</div><div class="line">static Bitmap createBitmap(Bitmap src)</div><div class="line">static Bitmap createBitmap(Bitmap src, int dstWidth, int dstHeight, boolean filter)</div><div class="line">static Bitmap createBitmap(Bitmap source, int x, int y, int width, int height)</div><div class="line">static Bitmap createBitmap(Bitmap source, int x, int y, int width, int height, Matrix m, boolean filter)</div><div class="line"></div><div class="line">// 在 API 17 中添加</div><div class="line">static Bitmap createBitmap(DisplayMetrics display, int width, int height, Bitmap.Config config)</div><div class="line">static Bitmap createBitmap(DisplayMetrics display, int[] colors, int width, int height, Bitmap.Config config)</div><div class="line">static Bitmap createBitmap(DisplayMetrics display, int[] colors, int offset, int stride, int width, int height, Bitmap.Config config)</div></pre></td></tr></table></figure><h4 id="1-static-Bitmap-createBitmap-int-width-int-height-Bitmap-Config-config"><a href="#1-static-Bitmap-createBitmap-int-width-int-height-Bitmap-Config-config" class="headerlink" title="1. static Bitmap createBitmap(int width, int height, Bitmap.Config config)"></a>1. static Bitmap createBitmap(int width, int height, Bitmap.Config config)</h4><p>这个函数可以创建一幅指定大小的空白图像。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-039ff3d2e96d4d67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Bitmap mDestBmp;</div><div class="line">    private Paint mPaint;</div><div class="line"></div><div class="line">    public TestView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs, int defStyle) &#123;</div><div class="line">        super(context, attrs, defStyle);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        mPaint = new Paint();</div><div class="line">        int width = 500;</div><div class="line">        int height = 300;</div><div class="line">        mDestBmp = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);</div><div class="line"></div><div class="line">        Canvas canvas = new Canvas(mDestBmp);</div><div class="line">        Paint paint = new Paint();</div><div class="line">        LinearGradient linearGradient = new LinearGradient(width / 2f, 0, width / 2f,</div><div class="line">                height, 0xffffffff, 0x00ffffff, Shader.TileMode.CLAMP);</div><div class="line">        paint.setShader(linearGradient);</div><div class="line">        canvas.drawRect(0, 0, width, height, paint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        canvas.drawBitmap(mDestBmp, 0, 0, mPaint);</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(5);</div><div class="line">        canvas.drawRect(0, 0, mDestBmp.getWidth(), mDestBmp.getHeight(), mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2-createBitmap-Bitmap-source-int-x-int-y-int-width-int-height"><a href="#2-createBitmap-Bitmap-source-int-x-int-y-int-width-int-height" class="headerlink" title="2. createBitmap(Bitmap source, int x, int y, int width, int height)"></a>2. createBitmap(Bitmap source, int x, int y, int width, int height)</h4><p>这个函数主要用于裁剪图像，各参数的含义如下。</p><ul><li>Bitmap source：用于裁剪的源图像。</li><li>int x, y：开始裁剪的位置点坐标。</li><li>int width, height：裁剪的宽度和高度。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Bitmap src = BitmapFactory.decodeResource(getResources(), R.drawable.dog);</div><div class="line">Bitmap cuteBmp = Bitmap.createBitmap(src, src.getWidth() / 3, src.getHeight() / 3, src.getWidth() / 3, src.getHeight() / 3)</div></pre></td></tr></table></figure><p>这里只是将图像裁剪成矩形。若想把图像裁剪成圆形或者椭圆形，不是使用 Bitmap 的自带方法，而需要用到 Xfermode 图像混合的知识，详见 8.3.2 节。</p><h4 id="3-createBitmap-Bitmap-source-int-x-int-y-int-width-int-height-Matrix-m-boolean-filter"><a href="#3-createBitmap-Bitmap-source-int-x-int-y-int-width-int-height-Matrix-m-boolean-filter" class="headerlink" title="3. createBitmap(Bitmap source, int x, int y, int width, int height, Matrix m, boolean filter)"></a>3. createBitmap(Bitmap source, int x, int y, int width, int height, Matrix m, boolean filter)</h4><p>这个函数相比上面的裁剪函数多了两个参数：Matrix m 和 boolean filter。它的作用也很明显，就是不仅能实现裁剪，还能给裁剪后的图像添加矩阵。</p><ul><li>Matrix m：给裁剪后的图像添加矩阵。</li><li>boolean filter：对应 paint.setFilterBitmap(filter)，即是否给图像添加滤波效果。如果设置为 true，则能够减少图像中由于噪声引起的突兀的孤立像素点或像素块。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Matrix matrix = new Matrix();</div><div class="line">matrix.setScale(2, 1);</div><div class="line">Bitmap src = BitmapFactory.decodeResource(getResources(), R.drawable.dog);</div><div class="line">Bitmap cuteBmp = Bitmap.createBitmap(src, src.getWidth() / 3, src.getHeight() / 3, src.getWidth() / 3, src.getHeight() / 3, matrix, true)</div></pre></td></tr></table></figure><p>将裁剪后的小狗宽度方向放大两倍。</p><h4 id="4-createBitmap-Bitmap-src-int-dstWidth-int-dstHeight-boolean-filter"><a href="#4-createBitmap-Bitmap-src-int-dstWidth-int-dstHeight-boolean-filter" class="headerlink" title="4. createBitmap(Bitmap src, int dstWidth, int dstHeight, boolean filter)"></a>4. createBitmap(Bitmap src, int dstWidth, int dstHeight, boolean filter)</h4><p>该函数用于缩放 Bitmap。各参数的含义如下。</p><ul><li>Bitmap src：需要缩放的源图像。</li><li>int dstWidth, dstHeight：缩放后的目标宽高。</li><li>boolean filter：是否给图像添加滤波效果，对应 paint.setFilterBitmap(filter)</li></ul><h4 id="5-建议"><a href="#5-建议" class="headerlink" title="5. 建议"></a>5. 建议</h4><p>在加载或创建 Bitmap 时，必须如下面代码所示，通过 try…catch 语句捕捉 OutOfMemoryError，以防出现 OOM 问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">    Bitmap src = BitmapFactory.decodeResource(getResources(), R.drawable.scenery);</div><div class="line">    Bitmap bitmap = Bitmap.createScaledBitmap(src, 300, 200, true);</div><div class="line">&#125; catch (OutOfMemoryError error) &#123;</div><div class="line">    error.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><div id="jump5"></div></p><h3 id="10-2-5-常用函数"><a href="#10-2-5-常用函数" class="headerlink" title="10.2.5 常用函数"></a>10.2.5 常用函数</h3><h4 id="1-copy-Config-config-boolean-isMutable"><a href="#1-copy-Config-config-boolean-isMutable" class="headerlink" title="1. copy(Config config, boolean isMutable)"></a>1. copy(Config config, boolean isMutable)</h4><p>根据源图像创建一个副本，可以指定副本的像素存储格式。</p><ul><li>Config config：像素在内存中的存储格式。取值为 ARGB_8888等。</li><li>boolean isMutable：新创建的 Bitmap 是否可以更改其中的像素。</li></ul><p>我们可以使用下面的方法来判断当前的 Bitmap 是不是像素可更改的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean isMutable();</div></pre></td></tr></table></figure></p><p>返回 true 表示像素可以更改的。如果像素是不可更改的，但仍要使用 setPixel() 等函数设置 Bitmap 中的像素值时，就会报错。通过 BitmapFactory 加载的 Bitmap 都是像素不可更改的，只有通过 Bitmap 中的几个函数创建的 Bitmap 才是像素可更改的。这些函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">copy(Bitmap.Config config, boolean isMutable)</div><div class="line">createBitmap(int width, int height, Bitmap.Config config)</div><div class="line">// 当指定的目标缩放宽高与源图像宽高一样时，就会返回源图像，如果源图像是像素不可更改的，那么返回的图像依然是不可更改的</div><div class="line">// 进行缩放过才会生成新的图像，而新生成的图像是像素可更改的。</div><div class="line">createScaledBitmap(Bitmap src, int dstWidth, int dstHeight, boolean filter)</div><div class="line">createBitmap(DisplayMetrics display, int width, int height, Bitmap.Config config)</div></pre></td></tr></table></figure></p><p>对于像素不可更改的图像，是不能作为画布的，比如下面的代码就会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Bitmap srcBmp = BitmapFactory.decodeResource(getResources(), R.drawable.dog);</div><div class="line">Canvas canvas = new Canvas(srcBmp);</div><div class="line">canvas.drawColor(Color.RED);</div></pre></td></tr></table></figure></p><p>显然，srcBmp 是像素不可更改的，然而，当其作为 Canvas 以后，如果要向其中填充颜色，则必然会改变它的像素值，肯定为报错。</p><h4 id="2-extractAlpha"><a href="#2-extractAlpha" class="headerlink" title="2. extractAlpha()"></a>2. extractAlpha()</h4><p>这个函数的主要作用是从 Bitmap 中抽取出 Alpha 值，生成一幅只含有 Alpha 值的图像，像素存储格式是 ALPHA_8。它有两个构造函数。</p><h5 id="1）Bitmap-extractAlpha"><a href="#1）Bitmap-extractAlpha" class="headerlink" title="1）Bitmap extractAlpha()"></a>1）Bitmap extractAlpha()</h5><p>示例：将图像的透明通道抽取出来，并染成天蓝色。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f95ee2e6f3ac9d44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Bitmap srcBmp = BitmapFactory.decodeResource(getResources(), R.drawable.cat_dog);</div><div class="line">Bitmap bitmap = Bitmap.createBitmap(srcBmp.getWidth(), srcBmp.getHeight(), Bitmap.Config.ARGB_8888);</div><div class="line">Canvas canvas = new Canvas(bitmap);</div><div class="line">Paint paint = new Paint();</div><div class="line">paint.setColor(Color.CYAN);</div><div class="line">canvas.drawBitmap(srcBmp.extractAlpha(), 0, 0, paint);</div><div class="line"></div><div class="line">ImageView iv = findViewById(R.id.img);</div><div class="line">iv.setImageBitmap(bitmap);</div><div class="line"></div><div class="line">srcBmp.recycle();</div></pre></td></tr></table></figure><h5 id="2）Bitmap-extractAlpha-Paint-paint-int-offsetXY"><a href="#2）Bitmap-extractAlpha-Paint-paint-int-offsetXY" class="headerlink" title="2）Bitmap extractAlpha(Paint paint, int[] offsetXY)"></a>2）Bitmap extractAlpha(Paint paint, int[] offsetXY)</h5><ul><li>Paint paint：具有 MaskFilter 效果的 Paint 对象，一般使用 BlurMaskFilter 模糊效果。</li><li>int[] offsetXY：返回在添加 BlurMaskFilter 效果以后原点的偏移量。比如，我们使用一个半径为 6 的 BlurMaskFilter 效果，那么在源图像被模糊以后，图像的上下左右 4 条边都会多出 6px 的模糊效果。所以，要想完全显示这幅图像，就不应该从源图像左上角 (0, 0) 点开始绘制，而应从 (-6, -6) 点开始绘制，而 offsetXY 就是相对源图像的建议绘制起始位置，所以此时 offsetXY 的值就是 [-6, -6]。注意，offsetXY 只是建议的绘制起始位置，其取值并不一定与 BlurMaskFilter 的模糊半径一致。</li></ul><p>利用这个模糊效果，可以实现发光效果，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ce03ecdfb64dff04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            Bitmap srcBmp = BitmapFactory.decodeResource(getResources(), R.drawable.cat_dog);</div><div class="line">            // 获取 Alpha Bitmap</div><div class="line">            Paint alphaPaint = new Paint();</div><div class="line">            BlurMaskFilter blurMaskFilter = new BlurMaskFilter(20, BlurMaskFilter.Blur.NORMAL);</div><div class="line">            alphaPaint.setMaskFilter(blurMaskFilter);</div><div class="line">            int[] offsetXY = new int[2];</div><div class="line">            Bitmap alphaBmp = srcBmp.extractAlpha(alphaPaint, offsetXY);</div><div class="line"></div><div class="line">            // 创建 Bitmap</div><div class="line">            Bitmap bitmap = Bitmap.createBitmap(alphaBmp.getWidth(), alphaBmp.getHeight(), Bitmap.Config.ARGB_8888);</div><div class="line">            Canvas canvas = new Canvas(bitmap);</div><div class="line">            Paint paint = new Paint();</div><div class="line">            paint.setColor(Color.CYAN);</div><div class="line">            canvas.drawBitmap(alphaBmp, 0, 0, paint);</div><div class="line"></div><div class="line">            // 绘制源图像</div><div class="line">            canvas.drawBitmap(srcBmp, -offsetXY[0], -offsetXY[1], null);</div><div class="line"></div><div class="line">            // 设置图像并回收没用的资源</div><div class="line">            ImageView iv = findViewById(R.id.img);</div><div class="line">            iv.setImageBitmap(bitmap);</div><div class="line">            srcBmp.recycle();</div><div class="line">        &#125; catch (OutOfMemoryError error) &#123;</div><div class="line">            error.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="3）示例：单击描边效果"><a href="#3）示例：单击描边效果" class="headerlink" title="3）示例：单击描边效果"></a>3）示例：单击描边效果</h5><p><img src="https://upload-images.jianshu.io/upload_images/14186083-5053ab04c41b42b4.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class TestView extends AppCompatImageView &#123;</div><div class="line"></div><div class="line">    public TestView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs, int defStyle) &#123;</div><div class="line">        super(context, attrs, defStyle);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onFinishInflate() &#123;</div><div class="line">        super.onFinishInflate();</div><div class="line">        Paint p = new Paint();</div><div class="line">        p.setColor(Color.CYAN);</div><div class="line">        setStateDrawable(this, p);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void setStateDrawable(ImageView view, Paint paint) &#123;</div><div class="line">        // 拿到源图像</div><div class="line">        BitmapDrawable bd = (BitmapDrawable) view.getDrawable();</div><div class="line">        Bitmap srcBmp = bd.getBitmap();</div><div class="line"></div><div class="line">        // 制作纯色背景</div><div class="line">        Bitmap bitmap = Bitmap.createBitmap(srcBmp.getWidth(), srcBmp.getHeight(), Bitmap.Config.ARGB_8888);</div><div class="line">        Canvas canvas = new Canvas(bitmap);</div><div class="line">        canvas.drawBitmap(srcBmp.extractAlpha(), 0, 0, paint);</div><div class="line"></div><div class="line">        // 添加动态</div><div class="line">        StateListDrawable sld = new StateListDrawable();</div><div class="line">        sld.addState(new int[]&#123;android.R.attr.state_pressed&#125;, new BitmapDrawable(bitmap));</div><div class="line"></div><div class="line">        // setBackgroundDrawable() 函数会移除原有的 padding 值。</div><div class="line">        // 如果需要 padding，则需要调用 setPadding() 函数。</div><div class="line">        view.setBackgroundDrawable(sld);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3-分配空间获取"><a href="#3-分配空间获取" class="headerlink" title="3. 分配空间获取"></a>3. 分配空间获取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// API 19，获取 Bitmap 所分配的内存</div><div class="line">int getAllocationByteCount()</div><div class="line"></div><div class="line">// API 12，获取 Bitmap 所分配的内存</div><div class="line">int getByteCount()</div><div class="line"></div><div class="line">// API 1，获取每行所分配的内存大小。Bitmap 所占内存 = getRowBytes() × bitmap.getHeight()。</div><div class="line">int getRowBytes()</div></pre></td></tr></table></figure><p>所以，一般计算 Bitmap 内存占用的函数会写成如下这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public int getBitmapSize(Bitmap bitmap) &#123;</div><div class="line">    if (bitmap == null) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</div><div class="line">        return bitmap.getAllocationByteCount();</div><div class="line">    &#125;</div><div class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB_MR1) &#123;</div><div class="line">        return bitmap.getByteCount();</div><div class="line">    &#125;</div><div class="line">    return bitmap.getRowBytes() * bitmap.getHeight();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="4-recycle-、isRecycled"><a href="#4-recycle-、isRecycled" class="headerlink" title="4. recycle()、isRecycled()"></a>4. recycle()、isRecycled()</h4><p>这是两个与图片回收有关的函数，其声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 强制回收 Bitmap 所占的内存</div><div class="line">public void recycle()</div><div class="line"></div><div class="line">// 判断当前 Bitmap 的内存是否被回收</div><div class="line">public final boolean isRecycled()</div></pre></td></tr></table></figure></p><p>所以，如果要回收内存，则代码一般这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (bitmap != null &amp;&amp; !bitmap.isRecycled()) &#123;</div><div class="line">    bitmap.recycle();</div><div class="line">    bitmap = null;</div><div class="line">    System.gc();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>注意：使用内存已经被回收的 Bitmap 引起 Crash；在 API 10 及以前的版本中，必须强制调用 recycle() 函数来释放内存；从 API 11 开始，不再强制调用 recycle() 函数来释放内存。</p></blockquote><h4 id="5-setDensity-、getDensity"><a href="#5-setDensity-、getDensity" class="headerlink" title="5. setDensity()、getDensity()"></a>5. setDensity()、getDensity()</h4><p>在 BitmapFactory 中，我们讲过几个 Density 值，如 inDensity、inTargetDensity，而这里 Bitmap 的 setDensity()、getDensity() 函数所对应的就是 inDensity。inDensity 用于表示该 Bitmap 适合的屏幕 dpi，当目标屏幕的 dpi (inTargetDensity) 不等于它时，将会缩放图像以适应目标机器。</p><h4 id="6-setPixel-、getPixel"><a href="#6-setPixel-、getPixel" class="headerlink" title="6. setPixel()、getPixel()"></a>6. setPixel()、getPixel()</h4><p>这两个函数用于针对 Bitmap 中某个位置的像素进行设置和获取。举个例子：将图片中的绿色通道增大 30，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b314a49805454d1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>完整代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        Bitmap srcBmp = BitmapFactory.decodeResource(getResources(), R.drawable.dog);</div><div class="line">        ImageView iv1 = findViewById(R.id.img1);</div><div class="line">        iv1.setImageBitmap(srcBmp);</div><div class="line"></div><div class="line">        Bitmap desBmp = srcBmp.copy(Bitmap.Config.ARGB_8888, true);</div><div class="line">        for (int h = 0; h &lt; srcBmp.getHeight(); h++) &#123;</div><div class="line">            for (int w = 0; w &lt; srcBmp.getWidth(); w++) &#123;</div><div class="line">                int originColor = srcBmp.getPixel(w, h);</div><div class="line"></div><div class="line">                int alpha = Color.alpha(originColor);</div><div class="line">                int red = Color.red(originColor);</div><div class="line">                int green = Color.green(originColor);</div><div class="line">                int blue = Color.blue(originColor);</div><div class="line"></div><div class="line">                if (green &lt; 225) &#123;</div><div class="line">                    green += 30;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                desBmp.setPixel(w, h, Color.argb(alpha, red, green, blue));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ImageView iv2 = findViewById(R.id.img2);</div><div class="line">        iv2.setImageBitmap(desBmp);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="7-compress"><a href="#7-compress" class="headerlink" title="7. compress()"></a>7. compress()</h4><h5 id="1）概述"><a href="#1）概述" class="headerlink" title="1）概述"></a>1）概述</h5><p>用于压缩图像，它会将压缩过得 Bitmap 写入指定的输出流中。函数声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public boolean compress(CompressFormat format, int quality, OutputStream stream)</div></pre></td></tr></table></figure></p><ul><li>CompressFormat format：压缩格式，取值有：CompressFormat.JPEG、CompressFormat.PNG、CompressFormat.WEBP (API 14)。</li><li>int quality：表示压缩后图像的画质，取值是 0~100。0 表示 以最低画质压缩，100 表示以最高画质压缩。对于 PNG 等无损格式的图片，会忽略此项设置。</li><li>OutputStream stream：这是输出值，Bitmap 在被压缩后，会以 OutputStream 的形式在这里输出。</li><li>返回值 boolean：当压缩成功后，返回 true；失败则返回 false。</li></ul><h5 id="2）压缩格式"><a href="#2）压缩格式" class="headerlink" title="2）压缩格式"></a>2）压缩格式</h5><ul><li>CompressFormat.JPEG： 采用 JPEG 压缩算法，是一种有损压缩方式，即在压缩过程中会改变图像的原本质量。compress() 函数中的 quality 参数值越小，画质越差，对图片的原有质量损伤越大，但是得到的图片文件比较小。而且，JPEG 不支持 Alpha 透明度，当遇到透明度像素时，会以黑色背景填充。</li><li>CompressFormat.PNG：采用 PNG 压缩算法，是一种支持透明度的无损压缩格式。</li><li>CompressFormat.WEBP：WEBP 是一种同时提供了有损压缩与无损压缩的图片文件格式，派生自视频编码格式 VP8；从 Android 4.0（API 14）开始支持 WEBP，从 Android 4.2.1+（API 18）开始支持无损 WEBP 和带 Alpha 通道的 WEBP。从整体来讲，WEBP 格式是通过牺牲压缩时间来减小产出文件大小的。</li></ul><h5 id="3）压缩图像"><a href="#3）压缩图像" class="headerlink" title="3）压缩图像"></a>3）压缩图像</h5><p><img src="https://upload-images.jianshu.io/upload_images/14186083-cbfa801ec2535f01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        ImageView iv1 = findViewById(R.id.img1);</div><div class="line">        final ImageView iv2 = findViewById(R.id.img2);</div><div class="line">        final Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.head);</div><div class="line">        iv1.setImageBitmap(bmp);</div><div class="line"></div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                // 压缩图像后，显示</div><div class="line">                ByteArrayOutputStream bos = new ByteArrayOutputStream();</div><div class="line">                bmp.compress(Bitmap.CompressFormat.JPEG, 1, bos);</div><div class="line">                byte[] bytes = bos.toByteArray();</div><div class="line">                final Bitmap bmp1 = BitmapFactory.decodeByteArray(bytes, 0, bytes.length);</div><div class="line">                iv2.post(new Runnable() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void run() &#123;</div><div class="line">                        iv2.setImageBitmap(bmp1);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="4）示例：保存压缩后的图像"><a href="#4）示例：保存压缩后的图像" class="headerlink" title="4）示例：保存压缩后的图像"></a>4）示例：保存压缩后的图像</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">private void saveBitmap(Bitmap bitmap) &#123;</div><div class="line">    File fileDir = Environment.getExternalStorageDirectory();</div><div class="line">    String path = fileDir.getAbsolutePath() + &quot;/xian.jpeg&quot;;</div><div class="line">    </div><div class="line">    File file = new File(path);</div><div class="line">    if (file.exists()) &#123;</div><div class="line">        file.delete();</div><div class="line">    &#125;</div><div class="line">    try &#123;</div><div class="line">        FileOutputStream outputStream = new FileOutputStream(file);</div><div class="line">        bitmap.compress(Bitmap.CompressFormat.JPEG, 10, outputStream);</div><div class="line">        outputStream.flush();</div><div class="line">        outputStream.close();</div><div class="line">    &#125; catch (FileNotFoundException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; catch (IOException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><div id="jump6"></div></p><h3 id="10-2-6-常见问题"><a href="#10-2-6-常见问题" class="headerlink" title="10.2.6 常见问题"></a>10.2.6 常见问题</h3><h4 id="1-对-Bitmap-的画笔设置-ANTI-ALIAS-FLAG-属性，为什么无效"><a href="#1-对-Bitmap-的画笔设置-ANTI-ALIAS-FLAG-属性，为什么无效" class="headerlink" title="1. 对 Bitmap 的画笔设置 ANTI_ALIAS_FLAG 属性，为什么无效"></a>1. 对 Bitmap 的画笔设置 ANTI_ALIAS_FLAG 属性，为什么无效</h4><p>简单来说，ANTI_ALIAS_FLAG 属性通过混合前景色与背景色来产生平滑的边缘。比如背景色是透明的，而前景色是红色的，ANTI_ALIAS_FLAG 属性通过将边缘处的像素由纯色逐步转换为透明来让边缘看起来是平滑的。</p><p>而当我们在 Bitmap 上重绘时，像素的颜色会越来越纯粹，从而导致边缘越来越粗糙。所以，可以有两种选择即可避免设置 ANTI_ALIAS_FLAG 属性无效的问题：</p><ul><li>避免重绘。</li><li>在重绘前清空 Bitmap。</li></ul><p>避免重绘的方法很简单，只需要保证让 Bitmap 只被绘制一次即可，比如将 Bitmap 绘制操作放在初始化的时候，而不要放在可能被多次调用的 onDraw()、onMeasure()、onLayout() 等函数中。</p><p>清空 Bitmap 可以参考如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private Bitmap mBitmap;</div><div class="line">private Canvas mCanvas;</div><div class="line"></div><div class="line">private void init() &#123;</div><div class="line">    mBitmap = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);</div><div class="line">    mCanvas = new Canvas(mBitmap);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line">    // 清空 Bitmap</div><div class="line">    mCanvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);</div><div class="line">    // ...</div><div class="line">    mCanvas.drawXXX();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="2-如何生成水印"><a href="#2-如何生成水印" class="headerlink" title="2. 如何生成水印"></a>2. 如何生成水印</h4><p>其实原理很简单，新生成一个 Bitmap，先后将源 Bitmap 和水印 Bitmap 画上去即可。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f8f0abbcefbe4426.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        Bitmap srcBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.meinv);</div><div class="line">        Bitmap waterBitmap = getWaterBitmap();</div><div class="line">        Bitmap bitmap = createWaterBitmap(srcBitmap, waterBitmap);</div><div class="line">        ImageView imageView = findViewById(R.id.img);</div><div class="line">        imageView.setImageBitmap(bitmap);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 添加水印</div><div class="line">     * @param srcBitmap 源图</div><div class="line">     * @param waterBitmap 水印图</div><div class="line">     * @return 添加水印的图像</div><div class="line">     */</div><div class="line">    private Bitmap createWaterBitmap(Bitmap srcBitmap, Bitmap waterBitmap) &#123;</div><div class="line">        if (srcBitmap == null) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        if (waterBitmap == null) &#123;</div><div class="line">            return srcBitmap;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int w = srcBitmap.getWidth();</div><div class="line">        int h = srcBitmap.getHeight();</div><div class="line">        int ww = waterBitmap.getWidth();</div><div class="line">        int wh = waterBitmap.getHeight();</div><div class="line"></div><div class="line">        // 创建空白图像，宽高等同 srcBitmap</div><div class="line">        Bitmap newBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);</div><div class="line">        Canvas canvas = new Canvas(newBitmap);</div><div class="line"></div><div class="line">        // 画原图，从 (0, 0) 坐标开始</div><div class="line">        canvas.drawBitmap(srcBitmap, 0, 0, null);</div><div class="line">        // 在原图的右下角画入水印</div><div class="line">        canvas.drawBitmap(waterBitmap, w - ww + 10, h - wh + 10, null);</div><div class="line">        return newBitmap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 水印</div><div class="line">     * @return Bitmap</div><div class="line">     */</div><div class="line">    private Bitmap getWaterBitmap() &#123;</div><div class="line">        return makeTextBitmap(&quot;先小涛&quot;, 200, Color.GRAY);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 将字符串转化成 bitmap</div><div class="line">     * @return Bitmap</div><div class="line">     */</div><div class="line">    private Bitmap makeTextBitmap(String text, int size, int color) &#123;</div><div class="line">        Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);</div><div class="line">        paint.setTextSize(size);</div><div class="line">        paint.setColor(color);</div><div class="line">        paint.setTextAlign(Paint.Align.LEFT);</div><div class="line"></div><div class="line">        Paint.FontMetricsInt fm = paint.getFontMetricsInt();</div><div class="line">        int width = (int) paint.measureText(text);</div><div class="line">        int height = fm.descent - fm.ascent;</div><div class="line"></div><div class="line">        Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);</div><div class="line">        Canvas canvas = new Canvas(bitmap);</div><div class="line">        canvas.drawText(text, 0, fm.leading - fm.ascent, paint);</div><div class="line">        canvas.save();</div><div class="line"></div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14186083-8204a98e80c98b99.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.1 精通自定义 View 之 Android 画布——ShapeDrawable</title>
      <link href="/2019/07/10/05%20CUSTOM%20VIEW/10.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94ShapeDrawable/"/>
      <url>/2019/07/10/05%20CUSTOM%20VIEW/10.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94ShapeDrawable/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7139f4c3b3ea0892.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p>前面，我们提到了获取画布的几种方法。除了重写系统的 onDraw()、dispatchDraw() 函数，还可以通过以下方法获得画布：</p><ul><li>通过 Bitmap 创建。</li><li>通过 SurfaceView 的 SurfaceHolder.lockCanvas() 函数获取。</li></ul><p>另外，我们也提到过通过创建 Drawable 对象，然后将画好的 Drawable 对象画在画布上，也是创建 Bitmap 的一种方式。</p><p>Drawable 类有很多的派生类，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c37778dc3d2d9332.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这些派生类都可以通过 Drawable 的 draw(Canvas canvas) 函数将其画到画布上。这里以最常用的 ShapeDrawable 为例来进行讲解。</p><p>shape 标签可以实现的效果与 ShapeDrawable 类似，但是 shape 标签所对应的 Java 类是 GradientDrawable，而不是 ShapeDrawable。使用如下代码会发生强转异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ShapeDrawable shapeDrawable = (ShapeDrawable) textView.getBackground();</div></pre></td></tr></table></figure></p><p><div id="jump1"></div></p><h3 id="10-1-1-shape-标签与-GradientDrawable"><a href="#10-1-1-shape-标签与-GradientDrawable" class="headerlink" title="10.1.1 shape 标签与 GradientDrawable"></a>10.1.1 shape 标签与 GradientDrawable</h3><h4 id="1-是-ShapeDrawable-还是-GradientDrawable"><a href="#1-是-ShapeDrawable-还是-GradientDrawable" class="headerlink" title="1. 是 ShapeDrawable 还是 GradientDrawable"></a>1. 是 ShapeDrawable 还是 GradientDrawable</h4><p>前面讲过，shape 标签所对应的类是 GradientDrawable 而不是 ShapeDrawable，但是 GradientDrawable 并不能完成 shape 标签的所有功能，因为 GradientDrawable 的构造函数如下如所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c902165bab4db480.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从构造函数中可以明显看出，GradientDrawable 所对应的是 gradient 标签的功能，并不能完成 shape 标签所能完成的构造矩形、椭圆等功能；而神奇的是，通过 ShapeDrawable 却可以完成 shape 标签的所有功能！至于造成这种问题的原因，此处不再深究，只需知道在代码中得到 shape 标签实例的时候要强转 GradientDrawable 就可以了。</p><h4 id="2-获取-shape-标签的实例"><a href="#2-获取-shape-标签的实例" class="headerlink" title="2. 获取 shape 标签的实例"></a>2. 获取 shape 标签的实例</h4><p>实现这样一个功能：在单击按钮的时候，给原有的 shape 标签添加圆角。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-cc96668581f19c89.gif?imageMogr2/auto-orient/strip" alt=""></p><p>新建 shape 文件：res/drawable/shape_solid.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</div><div class="line">    &lt;solid android:color=&quot;#FF0000&quot;/&gt;</div><div class="line">    &lt;stroke android:width=&quot;2dp&quot; android:color=&quot;#00FF00&quot;</div><div class="line">        android:dashGap=&quot;5dp&quot; android:dashWidth=&quot;5dp&quot;/&gt;</div><div class="line">&lt;/shape&gt;</div></pre></td></tr></table></figure></p><p>在布局中使用：res/layout/act_main.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/add_shape_corner&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;添加圆角&quot;/&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:id=&quot;@+id/shape_tv&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;shape 标签实例&quot;</div><div class="line">        android:padding=&quot;10dp&quot;</div><div class="line">        android:layout_margin=&quot;20dp&quot;</div><div class="line">        android:background=&quot;@drawable/shape_solid&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>动作代码：src/…/MainActivity.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        final TextView tv = findViewById(R.id.shape_tv);</div><div class="line">        findViewById(R.id.add_shape_corner).setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                GradientDrawable drawable = (GradientDrawable) tv.getBackground();</div><div class="line">                drawable.setCornerRadius(20);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><div id="jump2"></div></p><h3 id="10-1-2-ShapeDrawable-的构造函数"><a href="#10-1-2-ShapeDrawable-的构造函数" class="headerlink" title="10.1.2 ShapeDrawable 的构造函数"></a>10.1.2 ShapeDrawable 的构造函数</h3><p>ShapeDrawable 有两个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 一：无参构造函数，需配合 setShape()</div><div class="line">ShapeDrawable()</div><div class="line">setShape(Shape shape)</div><div class="line"></div><div class="line">// 二：常用</div><div class="line">ShapeDrawable(Shape shape)</div></pre></td></tr></table></figure></p><p>Shape 是个抽象基类，实际应用中需要 Shape 的派生类。Shape 类的派生类如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-757285c544048cb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>每个派生类的具体含义如下。</p><ul><li>RectShape：构造一个矩形 Shape。</li><li>ArcShape：构造一个扇形 Shape。</li><li>OvalShape：构造一个椭圆 Shape。</li><li>RoundRectShape：构造一个圆角矩形 Shape，可带有镂空矩形效果。</li><li>PathShape：构造一个可根据路径绘制的 Shape。</li></ul><h4 id="1-RectShape"><a href="#1-RectShape" class="headerlink" title="1. RectShape"></a>1. RectShape</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private ShapeDrawable mDrawable;</div><div class="line"></div><div class="line">    public TestView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mDrawable = new ShapeDrawable(new RectShape());</div><div class="line">        mDrawable.setBounds(new Rect(50, 50, 200, 100));</div><div class="line">        mDrawable.getPaint().setColor(Color.RED);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        mDrawable.draw(canvas);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用定义好的自定义控件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;</div><div class="line">    android:background=&quot;#EEE&quot;&gt;</div><div class="line">    &lt;com.xxt.xtest.TestView</div><div class="line">        android:layout_width=&quot;100dp&quot;</div><div class="line">        android:layout_height=&quot;80dp&quot;</div><div class="line">        android:layout_margin=&quot;50dp&quot;</div><div class="line">        android:background=&quot;#FFFFFF&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>效果图如下所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b8704b44fe51fd1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>为了方便显示，将整个控件设置为白色。而且为了确认 mDrawable.setBounds(new Rect(50, 50, 200, 100)); 中矩形位置是在当前控件中的位置，我们给 TestView 控件添加了 margin 值。</p><p>从效果图中可以看出：</p><ul><li>ShapeDrawable.setBounds() 函数所设置的矩形位置是指所在控件中的位置，而不是以屏幕左上角点为坐标的。</li><li>通过 mDrawable.getPaint() 函数得到 ShapeDrawable 自带的画笔，并对其进行操作，效果将直接显示在 ShapeDrawable 中。</li></ul><h4 id="2-OvalShape"><a href="#2-OvalShape" class="headerlink" title="2. OvalShape"></a>2. OvalShape</h4><p>OvalShape 是指根据 ShapeDrawable.setBounds() 函数所定义的位置矩形生成一个椭圆形状的 Shape。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private void init() &#123;</div><div class="line">    setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">    mDrawable = new ShapeDrawable(new OvalShape());</div><div class="line">    mDrawable.setBounds(new Rect(50, 50, 200, 100));</div><div class="line">    mDrawable.getPaint().setColor(Color.RED);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里的矩形位置和大小与 RectShape 中的矩形位置和大小一样，只是把 RectShape 改成了 OvalShape，效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-aaad3c55757f1a88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="3-ArcShape"><a href="#3-ArcShape" class="headerlink" title="3. ArcShape"></a>3. ArcShape</h4><p>ArcShape 是在 OvalShape 所形成的椭圆的基础上，将其进行角度切割所形成的扇形。其中扇形开始的 0° 在椭圆的 X 轴正方向上。其只有一个构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public ArcShape(float startAngle, float sweepAngle)</div></pre></td></tr></table></figure></p><ul><li>startAngle：指开始角度，扇形开始的 0° 在椭圆的 X 轴正方向上，即右中间位置。</li><li>sweepAngle：指扇形所扫过的角度。</li></ul><p>同举一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private void init() &#123;</div><div class="line">    setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">    mDrawable = new ShapeDrawable(new ArcShape(0, 300));</div><div class="line">    mDrawable.setBounds(new Rect(50, 50, 200, 100));</div><div class="line">    mDrawable.getPaint().setColor(Color.RED);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-714362acbe1e3f1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="4-RoundRectShape"><a href="#4-RoundRectShape" class="headerlink" title="4. RoundRectShape"></a>4. RoundRectShape</h4><p>RoundRectShape 在字面意思上是指圆角矩形。其实，它不仅能实现圆角矩形，它的本意是实现镂空的圆角矩形。它所能实现的效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-031438edefdc46b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>左图带有圆角的矩形，右图为中间带有镂空矩形的圆角矩形，而且中间的镂空矩形也可以带有圆角。</p><p>其构造函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public RoundRectShape(float[] outerRadii, RectF inset, float[] innerRadii)</div></pre></td></tr></table></figure></p><ul><li>float[] outerRadii：外围矩形的各个角的角度大小，需要填充 8 个数字，每两个数字一组，分别对应（左上角、右上角、右下角、左下角）4 个角的角度。每两个一组的数字构成一个椭圆，第一个数字代表椭圆的 X 轴半径，第二个数字代表椭圆的 Y 轴半径。如果不需要制定外围矩形的各个角的角度，则可以传入 null。</li><li>RectF inset：表示内部矩形与外部矩形各边的边距。RectF 的 4 个值分别对应 left、top、right、bottom 4 条边的边距。如果不需要内部矩形的镂空效果，则可以传入 null。</li><li>float[] innerRadii：表示内部矩形的各个角的角度大小，同样需要填充 8 个数字，其含义与 outerRadii 一样。如果不需要制定内部矩形的各个角的角度，则可以传入 null。</li></ul><p>同样举一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private void init() &#123;</div><div class="line">    setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">    float[] outerR = new float[] &#123; 12, 12, 12, 12, 0, 0, 0, 0 &#125;;</div><div class="line">    RectF inset = new RectF(6, 6, 6, 6);</div><div class="line">    float[] innerR = new float[] &#123; 50, 12, 0, 0, 12, 50, 0, 0 &#125;;</div><div class="line">    mDrawable = new ShapeDrawable(new RoundRectShape(outerR, inset, innerR));</div><div class="line">    mDrawable.setBounds(new Rect(50, 50, 200, 100));</div><div class="line">    mDrawable.getPaint().setColor(Color.RED);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ee6bb3c97565e75a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="5-PathShape"><a href="#5-PathShape" class="headerlink" title="5. PathShape"></a>5. PathShape</h4><p>PathShape 的含义是构造一个可根据路径绘制的 Shape。其构造函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public PathShape(Path path, float stdWidth, float stdHeight)</div></pre></td></tr></table></figure></p><ul><li>path：表示所要画的路径。</li><li>stdWidth：表示标准宽度，即将整个 ShapeDrawable 的宽度分成多少份。Path 中的 moveTo(x, y)、lineTo(x2, y2) 这些函数中的数值在这里其实都是以每一份的位置来计算的。当 ShapeDrawable 动态变大、变小时，每一份都会变大变小，而根据这些份的数值画出来的 Path 图形就会动态缩放。</li><li>stdHight：表示标准高度，即将 ShapeDrawable 的高度分成多少份。</li></ul><p>举例说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private void init() &#123;</div><div class="line">    setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">    Path path = new Path();</div><div class="line">    path.moveTo(0, 0);</div><div class="line">    path.lineTo(100, 0);</div><div class="line">    path.lineTo(100, 100);</div><div class="line">    path.lineTo(0, 100);</div><div class="line">    path.close();</div><div class="line">    mDrawable = new ShapeDrawable(new PathShape(path, 100, 100));</div><div class="line">    mDrawable.setBounds(new Rect(0, 0, 250, 150));</div><div class="line">    mDrawable.getPaint().setColor(Color.RED);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4c4e9a73aa085f11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>为了验证 PathShape 份的概念，将 ShapeDrawable 的高度和宽度都分成了100 份。现在把高度的份数改成 200，那么，同样的路径代码，画出来的效果应该是高度的一半。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private void init() &#123;</div><div class="line">    setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">    Path path = new Path();</div><div class="line">    path.moveTo(0, 0);</div><div class="line">    path.lineTo(100, 0);</div><div class="line">    path.lineTo(100, 100);</div><div class="line">    path.lineTo(0, 100);</div><div class="line">    path.close();</div><div class="line">    mDrawable = new ShapeDrawable(new PathShape(path, 100, 200));</div><div class="line">    mDrawable.setBounds(new Rect(0, 0, 250, 150));</div><div class="line">    mDrawable.getPaint().setColor(Color.RED);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-808ceb0149400e85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>与 100 份的效果图对比，果然只占了一半。</p><h4 id="6-自定义-Shape"><a href="#6-自定义-Shape" class="headerlink" title="6. 自定义 Shape"></a>6. 自定义 Shape</h4><p>各个 Shape 派生类只不过实现了 Shape 中的 draw 函数。现在自定义实现一个构造区域的 Shape，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class RegionShape extends Shape &#123;</div><div class="line">    private Region mRegion;</div><div class="line"></div><div class="line">    public RegionShape(Region region) &#123;</div><div class="line">        assert(region != null);</div><div class="line">        mRegion = region;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void draw(Canvas canvas, Paint paint) &#123;</div><div class="line">        RegionIterator iterator = new RegionIterator(mRegion);</div><div class="line">        Rect rect = new Rect();</div><div class="line">        while (iterator.next(rect)) &#123;</div><div class="line">            canvas.drawRect(rect, paint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 src/…/TestView.java 中使用 RegionShape：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private ShapeDrawable mDrawable;</div><div class="line"></div><div class="line">    public TestView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        Rect rect1 = new Rect(50, 0, 90, 150);</div><div class="line">        Rect rect2 = new Rect(0, 50, 250, 100);</div><div class="line">        Region region1 = new Region(rect1);</div><div class="line">        Region region2 = new Region(rect2);</div><div class="line">        region1.op(region2, Region.Op.XOR);</div><div class="line"></div><div class="line">        mDrawable = new ShapeDrawable(new RegionShape(region1));</div><div class="line">        mDrawable.setBounds(new Rect(0, 0, 250, 150));</div><div class="line">        mDrawable.getPaint().setColor(Color.RED);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        mDrawable.draw(canvas);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 res/layout/act_main.xml 中使用 TestView：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;</div><div class="line">    android:background=&quot;#EEE&quot;&gt;</div><div class="line">    &lt;com.xxt.xtest.TestView</div><div class="line">        android:layout_width=&quot;250px&quot;</div><div class="line">        android:layout_height=&quot;150px&quot;</div><div class="line">        android:layout_margin=&quot;50dp&quot;</div><div class="line">        android:background=&quot;#FFFFFF&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-8b8f9453ce1de7ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>由于自定义 Shape 太过麻烦，一般不这么做。当我们需要使用 ShapeDrawable 无法完成的功能时，一般会通过自定义 Drawable 来实现。见 10.1.4 节。</p><p><div id="jump3"></div></p><h3 id="10-1-3-常用函数"><a href="#10-1-3-常用函数" class="headerlink" title="10.1.3 常用函数"></a>10.1.3 常用函数</h3><h4 id="1-setBounds"><a href="#1-setBounds" class="headerlink" title="1. setBounds()"></a>1. setBounds()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">setBounds(int left, int top, int right, int bottom)</div><div class="line">setBounds(Rect bounds)</div></pre></td></tr></table></figure><p>它用来指定当前 ShapeDrawable 在当前控件中的显示位置。</p><h4 id="2-getPaint"><a href="#2-getPaint" class="headerlink" title="2. getPaint()"></a>2. getPaint()</h4><h5 id="1）概述"><a href="#1）概述" class="headerlink" title="1）概述"></a>1）概述</h5><p>通过 ShapeDrawable.getPaint() 函数得到 ShapeDrawable 的 Paint 对象，并对其进行操作，效果就会立刻显示在 ShapeDrawable 上。这也意味着可以调用 Paint 中的所有函数；在自定义 Shape 时，可以调用 Canvas 的所有绘图方法。所以，ShapeDrawable 可以调用 Paint 和 Canvas 的所有方法，实现绘图的所有功能。</p><p>需要注意的地方：当 ShapeDrawable 的 Paint 调用 Shader 时，Shader 是从 ShapeDrawable 所在区域的左上角开始绘制的。</p><h5 id="2）Paint-setShader"><a href="#2）Paint-setShader" class="headerlink" title="2）Paint.setShader()"></a>2）Paint.setShader()</h5><p>下面举一个例子来证明我们的观点：Shader 是从 ShapeDrawable 所在区域的左上角开始绘制的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private ShapeDrawable mDrawable;</div><div class="line"></div><div class="line">    public TestView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mDrawable = new ShapeDrawable(new RectShape());</div><div class="line">        mDrawable.setBounds(new Rect(100, 100, 500, 500));</div><div class="line">        BitmapFactory.Options options = new BitmapFactory.Options();</div><div class="line">        options.inSampleSize = 2;</div><div class="line">        Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.head, options);</div><div class="line">        BitmapShader bitmapShader = new BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);</div><div class="line">        mDrawable.getPaint().setShader(bitmapShader);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        mDrawable.draw(canvas);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ef1d22e2930e7bee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从效果图中可以看出，头像是在 TestView 控件的 Rect(100, 100, 500, 500) 位置绘制的，并不是从 TestView 的左上角开始绘制的，也不是从屏幕左上角开始绘制的。</p><h4 id="3-其他函数"><a href="#3-其他函数" class="headerlink" title="3. 其他函数"></a>3. 其他函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 设置透明度</div><div class="line">setAlpha(int alpha)</div><div class="line"></div><div class="line">// 设置 ColorFilter，是 ShapeDrawable 自带的函数</div><div class="line">setColorFilter(ColorFilter colorFilter)</div><div class="line"></div><div class="line">// 设置默认高度。当 Drawable 以 setBackgroundDrawable 及 setImageDrawable </div><div class="line">// 方式使用时，会使用默认宽度和高度来计算当前 Drawable 的大小和位置。</div><div class="line">// 如果不设置，则默认的宽高都是 -1px。详情请参考 10.1.4 节。</div><div class="line">setIntrinsicHeight(int height)</div><div class="line">// 设置默认宽度</div><div class="line">setIntrinsicWidth(int width)</div><div class="line"></div><div class="line">// 设置边距</div><div class="line">setPadding(Rect padding)</div></pre></td></tr></table></figure><h4 id="4-放大镜效果"><a href="#4-放大镜效果" class="headerlink" title="4. 放大镜效果"></a>4. 放大镜效果</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-dd9f0e3494d2c3f8.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private static final int RADIUS = 200;      // 放大镜的半径</div><div class="line">    private static final int FACTOR = 3;        // 放大倍数</div><div class="line"></div><div class="line">    private ShapeDrawable mDrawable;</div><div class="line">    private Bitmap mBitmap;</div><div class="line">    private final Matrix mMatrix = new Matrix();</div><div class="line"></div><div class="line">    public TestView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        final int x = (int) event.getX();</div><div class="line">        final int y = (int) event.getY();</div><div class="line">        // 这个位置表示的是绘制 Shader 的起始位置</div><div class="line">        mMatrix.setTranslate(RADIUS - x * FACTOR, RADIUS - y * FACTOR);</div><div class="line">        mDrawable.getPaint().getShader().setLocalMatrix(mMatrix);</div><div class="line"></div><div class="line">        mDrawable.setBounds(x - RADIUS, y - RADIUS, x + RADIUS, y + RADIUS);</div><div class="line">        invalidate();</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        if (mBitmap == null) &#123;</div><div class="line">            Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.meinv);</div><div class="line">            mBitmap = Bitmap.createScaledBitmap(bmp, getWidth(), getHeight(), false);</div><div class="line">            Bitmap tempBmp = Bitmap.createScaledBitmap(mBitmap, mBitmap.getWidth() * FACTOR,</div><div class="line">                    mBitmap.getHeight() * FACTOR, true);</div><div class="line">            BitmapShader shader = new BitmapShader(tempBmp, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);</div><div class="line">            mDrawable = new ShapeDrawable(new OvalShape());</div><div class="line">            mDrawable.getPaint().setShader(shader);</div><div class="line">            mDrawable.setBounds(0, 0, RADIUS * 2, RADIUS * 2);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        canvas.drawBitmap(mBitmap, 0, 0, null);</div><div class="line">        mDrawable.draw(canvas);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>说明：</p><h5 id="1）onDraw-函数部分"><a href="#1）onDraw-函数部分" class="headerlink" title="1）onDraw() 函数部分"></a>1）onDraw() 函数部分</h5><p>之所以将初始化代码放在 onDraw() 函数中，是因为我们需要把图片缩放到控件大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.meinv);</div><div class="line">mBitmap = Bitmap.createScaledBitmap(bmp, getWidth(), getHeight(), false);</div></pre></td></tr></table></figure></p><p>Bitmap.createScaledBitmap() 函数根据源图像生成一个指定宽度和高度的 Bitmap，这里就是指根据 bmp 创建一幅与当前控件同宽同高的图像，也就是将源图像缩放到当前控件的大小。</p><p>而 getWidth()、getHeight() 函数只有在调用 onLayout() 函数以后，这两个函数才能取到值的。</p><p>接下来创建 ShapeDrawable。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mDrawable = new ShapeDrawable(new OvalShape());</div><div class="line">mDrawable.setBounds(0, 0, RADIUS * 2, RADIUS * 2);</div></pre></td></tr></table></figure></p><p>这里创建一个椭圆形的 ShapeDrawable，而形成椭圆的矩形的宽高都是 RADIUS * 2，所以所形成的图形必然是一个圆形，且半径为 RADIUS。</p><p>最后是设置 BitmapShader 的过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Bitmap tempBmp = Bitmap.createScaledBitmap(mBitmap, </div><div class="line">        mBitmap.getWidth() * FACTOR, mBitmap.getHeight() * FACTOR, true);</div><div class="line">BitmapShader shader = new BitmapShader(tempBmp, Shader.TileMode.CLAMP, </div><div class="line">        Shader.TileMode.CLAMP);</div><div class="line">mDrawable.getPaint().setShader(shader);</div></pre></td></tr></table></figure></p><p>同样使用 Bitmap.createScaledBitmap() 函数创建一张放大 3 倍的图片。</p><h5 id="2）onTouchEvent-函数部分"><a href="#2）onTouchEvent-函数部分" class="headerlink" title="2）onTouchEvent() 函数部分"></a>2）onTouchEvent() 函数部分</h5><p>当手指有动作的时候，我们应当改变当前 ShapeDrawable 的显示位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mDrawable.setBounds(x - RADIUS, y - RADIUS, x + RADIUS, y + RADIUS);</div></pre></td></tr></table></figure></p><p>即以当前手指位置为中心，画一个圆。</p><p>最关键的是 Shader 如何移动到我们要显示的位置。我们讲过，Shader 的开始显示位置在 ShapeDrawable 的左上角。所以，如果我们不移动 Shape，那么显示出来的永远是图片的左上角部分。那如何将 Shader 移动到图片的对应点呢？</p><p>我们需要先找到当前手指位置放大 3 倍的图片上的对应点，然后以这个对应点为中心显示出半径为 RADIUS 的圆中的图形。</p><p>当前手指的位置是 (x, y)，那么放大 3 倍的图片上的对应点就是 (3x, 3y)。为了显示以放大 3 倍后的手指位置为中心的圆形区域，BitmapShader 需要向左和向上各移动多少呢？</p><p>首先，Shader 是从 ShapeDrawable 的左上角开始平铺的。也就是说，在初始状态下，ShapeDrawable 区域左上角一直显示的是 BitmapShader 的左上角(0, 0) 位置。我们在这里需要把 BitmapShader 向左上移动一段距离，以使 BitmapShader 中原来的 (3x, 3y) 点在 ShapeDrawable 区域中心。</p><p>第一步：我们可以将整个 BitmapShader 向左上移动 3x, 3y 的距离。由于在移动时，向右和向下是正值，所以左上移动的距离是 (-3x, -3y)，而移动后的 BitmapShader 左上角显示的是 (3x, 3y) 处的图像。</p><p>第二步：我们需要将左上角点显示的 (3x, 3y) 处的图像显示在 ShapeDrawable 区域中心，所以需要将原本在左上角 (3x, 3y) 点在向右下移动一个半径的距离。所以总移动的距离为 (-3x+RADIUS, -3y + RADIUS)。</p><p>即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mMatrix.setTranslate(RADIUS - x * FACTOR, RADIUS - y * FACTOR);</div><div class="line">mDrawable.getPaint().getShader().setLocalMatrix(mMatrix);</div></pre></td></tr></table></figure></p><p><div id="jump4"></div></p><h3 id="10-1-4-自定义-Drawable"><a href="#10-1-4-自定义-Drawable" class="headerlink" title="10.1.4 自定义 Drawable"></a>10.1.4 自定义 Drawable</h3><p>在 Drawable 的子类无法通过已有的函数完成指定的绘图功能时，一般会选择自定义 Drawable 来实现。本节将通过自定义 Drawable 来实现圆角功能。</p><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>我们写一个类，继承自 Drawable，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class TestDrawable extends Drawable &#123;</div><div class="line">    @Override</div><div class="line">    public void draw(@NonNull Canvas canvas) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void setAlpha(int alpha) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void setColorFilter(@Nullable ColorFilter colorFilter) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int getOpacity() &#123;</div><div class="line">        return PixelFormat.TRANSLUCENT;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这 4 个函数时 Drawable 类里的虚函数，是必须实现的。</p><ul><li>draw() 函数是我们将会用到的，与 View 类似，传入的参数是一个 Canvas 对象，我们只需要调用 Canvas 的一些地方，效果就会直接显示在 Drawable 上。</li><li>setAlpha() 和 setColorFilter() 函数是非常容易实现的。当外层调用 TestDrawable 的这两个函数时，我们只需将对应的参数传给 TestDrawable 的 Paint 即可。</li><li>getOpacity()：当外部需要知道我们自定义的 TestDrawable 的显示模式时会调用这个函数。它有 4 个取值：PixelFormat.UNKNOWN，TRANSLUCENT，TRANSPARENT，OPAQUE。其中，PixelFormat.TRANSLUCENT 表示当前 TestDrawable 的绘图是具有 Alpha 通道的，即使用 TestDrawable 后，其底部的图像仍有可能看到；PixelFormat.TRANSPARENT 表示当前 TestDrawable 是完全透明的，其中什么都没画，如果使用 TestDrawable，则将完全显示其底部图像；PixelFormat.OPAQUE 表示当前的 TestDrawable 是完全没有 Alpha 通道的，使用 TestDrawable 后，其底部的图像将被完全覆盖，而只显示 TestDrawable 本身的图像；PixelFormat.UNKNOWN 表示未知。一般而言，如果我们不知道该如何返回，则直接返回 PixelFormat.TRANSLUCENT 是最靠谱的做法。</li></ul><h4 id="2-实现圆角-Drawable"><a href="#2-实现圆角-Drawable" class="headerlink" title="2. 实现圆角 Drawable"></a>2. 实现圆角 Drawable</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">public class TestDrawable extends Drawable &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap mBitmap;</div><div class="line">    private BitmapShader mBitmapShader;</div><div class="line">    private RectF mBound;</div><div class="line"></div><div class="line">    public TestDrawable(Bitmap bitmap) &#123;</div><div class="line">        mBitmap = bitmap;</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setAntiAlias(true);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void draw(@NonNull Canvas canvas) &#123;</div><div class="line">        canvas.drawRoundRect(mBound, 20, 20, mPaint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void setAlpha(int alpha) &#123;</div><div class="line">        mPaint.setAlpha(alpha);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void setColorFilter(@Nullable ColorFilter colorFilter) &#123;</div><div class="line">        mPaint.setColorFilter(colorFilter);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int getOpacity() &#123;</div><div class="line">        // 是否具有透明度是由传入的 Bitmap 所决定的。</div><div class="line">        return PixelFormat.TRANSLUCENT;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 根据边界创建一个与 Drawable 相同大小的 Bitmap 作为 Drawable 的 Shader</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void setBounds(int left, int top, int right, int bottom) &#123;</div><div class="line">        super.setBounds(left, top, right, bottom);</div><div class="line"></div><div class="line">        mBitmapShader = new BitmapShader(</div><div class="line">                Bitmap.createScaledBitmap(mBitmap, right - left, bottom - top, true),</div><div class="line">                Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);</div><div class="line">        mPaint.setShader(mBitmapShader);</div><div class="line">        mBound = new RectF(left, top, right, bottom);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 设置 TestDrawable 的默认宽度</div><div class="line">     * @return int</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public int getIntrinsicWidth() &#123;</div><div class="line">        return mBitmap.getWidth();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 设置 TestDrawable 的默认高度</div><div class="line">     * @return int</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public int getIntrinsicHeight() &#123;</div><div class="line">        return mBitmap.getHeight();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3-Drawable-的使用方法"><a href="#3-Drawable-的使用方法" class="headerlink" title="3. Drawable 的使用方法"></a>3. Drawable 的使用方法</h4><p>一般有两种使用方法：一种是通过 ImageView 的 setImageDrawable(drawable) 函数将其设置为 ImageView 的源图片；另一种是通过 View 的 setBackgroundDrawable(drawable) 函数将其设置为背景。</p><h5 id="1）setImageDrawable-drawable-函数"><a href="#1）setImageDrawable-drawable-函数" class="headerlink" title="1）setImageDrawable(drawable) 函数"></a>1）setImageDrawable(drawable) 函数</h5><p>先在布局中定义一个 ImageView 标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;ImageView</div><div class="line">    android:id=&quot;@+id/img&quot;</div><div class="line">    android:layout_width=&quot;100dp&quot;</div><div class="line">    android:layout_height=&quot;50dp&quot;</div><div class="line">    android:layout_margin=&quot;10dp&quot;</div><div class="line">    android:background=&quot;#FFFFFF&quot;</div><div class="line">    android:scaleType=&quot;center&quot;/&gt;</div></pre></td></tr></table></figure></p><p>在代码中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.head);</div><div class="line">        ImageView imageView = findViewById(R.id.img);</div><div class="line">        TestDrawable drawable = new TestDrawable(bitmap);</div><div class="line">        imageView.setImageDrawable(drawable);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2f8eb2e0056cb6b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到，我们虽然在 TestDrawable 的 setBounds() 函数中将 Bitmap 缩放为整个边界大小，但是并没有覆盖整个 Bitmap，这是为什么呢？</p><p>在这里，我们使用 setImageDrawable(drawable) 函数来设置数据源，而源图片的显示大小是与 ImageView 的 scaleType 相关的。因为这里设置 scaleType=”center”，所以 ImageView 必然会居中缩放图片，然后将图片的显示位置通过 setBounds() 函数设置给 TestDrawable。下图展示了当前 Drawable 在不同的 scaleType 模式下的效果图。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-59955a6e7c542f66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>布局如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;</div><div class="line">    android:background=&quot;#EEE&quot;&gt;</div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;&gt;</div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/img&quot;</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;50dp&quot;</div><div class="line">            android:layout_margin=&quot;10dp&quot;</div><div class="line">            android:background=&quot;#FFFFFF&quot;</div><div class="line">            android:scaleType=&quot;fitStart&quot;/&gt;</div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/img2&quot;</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;50dp&quot;</div><div class="line">            android:layout_margin=&quot;10dp&quot;</div><div class="line">            android:background=&quot;#FFFFFF&quot;</div><div class="line">            android:scaleType=&quot;fitCenter&quot;/&gt;</div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/img3&quot;</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;50dp&quot;</div><div class="line">            android:layout_margin=&quot;10dp&quot;</div><div class="line">            android:background=&quot;#FFFFFF&quot;</div><div class="line">            android:scaleType=&quot;fitEnd&quot;/&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;&gt;</div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/img4&quot;</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;50dp&quot;</div><div class="line">            android:layout_margin=&quot;10dp&quot;</div><div class="line">            android:background=&quot;#FFFFFF&quot;</div><div class="line">            android:scaleType=&quot;centerInside&quot;/&gt;</div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/img5&quot;</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;50dp&quot;</div><div class="line">            android:layout_margin=&quot;10dp&quot;</div><div class="line">            android:background=&quot;#FFFFFF&quot;</div><div class="line">            android:scaleType=&quot;centerCrop&quot;/&gt;</div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/img6&quot;</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;50dp&quot;</div><div class="line">            android:layout_margin=&quot;10dp&quot;</div><div class="line">            android:background=&quot;#FFFFFF&quot;</div><div class="line">            android:scaleType=&quot;center&quot;/&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/img7&quot;</div><div class="line">        android:layout_width=&quot;100dp&quot;</div><div class="line">        android:layout_height=&quot;50dp&quot;</div><div class="line">        android:layout_margin=&quot;10dp&quot;</div><div class="line">        android:background=&quot;#FFFFFF&quot;</div><div class="line">        android:scaleType=&quot;fitXY&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><h5 id="2）setBackgroundDrawable-drawable-函数"><a href="#2）setBackgroundDrawable-drawable-函数" class="headerlink" title="2）setBackgroundDrawable(drawable) 函数"></a>2）setBackgroundDrawable(drawable) 函数</h5><p>布局：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;TextView</div><div class="line">    android:id=&quot;@+id/tv&quot;</div><div class="line">    android:layout_width=&quot;wrap_content&quot;</div><div class="line">    android:layout_height=&quot;wrap_content&quot;</div><div class="line">    android:layout_margin=&quot;10dp&quot;</div><div class="line">    android:text=&quot;欢迎光临先先生的 blog&quot;</div><div class="line">    android:textColor=&quot;#FF0000&quot;/&gt;</div></pre></td></tr></table></figure></p><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.head);</div><div class="line">TestDrawable drawable = new TestDrawable(bitmap);</div><div class="line">TextView tv = findViewById(R.id.tv);</div><div class="line">tv.setBackgroundDrawable(drawable);</div></pre></td></tr></table></figure></p><p>效果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-27b56dc51d2daac6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从效果图中可以看出，宽度使用的是 TextView 的宽度，而高度则使用的是 TestDrawable 的默认高度。之所以会出现这样的效果，是因为在使用 setBackgroundDrawable() 函数设置自定义 Drawable 时，自定义 Drawable 的宽度和高度计算是将 View 的宽、高和自定义 Drawable 的宽、高进行对比，哪个值大就用哪个值作为控件的宽、高的。而这个最终值就会通过 setBounds() 函数传递给自定义 Drawable。</p><h4 id="4-自定义-Drawable-与自定义-View-的区别"><a href="#4-自定义-Drawable-与自定义-View-的区别" class="headerlink" title="4. 自定义 Drawable 与自定义 View 的区别"></a>4. 自定义 Drawable 与自定义 View 的区别</h4><p>自定义 Drawable 的使用场景很明确，要么使用在可以设置 Drawable 的函数中（比如 setImageDrawable() 等），要么替代 Bitmap 用于 View 中（比如放大镜效果）。</p><p>而自定义 View 的功能十分强大，自定义 Drawable 和 Bitmap 无法完成的功能可以使用自定义 View 来完成。</p><p><div id="jump5"></div></p><h3 id="10-1-5-Drawable-与-Bitmap-的对比"><a href="#10-1-5-Drawable-与-Bitmap-的对比" class="headerlink" title="10.1.5 Drawable 与 Bitmap 的对比"></a>10.1.5 Drawable 与 Bitmap 的对比</h3><h4 id="1-定义对比"><a href="#1-定义对比" class="headerlink" title="1. 定义对比"></a>1. 定义对比</h4><p>Bitmap 称作位图，一般位图的文件格式扩展名为 .bmp，当然编码器也有很多，如 RGB565、RGB8888。作为一种逐像素的显示对象，其执行效率高；但存储效率低。</p><p>Drawable 作为 Android 下通用的图形对象，它可以装载常用格式的图像，比如 GIF、PNG、JPG 和 BMP，还提供了一些高级的可视化对象，比如渐变、图形等。</p><p>也就是说，Bitmap 是 Drawable，而 Drawable 不一定是 Bitmap。</p><h4 id="2-指标对比"><a href="#2-指标对比" class="headerlink" title="2. 指标对比"></a>2. 指标对比</h4><div class="table-container"><table><thead><tr><th style="text-align:left">对比项</th><th style="text-align:left">显示清晰度</th><th style="text-align:left">占用内存</th><th style="text-align:left">支持缩放</th><th style="text-align:left">支持色相色差调整</th><th style="text-align:left">支持旋转</th><th style="text-align:left">支持透明色</th><th style="text-align:left">绘制速度</th><th style="text-align:left">支持像素操作</th></tr></thead><tbody><tr><td style="text-align:left">Bitmap</td><td style="text-align:left">相同</td><td style="text-align:left">大</td><td style="text-align:left">是</td><td style="text-align:left">是</td><td style="text-align:left">是</td><td style="text-align:left">是</td><td style="text-align:left">慢</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">Drawable</td><td style="text-align:left">相同</td><td style="text-align:left">小</td><td style="text-align:left">是</td><td style="text-align:left">否</td><td style="text-align:left">是</td><td style="text-align:left">是</td><td style="text-align:left">快</td><td style="text-align:left">否</td></tr></tbody></table></div><h4 id="3-绘图便利性对比"><a href="#3-绘图便利性对比" class="headerlink" title="3. 绘图便利性对比"></a>3. 绘图便利性对比</h4><p>Drawable 有很多派生类，通过这些派生类可以很容易地生成渐变、层叠等效果。单从这一方面而言，Drawable 比 Bitmap 有优势。</p><p>但如果仅仅用作空白画布来绘图，那么 Drawable 构造和使用起来则不如 Bitmap 方便。</p><h4 id="4-使用简易性对比"><a href="#4-使用简易性对比" class="headerlink" title="4. 使用简易性对比"></a>4. 使用简易性对比</h4><p>Drawable 子类是自带画笔，调用 Paint 的函数很方便。但使用 Canvas 的函数并不方便，所以 Drawable 的子类一般只用来完成它固有的功能。如果想要使用 Drawable 绘图，则建议自定义 Drawable。</p><p>而如果想在 Bitmap 上作画，则一般使用类似如下的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Canvas canvas = new Canvas(bitmap);</div><div class="line">Paint paint = new Paint();</div><div class="line">paint.setColor(Color.RED);</div><div class="line">canvas.drawCircle(0, 0, 100, paint);</div></pre></td></tr></table></figure></p><p>从代码中可以看到，如果 Bitmap 想要作为画布，则需要通过 Canvas canvas = new Canvas(bitmap); 来创建 Canvas 对象，而通过生成的 Canvas 对象，所绘制的内容是直接画在 Bitmap 上的。而且画笔也是可以随意定义的。</p><p>所以，就使用简易性而言，Bitmap 确实要比 Drawable 易用。</p><h4 id="5-使用方式对比"><a href="#5-使用方式对比" class="headerlink" title="5. 使用方式对比"></a>5. 使用方式对比</h4><p>Bitmap 主要靠在 View 中通过 Canvas.drawBitmap() 函数画出来；而 Drawable 不仅能在 View 中通过 Drawable.draw(Canvas canvas) 函数画出来，也可以通过 setImageBackground()、setBackgroundDrawable() 等设置 Drawable 资源的函数来设置。</p><p>总结：</p><ul><li>Bitmap 在占用内存和绘制速度上不如 Drawable 有优势。</li><li>Bitmap 绘图方便。</li><li>Drawable 有一些子类，可以方便地完成一些绘图功能。</li></ul><p>那么，Drawable、Bitmap、自定义 View 在哪些情况下使用呢？</p><ul><li>Bitmap 只在一种情况下使用，即在 View 中需要自己生成图像时，才会使用 Bitmap 绘图。绘图后的结果保存在这个 Bitmap 中，供自己定义 View 使用。比如根据源 Bitmap 生成它的倒影，在使用 Xfermode 来融合倒转的图片原图与渐变的图片时，就需要根据图片大小生成一张同样大小的渐变图片，这时必须使用 Bitmap。</li><li>当使用 Drawable 的子类完成一些固有功能时，优先选用 Drawable。</li><li>当需要使用 setImageDrawable()、setBackgroundDrawable() 等可以直接设置 Drawable 资源的函数时，只能选用 Drawable。</li><li>在自定义 View 中指定位置显示图形功能时，既可以使用 Drawable，也可以使用 Bitmap。</li><li>除 Drawable 和 Bitmap 以外的地方，都可以使用自定义 View 来实现。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/14186083-086f3f173b766d6e.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09.4 精通自定义 View 之 Canvas 与图层——恢复画布</title>
      <link href="/2019/07/09/05%20CUSTOM%20VIEW/09.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E6%81%A2%E5%A4%8D%E7%94%BB%E5%B8%83/"/>
      <url>/2019/07/09/05%20CUSTOM%20VIEW/09.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E6%81%A2%E5%A4%8D%E7%94%BB%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a64222a38cc6aa33.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p>恢复画布有两个函数：restore() 和 restoreToCount(int count)。<br>其中，restore() 函数的作用就是把回退栈中的最上层画布状态出栈，恢复画布状态。在 1.5.2 节中已经详细地说明了 restore() 函数的用法，这里就不再赘述了。</p><p><div id="jump1"></div></p><h3 id="9-4-1-restoreToCount-int-count"><a href="#9-4-1-restoreToCount-int-count" class="headerlink" title="9.4.1 restoreToCount(int count)"></a>9.4.1 restoreToCount(int count)</h3><p>在 save()、saveLayer()、saveLayerAlpha() 函数保存画布后，都会返回一个 ID 值，这个 ID 值表示当前保存的画布信息的栈层索引（从 0 开始）。比如，保存在第三层，则返回 2。</p><p>而 restoreToCount() 函数的声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void restoreToCount(int saveCount);</div></pre></td></tr></table></figure></p><p>它表示一直退栈，一直把指定索引的画布信息退出来，之后的栈最上层的画布信息将作为最新的画布。比如，我们开始的栈已经有两层，然后调用如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int id = canvas.saveLayer(0, 0, etWidth(), getHeight(), mPaint, </div><div class="line">                          Canvas.ALL_SAVE_FLAG);</div><div class="line">canvas.restoreToCount(id);</div></pre></td></tr></table></figure></p><p>调用 canvas.saveLayer() 函数后，新保存的画布放在了第三层，返回的 ID 的值是对应的索引，即 2。而 canvas.restoreToCount(id); 则表示一直退栈，直到把索引为 2 的栈层给退出去，留下来的栈顶层信息将作为最新的画布。</p><p>下面我们举个例子来看下。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private String TAG = &quot;XIAN&quot;;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint = new Paint();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        int id1 = canvas.save();</div><div class="line">        canvas.clipRect(0, 0, 800, 800);</div><div class="line">        canvas.drawColor(Color.RED);</div><div class="line">        Log.d(TAG, &quot;count:&quot; + canvas.getSaveCount() + &quot; id1:&quot; + id1);</div><div class="line"></div><div class="line">        int id2 = canvas.saveLayer(0, 0, getWidth(), getHeight(), mPaint, Canvas.ALL_SAVE_FLAG);</div><div class="line">        canvas.clipRect(100, 100, 700, 700);</div><div class="line">        canvas.drawColor(Color.GREEN);</div><div class="line">        Log.d(TAG, &quot;count:&quot; + canvas.getSaveCount() + &quot; id2:&quot; + id2);</div><div class="line"></div><div class="line">        int id3 = canvas.saveLayerAlpha(0, 0, getWidth(), getHeight(), 0xF0, Canvas.ALL_SAVE_FLAG);</div><div class="line">        canvas.clipRect(200, 200, 600, 600);</div><div class="line">        canvas.drawColor(Color.YELLOW);</div><div class="line">        Log.d(TAG, &quot;count:&quot; + canvas.getSaveCount() + &quot; id3:&quot; + id3);</div><div class="line"></div><div class="line">        int id4 = canvas.save();</div><div class="line">        canvas.clipRect(300, 300, 500, 500);</div><div class="line">        canvas.drawColor(Color.BLUE);</div><div class="line">        Log.d(TAG, &quot;count:&quot; + canvas.getSaveCount() + &quot; id4:&quot; + id4);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 onDraw() 函数中，连续对 Canvas 进行裁剪，并且在裁剪后在当前画布上涂一层不同的颜色，然后把当前栈的层数和最高层的索引打印出来。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f5f4fed3a09cabcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-93bbe705a86d91d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="日志"></p><p>在整段代码的最后添加 canvas.restoreToCount(id3);，然后把整块画布涂成灰色。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line"></div><div class="line">    ...</div><div class="line">    </div><div class="line">    canvas.restoreToCount(id3);</div><div class="line">    canvas.drawColor(Color.GRAY);</div><div class="line">    Log.d(TAG, &quot;count:&quot; + canvas.getSaveCount());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4d6ecaa4ee57352e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b94b23b3f3123f89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="日志"></p><p>从代码中可以看出，在调用 canvas.restoreToCount(id3) 函数后，将恢复到生成 id3 之前的画布状态，即是 (100, 100, 700, 700)。</p><p><div id="jump2"></div></p><h3 id="9-4-2-restore-和-restoreToCount-int-count-的关系"><a href="#9-4-2-restore-和-restoreToCount-int-count-的关系" class="headerlink" title="9.4.2 restore() 和 restoreToCount(int count) 的关系"></a>9.4.2 restore() 和 restoreToCount(int count) 的关系</h3><p>这两个函数针对的是同一个栈，所以完全可以通用。不同的是，restore() 函数默认将栈顶内容退出还原画布；而 restoreToCount(int count) 函数则是一直退栈，直到把指定索引的画布信息退出来，之后的栈最上层的画布信息将作为最新的画布。</p><p>结论：</p><ul><li>restore() 的含义是把回退栈中的最上层画布状态出栈，恢复画布状态。restoreToCount(int count) 的含义是一直退栈，直到把指定索引的画布信息退出来，将此之前的所有动作都恢复。</li><li>无论哪种 save 函数、哪个 FLAG，保存画布时使用的都是同一个栈。</li><li>restore() 与 restoreToCount(int count) 针对的都是同一个栈，所以完全可以通用。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/14186083-37fa8511d6ce5f76.gif?imageMogr2/auto-orient/strip" alt="男人喜欢球.gif"></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09.3 精通自定义 View 之 Canvas 与图层——Flag 的具体含义</title>
      <link href="/2019/07/09/05%20CUSTOM%20VIEW/09.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94Flag%20%E7%9A%84%E5%85%B7%E4%BD%93%E5%90%AB%E4%B9%89/"/>
      <url>/2019/07/09/05%20CUSTOM%20VIEW/09.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94Flag%20%E7%9A%84%E5%85%B7%E4%BD%93%E5%90%AB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p>在 Canvas 中有如下几个 save 系列函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public int save()</div><div class="line">public int save(int saveFlags)</div><div class="line">public int saveLayer(RectF bounds, Paint paint, int saveFlags)</div><div class="line">public int saveLayer(float left, float top, float right, float bottom,Paint paint, int saveFlags)</div><div class="line">public int saveLayerAlpha(RectF bounds, int alpha, int saveFlags)</div><div class="line">public int saveLayerAlpha(float left, float top, float right, float bottom,int alpha, int saveFlags)</div></pre></td></tr></table></figure></p><p>可以看到，flag 参数在诸多函数中都有使用，这里我们先关注 save 的两个构造函数和 saveLayer 的两个构造函数。我们知道，二者的不同之处在于，saveLayer() 函数会新建一块画布，而 save() 函数则不会新建画布。它们都具有 Flag（标识），这些 Flag（标识）的含义和适用范围如下表所示。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Flag</th><th style="text-align:left">含义</th><th style="text-align:left">适用范围</th></tr></thead><tbody><tr><td style="text-align:left">ALL_SAVE_FLAG</td><td style="text-align:left">保存所有的标识</td><td style="text-align:left">save()、saveLayer()</td></tr><tr><td style="text-align:left">MATRIX_SAVE_FLAG</td><td style="text-align:left">仅保存 Canvas 的 matrix 数组</td><td style="text-align:left">save()、saveLayer()</td></tr><tr><td style="text-align:left">CLIP_SAVE_FLAG</td><td style="text-align:left">仅保存 Canvas 的当前大小</td><td style="text-align:left">save()、saveLayer()</td></tr><tr><td style="text-align:left">HAS_ALPHA_LAYER_SAVE_FLAG</td><td style="text-align:left">标识新建的 bmp 具有透明度，在与上层画布结合时，透明位置显示上图图像,与 FULL_COLOR_LAYER_SAVE_FLAG 冲突，若同时指定，则以 HAS_ALPHA_LAYER_SAVE_FLAG 为主</td><td style="text-align:left">saveLayer()</td></tr><tr><td style="text-align:left">FULL_COLOR_LAYER_SAVE_FLAG</td><td style="text-align:left">标识新建的 bmp 颜色完全独立，在与上层画布结合时，先清空上层画布再覆盖上去</td><td style="text-align:left">saveLayer()</td></tr><tr><td style="text-align:left">CLIP_TO_LAYER_SAVE_FLAG</td><td style="text-align:left">在保存图层前先把当前画布根据 bounds 裁剪，与 CLIP_SAVE_FLAG 冲突，若同时指定，则以 CLIP_SAVE_FLAG为主</td><td style="text-align:left">saveLayer()</td></tr></tbody></table></div><p>从上面的表格中可以看到，ALL_SAVE_FLAG、MATRIX_SAVE_FLAG、CLIP_SAVE_FLAG 是 save()、saveLayer() 函数共用的。而另外三个 Flag 是 saveLayer() 函数专用的。</p><p>我们逐个解析下它们的不同之处。在讲解之前，先考虑一下：如果让我们保存一块画布的状态，以便恢复，则需要保存哪些内容呢？</p><p>第一个是位置信息，第二个是大小信息，好像除此之外也没什么了。位置信息对应的是 MATRIX_SAVE_FLAG，大小信息对应的是 CLIP_SAVE_FLAG，这是 save() 和 saveLayer() 函数所共用的标识。而 saveLayer() 函数专用的三个标识用于指定 saveLayer() 函数新建的画布具有哪种特性，而不是保存画布的范畴。</p><h4 id="注意：以上内容已过时，这些标志已在-API-28-中删除。带有-Flag-的构造函数在-API-26-被标为已过时，不建议使用。且新的不带-Flag-参数的构造函数默认指定标识为-ALL-SAVE-FLAG。详情请参见此处。"><a href="#注意：以上内容已过时，这些标志已在-API-28-中删除。带有-Flag-的构造函数在-API-26-被标为已过时，不建议使用。且新的不带-Flag-参数的构造函数默认指定标识为-ALL-SAVE-FLAG。详情请参见此处。" class="headerlink" title="注意：以上内容已过时，这些标志已在 API 28 中删除。带有 Flag 的构造函数在 API 26 被标为已过时，不建议使用。且新的不带 Flag 参数的构造函数默认指定标识为 ALL_SAVE_FLAG。详情请参见此处。"></a>注意：以上内容已过时，这些标志已在 API 28 中删除。带有 Flag 的构造函数在 API 26 被标为已过时，不建议使用。且新的不带 Flag 参数的构造函数默认指定标识为 ALL_SAVE_FLAG。<a href="https://developer.android.google.cn/reference/android/graphics/Canvas" target="_blank" rel="external">详情请参见此处</a>。</h4>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09.2 精通自定义 View 之 Canvas 与图层——图层与画布</title>
      <link href="/2019/07/09/05%20CUSTOM%20VIEW/09.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E5%9B%BE%E5%B1%82%E4%B8%8E%E7%94%BB%E5%B8%83/"/>
      <url>/2019/07/09/05%20CUSTOM%20VIEW/09.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E5%9B%BE%E5%B1%82%E4%B8%8E%E7%94%BB%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-babf897bd2fc4a04.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p>前面讲过 Canvas 的 save() 和 restore() 函数，除这两个函数以外，还有其他一些函数来保存和恢复画布状态。</p><p><div id="jump1"></div></p><h3 id="9-2-1-saveLayer-函数"><a href="#9-2-1-saveLayer-函数" class="headerlink" title="9.2.1 saveLayer() 函数"></a>9.2.1 saveLayer() 函数</h3><p>saveLayer 有两个构造函数，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 保存指定矩形区域的canvas内容</div><div class="line"> */</div><div class="line">public int saveLayer(RectF bounds, Paint paint, int saveFlags)</div><div class="line">public int saveLayer(float left, float top, float right, float bottom,</div><div class="line">                     Paint paint, int saveFlags)</div></pre></td></tr></table></figure></p><p>参数：</p><ul><li>RectF bounds：要保存的区域所对应的矩形对象。</li><li>int saveFlags：取值有 ALL_SAVE_FLAG、MATRIX_SAVE_FLAG、CLIP_SAVE_FLAG、HAS_ALPHA_LAYER_SAVE_FLAG、FULL_COLOR_LAYER_SAVE_FLAG、 和<br>CLIP_TO_LAYER_SAVE_FLAG，其中 ALL_SAVE_FLAG 表示保存全部内容，这些标识的具体意义我们后面会具体讲。</li></ul><p>第二个构造函数实际与第一个是一样的，只不过它是根据 4 个点来构造一个矩形。下面以 Xfermode 为例，来看看 saveLayer() 函数都做了什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap dstBmp;</div><div class="line">    private Bitmap srcBmp;</div><div class="line">    private int width = 400;</div><div class="line">    private int height = 400;</div><div class="line">    private PorterDuffXfermode mMode;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(View.LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        dstBmp = makeBitmap(width, height, 0xFFFFCC44, &quot;oval&quot;);</div><div class="line">        srcBmp = makeBitmap(width, height, 0xFF66AAFF, &quot;rect&quot;);</div><div class="line">        mMode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Bitmap makeBitmap(int w, int h, int color, String type) &#123;</div><div class="line">        Bitmap bmp = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);</div><div class="line">        Canvas canvas = new Canvas(bmp);</div><div class="line">        Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);</div><div class="line">        paint.setColor(color);</div><div class="line">        if (&quot;oval&quot;.equals(type)) &#123;</div><div class="line">            canvas.drawOval(new RectF(0, 0, w, h), paint);</div><div class="line">        &#125; else &#123;</div><div class="line">            canvas.drawRect(0, 0, w, h, paint);</div><div class="line">        &#125;</div><div class="line">        return bmp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawColor(Color.GREEN);</div><div class="line"></div><div class="line">        int layerId = canvas.saveLayer(0, 0, width * 2, height * 2,</div><div class="line">                null, Canvas.ALL_SAVE_FLAG);</div><div class="line">        canvas.drawBitmap(dstBmp, 0, 0, mPaint);</div><div class="line">        mPaint.setXfermode(mMode);</div><div class="line">        canvas.drawBitmap(srcBmp, width / 2f, height / 2f, mPaint);</div><div class="line">        mPaint.setXfermode(null);</div><div class="line">        canvas.restoreToCount(layerId);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这段代码我们应该很熟悉，这是在讲解 setXfermode() 函数时的示例代码，但在调用 saveLayer() 函数前把整个屏幕画成了绿色，效果图如下。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7c8c4acbacc0ce72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>那么问题来了，如果我们把 saveLayer() 函数去掉，则会怎样？代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line">    canvas.drawColor(Color.GREEN);</div><div class="line">    canvas.drawBitmap(dstBmp, 0, 0, mPaint);</div><div class="line">    mPaint.setXfermode(mMode);</div><div class="line">    canvas.drawBitmap(srcBmp, width / 2f, height / 2f, mPaint);</div><div class="line">    mPaint.setXfermode(null);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2d5f53498b9e95ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到，效果居然不一样。先来回顾下 Mode.SRC_IN 模式的效果：在处理源图像时，以显示源图像为主，在相交时利用目标图像的透明度来改变源图像的透明度和饱和度；当目标图像透明度为 0 时，源图像就完全不显示。</p><p>再回过来看结果，第一个结果是对的，因为除与圆相交以外的区域透明度都是 0，而第二个结果怎么变成了这样，源图像为什么全部都显示出来了？</p><h4 id="1-调用-saveLayer-函数时的绘图流程"><a href="#1-调用-saveLayer-函数时的绘图流程" class="headerlink" title="1. 调用 saveLayer() 函数时的绘图流程"></a>1. 调用 saveLayer() 函数时的绘图流程</h4><p>在调用 saveLayer() 函数时，会生成一个全新的画布（Bitmap），这块画布的大小就是我们指定的所要保存区域的大小。新生成的画布是全透明的，在调用 saveLayer() 函数后所有的绘图操作都是在这个画布上进行的。</p><p>我们讲过，在利用 Xfermode 画源图像时，会把之前画布上所有的内容都做为目标图像，而在调用 saveLayer() 函数新生成的画布上，只有 dstBmp 对应的圆形。所以，除与圆形相交之外的位置都是空白像素。</p><p>对于 Xfermode 而言，在绘图完成之后，会把调用 saveLayer() 函数所生成的透明画布覆盖在原来的画布上面，以形成最终的显示结果。</p><p>此时的 Xfermode 的合成过程如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-89741e0db7478124?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>中间的透明画布就是调用 saveLayer() 函数自动生成的，最上方的透明图层是调用 drawBitmap() 函数生成的。我们知道，每次调用 canvas.drawXXX 系列函数，都会生成一个透明层来专门绘制这个图形，而每次生成的图层都会叠加到最近的画布上。因为我们在这里对源图像应用了 Xfermode 算法，所以在叠加到就近的调用 saveLayer() 函数生成的画布上时，会进行计算。在新建的画布上绘制完成以后，整体覆盖在原始画布上显示出来。</p><p>正是因为在使用 Xfermode 计算时，目标图像是绘制在新建的透明画布上的，所以除圆形以外的区域全部是透明像素，最终的显示结果是正确的。</p><h4 id="2-没有-saveLayer-函数时的绘图流程"><a href="#2-没有-saveLayer-函数时的绘图流程" class="headerlink" title="2. 没有 saveLayer() 函数时的绘图流程"></a>2. 没有 saveLayer() 函数时的绘图流程</h4><p>在第二个示例中，唯一不同的就是把 saveLayer() 函数去掉了。</p><p>在去掉 saveLayer() 函数后，就不会新建画布了。当然，所有的绘图操作都会在原始画布上进行。</p><p>由于先把整块画布染成了绿色，再画上一个圆形，所有在应用 Xfermode 来画源图像的时候，在目标画布上是没有透明像素的。这也就不难解释结果为什么是这样的。</p><p>此时的 Xfermode 合成过程如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-44689d53676ffb76?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>由于没有调用 saveLayer() 函数，所以圆形是直接画在原始画布上的，而当矩形与其相交时，就是直接与原始画布上的所有图像做计算的。</p><blockquote><p>结论：调用 saveLayer() 函数会创建一个全新的透明画布，大小与指定保存的区域大小一致，其后的绘图操作都放在这块画布上进行。在绘制结束后，会直接盖在原始画布上显示。</p></blockquote><p><div id="jump2"></div></p><h3 id="9-2-2-画布与图层"><a href="#9-2-2-画布与图层" class="headerlink" title="9.2.2 画布与图层"></a>9.2.2 画布与图层</h3><p>上面讲到了画布（Bitmap）、图层（Layer）和 Canvas 的概念，下面具体讲解下它们之间的关系。</p><ul><li>图层（Layer）：每一次调用 canvas.drawXXX 系列函数时，都会生成一个透明图层来专门来绘制这个图形，比如前面在绘制矩形时的透明图层就是这个概念。</li><li>画布（Bitmap）：每块画布都是一个 Bitmap，所有的图像都是画在 Bitmap上的。我们知道，每次调用 canvas.drawXXX 函数时，都会生成一个专用的透明图层来绘制这个图形，绘制完成以后，就覆盖在画布上。所以，如果我们连续调用 5 个 draw 函数，就会生成 5 个透明图层，画完之后依次覆盖在画布上显示。画布有两种：第一种是 View 的原始画布，是通过 onDraw(Canvas canvas) 函数传入的，参数中的 canvas 就对应的是 View 的原始画布，控件的背景就是画在这块画布上的；另一种是人造画布，通过 saveLayer()、new Canvas(bitmap) 等函数来人为地新建一块画布。尤其是 saveLayer() 函数，一旦调用 saveLayer() 函数新建一块画布，以后的所有 draw 函数所画的图像都是画在这块画布上的，只有在调用 restore()、resoreToCount() 函数以后，才会返回到原始画布上进行绘制。</li><li>Canvas：Canvas 是画布的表现形式，我们所要绘制的任何东西都是利用 Canvas 来实现的。在代码中，Canvas 的生成方式只有一种——new Canvas(bitmap)，即只能通过 Bitmap 生成，无论是原始画布还是人造画布，所有的画布最后都是通过 Canvas 画到 Bitmap 上的。可以把 Canvas 理解成绘图工具，利用它所封装的绘图函数来绘图，而所要绘制的内容最后是画在 Bitmap 上的。所以，如果我们利用 Canvas.clipXXX 系列函数将画布进行裁剪，其实就是把它对应的 Bitmap 进行裁剪，与之对应的结果就是再利用 Canvas 绘图的区域会减小。</li></ul><p><div id="jump3"></div></p><h3 id="9-2-3-saveLayer-和-saveLayerAlpha-函数的用法"><a href="#9-2-3-saveLayer-和-saveLayerAlpha-函数的用法" class="headerlink" title="9.2.3 saveLayer() 和 saveLayerAlpha() 函数的用法"></a>9.2.3 saveLayer() 和 saveLayerAlpha() 函数的用法</h3><h4 id="1-saveLayer-函数的用法"><a href="#1-saveLayer-函数的用法" class="headerlink" title="1. saveLayer() 函数的用法"></a>1. saveLayer() 函数的用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public int saveLayer(RectF bounds, Paint paint, int saveFlags)</div><div class="line">public int saveLayer(float left, float top, float right, float bottom, </div><div class="line">                     Paint paint, int saveFlags)</div></pre></td></tr></table></figure><p>参数：</p><ul><li>RectF bounds：新建画布的尺寸。</li><li>Paint paint：画笔实例。</li><li>int saveFlags：新建画布的标识（详见 9.3 节）。</li></ul><p>saveLayer() 函数会新建一块画布（Bitmap），后续的所有操作都是在这块画布上进行的。下面我们来看一下 saveLayer() 函数使用中的注意事项。</p><h5 id="1）saveLayer-函数后的所有动作都只对新建画布有小。"><a href="#1）saveLayer-函数后的所有动作都只对新建画布有小。" class="headerlink" title="1）saveLayer() 函数后的所有动作都只对新建画布有小。"></a>1）saveLayer() 函数后的所有动作都只对新建画布有小。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap mBitmap;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.dog);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawBitmap(mBitmap, 0, 0, mPaint);</div><div class="line"></div><div class="line">        int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), mPaint, Canvas.ALL_SAVE_FLAG);</div><div class="line">        canvas.skew(1.732f, 0);</div><div class="line">        canvas.drawRect(0, 0, 100, 100, mPaint);</div><div class="line">        canvas.restoreToCount(layerId);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14186083-3c785d4027271de4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在 onDraw() 函数中，我们先在 View 的原始画布上画上了小狗的图像，然后利用 saveLayer() 函数新建了一个图层，然后利用 canvas.skew() 函数将新建的图层水平斜切 45°，所以之后画的矩形 (0,0,100,100) 就是斜切的。</p><p>而正是由于在新建画布后的各种操作都是针对新建画布进行的，所以不会对以前的画布产生影响。从效果图中也可以明显看出，将画布水平斜切 45° 也只影响了 saveLayer() 函数的新建画布，并没有对之前的原始画布产生影响。</p><h5 id="2）通过-Rect-指定的矩形大小就是新建的画布大小。"><a href="#2）通过-Rect-指定的矩形大小就是新建的画布大小。" class="headerlink" title="2）通过 Rect 指定的矩形大小就是新建的画布大小。"></a>2）通过 Rect 指定的矩形大小就是新建的画布大小。</h5><p>在 saveLayer() 函数的参数中，可以通过指定 Rect 对象或者指定 4 个点来指定一个矩形，这个矩形的大小就是新建画布的大小。我们举例来看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line">    canvas.drawBitmap(mBitmap, 0, 0, mPaint);</div><div class="line"></div><div class="line">    int layerId = canvas.saveLayer(0, 0, 200, 200, mPaint, </div><div class="line">                                   Canvas.ALL_SAVE_FLAG);</div><div class="line">    canvas.drawColor(Color.GRAY);</div><div class="line">    canvas.restoreToCount(layerId);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d2d2bbfed7459587.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在绘图时，我们先把小狗图片绘制在原始画布上的，然后新建一个大小为 (0,0,200,200) 的透明画布，并将画布填充为灰色。由于画布大小只有 (0,0,200,200)，所以从效果图中可以看出，也只有这一小部分区域被填充为灰色。</p><p>有些读者可能会想，为了避免画布太小而出现问题，每次都新建一块屏幕大小的画布多好。这样虽然是不会出现问题，但屏幕大小的画布需要多少存储空间呢？按一个像素需要 8bit 存储空间算，分辨率为 1024 像素 x 768 像素的机器，所占用的存储空间就是 1024 * 768 * 8 = 6.2MB。所以我们在使用 saveLayer() 函数新建画布时，一定要选择适当的大小，否则你的 APP 很可能 OOM。</p><blockquote><p>注意：在前面示例中都是直接新建全屏画布的，这只是为了方便展示，在现实使用中一定要创建适当的画布大小。</p></blockquote><h4 id="2-saveLayerAlpha-函数的用法"><a href="#2-saveLayerAlpha-函数的用法" class="headerlink" title="2. saveLayerAlpha() 函数的用法"></a>2. saveLayerAlpha() 函数的用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public int saveLayerAlpha(RectF bounds, int alpha, int saveFlags)</div><div class="line">public int saveLayerAlpha(float left, float top, float right, float bottom,</div><div class="line">                          int alpha, int saveFlags)</div></pre></td></tr></table></figure><p>相比 saveLayer() 函数，多了一个 alpha 参数，用于指定新建画布的透明度，取值范围为 0~255，可以用十六进制的 0xAA 表示，取 0 时表示全透明。</p><p>这个函数的意义也是在调用的时候会新建一块画布，以后的各种绘图操作都作用在这个画布上，但这个画布是有透明度的，透明度就是通过 alpha 参数指定的。</p><p>将上述示例中的 saveLayer() 函数改为 saveLayerAlpha() 函数来重新作图。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line">    canvas.drawBitmap(mBitmap, 0, 0, mPaint);</div><div class="line"></div><div class="line">    int layerId = canvas.saveLayerAlpha(0, 0, 200, 200, 100, </div><div class="line">                                        Canvas.ALL_SAVE_FLAG);</div><div class="line">    canvas.drawColor(Color.WHITE);</div><div class="line">    canvas.restoreToCount(layerId);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-dd481599deaa6cdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在调用 saveLayerAlpha() 函数时，将新建画布的透明度设置为 100%，然后将画布同样填充为白色。从效果图中可以看出，在新建图像与上层画布合成以后，是具有透明度的。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-fb434ac4414c4788.gif?imageMogr2/auto-orient/strip" alt="愿化身那堵墙.gif"></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09.1 精通自定义 View 之 Canvas 与图层——获取 Canvas 对象的方法</title>
      <link href="/2019/07/09/05%20CUSTOM%20VIEW/09.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96%20Canvas%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2019/07/09/05%20CUSTOM%20VIEW/09.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96%20Canvas%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-171b3366544ced47.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="9-1-1-方法一：重写-onDraw-、dispatchDraw-函数"><a href="#9-1-1-方法一：重写-onDraw-、dispatchDraw-函数" class="headerlink" title="9.1.1 方法一：重写 onDraw()、dispatchDraw() 函数"></a>9.1.1 方法一：重写 onDraw()、dispatchDraw() 函数</h3><p>一般在自定义 View 时，我们都会重写 onDraw()、dispatchDraw() 函数。先来看一下 onDraw()、dispatchDraw() 函数的定义，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">protected void dispatchDraw(Canvas canvas) &#123;</div><div class="line">    super.dispatchDraw(canvas);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看到，onDraw()、dispatchDraw() 函数在传入的参数中都有一个 Canvas 对象。这个 Canvas 对象是 View 中的 Canvas 对象，利用这个 Canvas 对象绘图，效果会直接反映在 View 中。</p><p>onDraw()、dispatchDraw() 函数的区别如下：</p><ul><li>onDraw() 函数用于绘制视图自身。</li><li>dispatchDraw() 函数用于绘制子视图。</li></ul><p>无论是 View 还是 ViewGroup 对这连个函数的调用顺序都是 onDraw() —&gt; dispatchDraw()。</p><p>但在 ViewGroup 中，当它有背景的时候就会调用 onDraw() 函数，否则就会跳过 onDraw() 函数，直接调用 dispatchDraw() 函数。所以，如果要在 ViewGroup 中绘图，往往会重写 dispatchDraw() 函数。</p><p>在 View 中，onDraw() 和 dispatchDraw() 函数都会被调用的，所以我们无论把绘图代码放在 onDraw() 函数或者 dispatchDraw() 函数中都是可以得到效果的。但是，由于 dispatchDraw() 函数用于绘制子控件，所以，原则来上讲，在绘制 View 控件时，我们会重写 onDraw() 函数。</p><blockquote><p>总结：在绘制 View 控件时，需要重写 onDraw() 函数；在绘制 ViewGroup 时，需要重写 dispatchDraw() 函数。</p></blockquote><p><div id="jump2"></div></p><h3 id="9-1-2-方法二：使用-Bitmap-创建"><a href="#9-1-2-方法二：使用-Bitmap-创建" class="headerlink" title="9.1.2 方法二：使用 Bitmap 创建"></a>9.1.2 方法二：使用 Bitmap 创建</h3><h4 id="1-构建方法"><a href="#1-构建方法" class="headerlink" title="1. 构建方法"></a>1. 构建方法</h4><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Canvas c = new Canvas(bitmap);</div></pre></td></tr></table></figure></p><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Canvas c = new Canvas();</div><div class="line">c.setBitmap(bitmap);</div></pre></td></tr></table></figure></p><p>其中，bitmap 可以从图片中加载，也可以自行创建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 方法一：新建一个空白 bitmap</div><div class="line">Bitmap bmp = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);</div><div class="line">// 方法二：从图片中加载</div><div class="line">Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.img, null);</div></pre></td></tr></table></figure></p><p>除这两种方法以外，还有其他几种方法（比如构造一个具有 Matrix 的图像副本），这里不再涉及，大家可以去查看 Bitmap 的构造函数。</p><h4 id="2-在-onDraw-函数中使用"><a href="#2-在-onDraw-函数中使用" class="headerlink" title="2. 在 onDraw() 函数中使用"></a>2. 在 onDraw() 函数中使用</h4><p>需要注意的是，如果我们用 Bitmap 构造了一个 Canvas，那这个 Canvas 上绘制的图像也都会保存在这个 Bitmap 上，而不是画在 View 上。如果想画在 View 上就必须使用 OnDraw(Canvas canvas) 函数中传入的 Canvas 画一遍 Bitmap。</p><p>下面举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap mBitmap;</div><div class="line">    private Canvas mBitmapCanvas;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setTextSize(50);</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mBitmap = Bitmap.createBitmap(500, 500, Bitmap.Config.ARGB_8888);</div><div class="line">        mBitmapCanvas = new Canvas(mBitmap);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        mBitmapCanvas.drawText(&quot;先小涛&quot;, 100, 100, mPaint);</div><div class="line">        // canvas.drawBitmap(mBitmap, 0, 0, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行上述代码后会发现，结果是一片空白，我们写的字去哪儿了？在 onDraw() 函数中，我们只是将文字画在了 mBitmapCanvas 上，也就是我们新建 mBitmap 图片上，而最终没有将图片画在画布上。因为文字被写在了图片上，而画布上却没有任何内容，所以结果是一片空白。如果将注释掉的最后一句打开，即可将图片画在画布上，在视图上就会显示文字了，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f1dd4d89fab911cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><div id="jump3"></div></p><h3 id="9-1-3-方法三：调动-SurfaceHolder-lockCanvas-函数"><a href="#9-1-3-方法三：调动-SurfaceHolder-lockCanvas-函数" class="headerlink" title="9.1.3 方法三：调动 SurfaceHolder.lockCanvas() 函数"></a>9.1.3 方法三：调动 SurfaceHolder.lockCanvas() 函数</h3><p>在使用 SurfaceView 时，当调用 SurfaceHolder.lockCanvas() 函数时，也会创建 Canvas 对象，有关 SurfaceView 的知识可以参考第 10 章。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f640700a6ccd2b59.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08.4 精通自定义 View 之 混合模式——目标图像模式与其他模式</title>
      <link href="/2019/07/08/05%20CUSTOM%20VIEW/08.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%9B%AE%E6%A0%87%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/07/08/05%20CUSTOM%20VIEW/08.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%9B%AE%E6%A0%87%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ccf3f912a55ae730.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="8-4-1-目标图像模式"><a href="#8-4-1-目标图像模式" class="headerlink" title="8.4.1 目标图像模式"></a>8.4.1 目标图像模式</h3><p>我们知道，在与 SRC 相关的模式中，在处理相交区域时，优先以源图像显示为主；而在与 DST 相关的模式中，在处理相交区域时，优先以目标图像显示为主。这部分所涉及的模式有 Mode.DST、Mode.DST_IN、Mode.DST_OUT、Mode.DST_OVER、Mode.DST_ATOP。</p><h4 id="1-Mode-DST"><a href="#1-Mode-DST" class="headerlink" title="1. Mode.DST"></a>1. Mode.DST</h4><p>计算公式：[Da, Dc]。<br>从公式中也可以看出，在处理源图像所在区域的相交问题时，正好与 Mode.SRC 模式相反，全部以目标图像显示。示例图像如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-cb7d1f1fba1cb963.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="2-Mode-DST-IN"><a href="#2-Mode-DST-IN" class="headerlink" title="2. Mode.DST_IN"></a>2. Mode.DST_IN</h4><h5 id="1）概述"><a href="#1）概述" class="headerlink" title="1）概述"></a>1）概述</h5><p>计算公式为：[Da * Sa, Dc * Sa]。</p><p>将这个公式与 Mode.SRC_IN 的公式（[Sa * Da, Sc * Da]）对比一下，发现正好与 SRC_IN 相反，Mode.DST_IN 是在相交时利用源图像的透明度来改变目标图像的透明度和饱和度。当源图像透明度为 0时，目标图像就完全不显示。示例图像为：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4526322efb995406.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>利用 SRC 模式能实现的效果，只需要将源图像与目标图像对调，利用对应的 DST 模式就可以实现同样的效果。比如，在 8.3 节中所实现的圆角效果，它对应的 DST 模式的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap bmpDST, bmpSRC;</div><div class="line">    private PorterDuffXfermode mMode;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint = new Paint();</div><div class="line">        bmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.dog,null);</div><div class="line">        bmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.dog_shade,null);</div><div class="line">        mMode = new PorterDuffXfermode(PorterDuff.Mode.DST_IN);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG);</div><div class="line"></div><div class="line">        canvas.drawBitmap(bmpDST,0,0,mPaint);</div><div class="line">        mPaint.setXfermode(mMode);</div><div class="line">        canvas.drawBitmap(bmpSRC,0,0,mPaint);</div><div class="line"></div><div class="line">        mPaint.setXfermode(null);</div><div class="line">        canvas.restoreToCount(layerId);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>很明显，这里只改了两部分代码：首先，在解析图片时，将要显示的小狗图像作为目标图像，将控制哪部分显示的遮罩图像作为源图像；其次，将合成模式改为 Mode.DST_IN。其效果与 8.3 节中圆角效果一致。</p><h5 id="2）示例：区域波纹"><a href="#2）示例：区域波纹" class="headerlink" title="2）示例：区域波纹"></a>2）示例：区域波纹</h5><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0953ae10e49251e0.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Canvas mTempCanvas;</div><div class="line">    // 用来生成波纹</div><div class="line">    private Path mPath;</div><div class="line">    // 波纹图像为目标图像，要显示的内容</div><div class="line">    private Bitmap dstBmp;</div><div class="line">    // 文字图像为源图像</div><div class="line">    private Bitmap srcBmp;</div><div class="line">    // 波纹动画移动的距离</div><div class="line">    private int mDx;</div><div class="line">    // 波纹下降动画的位移</div><div class="line">    private int mDy;</div><div class="line">    // 一个波长</div><div class="line">    private int mItemWaveLength = 1000;</div><div class="line">    private PorterDuffXfermode mMode;</div><div class="line">    private String mText;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(View.LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPaint.setStyle(Paint.Style.FILL_AND_STROKE);</div><div class="line"></div><div class="line">        mMode = new PorterDuffXfermode(PorterDuff.Mode.DST_IN);</div><div class="line">        mPath = new Path();</div><div class="line">        mTempCanvas = new Canvas();</div><div class="line">        mText = &quot;先小涛&quot;;</div><div class="line"></div><div class="line">        srcBmp = makeTextBitmap();</div><div class="line">        dstBmp = Bitmap.createBitmap(srcBmp.getWidth(), srcBmp.getHeight(), Bitmap.Config.ARGB_8888);</div><div class="line"></div><div class="line">        startAnim();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 开启动画</div><div class="line">     */</div><div class="line">    public void startAnim() &#123;</div><div class="line">        // 波纹动画</div><div class="line">        ValueAnimator waveAnimator = ValueAnimator.ofInt(0, mItemWaveLength);</div><div class="line">        waveAnimator.setDuration(2000);</div><div class="line">        waveAnimator.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">        waveAnimator.setInterpolator(new LinearInterpolator());</div><div class="line">        waveAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">                mDx = (Integer) animation.getAnimatedValue();</div><div class="line">                postInvalidate();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        // 下降动画</div><div class="line">        ValueAnimator downAnimator = ValueAnimator.ofInt(0, srcBmp.getHeight());</div><div class="line">        downAnimator.setDuration(8000);</div><div class="line">        downAnimator.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">        downAnimator.setInterpolator(new LinearInterpolator());</div><div class="line">        downAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">                mDy = (Integer) animation.getAnimatedValue();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        AnimatorSet animatorSet = new AnimatorSet();</div><div class="line">        animatorSet.play(waveAnimator).with(downAnimator);</div><div class="line">        animatorSet.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        // 将生成的波纹绘制到空白区域</div><div class="line">        generateWavePath();</div><div class="line">        mTempCanvas.setBitmap(dstBmp);</div><div class="line">        mTempCanvas.drawColor(Color.BLACK, PorterDuff.Mode.CLEAR);</div><div class="line">        mTempCanvas.drawPath(mPath, mPaint);</div><div class="line"></div><div class="line">        // 先绘制文字，再绘制合成效果</div><div class="line">        canvas.drawBitmap(srcBmp, 0, 0, mPaint);</div><div class="line"></div><div class="line">        int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG);</div><div class="line">        canvas.drawBitmap(dstBmp, 0, 0, mPaint);</div><div class="line">        mPaint.setXfermode(mMode);</div><div class="line">        canvas.drawBitmap(srcBmp, 0, 0, mPaint);</div><div class="line">        mPaint.setXfermode(null);</div><div class="line">        canvas.restoreToCount(layerId);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 将字符串转化成 bitmap</div><div class="line">     * @return Bitmap</div><div class="line">     */</div><div class="line">    private Bitmap makeTextBitmap() &#123;</div><div class="line">        Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);</div><div class="line">        paint.setTextSize(200);</div><div class="line">        paint.setColor(Color.WHITE);</div><div class="line">        paint.setTextAlign(Paint.Align.LEFT);</div><div class="line"></div><div class="line">        Paint.FontMetricsInt fm = paint.getFontMetricsInt();</div><div class="line">        int width = (int) paint.measureText(mText);</div><div class="line">        int height = fm.descent - fm.ascent;</div><div class="line"></div><div class="line">        Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);</div><div class="line">        Canvas canvas = new Canvas(bitmap);</div><div class="line">        canvas.drawText(mText, 0, fm.leading - fm.ascent, paint);</div><div class="line">        canvas.save();</div><div class="line"></div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 生成波纹</div><div class="line">     */</div><div class="line">    private void generateWavePath() &#123;</div><div class="line">        mPath.reset();</div><div class="line">        // int originY = srcBmp.getHeight() / 2;</div><div class="line">        int originY = mDy;</div><div class="line">        int halfWaveLen = mItemWaveLength / 2;</div><div class="line">        mPath.moveTo(-mItemWaveLength + mDx, originY);</div><div class="line">        for (int i = -mItemWaveLength; i &lt;= getWidth() + mItemWaveLength; i+= mItemWaveLength) &#123;</div><div class="line">            mPath.rQuadTo(halfWaveLen / 2f, -50, halfWaveLen, 0);</div><div class="line">            mPath.rQuadTo(halfWaveLen / 2f, 50, halfWaveLen, 0);</div><div class="line">        &#125;</div><div class="line">        mPath.lineTo(srcBmp.getWidth(), srcBmp.getHeight());</div><div class="line">        mPath.lineTo(0, srcBmp.getHeight());</div><div class="line">        mPath.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="3）示例：区域不规则波纹"><a href="#3）示例：区域不规则波纹" class="headerlink" title="3）示例：区域不规则波纹"></a>3）示例：区域不规则波纹</h5><h4 id="3-Mode-DST-OUT"><a href="#3-Mode-DST-OUT" class="headerlink" title="3. Mode.DST_OUT"></a>3. Mode.DST_OUT</h4><p>计算公式为：[Da * (1 - Sa), Dc * (1 - Sa)]。</p><p>将这个公式与 Mode.SRC_OUT 的公式（[Sa * (1 - Da), Sc * (1 - Da)]）对比一下可以看出，Mode.SRC_OUT 是利用目标图像的透明度的补值来改变源图像的透明度和饱和度。而 Mode.DST_OUT 反过来，是通过源图像的透明度补值来改变目标图像的透明度和饱和度。</p><p>简单来说，在 Mode.DST_OUT 模式下，就是相交区域显示的是目标图像，目标图像的透明度和饱和度与源图像的透明度相反，当源图像透明底是 100% 时，则相交区域为空值。当源图像透明度为 0 时，则完全显示目标图像。非相交区域完全显示目标图像。示例图像如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-361e3c3461b8fcd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>用下图的分解图来讲解一下这个效果的生成方式，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-65d2b99bb482da0a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图中区域一的相交区域：在 DST_OUT 模式下，由于源图像的透明度是 100%，所以计算后的结果图像在这个区域是空白像素。</p><p>图中区域二的非相交区域：在 DST_OUT 模式下，这个区域的源图像透明度仍为 100%，所以计算后的结果图像在这个区域仍是空白像素。</p><p>所以，当源图像区域透明度为 100%时，所在区域计算结果为透明像素，当源图像的区域透明时，计算结果就是目标图像。</p><p>这与 SRC_OUT 模式的结果正好相反，在 SRC_OUT 模式下，当目标图像区域透明度为 100% 时，所在区域计算结果为透明像素；当目标图像的区域透明时，非相交区域的计算结果就是源图像。</p><p>所以，在 8.3.3 节中使用 SRC_OUT 模式实现的橡皮擦效果和刮刮卡效果都是可以使用 DST_OUT 模式实现的，只需要将 SRC 和 DST 所对应的图像翻转一下就可以了。</p><h4 id="4-Mode-DST-OVER"><a href="#4-Mode-DST-OVER" class="headerlink" title="4. Mode.DST_OVER"></a>4. Mode.DST_OVER</h4><p>计算公式为：[Sa + (1 - Sa) * Da, Rc = Dc + (1 - Da) * Sc]。</p><p>同样先与 Mode.SRC_OVER 的公式（[Sa + (1 - Sa) * Da, Rc = Sc + (1 - Sa) * Dc]）对比一下，可以看出，从 SRC 模式中以显示 SRC 图像为主变成了以显示 DST 图像为主，从 SRC 模式中的使用目标图像控制结果图像的透明度和饱和度变成了由源图像控件结果图像的透明度和饱和度。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-6c47a26b2ec99073.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="5-Mode-DST-ATOP"><a href="#5-Mode-DST-ATOP" class="headerlink" title="5. Mode.DST_ATOP"></a>5. Mode.DST_ATOP</h4><p>计算公式为：[Sa, Sa * Dc + Sc * (1 - Da)]。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b9e5222f1c048369.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在 SRC 中，一般而言，SRC_ATOP 是可以和 SRC_IN 通用的，但 SRC_ATOP 所产生的效果图在目标图的透明度不是 0 或 100% 的时候，会比 SRC_IN 模式产生的效果图更亮。</p><p>我们再来对比下 DST 中的两种模式与 SRC 中的这两种模式的公式的区别：</p><div class="table-container"><table><thead><tr><th style="text-align:left">模式</th><th style="text-align:left">公式</th></tr></thead><tbody><tr><td style="text-align:left">SRC_IN</td><td style="text-align:left">[Sa * Da, Sc * Da]</td></tr><tr><td style="text-align:left">SRC_ATOP</td><td style="text-align:left">[Da, Sc * Da + (1 - Sa) * Dc]</td></tr><tr><td style="text-align:left">DST_IN</td><td style="text-align:left">[Da * Sa, Dc * Sa ]</td></tr><tr><td style="text-align:left">DST_ATOP</td><td style="text-align:left">[Sa, Sa * Dc + Sc * (1 - Da)]</td></tr></tbody></table></div><p>从公式中可以看到，在 SRC 模式中，以显示源图像为主，透明度和饱和度利用 Da 来调节；而在 DST 模式中，以显示目标图像为主，透明度和饱和度利用 Sa 来调节。</p><p>所以，Mode.DST_ATOP 与 Mode.DST_IN 的关系也是：一般而言，DST_ATOP 是可以和 DST_IN 通用的，但 DST_ATOP 所产生的效果图在源图像的透明度不是 0 或 100% 的时候，会比 DST_IN 模式产生的效果图更亮。</p><p>同样，使用 Mode.DST_ATOP 也可以实现 8.3.2 节中利用 Mode.SRC_ATOP 所实现的两个示例：圆角效果和图片倒影，这里就不再讲了。</p><p>到这里，有关 DST 相关模式都讲完了，我们总结一下：</p><ul><li>DST 相关模式是完全可以使用 SRC 对应的模式来实现的，只需将目标图像和源图像对调一下即可。</li><li>在 SRC 模式中，是以显示源图像为主，通过目标图像的透明度来调节计算结果的透明度和饱和度，而在 DST 模式中，是以显示目标图像为主，通过源图像的透明度来调节计算结果的透明度和饱和度。</li></ul><p><div id="jump2"></div></p><h3 id="8-4-2-其他模式"><a href="#8-4-2-其他模式" class="headerlink" title="8.4.2 其他模式"></a>8.4.2 其他模式</h3><p>计算公式：[0, 0]。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-39b617495005ddf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从公式中可以看到，计算结果直接就是[0,0]，即空白像素。也就是说，源图像所在区域都会变成空像素，这样就起到了清空源图像所在区域图像的作用。</p><p><div id="jump3"></div></p><h3 id="8-4-3-模式总结"><a href="#8-4-3-模式总结" class="headerlink" title="8.4.3 模式总结"></a>8.4.3 模式总结</h3><p>在实际应用中，我们可以从以下三个方面来决定使用哪种模式。</p><ul><li>目标图像和源图像混合，需不需要生成颜色的叠加特效。如果需要，则从颜色叠加相关模式中选择，有 Mode.ADD（饱和度相加）、Mode.DARKEN（变暗）、Mode.LIGHTEN（变亮）、Mode.MULTIPLY（正片叠底）、Mode.OVERLAY（叠加）、Mode.SCREEN（滤色）。</li><li>当不需要特效，而需要根据某张图片的透明像素来裁剪时，就需要使用 SRC 相关或 DST 相关模式了。而 SRC 相关模式与 DST 相关模式是相通的，唯一不同的是决定当前哪个图像是目标图像和源图像。</li><li>当需要清空图像时，使用 Mode.CLEAR 模式。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2548df731bd4975c.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08.3 精通自定义 View 之 混合模式——PorterDuffXfermode 之源图像模式</title>
      <link href="/2019/07/08/05%20CUSTOM%20VIEW/08.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode%20%E4%B9%8B%E6%BA%90%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/07/08/05%20CUSTOM%20VIEW/08.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode%20%E4%B9%8B%E6%BA%90%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-8e6c1ded6638e46e.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p>除 Photoshop 中存在的几个模式以外，还有几种是在处理结果时以源图像显示为主的几个模式，所以大家在遇到图像相交，需要显示源图像的情况时，就需要从这几种模式中考虑了，主要有 Mode.SRC、Mode.SRC_IN、Mode.SRC_OUT、Mode.SRC_OVER、Mode.SRC_ATOP。</p><p><div id="jump1"></div></p><h3 id="8-3-1-Mode-SRC"><a href="#8-3-1-Mode-SRC" class="headerlink" title="8.3.1 Mode.SRC"></a>8.3.1 Mode.SRC</h3><p>计算公式为：[Sa, Sc]。<br>从公式中也可以看出，在处理源图像所在区域的相交问题时，全部以源图像显示。示例图像如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-89f7351e119d5fb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><div id="jump2"></div></p><h3 id="8-3-2-Mode-SRC-IN"><a href="#8-3-2-Mode-SRC-IN" class="headerlink" title="8.3.2 Mode.SRC_IN"></a>8.3.2 Mode.SRC_IN</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>计算公式为：[Sa * Da, Sc * Da]。<br>在这个公式中结果值的透明度和颜色值都是由 Sa、Sc 分别乘以目标图像的 Da 来计算的。所以当目标图像为空白像素时，计算结果也将会为空白像素。示例图像如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-cf39995c77c03dbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>大家注意 SRC_IN 模式与 SRC 模式的区别。一般而言，是在相交区域时无论 SRC_IN 还是 SRC 模式都是显示源图像，而唯一不同的是，当目标图像是空白像素时，在 SRC_IN 所对应的区域也将会变成空白像素。</p><p>其实更严格的来讲，SRC_IN 模式是在相交时利用目标图像的透明度来改变源图像的透明度和饱和度。当目标图像透明度为 0 时，源图像就完全不显示。</p><p>利用这个特性，我们能完成很多功能，比如圆角效果和图片倒影。</p><p>圆角效果的生成非常简单，依然使用两张图片合成，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a47ca08d9ba84b3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>小狗图像是源图像，目标图像是一张遮罩图，可以看到这张遮罩图的 4 个角都是圆形切角，而且是透明的。这里我们就需要使用 SRC_IN 模式的特性：当目标图像与源图像相交时，根据目标图像的透明度来决定显示源图像的哪部分。</p><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap bmpDST, bmpSRC;</div><div class="line">    private PorterDuffXfermode mMode;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint = new Paint();</div><div class="line">        bmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.dog_shade,null);</div><div class="line">        bmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.dog,null);</div><div class="line">        mMode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG);</div><div class="line"></div><div class="line">        canvas.drawBitmap(bmpDST,0,0,mPaint);</div><div class="line">        mPaint.setXfermode(mMode);</div><div class="line">        canvas.drawBitmap(bmpSRC,0,0,mPaint);</div><div class="line"></div><div class="line">        mPaint.setXfermode(null);</div><div class="line">        canvas.restoreToCount(layerId);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="2-图片倒影效果"><a href="#2-图片倒影效果" class="headerlink" title="2. 图片倒影效果"></a>2. 图片倒影效果</h4><p>SRC_IN 模式是在相交时利用目标图像的透明度来改变源图像的透明度和饱和度。所以当目标图像的透明度在 0~255 之间时，就会把源图像的透明度和颜色值都会变小。利用这个特性，可以做出倒影效果，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a9774a1637b816f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>很明显，由于 SRC_IN 模式的特性是根据目标图像的透明度来决定如何显示源图像，而我们要显示的是小狗图像，所以，源图像是小狗图像，目标图像是一张遮罩图，它是一个从上到下的白色填充渐变，白色的透明度从 49% 到 0。</p><p>小效果图中，我们先画出小狗图像，然后将画布下移，最后将源图像与目标图像再次合成，画出倒影即可。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line">    private Paint mBitPaint;</div><div class="line">    private Bitmap bmpDST, bmpSRC, bmpRevert;</div><div class="line">    private PorterDuffXfermode mode;</div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(View.LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mBitPaint = new Paint();</div><div class="line">        mode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN);</div><div class="line">        bmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.dog_invert_shade,null);</div><div class="line">        bmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.dog,null);</div><div class="line"></div><div class="line">        Matrix matrix = new Matrix();</div><div class="line">        matrix.setScale(1F, -1F);</div><div class="line">        // 生成倒影图</div><div class="line">        bmpRevert = Bitmap.createBitmap(bmpSRC, 0, 0, bmpSRC.getWidth(), bmpSRC.getHeight(), matrix, true);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        // 先画出小狗图片</div><div class="line">        canvas.drawBitmap(bmpSRC,0,0,mBitPaint);</div><div class="line"></div><div class="line">        // 再画出倒影</div><div class="line">        int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG);</div><div class="line">        canvas.translate(0, bmpSRC.getHeight());</div><div class="line">        canvas.drawBitmap(bmpDST,0,0,mBitPaint);</div><div class="line">        mBitPaint.setXfermode(mode);</div><div class="line">        canvas.drawBitmap(bmpRevert,0,0,mBitPaint);</div><div class="line">        mBitPaint.setXfermode(null);</div><div class="line">        canvas.restoreToCount(layerId);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><div id="jump3"></div></p><h3 id="8-3-3-Mode-SRC-OUT"><a href="#8-3-3-Mode-SRC-OUT" class="headerlink" title="8.3.3 Mode.SRC_OUT"></a>8.3.3 Mode.SRC_OUT</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>计算公式为：[Sa * (1 - Da), Sc * (1 - Da)]。<br>示例图像如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-6e57a4f4165ff0c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从公式中可以看出，计算结果的透明度为 Sa * (1 - Da)；也就是说当目标图像图像完全不透明时，计算结果将是透明的。</p><p>从示例图中也可以看出，源图像与目标图像的相交部分由于目标图像的不透明度为 100%，所以相交部分的计算结果为空白像素。在目标图像为空白像素时，完全以源图像显示。</p><p>所以这个模式的特性可以概括为：以目标图像的透明度的补值来调节源图像的透明度和色彩饱和度。即当目标图像为空白像素时，就完全显示源图像，当目标图像的不透明度为 100%时，交合区域为空像素。简单来说，当目标图像有图像时结果显示空白像素，当目标图像没有图像时，结果显示源图像。</p><h4 id="2-橡皮擦效果"><a href="#2-橡皮擦效果" class="headerlink" title="2. 橡皮擦效果"></a>2. 橡皮擦效果</h4><p>利用 SRC_OUT 模式的特性，可以实现橡皮擦效果，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-39dc8d760b630613.gif?imageMogr2/auto-orient/strip" alt=""></p><p>原理：对于 Mode.SRC_OUT 模式，当目标图像有图像时计算结果为空白像素；当目标图像没有图像时，显示源图像。所以我们把手指轨迹做为目标图像，在与源图像计算时，有手指轨迹的地方就变为空白像素了，看起来的效果就是被擦除了。</p><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap mDstBmp;</div><div class="line">    private Bitmap mSrcBmp;</div><div class="line">    private Path mPath;</div><div class="line">    private float mPreX, mPreY;</div><div class="line">    private PorterDuffXfermode mMode;</div><div class="line">    private Canvas mTempCanvas;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(View.LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(100);</div><div class="line">        mPaint.setStrokeCap(Paint.Cap.ROUND);</div><div class="line"></div><div class="line">        BitmapFactory.Options options = new BitmapFactory.Options();</div><div class="line">        options.inSampleSize = 2;</div><div class="line"></div><div class="line">        mSrcBmp = BitmapFactory.decodeResource(getResources(), R.drawable.meinv, options);</div><div class="line">        mDstBmp = Bitmap.createBitmap(mSrcBmp.getWidth(), mSrcBmp.getHeight(), Bitmap.Config.ARGB_8888);</div><div class="line">        mPath = new Path();</div><div class="line">        mTempCanvas = new Canvas();</div><div class="line">        mMode = new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        switch (event.getAction()) &#123;</div><div class="line">            case MotionEvent.ACTION_DOWN:</div><div class="line">                mPath.moveTo(event.getX(), event.getY());</div><div class="line">                mPreX = event.getX();</div><div class="line">                mPreY = event.getY();</div><div class="line">                return true;</div><div class="line">            case MotionEvent.ACTION_MOVE:</div><div class="line">                float endX = (mPreX + event.getX()) / 2;</div><div class="line">                float endY = (mPreY + event.getY()) / 2;</div><div class="line">                mPath.quadTo(mPreX, mPreY, endX, endY);</div><div class="line">                mPreX = event.getX();</div><div class="line">                mPreY = event.getY();</div><div class="line">                break;</div><div class="line">            case MotionEvent.ACTION_UP:</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        postInvalidate();</div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG);</div><div class="line">        // 先把手势轨迹画到目标图像上</div><div class="line">        mTempCanvas.setBitmap(mDstBmp);</div><div class="line">        mTempCanvas.drawPath(mPath, mPaint);</div><div class="line">        // 然后把目标图像画到画布上</div><div class="line">        canvas.drawBitmap(mDstBmp, 0 , 0, mPaint);</div><div class="line">        // 计算源图像区域</div><div class="line">        mPaint.setXfermode(mMode);</div><div class="line">        canvas.drawBitmap(mSrcBmp, 0, 0, mPaint);</div><div class="line">        mPaint.setXfermode(null);</div><div class="line">        canvas.restoreToCount(layerId);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="3-刮刮卡效果"><a href="#3-刮刮卡效果" class="headerlink" title="3. 刮刮卡效果"></a>3. 刮刮卡效果</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0f4082ea19d4bf65.gif?imageMogr2/auto-orient/strip" alt=""></p><p>需要准备两张图片，一张是刮奖遮罩层图片（scratch_over.png），一张是中奖图片图片（scratch.png），如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-39e40bd1ea2aad4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="scratch_over.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-80d3e5f4969ba35e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="scratch.png"></p><p>示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap mDstBmp;</div><div class="line">    private Bitmap mSrcBmp;</div><div class="line">    private Bitmap mTextBmp;</div><div class="line">    private Path mPath;</div><div class="line">    private float mPreX, mPreY;</div><div class="line">    private PorterDuffXfermode mMode;</div><div class="line">    private Canvas mTempCanvas;</div><div class="line">    private RectF mRect;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(View.LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(100);</div><div class="line">        mPaint.setStrokeCap(Paint.Cap.ROUND);</div><div class="line"></div><div class="line">        mTextBmp = BitmapFactory.decodeResource(getResources(), R.drawable.scratch);</div><div class="line">        mSrcBmp = BitmapFactory.decodeResource(getResources(), R.drawable.scratch_over);</div><div class="line">        mDstBmp = Bitmap.createBitmap(mSrcBmp.getWidth(), mSrcBmp.getHeight(), Bitmap.Config.ARGB_8888);</div><div class="line">        mPath = new Path();</div><div class="line">        mTempCanvas = new Canvas();</div><div class="line">        mMode = new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT);</div><div class="line">        mRect = new RectF();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        switch (event.getAction()) &#123;</div><div class="line">            case MotionEvent.ACTION_DOWN:</div><div class="line">                mPath.moveTo(event.getX(), event.getY());</div><div class="line">                mPreX = event.getX();</div><div class="line">                mPreY = event.getY();</div><div class="line">                return true;</div><div class="line">            case MotionEvent.ACTION_MOVE:</div><div class="line">                float endX = (mPreX + event.getX()) / 2;</div><div class="line">                float endY = (mPreY + event.getY()) / 2;</div><div class="line">                mPath.quadTo(mPreX, mPreY, endX, endY);</div><div class="line">                mPreX = event.getX();</div><div class="line">                mPreY = event.getY();</div><div class="line">                break;</div><div class="line">            case MotionEvent.ACTION_UP:</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        postInvalidate();</div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        float width = mTextBmp.getWidth();</div><div class="line">        float height = mTextBmp.getHeight();</div><div class="line">        float screenWidth = getWidth();</div><div class="line">        if (width &gt; screenWidth) &#123;</div><div class="line">            height = height * screenWidth / width;</div><div class="line">            width = screenWidth;</div><div class="line">        &#125;</div><div class="line">        mRect.set(0, 0, width, height);</div><div class="line"></div><div class="line">        // 先画底层奖励文案图片</div><div class="line">        canvas.drawBitmap(mTextBmp, null, mRect, mPaint);</div><div class="line">        int layerId = canvas.saveLayer(140, 70, width - 140, height - 70,</div><div class="line">                null, Canvas.ALL_SAVE_FLAG);</div><div class="line">        // 把手势轨迹画到目标图像上</div><div class="line">        mTempCanvas.setBitmap(mDstBmp);</div><div class="line">        mTempCanvas.drawPath(mPath, mPaint);</div><div class="line">        // 然后把目标图像画到画布上</div><div class="line">        canvas.drawBitmap(mDstBmp, 0, 0, mPaint);</div><div class="line">        // 计算源图像区域</div><div class="line">        mPaint.setXfermode(mMode);</div><div class="line">        mRect.set(140, 70, width-140, height-70);</div><div class="line">        canvas.drawBitmap(mSrcBmp, null, mRect, mPaint);</div><div class="line">        mPaint.setXfermode(null);</div><div class="line">        canvas.restoreToCount(layerId);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><div id="jump4"></div></p><h3 id="8-3-4-Mode-SRC-OVER"><a href="#8-3-4-Mode-SRC-OVER" class="headerlink" title="8.3.4 Mode.SRC_OVER"></a>8.3.4 Mode.SRC_OVER</h3><p>计算公式为：[Sa + (1 - Sa) * Da, Rc = Sc + (1 - Sa) * Dc]。<br>示例图像为：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a65e54a4d2ed9fd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在计算结果中，源图像没有改变。它的意思就是，在目标图像的顶部绘制源图像。从公式中也可以看出，目标图像的透明度为 Sa + (1 - Sa) * Da；即在源图像的透明度基础上增加一部分目标图像的透明度。增加的透明度是源图像透明度的补量；目标图像的色彩值的计算方式同理，所以当源图像透明度为 100% 时，就原样显示源图像。</p><p><div id="jump5"></div></p><h3 id="8-3-5-Mode-SRC-ATOP"><a href="#8-3-5-Mode-SRC-ATOP" class="headerlink" title="8.3.5 Mode.SRC_ATOP"></a>8.3.5 Mode.SRC_ATOP</h3><p>计算公式为：[Da, Sc * Da + (1 - Sa) * Dc]。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4d160056ab5c4a12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>很奇怪，它的效果图竟然与 SRC_IN 模式是相同的，我们来对比一下它们的公式：</p><p>SRC_IN：[Sa * Da, Sc * Da]<br>SRC_ATOP：[Da, Sc * Da + (1 - Sa) * Dc]</p><p>先看透明度：在 SRC_IN 中是 Sa * Da,在 SRC_ATOP 是 Da。<br>SRC_IN 是源图像透明度乘以目标图像的透明度做为结果透明度，而SRC_ATOP 是直接使用目标图像的透明度做为结果透明度。</p><p>再看颜色值：SRC_IN 的颜色值为 Sc * Da，SRC_ATOP 的颜色值为Sc * Da + (1 - Sa) * Dc，SRC_ATOP 在 SRC_IN 的基础上还增加了(1 - Sa) * Dc。</p><p>所以，结论为：<br>1）当透明度是 100% 和 0 时，SRC_ATOP 和 SRC_IN 模式是通用的。<br>2）当透明度不是 100% 和 0 时，SRC_ATOP 相比 SRC_IN 源图像的饱和度会增加，即会显得更亮。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-60dbee53950e2be4.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08.2 精通自定义 View 之 混合模式——PorterDuffXfermode</title>
      <link href="/2019/07/08/05%20CUSTOM%20VIEW/08.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode/"/>
      <url>/2019/07/08/05%20CUSTOM%20VIEW/08.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-36be731dd94fd9b1.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="8-2-1-PorterDuffXfermode-概述"><a href="#8-2-1-PorterDuffXfermode-概述" class="headerlink" title="8.2.1 PorterDuffXfermode 概述"></a>8.2.1 PorterDuffXfermode 概述</h3><p><a href="">官方文档链接</a><br>PorterDuffXfermode 的构造函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public PorterDuffXfermode(PorterDuff.Mode mode)</div></pre></td></tr></table></figure></p><p>它只有一个参数 <a href="https://developer.android.google.cn/reference/android/graphics/PorterDuff.Mode.html?hl=en" target="_blank" rel="external">PorterDuff.Mode</a>，表示混合模式，枚举值有 18 个，表示各种图形混合模式，每一种模式都对应着一种算法，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b3b585f409b1e5a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>比如，LIGHTEN 的计算方式为 [Sa + Da - Sa * Da, Sc * (1 - Da) + Dc * (1 - Sa) + max(Sc, Dc)]，其中 Sa 全称为 Source alpha 表示源图的 Alpha 通道；Sc 全称为 Source color 表示源图的颜色；Da 全称为 Destination alpha 表示目标图的 Alpha 通道；Dc 全称为 Destination color 表示目标图的颜色，在每个公式中，都会被分为两部分 [……，……]，其中 “,” 前的部分为 “Sa + Da - Sa * Da” 这一部分的值代表计算后的 Alpha 通道；而 “,” 后的部分为 “Sc * (1 - Da) + Dc * (1 - Sa) + max(Sc, Dc)” 这一部分的值代表计算后的颜色值，图形混合后的图片就是依据这个公式来对 DST 和 SRC 两张图像中每一个像素进行计算，得到最终的结果的。</p><p>显示的是两个图形一圆一方通过一定的计算产生不同的组合效果，其中圆形是底部的目标图像，方形是上方的源图像。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2792a9df1c20f4ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在上面的公式中涉及到一个概念，目标图 DST，源图 SRC。那什么是源图，什么是目标图呢？我们简单举例子来说明一下：</p><p>首先需要自定义一个控件并进行初始化；然后禁用硬件加速；新建两张空白图片，然后在图片上分别画一个圆形 (DST) 和一个矩形 (SRC) 并填充相应的颜色，图形以外的位置都是空白像素；最后在离屏绘制部分，现在 (0, 0) 位置把圆形图像画出来，然后设置 PorterDuffXfermode 的模式为 Mode.SRC_IN，之后再以圆形中心为左上角点画出矩形，清空 Xfermode。</p><p>在 Xfermode 设置前画出的图像叫做目标图像，即给谁应用 Xfermode；在 Xfermode 设置后画出的图像叫做源图像，即拿什么应用 Xfermode。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap dstBmp;</div><div class="line">    private Bitmap srcBmp;</div><div class="line">    private int width = 200;</div><div class="line">    private int height = 200;</div><div class="line">    private PorterDuffXfermode mMode;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(View.LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        dstBmp = makeBitmap(width, height, 0xFFFFCC44, &quot;oval&quot;);</div><div class="line">        srcBmp = makeBitmap(width, height, 0xFF66AAFF, &quot;rect&quot;);</div><div class="line">        mMode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Bitmap makeBitmap(int w, int h, int color, String type) &#123;</div><div class="line">        Bitmap bmp = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);</div><div class="line">        Canvas canvas = new Canvas(bmp);</div><div class="line">        Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);</div><div class="line">        paint.setColor(color);</div><div class="line">        if (&quot;oval&quot;.equals(type)) &#123;</div><div class="line">            canvas.drawOval(new RectF(0, 0, w, h), paint);</div><div class="line">        &#125; else &#123;</div><div class="line">            canvas.drawRect(0, 0, w, h, paint);</div><div class="line">        &#125;</div><div class="line">        return bmp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.translate(100, 100);</div><div class="line">        int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG);</div><div class="line">        canvas.drawBitmap(dstBmp, 0, 0, mPaint);</div><div class="line">        mPaint.setXfermode(mMode);</div><div class="line">        canvas.drawBitmap(srcBmp, width / 2f, height / 2f, mPaint);</div><div class="line">        mPaint.setXfermode(null);</div><div class="line">        canvas.restoreToCount(layerId);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>该示例的效果如下图所示。<br><img src="https://upload-images.jianshu.io/upload_images/14186083-63bb7357915f6bbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于 Mode.SRC_IN，它的计算公式为 [Sa * Da, Sc * Da]。在这个公式中，结果值的透明度和颜色值都是由 Sa、Sc 分别乘以目标图像的 Da 来计算的。当目标图像为空白像素时，计算结果也将为空白像素；当目标图像不透明时，相交区域将显示源图像像素。所以，从效果图中可以看出，两图像相交部分显示的是源图像；对于不相交的部分，此时目标图像的透明度是 0，源图像不显示。</p><p><div id="jump2"></div></p><h3 id="8-2-2-颜色叠加相关模式"><a href="#8-2-2-颜色叠加相关模式" class="headerlink" title="8.2.2 颜色叠加相关模式"></a>8.2.2 颜色叠加相关模式</h3><p>这部分涉及到的几个模式有 Mode.ADD（饱和度相加）、Mode.LIGHTEN（变亮）、Mode.DARKEN（变暗）、Mode.MULTIPLY（正片叠底）、Mode.OVERLAY（叠加），Mode.SCREEN（滤色）。</p><h4 id="1-Mode-ADD（饱和度相加）"><a href="#1-Mode-ADD（饱和度相加）" class="headerlink" title="1. Mode.ADD（饱和度相加）"></a>1. Mode.ADD（饱和度相加）</h4><p>它的公式是 Saturate(S + D)。ADD 模式简单来说就是对 SRC 与 DST 两张图片相交区域的饱和度进行相加。使用 8.2.1 节中的例子，将 PorterDuff.Mode.SRC_IN 改为 PorterDuff.Mode.ADD，效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-272826d11c1fe6df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从效果图中可以看出，只有源图与目标图像相交的部分的图像的饱和度产生了变化，没相交的部分是没有变的，因为对方的饱和度是 0，当然不相交的位置饱和度是不会变的。这个模式的应用范围比较少，暂时想不到哪里会用到。</p><h4 id="2-Mode-LIGHTEN（变亮）"><a href="#2-Mode-LIGHTEN（变亮）" class="headerlink" title="2. Mode.LIGHTEN（变亮）"></a>2. Mode.LIGHTEN（变亮）</h4><p>它的算法是： [Sa + Da - Sa * Da, Sc * (1 - Da) + Dc * (1 - Sa) + max(Sc, Dc)]。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0407b841d01c9059.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这个效果比较容易理解，两个图像重合的区域才会有颜色值变化，所以只有重合区域才有变亮的效果，源图像非重合的区域，由于对应区域的目标图像是空白像素，所以直接显示源图像。</p><p>在实际应用中，会出现这种情况：当选中一本书时，给这本书加上灯光效果，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a7a6238ac3259e1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap bmpDST, bmpSRC;</div><div class="line">    private PorterDuffXfermode mMode;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint = new Paint();</div><div class="line">        bmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.book_bg,null);</div><div class="line">        bmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.book_light,null);</div><div class="line">        mMode = new PorterDuffXfermode(PorterDuff.Mode.LIGHTEN);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG);</div><div class="line">        // 先画书架，做为目标图像</div><div class="line">        canvas.drawBitmap(bmpDST,0,0,mPaint);</div><div class="line">        mPaint.setXfermode(mMode);</div><div class="line">        // 再图光点</div><div class="line">        canvas.drawBitmap(bmpSRC,0,0,mPaint);</div><div class="line"></div><div class="line">        mPaint.setXfermode(null);</div><div class="line">        canvas.restoreToCount(layerId);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="3-Mode-DARKEN（变暗）"><a href="#3-Mode-DARKEN（变暗）" class="headerlink" title="3. Mode.DARKEN（变暗）"></a>3. Mode.DARKEN（变暗）</h4><p>对应公式是： [Sa + Da - Sa * Da, Sc * (1 - Da) + Dc * (1 - Sa) + max(Sc, Dc)]。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-208c3a7a05ec8be7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="4-Mode-MULTIPLY（正片叠底）"><a href="#4-Mode-MULTIPLY（正片叠底）" class="headerlink" title="4. Mode.MULTIPLY（正片叠底）"></a>4. Mode.MULTIPLY（正片叠底）</h4><p>公式是：[Sa * Da, Sc * Dc]。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-47b83c76e8a6ebc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从公式中可以看出，计算 Alpha 值时的公式是 Sa * Da，是用源图像的 Alpha 值乘以目标图像的 Alpha 值。由于源图像的非相交区域所对应的目标图像像素的 Alpha 是 0，所以结果像素的 Alpha 值仍是 0，源图像的非相交区域在计算后是透明的。</p><h4 id="5-Mode-OVERLAY（叠加）"><a href="#5-Mode-OVERLAY（叠加）" class="headerlink" title="5. Mode.OVERLAY（叠加）"></a>5. Mode.OVERLAY（叠加）</h4><p>Google 没有给出这种模式的算法，效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-59f7de884fff1620.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="6-Mode-SCREEN（滤色）"><a href="#6-Mode-SCREEN（滤色）" class="headerlink" title="6. Mode.SCREEN（滤色）"></a>6. Mode.SCREEN（滤色）</h4><p>对应公式是：[Sa + Da - Sa * Da, Sc + Dc - Sc * Dc]。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-272f4a1d4a6e941f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>到这里，这六种混合模式就讲完了，下面总结一下：</p><ul><li>这几种模式都是 PhotoShop 中存在的模式，是通过计算改变交合区域的颜色值的。</li><li>除了 Mode.MULTIPLY（正片叠底）会在目标图像透明时将结果对应区域置为透明，其它图像都不受目标图像透明像素影响，即源图像非交合部分保持原样。</li></ul><h4 id="7-示例：Twitter-标识的描边效果"><a href="#7-示例：Twitter-标识的描边效果" class="headerlink" title="7. 示例：Twitter 标识的描边效果"></a>7. 示例：Twitter 标识的描边效果</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d17cc37950a2fe6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在图一中，小鸟整个都是蓝色的。在图二中，只有小鸟的边缘部分是白色的，中间部分是透明的。在最终的合成图中：图一和图二中小鸟与边缘的是显示的，而且还有某种效果，但小鸟中间的区域变透明了，显示的是底部 Activity 的背景色。</p><p>前面学到的几种样式中，只有 Mode.MULTIPLY（正片叠底）会在两个图像的一方透明时，结果像素就是透明的。所以这里使用的模式就是 Mode.MULTIPLY 模式。</p><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap bmpDST, bmpSRC;</div><div class="line">    private PorterDuffXfermode mMode;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint = new Paint();</div><div class="line">        bmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.twiter_bg,null);</div><div class="line">        bmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.twiter_light,null);</div><div class="line">        mMode = new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG);</div><div class="line">        </div><div class="line">        canvas.drawBitmap(bmpDST,0,0,mPaint);</div><div class="line">        mPaint.setXfermode(mMode);</div><div class="line">        canvas.drawBitmap(bmpSRC,0,0,mPaint);</div><div class="line"></div><div class="line">        mPaint.setXfermode(null);</div><div class="line">        canvas.restoreToCount(layerId);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d279d248c58ef680.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08.1 精通自定义 View 之 混合模式——AvoidXfermode</title>
      <link href="/2019/07/08/05%20CUSTOM%20VIEW/08.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AvoidXfermode/"/>
      <url>/2019/07/08/05%20CUSTOM%20VIEW/08.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AvoidXfermode/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="8-1-1-混合模式概述"><a href="#8-1-1-混合模式概述" class="headerlink" title="8.1.1 混合模式概述"></a>8.1.1 混合模式概述</h3><p>混合模式能够将两张图片无缝结合，实现类似 Photoshop 中的两张图片融合效果。</p><p>混合模式是通过 Paint 类中的 Xfermode setXfermode(Xfermode xfermode) 函数实现的，它的参数 Xfermode 是一个空类，主要靠它的子类来实现不同的功能，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2b8b059439df3bc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在启舰的书里派生自 Xfermode 的子类有 AvoidXfermode、PixelXorXfermode 和 PorterDuffXfermode，并且讲解了相关的知识。但笔者在 2019 年最新的官方文档中，已经找不到 AvoidXfermode 和 PixelXorXfermode 这两个类的相关文档，且在 AndroidX 系列中不支持相关 API。<a href="https://blog.csdn.net/harvic880925/article/details/51264653" target="_blank" rel="external">若想了解详情，请点击前往启舰的博客</a>。</p><p>在使用 Xfermode 时，需要做两件事。<br>1）禁用硬件加速<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setLayerType(View.LAYER_TYPE_SOFTWARE, null);</div></pre></td></tr></table></figure></p><p>2）使用离屏绘制（详见第九章）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 新建图层</div><div class="line">int layerId = canvas.saveLayer(0,0,getWidth(),getHeight(),null, Canvas.ALL_SAVE_FLAG);</div><div class="line"></div><div class="line">// 核心绘制代码</div><div class="line">...</div><div class="line"></div><div class="line">// 还原图层</div><div class="line">canvas.restoreToCount(layerId);</div></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07.6 精通自定义 View 之 绘图进阶——Shader 之 RadialGradient</title>
      <link href="/2019/07/07/05%20CUSTOM%20VIEW/07.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20RadialGradient/"/>
      <url>/2019/07/07/05%20CUSTOM%20VIEW/07.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20RadialGradient/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-dd5291b888ce4390.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p>RadialGradient 是 Shader 的另一种实现，它的含义是放射渐变，即它会像一个放射源一样，从一个点开始向外扩散，从一种颜色变成另一种颜色。</p><p><div id="jump1"></div></p><h3 id="7-6-1-双色渐变"><a href="#7-6-1-双色渐变" class="headerlink" title="7.6.1 双色渐变"></a>7.6.1 双色渐变</h3><p>RadialGradient 有两个构造函数，分别能完成双色渐变和多色渐变。双色渐变的构造函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RadialGradient(float centerX, float centerY, float radius, </div><div class="line">        int centerColor, int edgeColor, Shader.TileMode tileMode)</div></pre></td></tr></table></figure></p><ul><li>centerX：渐变中心点X坐标。</li><li>centerY：渐变中心点Y坐标。</li><li>radius：渐变半径。</li><li>centerColor：渐变的起始颜色，即渐变中心点的颜色,取值类型必须是八位的0xAARRGGBB色值！透明底Alpha值不能省略，不然不会显示出颜色。</li><li>edgeColor：渐变结束时的颜色，即渐变圆边缘的颜色，同样，取值类型必须是八位的0xAARRGGBB色值。</li><li>TileMode：与我们前面讲的各个Shader一样，用于指定当控件区域大于指定的渐变区域时，空白区域的颜色填充方式。</li></ul><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class TestView extends AppCompatTextView &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private RadialGradient mRadialGradient;</div><div class="line">    private int mRadius;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = getPaint();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</div><div class="line">        super.onSizeChanged(w, h, oldw, oldh);</div><div class="line">        mRadius = w / 5;</div><div class="line">        mRadialGradient = new RadialGradient(w / 2f, h / 2f, mRadius, 0xffff0000, 0xff00ff00, Shader.TileMode.CLAMP);</div><div class="line">        mPaint.setShader(mRadialGradient);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawCircle(getWidth()/2f, getHeight()/2f, mRadius, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-22066725bd2f934f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><div id="jump2"></div></p><h3 id="7-6-2-多色渐变"><a href="#7-6-2-多色渐变" class="headerlink" title="7.6.2 多色渐变"></a>7.6.2 多色渐变</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RadialGradient(float centerX, float centerY, float radius, </div><div class="line">        int[] colors, float[] stops, Shader.TileMode tileMode)</div></pre></td></tr></table></figure><ul><li>int[] colors：表示所需要的渐变颜色数组。<br>+float[] stops：表示每个渐变颜色所在的位置百分点，取值 0~1，数量必须与 colors 数组保持一致，不然直接 crash。一般第一个数值取 0，最后一个数值取 1，比如，取一个位置数组：{0.2,0.5,0.8}，起始点是0.2百分比位置，结束点是0.8百分比位置，而 0~0.2 百分比位置和 0.8~1.0 百分比的位置都是没有指定颜色的。这些位置的颜色就是根据我们指定的 TileMode 空白区域填充模式来自行填充。但有时效果我们是不可控的。所以，为了方便起见，建议大家 stop 数组的起始和终止数值设为 0 和 1。</li></ul><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class TestView extends AppCompatTextView &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private RadialGradient mRadialGradient;</div><div class="line">    private int mRadius;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = getPaint();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</div><div class="line">        super.onSizeChanged(w, h, oldw, oldh);</div><div class="line">        mRadius = w / 5;</div><div class="line">        int[] colors = &#123;0xffff0000, 0xff00ff00, 0xff0000ff, 0xffffff00&#125;;</div><div class="line">        float[] stops = &#123;0f, 0.2f, 0.5f, 1f&#125;;</div><div class="line">        mRadialGradient = new RadialGradient(w / 2f, h / 2f, mRadius, colors, stops, Shader.TileMode.CLAMP);</div><div class="line">        mPaint.setShader(mRadialGradient);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawCircle(getWidth()/2f, getHeight()/2f, mRadius, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d5a4aac06acfb365.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><div id="jump3"></div></p><h3 id="7-6-3-TileMode-填充模式"><a href="#7-6-3-TileMode-填充模式" class="headerlink" title="7.6.3 TileMode 填充模式"></a>7.6.3 TileMode 填充模式</h3><p>在 RadialGradient 构造函数中，只有一个 TileMode 参数，这说明当填充空白区域时，X 轴和 Y 轴使用同一种填充模式。而不能像 BitmapShader 那样分别指定 X 轴与 Y 轴的填充参数。</p><p>分别设置填充模式为：TileMode.CLAMP、TileMode.MIRROR、TileMode.REPEAT。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7290d14d66a44d1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TileMode.CLAMP"></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-034e859f3e78b1a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TileMode.MIRROR"></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-84766214e50ca249.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TileMode.REPEAT"></p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class TestView extends AppCompatTextView &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private RadialGradient mGradient;</div><div class="line">    private int mRadius;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = getPaint();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</div><div class="line">        super.onSizeChanged(w, h, oldw, oldh);</div><div class="line">        mRadius = w / 10;</div><div class="line">        mGradient = new RadialGradient(w / 2f, h / 2f, mRadius, 0xffff0000, 0xff00ff00, Shader.TileMode.REPEAT);</div><div class="line">        mPaint.setShader(mGradient);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawRect(0, 0, getWidth(), getHeight(), mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><div id="jump4"></div></p><h3 id="7-6-4-示例：水波纹按钮效果"><a href="#7-6-4-示例：水波纹按钮效果" class="headerlink" title="7.6.4 示例：水波纹按钮效果"></a>7.6.4 示例：水波纹按钮效果<div id="jump4"></div></h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c5bfca27e35260ff.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">public class TestView extends AppCompatButton &#123;</div><div class="line"></div><div class="line">    private int mX, mY;</div><div class="line">    private ObjectAnimator mAnimator;</div><div class="line">    private int DEFAULT_RADIUS = 50;</div><div class="line">    private int mCurRadius = 0;</div><div class="line">    private RadialGradient mRadialGradient;</div><div class="line">    private Paint mPaint;</div><div class="line"></div><div class="line">    public TestView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs, int defStyle) &#123;</div><div class="line">        super(context, attrs, defStyle);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE,null);</div><div class="line">        mPaint = new Paint();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        if (mX != event.getX() || mY != mY) &#123;</div><div class="line">            mX = (int) event.getX();</div><div class="line">            mY = (int) event.getY();</div><div class="line">            setRadius(DEFAULT_RADIUS);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (event.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">            return true;</div><div class="line">        &#125; else if (event.getAction() == MotionEvent.ACTION_UP) &#123;</div><div class="line">            if (mAnimator != null &amp;&amp; mAnimator.isRunning()) &#123;</div><div class="line">                mAnimator.cancel();</div><div class="line">            &#125;</div><div class="line">            if (mAnimator == null) &#123;</div><div class="line">                mAnimator = ObjectAnimator.ofInt(this, &quot;radius&quot;, </div><div class="line">                    DEFAULT_RADIUS, getWidth());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mAnimator.setInterpolator(new AccelerateInterpolator());</div><div class="line">            mAnimator.addListener(new Animator.AnimatorListener() &#123;</div><div class="line">                @Override</div><div class="line">                public void onAnimationStart(Animator animation) &#123;&#125;</div><div class="line">                @Override</div><div class="line">                public void onAnimationEnd(Animator animation) &#123;</div><div class="line">                    setRadius(0);</div><div class="line">                &#125;</div><div class="line">                @Override</div><div class="line">                public void onAnimationCancel(Animator animation) &#123;&#125;</div><div class="line">                @Override</div><div class="line">                public void onAnimationRepeat(Animator animation) &#123;&#125;</div><div class="line">            &#125;);</div><div class="line">            mAnimator.start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setRadius(final int radius) &#123;</div><div class="line">        mCurRadius = radius;</div><div class="line">        if (mCurRadius &gt; 0) &#123;</div><div class="line">            mRadialGradient = new RadialGradient(mX, mY, mCurRadius, 0x00FFFFFF, </div><div class="line">                0xFF58FAAC, Shader.TileMode.CLAMP);</div><div class="line">            mPaint.setShader(mRadialGradient);</div><div class="line">        &#125;</div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        canvas.drawCircle(mX, mY, mCurRadius, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d61edf0ac133e6b6.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07.5 精通自定义 View 之 绘图进阶——Shader 之 LinearGradient</title>
      <link href="/2019/07/07/05%20CUSTOM%20VIEW/07.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20LinearGradient/"/>
      <url>/2019/07/07/05%20CUSTOM%20VIEW/07.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20LinearGradient/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1df0a28c6079dd1d.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p>通过 LinearGradient 可以实现线性渐变效果。</p><p><div id="jump1"></div></p><h3 id="7-5-1-概述"><a href="#7-5-1-概述" class="headerlink" title="7.5.1 概述"></a>7.5.1 概述</h3><h4 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1. 构造函数"></a>1. 构造函数</h4><p>第一个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public LinearGradient(float x0, float y0, float x1, float y1,</div><div class="line">        int color0, int color1, TileMode tile)</div></pre></td></tr></table></figure></p><ul><li>(x0,y0) ：起始渐变点坐标；(x1,y1) ：结束渐变点坐标。</li><li>color0：起始颜色；color1：终止颜色。颜色值必须使用 0xAARRGGBB 形式的 16 进制表示，表示透明度的 AA 一定不能少。</li><li>TileMode tile：与 BitmapShader 一样，用于指定控件区域大于指定的渐变区域时，空白区域的颜色填充方法。</li></ul><p>第二个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public LinearGradient(float x0, float y0, float x1, float y1,</div><div class="line">        int colors[], float positions[], TileMode tile)</div></pre></td></tr></table></figure></p><ul><li>colors[]：用于指定渐变的颜色值数组。同样，颜色值必须使用 0xAARRGGBB 形式的 16 进制表示，表示透明度的 AA 一定不能少。</li><li>positions[]：与渐变的颜色相对应，取值是 0-1 的 float 类型，表示在每一个颜色在整条渐变线中的百分比位置</li></ul><h4 id="2-双色渐变使用示例"><a href="#2-双色渐变使用示例" class="headerlink" title="2. 双色渐变使用示例"></a>2. 双色渐变使用示例</h4><p>自定义一个从左到右的双色渐变控件，代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private int mWidth, mHeight;</div><div class="line">    private LinearGradient mLinearGradient;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</div><div class="line">        super.onSizeChanged(w, h, oldw, oldh);</div><div class="line">        mWidth = getMeasuredWidth();</div><div class="line">        mHeight = getMeasuredHeight();</div><div class="line">        mLinearGradient = new LinearGradient(0, mHeight / 2f, mWidth, mHeight / 2f,</div><div class="line">                0xFFFF0000, 0xFF00FF00, Shader.TileMode.CLAMP);</div><div class="line">        mPaint.setShader(mLinearGradient);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawRect(0, 0, mWidth, mHeight, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-bd6dbc498b7ed192.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="3-多色渐变使用示例"><a href="#3-多色渐变使用示例" class="headerlink" title="3. 多色渐变使用示例"></a>3. 多色渐变使用示例</h4><p>在上面示例的基础上，使用多色渐变来构造 LinearGradient 实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private int mWidth, mHeight;</div><div class="line">    private LinearGradient mLinearGradient;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</div><div class="line">        super.onSizeChanged(w, h, oldw, oldh);</div><div class="line">        mWidth = getMeasuredWidth();</div><div class="line">        mHeight = getMeasuredHeight();</div><div class="line">        int[] colors = &#123;0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFFFFFF00, 0xFF00FFFF&#125;;</div><div class="line">        float[] pos = &#123;0f, 0.2f, 0.4f, 0.6f, 1.0f&#125;;</div><div class="line">        mLinearGradient = new LinearGradient(0, mHeight / 2f, mWidth, mHeight / 2f,</div><div class="line">                colors, pos, Shader.TileMode.CLAMP);</div><div class="line">        mPaint.setShader(mLinearGradient);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawRect(0, 0, mWidth, mHeight, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2d1eccd29d3cf068.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从这里可以看出，渐变的开始点同样是控件左边中点，渐变的结束点也同样是控件右边中点；这里我们指定了五种渐变颜色，而且指定了每个颜色的位置，前四种颜色是按 20% 均匀分布的，最后两种颜色相距 40%；最后通过 canvas.drawRect() 函数把整个控件区域画出来。</p><p>注意：colors 和 pos 的个数一定要相等，也就是说必须指定每一个颜色值的位置。如果元素个数不相等，则会直接报错，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b3a9b6144803c90f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="4-TileMode-填充模式"><a href="#4-TileMode-填充模式" class="headerlink" title="4. TileMode 填充模式"></a>4. TileMode 填充模式</h4><p>从构造函数中可以看出，LiearGradient 只有一个 TileMode 参数，这说明 X 轴与 Y 轴共用这一个 TileMode 填充参数，而不能像 BitmapShader 那样分别指定 X 轴与 Y 轴的填充参数。</p><p>示例：分别指定不同的填充模式</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d78f1af0694fccb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="从上到下依次为：CLAMP、MIRROR、REPEAT"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private int mWidth, mHeight;</div><div class="line">    private LinearGradient mGradientCLAMP, mGradientMIRROR, mGradientREPEAT;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</div><div class="line">        super.onSizeChanged(w, h, oldw, oldh);</div><div class="line">        mWidth = getMeasuredWidth();</div><div class="line">        mHeight = 200;</div><div class="line">        int[] colors = &#123;0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFFFFFF00, 0xFF00FFFF&#125;;</div><div class="line">        float[] pos = &#123;0f, 0.2f, 0.4f, 0.6f, 1.0f&#125;;</div><div class="line">        mGradientCLAMP = new LinearGradient(0, 0, mWidth / 2f, mHeight / 2f,</div><div class="line">                colors, pos, Shader.TileMode.CLAMP);</div><div class="line">        mGradientMIRROR = new LinearGradient(0, mHeight, mWidth / 2f, mHeight * 3f / 2,</div><div class="line">                colors, pos, Shader.TileMode.MIRROR);</div><div class="line">        mGradientREPEAT = new LinearGradient(0, mHeight * 2f, mWidth / 2f, mHeight*5 / 2f,</div><div class="line">                colors, pos, Shader.TileMode.REPEAT);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        mPaint.setShader(mGradientCLAMP);</div><div class="line">        canvas.drawRect(0, 0, mWidth, mHeight, mPaint);</div><div class="line">        mPaint.setShader(mGradientMIRROR);</div><div class="line">        canvas.drawRect(0, mHeight, mWidth, mHeight * 2, mPaint);</div><div class="line">        mPaint.setShader(mGradientREPEAT);</div><div class="line">        canvas.drawRect(0, mHeight * 2, mWidth, mHeight * 3, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="5-Shader-填充与显示区域"><a href="#5-Shader-填充与显示区域" class="headerlink" title="5. Shader 填充与显示区域"></a>5. Shader 填充与显示区域</h4><p>所有 Shader 都是一样的：Shader 的布局和显示是分离的；Shader 总是从控件的左上角开始布局的；如果单张图片无法覆盖整个控件，则会使用 TileMode 重复模式来填充空白区域；而 canvas.draw 系列函数则只表示哪部分区域被显示出来。</p><p>下面利用 drawText() 函数实现一个渐变文字效果。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d3c178884edce57a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private String mText;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setTextSize(80);</div><div class="line">        mText = &quot;欢迎关注先先生的Blog&quot;;</div><div class="line"></div><div class="line">        float width = mPaint.measureText(mText);</div><div class="line">        int[] colors = &#123;0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFFFFFF00, 0xFF00FFFF&#125;;</div><div class="line">        float[] pos = &#123;0f, 0.2f, 0.4f, 0.6f, 1.0f&#125;;</div><div class="line">        LinearGradient gradient = new LinearGradient(0, 0, width / 2f, 0,</div><div class="line">                colors, pos, Shader.TileMode.MIRROR);</div><div class="line">        mPaint.setShader(gradient);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawText(mText, 0, 100, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><div id="jump2"></div></p><h3 id="7-5-2-示例：闪光文字效果"><a href="#7-5-2-示例：闪光文字效果" class="headerlink" title="7.5.2 示例：闪光文字效果"></a>7.5.2 示例：闪光文字效果</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1df20933fc32f800.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public class TestView extends AppCompatTextView &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private LinearGradient mLinearGradient;</div><div class="line">    private int mDx;</div><div class="line">    private Matrix mMatrix;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = getPaint();</div><div class="line">        mMatrix = new Matrix();</div><div class="line">        int length = (int) mPaint.measureText(getText().toString());</div><div class="line">        createAnim(length);</div><div class="line">        createLinearGradient(length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void createAnim(int length) &#123;</div><div class="line">        ValueAnimator animator = ValueAnimator.ofInt(0, 2 * length);</div><div class="line">        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">                mDx = (Integer) animation.getAnimatedValue();</div><div class="line">                postInvalidate();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        animator.setRepeatMode(ValueAnimator.RESTART);</div><div class="line">        animator.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">        animator.setDuration(2000);</div><div class="line">        animator.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void createLinearGradient(int length) &#123;</div><div class="line">        mLinearGradient = new LinearGradient(-length, 0, 0, 0,</div><div class="line">                new int[]&#123;getCurrentTextColor(), 0xFF00FF00, getCurrentTextColor()&#125;,</div><div class="line">                new float[]&#123;0, 0.5f, 1&#125;,</div><div class="line">                Shader.TileMode.CLAMP);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        mMatrix.reset();</div><div class="line">        mMatrix.setTranslate(mDx, 0);</div><div class="line">        mLinearGradient.setLocalMatrix(mMatrix);</div><div class="line">        mPaint.setShader(mLinearGradient);</div><div class="line"></div><div class="line">        super.onDraw(canvas);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 res/layout/act_main.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line">    &lt;com.xxt.xtest.TestView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_margin=&quot;20dp&quot;</div><div class="line">        android:textSize=&quot;24sp&quot;</div><div class="line">        android:text=&quot;欢迎关注先先生的Blog&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>控件派生自 TextView 的子类，所以可以使用 TextView 的自带方法 getCurrentTextColor() 来获取文字颜色、画笔、文字长度等；利用 Shader.setLocalMatrix(Matrix localM) 设置逐渐平移的矩阵，最后用 ValueAnimator 来控制矩阵平移的位移 mDx，移动距离是从 0 到两倍的 text 距离。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f4923d1208c4d342.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07.4 精通自定义 View 之 绘图进阶——Shader 与 BitmapShader</title>
      <link href="/2019/07/07/05%20CUSTOM%20VIEW/07.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B8%8E%20BitmapShader/"/>
      <url>/2019/07/07/05%20CUSTOM%20VIEW/07.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B8%8E%20BitmapShader/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f8a7b8e535ad26c0.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="7-4-1-Shader-概述"><a href="#7-4-1-Shader-概述" class="headerlink" title="7.4.1 Shader 概述"></a>7.4.1 Shader 概述</h3><p>Shader 在三维软件中称之为着色器，是用来给空白图形上色用的。在 PhotoShop 中有一个印章工具，能够指定印章的样式来填充图形。印章的样式可以是图像、颜色、渐变色等。这里的 Shader 实现的效果与印章类似。我们也是通过给 Shader 指定对应的图像、渐变色等来填充图形的。Paint 中有一个函数专门用于设置 Shader，其声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public Shader setShader(Shader shader)</div></pre></td></tr></table></figure></p><p>Shader 类只是一个基类，其中只有两个函数 setLocalMatrix(Matrix localM) 和 getLocalMatrix(Matrix localM)，用来设置坐标变换矩阵的。</p><p>Shader 类其实是一个空类，它的功能主要是靠它的派生类来实现的。继承关系如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f0612d7804eb21c1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><div id="jump2"></div></p><h3 id="7-4-2-BitmapShader-的基本用法"><a href="#7-4-2-BitmapShader-的基本用法" class="headerlink" title="7.4.2 BitmapShader 的基本用法"></a>7.4.2 BitmapShader 的基本用法</h3><p>它的构造函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public BitmapShader(Bitmap bitmap, TileMode tileX, TileMode tileY)</div></pre></td></tr></table></figure></p><p>这就相当于 PhotoShop 中的印章工具，bitmap 用来指定图案，tileX 用来指定当 X 轴超出单个图片大小时时所使用的重复策略，同样 tileY 用于指定当 Y 轴超出单个图片大小时时所使用的重复策略。</p><p>其中TileMode的取值有：</p><ul><li>TileMode.CLAMP：用边缘色彩填充多余空间。</li><li>TileMode.REPEAT：重复原图像来填充多余空间。</li><li>TileMode.MIRROR：重复使用镜像模式的图像来填充多余空间。</li></ul><h4 id="1-示例"><a href="#1-示例" class="headerlink" title="1. 示例"></a>1. 示例</h4><p>这里使用的印章图像如下图所示 (dog.png)。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-06b392e88addc2f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>中间是一幅小狗头像，四周被四种不同的颜色给包围。设置 Shader 的完整代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        Bitmap mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.dog_edge);</div><div class="line">        mPaint.setShader(new BitmapShader(mBitmap, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawRect(0, 0, getWidth(), getHeight(), mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果图如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-3148e2d732cb7ba9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>给自定义的控件添加上宽高限制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;!--&lt;com.xxt.xtest.TestView</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot; /&gt;--&gt;</div><div class="line">&lt;com.xxt.xtest.TestView</div><div class="line">    android:layout_width=&quot;300dp&quot;</div><div class="line">    android:layout_height=&quot;450dp&quot;</div><div class="line">    android:layout_gravity=&quot;center_horizontal&quot;/&gt;</div></pre></td></tr></table></figure></p><p>效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-6d202b7ca6dc61aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从效果图中可以看出：</p><ul><li>在 X 轴和 Y 轴都使用 REPEAT 模式下，在超出单个图像的区域后，就会重复绘制这个图像。</li><li>绘制是从控件的左上角开始的，而不是从屏幕原点开始的。这点很好理解，因为我们只会在自定义控件上绘图，不会在全屏幕上绘图。</li></ul><h4 id="2-TileMode-模式解析"><a href="#2-TileMode-模式解析" class="headerlink" title="2. TileMode 模式解析"></a>2. TileMode 模式解析</h4><p>上面初步看到了 REPEAT 模式的用法，现在我们分别来看在各个模式下的不同表现。<br><strong>1）TileMode.REPEAT 模式：重复原图像来填充多余空间</strong><br>在更改模式时，只需要更新 setShader 里的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mPaint.setShader(new BitmapShader(mBmp, TileMode.REPEAT, TileMode.REPEAT));</div></pre></td></tr></table></figure></p><p>在这里，X 轴、Y 轴全部设置成 REPEAT 模式，所以当控件的显示范围超出了单个图的显示范围时，在 X 轴上将使用 REPEAT 模式；同样，在 Y 轴上也将使用 REPEAT 模式。</p><p><strong>2）TileMode.MIRROR 模式：重复使用镜像模式的图像来填充多余空间</strong><br>同样，将 X 轴、Y 轴全部改为 MIRROR 模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mPaint.setShader(new BitmapShader(mBmp, TileMode.MIRROR, TileMode.MIRROR));</div></pre></td></tr></table></figure></p><p>效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1acfebf405a0e336.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在 X 轴上每两张图片的显示都像镜子一样翻转一下。同样，在 Y 轴上每两张图片的显示也都像镜子一样翻转一下。所以这就是镜相效果的作用，镜像效果其实就是在显示下一图片的时候，就相当于两张图片中间放了一个镜子一样。</p><p><strong>3）TileMode.CLAMP：用边缘色彩填充多余空间</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mPaint.setShader(new BitmapShader(mBmp, TileMode.CLAMP, TileMode.CLAMP));</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a3d0c5b36c613db1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>CLAMP 模式的意思就是当控件区域超过当前单个图片的大小时，空白位置的颜色填充就用图片的边缘颜色来填充。</p><p><strong>4）TileMode.CLAMP 与填充顺序</strong><br>当 X 轴、Y 轴全部都是 CLAMP 模式时，X 轴的空白区域会用图像的右侧边缘颜色来填充；Y 轴的空白区域会用图像的底部的边缘颜色来填充，那效果应该是这样的：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-8a5b91ff64280b8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>明显右下角的空白位置根本与图像是不沾边的，那它要用什么颜色来填充呢？是填充上方的蓝色还是填充左侧的绿色呢？</p><p>从最终的效果图来看，这部分填充的颜色是绿色的，可为什么呢？其实这是跟填充顺序有关的，并且是先填充竖向再填充横向。如果是先填充横向再填充竖向，那么右下角颜色应该是蓝色。</p><p><strong>4）使用混合填充模式</strong><br>比如在 X 轴填充空白区域时使用 MIRROR 样式、在填充 Y 轴空白区域时使用REPEAT样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mPaint.setShader(new BitmapShader(mBmp, TileMode.MIRROR, TileMode.REPEAT));</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-9dbadb9051f8c178.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从效果图中可以看出来，首先使用 REPEAT 模式填充 Y 轴，然后使用 MIRROR 模式填充 X 轴。</p><blockquote><p>总之：无论哪两种模式混合或者相同模式，都是先填充 Y 轴，然后填充 X 轴。</p></blockquote><h4 id="3-绘图位置与图像显示"><a href="#3-绘图位置与图像显示" class="headerlink" title="3. 绘图位置与图像显示"></a>3. 绘图位置与图像显示</h4><p>在上面的例子中，我们利用 drawRect 把整个控件大小都给覆盖了，那假如我们只画一个小矩形而不完全覆盖整个控件，那我们 setShader() 函数中所设置的图片是从哪里开始画的呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        Bitmap mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.dog_edge);</div><div class="line">        mPaint.setShader(new BitmapShader(mBitmap, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        float left = getWidth() / 3f;</div><div class="line">        float top = getHeight() / 3f;</div><div class="line">        float right = getWidth() * 2f / 3;</div><div class="line">        float bottom = getHeight() * 2f / 3;</div><div class="line">        canvas.drawRect(left,top,right,bottom, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>即在绘图时，并不是完全覆盖控件大小的，而是取控件中间位置的 1/3 区域显示的。效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-bebdbf0c243f7d16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><div id="jump3"></div></p><h3 id="7-4-3-示例一：望远镜效果"><a href="#7-4-3-示例一：望远镜效果" class="headerlink" title="7.4.3 示例一：望远镜效果"></a>7.4.3 示例一：望远镜效果</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d4a84ed28fe1ee93.gif?imageMogr2/auto-orient/strip" alt=""></p><p>这里要实现的效果是：根据手指所在的位置，把对应的图像绘制出来。这样看起来就是望远镜效果了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Rect mRect;</div><div class="line">    private int mDx = -1;</div><div class="line">    private int mDy = -1;</div><div class="line">    private Bitmap mBitmap, mBitmapBg;</div><div class="line">    private int mRadius = 300;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.meinv);</div><div class="line">        mRect = new Rect();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        switch (event.getAction()) &#123;</div><div class="line">            case MotionEvent.ACTION_DOWN:</div><div class="line">                mDx = (int) event.getX();</div><div class="line">                mDy = (int) event.getY();</div><div class="line">                invalidate();</div><div class="line">                return true;</div><div class="line">            case MotionEvent.ACTION_MOVE:</div><div class="line">                mDx = (int) event.getX();</div><div class="line">                mDy = (int) event.getY();</div><div class="line">                break;</div><div class="line">            case MotionEvent.ACTION_UP:</div><div class="line">            case MotionEvent.ACTION_CANCEL:</div><div class="line">                mDx = -1;</div><div class="line">                mDy = -1;</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        invalidate();</div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        if (mBitmapBg == null) &#123;</div><div class="line">            mBitmapBg = Bitmap.createBitmap(getWidth(), getHeight(), Bitmap.Config.ARGB_8888);</div><div class="line">            Canvas canvasBg = new Canvas(mBitmapBg);</div><div class="line">            mRect.set(0, 0, getWidth(), getHeight());</div><div class="line">            canvasBg.drawBitmap(mBitmap, null, mRect, mPaint);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mDx != -1 &amp;&amp; mDy != -1) &#123;</div><div class="line">            mPaint.setShader(new BitmapShader(mBitmapBg, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT));</div><div class="line">            canvas.drawCircle(mDx, mDy, mRadius, mPaint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们主要来看下 OnDraw() 函数：<br>在 onDraw() 函数中，第一部分，就是新建一个空白的 bitmap，这个 bitmap 的大小与控件一样，然后把我们的背景图进行拉伸，画到这个空白的 bitmap 上。由于这里的 canvasBg 是用 mBitmapBg 创建的，所以所画的任何图像都会直接显示在 mBitmapBg 上，而我们创建的 mBitmapBg 是与控件一样大的，所以当把 mBitmapBg 做为 Shader 来设置给 mPaint 时，mBitmapBg 会正好覆盖整个控件，而不会有多余的空白像素。</p><p>这里需要注意的就是我们在将原图像画到 mBitmapBg 时，进行了拉伸压缩，把它拉伸到和当前控件一样大小。然后利用 OnMotionEvent 来捕捉用户的手指位置，当用户手指下按时，在手指位置画一个半径为 mRadius 的圆形，把对应的位置的图像显示出来就可以了。</p><p><div id="jump4"></div></p><h3 id="7-4-4-示例二：生成不规则头像"><a href="#7-4-4-示例二：生成不规则头像" class="headerlink" title="7.4.4 示例二：生成不规则头像"></a>7.4.4 示例二：生成不规则头像</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-817a7e05511f03bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>res/values/attrs.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">    &lt;declare-styleable name=&quot;TestView&quot;&gt;</div><div class="line">        &lt;attr name=&quot;src&quot; format=&quot;reference&quot; /&gt;</div><div class="line">        &lt;attr name=&quot;format&quot; format=&quot;enum&quot;&gt;</div><div class="line">            &lt;enum name=&quot;circle&quot; value=&quot;0&quot;/&gt;</div><div class="line">            &lt;enum name=&quot;rectTangle&quot; value=&quot;1&quot;/&gt;</div><div class="line">        &lt;/attr&gt;</div><div class="line">        &lt;attr name=&quot;radius&quot; format=&quot;integer&quot; /&gt;</div><div class="line">    &lt;/declare-styleable&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure></p><p>自定义控件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap mBitmap;</div><div class="line">    private BitmapShader mBitmapShader;</div><div class="line">    private int mEnumFormat = 0;</div><div class="line">    private int mRadius = 5;</div><div class="line">    private RectF mRectF;</div><div class="line">    private Matrix mMatrix;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) throws Exception&#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init(context,attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs, int defStyle) throws Exception&#123;</div><div class="line">        super(context, attrs, defStyle);</div><div class="line">        init(context,attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init(Context context,AttributeSet attrs) throws Exception&#123;</div><div class="line">        // 提取属性定义</div><div class="line">        TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.TestView);</div><div class="line">        int BitmapID = typedArray.getResourceId(R.styleable.TestView_src,-1);</div><div class="line">        if (BitmapID == -1)&#123;</div><div class="line">            throw new Exception(&quot;TestView 需要定义 Src 属性，而且必须是图像&quot;);</div><div class="line">        &#125;</div><div class="line">        mBitmap = BitmapFactory.decodeResource(getResources(),BitmapID);</div><div class="line">        mEnumFormat = typedArray.getInt(R.styleable.TestView_format,0);</div><div class="line">        if (mEnumFormat == 1)&#123;</div><div class="line">            mRadius = typedArray.getInt(R.styleable.TestView_radius,5);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        typedArray.recycle();</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mBitmapShader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);</div><div class="line">        mRectF = new RectF();</div><div class="line">        mMatrix = new Matrix();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">        int measureWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        int measureHeight = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">        int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">        int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"></div><div class="line">        int width = mBitmap.getWidth();</div><div class="line">        int height = mBitmap.getHeight();</div><div class="line">        width = (measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth: width;</div><div class="line">        height = (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight: height;</div><div class="line">        setMeasuredDimension(width, height);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        float scale = (float) getWidth()/mBitmap.getWidth();</div><div class="line">        mMatrix.reset();</div><div class="line">        mMatrix.setScale(scale, scale);</div><div class="line">        mBitmapShader.setLocalMatrix(mMatrix);</div><div class="line">        mPaint.setShader(mBitmapShader);</div><div class="line"></div><div class="line">        float half = getWidth() / 2f;</div><div class="line"></div><div class="line">        if (mEnumFormat == 0)&#123;</div><div class="line">            canvas.drawCircle(half, half, getWidth() / 2f, mPaint);</div><div class="line">        &#125; else if(mEnumFormat == 1)&#123;</div><div class="line">            mRectF.set(0, 0, getWidth(), getHeight());</div><div class="line">            canvas.drawRoundRect(mRectF, mRadius, mRadius, mPaint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 XML 中使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:padding=&quot;20dp&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line">    &lt;com.xxt.xtest.TestView</div><div class="line">        android:layout_width=&quot;50dp&quot;</div><div class="line">        android:layout_height=&quot;50dp&quot;</div><div class="line">        app:src=&quot;@drawable/meinv&quot;</div><div class="line">        app:format=&quot;circle&quot;/&gt;</div><div class="line">    &lt;com.xxt.xtest.TestView</div><div class="line">        android:layout_width=&quot;100dp&quot;</div><div class="line">        android:layout_height=&quot;100dp&quot;</div><div class="line">        app:src=&quot;@drawable/head&quot;</div><div class="line">        app:format=&quot;circle&quot;/&gt;</div><div class="line">    &lt;com.xxt.xtest.TestView</div><div class="line">        android:layout_width=&quot;100dp&quot;</div><div class="line">        android:layout_height=&quot;100dp&quot;</div><div class="line">        android:layout_marginTop=&quot;10dp&quot;</div><div class="line">        app:src=&quot;@drawable/meinv&quot;</div><div class="line">        app:format=&quot;rectTangle&quot;</div><div class="line">        app:radius=&quot;10&quot;/&gt;</div><div class="line">    &lt;com.xxt.xtest.TestView</div><div class="line">        android:layout_width=&quot;130dp&quot;</div><div class="line">        android:layout_height=&quot;130dp&quot;</div><div class="line">        android:layout_marginTop=&quot;10dp&quot;</div><div class="line">        app:src=&quot;@drawable/head&quot;</div><div class="line">        app:format=&quot;rectTangle&quot;</div><div class="line">        app:radius=&quot;30&quot;/&gt;</div><div class="line">    &lt;com.xxt.xtest.TestView</div><div class="line">        android:layout_width=&quot;150dp&quot;</div><div class="line">        android:layout_height=&quot;150dp&quot;</div><div class="line">        android:layout_marginTop=&quot;10dp&quot;</div><div class="line">        app:src=&quot;@drawable/meinv&quot;</div><div class="line">        app:format=&quot;rectTangle&quot;</div><div class="line">        app:radius=&quot;70&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e201f8934937ad76.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07.3 精通自定义 View 之 绘图进阶——BlurMaskFilter 发光效果与图片阴影</title>
      <link href="/2019/07/07/05%20CUSTOM%20VIEW/07.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94BlurMaskFilter%20%E5%8F%91%E5%85%89%E6%95%88%E6%9E%9C%E4%B8%8E%E5%9B%BE%E7%89%87%E9%98%B4%E5%BD%B1/"/>
      <url>/2019/07/07/05%20CUSTOM%20VIEW/07.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94BlurMaskFilter%20%E5%8F%91%E5%85%89%E6%95%88%E6%9E%9C%E4%B8%8E%E5%9B%BE%E7%89%87%E9%98%B4%E5%BD%B1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-275d667f1ad0f93f.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2c82cb72b3789dbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在这张效果图中涉及三个发光效果：文字、图形和位图。</p><p>从最后一张美女位图所形成的发光效果中可以看到，与 setShadowLayer() 函数一样，发光效果也只会影响边缘部分图像，内部图像是不受影响的。</p><p>从第三幅图像（红绿各一半的位图）中可以看到：发光效果是无法指定发光颜色的，采用边缘部分的颜色取样来进行模糊发光。所以边缘是什么颜色，发出的光也就是什么颜色的。</p><p>所以初步我们对发光效果有如下结论：</p><ul><li>与 setShadowLayer() 函数一样，发光效果使用的也是高斯模糊算法，并且只会影响边缘部分图像，内部图像是不受影响的。</li><li>发光效果是无法指定发光颜色的，采用边缘部分的颜色取样来进行模糊发光。所以边缘是什么颜色，发出的光也就是什么颜色的。</li></ul><p><div id="jump1"></div></p><h3 id="7-3-1-概述"><a href="#7-3-1-概述" class="headerlink" title="7.3.1 概述"></a>7.3.1 概述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public MaskFilter setMaskFilter(MaskFilter maskfilter)</div></pre></td></tr></table></figure><p>setMaskFilter() 函数中的 MaskFilter 也是没有具体实现的，是通过派生子类来实现具体的不同功能的。MaskFilter 有两个派生类：BlurMaskFilter 和 EmbossMaskFilter。其中，BlurMaskFilter 就能够实现发光效果；而 EmbossMaskFilter 则可以用于实现浮雕效果，用处很少，这里就不再讲解了。另一点需要注意的是，setMaskFilter() 函数是不支持硬件加速的，必须关闭硬件加速才可以。</p><p>BlurMaskFilter 的构造函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public BlurMaskFilter(float radius, Blur style)</div></pre></td></tr></table></figure></p><ul><li>float radius：用来定义模糊半径，同样是高斯模糊算法。</li><li>Blur style：发光样式，有内 Blur.INNER(内发光)、Blur.SOLID(外发光)、Blur.NORMAL(内外发光)、Blur.OUTER(仅发光部分可见)。</li></ul><p>上面效果图的示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint = new Paint();</div><div class="line">    private Bitmap mHeadBmp;</div><div class="line">    private Rect mRect;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init()&#123;</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setTextSize(50);</div><div class="line">        mHeadBmp = BitmapFactory.decodeResource(getResources(), R.drawable.head);</div><div class="line">        mRect = new Rect();</div><div class="line">        mPaint.setMaskFilter(new BlurMaskFilter(40, BlurMaskFilter.Blur.SOLID));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        canvas.drawText(&quot;xian小涛&quot;,100,100, mPaint);</div><div class="line">        canvas.drawCircle(300,300,50, mPaint);</div><div class="line">        mRect.set(300,500,300 + mHeadBmp.getWidth(),500 + mHeadBmp.getHeight());</div><div class="line">        canvas.drawBitmap(mHeadBmp,null, mRect, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>BlurStyle 发光效果图</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a54f96eedd8b3cf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="依次为：Blur.INNER(内发光)、Blur.SOLID(外发光)、Blur.NORMAL(内外发光)、Blur.OUTER(仅发光部分可见)"></p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private BlurMaskFilter inner, solid, normal, outer;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line"></div><div class="line">        inner = new BlurMaskFilter(40, BlurMaskFilter.Blur.INNER);</div><div class="line">        solid = new BlurMaskFilter(40, BlurMaskFilter.Blur.SOLID);</div><div class="line">        normal = new BlurMaskFilter(40, BlurMaskFilter.Blur.NORMAL);</div><div class="line">        outer = new BlurMaskFilter(40, BlurMaskFilter.Blur.OUTER);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        mPaint.setMaskFilter(inner);</div><div class="line">        canvas.drawCircle(200,200,100, mPaint);</div><div class="line"></div><div class="line">        canvas.translate(300, 0);</div><div class="line">        mPaint.setMaskFilter(solid);</div><div class="line">        canvas.drawCircle(200,200,100, mPaint);</div><div class="line"></div><div class="line">        canvas.translate(300, 0);</div><div class="line">        mPaint.setMaskFilter(normal);</div><div class="line">        canvas.drawCircle(200,200,100, mPaint);</div><div class="line"></div><div class="line">        canvas.translate(300, 0);</div><div class="line">        mPaint.setMaskFilter(outer);</div><div class="line">        canvas.drawCircle(200,200,100, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>其中，Blur.OUTER 比较特殊，在这种模式下仅显示发光效果，会把原图像中除发光部分外的其他部分全部变为透明。</p></blockquote><p><div id="jump2"></div></p><h3 id="7-3-2-给图片添加纯色阴影"><a href="#7-3-2-给图片添加纯色阴影" class="headerlink" title="7.3.2 给图片添加纯色阴影"></a>7.3.2 给图片添加纯色阴影</h3><p>大家是否可以看出来发光效果与 setShadowLayer() 函数所生成的阴影之间有什么联系？</p><p>先来分析一下 setShadowLayer() 函数的阴影形成过程（假定阴影画笔是灰色）。对于文字和图形，它首先产生一个跟原型一样的灰色副本。然后对这个灰色副本应用 BlurMaskFilter，使其内外发光；这样就形成了所谓的阴影，当然最后再偏移一段距离。</p><p>所以，我们要给图片添加灰色阴影效果，就可以仿照这个过程：先绘制一幅跟图片一样大小的灰色图像，然后给这个灰色图形应用 BlurMaskFilter 使其内外发光，最后偏移原图形一段距离绘制阴影。</p><p>这里涉及到三个点：</p><ul><li>绘制一幅跟图片一样大小的灰色图像。</li><li>对灰色图像应用 BlurMaskFilter 使其内外发光。</li><li>偏移原图形一段距离绘制阴影。</li></ul><h4 id="1-抽取灰色图像"><a href="#1-抽取灰色图像" class="headerlink" title="1. 抽取灰色图像"></a>1. 抽取灰色图像</h4><p>首先来看怎么能绘出一个指定位图所对应的灰色图像。我们知道 canvas.drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint) 中的画笔颜色对画出来的位图是没有任何影响的，所以，如果我们需要画一张对应的灰色图像，就需要新建一张一样大小的空白图，而且新图片的透明度要与原图片保持一致。这样一来，如何从原图片中抽出 Alpha 值成为关键。即我们只需要创建一个与原图片一样大小且 Alpha 相同的图片即可。</p><p>其实，Bitmap 中已经存在抽取出只具有 Alpha 值图片的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public Bitmap extractAlpha();</div></pre></td></tr></table></figure></p><p>这个函数的功能是：新建一张空白图片，该图片具有与原图片一样的 Alpha 值，把这个新建的 Bitmap 作为结果返回。这个空白图片中每个像素都具有与原图片一样的 Alpha 值，而且具体的颜色是在使用canvas.drawBitmap() 函数绘制时由传入的画笔颜色指定的。</p><p><strong>总结：extractAlpha() 会新建一幅仅具有 Alpha 值的空白图像，而且这张图像的颜色是在使用 canvas.drawBitmap() 函数绘制时传入的画笔颜色指定的。</strong></p><p>下面拿一张图片来做实验，这张 PNG 图片中，只有一只小狗，其余地方都是透明色。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0fa63d9969df5489.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>下面分别利用 extractAlpha() 函数画出该图片所对应的灰色和黑色阴影，效果图如下所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ca07885ef1838c7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原图、灰色阴影、黑色阴影"></p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap mBitmap, mAlphaBmp;</div><div class="line">    private Rect mRect;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mRect = new Rect();</div><div class="line">        mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.dog);</div><div class="line">        mAlphaBmp = mBitmap.extractAlpha();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        int width = 200;</div><div class="line">        int height = width * mAlphaBmp.getHeight() / mAlphaBmp.getWidth();</div><div class="line">        // 绘制原图</div><div class="line">        mRect.set(50, 50, 50 + width, 50 + height);</div><div class="line">        canvas.drawBitmap(mBitmap, null, mRect, mPaint);</div><div class="line">        // 绘制灰色阴影</div><div class="line">        canvas.translate(width + 100, 0);</div><div class="line">        mPaint.setColor(Color.GRAY);</div><div class="line">        canvas.drawBitmap(mAlphaBmp, null, mRect, mPaint);</div><div class="line">        // 绘制黑色阴影</div><div class="line">        canvas.translate(width + 100, 0);</div><div class="line">        mPaint.setColor(Color.BLACK);</div><div class="line">        canvas.drawBitmap(mAlphaBmp, null, mRect, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="2-绘制阴影"><a href="#2-绘制阴影" class="headerlink" title="2. 绘制阴影"></a>2. 绘制阴影</h4><p>在上面灰色纯色图像的基础上，将此灰色图像使用 BlurMaskFilter 使其内外发光。然后再在灰色模糊阴影的基础上画上原图像，就形成了模糊阴影。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap mBitmap, mAlphaBmp;</div><div class="line">    private Rect mRect;</div><div class="line">    private BlurMaskFilter mFilter;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mRect = new Rect();</div><div class="line">        mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.dog);</div><div class="line">        mAlphaBmp = mBitmap.extractAlpha();</div><div class="line">        mFilter = new BlurMaskFilter(30, BlurMaskFilter.Blur.NORMAL);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        int width = 200;</div><div class="line">        int height = width * mAlphaBmp.getHeight() / mAlphaBmp.getWidth();</div><div class="line">        mRect.set(50, 50, 50 + width, 50 + height);</div><div class="line"></div><div class="line">        // 绘制灰色阴影</div><div class="line">        mPaint.setColor(Color.GRAY);</div><div class="line">        mPaint.setMaskFilter(mFilter);</div><div class="line">        canvas.drawBitmap(mAlphaBmp, null, mRect, mPaint);</div><div class="line"></div><div class="line">        // 绘制原图</div><div class="line">        mPaint.setMaskFilter(null);</div><div class="line">        canvas.translate(-10, -10);</div><div class="line">        canvas.drawBitmap(mBitmap, null, mRect, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-64d6af67e125a769.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><div id="jump3"></div></p><h3 id="7-3-3-封装控件"><a href="#7-3-3-封装控件" class="headerlink" title="7.3.3 封装控件"></a>7.3.3 封装控件</h3><p>将它封装成一个控件，具有如下功能：</p><ul><li>让用户定义图片内容。</li><li>让用户定义偏移距离。</li><li>让用户定义阴影颜色和阴影模糊程度。</li><li>可以使用 wrap_content 属性自适应大小。</li></ul><blockquote><p>下面程序经过多次测试，效果并不完美，待完善。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7a5cfd013c874038.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>res/values/xshadow.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">    &lt;declare-styleable name=&quot;XShadowImageView&quot;&gt;</div><div class="line">        &lt;attr name=&quot;src&quot; format=&quot;reference&quot;/&gt;</div><div class="line">        &lt;attr name=&quot;shadowDx&quot; format=&quot;integer&quot; /&gt;</div><div class="line">        &lt;attr name=&quot;shadowDy&quot; format=&quot;integer&quot; /&gt;</div><div class="line">        &lt;attr name=&quot;shadowColor&quot; format=&quot;color&quot;/&gt;</div><div class="line">        &lt;attr name=&quot;shadowRadius&quot; format=&quot;float&quot;/&gt;</div><div class="line">    &lt;/declare-styleable&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure></p><p>src/…/XShadowImageView.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">public class XShadowImageView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap mBitmap, mShadowBitmap;</div><div class="line">    private int mDx, mDy;</div><div class="line">    private float mRadius;</div><div class="line">    private int mShadowColor;</div><div class="line">    private BlurMaskFilter mBlurMaskFilter;</div><div class="line">    private Rect mRect;</div><div class="line"></div><div class="line">    public XShadowImageView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public XShadowImageView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">        init(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        // 禁用硬件加速</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line"></div><div class="line">        // 提取属性</div><div class="line">        TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.XShadowImageView);</div><div class="line">        mDx = ta.getInt(R.styleable.XShadowImageView_shadowDx, 0);</div><div class="line">        mDy = ta.getInt(R.styleable.XShadowImageView_shadowDy, 0);</div><div class="line">        mRadius = ta.getFloat(R.styleable.XShadowImageView_shadowRadius, 0);</div><div class="line">        mShadowColor = ta.getInt(R.styleable.XShadowImageView_shadowColor, Color.BLACK);</div><div class="line">        int bitmapId = ta.getResourceId(R.styleable.XShadowImageView_src, -1);</div><div class="line">        if (bitmapId != -1) &#123;</div><div class="line">            mBitmap = BitmapFactory.decodeResource(getResources(), bitmapId);</div><div class="line">        &#125;</div><div class="line">        ta.recycle();</div><div class="line"></div><div class="line">        // 其他初始化</div><div class="line">        mRect = new Rect();</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(mShadowColor);</div><div class="line">        mBlurMaskFilter = new BlurMaskFilter(mRadius, BlurMaskFilter.Blur.NORMAL);</div><div class="line">        if (mBitmap != null) &#123;</div><div class="line">            mShadowBitmap = mBitmap.extractAlpha();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">        int measureWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        int measureHeight = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">        int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">        int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"></div><div class="line">        int width = mBitmap.getWidth();</div><div class="line">        int height = mBitmap.getHeight();</div><div class="line">        width = (measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth: width;</div><div class="line">        height = (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight: height;</div><div class="line">        setMeasuredDimension(width, height);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        if (mBitmap != null) &#123;</div><div class="line">            int width = getWidth() - mDx;</div><div class="line">            int height = getHeight() - mDy;</div><div class="line"></div><div class="line">            // 绘制阴影</div><div class="line">            mPaint.setMaskFilter(mBlurMaskFilter);</div><div class="line">            mRect.set(mDx, mDy, width, height);</div><div class="line">            canvas.drawBitmap(mShadowBitmap, null, mRect, mPaint);</div><div class="line"></div><div class="line">            // 绘制原图像</div><div class="line">            mPaint.setMaskFilter(null);</div><div class="line">            mRect.set(0, 0, width, height);</div><div class="line">            canvas.drawBitmap(mBitmap, null, mRect, mPaint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.xxt.xtest.XShadowImageView</div><div class="line">        android:layout_width=&quot;100dp&quot;</div><div class="line">        android:layout_height=&quot;100dp&quot;</div><div class="line">        android:layout_gravity=&quot;center_horizontal&quot;</div><div class="line">        app:src=&quot;@drawable/head&quot;</div><div class="line">        app:shadowDx=&quot;30&quot;</div><div class="line">        app:shadowDy=&quot;30&quot;</div><div class="line">        app:shadowRadius=&quot;30.0&quot;</div><div class="line">        app:shadowColor=&quot;@android:color/black&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;com.xxt.xtest.XShadowImageView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_gravity=&quot;center_horizontal&quot;</div><div class="line">        app:src=&quot;@drawable/head&quot;</div><div class="line">        app:shadowDx=&quot;30&quot;</div><div class="line">        app:shadowDy=&quot;30&quot;</div><div class="line">        app:shadowRadius=&quot;30.0&quot;</div><div class="line">        app:shadowColor=&quot;@android:color/holo_red_dark&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;com.xxt.xtest.XShadowImageView</div><div class="line">        android:layout_width=&quot;260dp&quot;</div><div class="line">        android:layout_height=&quot;360dp&quot;</div><div class="line">        android:layout_gravity=&quot;center_horizontal&quot;</div><div class="line">        app:src=&quot;@drawable/meinv&quot;</div><div class="line">        app:shadowDx=&quot;40&quot;</div><div class="line">        app:shadowDy=&quot;40&quot;</div><div class="line">        app:shadowRadius=&quot;40.0&quot;</div><div class="line">        app:shadowColor=&quot;@android:color/holo_red_dark&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c8583fd4b069d137.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07.2 精通自定义 View 之 绘图进阶——setShadowLayer 与阴影效果</title>
      <link href="/2019/07/07/05%20CUSTOM%20VIEW/07.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94setShadowLayer%20%E4%B8%8E%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/"/>
      <url>/2019/07/07/05%20CUSTOM%20VIEW/07.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94setShadowLayer%20%E4%B8%8E%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-8f74a52450fe8d3d.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p>利用 layer-list 只能实现按钮的阴影效果，对于文字和图片都无法实现阴影效果，除了 layer-list，我们只能用自定义控件来实现阴影效果了，Paint 中有一个专门用来实现阴影效果的函数 setShadowLayer，我们先来看看这个函数实现的阴影效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-fea6ceb64d2ef245.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从效果图中可以看出 setShadowLayer 函数能够实现：</p><ul><li>定制阴影模糊程度</li><li>定制阴影偏移距离</li><li>清除阴影和显示阴影</li></ul><p><div id="jump1"></div></p><h3 id="7-2-1-setShadowLayer-构造函数"><a href="#7-2-1-setShadowLayer-构造函数" class="headerlink" title="7.2.1 setShadowLayer() 构造函数"></a>7.2.1 setShadowLayer() 构造函数</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void setShadowLayer(float radius, float dx, float dy, int color)</div></pre></td></tr></table></figure><ul><li>float radius：意思是模糊半径，radius 越大越模糊，越小越清晰，但是如果 radius 设置为 0，则阴影消失不见。</li><li>float dx：阴影的横向偏移距离，正值向右偏移，负值向左偏移。</li><li>float dy：阴影的纵向偏移距离，正值向下偏移，负值向上偏移。</li><li>int color：绘制阴影的画笔颜色，即阴影的颜色（对图片阴影无效）。</li></ul><p>setShadowLayer 使用的是高斯模糊算法，高斯模糊的具体算法是：对于正在处理的每一个像素，取周围若干个像素的 RGB 值并且平均，然后这个平均值就是模糊处理过的像素。如果对图片中的所有像素都这么处理的话，处理完成的图片就会变得模糊。其中，所取周围像素的半径就是模糊半径。所以，模糊半径越大，所得平均像素与原始像素相差就越大，也就越模糊。</p><p>绘制阴影的画笔颜色为什么对图片无效？</p><p>从上面的效果图中可以看出，使用 setShadowLayer 所产生的阴影，对于文字和绘制的图形的阴影都是使用自定义的阴影画笔颜色来画的；而图片的阴影则是直接产生一张相同的图片，仅对阴影图片的边缘进行模糊。之所以生成一张相同的背景图片，是因为如果统一使用某一种颜色来做阴影可能会与图片的颜色相差很大，而且不协调，比如某张图片的色彩非常丰富，而阴影如果使用灰色来做，可能就会显得很突兀，所以为了解决这个问题，针对图片的阴影就不再是统一颜色了，而是复制出这张图片，把复制出的图片的边缘进行模糊，做为阴影。但这样又会引起一个问题，就是如果我们想把图片的阴影做成灰色怎么办？使用 setShadowLayer 自动生成阴影是没办法了，在下篇我们会具体来讲，如何给图片添加指定颜色的阴影。</p><blockquote><p>注意：setShadowLayer 只有文字绘制阴影支持硬件加速，其它都不支持硬件加速，为了方便起见，需要在自定义控件中禁用硬件加速。</p></blockquote><h4 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-fc3493677e1727cb.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint = new Paint();</div><div class="line">    private Bitmap mHeadBmp;</div><div class="line">    private Rect mRect;</div><div class="line">    private int mRadius = 1;</div><div class="line">    private int mDx = 10;</div><div class="line">    private int mDy = 10;</div><div class="line">    private boolean mSetShadow = true;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init()&#123;</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setTextSize(50);</div><div class="line">        mHeadBmp = BitmapFactory.decodeResource(getResources(), R.drawable.head);</div><div class="line">        mRect = new Rect();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        if (mSetShadow) &#123;</div><div class="line">            mPaint.setShadowLayer(mRadius, mDx, mDy, Color.GRAY);</div><div class="line">        &#125; else &#123;</div><div class="line">            mPaint.clearShadowLayer();</div><div class="line">        &#125;</div><div class="line">        canvas.drawText(&quot;xian小涛&quot;,100,100, mPaint);</div><div class="line">        canvas.drawCircle(200,200,50, mPaint);</div><div class="line">        mRect.set(200,300,200 + mHeadBmp.getWidth(),300 + mHeadBmp.getHeight());</div><div class="line">        canvas.drawBitmap(mHeadBmp,null, mRect, mPaint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void changeRadius() &#123;</div><div class="line">        mRadius++;</div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void changeDx() &#123;</div><div class="line">        mDx+=5;</div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void changeDy() &#123;</div><div class="line">        mDy+=5;</div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void clearShadow()&#123;</div><div class="line">        mSetShadow = false;</div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void showShadow()&#123;</div><div class="line">        mSetShadow = true;</div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123;</div><div class="line"></div><div class="line">    private TestView mView;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        mView = findViewById(R.id.view);</div><div class="line">        findViewById(R.id.radius_btn).setOnClickListener(this);</div><div class="line">        findViewById(R.id.dx_btn).setOnClickListener(this);</div><div class="line">        findViewById(R.id.dy_btn).setOnClickListener(this);</div><div class="line">        findViewById(R.id.clear_btn).setOnClickListener(this);</div><div class="line">        findViewById(R.id.show_btn).setOnClickListener(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onClick(View v) &#123;</div><div class="line">        switch (v.getId())&#123;</div><div class="line">            case R.id.radius_btn:</div><div class="line">                mView.changeRadius();</div><div class="line">                break;</div><div class="line">            case R.id.dx_btn:</div><div class="line">                mView.changeDx();</div><div class="line">                break;</div><div class="line">            case R.id.dy_btn:</div><div class="line">                mView.changeDy();</div><div class="line">                break;</div><div class="line">            case R.id.clear_btn:</div><div class="line">                mView.clearShadow();</div><div class="line">                break;</div><div class="line">            case R.id.show_btn:</div><div class="line">                mView.showShadow();</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><div id="jump2"></div></p><h3 id="7-2-2-清除阴影"><a href="#7-2-2-清除阴影" class="headerlink" title="7.2.2 清除阴影"></a>7.2.2 清除阴影</h3><p>清除阴影其实有两个方法，可以将 setShadowLayer 的 radius 的值设为 0，也可以使用专门的清除阴影的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void clearShadowLayer()</div></pre></td></tr></table></figure></p><p>具体效果见上面例子。</p><p><div id="jump3"></div></p><h3 id="7-2-3-示例：给文字添加阴影"><a href="#7-2-3-示例：给文字添加阴影" class="headerlink" title="7.2.3 示例：给文字添加阴影"></a>7.2.3 示例：给文字添加阴影</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-37733c90da49b0ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从图中可以看到，TextView、Button、EditText 中的文字自定添加了阴影。而且对于 EditText 而言，新输入的文字依然有阴影效果。</p><p>setShadowLayer 是 API 1 就已经引入的函数，而且添加了 TextView 类 和 TextView 的派生类来支持阴影设置。TextView 的派生类如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-301e117f9c6a7c53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="1-通过-XML-属性添加阴影"><a href="#1-通过-XML-属性添加阴影" class="headerlink" title="1. 通过 XML 属性添加阴影"></a>1. 通过 XML 属性添加阴影</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;TextView</div><div class="line">    ......</div><div class="line">    android:shadowRadius=&quot;3&quot;</div><div class="line">    android:shadowDx=&quot;5&quot;</div><div class="line">    android:shadowDy=&quot;5&quot;</div><div class="line">    android:shadowColor=&quot;@android:color/darker_gray&quot;/&gt;</div></pre></td></tr></table></figure><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line"></div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;使用XML添加阴影效果&quot;</div><div class="line">        android:shadowRadius=&quot;3&quot;</div><div class="line">        android:shadowDx=&quot;5&quot;</div><div class="line">        android:shadowDy=&quot;5&quot;</div><div class="line">        android:shadowColor=&quot;@android:color/darker_gray&quot;/&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/radius_btn&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;使用XML添加阴影效果&quot;</div><div class="line">        android:shadowRadius=&quot;3&quot;</div><div class="line">        android:shadowDx=&quot;5&quot;</div><div class="line">        android:shadowDy=&quot;5&quot;</div><div class="line">        android:shadowColor=&quot;@android:color/darker_gray&quot;/&gt;</div><div class="line">    &lt;EditText</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;使用XML添加阴影效果&quot;</div><div class="line">        android:shadowRadius=&quot;3&quot;</div><div class="line">        android:shadowDx=&quot;5&quot;</div><div class="line">        android:shadowDy=&quot;5&quot;</div><div class="line">        android:shadowColor=&quot;@android:color/darker_gray&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><h4 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h4><p>TextView 及其派生类都有一个 Paint.setShadowLayer 的同名方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void setShadowLayer(float radius, float dx, float dy, int color)</div></pre></td></tr></table></figure></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TextView tv = findViewById(R.id.tv);</div><div class="line">tv.setShadowLayer(3, 5, 5, Color.GRAY);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4f0e1e374bf01c8e.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07.1 精通自定义 View 之 绘图进阶——贝济埃曲线</title>
      <link href="/2019/07/07/05%20CUSTOM%20VIEW/07.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E8%B4%9D%E6%B5%8E%E5%9F%83%E6%9B%B2%E7%BA%BF/"/>
      <url>/2019/07/07/05%20CUSTOM%20VIEW/07.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E8%B4%9D%E6%B5%8E%E5%9F%83%E6%9B%B2%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-abe78c0d33504f83.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="7-1-1-概述"><a href="#7-1-1-概述" class="headerlink" title="7.1.1 概述"></a>7.1.1 概述</h3><p>在 Path 的系列函数中，除了一些基本的设置和绘图用法外，还有一个强大的工具——贝济埃曲线。它能将利用 moveTo、lineTo 连接的生硬路径变得平滑，也能够实现很多炫酷的效果，比如水波纹等。</p><h4 id="1-贝赛尔曲线来源"><a href="#1-贝赛尔曲线来源" class="headerlink" title="1. 贝赛尔曲线来源"></a>1. 贝赛尔曲线来源</h4><p>贝塞尔曲线于 1962 年，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由 Paul de Casteljau 于 1959 年运用 de Casteljau 算法开发，以稳定数值的方法求出贝塞尔曲线。</p><p>在数学的数值分析领域中，贝赛尔曲线（Bézier 曲线）是电脑图形学中相当重要的参数曲线。更高维度的广泛化贝塞尔曲线就称作贝塞尔曲面，其中贝塞尔三角是一种特殊的实例。</p><h4 id="2-贝济埃曲线公式"><a href="#2-贝济埃曲线公式" class="headerlink" title="2. 贝济埃曲线公式"></a>2. 贝济埃曲线公式</h4><p><strong>1）一阶贝济埃曲线</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d7535084366336a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-88a1d9f33c56d0d5?imageMogr2/auto-orient/strip" alt=""></p><p>P0 为起点、P1 为终点，t 表示当前时间，B(t) 表示公式的结果值。</p><p>注意，曲线的意义就是公式结果 B(t) 随时间的变化，其取值所形成的轨迹。在动画中，黑色点表示在当前时间 t 下公式 B(t) 的取值。而红色的那条线就不在各个时间点下不同取值的 B(t) 所形成的轨迹。</p><p>总而言之：对于一阶贝济埃曲线，大家可以理解为在起始点和终点形成的这条直线上，匀速移动的点。</p><p><strong>2）二阶贝济埃曲线</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d0fab250e052d246?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-723ce7c1ee1e0016?imageMogr2/auto-orient/strip" alt=""></p><p>在这里 P0 是起始点，P2 是终点，P1 是控制点。假设将时间定在 t=0.25 的时刻，此时的状态如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b43003ea2bdfb507?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>首先，P0 点和 P1 点形成了一条贝济埃曲线，还记得我们上面对一阶贝济埃曲线的总结么：就是一个点在这条直线上做匀速运动；所以 P0-P1 这条直线上的移动的点就是 Q0。</p><p>同样，P1、P2 形成了一条一阶贝济埃曲线，在这条一阶贝济埃曲线上，它们的随时间移动的点是 Q1。</p><p>最后，动态点 Q0 和 Q1 又形成了一条一阶贝济埃曲线，在它们这条一阶贝济埃曲线动态移动的点是 B。而 B 的移动轨迹就是这个二阶贝济埃曲线的最终形态。从上面的讲解大家也可以知道，之所以叫它二阶贝济埃曲线是因为，B 的移动轨迹是建立在两个一阶贝济埃曲线的中间点 Q0、Q1 的基础上的。</p><p>在理解了二阶贝赛尔曲线的形成原理以后，我们就不难理解三阶贝赛尔曲线了。</p><p><strong>3）三阶贝济埃曲线</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-044ad9428fcbbc29?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2c38ba6a9c8950a3?imageMogr2/auto-orient/strip" alt=""></p><p>同样，我们取其中一点来讲解轨迹的形成原理，当 t=0.25 时,此时状态如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f67fcc49e576bc40?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>同样，P0 是起始点，P3 是终点；P1 是第一个控制点，P2 是第二个控制点。</p><p>首先，这里有三条一阶贝济埃曲线，分别是 P0-P1、P1-P2、P2-P3，他们随时间变化的点分别为 Q0、Q1、Q2。然后是由 Q0、Q1、Q2 这三个点，再次连接，形成了两条一阶贝济埃曲线，分别是Q0-Q1、Q1-Q2，他们随时间变化的点为 R0、R1。</p><p>同样，R0 和 R1 同样可以连接形成一条一阶贝济埃曲线，在 R0-R1 这条贝赛尔曲线上随时间移动的点是 B，而 B 的移动轨迹就是这个三阶贝济埃曲线的最终形状。</p><p>从上面的解析大家可以看出，所谓几阶贝济埃曲线，全部是由一条条一阶贝济埃曲线搭起来的。在上图中，形成一阶贝济埃曲线的直线是灰色的，形成二阶贝济埃曲线线是绿色的，形成三阶贝济埃曲线的线是蓝色的。</p><p>在理解了上面的二阶和三阶贝济埃曲线以后，我们再来看几个贝济埃曲线的动态图。</p><p><strong>4）四阶贝济埃曲线</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-91e7647f793fd876?imageMogr2/auto-orient/strip" alt=""></p><p><strong>5）五阶贝济埃曲线</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e28ef335e39c174f?imageMogr2/auto-orient/strip" alt=""></p><h4 id="3-贝济埃曲线与-PhotoShop-钢笔工具"><a href="#3-贝济埃曲线与-PhotoShop-钢笔工具" class="headerlink" title="3. 贝济埃曲线与 PhotoShop 钢笔工具"></a>3. 贝济埃曲线与 PhotoShop 钢笔工具</h4><p>在专业绘图工具 Photoshop 中，有一个钢笔工具，它使用的路径弯曲效果就是二阶贝济埃曲线，下面利用 Photoshop 的钢笔工具来得出二阶贝济埃曲线的相关控制点。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-003dae5d4ff785c8?imageMogr2/auto-orient/strip" alt=""></p><p>我们拿最终成形的图形来看一下为什么钢笔工具是二阶贝济埃曲线：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-cb15295694db8eff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>右图演示的假设某一点 t=0.25 时，动态点 B 的位置图。同样，这里 P0 是起始点，P2 是终点，P1 是控制点。P0-P1、P1-P2 形成了第一层的一阶贝济埃曲线。它们随时间的动态点分别是 Q0、Q1；动态点 Q0、Q1 又形成了第二层的一阶贝济埃曲线，它们的动态点是 B。而 B 的轨迹跟钢笔工具的形状是完全一样的，所以说钢笔工具的拉伸效果使用的是二阶贝济埃曲线。</p><p>这里需要注意的是，我们在使用钢笔工具时，拖动的是 P5 点。其实二阶贝济埃曲线的控制点是其对面的 P1 点，钢笔工具这样设计是当然是因为操作起来比较方便。</p><p><div id="jump2"></div></p><h3 id="7-1-2-贝济埃曲线之-quadTo"><a href="#7-1-2-贝济埃曲线之-quadTo" class="headerlink" title="7.1.2 贝济埃曲线之 quadTo"></a>7.1.2 贝济埃曲线之 quadTo</h3><p>在 Path 类中有四个方法与贝济埃曲线相关，分别是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 二阶济埃尔</div><div class="line">public void quadTo(float x1, float y1, float x2, float y2)</div><div class="line">public void rQuadTo(float dx1, float dy1, float dx2, float dy2)</div><div class="line">// 三阶济埃尔</div><div class="line">public void cubicTo(float x1, float y1, float x2, float y2,float x3, float y3)</div><div class="line">public void rCubicTo(float x1, float y1, float x2, float y2,float x3, float y3)</div></pre></td></tr></table></figure></p><p>在这四个函数中 quadTo、rQuadTo 是二阶贝济埃曲线，cubicTo、rCubicTo 是三阶贝济埃曲线；我们这篇文章以二阶贝济埃曲线的 quadTo、rQuadTo 为主，三阶贝济埃曲线 cubicTo、rCubicTo 用的使用方法与二阶贝济埃曲线类似，用处也比较少，这篇就不再细讲了。</p><h4 id="1-quadTo-使用原理"><a href="#1-quadTo-使用原理" class="headerlink" title="1. quadTo 使用原理"></a>1. quadTo 使用原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void quadTo(float x1, float y1, float x2, float y2)</div></pre></td></tr></table></figure><p>参数中 (x1,y1) 是控制点坐标，(x2,y2) 是终点坐标。<br>大家可能会有一个疑问：有控制点和终点坐标，那起始点是多少呢？<br>整条线的起始点是通过 Path.moveTo(x,y) 来指定的，而如果我们连续调用 quadTo()，前一个 quadTo() 的终点，就是下一个 quadTo() 函数的起点；如果初始没有调用 Path.moveTo(x,y) 来指定起始点，则默认以控件左上角(0,0)为起始点。大家可能还是有点迷糊，下面我们就举个例子来看看，我们利用 quadTo() 来画下面的这条波浪线：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-8c334c61c48848cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>下面分析一下，在这条路径轨迹中，控制点分别在哪个位置，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e37060659bbc933e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>我们先看 P0-P2 这条轨迹，P0 是起点，假设位置坐标是 (100,300)，P2 是终点，假充位置坐标是 (300,300)；在以 P0 为起始点，P2 为终点这条二阶贝济埃曲线上，P1 是控制点，很明显 P1 大概在 P0、P2 中间的位置，所以它的 X 坐标应该是 200，关于 Y 坐标，我们无法确定，但很明显的是 P1 在 P0、P2 点的上方，也就是它的 Y 值比它们的小，所以根据钢笔工具上面的位置，我们让 P1 的比 P0、P2 的小 100，所以 P1的坐标是 (200，200)。</p><p>同理，不难求出在 P2-P4 这条二阶贝济埃曲线上，它们的控制点 P3 的坐标位置应该是 (400,400)。</p><p>所以我们就可以自定义一个控件，并重写它的 onDraw() 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setStrokeWidth(4);</div><div class="line">        mPaint.setColor(Color.GRAY);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setAntiAlias(true);</div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        mPath.moveTo(100, 300);</div><div class="line">        mPath.quadTo(200, 200, 300, 300);</div><div class="line">        mPath.quadTo(400, 400, 500, 300);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通过这个例子希望大家知道两点：</p><ul><li>整条线的起始点是通过 Path.moveTo(x,y) 来指定的，如果初始没有调用 Path.moveTo(x,y) 来指定起始点，则默认以控件左上角 (0,0) 为起始点。</li><li>如果我们连续调用 quadTo()，前一个 quadTo() 的终点，就是下一个 quadTo() 函数的起点。</li></ul><h4 id="2-示例：手指轨迹"><a href="#2-示例：手指轨迹" class="headerlink" title="2. 示例：手指轨迹"></a>2. 示例：手指轨迹</h4><p>要实现手指轨迹其实是非常简单的，我们只需要在自定义中拦截 OnTouchEvent，然后根据手指的移动轨迹来绘制 Path 即可。最简单的方法就是直接使用 Path.lineTo() 就能实现把各个点连接起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(4);</div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        switch (event.getAction())&#123;</div><div class="line">            case MotionEvent.ACTION_DOWN:</div><div class="line">                mPath.moveTo(event.getX(), event.getY());</div><div class="line">                return true;</div><div class="line">            case MotionEvent.ACTION_MOVE:</div><div class="line">                mPath.lineTo(event.getX(), event.getY());</div><div class="line">                invalidate();</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>虽然实现了画出手指的移动轨迹，但我们仔细来看看画出来的图：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d6cd12f5a2fbbdd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>我们把轨迹放大，明显看出，在两个点连接处有明显的转折，而且在轨迹顶部位置横纵坐标变化比较快的位置，看起来跟图片这大后的马赛克一样；利用 Path 绘图，是不可能出现马赛克的，因为除了 Bitmap 以外的任何 canvas 绘图全部都是矢量图，也就是利用数学公式来作出来的图，无论放在多大屏幕上，都不可能会出现马赛克。这里利用 Path 绘图，在轨迹顶部之所以看起来像是马赛克是因为这个轨迹是由各个不同点之间连线写出来的，而之间并没有平滑过渡，所以当坐标变化比较剧烈时，线与线之间的转折就显得特别明显了。</p><p>所以要想优化这种效果，就得实现线与线之间的平滑过渡，很显然，二阶贝济埃曲线就是干这个事的。下面我们就利用我们新学的 Path.quadTo 函数来重新实现下移动轨迹效果。</p><h4 id="3-优化：使用-Path-quadTo-函数实现手势过渡"><a href="#3-优化：使用-Path-quadTo-函数实现手势过渡" class="headerlink" title="3. 优化：使用 Path.quadTo() 函数实现手势过渡"></a>3. 优化：使用 Path.quadTo() 函数实现手势过渡</h4><p>使用 Path.lineTo() 的最大问题就是线段转折处不够平滑。Path.quadTo() 可以实现平滑过渡，但使用 Path.quadTo() 的最大问题是，如何找到起始点和结束点。</p><p>下图中，有用绿点表示的三个点，连成的两条直线，很明显他们转折处是有明显折痕的</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-88af940cfd85bb19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>下面我们在 PhotoShop 中利用钢笔工具，看如何才能实现这两条线之间的转折。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-65b3cc5c9634eb46?imageMogr2/auto-orient/strip" alt=""></p><p>最终的贝济埃曲线连接如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b26dea192018dcc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从这两个线段中可以看出，我们使用 Path.lineTo() 的时候，是直接把手指触点 A、B、C 给连起来。而钢笔工具要实现这三个点间的流畅过渡，就只能将这两个线段的中间点做为起始点和结束点，而将手指的倒数第二个触点 B 做为控制点。</p><p>大家可能会觉得，那这样，在结束的时候，A 到 P0 和 P1 到 C1 的这段距离岂不是没画进去？是的，如果 Path 最终没有 close 的话，这两段距离是被抛弃掉的。因为手指间滑动时，每两个点间的距离很小，所以 P1 到 C 之间的距离可以忽略不计。</p><p>下面我们就利用这种方法在 photoshop 中求证，在连接多个线段时，是否能行？</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c8dbebc11cee4204.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在这个图形中，有很多点连成了弯弯曲曲的线段，我们利用上面我们讲的，将两个线段的中间做为二阶贝济埃曲线的起始点和终点，把上一个手指的位置做为控制点，来看看是否真的能组成平滑的连线<br>整个连接过程如动画所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c2167deb01b0a691?imageMogr2/auto-orient/strip" alt=""></p><p>在最终的路径中看来，各个点间的连线是非常平滑的。从这里也可以看出，在为了实现平滑效果，我们只能把开头的线段一半和结束的线段的一半抛弃掉。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a218b1d8f0dce88d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line">    private float mPreX, mPreY;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(4);</div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        switch (event.getAction())&#123;</div><div class="line">            case MotionEvent.ACTION_DOWN:</div><div class="line">                mPath.moveTo(event.getX(), event.getY());</div><div class="line">                mPreX = event.getX();</div><div class="line">                mPreY = event.getY();</div><div class="line">                return true;</div><div class="line">            case MotionEvent.ACTION_MOVE:</div><div class="line">                float endX = (mPreX + event.getX()) / 2;</div><div class="line">                float endY = (mPreY + event.getY()) / 2;</div><div class="line">                mPath.quadTo(mPreX, mPreY, endX, endY);</div><div class="line">                mPreX = event.getX();</div><div class="line">                mPreY = event.getY();</div><div class="line">                invalidate();</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><div id="jump3"></div></p><h3 id="7-1-3-贝济埃曲线之-rQuadTo"><a href="#7-1-3-贝济埃曲线之-rQuadTo" class="headerlink" title="7.1.3 贝济埃曲线之 rQuadTo"></a>7.1.3 贝济埃曲线之 rQuadTo</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void rQuadTo(float dx1, float dy1, float dx2, float dy2)</div></pre></td></tr></table></figure><ul><li>dx1：控制点 X 坐标，表示相对上一个终点 X 坐标的位移坐标，可为负值，正值表示相加，负值表示相减。</li><li>dy1：控制点 Y 坐标，表示相对上一个终点 Y 坐标的位移坐标。同样可为负值，正值表示相加，负值表示相减。</li><li>dx2：终点 X 坐标，同样是一个相对坐标，相对上一个终点 X 坐标的位移值，可为负值，正值表示相加，负值表示相减。</li><li>dy2：终点 Y 坐标，同样是一个相对，相对上一个终点 Y 坐标的位移值。可为负值，正值表示相加，负值表示相减。</li></ul><p>这四个参数都是传递的都是相对值，相对上一个终点的位移值。</p><p>比如，我们上一个终点坐标是 (300,400) 那么利用，rQuadTo(100,-100,200,100) 得到的控制点坐标是 (300+100, 400-100) 即 (500,300)；同样，得到的终点坐标是 (300+200, 400+100)，即 (500,500)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 利用 quadTo 定义一个绝对坐标：</div><div class="line">path.moveTo(300,400);</div><div class="line">path.quadTo(500,300,500,500);</div><div class="line"></div><div class="line">// 与利用 rQuadTo 定义相对坐标是等价的：</div><div class="line">path.moveTo(300,400);</div><div class="line">path.rQuadTo(100,-100,200,100)</div></pre></td></tr></table></figure></p><h4 id="2-使用-rQuadTo-函数实现波浪线"><a href="#2-使用-rQuadTo-函数实现波浪线" class="headerlink" title="2. 使用 rQuadTo() 函数实现波浪线"></a>2. 使用 rQuadTo() 函数实现波浪线</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mPath.moveTo(100, 300);</div><div class="line">/*</div><div class="line">mPath.quadTo(200, 200, 300, 300);</div><div class="line">mPath.quadTo(400, 400, 500, 300);</div><div class="line">*/</div><div class="line">// 替换成</div><div class="line">mPath.rQuadTo(100, -100, 200, 0);</div><div class="line">mPath.rQuadTo(100, 100, 200, 0);</div><div class="line">canvas.drawPath(mPath, mPaint);</div></pre></td></tr></table></figure><p>第一句：path.rQuadTo(100,-100,200,0); 是建立在 (100,300) 这个点基础上来计算相对坐标的，所以：<br>控制点X坐标 = 上一个终点X坐标 + 控制点X位移 = 100+100 = 200；<br>控制点Y坐标 = 上一个终点Y坐标 + 控制点Y位移 = 300-100 = 200；<br>终点X坐标 = 上一个终点X坐标 + 终点X位移 = 100+200 = 300；<br>终点Y坐标 = 上一个终点Y坐标 + 终点Y位移 = 300+0 = 300;<br>所以这句与 path.quadTo(200,200,300,300); 对等的。</p><p>第二句：path.rQuadTo(100,100,200,0); 是建立在它的前一个终点即 (300,300) 的基础上来计算相对坐标的，所以：<br>控制点X坐标 = 上一个终点X坐标 + 控制点X位移 = 300+100 = 200；<br>控制点Y坐标 = 上一个终点Y坐标 + 控制点Y位移 = 300+100 = 200；<br>终点X坐标 = 上一个终点X坐标 + 终点X位移 = 300+200 = 500；<br>终点Y坐标 = 上一个终点Y坐标 + 终点Y位移 = 300+0 = 300;<br>所以这句与 path.quadTo(400,400,500,300); 对等的。</p><p>最终效果也是一样的。</p><p>通过这个例子，只想让大家明白一点：rQuadTo(float dx1, float dy1, float dx2, float dy2) 中的位移坐标，都是以上一个终点位置为基准来做偏移的。</p><p><div id="jump4"></div></p><h3 id="7-1-4-示例：波浪效果"><a href="#7-1-4-示例：波浪效果" class="headerlink" title="7.1.4 示例：波浪效果"></a>7.1.4 示例：波浪效果</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-500be19b0bdb1bd8.gif?imageMogr2/auto-orient/strip" alt=""></p><p>我们将 mPath 的起始位置向左移一个波长，然后利用 for 循环画出当前屏幕中可能容得下的所有波。然后画一个波的左右两个半波：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 画的是一个波长中的前半个波</div><div class="line">mPath.rQuadTo(halfWaveLen/2, -100, halfWaveLen, 0); </div><div class="line">// 画的是一个波长中的后半个波</div><div class="line">mPath.rQuadTo(halfWaveLen/2, 100, halfWaveLen, 0);</div></pre></td></tr></table></figure></p><p>大家在这里可以看到，屏幕左右都多画了一个波长的图形。这是为了波形移动做准备的。</p><p>让波纹动起来其实挺简单，利用调用在 path.moveTo 的时候，将起始点向右移动即可实现移动，而且只要我们移动一个波长的长度，波纹就会重合，就可以实现无限循环了。</p><p>完整的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line">    private int mItemWaveLength = 1000;</div><div class="line">    private int dx;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPath = new Path();</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setStyle(Paint.Style.FILL_AND_STROKE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        mPath.reset();</div><div class="line">        int originY = 300;</div><div class="line">        int halfWaveLen = mItemWaveLength/2;</div><div class="line">        mPath.moveTo(-mItemWaveLength+dx,originY);</div><div class="line">        for (int i = -mItemWaveLength; i&lt;=getWidth()+mItemWaveLength; i+=mItemWaveLength)&#123;</div><div class="line">            mPath.rQuadTo(halfWaveLen/2f,-100,halfWaveLen,0);</div><div class="line">            mPath.rQuadTo(halfWaveLen/2f,100,halfWaveLen,0);</div><div class="line">        &#125;</div><div class="line">        mPath.lineTo(getWidth(),getHeight());</div><div class="line">        mPath.lineTo(0,getHeight());</div><div class="line">        mPath.close();</div><div class="line"></div><div class="line">        canvas.drawPath(mPath,mPaint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void startAnim()&#123;</div><div class="line">        ValueAnimator animator = ValueAnimator.ofInt(0,mItemWaveLength);</div><div class="line">        animator.setDuration(2000);</div><div class="line">        animator.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">        animator.setInterpolator(new LinearInterpolator());</div><div class="line">        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">                dx = (int)animation.getAnimatedValue();</div><div class="line">                postInvalidate();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        animator.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用 TestView<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        TestView view = findViewById(R.id.view);</div><div class="line">        view.startAnim();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d2a00ef48150506e.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06.3 精通自定义 View 之 Paint 基本使用——常用函数</title>
      <link href="/2019/07/06/05%20CUSTOM%20VIEW/06.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>/2019/07/06/05%20CUSTOM%20VIEW/06.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-68545bf6475f027d.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="6-1-1-基本函数设置"><a href="#6-1-1-基本函数设置" class="headerlink" title="6.1.1 基本函数设置"></a>6.1.1 基本函数设置</h3><p>我们先来看一下 paint 中基本设置的函数都有哪些。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 重置画笔</div><div class="line">reset()</div><div class="line">// 给画笔设置颜色值</div><div class="line">setColor(int color)</div><div class="line">// 设置颜色，利用 ARGB 分开设置</div><div class="line">setARGB(int a, int r, int g, int b)</div><div class="line">// 设置画笔透明度</div><div class="line">setAlpha(int a)</div><div class="line">// 设置画笔样式，取值有：Paint.Style.FILL、STROKE、FILL_AND_STROKE</div><div class="line">setStyle(Paint.Style style)</div><div class="line">// 设置画笔宽度</div><div class="line">setStrokeWidth(float width)</div><div class="line">// 设置画笔是否抗锯齿</div><div class="line">setAntiAlias(boolean aa)</div><div class="line"></div><div class="line">// 设置线冒样式，取值有Cap.ROUND(圆形线冒)、</div><div class="line">// Cap.SQUARE(方形线冒)、Paint.Cap.BUTT(无线冒)</div><div class="line">setStrokeCap(Paint.Cap cap)</div><div class="line">// 设置线段连接处样式，取值有：Join.MITER（结合处为锐角）、</div><div class="line">// Join.Round(结合处为圆弧)、Join.BEVEL(结合处为直线)</div><div class="line">setStrokeJoin(Paint.Join join)</div><div class="line">// 设置笔画的倾斜度，区别不明显</div><div class="line">setStrokeMiter(float miter)</div><div class="line">// 设置路径样式。取值类型是所有派生自 PathEffect 的子类：</div><div class="line">// ComposePathEffect、CornerPathEffect、DashPathEffect、</div><div class="line">// DiscretePathEffect、PathDashPathEffect、SumPathEffect</div><div class="line">setPathEffect(PathEffect effect)</div></pre></td></tr></table></figure></p><h4 id="1-setStrokeCap-Paint-Cap-cap"><a href="#1-setStrokeCap-Paint-Cap-cap" class="headerlink" title="1. setStrokeCap(Paint.Cap cap)"></a>1. setStrokeCap(Paint.Cap cap)</h4><p>设置线帽样式，取值有 Cap.ROUND (圆形线帽)、Cap.SQUARE (方形线帽)、Paint.Cap.BUTT (无线帽)</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-8d1fcbc504d407cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>红线左侧多出来的区域就是线帽。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setStrokeWidth(80);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setAntiAlias(true);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        // 无线帽</div><div class="line">        mPaint.setStrokeCap(Paint.Cap.BUTT);</div><div class="line">        canvas.drawLine(100, 200, 400, 200, mPaint);</div><div class="line">        // 方形线帽</div><div class="line">        mPaint.setStrokeCap(Paint.Cap.SQUARE);</div><div class="line">        canvas.drawLine(100, 400, 400, 400, mPaint);</div><div class="line">        // 圆形线帽</div><div class="line">        mPaint.setStrokeCap(Paint.Cap.ROUND);</div><div class="line">        canvas.drawLine(100, 600, 400, 600, mPaint);</div><div class="line"></div><div class="line">        // 画辅助线</div><div class="line">        mPaint.reset();</div><div class="line">        mPaint.setStrokeWidth(2);</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        canvas.drawLine(100, 50, 100, 750, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2-setStrokeJoin-Paint-Join-join"><a href="#2-setStrokeJoin-Paint-Join-join" class="headerlink" title="2. setStrokeJoin(Paint.Join join)"></a>2. setStrokeJoin(Paint.Join join)</h4><p>参数取值有：Join.MITER (结合处为锐角)、Join.Round (结合处为圆弧)、Join.BEVEL(结合处为直线)</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4e349899a7f42832?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-10d2f61db3868fbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setStrokeWidth(40);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setAntiAlias(true);</div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        // 结合处为锐角 MITER</div><div class="line">        mPath.moveTo(100, 100);</div><div class="line">        mPath.lineTo(250, 100);</div><div class="line">        mPath.lineTo(100, 250);</div><div class="line">        mPaint.setStrokeJoin(Paint.Join.MITER);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        // 结合处为圆弧 ROUND</div><div class="line">        mPath.moveTo(300, 100);</div><div class="line">        mPath.lineTo(450, 100);</div><div class="line">        mPath.lineTo(300, 250);</div><div class="line">        mPaint.setStrokeJoin(Paint.Join.ROUND);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        // 结合处为直线 BEVEL</div><div class="line">        mPath.moveTo(500, 100);</div><div class="line">        mPath.lineTo(650, 100);</div><div class="line">        mPath.lineTo(500, 250);</div><div class="line">        mPaint.setStrokeJoin(Paint.Join.BEVEL);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3-setPathEffect-PathEffect-effect"><a href="#3-setPathEffect-PathEffect-effect" class="headerlink" title="3. setPathEffect(PathEffect effect)"></a>3. setPathEffect(PathEffect effect)</h4><p>设置路径样式。取值类型是所有派生自 PathEffect 的子类：ComposePathEffect、CornerPathEffect、DashPathEffect、DiscretePathEffect、PathDashPathEffect、SumPathEffect。</p><p>1）CornerPathEffect<br>它的作用就是将原来 Path 生硬的直线拐角，变成圆形拐角。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public CornerPathEffect(float radius)</div></pre></td></tr></table></figure></p><p>参数 radius：即当前连接两条直线所使用的圆的半径。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-fc5362e0bd2e16ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c6098ec540f11b5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line">    private CornerPathEffect effect100, effect200;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setStrokeWidth(4);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setAntiAlias(true);</div><div class="line">        mPath = new Path();</div><div class="line">        effect100 = new CornerPathEffect(100);</div><div class="line">        effect200 = new CornerPathEffect(200);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        mPath.moveTo(100,600);</div><div class="line">        mPath.lineTo(400,100);</div><div class="line">        mPath.lineTo(700,900);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line"></div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPaint.setPathEffect(effect100);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line"></div><div class="line">        mPaint.setColor(Color.BLUE);</div><div class="line">        mPaint.setPathEffect(effect200);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>2）DashPathEffect 虚线效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public DashPathEffect(float intervals[], float phase)</div></pre></td></tr></table></figure></p><p>phase：开始绘制的偏移值。<br>intervals[]：表示组成虚线的各个线段的长度；整条虚线就是由 intervals[] 中这些基本线段循环组成的。比如，我们定义 new float[] {20,10}；那这个虚线段就是由两段线段组成的，第一个可见的线段长为 20，每二个线段不可见，长度为 10。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-6d72336d24afbebb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于 intervals[] 数组的有两个限定：</p><ul><li>长度必须大于等于 2；因为必须有一个实线段和一个空线段来组成虚线。</li><li>个数必须为偶数，如果是基数，最后一个数字将被忽略；这个很好理解，因为一组虚线的组成必然是一个实线和一个空线成对组成的。</li></ul><p>示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-aed9539fe190586b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line">    private DashPathEffect effect1, effect2;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setStrokeWidth(4);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setAntiAlias(true);</div><div class="line">        mPath = new Path();</div><div class="line">        effect1 = new DashPathEffect(new float[]&#123;20,10,100,100&#125;,0);</div><div class="line">        effect2 = new DashPathEffect(new float[]&#123;20,10,50,100&#125;,15);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        mPath.moveTo(100,600);</div><div class="line">        mPath.lineTo(400,100);</div><div class="line">        mPath.lineTo(700,900);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line"></div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPaint.setPathEffect(effect1);</div><div class="line">        canvas.translate(0, 100);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line"></div><div class="line">        mPaint.setColor(Color.BLUE);</div><div class="line">        mPaint.setPathEffect(effect2);</div><div class="line">        canvas.translate(0, 100);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>3）DiscretePathEffect 离散路径效果<br>DiscretePathEffect 就是将原来路径分隔成定长的线段，然后将每条线段随机偏移一段位置，我们可以用它来模拟一种类似生锈铁丝的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public DiscretePathEffect(float segmentLength, float deviation)</div></pre></td></tr></table></figure></p><ul><li>参数 segmentLength：表示将原来的路径切成多长的线段。如果值为 2，那么这个路径就会被切成一段段由长度为 2 的小线段。所以这个值越小，所切成的小线段越多；这个值越大，所切成的小线段越少。</li><li>参数 deviation：表示被切成的每个小线段的可偏移距离。值越大，就表示每个线段的可偏移距离就越大，就显得越凌乱，值越小，每个线段的可偏移原位置的距离就越小。</li></ul><p>示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-9d31b725f3a65625.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = getPaint();</div><div class="line">        mPath = getPath();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        // 第一条原生 Path</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        // 第二条 Path</div><div class="line">        canvas.translate(0,200);</div><div class="line">        mPaint.setPathEffect(new DiscretePathEffect(2,5));</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        // 第三条 Path</div><div class="line">        canvas.translate(0,200);</div><div class="line">        mPaint.setPathEffect(new DiscretePathEffect(6,5));</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        // 第四条 Path</div><div class="line">        canvas.translate(0,200);</div><div class="line">        mPaint.setPathEffect(new DiscretePathEffect(6,15));</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Path getPath()&#123;</div><div class="line">        Path path = new Path();</div><div class="line">        // 定义路径的起点</div><div class="line">        path.moveTo(0, 0);</div><div class="line"></div><div class="line">        // 定义路径的各个点</div><div class="line">        for (int i = 0; i &lt;= 40; i++) &#123;</div><div class="line">            path.lineTo(i*35, (float) (Math.random() * 150));</div><div class="line">        &#125;</div><div class="line">        return path;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Paint getPaint()&#123;</div><div class="line">        Paint paint = new Paint();</div><div class="line">        paint.setStrokeWidth(4);</div><div class="line">        paint.setColor(Color.GREEN);</div><div class="line">        paint.setStyle(Paint.Style.STROKE);</div><div class="line">        paint.setAntiAlias(true);</div><div class="line">        return paint;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>4）PathDashPathEffect 印章路径效果<br>它的作用就是用另一个路径图案做为印章，沿着指定路径一个个盖上去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public PathDashPathEffect(Path shape, float advance, float phase,Style style)</div></pre></td></tr></table></figure></p><ul><li>Path shape：表示印章路径，比如我们下面示例中的三角形加右上角一个点。</li><li>float advance：表示两个印章路径间的距离，印章间距离越大，间距就越大。</li><li>float phase：路径绘制偏移距离，与上面 DashPathEffect 中的 float phase 参数意义相同。</li><li>Style style：表示在遇到转角时，如何操作印章以使转角平滑过渡，取值有：Style.ROTATE，Style.MORPH，Style.TRANSLATE；Style.ROTATE 表示通过旋转印章来过渡转角；Style.MORPH 表示通过变形印章来过渡转角；Style.TRANSLATE 表示通过位移来过渡转角。</li></ul><p>示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4dfb51710a4d6aa1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line">    private PathDashPathEffect mEffectMORPH, mEffectROTATE, mEffectTRANSLATE;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint = getPaint();</div><div class="line">        mPath = getPath();</div><div class="line">        // 构建印章路径</div><div class="line">        Path stampPath = getStampPath();</div><div class="line">        stampPath.addCircle(0,0,3, Path.Direction.CCW);</div><div class="line">        mEffectMORPH = new PathDashPathEffect(stampPath,35,0, PathDashPathEffect.Style.MORPH);</div><div class="line">        mEffectROTATE = new PathDashPathEffect(stampPath,35,0, PathDashPathEffect.Style.ROTATE);</div><div class="line">        mEffectTRANSLATE = new PathDashPathEffect(stampPath,35,0, PathDashPathEffect.Style.TRANSLATE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        // 原始线</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        // 使用印章路径效果 MORPH</div><div class="line">        canvas.translate(0,200);</div><div class="line">        mPaint.setPathEffect(mEffectMORPH);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        // 使用印章路径效果 ROTATE</div><div class="line">        canvas.translate(0,200);</div><div class="line">        mPaint.setPathEffect(mEffectROTATE);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        // 使用印章路径效果 TRANSLATE</div><div class="line">        canvas.translate(0,200);</div><div class="line">        mPaint.setPathEffect(mEffectTRANSLATE);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Path getPath()&#123;</div><div class="line">        Path path = new Path();</div><div class="line">        // 定义路径的起点</div><div class="line">        path.moveTo(0, 0);</div><div class="line"></div><div class="line">        // 定义路径的各个点</div><div class="line">        for (int i = 0; i &lt;= 40; i++) &#123;</div><div class="line">            path.lineTo(i*35, (float) (Math.random() * 150));</div><div class="line">        &#125;</div><div class="line">        return path;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Path getStampPath()&#123;</div><div class="line">        Path path  = new Path();</div><div class="line">        path.moveTo(0,20);</div><div class="line">        path.lineTo(10,0);</div><div class="line">        path.lineTo(20,20);</div><div class="line">        path.close();</div><div class="line"></div><div class="line">        path.addCircle(0,0,3, Path.Direction.CCW);</div><div class="line">        return path;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Paint getPaint()&#123;</div><div class="line">        Paint paint = new Paint();</div><div class="line">        paint.setStrokeWidth(4);</div><div class="line">        paint.setColor(Color.GREEN);</div><div class="line">        paint.setStyle(Paint.Style.STROKE);</div><div class="line">        paint.setAntiAlias(true);</div><div class="line">        return paint;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>5）ComposePathEffect &amp; SumPathEffect<br>这两个都是用来合并两个特效的。但它们之间是有区别的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public ComposePathEffect(PathEffect outerpe, PathEffect innerpe)</div><div class="line">public SumPathEffect(PathEffect first, PathEffect second)</div></pre></td></tr></table></figure></p><p>ComposePathEffect 合并两个特效是有先后顺序的，它会先将第二个参数的 PathEffect innerpe 的特效作用于路径上，然后再在此加了特效的路径上作用第一个特效。</p><p>而 SumPathEffect 是分别对原始路径分别作用第一个特效和第二个特效。然后再将这两条路径合并，做为最终结果。示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b66b98bda013a645.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 画原始路径</div><div class="line">Paint paint = getPaint();</div><div class="line">Path path = getPath();</div><div class="line">canvas.drawPath(path,paint);</div><div class="line"> </div><div class="line">// 仅应用圆角特效的路径</div><div class="line">canvas.translate(0,200);</div><div class="line">CornerPathEffect cornerPathEffect = new CornerPathEffect(100);</div><div class="line">paint.setPathEffect(cornerPathEffect);</div><div class="line">canvas.drawPath(path,paint);</div><div class="line"> </div><div class="line">// 仅应用虚线特效的路径</div><div class="line">canvas.translate(0,200);</div><div class="line">DashPathEffect dashPathEffect = new DashPathEffect(new float[]&#123;2,5,10,10&#125;,0);</div><div class="line">paint.setPathEffect(dashPathEffect);</div><div class="line">canvas.drawPath(path,paint);</div><div class="line"> </div><div class="line">// 利用 ComposePathEffect 先应用圆角特效，再应用虚线特效</div><div class="line">canvas.translate(0,200);</div><div class="line">ComposePathEffect composePathEffect = new ComposePathEffect(dashPathEffect,cornerPathEffect);</div><div class="line">paint.setPathEffect(composePathEffect);</div><div class="line">canvas.drawPath(path,paint);</div><div class="line"> </div><div class="line">// 利用 SumPathEffect，分别将圆角特效应用于原始路径，然后将生成的两条特效路径合并</div><div class="line">canvas.translate(0,200);</div><div class="line">paint.setStyle(Paint.Style.STROKE);</div><div class="line">SumPathEffect sumPathEffect = new SumPathEffect(cornerPathEffect,dashPathEffect);</div><div class="line">paint.setPathEffect(sumPathEffect);</div><div class="line">canvas.drawPath(path,paint);</div></pre></td></tr></table></figure><p><div id="jump2"></div></p><h3 id="6-1-2-字体相关函数"><a href="#6-1-2-字体相关函数" class="headerlink" title="6.1.2 字体相关函数"></a>6.1.2 字体相关函数</h3><p><strong>setTextSize(float textSize)</strong><br>设置文字大小</p><p><strong>setFakeBoldText(boolean fakeBoldText)</strong><br>设置是否为粗体文字</p><p><strong>setStrikeThruText(boolean strikeThruText)</strong><br>设置带有删除线效果</p><p><strong>setUnderlineText(boolean underlineText)</strong><br>设置下划线</p><p><strong>setTextAlign(Paint.Align align)</strong><br>设置开始绘图点位置</p><p><strong>setTextScaleX(float scaleX)</strong><br>水平拉伸设置</p><p><strong>setTextSkewX(float skewX)</strong><br>设置字体水平倾斜度，普通斜体字是-0.25，可见往右斜</p><p><strong>setTypeface(Typeface typeface)</strong><br>字体样式</p><p><strong>setLinearText(boolean linearText)</strong><br>设置是否打开线性文本标识；由于文本想要快速绘制出来，必然是需要提前缓存在显存中的，一般而言每个文字需要一个字节的大小来存储它（当然具体需要多少字节与编码方式有关），那如果是长篇文章，可见所需的大小可想而知。我们可以通过 setLinearText (true) 告诉 Android 我们不需要这样的文本缓存。但如果我们不用文本缓存，虽然能够省去一些内存空间，但这是以显示速度为代价的。</p><p>由于这个是 API 1 的函数，由于当时的 android 手机的内存大小还是很小的，所以尽量减少内存使用是每个应用的头等大事，在当时的的环境下这个函数还是很有用的。</p><p>但在今天，内存动不动就是 4G 以上了，文本缓存的所占的那点内存就微不足道了，没有哪个 APP 会牺牲性能来减少这点这内存占用了，所以这个函数基本没用了。</p><p><strong>setSubpixelText(boolean subpixelText)</strong><br>表示是否打开亚像素设置来绘制文本。亚像素的概念比较难理解，首先，我们都知道像素，比如一个 android 手机的分辨率是 1280<em>720，那就是指它的屏幕在垂直方向有 1280 个像素点，水平方向上有 720 个像素点。我们知道每个像素点都是一个独立显示一个颜色的个体。所以如果一副图片，在一个屏幕上用了 300</em>100 个相素点，而在另一个屏幕上却用了 450*150 个像素来显示。那么，请问在哪个屏幕上这张图片显示的更清晰？当然是第二个屏幕，因为它使用的像素点更多，所显示的细节更精细。</p><p>那么问题来了，android 设置在出厂时，设定的像素显示都是固定的几个范围：320*480，480*800，720*1280，1080*1920 等等；那么如何在同样的分辨率的显示器中增强显示清晰度呢？</p><p>亚像素的概念就油然而生了，亚像素就是把两个相邻的两个像素之间的距离再细分，再插入一些像素，这些通过程序加入的像素就是亚像素。在两个像素间插入的像素个数是通过程序计算出来的，一般是插入两个、三个或四个。</p><p>所以打开亚像素显示，是可以在增强文本显示清晰度的，但由于插入亚像素是通过程序计算而来的，所以会耗费一定的计算机性能。注意：亚像素是通过程序计算出来模拟插入的，在没有改变硬件构造的情况下，来改善屏幕分辨率大小。</p><p>亚像素显示，是仅在液晶显示器上使用的一种增强字体清晰度的技术。但这种技术有时会出现问题，用投影仪投射到白色墙壁上，会出出字体显示不正常的情况，而且对于老式的 CRT 显示器是根本不支持的。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b47e8f3785ea601d.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06.2 精通自定义 View 之 Paint 基本使用——文字</title>
      <link href="/2019/07/06/05%20CUSTOM%20VIEW/06.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/"/>
      <url>/2019/07/06/05%20CUSTOM%20VIEW/06.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-9dd19497fc78311d.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="6-2-1-概述"><a href="#6-2-1-概述" class="headerlink" title="6.2.1 概述"></a>6.2.1 概述</h3><h4 id="1-四线格与基线"><a href="#1-四线格与基线" class="headerlink" title="1. 四线格与基线"></a>1. 四线格与基线</h4><p>小时候，我们在刚开始学习写字母时，用的本子是四线格的，我们必须把字母按照规则写在四线格内。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-57da700226403807.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在 canvas 在利用 drawText 绘制文字时，也是有规则的，这个规则就是基线！我们先来看一下什么是基线：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1ca1a9bb09b43d53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可见基线就是四线格中的第三条线。也就是说，只要基线的位置定了，那文字的位置必然是定了的！</p><h4 id="2-canvas-drawText"><a href="#2-canvas-drawText" class="headerlink" title="2. canvas.drawText()"></a>2. canvas.drawText()</h4><p>1）canvas.drawText() 与基线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * text:要绘制的文字</div><div class="line"> * x：绘制原点x坐标</div><div class="line"> * y：绘制原点y坐标</div><div class="line"> * paint:用来做画的画笔</div><div class="line"> */</div><div class="line">public void drawText(String text, float x, float y, Paint paint)</div></pre></td></tr></table></figure></p><p>上面这个构造函数是最常用的 drawText 方法，传进去一个 String 对象就能画出对应的文字。但这里有两个参数需要非常注意，表示原点坐标的 x 和 y。很多同学可能会认为，这里传进去的原点参数 (x,y) 是所在绘制文字所在矩形的左上角的点。但实际上并不是！比如，我们上面如果要画 “harvic’s blog” 这几个字，这个原点坐标应当是下图中绿色小点的位置。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b9eddb44f3acefa7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>一般而言，(x,y) 所代表的位置是所画图形对应的矩形的左上角点。但在 drawText 中是非常例外的，y 所代表的是基线的位置。</p><p>2）示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line"> </div><div class="line">    int baseLineX = 0;</div><div class="line">    int baseLineY = 200;</div><div class="line">    </div><div class="line">    // 画基线</div><div class="line">    Paint paint = new Paint();</div><div class="line">    paint.setColor(Color.RED);</div><div class="line">    canvas.drawLine(baseLineX, baseLineY, 3000, baseLineY, paint);</div><div class="line"> </div><div class="line">    // 写文字</div><div class="line">    paint.setColor(Color.GREEN);</div><div class="line">    paint.setTextSize(120); // 以px为单位</div><div class="line">    canvas.drawText(&quot;harvic\&apos;s blog&quot;, baseLineX, baseLineY, paint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>首先，我们把 (0,200) 所在的这条横线画出来，所以我先画了一条线从点坐标为 (0,200) 到点坐标为 (3000,200) 的一条直线，然后利用 canvas.drawText 以 (0,200) 为原点画出文字，最终效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ba0826eb929753ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>结论：</p><ul><li>drawText() 函数中的参数 y 是基线的位置。</li><li>一定要清楚的是，只要 x 坐标、基线位置、文字大小确定，文字的位置就是确定了。</li></ul><h4 id="3-paint-setTextAlign-函数"><a href="#3-paint-setTextAlign-函数" class="headerlink" title="3. paint.setTextAlign() 函数"></a>3. paint.setTextAlign() 函数</h4><p>在上面我们讲了，drawText() 函数中的 y 参数表示所要绘制文字的基线所在位置。从上面的例子中可以看到，绘制是从 x 坐标的右边开始的，但这并不是必然的结果。我们来看一张图：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-308a568c5c7ea992.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在 drawText(text, x, y, paint) 中传进去的原点坐标 (x,y)。其中，y 表示的基线的位置。那 x 代表什么呢？从上面的例子运行结果来看，应当是文字开始绘制的地方。</p><p>并不是！x 代表所要绘制文字所在矩形的相对位置。相对位置就是指指定点 (x,y) 在在所要绘制矩形的位置。我们知道所绘制矩形的纵坐标是由 y 值来确定的，而相对 x 坐标的位置，只有左、中、右三个位置了。也就是所绘制矩形可能是在 x 坐标的左侧绘制，也有可能在 x 坐标的中间，也有可能在 x 坐标的右侧。而定义在 x 坐标在所绘制矩形相对位置的函数是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 其中 Align 的取值为：</div><div class="line"> * Panit.Align.LEFT, Paint.Align.CENTER, Paint.Align.RIGHT</div><div class="line"> */</div><div class="line">Paint::setTextAlign(Align align);</div></pre></td></tr></table></figure></p><p>仍然使用上面的例子，当设置不同的 Align 取值时，效果如下图所示。<br><strong>Paint.Align.LEFT：</strong><br><img src="https://upload-images.jianshu.io/upload_images/14186083-7cbb15dc7967a198.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>Paint.Align.CENTER：</strong><br><img src="https://upload-images.jianshu.io/upload_images/14186083-dcdac7faa0f2601e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>Paint.Align.RIGHT：</strong><br><img src="https://upload-images.jianshu.io/upload_images/14186083-fe138d527ea49694.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="4-注意"><a href="#4-注意" class="headerlink" title="4. 注意"></a>4. 注意</h4><p>这里需要再次强调的是：相对位置是根据所要绘制文字所在矩形来计算的。比如，只写一个大写字母 A，将其相对位置设置为 Paint.Align.CENTER。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mPaint.setTextAlign(Paint.Align.CENTER);</div><div class="line">canvas.drawText(&quot;A&quot;, baseLineX, baseLineY, mPaint);</div></pre></td></tr></table></figure></p><p>效果如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e0e6bdfd3959f399.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><div id="jump2"></div></p><h3 id="6-2-2-绘图四线格与-FontMetrics"><a href="#6-2-2-绘图四线格与-FontMetrics" class="headerlink" title="6.2.2 绘图四线格与 FontMetrics"></a>6.2.2 绘图四线格与 FontMetrics</h3><h4 id="1-文字的绘图四线格"><a href="#1-文字的绘图四线格" class="headerlink" title="1. 文字的绘图四线格"></a>1. 文字的绘图四线格</h4><p>除了基线以外，系统在绘制文字时还有 4 条线，分别是 ascent、descent、top、bottom，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f4f98522d06491b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>ascent：系统建议的，绘制单个字符时，字符应当的最高高度所在线。</li><li>descent：系统建议的，绘制单个字符时，字符应当的最低高度所在线。</li><li>top：可绘制的最高高度所在线。</li><li>bottom：可绘制的最低高度所在线。</li></ul><p>我们在绘制文字时，ascent 是推荐的绘制文字的最高高度，就表示在绘制文字时，尽力要在这个最高高度以下绘制文字。descent 是推荐的绘制文字的最底高度线，同样表示是在绘制文字时尽量在这个 descent 线以上来绘制文字。而 top 线则指该文字可以绘制的最高高度线，bottom 则是表示该文字可以绘制的最低高度线。ascent、descent 是系统建议上的绘制高度，而 top、bottom 则是物理上屏幕最高、最低可以画的高度值。</p><h4 id="2-FontMetrics"><a href="#2-FontMetrics" class="headerlink" title="2. FontMetrics"></a>2. FontMetrics</h4><p>1）FontMetrics 概述<br>我们知道基线的位置是我们在构造 drawText() 函数时由参数 y 来决定的，那 ascent、descent、top、bottom 这些线的位置要怎么计算出来呢？</p><p>Android 给我们提供了一个类：FontMetrics，它里面有四个成员变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FontMetrics::ascent;</div><div class="line">FontMetrics::descent;</div><div class="line">FontMetrics::top;</div><div class="line">FontMetrics::bottom;</div></pre></td></tr></table></figure></p><p>他们的意义与值的计算方法分别如下：</p><ul><li>ascent = ascent 线的 y 坐标 - baseline 线的 y 坐标。</li><li>descent = descent 线的 y 坐标 - baseline 线的 y 坐标。</li><li>top = top 线的 y 坐标 - baseline 线的 y 坐标。</li><li>bottom = bottom 线的 y 坐标 - baseline 线的 y 坐标。</li></ul><p>我们再来看个图：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0cfad062b77303f8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从这个图中，我们先说明两点，然后再回过头来看上面的公式：<br>1、X 轴，Y 轴的正方向走向是 X 轴向右是正方向，Y 轴向下是正方向，所以越往下 Y 坐标越大！<br>2、大家千万不要将 FontMetrics 中的 ascent、descent、top、bottom 与现实中的 ascent、descent、top、bottom 所在线混淆！这几条线是真实存在的，而 FontMetrics 中的 ascent、descent、top、bottom 这个变量的值就是用来计算这几条线的位置的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ascent = ascent 线的 y 坐标 - baseline 线的 y 坐标</div></pre></td></tr></table></figure></p><p>FontMetrics 的这几个变量的值都是以 baseline 为基准的，对于 ascent 来说，baseline 线在 ascent 线之下，所以必然 baseline 的 y 值要大于 ascent 线的 y 值，所以 ascent 变量的值是负的。</p><p>同理，对于 descent 而言：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">descent = descent 线的 y 坐标 - baseline 线的 y 坐标</div></pre></td></tr></table></figure></p><p>descent 线在 baseline 线之下，所以必然 descent 线的 y 坐标要大于 baseline 线的 y 坐标，所以 descent 变量的值必然是正数。</p><p>2）得到 Text 四线格的各线位置<br>先列出一个公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ascent 线 Y 坐标 = baseline 线 Y 坐标 + fontMetric.ascent</div></pre></td></tr></table></figure></p><p>推算过程如下：</p><p>因为 ascent 线的 Y 坐标等于 baseline 线的 Y 坐标减去从 baseline 线到 ascent 线的这段距离。也就是：(|fontMetric.ascent| 表示取绝对值)。<br>ascent 线 Y 坐标 = baseline 线 Y 坐标 - |fontMetric.ascent|;<br>又因为 fontMetric.ascent 是负值，所以：<br>ascent 线 Y 坐标 = baseline 线 Y 坐标 - |fontMetric.ascent|;<br>ascent 线 Y 坐标 = baseline 线 Y 坐标 - (-fontMetric.ascent);<br>ascent 线 Y 坐标 = baseline 线 Y 坐标 + fontMetric.ascent;</p><p>这就是整个推算过程，没什么难度，同理可以得到：</p><ul><li>ascent 线 Y 坐标 = baseline 线的 y 坐标 + fontMetric.ascent；</li><li>descent 线 Y 坐标 = baseline 线的 y 坐标 + fontMetric.descent；</li><li>top 线 Y 坐标 = baseline 线的 y 坐标 + fontMetric.top；</li><li>bottom 线 Y 坐标 = baseline 线的 y 坐标 + fontMetric.bottom；</li></ul><p>3）获取 FontMetrics 对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Paint paint = new Paint();</div><div class="line">Paint.FontMetrics fm = paint.getFontMetrics();</div><div class="line">Paint.FontMetricsInt fmInt = paint.getFontMetricsInt();</div></pre></td></tr></table></figure></p><p>从这里可以看到，通过 paint.getFontMetrics() 得到对应的 FontMetrics 对象。这里还有另外一个 FontMetrics 同样的类叫做 FontMetricsInt，它的意义与 FontMetrics 完全相同，只是得到的值的类型不一样而已，FontMetricsInt 中的四个成员变量的值都是 Int 类型，而 FontMetrics 得到的四个成员变量的值则都是 float 类型的。</p><p>4）示例：计算 Text 四线格位置</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-dbe98aa14347e5e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Paint.FontMetrics mFm;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setTextSize(120);</div><div class="line">        mPaint.setTextAlign(Paint.Align.LEFT);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        int baseLineX = 0;</div><div class="line">        int baseLineY = 200;</div><div class="line"></div><div class="line">        // 写文字</div><div class="line">        canvas.drawText(&quot;harvic\&apos;s blog&quot;, baseLineX, baseLineY, mPaint);</div><div class="line">        // 计算各线在位置</div><div class="line">        mFm = mPaint.getFontMetrics();</div><div class="line">        float ascent = baseLineY + mFm.ascent;</div><div class="line">        float descent = baseLineY + mFm.descent;</div><div class="line">        float top = baseLineY + mFm.top;</div><div class="line">        float bottom = baseLineY + mFm.bottom;</div><div class="line">        // 画基线</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        canvas.drawLine(baseLineX, baseLineY, 3000, baseLineY, mPaint);</div><div class="line">        // 画 top</div><div class="line">        mPaint.setColor(Color.BLUE);</div><div class="line">        canvas.drawLine(baseLineX, top, 3000, top, mPaint);</div><div class="line">        // 画 ascent</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        canvas.drawLine(baseLineX, ascent, 3000, ascent, mPaint);</div><div class="line">        // 画 descent</div><div class="line">        mPaint.setColor(Color.YELLOW);</div><div class="line">        canvas.drawLine(baseLineX, descent, 3000, descent, mPaint);</div><div class="line">        // 画 bottom</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        canvas.drawLine(baseLineX, bottom, 3000, bottom, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><div id="jump3"></div></p><h3 id="6-2-3-常用函数"><a href="#6-2-3-常用函数" class="headerlink" title="6.2.3 常用函数"></a>6.2.3 常用函数</h3><h4 id="1-字符串所占高度和宽度"><a href="#1-字符串所占高度和宽度" class="headerlink" title="1. 字符串所占高度和宽度"></a>1. 字符串所占高度和宽度</h4><p>1）高度<br>字符串所占高度很容易得到，直接用 bottom 线所在位置的 Y 坐标减去 top 线所在位置的 Y 坐标就是字符串所占的高度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mFm = mPaint.getFontMetricsInt();</div><div class="line">int top = baseLineY + fm.top;</div><div class="line">int bottom = baseLineY + fm.bottom;</div><div class="line">// 所占高度</div><div class="line">int height = bottom - top;</div></pre></td></tr></table></figure></p><p>2）、宽度<br>宽度是非常容易得到的，直接利用下面的函数就可以得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int width = mPaint.measureText(&quot;harvic&apos;s blog&quot;);</div></pre></td></tr></table></figure></p><h4 id="2-最小矩形"><a href="#2-最小矩形" class="headerlink" title="2. 最小矩形"></a>2. 最小矩形</h4><p>1）概述<br>要获取最小矩形，也是通过系统函数来获取的，函数及意义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 获取指定字符串所对应的最小矩形，以（0，0）点所在位置为基线</div><div class="line"> * @param text  要测量最小矩形的字符串</div><div class="line"> * @param start 要测量起始字符在字符串中的索引</div><div class="line"> * @param end   所要测量的字符的长度</div><div class="line"> * @param bounds 接收测量结果</div><div class="line"> */</div><div class="line">public void getTextBounds(String text, int start, int end, Rect bounds);</div></pre></td></tr></table></figure></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">String text = &quot;harvic\&apos;s blog&quot;;</div><div class="line">Paint paint = new Paint();</div><div class="line">// 设置paint</div><div class="line">paint.setTextSize(120); </div><div class="line"> </div><div class="line">Rect minRect = new Rect();</div><div class="line">paint.getTextBounds(text,0,text.length(),minRect);</div><div class="line">Log.e(&quot;xian&quot;,minRect.toShortString());</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-65a904e02b3acde3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到这个矩形的左上角位置为（8,-90），右下角的位置为（654,25）；大家可能会有疑问，为什么左上角的 Y 坐标是个负数？从代码中，我们也可以看到，我们并没有给 getTextBounds() 传递基线位置。那它就是以（0,0）为基线来得到这个最小矩形的，所以这个最小矩形的位置就是以（0,0）为基线的结果。</p><p>2）得到最小矩形的实际位置<br>我们先来看一个原理图：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-436e2f53ad881b18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在上面这个图中，我们将黑色矩形平行下移距离Y（黄色线依照的是基线的位置），那么平移后的左上角点的 y 坐标就是 y2 = y1 + Y。</p><p>同样的道理，由于 paint.getTextBounds() 得到最小矩形的基线是 y = 0；那我们直接将这个矩形移动 baseline 的距离就可以得到这个矩形实际应当在的位置了。</p><p>所以矩形应当所在实际位置的坐标是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Rect minRect = new Rect();</div><div class="line">paint.getTextBounds(text,0,text.length(),minRect);</div><div class="line">// 最小矩形，实际 top 位置</div><div class="line">int minTop = bounds.top + baselineY;</div><div class="line">// 最小矩形，实际 bottom 位置</div><div class="line">int minBottom = bounds.bottom + baselineY;</div></pre></td></tr></table></figure></p><p>3）完整的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line"></div><div class="line">    String text = &quot;harvic\&apos;s blog&quot;;</div><div class="line">    int baseLineY = 200;</div><div class="line">    int baseLineX = 0 ;</div><div class="line"></div><div class="line">    // 设置paint</div><div class="line">    Paint paint = new Paint();</div><div class="line">    paint.setTextSize(120); //以px为单位</div><div class="line">    paint.setTextAlign(Paint.Align.LEFT);</div><div class="line"></div><div class="line">    // 画text所占的区域</div><div class="line">    Paint.FontMetricsInt fm = paint.getFontMetricsInt();</div><div class="line">    int top = baseLineY + fm.top;</div><div class="line">    int bottom = baseLineY + fm.bottom;</div><div class="line">    int width = (int)paint.measureText(text);</div><div class="line">    Rect rect = new Rect(baseLineX,top,baseLineX+width,bottom);</div><div class="line"></div><div class="line">    paint.setColor(Color.GREEN);</div><div class="line">    canvas.drawRect(rect,paint);</div><div class="line"></div><div class="line">    // 画最小矩形</div><div class="line">    Rect minRect = new Rect();</div><div class="line">    paint.getTextBounds(text,0,text.length(),minRect);</div><div class="line">    minRect.top = baseLineY + minRect.top;</div><div class="line">    minRect.bottom = baseLineY + minRect.bottom;</div><div class="line">    paint.setColor(Color.RED);</div><div class="line">    canvas.drawRect(minRect,paint);</div><div class="line"></div><div class="line">    // 写文字</div><div class="line">    paint.setColor(Color.BLACK);</div><div class="line">    canvas.drawText(text, baseLineX, baseLineY, paint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ebb6cef9d9cbf11e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><div id="jump4"></div></p><h3 id="6-2-4-示例：定点写字"><a href="#6-2-4-示例：定点写字" class="headerlink" title="6.2.4 示例：定点写字"></a>6.2.4 示例：定点写字</h3><h4 id="1-给定左上顶点绘图"><a href="#1-给定左上顶点绘图" class="headerlink" title="1. 给定左上顶点绘图"></a>1. 给定左上顶点绘图</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ea033f084880c022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在这个图中，我们给定左上角的位置，即 (left,top)；我们知道要画文字，drawText() 中传进去的 Y 坐标是基线的位置，所以我们就必须根据 top 的位置计算出 baseline 的位置。</p><p>我们来看一个公式：<br>FontMetrics.top = top - baseline;</p><p>所以：<br>baseline = top - FontMetrics.top;</p><p>因为 FontMetrics.top 是可以得到的，又因为我们的 top 坐标是给定的，所以通过这个公式就能得到 baseline 的位置了。</p><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Paint.FontMetrics mFm;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setTextSize(120);</div><div class="line">        mPaint.setTextAlign(Paint.Align.LEFT);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        mFm = mPaint.getFontMetrics();</div><div class="line">        float top = 0;</div><div class="line">        int baseLineX = 0;</div><div class="line">        float baseLineY = top - mFm.top;</div><div class="line"></div><div class="line">        // 写文字</div><div class="line">        canvas.drawText(&quot;harvic\&apos;s blog&quot;, 0, baseLineY, mPaint);</div><div class="line"></div><div class="line">        // 画基线</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        canvas.drawLine(baseLineX, baseLineY, 3000, baseLineY, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="2-给定中间线位置绘图"><a href="#2-给定中间线位置绘图" class="headerlink" title="2. 给定中间线位置绘图"></a>2. 给定中间线位置绘图</h4><p>先来看一张图：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1072d0900b738e32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在这个图中，总共有四条线：top 线、bottom 线、baseline 和 center线。其中 center 线正是在 top 线和 bottom 线的正中间。</p><p>为了方便推导公式，另外标了三个距离 A、B、C。显然，距离 A 和距离 C 是相等的，都等于文字所在矩形高度以的一半，即 A = C = (bottom - top)/2。</p><p>又因为：<br>bottom = baseline + FontMetrics.bottom<br>top = baseline + FontMetrics.top<br>将这两个公式代入上面的公式，就可得到：<br>A = C = (FontMetrics.bottom - FontMetrics.top)/2</p><p>而距离 B 则表示 center 线到 baseline 的距离。很显然距离<br>B = C - (bottom - baseline)</p><p>又因为：<br>FontMetrics.bottom = bottom - baseline<br>C = A<br>所以：<br>B = A - FontMetrics.bottom</p><p>从而有：<br>baseline = center + B = center + A - FontMetrics.bottom = center + (FontMetrics.bottom - FontMetrics.top)/2 - FontMetrics.bottom</p><p>根据上面的推导过程，我们最终可知，当给定中间线 center 位置以后，baseline 的位置为：<br>baseline = center + (FontMetrics.bottom - FontMetrics.top)/2 - FontMetrics.bottom</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-5013074679f6ea8e.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06.1 精通自定义 View 之 Paint 基本使用——硬件加速</title>
      <link href="/2019/07/06/05%20CUSTOM%20VIEW/06.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/"/>
      <url>/2019/07/06/05%20CUSTOM%20VIEW/06.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-fc664ea4562be547.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><a href="https://www.jianshu.com/p/7a832e074b69" target="_blank" rel="external">参考文档：硬件加速</a></p><p><div id="jump1"></div></p><h3 id="6-1-1-本质和原理"><a href="#6-1-1-本质和原理" class="headerlink" title="6.1.1 本质和原理"></a>6.1.1 本质和原理</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><p>所谓硬件加速，指的是把某些计算工作交给专门的硬件来做，而不是和普通的计算工作一样交给 CPU 来处理。这样不仅减轻了 CPU 的压力，而且由于有了「专人」的处理，这份计算工作的速度也被加快了。这就是「硬件加速」。</p><p>而对于 Android 来说，硬件加速有它专属的意思：在 Android 里，硬件加速专指把 View 中绘制的计算工作交给 GPU 来处理。进一步地再明确一下，这个「绘制的计算工作」指的就是把绘制方法中的那些 Canvas.drawXXX() 变成实际的像素这件事。</p><h4 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h4><p>在硬件加速关闭的时候，Canvas 绘制的工作方式是：把要绘制的内容写进一个 Bitmap，然后在之后的渲染过程中，这个 Bitmap 的像素内容被直接用于渲染到屏幕。这种绘制方式的主要计算工作在于把绘制操作转换为像素的过程（例如由一句 Canvas.drawCircle() 来获得一个具体的圆的像素信息），这个过程的计算是由 CPU 来完成的。大致就像这样：</p><p><img src="https://upload-images.jianshu.io/upload_images/2789715-2e12c05c18113d57.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/839/format/webp" alt=""></p><p>而开启硬件加速后，Canvas 的工作方式改变了：它把绘制的内容转为 GPU 的操作保存下来，然后交给 GPU 来完成显示工作。大致过程：</p><p><img src="https://upload-images.jianshu.io/upload_images/2789715-38ff7dae4e1cdd37.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/839/format/webp" alt=""></p><p>从上图可以看出，开启硬件加速后，绘制的计算工作有 CPU 交给 GPU，不过这怎么就能起到加速作用，让绘制变快了呢？</p><ul><li>本来 CPU 的工作，分摊一部分给 GPU，自然可以提高效率；</li><li>相对于 CPU 来说，GPU 自身的设计本来就对于很多常见类型内容的计算 (例如简单的圆形、方形) 具有优势；</li><li>由于绘制流程的不同；硬件加速在界面内容发生重绘的时候绘制流程可以得到优化，避免一些重复操作，从而大幅提升绘制效率。</li></ul><p>关于第三点，它的原理大致说一下：</p><p>关闭硬件加速时，绘制内容会被 CPU 转为实际的像素，然后直接渲染到屏幕，具体来说，这个「实际的像素」，是由 bitmap 承载的，在界面的某个 View 由于内容发生改变而调用 invalidat() 方法时，如果没有开启硬件加速，为了正确计算 bitmap 的像素，这个 View 的父 View、父 View 的父 View 乃至一直向上知道最顶级的 View，以及所有和它相交的 View，都需要被调用 invalidate() 来重绘，一个 View 的改变使得大半个界面甚至整个界面重绘一遍，这个工作量是非常大的。</p><p>而在开启硬件加速时，绘制的内容会被转换成 GPU 的操作保存下来 (承载的形式成为 displaylist，对应的类也叫作 DisplayList)，再转交给 GPU。由于所有绘制的内容都没有变成最终的像素，所以它们之间是相互独立的，那么在界面内容发生改变时，只需把发生了改变的 View 调用 invalidate() 方法以更新它所对应的 GPU 就好，至于它的父 View 和兄弟 View，只需要保持原样，那么这个工作量就很小了。</p><p>正是由于上面的原因，硬件加速不仅是由于 GPU 的引入提高效率，而且因为绘制机制的改变，而极大的提高了界面内容改变时的刷新效率。</p><p>总结：<strong>用了 GPU，绘制更快；绘制机制的改变，导致界面内容改变时的刷新效率极大提高。</strong></p><p><div id="jump2"></div></p><h3 id="6-1-2-在-Android-中的限制"><a href="#6-1-2-在-Android-中的限制" class="headerlink" title="6.1.2 在 Android 中的限制"></a>6.1.2 在 Android 中的限制</h3><p>可事实就是，硬件加速不止有好处，也有限制：收到 GPU 绘制方式的限制，Canvas 的有些方法在硬件加速开启时会失效或者无法正常工作，比如：开启硬件加速，clipPath() 在 API 18 及以上系统中才有效，具体的 API 限制和 API 版本的关系如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2789715-ea809b43011e9e11.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/783/format/webp" alt=""></p><p>所以，如果你对自定义控件有自定义绘制的内容，最好参照一下表格，确保你的绘制操作可以正确地在所有用户手机中正常显示，而不是只在你最新 Android 系统的 Nexus 或 Pixel 里测试一遍没问题就发布。那就小心被祭天了。</p><p><div id="jump3"></div></p><h3 id="6-1-3-禁用-GPU-硬件加速的方法"><a href="#6-1-3-禁用-GPU-硬件加速的方法" class="headerlink" title="6.1.3 禁用 GPU 硬件加速的方法"></a>6.1.3 禁用 GPU 硬件加速的方法</h3><p>1）在 AndroidManifest.xml 文件中为 application 标签添加如下属性，即可为整个应用程序开启/关闭硬件加速。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;application android:hardwareAccelerated=&quot;true&quot; ...&gt;</div></pre></td></tr></table></figure></p><p>2）在 AndroidManifest.xml 文件中为 activity 标签下使用 hardwareAccelerated 属性开启/关闭硬件加速。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;activity android:hardwareAccelerated=&quot;false&quot; ...&gt;</div></pre></td></tr></table></figure></p><p>3）在 Window 层级上使用如下代码开启硬件加速（Window 层级不支持关闭硬件加速）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">getWindow().setFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, </div><div class="line">     WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);</div></pre></td></tr></table></figure></p><p>4）在 View 层级上使用如下代码关闭硬件加速(在 View 层级上不支持开启硬件加速)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setLayerType(LAYER_TYPE_SOFTWARE,null);</div></pre></td></tr></table></figure></p><p>或者在layout xml中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:layerType=&quot;software&quot; &gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>事实上，view.setLayerType(LAYER_TYPE_SOFTWARE, null) 这个方法的作用并不是关闭硬件加速，只是当它的参数为 LAYER_TYPE_SOFTWARE 的时候，可以顺便把硬件加速关掉而已；并且除了这个方法外，Android 并没有提供专门的 View 级别的硬件加速开关，所以它就顺便成了一个开关硬件加速的方法。</p><ul><li>参数为 LAYER_TYPE_SOFTWARE 时，使用软件来绘制 View Layer，绘制到一个 Bitmap，并顺便关闭硬件加速；</li><li>参数为 LAYER_TYPE_HARDWARE 时，使用 GPU 来绘制 View Layer，绘制到一个 OpenGL texture (如果硬件加速关闭，那么行为和 LAYER_TYPE_SOFTWARE 一致)；</li><li>参数为 LAYER_TYPE_NONE 时，关闭 View Layer。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7dad129a07bc73a2.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05.2 精通自定义 View 之动画进阶——SVG 动画</title>
      <link href="/2019/07/05/05%20CUSTOM%20VIEW/05.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94SVG%20%E5%8A%A8%E7%94%BB/"/>
      <url>/2019/07/05/05%20CUSTOM%20VIEW/05.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94SVG%20%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ea7dda9b8ae82ec7.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="5-2-1-概述"><a href="#5-2-1-概述" class="headerlink" title="5.2.1 概述"></a>5.2.1 概述</h3><p>SVG 全称是 Scalable Vector Graphics（可缩放矢量图形），即 SVG 是矢量图。与矢量图对应的是位图，Bitmap 就是位图，它由一个个像素点组成，当图片放大到一定大小时，就会出现马赛克现象，Photoshop 就是常用的位图处理软件。而矢量图则由一个个点组成，经过数学计算利用直线和曲线绘制而成，无论如何放大，都不会出现马赛克现象，Illustrator 就是常用的矢量图绘图软件。</p><p>SVG 与 Bitmap 相比有以下好处：</p><ul><li>SVG 使用 XML 格式定义图形，可被非常多的工具读取和修改。</li><li>SVG 由点来存储，由计算机根据点信息绘图，不会失真，无须根据分辨率适配多套图标。</li><li>SVG 的占用空间明显比 Bitmap 小。如 500px X 500px 的图像，转成 SVG 后占用的空间大小是 20KB，而 PNG 图片则需要 732KB 的空间。</li><li>SVG 可以转换为 Path 路径，与 Path 动画相结合，可以形成丰富的动画。</li></ul><p>对于 Android 5.0 以下的机型，可以通过引入 com.android.support:appcompat-v7:23.4.0 及以上版本进行支持。</p><p>Android 并没有对原生的 SVG 图像语法进行支持，而是以一种简化的方式对 SVG 进行兼容，也就是通过使用它的 path 标签，几乎可以实现 SVG 中的其他所有标签。这些东西可以通过工具来完成。</p><p><div id="jump2"></div></p><h3 id="5-2-2-vector-标签与图像显示"><a href="#5-2-2-vector-标签与图像显示" class="headerlink" title="5.2.2 vector 标签与图像显示"></a>5.2.2 vector 标签与图像显示</h3><p>res/drawable/svg.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:width=&quot;200dp&quot;</div><div class="line">    android:height=&quot;100dp&quot;</div><div class="line">    android:viewportWidth=&quot;100&quot;</div><div class="line">    android:viewportHeight=&quot;50&quot;&gt;</div><div class="line">    &lt;path</div><div class="line">        android:name=&quot;bar&quot;</div><div class="line">        android:pathData=&quot;M50,23 L100,23&quot;</div><div class="line">        android:strokeWidth=&quot;2&quot;</div><div class="line">        android:strokeColor=&quot;@color/colorAccent&quot;/&gt;</div><div class="line">&lt;/vector&gt;</div></pre></td></tr></table></figure></p><p>效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c19a24bc41592925.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>vector 标签：指定画布大小，上图蓝框区域。</li><li>path 标签：绘制路径，对应上图中的红色线段。</li><li>width &amp; height 属性：表示该 SVG 图形的具体大小。</li><li>viewportWidth &amp; viewportHeight 属性：表示 SVG 图形划分的比例。</li></ul><p>width &amp; height 类似于指定画布的大小，而 viewportWidth &amp; viewportHeight 则是指将画布的宽、高分为多少个点，而 Path 中的点坐标都是以 viewportWidth &amp; viewportHeight 的点数为坐标的，而不是 dp 值。此处将宽度 200dp 分为 100 个点，在高度 100dp 分为 50 个点，每个点有 2dp。而 path 中字母 M 表示 moveTo，字母 L 表示 lineTo，所以，这里代表从（50, 23) 到点 (100, 23) 画了一条线段。</p><h4 id="1-path-标签"><a href="#1-path-标签" class="headerlink" title="1. path 标签"></a>1. path 标签</h4><p>1）常用属性</p><ul><li>android:name：声明一个标记，类似于 ID。</li><li>android:pathData：对 SVG 矢量图的描述。</li><li>android:strokeWidth：画笔的宽度</li><li>android:fillColor：填充颜色。</li><li>android:fillAlpha：填充颜色的透明度。</li><li>android:strokeColor：描边颜色。</li><li>android:strokeWidth：描边宽度。</li><li>android:strokeAlpha：描边透明度。</li><li>android:strokeLineJoin：用于指定折线拐角形状，取值有 miter（结合处为锐角）、round（结合处为圆弧）、bevel（结合处为直线）。</li><li>android:strokeLineCap：画出线条的终点的形状（线帽），取值有 butt（无线帽）、round（圆形线帽）、square（方形线帽）</li><li>android:strokeMiterLimit：设置斜角的上限。当 strokeLineJoin 为 “round” 或 “bevel” 时，该属性无效。</li></ul><p>2）android:trimPathStart 属性<br>该属性用于指定路径从哪里开始，取值为 0~1，表示路径开始位置的百分比。取值为 0 时，表示从头开始；取值为 1 时，整条路径不可见。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;path</div><div class="line">    android:name=&quot;bar&quot;</div><div class="line">    android:pathData=&quot;M50,23 L100,23&quot;</div><div class="line">    android:strokeWidth=&quot;2&quot;</div><div class="line">    android:trimPathStart=&quot;0.5&quot;</div><div class="line">    android:strokeColor=&quot;@color/colorAccent&quot;/&gt;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-343a12e0dc24f75c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>灰色部分代表的是被删除的部分，实际上是不会显示出来的，这里只是为了展示效果，下同。</p><p>3）android:trimPathEnd 属性<br>该属性用于指定路径的结束位置，取值为 0~1，表是路径结束位置的百分比。取值为 1 时，路径正常结束；取值为 0 时，表示从开始位置就已经结束了，即整条路径不可见。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;path</div><div class="line">    android:name=&quot;bar&quot;</div><div class="line">    android:pathData=&quot;M50,23 L100,23&quot;</div><div class="line">    android:strokeWidth=&quot;2&quot;</div><div class="line">    android:trimPathEnd=&quot;0.8&quot;</div><div class="line">    android:strokeColor=&quot;@color/colorAccent&quot;/&gt;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a913b917f9134edd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>4）android:trimPathOffset 属性<br>该属性用于指定路径的位移距离，取值 0~1。取值为 0 时，不位移；当取值 为 1 时，位移整条路径的长度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;path</div><div class="line">    android:name=&quot;bar&quot;</div><div class="line">    android:pathData=&quot;M50,23 L100,23&quot;</div><div class="line">    android:strokeWidth=&quot;2&quot;</div><div class="line">    android:trimPathStart=&quot;0.2&quot;</div><div class="line">    android:trimPathEnd=&quot;0.4&quot;</div><div class="line">    android:trimPathOffset=&quot;0.6&quot;</div><div class="line">    android:strokeColor=&quot;@color/colorAccent&quot;/&gt;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b3fd2fce5e592895.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>5）android:pathData 属性<br>指定 SVG 图像的显示内容。</p><ul><li>M = moveTo(M X,Y)：将画笔移动到指定的坐标位置。</li><li>L = lineTo(L X,Y)：画直线到指定的坐标位置。</li><li>H = horizontal lineTo(H X)：画水平线到指定的 X 坐标位置。</li><li>V = vertical lineTo(V Y)：画垂直线到指定的 Y 坐标位置。</li><li>C = curveTo(C X1,Y1,X2,Y2,ENDX,ENDY)：三阶贝济埃曲线。</li><li>S = smooth curveTo(S X2,Y2,ENDX,ENDY)：三阶贝济埃曲线。S 指令会将上一条指令的终点作为这条指令的起始点。</li><li>Q = quadratic Bezier curve(Q X,Y,ENDX,ENDY)：二阶贝济埃曲线。</li><li>T = smooth quadratic Bezier curveTo(T ENDX,ENDY)：映射前面路径后的终点。</li><li>A = elliptical Arc(A RX,RY,XROTATION,FLAG1,FLAG2,X,Y)：弧线。</li><li>Z = closePath()：关闭路径。</li></ul><p>使用上面的指令时，需要注意的几点：</p><ul><li>坐标轴以（0,0）位中心，X轴水平向右，Y轴水平向下。</li><li>所有指令大小写均可，大写绝对定位，参照全局坐标系，小写相对定位，参照父容器坐标系。</li><li>指令和数据间的空格可以无视。</li><li>同一指令出现多次可以用一个。</li></ul><h4 id="2-group-标签"><a href="#2-group-标签" class="headerlink" title="2. group 标签"></a>2. group 标签</h4><p>group 标签用于定义一系列路径或者将 path 标签分组。具有以下常用属性。</p><ul><li>android:name：组的名称，用于与动画相关联。</li><li>android:rotation：指定该组图像的旋转度数。</li><li>android:pivotX：定义缩放和旋转该组时的 X 参考点。</li><li>android:pivotY：定义缩放和旋转该组时的 Y 参考点。</li><li>android:scaleX：指定该组 X 轴缩放大小。</li><li>android:scaleY：指定该组 Y 轴缩放大小。</li><li>android:translateX：指定该组沿 X 轴平移的距离。</li><li>android:translateY：指定该组沿 Y 轴平移的距离。</li></ul><p>示例：围绕画布中心旋转 90 度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:width=&quot;200dp&quot;</div><div class="line">    android:height=&quot;100dp&quot;</div><div class="line">    android:viewportWidth=&quot;100&quot;</div><div class="line">    android:viewportHeight=&quot;50&quot;&gt;</div><div class="line">    &lt;group</div><div class="line">        android:rotation=&quot;90&quot;</div><div class="line">        android:pivotX=&quot;50&quot;</div><div class="line">        android:pivotY=&quot;25&quot;&gt;</div><div class="line">        &lt;path</div><div class="line">            android:name=&quot;bar&quot;</div><div class="line">            android:pathData=&quot;M50,23 L100,23&quot;</div><div class="line">            android:strokeWidth=&quot;2&quot;</div><div class="line">            android:strokeColor=&quot;@color/colorAccent&quot;/&gt;</div><div class="line">    &lt;/group&gt;</div><div class="line">&lt;/vector&gt;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-574df53f3790cc98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="3-制作-SVG-图像"><a href="#3-制作-SVG-图像" class="headerlink" title="3. 制作 SVG 图像"></a>3. 制作 SVG 图像</h4><p>方法一：设计软件<br>如果有绘图基础，可以直接使用 Illustrator 或在线 SVG 工具制作 SVG 图像（如 <a href="http://editor.method.ac/" target="_blank" rel="external">http://editor.method.ac/</a>），或者通过 SVG 源文件下载网站下载后进行编辑。</p><p>方法二：Iconfont<br>有很多 Iconfont 开源网站，比如国内的阿里巴巴矢量图库，地址为 <a href="http://www.iconfont.cn/" target="_blank" rel="external">http://www.iconfont.cn/</a>。</p><h4 id="4-在-Android-中引入-SVG-图像"><a href="#4-在-Android-中引入-SVG-图像" class="headerlink" title="4. 在 Android 中引入 SVG 图像"></a>4. 在 Android 中引入 SVG 图像</h4><p>在 Android 中是不支持 SVG 图像解析的，我们必须将 SVG 图像转换为 vector 标签描述，这里同样有两种方法。</p><p>方法一：<a href="http://inloop.github.io/svg2android/" target="_blank" rel="external">在线转换</a>。<br>This tool has been deprecated. Use official <a href="https://developer.android.com/studio/write/vector-asset-studio#svg" target="_blank" rel="external"><strong>Vector Asset Studio</strong></a> instead.</p><p>方法二：Vector Asset Studio<br>Android Studio 2.0 及以上版本中支持创建 Vector 文件，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-9ff6527094fa10b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-818c4a056b161b50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h4><p>1）引入兼容包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">compile &apos;com.android.support:appcompat-v7:23.4.0&apos;</div><div class="line">// 或使用 androidx</div><div class="line">implementation &apos;androidx.appcompat:appcompat:1.0.2&apos;</div></pre></td></tr></table></figure></p><p>在项目的 build.gradle 脚本中添加对 Vector 兼容性的支持。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    defaultConfig &#123;</div><div class="line">        vectorDrawables.useSupportLibrary = true</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>2）生成 Vector 图像<br>使用前面例子中的一条横线的 Vector 图像（src/drawable/svg.xml）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:width=&quot;200dp&quot;</div><div class="line">    android:height=&quot;100dp&quot;</div><div class="line">    android:viewportWidth=&quot;100&quot;</div><div class="line">    android:viewportHeight=&quot;50&quot;&gt;</div><div class="line">    &lt;path</div><div class="line">        android:name=&quot;bar&quot;</div><div class="line">        android:pathData=&quot;M50,23 L100,23&quot;</div><div class="line">        android:strokeWidth=&quot;2&quot;</div><div class="line">        android:strokeColor=&quot;@color/colorAccent&quot;/&gt;</div><div class="line">&lt;/vector&gt;</div></pre></td></tr></table></figure></p><p>3）在 ImageView、ImageButton 中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;ImageView</div><div class="line">    android:id=&quot;@+id/iv&quot;</div><div class="line">    android:layout_width=&quot;wrap_content&quot;</div><div class="line">    android:layout_height=&quot;wrap_content&quot;</div><div class="line">    app:srcCompat=&quot;@drawable/svg&quot;/&gt;</div></pre></td></tr></table></figure></p><p>在代码中设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ImageView iv = findViewById(R.id.iv);</div><div class="line">iv.setImageResource(R.drawable.svg);</div></pre></td></tr></table></figure></p><blockquote><p>本人测试使用 android:background=”@drawable/svg” 也是正常的。测试机型 Pixel XL，Android 7.1.2。</p></blockquote><p>4）在 Button、RadioButton 中使用<br>Button 并不能直接通过 app:srcCompat 属性来使用 Vector 图像，而需要通过 selector 标签来使用（selector_svg.xml）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</div><div class="line">    &lt;item android:drawable=&quot;@drawable/svg&quot; android:state_pressed=&quot;true&quot;/&gt;</div><div class="line">    &lt;item android:drawable=&quot;@drawable/svg&quot;/&gt;</div><div class="line">&lt;/selector&gt;</div></pre></td></tr></table></figure></p><p>如果到这里并不能直接运行，需要把下面这段代码放在 Activity 的前面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line">    static &#123;</div><div class="line">        AppCompatDelegate.setCompatVectorFromResourcesEnabled(true);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>本人测试可以直接使用 android:background=”@drawable/svg” 并且不需要在 Activity 中加入上述代码 即可正常运行。测试机型 Pixel XL，Android 7.1.2。</p></blockquote><p><div id="jump3"></div></p><h3 id="5-2-3-动态-Vector"><a href="#5-2-3-动态-Vector" class="headerlink" title="5.2.3 动态 Vector"></a>5.2.3 动态 Vector</h3><p>实现 Vector 动画，步骤如下：<br>1）使用上述 drawable/svg.xml<br>2）创建 animator/anim_trim_start.xml 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:propertyName=&quot;trimPathStart&quot;</div><div class="line">    android:valueFrom=&quot;0&quot;</div><div class="line">    android:valueTo=&quot;1&quot;</div><div class="line">    android:duration=&quot;2000&quot;/&gt;</div></pre></td></tr></table></figure></p><p>3）关联 Vector &amp; Animator。drawable/animated_vector.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;animated-vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:drawable=&quot;@drawable/svg&quot;&gt;</div><div class="line">    &lt;target</div><div class="line">        android:animation=&quot;@animator/anim_trim_start&quot;</div><div class="line">        android:name=&quot;bar&quot;/&gt;</div><div class="line">&lt;/animated-vector&gt;</div></pre></td></tr></table></figure></p><p>4）最后在代码中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        final ImageView imageView = findViewById(R.id.iv);</div><div class="line">        AnimatedVectorDrawableCompat compat = AnimatedVectorDrawableCompat.create(</div><div class="line">                MainActivity.this, R.drawable.animated_vector);</div><div class="line">        imageView.setImageDrawable(compat);</div><div class="line"></div><div class="line">        findViewById(R.id.btn).setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                ((Animatable) imageView.getDrawable()).start();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果图如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-07e5d6f4bfb689d8.gif?imageMogr2/auto-orient/strip" alt=""></p><p><div id="jump4"></div></p><h3 id="5-2-4-示例：输入搜索动画"><a href="#5-2-4-示例：输入搜索动画" class="headerlink" title="5.2.4 示例：输入搜索动画"></a>5.2.4 示例：输入搜索动画</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a5ed5dd59e09fc2c.gif?imageMogr2/auto-orient/strip" alt=""></p><h4 id="1-准备-SVG-图像"><a href="#1-准备-SVG-图像" class="headerlink" title="1. 准备 SVG 图像"></a>1. 准备 SVG 图像</h4><p>res/drawable/svg.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:width=&quot;150dp&quot;</div><div class="line">    android:height=&quot;24dp&quot;</div><div class="line">    android:viewportWidth=&quot;150&quot;</div><div class="line">    android:viewportHeight=&quot;24&quot;&gt;</div><div class="line">    &lt;!-- 搜索图形 --&gt;</div><div class="line">    &lt;path</div><div class="line">        android:name=&quot;search&quot;</div><div class="line">        android:pathData=&quot;M141,17 A9,9 0 1,1 142,16 L149,23&quot;</div><div class="line">        android:strokeWidth=&quot;2&quot;</div><div class="line">        android:strokeColor=&quot;@color/colorAccent&quot;/&gt;</div><div class="line">    &lt;path</div><div class="line">        android:name=&quot;bar&quot;</div><div class="line">        android:trimPathStart=&quot;1&quot;</div><div class="line">        android:pathData=&quot;M0,23 L149,23&quot;</div><div class="line">        android:strokeWidth=&quot;2&quot;</div><div class="line">        android:strokeColor=&quot;@color/colorAccent&quot;/&gt;</div><div class="line">&lt;/vector&gt;</div></pre></td></tr></table></figure></p><h4 id="2-准备动画"><a href="#2-准备动画" class="headerlink" title="2. 准备动画"></a>2. 准备动画</h4><p>res/animator/anim_bar_trim_start.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:propertyName=&quot;trimPathStart&quot;</div><div class="line">    android:valueFrom=&quot;0&quot;</div><div class="line">    android:valueTo=&quot;1&quot;</div><div class="line">    android:valueType=&quot;floatType&quot;</div><div class="line">    android:duration=&quot;500&quot;/&gt;</div></pre></td></tr></table></figure></p><p>res/animator/anim_search_trim_start.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:propertyName=&quot;trimPathEnd&quot;</div><div class="line">    android:valueFrom=&quot;0&quot;</div><div class="line">    android:valueTo=&quot;1&quot;</div><div class="line">    android:valueType=&quot;floatType&quot;</div><div class="line">    android:duration=&quot;500&quot;/&gt;</div></pre></td></tr></table></figure></p><p>关联 Vector &amp; Animator<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;animated-vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:drawable=&quot;@drawable/svg&quot;&gt;</div><div class="line">    &lt;target</div><div class="line">        android:animation=&quot;@animator/anim_bar_trim_start&quot;</div><div class="line">        android:name=&quot;bar&quot;/&gt;</div><div class="line">    &lt;target</div><div class="line">        android:animation=&quot;@animator/anim_search_trim_start&quot;</div><div class="line">        android:name=&quot;search&quot;/&gt;</div><div class="line">&lt;/animated-vector&gt;</div></pre></td></tr></table></figure></p><h4 id="3-布局与开始动画"><a href="#3-布局与开始动画" class="headerlink" title="3. 布局与开始动画"></a>3. 布局与开始动画</h4><p>res/layout/act_main.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;FrameLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:padding=&quot;20dp&quot; &gt;</div><div class="line">    &lt;EditText</div><div class="line">        android:id=&quot;@+id/edit&quot;</div><div class="line">        android:layout_width=&quot;150dp&quot;</div><div class="line">        android:layout_height=&quot;24dp&quot;</div><div class="line">        android:hint=&quot;点击输入&quot;</div><div class="line">        android:background=&quot;@null&quot;/&gt;</div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/iv&quot;</div><div class="line">        android:layout_width=&quot;150dp&quot;</div><div class="line">        android:layout_height=&quot;24dp&quot; /&gt;</div><div class="line">&lt;/FrameLayout&gt;</div></pre></td></tr></table></figure></p><p>开始动画代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        final ImageView imageView = findViewById(R.id.iv);</div><div class="line">        // 将焦点放在 ImageView 上</div><div class="line">        imageView.setFocusable(true);</div><div class="line">        imageView.setFocusableInTouchMode(true);</div><div class="line">        imageView.requestFocus();</div><div class="line">        imageView.requestFocusFromTouch();</div><div class="line"></div><div class="line">        EditText editText = findViewById(R.id.edit);</div><div class="line">        editText.setOnFocusChangeListener(new View.OnFocusChangeListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onFocusChange(View v, boolean hasFocus) &#123;</div><div class="line">                AnimatedVectorDrawableCompat compat = AnimatedVectorDrawableCompat.create(</div><div class="line">                        MainActivity.this, R.drawable.animated_vector);</div><div class="line">                imageView.setImageDrawable(compat);</div><div class="line">                ((Animatable) imageView.getDrawable()).start();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-6038ddbd1ad31a52.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05.1 精通自定义 View 之动画进阶——利用 PathMeasure 实现路径动画</title>
      <link href="/2019/07/05/05%20CUSTOM%20VIEW/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/"/>
      <url>/2019/07/05/05%20CUSTOM%20VIEW/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-6022ab8445f95237.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p>PathMeasure 类似一个计算器，可以计算出指定路径的一些信息，比如路径总长、指定长度所对应的坐标等。我们可以通过 PathMeasure 可以实现复杂的动画效果。</p><p><div id="jump1"></div></p><h3 id="5-1-1-初始化"><a href="#5-1-1-初始化" class="headerlink" title="5.1.1 初始化"></a>5.1.1 初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 初始化方法一</div><div class="line">public PathMeasure();</div><div class="line">setPath(Path path, boolean forceClosed);</div><div class="line"></div><div class="line">// 初始化方法二</div><div class="line">public PathMeasure(Path path, boolean forceClosed);</div></pre></td></tr></table></figure><p>参数 boolean forceClosed 表示Path 最终是否需要闭合，如果为 true，则不管关联的 Path 是否是闭合的，都会被闭合。但是 forceClosed 参数对绑定的 Path 不会产生任何影响，例如一个折线段的 Path，本身是没有闭合的，当 forceClosed 设置为 true 的时候，PathMeasure 计算的 Path 是闭合的，但 Path 绘制出来的是不会闭合的。forceClosed 参数只对 PathMeasure 的测量结果有影响，例如一个折线段的 Path，本身没有闭合，当 forceClosed 设置为 true 时，PathMeasure 的计算就会包含最后一段闭合的路径，与原来的 Path 不同。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line">    private PathMeasure mPathMeasureFalse;</div><div class="line">    private PathMeasure mPathMeasureTrue;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.BLACK);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(8);</div><div class="line"></div><div class="line">        mPath = new Path();</div><div class="line">        mPath.moveTo(50, 50);</div><div class="line">        mPath.lineTo(50, 150);</div><div class="line">        mPath.lineTo(150, 150);</div><div class="line">        mPath.lineTo(150, 50);</div><div class="line"></div><div class="line">        mPathMeasureFalse = new PathMeasure(mPath, false);</div><div class="line">        mPathMeasureTrue = new PathMeasure(mPath, true);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        Log.i(&quot;xian&quot;, &quot;forceClosed=false----&gt;&quot; + mPathMeasureFalse.getLength());</div><div class="line">        Log.i(&quot;xian&quot;, &quot;forceClosed=true-----&gt;&quot; + mPathMeasureTrue.getLength());</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-adc6485f5f2929f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="path 图"></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-6c7df70a4f1b8325.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="日志输出"></p><p>从图中可以看到，我们创建的只是正方形的三条边，而日志打印结果表示：如果 forceClosed 为 false，则测量的是当前 Path 状态的长度；如果 forceClosed 为 true，则不论 Path 是否闭合，测量的都是 Path 的闭合长度。</p><p><div id="jump2"></div></p><h3 id="5-1-2-简单函数使用"><a href="#5-1-2-简单函数使用" class="headerlink" title="5.1.2 简单函数使用"></a>5.1.2 简单函数使用</h3><h4 id="1-getLength"><a href="#1-getLength" class="headerlink" title="1. getLength()"></a>1. getLength()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 获取一段路径的长度，不一定是整个 Path 的长度</div><div class="line">public float getLength()</div></pre></td></tr></table></figure><h4 id="2-isClosed"><a href="#2-isClosed" class="headerlink" title="2. isClosed()"></a>2. isClosed()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 判断测量 Path 时是否计算闭合，返回值是 forceClosed</div><div class="line">public boolean isClosed()</div></pre></td></tr></table></figure><h4 id="3-nextContour"><a href="#3-nextContour" class="headerlink" title="3. nextContour()"></a>3. nextContour()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public boolean nextContour()</div></pre></td></tr></table></figure><p>Path 可以由多条曲线构成，但不论是 getLength()、getSegment() 还是其他函数，都会只针对其中第一条线段进行计算。而 nextContour() 就是用于跳转到下一条曲线的函数。如果跳转成功，则返回 true；如果跳转失败，则返回 false。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath1, mPath2, mPath3;</div><div class="line">    private PathMeasure mPathMeasure;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.BLACK);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(8);</div><div class="line"></div><div class="line">        mPath1 = new Path();</div><div class="line">        mPath1.addRect(-50, -50, 50, 50, Path.Direction.CW);</div><div class="line">        mPath2 = new Path();</div><div class="line">        mPath2.addRect(-100, -100, 100, 100, Path.Direction.CW);</div><div class="line">        mPath3 = new Path();</div><div class="line">        mPath3.addRect(-120, -120, 120, 120, Path.Direction.CW);</div><div class="line">        mPathMeasure = new PathMeasure();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        canvas.translate(150, 150);</div><div class="line"></div><div class="line">        // 只绘画最大的区域</div><div class="line">        // mPath.addRect(-50, -50, 50, 50, Path.Direction.CW);</div><div class="line">        // mPath.addRect(-100, -100, 100, 100, Path.Direction.CW);</div><div class="line">        // mPath.addRect(-120, -120, 120, 120, Path.Direction.CW);</div><div class="line">        // canvas.drawPath(mPath, mPaint);</div><div class="line"></div><div class="line">        mPath1.addPath(mPath2);</div><div class="line">        mPath1.addPath(mPath3);</div><div class="line">        canvas.drawPath(mPath1, mPaint);</div><div class="line">        mPathMeasure.setPath(mPath1, false);</div><div class="line"></div><div class="line">        do &#123;</div><div class="line">            float len = mPathMeasure.getLength();</div><div class="line">            Log.i(&quot;xian&quot;, &quot;len=&quot; + len);</div><div class="line">        &#125; while (mPathMeasure.nextContour());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-fcf22a7220079a96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-aee6cf7489e70d83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="日志打印结果"></p><p>通过这个例子可以得出以下结论：</p><ul><li>nextContour() 函数得到的曲线的顺序与 Path 中添加的顺序相同。</li><li>getLength() 等函数针对的是当前线段，不是整个 Path。</li></ul><p><div id="jump3"></div></p><h3 id="5-1-3-getSegment-函数"><a href="#5-1-3-getSegment-函数" class="headerlink" title="5.1.3 getSegment() 函数"></a>5.1.3 getSegment() 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public boolean getSegment(float startD, float stopD, Path dst, boolean startWithMoveTo)</div></pre></td></tr></table></figure><p>用于截取整个 Path 中的某个片段，通过参数 startD 与 stopD 来控制截取的长度，并将截取后的 Path 保存并添加（不是替换）到参数 dst 中。startWithMoveTo 表示起始点是否使用 moveTo 将路径的新起点移动到结果 Path 的起始点，通常设置为 true，以保证每次截取的 Path 都是正常的、完整的；如果设置为 false，则新增的片段会从上一次 Path 终点开始计算，这样可以保证截取的 Path 片段是连续的，但不一定时正常的。</p><p>注意：</p><ul><li>如果 startD、stopD 的数值不在取值范围 [0, getLength] 内，或者 startD == stopD，则返回值为 false，而且不会改变 dst 中的内容。</li><li>使用 getSegment() 函数时需要禁用硬件加速功能。 setLayerType(LAYER_TYPE_SOFTWARE, null)。</li></ul><p>示例一：用法举例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath, mDst;</div><div class="line">    private PathMeasure mPathMeasure;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.BLACK);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(8);</div><div class="line"></div><div class="line">        mPath = new Path();</div><div class="line">        mPath.addRect(-50, -50, 50, 50, Path.Direction.CW);</div><div class="line">        mDst = new Path();</div><div class="line">        mPathMeasure = new PathMeasure(mPath, false);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        canvas.translate(100, 100);</div><div class="line">        mPathMeasure.getSegment(0, 150, mDst, true);</div><div class="line">        canvas.drawPath(mDst, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ace4ca83b064f380.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>结论一：路径截取是以路径的左上角为起始点开始的。</p></blockquote><p>示例二：逆时针<br>将生成路径的方式指定为逆时针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// mPath.addRect(-50, -50, 50, 50, Path.Direction.CW);</div><div class="line">mPath.addRect(-50, -50, 50, 50, Path.Direction.CCW);</div></pre></td></tr></table></figure></p><p>效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c571e32b3e662b87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>结论二：路径的截取方向与路径的生成方向相同。</p></blockquote><p>示例三：如果 dst 路径不为空<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mDst = new Path();</div><div class="line">mDst.lineTo(10, 100);</div><div class="line">mPathMeasure = new PathMeasure(mPath, false);</div></pre></td></tr></table></figure></p><p>效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-fb56b254e3f2b72b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>结论三：会将截取的 Path 片段添加到路径 dst 中，而不是替换 dst 中的内容。</p></blockquote><p>示例四：如果 startWithMoveTo 参数为 false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// mPathMeasure.getSegment(0, 150, mDst, true);</div><div class="line">mPathMeasure.getSegment(0, 150, mDst, false);</div></pre></td></tr></table></figure></p><p>效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c63826461afbc1d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>结论四：如果 startWithMoveTo 为 true，则被截取出来的 Path 片段保持原状；如果 startWithMoveTo 为 false，则会截取出来的 Path 片段的起始点移动到 dst 的最后一个点，以保证 dst 路径的连续性。</p></blockquote><h4 id="示例：路径加载动画"><a href="#示例：路径加载动画" class="headerlink" title="示例：路径加载动画"></a>示例：路径加载动画</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0e3076580b729727.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mCirclePath, mDstPath;</div><div class="line">    private PathMeasure mPathMeasure;</div><div class="line">    private float mCurAnimValue;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.BLACK);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(4);</div><div class="line"></div><div class="line">        mDstPath = new Path();</div><div class="line">        mCirclePath = new Path();</div><div class="line">        mCirclePath.addCircle(100, 100, 50, Path.Direction.CW);</div><div class="line">        mPathMeasure = new PathMeasure(mCirclePath, false);</div><div class="line"></div><div class="line">        ValueAnimator animator = ValueAnimator.ofFloat(0, 1);</div><div class="line">        animator.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">                mCurAnimValue = (Float) animation.getAnimatedValue();</div><div class="line">                invalidate();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        animator.setDuration(1000);</div><div class="line">        animator.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawColor(Color.WHITE);</div><div class="line">        float stop = mPathMeasure.getLength() * mCurAnimValue;</div><div class="line">        mDstPath.reset();</div><div class="line">        mPathMeasure.getSegment(0, stop, mDstPath, true);</div><div class="line">        canvas.drawPath(mDstPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述示例中，在生成动画路径时，始终是从 0 位置开始的。如果我们稍微改变一下生成路径的起始点位置，就可以完成一个比较有意思的加载图动画，效果图如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0bb7aa97dfd0d0db.gif?imageMogr2/auto-orient/strip" alt=""></p><p>修改代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line">    canvas.drawColor(Color.WHITE);</div><div class="line">    float length = mPathMeasure.getLength();</div><div class="line">    float stop = length * mCurAnimValue;</div><div class="line">    float start = (float) (stop - ((0.5 - Math.abs(mCurAnimValue - 0.5)) * length));</div><div class="line">    mDstPath.reset();</div><div class="line">    mPathMeasure.getSegment(start, stop, mDstPath, true);</div><div class="line">    canvas.drawPath(mDstPath, mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><div id="jump4"></div></p><h3 id="5-1-4-getPosTan-函数"><a href="#5-1-4-getPosTan-函数" class="headerlink" title="5.1.4 getPosTan() 函数"></a>5.1.4 getPosTan() 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean getPosTan(float distance, float[] pos, float[] tan)</div></pre></td></tr></table></figure><p>用于得到路径上某一长度的位置以及该位置的正切值。参数：</p><ul><li>float distance：距离 Path 起始点的长度，取值范围 0 ≤ distance ≤ getLength。</li><li>float[] pos：该点的坐标值。pos[0] 表示 x 坐标，pos[1] 表示 y 坐标。</li><li>float[] tan：该点的正切值。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/14186083-52fa16f0ba77e7a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="半径为1的各点的坐标值"></p><p>在 Math 类中，有两个求反切值的函数，即夹角 a 的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">double atan(double d)</div><div class="line">double atan2(double x, double y)</div></pre></td></tr></table></figure></p><p>示例：飞机加载动画</p><p><img src="https://upload-images.jianshu.io/upload_images/10002669-6f7a869e08621eb2.png?imageMogr2/auto-orient/strip|imageView2/2/w/808/format/webp" alt="动画原理"></p><p>动画效果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-49a48bdececab025.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mCirclePath, mDstPath;</div><div class="line">    private PathMeasure mPathMeasure;</div><div class="line">    private float mCurAnimValue;</div><div class="line">    private Bitmap mPlaneBmp;</div><div class="line">    private Matrix mMatrix;</div><div class="line">    private ValueAnimator mValueAnimator;</div><div class="line">    private float[] pos = new float[2];</div><div class="line">    private float[] tan = new float[2];</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPlaneBmp = BitmapFactory.decodeResource(getResources(), R.drawable.plane);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.BLACK);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(4);</div><div class="line"></div><div class="line">        mDstPath = new Path();</div><div class="line">        mCirclePath = new Path();</div><div class="line">        mPathMeasure = new PathMeasure();</div><div class="line">        mMatrix = new Matrix();</div><div class="line"></div><div class="line">        mValueAnimator = ValueAnimator.ofFloat(0, 1);</div><div class="line">        mValueAnimator.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">        mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">                mCurAnimValue = (Float) animation.getAnimatedValue();</div><div class="line">                invalidate();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        mValueAnimator.setDuration(2000);</div><div class="line">        mValueAnimator.setInterpolator(new AccelerateDecelerateInterpolator());</div><div class="line">        mValueAnimator.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">        int width = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        int height = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">        int radius;</div><div class="line">        if (width &gt;= height) &#123;</div><div class="line">            radius = height / 2 - height / 8;</div><div class="line">        &#125; else &#123;</div><div class="line">            radius = width / 2 - width / 8;</div><div class="line">        &#125;</div><div class="line">        // 先画圆的 path，但是这个圆只是用来计算</div><div class="line">        mCirclePath.addCircle(width / 2f, height / 2f, radius, Path.Direction.CW);</div><div class="line">        //计算圆的path的长度</div><div class="line">        mPathMeasure.setPath(mCirclePath, false);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        // 绘制路径加载动画</div><div class="line">        float length = mPathMeasure.getLength();</div><div class="line">        float stop = length * mCurAnimValue;</div><div class="line">        float start = (float) (stop - ((0.5 - Math.abs(mCurAnimValue - 0.5)) * length));</div><div class="line"></div><div class="line">        mDstPath.reset();</div><div class="line">        mPathMeasure.getSegment(start, stop, mDstPath, true);</div><div class="line">        canvas.drawPath(mDstPath, mPaint);</div><div class="line"></div><div class="line">        // 旋转飞机图片并绘制</div><div class="line">        // 使用 getMatrix</div><div class="line">        // mPathMeasure.getMatrix(stop, mMatrix, PathMeasure.POSITION_MATRIX_FLAG|PathMeasure.TANGENT_MATRIX_FLAG);</div><div class="line">        // mMatrix.preTranslate(-mPlaneBmp.getWidth() / 2f,-mPlaneBmp.getHeight() / 2f);</div><div class="line"></div><div class="line">        // 使用 getPosTan</div><div class="line">        mPathMeasure.getPosTan(stop, pos, tan);</div><div class="line">        float degrees = (float) (Math.atan2(tan[1], tan[0]) * 180.0 / Math.PI);</div><div class="line">        float px = mPlaneBmp.getWidth() / 2f;</div><div class="line">        float py = mPlaneBmp.getHeight() / 2f;</div><div class="line">        mMatrix.reset();</div><div class="line">        mMatrix.postRotate(degrees, mPlaneBmp.getWidth() / 2f, mPlaneBmp.getHeight() / 2f);</div><div class="line">        mMatrix.postTranslate(pos[0] - px, pos[1] - py);</div><div class="line">        canvas.drawBitmap(mPlaneBmp, mMatrix, mPaint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDetachedFromWindow() &#123;</div><div class="line">        super.onDetachedFromWindow();</div><div class="line">        mValueAnimator.cancel();</div><div class="line">        mValueAnimator = null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><div id="jump5"></div></p><h3 id="5-1-5-getMatrix-函数"><a href="#5-1-5-getMatrix-函数" class="headerlink" title="5.1.5 getMatrix() 函数"></a>5.1.5 getMatrix() 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean getMatrix(float distance, Matrix matrix, int flags)</div></pre></td></tr></table></figure><p>用于得到路径上某一长度的位置以及该位置的正切值的矩阵。</p><ul><li>distance：距离 Path 起始点的长度。</li><li>matrix：根据flags 封装好的 matrix 会根据 flags 的设置而存入不同的内容。</li><li>flags：用于指定哪些内容会存入 matrix 中。flags 值有两个：PathMeasure.POSITION_MATRIX_FLAG 表示获取位置信息；PathMeasure.TANGENT_MATRIX_FLAG 表示获取切边信息，使得图片按 Path 旋转。可以只指定一个，也可以用“|”同时指定。</li></ul><p>很明显，getMatrix() 函数只是 PathMeasure.getPosTan() 函数的另一种实现而已。如下更改飞机加载动画：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line">    // 绘制路径加载动画</div><div class="line">    float length = mPathMeasure.getLength();</div><div class="line">    float stop = length * mCurAnimValue;</div><div class="line">    float start = (float) (stop - ((0.5 - Math.abs(mCurAnimValue - 0.5)) * length));</div><div class="line"></div><div class="line">    mDstPath.reset();</div><div class="line">    mPathMeasure.getSegment(start, stop, mDstPath, true);</div><div class="line">    canvas.drawPath(mDstPath, mPaint);</div><div class="line"></div><div class="line">    // 旋转飞机图片并绘制</div><div class="line">    // 使用 getMatrix</div><div class="line">    mMatrix.reset();</div><div class="line">    mPathMeasure.getMatrix(stop, mMatrix, PathMeasure.POSITION_MATRIX_FLAG|PathMeasure.TANGENT_MATRIX_FLAG);</div><div class="line">    mMatrix.preTranslate(-mPlaneBmp.getWidth() / 2f,-mPlaneBmp.getHeight() / 2f);</div><div class="line"></div><div class="line">    // 使用 getPosTan</div><div class="line">    // mPathMeasure.getPosTan(stop, pos, tan);</div><div class="line">    // float degrees = (float) (Math.atan2(tan[1], tan[0]) * 180.0 / Math.PI);</div><div class="line">    // float px = mPlaneBmp.getWidth() / 2f;</div><div class="line">    // float py = mPlaneBmp.getHeight() / 2f;</div><div class="line">    // mMatrix.postRotate(degrees, mPlaneBmp.getWidth() / 2f, mPlaneBmp.getHeight() / 2f);</div><div class="line">    // mMatrix.postTranslate(pos[0] - px, pos[1] - py);</div><div class="line">    canvas.drawBitmap(mPlaneBmp, mMatrix, mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><div id="jump6"></div></p><h3 id="5-1-6-示例：支付宝支付成功动画"><a href="#5-1-6-示例：支付宝支付成功动画" class="headerlink" title="5.1.6 示例：支付宝支付成功动画"></a>5.1.6 示例：支付宝支付成功动画</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a5fb69f068b0ad8b.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mCirclePath, mDstPath;</div><div class="line">    private PathMeasure mPathMeasure;</div><div class="line">    private float mCurAnimValue;</div><div class="line">    private ValueAnimator mValueAnimator;</div><div class="line">    private boolean mNext = false;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.BLACK);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(8);</div><div class="line"></div><div class="line">        mDstPath = new Path();</div><div class="line">        mCirclePath = new Path();</div><div class="line">        mPathMeasure = new PathMeasure();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">        mCirclePath.reset();</div><div class="line"></div><div class="line">        int width = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        int height = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">        int centerX = width / 2;</div><div class="line">        int centerY = height / 2;</div><div class="line">        int radius = Math.min(centerX, centerY) / 2;</div><div class="line"></div><div class="line">        mCirclePath.addCircle(centerX, centerY, radius, Path.Direction.CW);</div><div class="line">        mCirclePath.moveTo(centerX - radius/2f, centerY);                // 勾的起点</div><div class="line">        mCirclePath.lineTo(centerX,centerY + radius/2f);                 // 勾的拐点</div><div class="line">        mCirclePath.lineTo(centerX + radius/2f,centerY - radius/3f);  // 勾的终点</div><div class="line">        mPathMeasure.setPath(mCirclePath,false);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        if (mCurAnimValue &lt; 1) &#123;</div><div class="line">            float stop = mPathMeasure.getLength() * mCurAnimValue;</div><div class="line">            mPathMeasure.getSegment(0, stop, mDstPath, true);</div><div class="line">        &#125; else &#123;</div><div class="line">            if (!mNext) &#123;</div><div class="line">                mNext = true;</div><div class="line">                mPathMeasure.getSegment(0, mPathMeasure.getLength(), mDstPath, true);</div><div class="line">                mPathMeasure.nextContour();</div><div class="line">            &#125; else &#123;</div><div class="line">                float stop = mPathMeasure.getLength() * (mCurAnimValue - 1);</div><div class="line">                mPathMeasure.getSegment(0, stop, mDstPath, true);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        canvas.drawPath(mDstPath, mPaint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDetachedFromWindow() &#123;</div><div class="line">        super.onDetachedFromWindow();</div><div class="line">        if (mValueAnimator != null) &#123;</div><div class="line">            mValueAnimator.cancel();</div><div class="line">            mValueAnimator = null;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void startAnim() &#123;</div><div class="line">        mValueAnimator = ValueAnimator.ofFloat(0, 2);</div><div class="line">        mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">                mCurAnimValue = (Float) animation.getAnimatedValue();</div><div class="line">                invalidate();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        mValueAnimator.setDuration(2000);</div><div class="line">        mValueAnimator.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用自定义控件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        findViewById(R.id.start_btn).setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                TestView tv = findViewById(R.id.test_view);</div><div class="line">                tv.startAnim();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-dbecfb785ccf0416.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04.4 精通自定义 View 之属性动画进阶——NineOldAndroids</title>
      <link href="/2019/07/04/05%20CUSTOM%20VIEW/04.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94NineOldAndroids/"/>
      <url>/2019/07/04/05%20CUSTOM%20VIEW/04.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94NineOldAndroids/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-828fa76b56725e28.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p>Android 3.0 推出了全新的 Animation API，使用起来很方便，但是不能在 3.0 以下版本中使用。NineOldAndroids 是一个可以在任意 Android 版本上使用的 Animation API。</p><p>常用类有 ObjectAnimator、ValueAnimator、AnimatorSet、PropertyValuesHolder、Keyframe、ViewPropertyAnimator、ViewHelper.</p><p><div id="jump1"></div></p><h3 id="4-4-1-NineOldAndroids-中的-ViewPropertyAnimator"><a href="#4-4-1-NineOldAndroids-中的-ViewPropertyAnimator" class="headerlink" title="4.4.1 NineOldAndroids 中的 ViewPropertyAnimator"></a>4.4.1 NineOldAndroids 中的 ViewPropertyAnimator</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 官方 API（3.1 以上）</div><div class="line">mView.animate().setDuration(5000).rotationY(720).x(100).y(100).start();</div><div class="line"></div><div class="line">// NineOldAndroids</div><div class="line">ViewPropertyAnimator.animate(mView).setDuration(5000).rotationY(720).x(100).y(100).start();</div></pre></td></tr></table></figure><p>从对比中可以看出，唯一不同的是 animate() 函数，其他诸如链式操作、各属性对应的函数、添加监听器都与官方 API 完全相同。</p><p><div id="jump2"></div></p><h3 id="4-4-2-NineOldAndroids-中的-ViewHelper"><a href="#4-4-2-NineOldAndroids-中的-ViewHelper" class="headerlink" title="4.4.2 NineOldAndroids 中的 ViewHelper"></a>4.4.2 NineOldAndroids 中的 ViewHelper</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>ViewHelper 提供了一系列 set/get 函数去操作 View 的各种属性，比如透明度、偏移量、旋转角度等，大大方便了我们的使用，而且无须考虑低版本的兼容性问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public static float getAlpha(View view)</div><div class="line">public static void setAlpha(View view, float alpha)</div><div class="line"></div><div class="line">public static float getPivotX(View view)</div><div class="line">public static void setPivotX(View view, float pivotX)</div><div class="line"></div><div class="line">public static float getPivotY(View view)</div><div class="line">public static void setPivotY(View view, float pivotY)</div><div class="line"></div><div class="line">public static float getRotation(View view)</div><div class="line">public static void setRotation(View view, float rotation)</div><div class="line"></div><div class="line">public static float getRotationX(View view)</div><div class="line">public static void setRotationX(View view, float rotationX)</div><div class="line"></div><div class="line">public static float getRotationY(View view)</div><div class="line">public static void setRotationY(View view, float rotationY)</div><div class="line"></div><div class="line">public static float getScaleX(View view)</div><div class="line">public static void setScaleX(View view, float scaleX)</div><div class="line"></div><div class="line">public static float getScaleY(View view)</div><div class="line">public static void setScaleY(View view, float scaleY)</div><div class="line"></div><div class="line">public static float getScrollX(View view)</div><div class="line">public static void setScrollX(View view, float scrollX)</div><div class="line"></div><div class="line">public static float getScrollY(View view)</div><div class="line">public static void setScrollY(View view, float scrollY)</div><div class="line"></div><div class="line">public static float getTranslationX(View view)</div><div class="line">public static void setTranslationX(View view, float translationX)</div><div class="line"></div><div class="line">public static float getTranslationY(View view)</div><div class="line">public static void setTranslationY(View view, float translationY)</div><div class="line"></div><div class="line">public static float getX(View view)</div><div class="line">public static void setX(View view, float x)</div><div class="line"></div><div class="line">public static float getY(View view)</div><div class="line">public static void setY(View view, float y)</div></pre></td></tr></table></figure></p><h4 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">final TextView tv = (TextView) findViewById(R.id.tv);</div><div class="line"></div><div class="line">findViewById(R.id.btn).setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">    public void onClick(View v) &#123;</div><div class="line">        ValueAnimator animator = ValueAnimator.ofFloat(0, 200);</div><div class="line">        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            public void onAnimationUpdate(ValueAnimator valueAnimator) &#123;</div><div class="line">                Float cur = (Float) valueAnimator.getAnimatedValue();</div><div class="line">                ViewHelper.setTranslationX(tv, cur);</div><div class="line">                ViewHelper.setTranslationY(tv, cur);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14186083-85cebdd2a14568d7.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04.3 精通自定义 View 之属性动画进阶——为 ViewGroup 内的组件添加动画</title>
      <link href="/2019/07/04/05%20CUSTOM%20VIEW/04.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E4%B8%BA%20ViewGroup%20%E5%86%85%E7%9A%84%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB/"/>
      <url>/2019/07/04/05%20CUSTOM%20VIEW/04.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E4%B8%BA%20ViewGroup%20%E5%86%85%E7%9A%84%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-255f494c4e6aed25.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump0"></div></p><h3 id="4-3-0-概述"><a href="#4-3-0-概述" class="headerlink" title="4.3.0 概述"></a>4.3.0 概述</h3><p>为 ViewGroup 内的组件添加动画，Android 共提供了 4 种方法。<br><strong>1. layoutAnimation 标签与 LayoutAnimationController</strong><br>第一：定义一个 layoutAnimation 的 animation 文件，如：(anim/layout_animation.xml)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;layoutAnimation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:delay=&quot;1&quot;</div><div class="line">    android:animationOrder=&quot;normal&quot;</div><div class="line">    android:animation=&quot;@anim/slide_in_left&quot;/&gt;</div></pre></td></tr></table></figure></p><p>第二步：在 viewGroup 类型的控件中，添加 android:layoutAnimation=”@anim/layout_animation”，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;ListView</div><div class="line">    android:id=&quot;@+id/listview&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:layoutAnimation=&quot;@anim/layout_animation&quot; /&gt;</div></pre></td></tr></table></figure></p><p>其中 @anim/slide_in_left 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;1000&quot;&gt;</div><div class="line">    &lt;translate android:fromXDelta=&quot;-50%p&quot; android:toXDelta=&quot;0&quot;/&gt;</div><div class="line">    &lt;alpha android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot;/&gt;</div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure></p><blockquote><p>注意：android:layoutAnimation 只在 ViewGroup 创建的时候，才会对其中的 item 添加动画。在创建成功以后，再向其中添加 item 将不会再有动画。</p></blockquote><p><strong>2. gridLayoutAnimation 标签与 GridLayoutAnimationController</strong><br>gridLayoutAnimation 与 layoutAnimation 一样有缺陷：即在 GridView 初次创建的时候有入场动画，之后新添加的数据是不会有入场动画的。</p><p><a href="https://blog.csdn.net/harvic880925/article/details/50785786" target="_blank" rel="external">详情请点击前往：layoutAnimation &amp; gridLayoutAnimation</a></p><p><strong>3. animateLayoutChanges 属性</strong><br>在 API 11 之后，Android 为了支持 ViewGroup 类控件，在添加和移除其中控件时自动添加动画，为我们提供了一个非常简单的属性：android:animateLayoutChanges=[true/false]，所有派生自 ViewGroup 的控件都具有此属性，只要在 XML 中添加上这个属性，就能实现添加/删除其中控件时，带有默认动画了。</p><p><strong>4. LayoutTransition</strong><br>在 API 11 之后引入，可以实现在 ViewGroup 动态添加或删除其中的控件时指定动画。动画可以自定义。对比前三种方法，LayoutTransition 是最强大的。</p><p><div id="jump1"></div></p><h3 id="4-3-1-animateLayoutChanges-属性"><a href="#4-3-1-animateLayoutChanges-属性" class="headerlink" title="4.3.1 animateLayoutChanges 属性"></a>4.3.1 animateLayoutChanges 属性</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1009a7ad10f53cab.gif?imageMogr2/auto-orient/strip" alt=""></p><p>在相应的 GroupView 子类中添加 android:animateLayoutChanges=”true”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;&gt;</div><div class="line">        &lt;Button</div><div class="line">            android:id=&quot;@+id/add_btn&quot;</div><div class="line">            android:layout_width=&quot;wrap_content&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:text=&quot;添加控件&quot;/&gt;</div><div class="line">        &lt;Button</div><div class="line">            android:id=&quot;@+id/remove_btn&quot;</div><div class="line">            android:layout_width=&quot;wrap_content&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:text=&quot;移除控件&quot;/&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line">    &lt;LinearLayout</div><div class="line">        android:id=&quot;@+id/layoutTransitionGroup&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:animateLayoutChanges=&quot;true&quot;</div><div class="line">        android:orientation=&quot;vertical&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123;</div><div class="line">    private LinearLayout layoutTransitionGroup;</div><div class="line"></div><div class="line">    private int i = 0;</div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        layoutTransitionGroup = findViewById(R.id.layoutTransitionGroup);</div><div class="line">        findViewById(R.id.add_btn).setOnClickListener(this);</div><div class="line">        findViewById(R.id.remove_btn).setOnClickListener(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void addButtonView() &#123;</div><div class="line">        i++;</div><div class="line">        Button button = new Button(this);</div><div class="line">        button.setText(&quot;button&quot; + i);</div><div class="line">        LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(</div><div class="line">                ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);</div><div class="line">        button.setLayoutParams(params);</div><div class="line">        layoutTransitionGroup.addView(button, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void removeButtonView() &#123;</div><div class="line">        if (i &gt; 0) &#123;</div><div class="line">            layoutTransitionGroup.removeViewAt(0);</div><div class="line">        &#125;</div><div class="line">        i--;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onClick(View v) &#123;</div><div class="line">        if (v.getId() == R.id.add_btn) &#123;</div><div class="line">            addButtonView();</div><div class="line">        &#125;</div><div class="line">        if (v.getId() == R.id.remove_btn) &#123;</div><div class="line">            removeButtonView();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><div id="jump2"></div></p><h3 id="4-3-2-LayoutTransition"><a href="#4-3-2-LayoutTransition" class="headerlink" title="4.3.2 LayoutTransition"></a>4.3.2 LayoutTransition</h3><p>上面虽然在 ViewGroup 类控件 XML 中仅添加一行 android:animateLayoutChanges=[true] 即可实现内部控件添加删除时都加上动画效果。但却只能使用默认动画效果，而无法自定义动画。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-54c50a8ff19f0356.gif?imageMogr2/auto-orient/strip" alt=""></p><p>为了能让我们自定义动画，谷歌在 API 11 时，同时为我们引入了一个类 LayoutTransaction。要使用LayoutTransaction是非常容易的，只需要三步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 1. 创建实例</div><div class="line">LayoutTransaction transitioner = new LayoutTransition();</div><div class="line">// 2. 创建动画并设置</div><div class="line">ObjectAnimator animOut = ObjectAnimator.ofFloat(null, &quot;rotation&quot;, 0f, 90f, 0f);</div><div class="line">transitioner.setAnimator(LayoutTransition.DISAPPEARING, animOut);</div><div class="line">// 3. 将 LayoutTransaction 设置进 ViewGroup</div><div class="line">linearLayout.setLayoutTransition(mTransitioner);</div></pre></td></tr></table></figure></p><p>在第二步中，transitioner.setAnimator 设置动画的函数声明为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void setAnimator(int transitionType, Animator animator)</div></pre></td></tr></table></figure></p><ul><li><strong>int transitionType</strong>：表示当前应用动画的对象范围，取值有：<br>APPEARING：元素在容器中出现时所定义的动画。<br>DISAPPEARING：元素在容器中消失时所定义的动画。<br>CHANGE_APPEARING：由于容器中要显现一个新的元素，其它需要变化的元素所应用的动画。<br>CHANGE_DISAPPEARING：当容器中某个元素消失，其它需要变化的元素所应用的动画。</li><li><strong>Animator animator</strong>：表示当前所选范围的控件所使用的动画。</li></ul><h4 id="1-APPEARING-与-DISAPPEARING"><a href="#1-APPEARING-与-DISAPPEARING" class="headerlink" title="1. APPEARING 与 DISAPPEARING"></a>1. APPEARING 与 DISAPPEARING</h4><p>LayoutTransition.APPEARING 所对应的当一个控件出现时所对应的动画；LayoutTransition.DISAPPEARING 在一个控件被移除时所对应的动画。修改上一个示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">layoutTransitionGroup = findViewById(R.id.layoutTransitionGroup);</div><div class="line">findViewById(R.id.add_btn).setOnClickListener(this);</div><div class="line">findViewById(R.id.remove_btn).setOnClickListener(this);</div><div class="line"></div><div class="line">mTransitioner = new LayoutTransition();</div><div class="line">// 入场动画：view 在这个容器中出现时触发的动画</div><div class="line">ObjectAnimator animIn = ObjectAnimator.ofFloat(null, &quot;rotationY&quot;, 0f, 360f,0f);</div><div class="line">mTransitioner.setAnimator(LayoutTransition.APPEARING, animIn);</div><div class="line"></div><div class="line">// 出场动画：view 在这个容器中消失时触发的动画</div><div class="line">ObjectAnimator animOut = ObjectAnimator.ofFloat(null, &quot;rotation&quot;, 0f, 90f, 0f);</div><div class="line">mTransitioner.setAnimator(LayoutTransition.DISAPPEARING, animOut);</div><div class="line"></div><div class="line">layoutTransitionGroup.setLayoutTransition(mTransitioner);</div></pre></td></tr></table></figure></p><p>同时要删除 XML 中的 android:animateLayoutChanges=”true” 设置。</p><h4 id="2-CHANGE-APPEARING"><a href="#2-CHANGE-APPEARING" class="headerlink" title="2. CHANGE_APPEARING"></a>2. CHANGE_APPEARING</h4><p>在添加控件时，除了被添加控件本身的入场动画以外，其它需要移动位置的控件，在移动位置时，也被添加上了动画（left 点位移动画），这些除了被添加控件以外的其它需要移动位置的控件组合，所对应的动画就是 LayoutTransition.CHANGE_APPEARING。同样，在移除一个控件时，其它所有需要改变位置的控件组合所对应的动画就是 LayoutTransition.CHANGE_DISAPPEARING。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.act_main);</div><div class="line"> </div><div class="line">    layoutTransitionGroup = (LinearLayout) findViewById(R.id.layoutTransitionGroup);</div><div class="line">    findViewById(R.id.add_btn).setOnClickListener(this);</div><div class="line">    findViewById(R.id.remove_btn).setOnClickListener(this);</div><div class="line"> </div><div class="line">    mTransitioner = new LayoutTransition();</div><div class="line">    // 入场动画：view 在这个容器中出现时触发的动画</div><div class="line">    ObjectAnimator animIn = ObjectAnimator.ofFloat(null, &quot;rotationY&quot;, 0f, 360f,0f);</div><div class="line">    mTransitioner.setAnimator(LayoutTransition.APPEARING, animIn);</div><div class="line"> </div><div class="line">    // 出场动画：view 在这个容器中消失时触发的动画</div><div class="line">    ObjectAnimator animOut = ObjectAnimator.ofFloat(null, &quot;rotation&quot;, 0f, 90f, 0f);</div><div class="line">    mTransitioner.setAnimator(LayoutTransition.DISAPPEARING, animOut);</div><div class="line"> </div><div class="line">    PropertyValuesHolder pvhLeft = PropertyValuesHolder.ofInt(&quot;left&quot;,0,100,0);</div><div class="line">    PropertyValuesHolder pvhTop = PropertyValuesHolder.ofInt(&quot;top&quot;,1,1);</div><div class="line">    Animator changeAppearAnimator = ObjectAnimator.ofPropertyValuesHolder(</div><div class="line">        layoutTransitionGroup, pvhLeft,pvhBottom,pvhTop,pvhRight);</div><div class="line">    mTransitioner.setAnimator(LayoutTransition.CHANGE_APPEARING,changeAppearAnimator);</div><div class="line"> </div><div class="line">    layoutTransitionGroup.setLayoutTransition(mTransitioner);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注意：<br>1、LayoutTransition.CHANGE_APPEARING 和 LayoutTransition.CHANGE_DISAPPEARING 必须使用 PropertyValuesHolder 所构造的动画才会有效果，不然无效！也就是说使用 ObjectAnimator 构造的动画，在这里是不会有效果的！<br>2、在构造 PropertyValuesHolder 动画时，“left”、“top” 属性的变动是必写的。如果不需要变动，则直接写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PropertyValuesHolder pvhLeft = PropertyValuesHolder.ofInt(&quot;left&quot;,0,0);</div><div class="line">PropertyValuesHolder pvhTop = PropertyValuesHolder.ofInt(&quot;top&quot;,0,0);</div></pre></td></tr></table></figure></p><p>3、在构造 PropertyValuesHolder 时，所使用的 ofInt、ofFloat 中的参数值，第一个值和最后一个值必须相同，不然此属性所对应的的动画将被放弃，在此属性值上将不会有效果。<br>4、在构造 PropertyValuesHolder 时，所使用的 ofInt，ofFloat 中，如果所有参数值都相同，也将不会有动画效果。</p><h4 id="3-CHANGE-DISAPPEARING"><a href="#3-CHANGE-DISAPPEARING" class="headerlink" title="3. CHANGE_DISAPPEARING"></a>3. CHANGE_DISAPPEARING</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">PropertyValuesHolder outLeft = PropertyValuesHolder.ofInt(&quot;left&quot;,0,0);</div><div class="line">PropertyValuesHolder outTop = PropertyValuesHolder.ofInt(&quot;top&quot;,0,0);</div><div class="line"> </div><div class="line">Keyframe frame0 = Keyframe.ofFloat(0f, 0);</div><div class="line">Keyframe frame1 = Keyframe.ofFloat(0.1f, -20f);</div><div class="line">Keyframe frame2 = Keyframe.ofFloat(0.2f, 20f);</div><div class="line">Keyframe frame3 = Keyframe.ofFloat(0.3f, -20f);</div><div class="line">Keyframe frame4 = Keyframe.ofFloat(0.4f, 20f);</div><div class="line">Keyframe frame5 = Keyframe.ofFloat(0.5f, -20f);</div><div class="line">Keyframe frame6 = Keyframe.ofFloat(0.6f, 20f);</div><div class="line">Keyframe frame7 = Keyframe.ofFloat(0.7f, -20f);</div><div class="line">Keyframe frame8 = Keyframe.ofFloat(0.8f, 20f);</div><div class="line">Keyframe frame9 = Keyframe.ofFloat(0.9f, -20f);</div><div class="line">Keyframe frame10 = Keyframe.ofFloat(1, 0);</div><div class="line">PropertyValuesHolder mPropertyValuesHolder = PropertyValuesHolder.ofKeyframe(</div><div class="line">        &quot;rotation&quot;,frame0,frame1,frame2,frame3,frame4,</div><div class="line">        frame5,frame6,frame7,frame8,frame9,frame10);</div><div class="line"> </div><div class="line">ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(</div><div class="line">        this, outLeft, outTop, mPropertyValuesHolder);</div><div class="line">mTransitioner.setAnimator(LayoutTransition.CHANGE_DISAPPEARING, animator);</div></pre></td></tr></table></figure><p>第一步：由于 left、top 属性是必须的，但我们做响铃效果时，是不需要 left，top 变动的，所有给他们设置为无效值。<br>第二步：用 KeyFrame 构造 PropertyValuesHolder。<br>第三步：设置 LayoutTransition.CHANGE_DISAPPEARING 动画。</p><p><div id="jump3"></div></p><h3 id="4-3-3-其他函数"><a href="#4-3-3-其他函数" class="headerlink" title="4.3.3 其他函数"></a>4.3.3 其他函数</h3><h4 id="1-基本设置"><a href="#1-基本设置" class="headerlink" title="1. 基本设置"></a>1. 基本设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 设置所有动画完成所需要的时长</div><div class="line"> */</div><div class="line">public void setDuration(long duration)</div><div class="line">/**</div><div class="line"> * 针对单个type，设置动画时长；</div><div class="line"> * transitionType取值为：APPEARING、DISAPPEARING、CHANGE_APPEARING、CHANGE_DISAPPEARING</div><div class="line"> */</div><div class="line">public void setDuration(int transitionType, long duration) </div><div class="line">/**</div><div class="line"> * 针对单个type设置插值器</div><div class="line"> * transitionType取值为：APPEARING、DISAPPEARING、CHANGE_APPEARING、CHANGE_DISAPPEARING</div><div class="line"> */</div><div class="line">public void setInterpolator(int transitionType, TimeInterpolator interpolator)</div><div class="line">/**</div><div class="line"> * 针对单个type设置动画延时</div><div class="line"> * transitionType取值为：APPEARING、DISAPPEARING、CHANGE_APPEARING、CHANGE_DISAPPEARING</div><div class="line"> */</div><div class="line">public void setStartDelay(int transitionType, long delay)</div><div class="line">/**</div><div class="line"> * 针对单个type设置，每个子item动画的时间间隔</div><div class="line"> */</div><div class="line">public void setStagger(int transitionType, long duration)</div></pre></td></tr></table></figure><h4 id="2-LayoutTransition-设置监听"><a href="#2-LayoutTransition-设置监听" class="headerlink" title="2. LayoutTransition 设置监听"></a>2. LayoutTransition 设置监听</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void addTransitionListener(TransitionListener listener)</div><div class="line">public interface TransitionListener &#123;</div><div class="line">    public void startTransition(LayoutTransition transition, ViewGroup container,View view, int transitionType);</div><div class="line">    public void endTransition(LayoutTransition transition, ViewGroup container,View view, int transitionType);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 TransitionListener 中总共有四个参数：</p><ul><li>LayoutTransition transition：当前的 LayoutTransition 实例。</li><li>ViewGroup container：当前应用 LayoutTransition 的 container。</li><li>View view：当前在做动画的 View 对象。</li><li>int transitionType：当前的 LayoutTransition 类型，取值有：APPEARING、DISAPPEARING、CHANGE_APPEARING、CHANGE_DISAPPEARING。</li></ul><p>在添加控件时，先是 start 回调，再是 end 回调；APPEARING 事件所对应的 View 是控件，而 CHANGE_APPEARING 所对应的控件是容器。删除控件时，原理相同。</p><p>这是因为，在添加控件时，APPEARING 事件只针对当前被添加的控件做动画，所以返回的 View 是当前被添加的控件。而 CHANGE_APPEARING 是对容器中所有已存在的控件做动画，所以返回的 View 是容器。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-9b5c240585b26f18.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04.2 精通自定义 View 之属性动画进阶——ViewPropertyAnimator</title>
      <link href="/2019/07/04/05%20CUSTOM%20VIEW/04.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94ViewPropertyAnimator/"/>
      <url>/2019/07/04/05%20CUSTOM%20VIEW/04.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94ViewPropertyAnimator/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4497aaa0309357ae.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="4-2-1-概述"><a href="#4-2-1-概述" class="headerlink" title="4.2.1 概述"></a>4.2.1 概述</h3><p>使用 ObjectAnimator：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(mView, &quot;alpha&quot;, 0f);</div><div class="line">animator.start();</div></pre></td></tr></table></figure></p><p>使用 ViewPropertyAnimator：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mView.animate().alpha(0f);</div></pre></td></tr></table></figure></p><p>除此之外，还可以非常容易地将多个动画结合起来。比如：将控件移动到点 (50, 100) 且完全透明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mView.animate().x(50).y(100).alpha(0f);</div></pre></td></tr></table></figure></p><p>此类事专门针对 View 对象动画而操作的类：链式调用，自动 start， 简化流程，提高效率： </p><ul><li>提供了更简洁的链式调用设置多个属性动画，这些动画可以同时进行的。</li><li>拥有更好的性能，多个属性动画是一次同时变化，只执行一次 UI 刷新（也就是只调用一次 invalidate，而 n 个 ObjectAnimator 就会进行 n 次属性变化，就有 n 次 invalidate）。</li><li>每个属性提供两种类型方法设置。如：scaleX()、scaleXBy()。</li><li>该类只能通过 View 的 animate() 获取其实例对象的引用。</li></ul><p><div id="jump2"></div></p><h3 id="4-2-2-常用函数"><a href="#4-2-2-常用函数" class="headerlink" title="4.2.2 常用函数"></a>4.2.2 常用函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">view.animate()                  // 获取ViewPropertyAnimator对象</div><div class="line">        // 位移</div><div class="line">        .translationX(100)</div><div class="line">        .translationXBy(100)</div><div class="line">        .translationY(100)</div><div class="line">        .translationYBy(100)</div><div class="line">        .translationZ(100)      // Z 轴移动，API 21 添加</div><div class="line">        .translationZBy(100)    // API 21 添加</div><div class="line">        // 改变坐标</div><div class="line">        .x(100)</div><div class="line">        .xBy(100)</div><div class="line">        .y(100)</div><div class="line">        .yBy(100)</div><div class="line">        // 改变透明度</div><div class="line">        .alpha(0.1f)</div><div class="line">        .alphaBy(0.1f)</div><div class="line">        // 改变透明度</div><div class="line">        .scaleX(0.1f)</div><div class="line">        .scaleXBy(0.1f)</div><div class="line">        .scaleY(0.1f)</div><div class="line">        .scaleYBy(0.1f)</div><div class="line">        // 旋转</div><div class="line">        .rotation(180)</div><div class="line">        .rotationX(180)</div><div class="line">        .rotationBy(180)</div><div class="line">        .rotationY(180)</div><div class="line">        .rotationYBy(180)</div><div class="line">        // 持续时间</div><div class="line">        .setDuration(1000)</div><div class="line">        // 动画开始时执行 runnable，API 16 添加</div><div class="line">        .withStartAction(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        // 动画结束时执行 runnable，API 16 添加</div><div class="line">        .withEndAction(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .withLayer()            // 硬件加速,API 16添加</div><div class="line">        .setStartDelay(1000)    // 执行延迟</div><div class="line">        // 设置插值器</div><div class="line">        .setInterpolator(new LinearInterpolator())</div><div class="line">        // 设置更新监听</div><div class="line">        .setUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;&#125;</div><div class="line">        &#125;)</div><div class="line">        // 动画监听</div><div class="line">        .setListener(new Animator.AnimatorListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationStart(Animator animation) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationEnd(Animator animation) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationCancel(Animator animation) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationRepeat(Animator animation) &#123;&#125;</div><div class="line">        &#125;)</div><div class="line">        .start();</div></pre></td></tr></table></figure><p>举例说明一下 xxxX() 和 xxxXBy() 函数之间的区别。如 scaleY(2f) 和 scaleYBy(2f)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private TextView tv1, tv2;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        Button startBtn = findViewById(R.id.start_btn);</div><div class="line">        tv1 = findViewById(R.id.tv1);</div><div class="line">        tv2 = findViewById(R.id.tv2);</div><div class="line"></div><div class="line">        startBtn.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                tv1.animate().scaleX(2f);</div><div class="line">                tv2.animate().scaleXBy(2f);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>原图：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4c85d0f46e0e3cea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>第一次点击开始动画按钮，效果图如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f744e1aa04b08df1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>第二次点击开始动画按钮，效果图如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-aa7a1ac92a785e49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-85a1d2e0d70f5332.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04.1 精通自定义 View 之属性动画进阶——PropertyValuesHolder 与 Keyframe</title>
      <link href="/2019/07/04/05%20CUSTOM%20VIEW/04.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94PropertyValuesHolder%20%E4%B8%8E%20Keyframe/"/>
      <url>/2019/07/04/05%20CUSTOM%20VIEW/04.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94PropertyValuesHolder%20%E4%B8%8E%20Keyframe/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-715dc7fbddf15429.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p>ValueAnimator、ObjectAnimator 除了 ofInt()、ofFloat()、ofObject() 函数创建 Animator 实例的方法以外，都还有一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// valueAnimator 的</div><div class="line">public static ValueAnimator ofPropertyValuesHolder (</div><div class="line">    PropertyValuesHolder... values) </div><div class="line">// ObjectAnimator的</div><div class="line">public static ObjectAnimator ofPropertyValuesHolder (</div><div class="line">    Object target,PropertyValuesHolder... values)</div></pre></td></tr></table></figure></p><p><div id="jump1"></div></p><h3 id="4-1-1-PropertyValuesHolder"><a href="#4-1-1-PropertyValuesHolder" class="headerlink" title="4.1.1 PropertyValuesHolder"></a>4.1.1 PropertyValuesHolder</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>PropertyValuesHolder 这个类的意义就是，它其中保存了动画过程中所需要操作的属性和对应的值。我们通过 ofFloat(Object target, String propertyName, float… values) 构造的动画，ofFloat() 的内部实现其实就是将传进来的参数封装成 PropertyValuesHolder 实例来保存动画状态。在封装成 PropertyValuesHolder 实例以后，后期的各种操作也是以 PropertyValuesHolder 为主的。</p><p>PropertyValuesHolder 中有很多函数，有些函数的 api 等级是11，有些函数的 api 等级是 14 和 21，具体参考文档<a href="http://developer.android.com/reference/android/animation/PropertyValuesHolder.html" target="_blank" rel="external">《Google：PropertyValuesHolder》</a></p><p>首先，我们来看看创建实例的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static PropertyValuesHolder ofFloat(String propertyName, float... values)</div><div class="line">public static PropertyValuesHolder ofInt(String propertyName, int... values) </div><div class="line">public static PropertyValuesHolder ofObject(String propertyName, TypeEvaluator evaluator, Object... values)</div><div class="line">public static PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values)</div></pre></td></tr></table></figure></p><h4 id="2-PropertyValuesHolder-之-ofFloat-、ofInt"><a href="#2-PropertyValuesHolder-之-ofFloat-、ofInt" class="headerlink" title="2. PropertyValuesHolder 之 ofFloat()、ofInt()"></a>2. PropertyValuesHolder 之 ofFloat()、ofInt()</h4><p>1）ofFloat()、ofInt()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static PropertyValuesHolder ofFloat(String propertyName, float... values)</div><div class="line">public static PropertyValuesHolder ofInt(String propertyName, int... values)</div></pre></td></tr></table></figure></p><ul><li><strong>propertyName</strong>：表示 ObjectAnimator 需要操作的属性名。即 ObjectAnimator 需要通过反射查找对应属性的 setProperty() 函数的那个 property。</li><li><strong>values</strong>：属性所对应的参数，同样是可变长参数，可以指定多个，还记得我们在 ObjectAnimator 中讲过，如果只指定了一个，那么 ObjectAnimator 会通过查找 getProperty() 方法来获得初始值。</li></ul><p>2）ObjectAnimator.ofPropertyValuesHolder()<br>ObjectAnimator 提供了一个方法，构造 PropertyValuesHolder 来构造动画。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ObjectAnimator ofPropertyValuesHolder(Object target, </div><div class="line">        PropertyValuesHolder... values)</div></pre></td></tr></table></figure></p><ul><li><strong>target</strong>：指需要执行动画的控件。</li><li><strong>values</strong>：是一个可变长参数，可以传进去多个PropertyValuesHolder 实例，由于每个 PropertyValuesHolder 实例都会针对一个属性做动画，所以如果传进去多个 PropertyValuesHolder 实例，将会对控件的多个属性同时做动画操作。 </li></ul><p>3）示例</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f17b350f2aa6422b.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private TextView mTv;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        Button startBtn = findViewById(R.id.start_btn);</div><div class="line">        mTv = findViewById(R.id.tv);</div><div class="line"></div><div class="line">        startBtn.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                startAnim();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void startAnim() &#123;</div><div class="line">        PropertyValuesHolder rotationHolder = PropertyValuesHolder.ofFloat(&quot;rotation&quot;,</div><div class="line">                60f, -60f, 40f, -40f, 20f, -20f, 10f, -10f, 0f);</div><div class="line">        PropertyValuesHolder alphaHolder = PropertyValuesHolder.ofFloat(&quot;alpha&quot;,</div><div class="line">                0.1f, 1f, 0.1f, 1f);</div><div class="line">        ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(mTv, rotationHolder, alphaHolder);</div><div class="line">        animator.setDuration(3000);</div><div class="line">        animator.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3-PropertyValuesHolder-之-ofObject"><a href="#3-PropertyValuesHolder-之-ofObject" class="headerlink" title="3. PropertyValuesHolder 之 ofObject()"></a>3. PropertyValuesHolder 之 ofObject()</h4><p>1）概述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static PropertyValuesHolder ofObject(String propertyName, </div><div class="line">        TypeEvaluator evaluator, Object... values)</div></pre></td></tr></table></figure></p><ul><li><strong>propertyName</strong>：ObjectAnimator 动画操作的属性名。</li><li><strong>evaluator</strong>：Evaluator 实例，Evaluator 是将当前动画进度计算出当前值的类，可以使用系统自带的 IntEvaluator、FloatEvaluator 也可以自定义。</li><li><strong>values</strong>：可变长参数，表示操作动画属性的值。</li></ul><p>2）示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-db0243fadce74f39.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private TextView mTv;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        Button startBtn = findViewById(R.id.start_btn);</div><div class="line">        mTv = findViewById(R.id.tv);</div><div class="line"></div><div class="line">        startBtn.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                startAnim();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void startAnim() &#123;</div><div class="line">        PropertyValuesHolder charHolder = PropertyValuesHolder.ofObject(&quot;CharText&quot;,</div><div class="line">                new CharEvaluator(), Character.valueOf(&apos;A&apos;), Character.valueOf(&apos;Z&apos;));</div><div class="line">        ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(mTv, charHolder);</div><div class="line">        animator.setDuration(3000);</div><div class="line">        animator.setInterpolator(new AccelerateInterpolator());</div><div class="line">        animator.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>自定义 View 和 Evaluator<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class MyTextView extends AppCompatTextView &#123;</div><div class="line">    private Character charText;</div><div class="line"></div><div class="line">    public MyTextView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setCharText(Character charText) &#123;</div><div class="line">        setText(String.valueOf(charText));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class CharEvaluator implements TypeEvaluator&lt;Character&gt; &#123;</div><div class="line">    @Override</div><div class="line">    public Character evaluate(float fraction, Character startValue, Character endValue) &#123;</div><div class="line">        int startInt = (int) startValue;</div><div class="line">        int endInt = (int) endValue;</div><div class="line">        int result = (int) (startInt + fraction * (endInt - startInt));</div><div class="line">        return (char) result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><div id="jump2"></div></p><h3 id="4-1-2-Keyframe"><a href="#4-1-2-Keyframe" class="headerlink" title="4.1.2 Keyframe"></a>4.1.2 Keyframe</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>如果要控制动画速率的变化，可以通过自定义插值器，也可以通过自定义 Evaluator 来实现。但需要足够的数学知识。 为了解决方便的控制动画速率的问题，谷歌为了我们定义了一个 KeyFrame 的类，KeyFrame 直译过来就是关键帧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static Keyframe ofFloat(float fraction, float value)</div></pre></td></tr></table></figure></p><ul><li><strong>fraction</strong>：表示当前的显示进度，即从加速器中 getInterpolation() 函数的返回值。</li><li><strong>value</strong>：表示当前应该在的位置。</li></ul><p>比如 Keyframe.ofFloat(0, 0) 表示动画进度为 0 时，动画所在的数值位置为 0；Keyframe.ofFloat(0.25f, -20f) 表示动画进度为 25% 时，动画所在的数值位置为 -20；Keyframe.ofFloat(1f, 0) 表示动画结束时，动画所在的数值位置为 0。</p><p>PropertyValuesHolder 是这样使用 KeyFrame 对象的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values)</div></pre></td></tr></table></figure></p><ul><li><strong>propertyName</strong>：动画所要操作的属性名。</li><li><strong>values</strong>：Keyframe 的列表，PropertyValuesHolder 会根据每个 Keyframe 的设定，定时将指定的值输出给动画。</li></ul><p>所以完整的 KeyFrame 的使用代码应该是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Keyframe frame0 = Keyframe.ofFloat(0f, 0);</div><div class="line">Keyframe frame1 = Keyframe.ofFloat(0.1f, -20f);</div><div class="line">Keyframe frame2 = Keyframe.ofFloat(1, 0);</div><div class="line">PropertyValuesHolder frameHolder = PropertyValuesHolder.ofKeyframe(</div><div class="line">        &quot;rotation&quot;,frame0,frame1,frame2);</div><div class="line">Animator animator = ObjectAnimator.ofPropertyValuesHolder(mImage,frameHolder);</div><div class="line">animator.setDuration(1000);</div><div class="line">animator.start();</div></pre></td></tr></table></figure></p><h4 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-29d2aa9f6df19102.gif?imageMogr2/auto-orient/strip" alt=""></p><p>1）布局文件 act_main.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;</div><div class="line">    android:padding=&quot;20dp&quot;&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/start_btn&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;start animation&quot;/&gt;</div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/tel_img&quot;</div><div class="line">        android:layout_width=&quot;70dp&quot;</div><div class="line">        android:layout_height=&quot;70dp&quot;</div><div class="line">        android:layout_margin=&quot;30dp&quot;</div><div class="line">        android:src=&quot;@drawable/icon_tel&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>2）MainActivity.java 核心代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Keyframe frame0 = Keyframe.ofFloat(0f, 0);</div><div class="line">Keyframe frame1 = Keyframe.ofFloat(0.1f, -20f);</div><div class="line">Keyframe frame2 = Keyframe.ofFloat(0.2f, 20f);</div><div class="line">Keyframe frame3 = Keyframe.ofFloat(0.3f, -20f);</div><div class="line">Keyframe frame4 = Keyframe.ofFloat(0.4f, 20f);</div><div class="line">Keyframe frame5 = Keyframe.ofFloat(0.5f, -20f);</div><div class="line">Keyframe frame6 = Keyframe.ofFloat(0.6f, 20f);</div><div class="line">Keyframe frame7 = Keyframe.ofFloat(0.7f, -20f);</div><div class="line">Keyframe frame8 = Keyframe.ofFloat(0.8f, 20f);</div><div class="line">Keyframe frame9 = Keyframe.ofFloat(0.9f, -20f);</div><div class="line">Keyframe frame10 = Keyframe.ofFloat(1f, 0);</div><div class="line">PropertyValuesHolder frameHolder = PropertyValuesHolder.ofKeyframe(&quot;rotation&quot;,</div><div class="line">        frame0, frame1, frame2, frame3, frame4, frame5,</div><div class="line">        frame6, frame7, frame8, frame9, frame10);</div><div class="line">Animator animator = ObjectAnimator.ofPropertyValuesHolder(mView, frameHolder);</div><div class="line">animator.setDuration(2000);</div><div class="line">animator.start();</div></pre></td></tr></table></figure></p><h4 id="3-ofInt-和-ofFloat"><a href="#3-ofInt-和-ofFloat" class="headerlink" title="3. ofInt 和 ofFloat"></a>3. ofInt 和 ofFloat</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// ofFloat</div><div class="line">public static Keyframe ofFloat(float fraction) </div><div class="line">public static Keyframe ofFloat(float fraction, float value)</div><div class="line">// ofInt</div><div class="line">public static Keyframe ofInt(float fraction)</div><div class="line">public static Keyframe ofInt(float fraction, int value)</div></pre></td></tr></table></figure><p>fraction 表示当前关键帧所在的动画进度位置，value 表示当前位置所对应的值。</p><p>Keyframe 还有一些常用函数来设置 fraction，value 和 interpolator，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 设置fraction参数，即Keyframe所对应的进度</div><div class="line">public void setFraction(float fraction) </div><div class="line">// 设置当前Keyframe所对应的值</div><div class="line">public void setValue(Object value)</div><div class="line">// 设置Keyframe动作期间所对应的插值器</div><div class="line">public void setInterpolator(TimeInterpolator interpolator)</div></pre></td></tr></table></figure></p><p>如果使用 ofFloat(float fraction) 来构造，也必须使用 setValue(Object value) 来设置这个关键帧所对应的值。</p><h4 id="4-插值器"><a href="#4-插值器" class="headerlink" title="4. 插值器"></a>4. 插值器</h4><p>如果给某个 Keyframe 设置上插值器，那么这个插值器就是从上一个 Keyframe 开始到当前设置插值器的 Keyframe 时，这个过程值的计算是利用这个插值器的，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Keyframe frame0 = Keyframe.ofFloat(0f, 0);</div><div class="line">Keyframe frame1 = Keyframe.ofFloat(0.1f, -20f);</div><div class="line">frame1.setInterpolator(new BounceInterpolator());</div><div class="line">Keyframe frame2 = Keyframe.ofFloat(1f, 20f);</div><div class="line">frame2.setInterpolator(new LinearInterpolator());</div></pre></td></tr></table></figure></p><p>在上面的代码中，我们给 frame1 设置了插值器 BounceInterpolator，那么在 frame0 到 frame1 的中间值计算过程中，就是用的就是回弹插值器；同样，我们给 frame2 设置了线性插值器 LinearInterpolator，所以在 frame1 到 frame2 的中间值计算过程中，使用的就是线性插值器。很显然，给 Keyframe.ofFloat(0f, 0) 设置插值器是无效的，因为它是第一帧。</p><h4 id="5-Keyframe-之-ofObject"><a href="#5-Keyframe-之-ofObject" class="headerlink" title="5. Keyframe 之 ofObject"></a>5. Keyframe 之 ofObject</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f02d1264fbae982f.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static Keyframe ofObject(float fraction)</div><div class="line">public static Keyframe ofObject(float fraction, Object value)</div></pre></td></tr></table></figure><p>同样，如果使用 ofObject(float fraction) 来构造，也必须使用 setValue(Object value) 来设置这个关键帧所对应的值。</p><p>还以 TextView 更改字母的例子来使用下 Keyframe.ofObject：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Keyframe frame0 = Keyframe.ofObject(0f, Character.valueOf(&apos;A&apos;));</div><div class="line">Keyframe frame1 = Keyframe.ofObject(0.1f, Character.valueOf(&apos;L&apos;));</div><div class="line">Keyframe frame2 = Keyframe.ofObject(1f, Character.valueOf(&apos;Z&apos;));</div><div class="line">PropertyValuesHolder frameHolder = PropertyValuesHolder.ofKeyframe(&quot;CharText&quot;,</div><div class="line">        frame0, frame1, frame2);</div><div class="line">frameHolder.setEvaluator(new CharEvaluator());</div><div class="line">Animator animator = ObjectAnimator.ofPropertyValuesHolder(mView, frameHolder);</div><div class="line">animator.setDuration(2000);</div><div class="line">animator.start();</div></pre></td></tr></table></figure></p><h4 id="6-疑问：如果没有设置进度为0或者进度为1时的关键帧，展示是怎样的？"><a href="#6-疑问：如果没有设置进度为0或者进度为1时的关键帧，展示是怎样的？" class="headerlink" title="6. 疑问：如果没有设置进度为0或者进度为1时的关键帧，展示是怎样的？"></a>6. 疑问：如果没有设置进度为0或者进度为1时的关键帧，展示是怎样的？</h4><ul><li>如果去掉第 0 帧，将以第一个关键帧为起始位置。</li><li>如果去掉结束帧，将以最后一个关键帧为结束位置。</li><li>使用 Keyframe 来构建动画，至少要有两个或两个以上帧，否则崩溃。</li></ul><p><div id="jump3"></div></p><h3 id="4-1-3-PropertyValuesHolder-其他函数"><a href="#4-1-3-PropertyValuesHolder-其他函数" class="headerlink" title="4.1.3 PropertyValuesHolder 其他函数"></a>4.1.3 PropertyValuesHolder 其他函数</h3><p>PropertyValuesHolder 除了上面的讲到的 ofInt、ofFloat、ofObject、ofKeyframe 以外，API 11 的还有几个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 设置动画的Evaluator</div><div class="line">public void setEvaluator(TypeEvaluator evaluator)</div><div class="line">// 用于设置ofFloat所对应的动画值列表</div><div class="line">public void setFloatValues(float... values)</div><div class="line">// 用于设置ofInt所对应的动画值列表</div><div class="line">public void setIntValues(int... values)</div><div class="line">// 用于设置ofKeyframe所对应的动画值列表</div><div class="line">public void setKeyframes(Keyframe... values)</div><div class="line">// 用于设置ofObject所对应的动画值列表</div><div class="line">public void setObjectValues(Object... values)</div><div class="line">// 设置动画属性名</div><div class="line">public void setPropertyName(String propertyName)</div></pre></td></tr></table></figure></p><p><div id="jump4"></div></p><h3 id="4-1-4-示例：电话响铃效果"><a href="#4-1-4-示例：电话响铃效果" class="headerlink" title="4.1.4 示例：电话响铃效果"></a>4.1.4 示例：电话响铃效果</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-81f9947638db226f.gif?imageMogr2/auto-orient/strip" alt=""></p><p>核心代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">// 左右晃动</div><div class="line">Keyframe frame0 = Keyframe.ofFloat(0f, 0);</div><div class="line">Keyframe frame1 = Keyframe.ofFloat(0.1f, -20f);</div><div class="line">Keyframe frame2 = Keyframe.ofFloat(0.2f, 20f);</div><div class="line">Keyframe frame3 = Keyframe.ofFloat(0.3f, -20f);</div><div class="line">Keyframe frame4 = Keyframe.ofFloat(0.4f, 20f);</div><div class="line">Keyframe frame5 = Keyframe.ofFloat(0.5f, -20f);</div><div class="line">Keyframe frame6 = Keyframe.ofFloat(0.6f, 20f);</div><div class="line">Keyframe frame7 = Keyframe.ofFloat(0.7f, -20f);</div><div class="line">Keyframe frame8 = Keyframe.ofFloat(0.8f, 20f);</div><div class="line">Keyframe frame9 = Keyframe.ofFloat(0.9f, -20f);</div><div class="line">Keyframe frame10 = Keyframe.ofFloat(1f, 0);</div><div class="line">PropertyValuesHolder frameHolder = PropertyValuesHolder.ofKeyframe(&quot;rotation&quot;,</div><div class="line">        frame0, frame1, frame2, frame3, frame4, frame5,</div><div class="line">        frame6, frame7, frame8, frame9, frame10);</div><div class="line">// X 轴缩放</div><div class="line">Keyframe scaleXFrame0 = Keyframe.ofFloat(0f, 1);</div><div class="line">Keyframe scaleXFrame1 = Keyframe.ofFloat(0.1f, 1.2f);</div><div class="line">Keyframe scaleXFrame9 = Keyframe.ofFloat(0.9f, 1.2f);</div><div class="line">Keyframe scaleXFrame10 = Keyframe.ofFloat(1f, 1);</div><div class="line">PropertyValuesHolder scaleXholder = PropertyValuesHolder.ofKeyframe(&quot;scaleX&quot;,</div><div class="line">        scaleXFrame0, scaleXFrame1, scaleXFrame9, scaleXFrame10);</div><div class="line">// Y 轴缩放</div><div class="line">Keyframe scaleYFrame0 = Keyframe.ofFloat(0f, 1);</div><div class="line">Keyframe scaleYFrame1 = Keyframe.ofFloat(0.1f, 1.2f);</div><div class="line">Keyframe scaleYFrame9 = Keyframe.ofFloat(0.9f, 1.2f);</div><div class="line">Keyframe scaleYFrame10 = Keyframe.ofFloat(1f, 1);</div><div class="line">PropertyValuesHolder scaleYholder = PropertyValuesHolder.ofKeyframe(&quot;scaleY&quot;,</div><div class="line">        scaleYFrame0, scaleYFrame1, scaleYFrame9, scaleYFrame10);</div><div class="line"></div><div class="line">Animator animator = ObjectAnimator.ofPropertyValuesHolder(mView,</div><div class="line">        frameHolder, scaleXholder, scaleYholder);</div><div class="line">animator.setDuration(2000);</div><div class="line">animator.start();</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-5b0e7f588fea169d.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03.6 精通自定义 View 之属性动画——Animator 动画的 XML 实现</title>
      <link href="/2019/07/03/05%20CUSTOM%20VIEW/03.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94Animator%20%E5%8A%A8%E7%94%BB%E7%9A%84%20XML%20%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/07/03/05%20CUSTOM%20VIEW/03.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94Animator%20%E5%8A%A8%E7%94%BB%E7%9A%84%20XML%20%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-bfdb45c4ef679e0b.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p>在 xml 中对应 animator 总共有三个标签，分别是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;animator/&gt;: 对应 ValueAnimator</div><div class="line">&lt;objectAnimator/&gt;: 对应 ObjectAnimator</div><div class="line">&lt;set/&gt;: 对应 AnimatorSet</div></pre></td></tr></table></figure></p><p><div id="jump1"></div></p><h3 id="3-6-1-animator-标签"><a href="#3-6-1-animator-标签" class="headerlink" title="3.6.1 animator 标签"></a>3.6.1 animator 标签</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>下面是完整的 animator 所有的字段及取值范围：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;animator</div><div class="line">    android:duration=&quot;int&quot;</div><div class="line">    android:valueFrom=&quot;float | int | color&quot;</div><div class="line">    android:valueTo=&quot;float | int | color&quot;</div><div class="line">    android:startOffset=&quot;int&quot;</div><div class="line">    android:repeatCount=&quot;int&quot;</div><div class="line">    android:repeatMode=[&quot;repeat&quot; | &quot;reverse&quot;]</div><div class="line">    android:valueType=[&quot;intType&quot; | &quot;floatType&quot;]</div><div class="line">    android:interpolator=[&quot;@android:interpolator/XXX&quot;]/&gt;</div></pre></td></tr></table></figure></p><ul><li><strong>android:duration</strong>：每次动画播放的时长。</li><li><strong>android:valueFrom</strong>：初始动化值；取值范围为 float、int 和 color，如果取值为 float 对应的值样式应该为 89.0，取值为 Int 时，对应的值样式为：89；当取值为 clolor 时，对应的值样式为 #333333。</li><li><strong>android:valueTo</strong>：动画结束值；取值范围同样是 float、int 和 color 这三种类型的值。</li><li><strong>android:startOffset</strong>：动画激活延时；对应代码中的 startDelay(long delay) 函数；</li><li><strong>android:repeatCount</strong>：动画重复次数</li><li><strong>android:repeatMode</strong>：动画重复模式，取值为 repeat 和 reverse；repeat 表示正序重播，reverse 表示倒序重播</li><li><strong>android:valueType</strong>：表示参数值类型，取值为 intType 和 floatType；与 android:valueFrom、android:valueTo 相对应。如果这里的取值为 intType，那么 android:valueFrom、android:valueTo 的值也就要对应的是 int 类型的数值。如果这里的数值是 floatType，那么 android:valueFrom、android:valueTo 的值也要对应的设置为 float 类型的值。非常注意的是，如果 android:valueFrom、android:valueTo 的值设置为 color 类型的值，那么不需要设置这个参数。</li><li><strong>android:interpolator</strong>：设置加速器；有关系统加速器所对应的 xml 值对照表如下：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/14186083-cf80cc3cfd34b03a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>加载 XML 文件到程序中的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ValueAnimator valueAnimator = (ValueAnimator) AnimatorInflater.loadAnimator(</div><div class="line">    MainActivity.this, R.animator.animator);</div><div class="line">valueAnimator.start();</div></pre></td></tr></table></figure></p><h4 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;animator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">          android:valueFrom=&quot;0&quot;</div><div class="line">          android:valueTo=&quot;300&quot;</div><div class="line">          android:duration=&quot;1000&quot;</div><div class="line">          android:valueType=&quot;intType&quot;</div><div class="line">          android:interpolator=&quot;@android:anim/bounce_interpolator&quot;/&gt;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ValueAnimator valueAnimator = (ValueAnimator) AnimatorInflater.loadAnimator(</div><div class="line">        MainActivity.this, R.animator.animator);</div><div class="line">valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">   @Override</div><div class="line">   public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">       int offset = (int)animation.getAnimatedValue();</div><div class="line">       mTv1.layout(offset, offset, mTv1.getWidth() + offset,</div><div class="line">                   mTv1.getHeight() + offset);</div><div class="line">   &#125;</div><div class="line">&#125;);</div><div class="line">valueAnimator.start();</div></pre></td></tr></table></figure><p><div id="jump2"></div></p><h3 id="3-6-2-objectAnimator-标签"><a href="#3-6-2-objectAnimator-标签" class="headerlink" title="3.6.2 objectAnimator 标签"></a>3.6.2 objectAnimator 标签</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;objectAnimator</div><div class="line">    android:propertyName=&quot;string&quot;</div><div class="line">    android:duration=&quot;int&quot;</div><div class="line">    android:valueFrom=&quot;float | int | color&quot;</div><div class="line">    android:valueTo=&quot;float | int | color&quot;</div><div class="line">    android:startOffset=&quot;int&quot;</div><div class="line">    android:repeatCount=&quot;int&quot;</div><div class="line">    android:repeatMode=[&quot;repeat&quot; | &quot;reverse&quot;]</div><div class="line">    android:valueType=[&quot;intType&quot; | &quot;floatType&quot;]</div><div class="line">    android:interpolator=[&quot;@android:interpolator/XXX&quot;]/&gt;</div></pre></td></tr></table></figure><ul><li><strong>android:propertyName</strong>：对应属性名，即 ObjectAnimator 所需要操作的属性名。其它字段的意义与 animator 的意义与取值是一样的，下面再重新列举一下。</li></ul><h4 id="2-示例-1"><a href="#2-示例-1" class="headerlink" title="2. 示例"></a>2. 示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:propertyName=&quot;TranslationY&quot;</div><div class="line">    android:duration=&quot;2000&quot;</div><div class="line">    android:valueFrom=&quot;0.0&quot;</div><div class="line">    android:valueTo=&quot;400.0&quot;</div><div class="line">    android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;</div><div class="line">    android:valueType=&quot;floatType&quot;</div><div class="line">    android:repeatCount=&quot;1&quot;</div><div class="line">    android:repeatMode=&quot;reverse&quot;</div><div class="line">    android:startOffset=&quot;2000&quot;/&gt;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator = (ObjectAnimator) AnimatorInflater.loadAnimator(</div><div class="line">        MainActivity.this, R.animator.object_animator);</div><div class="line">animator.setTarget(mTv1);</div><div class="line">animator.start();</div></pre></td></tr></table></figure><h4 id="3-color"><a href="#3-color" class="headerlink" title="3. color"></a>3. color</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:propertyName=&quot;BackgroundColor&quot;</div><div class="line">    android:duration=&quot;5000&quot;</div><div class="line">    android:valueFrom=&quot;#ffff00ff&quot;</div><div class="line">    android:valueTo=&quot;#ffffff00&quot;/&gt;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator = (ObjectAnimator) AnimatorInflater.loadAnimator(</div><div class="line">        MainActivity.this, R.animator.color_animator);</div><div class="line">animator.setTarget(mTv1);</div><div class="line">animator.start();</div></pre></td></tr></table></figure><p><div id="jump3"></div></p><h3 id="3-6-3-set-标签"><a href="#3-6-3-set-标签" class="headerlink" title="3.6.3 set 标签"></a>3.6.3 set 标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;set android:ordering=[&quot;together&quot; | &quot;sequentially&quot;]&gt;</div></pre></td></tr></table></figure><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:ordering=&quot;together&quot;&gt;</div><div class="line">    &lt;objectAnimator</div><div class="line">        android:propertyName=&quot;x&quot;</div><div class="line">        android:duration=&quot;500&quot;</div><div class="line">        android:valueFrom=&quot;0&quot;</div><div class="line">        android:valueTo=&quot;400&quot;</div><div class="line">        android:valueType=&quot;floatType&quot;/&gt;</div><div class="line">    &lt;objectAnimator</div><div class="line">        android:propertyName=&quot;y&quot;</div><div class="line">        android:duration=&quot;500&quot;</div><div class="line">        android:valueFrom=&quot;0&quot;</div><div class="line">        android:valueTo=&quot;300&quot;</div><div class="line">        android:valueType=&quot;floatType&quot;/&gt;</div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure></p><p>加载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(</div><div class="line">        MainActivity.this, R.animator.set_animator);</div><div class="line">set.setTarget(mTv1);</div><div class="line">set.start();</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-6e83ff5fe5a1f08a.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03.5 精通自定义 View 之属性动画——AnimatorSet</title>
      <link href="/2019/07/03/05%20CUSTOM%20VIEW/03.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94AnimatorSet/"/>
      <url>/2019/07/03/05%20CUSTOM%20VIEW/03.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94AnimatorSet/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-489f68e515417cef.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p>ValueAnimator 和 ObjectAnimator 都只能单单实现一个动画，那如果我们想要使用一个组合动画，就需要用到 AnimatorSet。</p><p>AnimatorSet 针对 ValueAnimator 和 ObjectAnimator 都是适用的，但一般而言，我们不会用到 ValueAnimator 的组合动画，所以我们这篇仅讲解 ObjectAnimator 下的组合动画实现。</p><p>在 AnimatorSet 中直接给为我们提供了两个方法 playSequentially 和 playTogether，playSequentially 表示所有动画依次播放，playTogether 表示所有动画一起开始。</p><p><div id="jump1"></div></p><h3 id="3-5-1-playSequentially-与-playTogether-函数"><a href="#3-5-1-playSequentially-与-playTogether-函数" class="headerlink" title="3.5.1 playSequentially() 与 playTogether() 函数"></a>3.5.1 playSequentially() 与 playTogether() 函数</h3><h4 id="1-playSequentially"><a href="#1-playSequentially" class="headerlink" title="1. playSequentially()"></a>1. playSequentially()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public void playSequentially(Animator... items);</div><div class="line">public void playSequentially(List&lt;Animator&gt; items);</div></pre></td></tr></table></figure><p>这里有两种声明，第一个是我们最常用的，它的参数是可变长参数，也就是说我们可以传进去任意多个 Animator 对象。这些对象的动画会逐个播放。第二个构造函数，是传进去一个 List&lt;Animator&gt; 的列表。原理一样，也是逐个去取 List 中的动画对象，然后逐个播放。</p><p>示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-5e9f4c01a7c476e3.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private Button mButton;</div><div class="line">    private TextView mTv1, mTv2;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        mButton =  findViewById(R.id.btn);</div><div class="line">        mTv1 =  findViewById(R.id.tv_1);</div><div class="line">        mTv2 =  findViewById(R.id.tv_2);</div><div class="line"></div><div class="line">        mButton.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                doPlaySequentiallyAnimator();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void doPlaySequentiallyAnimator() &#123;</div><div class="line">        ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1, </div><div class="line">                &quot;BackgroundColor&quot;, 0xffff00ff, 0xffffff00, 0xffff00ff);</div><div class="line">        ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1, </div><div class="line">                &quot;translationY&quot;, 0, 300, 0);</div><div class="line">        ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2, </div><div class="line">                &quot;translationY&quot;, 0, 400, 0);</div><div class="line"></div><div class="line">        AnimatorSet animatorSet = new AnimatorSet();</div><div class="line">        animatorSet.playSequentially(tv1BgAnimator, tv1TranslateY, tv2TranslateY);</div><div class="line">        animatorSet.setDuration(1000);</div><div class="line">        animatorSet.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>布局 act_main.xml：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/btn&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:padding=&quot;10dp&quot;</div><div class="line">        android:text=&quot;start anim&quot;/&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:id=&quot;@+id/tv_2&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_alignParentRight=&quot;true&quot;</div><div class="line">        android:layout_marginRight=&quot;30dp&quot;</div><div class="line">        android:background=&quot;#ff00ff&quot;</div><div class="line">        android:padding=&quot;10dp&quot;</div><div class="line">        android:text=&quot;TextView-2&quot; /&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:id=&quot;@+id/tv_1&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_toLeftOf=&quot;@id/tv_2&quot;</div><div class="line">        android:layout_marginRight=&quot;30dp&quot;</div><div class="line">        android:background=&quot;#ffff00&quot;</div><div class="line">        android:padding=&quot;10dp&quot;</div><div class="line">        android:text=&quot;TextView-1&quot; /&gt;</div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure></p><h4 id="2-playTogether"><a href="#2-playTogether" class="headerlink" title="2. playTogether()"></a>2. playTogether()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public void playTogether(Animator... items);</div><div class="line">public void playTogether(Collection&lt;Animator&gt; items);</div></pre></td></tr></table></figure><p>将上例中的代码更改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// animatorSet.playSequentially(tv1BgAnimator, tv1TranslateY, tv2TranslateY);</div><div class="line">animatorSet.playTogether(tv1BgAnimator, tv1TranslateY, tv2TranslateY);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-75a764faeec10d66.gif?imageMogr2/auto-orient/strip" alt=""></p><p>即三个动画同时播放。</p><h4 id="3、playSequentially-和-playTogether-函数的真正意义"><a href="#3、playSequentially-和-playTogether-函数的真正意义" class="headerlink" title="3、playSequentially 和 playTogether 函数的真正意义"></a>3、playSequentially 和 playTogether 函数的真正意义</h4><p>想必大家都看到赛马，在赛马开始前，每个马都会被放在起点的小门后面，到点了，门打开，马开始一起往前跑。而假如我们把每匹马看做是一个动画，那我们的 playTogether 就相当于赛马场里每个赛道上门的意义（当比赛开始时，每个赛道上的门会打开，马就可以开始比赛了）；也就是说，playTogether 只是一个时间点上的一起开始，对于开始后，各个动画怎么操作就是他们自己的事了，至于各个动画结不结束也是他们自已的事了。所以最恰当的描述就是门只负责打开，打开之后马咋跑，门也管不着，最后，马回不回来跟门也没啥关系。门的责任只是到点就打开而已。放在动画上，就是在激活动画之后，动画开始后的操作只是动画自己来负责。至于动画结不结束，也只有动画自己知道。</p><p>而 playSequentially 的意义就是当一匹马回来以后，再放另一匹。那如果上匹马永远没回来，那下一匹马也永远不会被放出来。放到动画上，就是把激活一个动画之后，动画之后的操作就是动画自己来负责了，这个动画结束之后，再激活下一个动画。如果上一个动画没有结束，那下一个动画就永远也不会被激活。</p><p>首先用 playTogether 来看个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1,</div><div class="line">        &quot;BackgroundColor&quot;, 0xffff00ff, 0xffffff00, 0xffff00ff);</div><div class="line">ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1,</div><div class="line">        &quot;translationY&quot;, 0, 300, 0);</div><div class="line">tv1TranslateY.setStartDelay(1000);</div><div class="line">tv1TranslateY.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2,</div><div class="line">        &quot;translationY&quot;, 0, 400, 0);</div><div class="line">tv2TranslateY.setStartDelay(1000);</div><div class="line"></div><div class="line">AnimatorSet animatorSet = new AnimatorSet();</div><div class="line">animatorSet.playTogether(tv1BgAnimator, tv1TranslateY, tv2TranslateY);</div><div class="line">animatorSet.setDuration(1000);</div><div class="line">animatorSet.start();</div></pre></td></tr></table></figure></p><p>在这个例子中，我们将 tv1TranslateY 开始延迟 1000 毫秒开始，并设为无限循环。tv2TranslateY 设为开始延迟 1000 毫秒。而tv1BgAnimator 则是没有任何设置，所以是默认直接开始。我们来看效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-aa0dd7dac5a3a77b.gif?imageMogr2/auto-orient/strip" alt=""></p><p>将上述例子做如下更改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// animatorSet.playTogether(tv1BgAnimator, tv1TranslateY, tv2TranslateY);</div><div class="line">animatorSet.playSequentially(tv1BgAnimator, tv1TranslateY, tv2TranslateY);</div></pre></td></tr></table></figure></p><p>使用 playSequentially 来逐个播放这三个动画，首先是tv1BgAnimator，动画结束之后，激活 tv1TranslateY。不过由于设置了延时，故 1000 毫秒再开始，而且该动画会无限循环。无限循环也就是说它永远也不会结束。那么第三个动画 tv2TranslateY 也永远不会开始。效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a7a097fbfc347421.gif?imageMogr2/auto-orient/strip" alt=""></p><p>总结：</p><ul><li>playTogether 和 playSequentially 在激活动画后，控件的动画情况与它们无关，他们只负责定时激活控件动画。</li><li>playSequentially 只有上一个控件做完动画以后，才会激活下一个控件的动画，如果上一控件的动画是无限循环，那下一个控件就别再指望能做动画了。</li></ul><h4 id="4-实现无限循环动画"><a href="#4-实现无限循环动画" class="headerlink" title="4. 实现无限循环动画"></a>4. 实现无限循环动画</h4><p>因为 AnimatorSet 中没有设置循环次数的函数，所以得为每个动画设置了无限循环，并且只能用 playTogether() 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1,</div><div class="line">        &quot;BackgroundColor&quot;, 0xffff00ff, 0xffffff00, 0xffff00ff);</div><div class="line">tv1BgAnimator.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1,</div><div class="line">        &quot;translationY&quot;, 0, 300, 0);</div><div class="line">tv1TranslateY.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2,</div><div class="line">        &quot;translationY&quot;, 0, 400, 0);</div><div class="line">tv2TranslateY.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line"></div><div class="line">AnimatorSet animatorSet = new AnimatorSet();</div><div class="line">animatorSet.playTogether(tv1BgAnimator, tv1TranslateY, tv2TranslateY);</div><div class="line">animatorSet.setDuration(1000);</div><div class="line">animatorSet.start();</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d38d7f24f286dbca.gif?imageMogr2/auto-orient/strip" alt=""></p><p><div id="jump2"></div></p><h3 id="3-5-2-AnimatorSet-Builder"><a href="#3-5-2-AnimatorSet-Builder" class="headerlink" title="3.5.2 AnimatorSet.Builder"></a>3.5.2 AnimatorSet.Builder</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>playTogether 和 playSequentially，分别能实现一起开始动画和逐个开始动画。但并不是非常自由的组合动画，比如我们有三个动画 A、B、C，我们想先播放 C 然后同时播放 A 和 B。利用 playTogether 和 playSequentially 是没办法实现的，所以为了更方便的组合动画，谷歌的开发人员另外给我们提供一个类 AnimatorSet.Builder。</p><p>我们这里使用 AnimatorSet.Builder 实现两个控件一同开始动画。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1,</div><div class="line">        &quot;BackgroundColor&quot;, 0xffff00ff, 0xffffff00, 0xffff00ff);</div><div class="line">ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1,</div><div class="line">        &quot;translationY&quot;, 0, 300, 0);</div><div class="line">ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2,</div><div class="line">        &quot;translationY&quot;, 0, 400, 0);</div><div class="line"></div><div class="line">AnimatorSet animatorSet = new AnimatorSet();</div><div class="line">AnimatorSet.Builder builder = animatorSet.play(tv1BgAnimator);</div><div class="line">builder.with(tv1TranslateY).with(tv2TranslateY);</div><div class="line">// animatorSet.playTogether(tv1BgAnimator, tv1TranslateY, tv2TranslateY);</div><div class="line">animatorSet.setDuration(1000);</div><div class="line">animatorSet.start();</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e31f09c7c1458d53.gif?imageMogr2/auto-orient/strip" alt=""></p><h4 id="2-AnimatorSet-Builder-的函数"><a href="#2-AnimatorSet-Builder-的函数" class="headerlink" title="2. AnimatorSet.Builder 的函数"></a>2. AnimatorSet.Builder 的函数</h4><p>从上面的代码中，我们可以看到 AnimatorSet.Builder 是通过 animatorSet.play(tv1BgAnimator) 生成的，这是生成AnimatorSet.Builder对象的唯一途径！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 表示要播放哪个动画</div><div class="line">public Builder play(Animator anim)</div><div class="line">// 和前面动画一起执行</div><div class="line">public Builder with(Animator anim)</div><div class="line">// 执行前面的动画后才执行该动画</div><div class="line">public Builder before(Animator anim)</div><div class="line">// 执行先执行这个动画再执行前面动画</div><div class="line">public Builder after(Animator anim)</div><div class="line">// 延迟 n 毫秒之后执行动画</div><div class="line">public Builder after(long delay)</div></pre></td></tr></table></figure></p><p>play(Animator anim) 表示当前在播放哪个动画，另外的 with(Animator anim)、before(Animator anim)、after(Animator anim) 都是以 play 中的当前所播放的动画为基准的。</p><p>比如，当 play(playAnim) 与 before(beforeAnim) 共用，则表示在播放 beforeAnim 之前，先播放 playAnim 动画；同样，当 play(playAnim) 与 after(afterAnim) 共用时，则表示在在播放 afterAnim 动画之后，再播放 playAnim 动画。</p><p>每个函数的返回值都是 Builder 对象，于是可以使用串行方式使用它们：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">animatorSet.play(tv1BgAnimator).with(tv1TranslateY).with(tv2TranslateY);</div></pre></td></tr></table></figure></p><p><div id="jump3"></div></p><h3 id="3-5-3-AnimatorSet-监听器"><a href="#3-5-3-AnimatorSet-监听器" class="headerlink" title="3.5.3 AnimatorSet 监听器"></a>3.5.3 AnimatorSet 监听器</h3><p>在 AnimatorSet 中也可以添加监听器，对应的监听器为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public static interface AnimatorListener &#123;</div><div class="line">    // 当AnimatorSet开始时调用</div><div class="line">    void onAnimationStart(Animator animation);</div><div class="line">    // 当AnimatorSet结束时调用</div><div class="line">    void onAnimationEnd(Animator animation);</div><div class="line">    // 当AnimatorSet被取消时调用</div><div class="line">    void onAnimationCancel(Animator animation);</div><div class="line">    /**</div><div class="line">     * 当 AnimatorSet 重复时调用，由于 AnimatorSet 没有设置 </div><div class="line">     * repeat 的函数，所以这个方法永远不会被调用。</div><div class="line">     */</div><div class="line">    void onAnimationRepeat(Animator animation);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private AnimatorSet mAnimatorSet;</div><div class="line">    private TextView mTv1, mTv2;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        mTv1 =  findViewById(R.id.tv_1);</div><div class="line">        mTv2 =  findViewById(R.id.tv_2);</div><div class="line"></div><div class="line">        findViewById(R.id.start_btn).setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                mAnimatorSet = doPlayAnimatorSet();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        findViewById(R.id.cancel_btn).setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                if (mAnimatorSet != null) &#123;</div><div class="line">                    mAnimatorSet.cancel();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private AnimatorSet doPlayAnimatorSet() &#123;</div><div class="line">        ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1,</div><div class="line">                &quot;translationY&quot;, 0, 400, 0);</div><div class="line">        ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2,</div><div class="line">                &quot;translationY&quot;, 0, 400, 0);</div><div class="line">        tv2TranslateY.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line"></div><div class="line">        AnimatorSet animatorSet = new AnimatorSet();</div><div class="line">        animatorSet.play(tv1TranslateY).with(tv2TranslateY);</div><div class="line">        animatorSet.addListener(new Animator.AnimatorListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationStart(Animator animation) &#123;</div><div class="line">                Log.e(&quot;xian&quot;, &quot;animator start&quot;);</div><div class="line">            &#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationEnd(Animator animation) &#123;</div><div class="line">                Log.e(&quot;xian&quot;, &quot;animator end&quot;);</div><div class="line">            &#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationCancel(Animator animation) &#123;</div><div class="line">                Log.e(&quot;xian&quot;, &quot;animator cancel&quot;);</div><div class="line">            &#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationRepeat(Animator animation) &#123;</div><div class="line">                Log.e(&quot;xian&quot;, &quot;animator repeat&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        animatorSet.setDuration(1000);</div><div class="line">        animatorSet.start();</div><div class="line"></div><div class="line">        return animatorSet;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-165bcafa582d0d1e.gif?imageMogr2/auto-orient/strip" alt=""></p><p>日志输出如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-41da58e3c9eab1e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>总结一下 AnimatorSet 的监听：<br>AnimatorSet 的监听函数也只是用来监听 AnimatorSet 的状态的，与其中的动画无关。<br>AnimatorSet 中没有设置循环的函数，所以 AnimatorSet 监听器中永远无法运行到 onAnimationRepeat() 中。</p></blockquote><p><div id="jump4"></div></p><h3 id="3-5-4-常用函数"><a href="#3-5-4-常用函数" class="headerlink" title="3.5.4 常用函数"></a>3.5.4 常用函数</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>在 AnimatorSet 中还有几个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 设置单次动画时长</div><div class="line">public AnimatorSet setDuration(long duration);</div><div class="line">// 设置加速器</div><div class="line">public void setInterpolator(TimeInterpolator interpolator)</div><div class="line">// 设置ObjectAnimator动画目标控件</div><div class="line">public void setTarget(Object target)</div></pre></td></tr></table></figure></p><p>在 AnimatorSet 中设置以后，会覆盖单个 ObjectAnimator 中的设置；即如果 AnimatorSet 中没有设置，那么就以 ObjectAnimator 中的设置为准。如果 AnimatorSet 中设置以后，ObjectAnimator 中的设置就会无效。</p><p>下面我们简单举个例子来看下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1, &quot;translationY&quot;, 0, 400, 0);</div><div class="line">tv1TranslateY.setDuration(500000000);</div><div class="line">tv1TranslateY.setInterpolator(new BounceInterpolator());</div><div class="line"></div><div class="line">ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2, &quot;translationY&quot;, 0, 400, 0);</div><div class="line">tv2TranslateY.setInterpolator(new AccelerateDecelerateInterpolator());</div><div class="line"></div><div class="line">AnimatorSet animatorSet = new AnimatorSet();</div><div class="line">animatorSet.play(tv2TranslateY).with(tv1TranslateY);</div><div class="line">animatorSet.setDuration(2000);</div><div class="line">animatorSet.start();</div></pre></td></tr></table></figure></p><p>在第这个例子中，我们通过 animatorSet.setDuration(2000); 设置为所有动画单词运动时长为 2000 毫秒，虽然我们给 tv1TranslateY 设置了单次动画时长为 tv1TranslateY.setDuration(500000000); 但由于 AnimatorSet 设置了 setDuration(2000) 这个参数以后，单个动画的时长设置将无效。所以每个动画的时长为 2000 毫秒。</p><p>但我们这里还分别给 tv1 和 tv2 设置了加速器，但并没有给 AnimatorSet 设置加速器，那么 tv1、tv2 将按各自加速器的表现形式做动画。同样，如果我们给 AnimatorSet 设置上了加速器，那么单个动画中所设置的加速器都将无效，以 AnimatorSet 中的加速器为准。</p><h4 id="2-setTarget-Object-target-函数"><a href="#2-setTarget-Object-target-函数" class="headerlink" title="2. setTarget(Object target) 函数"></a>2. setTarget(Object target) 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 设置 ObjectAnimator 动画目标控件</div><div class="line">public void setTarget(Object target)</div></pre></td></tr></table></figure><p>这个函数是用来设置目标控件的，也就是说，只要通过 AnimatorSet 的 setTartget 函数设置了目标控件，那么单个动画中的目标控件都以 AnimatorSet 设置的为准。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1, &quot;BackgroundColor&quot;, </div><div class="line">        0xffff00ff, 0xffffff00, 0xffff00ff);</div><div class="line">ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2, &quot;translationY&quot;, 0, 400, 0);</div><div class="line"></div><div class="line">AnimatorSet animatorSet = new AnimatorSet();</div><div class="line">animatorSet.playTogether(tv1BgAnimator,tv2TranslateY);</div><div class="line">animatorSet.setDuration(2000);</div><div class="line">animatorSet.setTarget(mTv2);</div><div class="line">animatorSet.start();</div></pre></td></tr></table></figure></p><p>在这段代码中，我们给 tv1 设置了改变背景色，给 tv2 设置了上下移动。但由于我们通过 animatorSet.setTarget(mTv2); 将各个动画的目标控件设置为 mTv2，所以 tv1 将不会有任何动画，所有的动画都会发生在 tv2 上。</p><h4 id="3-setStartDelay-long-startDelay-函数"><a href="#3-setStartDelay-long-startDelay-函数" class="headerlink" title="3. setStartDelay(long startDelay) 函数"></a>3. setStartDelay(long startDelay) 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 设置延时开始动画时长</div><div class="line">public void setStartDelay(long startDelay)</div></pre></td></tr></table></figure><p>上面我们讲了，当 AnimatorSet 所拥有的函数与单个动画所拥有的函数冲突时，就以 AnimatorSet 设置为准。但唯一的例外就是 setStartDelay。</p><ul><li>AnimatorSet 的延时是仅针对性的延长 AnimatorSet 激活时间的，对单个动画的延时设置没有影响。</li><li>AnimatorSet 真正激活延时 = AnimatorSet.startDelay + 第一个动画.startDelay</li><li>在 AnimatorSet 激活之后，第一个动画绝对是会开始运行的，后面的动画则根据自己是否延时自行处理。</li></ul><p><div id="jump5"></div></p><h3 id="3-5-5-示例：路径动画"><a href="#3-5-5-示例：路径动画" class="headerlink" title="3.5.5 示例：路径动画"></a>3.5.5 示例：路径动画</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-669df7152448f16f.gif?imageMogr2/auto-orient/strip" alt=""></p><p>代码 MainActivity.java：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private Button btn1, btn2, btn3, btn4, btn5;</div><div class="line">    private boolean mIsMenuOpen = false;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        Button menu = findViewById(R.id.menu);</div><div class="line">        btn1 = findViewById(R.id.btn1);</div><div class="line">        btn2 = findViewById(R.id.btn2);</div><div class="line">        btn3 = findViewById(R.id.btn3);</div><div class="line">        btn4 = findViewById(R.id.btn4);</div><div class="line">        btn5 = findViewById(R.id.btn5);</div><div class="line"></div><div class="line">        menu.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                if (mIsMenuOpen) &#123;</div><div class="line">                    closeMenu();</div><div class="line">                    mIsMenuOpen = false;</div><div class="line">                &#125; else &#123;</div><div class="line">                    openMenu();</div><div class="line">                    mIsMenuOpen = true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void openMenu() &#123;</div><div class="line">        doAnimateOpen(btn1, 0, 5, 600);</div><div class="line">        doAnimateOpen(btn2, 1, 5, 600);</div><div class="line">        doAnimateOpen(btn3, 2, 5, 600);</div><div class="line">        doAnimateOpen(btn4, 3, 5, 600);</div><div class="line">        doAnimateOpen(btn5, 4, 5, 600);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void closeMenu() &#123;</div><div class="line">        doAnimatColse(btn1, 0, 5, 600);</div><div class="line">        doAnimatColse(btn2, 1, 5, 600);</div><div class="line">        doAnimatColse(btn3, 2, 5, 600);</div><div class="line">        doAnimatColse(btn4, 3, 5, 600);</div><div class="line">        doAnimatColse(btn5, 4, 5, 600);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void doAnimateOpen(View view, int index, int total, int radius) &#123;</div><div class="line">        double degree = Math.toRadians(90) / (total - 1) * index;</div><div class="line">        int translationX = -(int) (Math.sin(degree) * radius);</div><div class="line">        int translationY = -(int) (Math.cos(degree) * radius);</div><div class="line">        AnimatorSet animatorSet = new AnimatorSet();</div><div class="line">        animatorSet.playTogether(</div><div class="line">                ObjectAnimator.ofFloat(view, &quot;translationX&quot;, 0, translationX),</div><div class="line">                ObjectAnimator.ofFloat(view, &quot;translationY&quot;, 0, translationY),</div><div class="line">                ObjectAnimator.ofFloat(view, &quot;scaleX&quot;, 0f, 1f),</div><div class="line">                ObjectAnimator.ofFloat(view, &quot;scaleY&quot;, 0f, 1f),</div><div class="line">                ObjectAnimator.ofFloat(view, &quot;alpha&quot;, 0f, 1f));</div><div class="line">        animatorSet.setDuration(500);</div><div class="line">        animatorSet.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void doAnimatColse(View view, int index, int total, int radius) &#123;</div><div class="line">        double degree = Math.toRadians(90) / (total - 1) * index;</div><div class="line">        int translationX = -(int) (Math.sin(degree) * radius);</div><div class="line">        int translationY = -(int) (Math.cos(degree) * radius);</div><div class="line">        AnimatorSet animatorSet = new AnimatorSet();</div><div class="line">        animatorSet.playTogether(</div><div class="line">                ObjectAnimator.ofFloat(view, &quot;translationX&quot;, translationX, 0),</div><div class="line">                ObjectAnimator.ofFloat(view, &quot;translationY&quot;, translationY, 0),</div><div class="line">                ObjectAnimator.ofFloat(view, &quot;scaleX&quot;, 1f, 0f),</div><div class="line">                ObjectAnimator.ofFloat(view, &quot;scaleY&quot;, 1f, 0f),</div><div class="line">                ObjectAnimator.ofFloat(view, &quot;alpha&quot;, 1f, 0f));</div><div class="line">        animatorSet.setDuration(500);</div><div class="line">        animatorSet.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>布局文件 act_main：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:padding=&quot;20dp&quot;&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/btn1&quot;</div><div class="line">        style=&quot;@style/MenuItemStyle&quot;</div><div class="line">        android:background=&quot;@drawable/circle1&quot;/&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/btn2&quot;</div><div class="line">        style=&quot;@style/MenuItemStyle&quot;</div><div class="line">        android:background=&quot;@drawable/circle2&quot;/&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/btn3&quot;</div><div class="line">        style=&quot;@style/MenuItemStyle&quot;</div><div class="line">        android:background=&quot;@drawable/circle3&quot;/&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/btn4&quot;</div><div class="line">        style=&quot;@style/MenuItemStyle&quot;</div><div class="line">        android:background=&quot;@drawable/circle4&quot;/&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/btn5&quot;</div><div class="line">        style=&quot;@style/MenuItemStyle&quot;</div><div class="line">        android:background=&quot;@drawable/circle5&quot;/&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/menu&quot;</div><div class="line">        style=&quot;@style/MenuStyle&quot;</div><div class="line">        android:background=&quot;@drawable/circle&quot;/&gt;</div><div class="line">&lt;/FrameLayout&gt;</div></pre></td></tr></table></figure></p><p>引用资源 circle.xml：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:shape=&quot;oval&quot;&gt;</div><div class="line">    &lt;solid android:color=&quot;@color/colorAccent&quot;/&gt;</div><div class="line">    &lt;solid android:color=&quot;#983B90&quot;/&gt;</div><div class="line">    &lt;solid android:color=&quot;#785B90&quot;/&gt;</div><div class="line">    &lt;solid android:color=&quot;#587BA0&quot;/&gt;</div><div class="line">    &lt;solid android:color=&quot;#389BF0&quot;/&gt;</div><div class="line">    &lt;solid android:color=&quot;#18DB00&quot;/&gt;</div><div class="line">&lt;/shape&gt;</div></pre></td></tr></table></figure></p><p>主题样式 style.xml：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;resources&gt;</div><div class="line">    ...</div><div class="line">    &lt;style name=&quot;MenuStyle&quot; &gt;</div><div class="line">        &lt;item name=&quot;android:layout_width&quot;&gt;50dp&lt;/item&gt;</div><div class="line">        &lt;item name=&quot;android:layout_height&quot;&gt;50dp&lt;/item&gt;</div><div class="line">        &lt;item name=&quot;android:layout_gravity&quot;&gt;right|bottom&lt;/item&gt;</div><div class="line">    &lt;/style&gt;</div><div class="line">    &lt;style name=&quot;MenuItemStyle&quot; &gt;</div><div class="line">        &lt;item name=&quot;android:layout_width&quot;&gt;40dp&lt;/item&gt;</div><div class="line">        &lt;item name=&quot;android:layout_height&quot;&gt;40dp&lt;/item&gt;</div><div class="line">        &lt;item name=&quot;android:layout_margin&quot;&gt;5dp&lt;/item&gt;</div><div class="line">        &lt;item name=&quot;android:layout_gravity&quot;&gt;right|bottom&lt;/item&gt;</div><div class="line">    &lt;/style&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c76549cfcb3c392c.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03.4 精通自定义 View 之属性动画——ObjectAnimator</title>
      <link href="/2019/07/03/05%20CUSTOM%20VIEW/03.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ObjectAnimator/"/>
      <url>/2019/07/03/05%20CUSTOM%20VIEW/03.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ObjectAnimator/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e6d9339e5b6e0731.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="3-4-1-概述"><a href="#3-4-1-概述" class="headerlink" title="3.4.1 概述"></a>3.4.1 概述</h3><h4 id="1-引入"><a href="#1-引入" class="headerlink" title="1. 引入"></a>1. 引入</h4><p>ObjectAnimator 派生自 ValueAnimator，所以 ValueAnimator 能用的方法，ObjectAnimator 都能用，ObjectAnimator 是 ValueAnimator 的子类。</p><p>ObjectAnimator 重载了几个方法，例如 ofInt()，ofFloat() 等，这里我以 ofFloat() 做个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(mView, &quot;alpha&quot;, 1, 0, 1);</div><div class="line">animator.setDuration(2000);</div><div class="line">animator.start();</div></pre></td></tr></table></figure></p><p>其构造函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static ObjectAnimator ofFloat(Object target, String propertyName,float... values)</div></pre></td></tr></table></figure></p><ul><li>第一个参数用于指定这个动画要操作的是哪个控件。</li><li>第二个参数用于指定这个动画要操作这个控件的哪个属性。</li><li>第三个参数是可变长参数，是指这个属性值如何变化。</li></ul><h4 id="2-set-函数"><a href="#2-set-函数" class="headerlink" title="2. set 函数"></a>2. set 函数</h4><p>ObjectAnimator 做动画，是通过指定属性所对应的 set 方法来改变的。比如，我们上面指定的改变 alpha 的属性值，ObjectAnimator 在做动画时就会到指定控件（TextView）中去找对应的 setAlpha() 方法来改变控件中对应的值。在 View 中有关动画，总共有下面几组 set 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 1. 透明度：alpha  </div><div class="line">public void setAlpha(float alpha)  </div><div class="line">  </div><div class="line">// 2. 旋转度数：rotation、rotationX、rotationY  </div><div class="line">public void setRotation(float rotation)  </div><div class="line">public void setRotationX(float rotationX)  </div><div class="line">public void setRotationY(float rotationY)  </div><div class="line">  </div><div class="line">// 3. 平移：translationX、translationY  </div><div class="line">public void setTranslationX(float translationX)   </div><div class="line">public void setTranslationY(float translationY)  </div><div class="line">  </div><div class="line">// 4. 缩放：scaleX、scaleY  </div><div class="line">public void setScaleX(float scaleX)  </div><div class="line">public void setScaleY(float scaleY)</div></pre></td></tr></table></figure></p><p>注意：</p><ul><li>要使用 ObjectAnimator 来构造对画，要操作的控件中，必须存在对应的属性的 set 方法，而且参数类型必须与构造所使用的 ofFloat() 或者 ofInt() 函数一致。</li><li>set 方法的命名必须以骆驼拼写法命名，即 set 后每个单词首字母大写，其余字母小写，即类似于 setPropertyName 所对应的属性为propertyName。</li></ul><h5 id="1）改变旋转度数-rotation、rotationX、rotationY"><a href="#1）改变旋转度数-rotation、rotationX、rotationY" class="headerlink" title="1）改变旋转度数 rotation、rotationX、rotationY"></a>1）改变旋转度数 rotation、rotationX、rotationY</h5><ul><li>float rotationX：表示围绕 X 轴旋转，rotationX 表示旋转度数</li><li>float rotationY：表示围绕 Y 轴旋转，rotationY 表示旋转度数</li><li>float rotation：表示围绕 Z 轴（垂直于屏幕）旋转，rotation 表示旋转度数</li></ul><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(mView, &quot;rotationX&quot;, 0, 270, 0);</div><div class="line">// ObjectAnimator animator = ObjectAnimator.ofFloat(mView, &quot;rotationY&quot;, 0, 180, 0);</div><div class="line">// ObjectAnimator animator = ObjectAnimator.ofFloat(mView, &quot;rotation&quot;, 0, 270, 0);</div><div class="line">animator.setDuration(2000);</div><div class="line">animator.start();</div></pre></td></tr></table></figure></p><h5 id="2）移动-translationX、translationY"><a href="#2）移动-translationX、translationY" class="headerlink" title="2）移动 translationX、translationY"></a>2）移动 translationX、translationY</h5><ul><li>float translationX：表示在 X 轴上的平移距离，以当前控件为原点，向右为正方向，参数 translationX 表示移动的距离。</li><li>float translationY：表示在 Y 轴上的平移距离，以当前控件为原点，向下为正方向，参数 translationY 表示移动的距离。</li></ul><h5 id="3）缩放-scaleX、scaleY"><a href="#3）缩放-scaleX、scaleY" class="headerlink" title="3）缩放 scaleX、scaleY"></a>3）缩放 scaleX、scaleY</h5><ul><li>float scaleX：在 X 轴上缩放，scaleX 表示缩放倍数</li><li>float scaleY：在 Y 轴上缩放，scaleY 表示缩放倍数</li></ul><h5 id="4）改变透明度-alpha"><a href="#4）改变透明度-alpha" class="headerlink" title="4）改变透明度 alpha"></a>4）改变透明度 alpha</h5><ul><li>float alpha：改变透明度</li></ul><p><div id="jump2"></div></p><h3 id="3-4-2-ObjectAnimator-动画原理"><a href="#3-4-2-ObjectAnimator-动画原理" class="headerlink" title="3.4.2 ObjectAnimator 动画原理"></a>3.4.2 ObjectAnimator 动画原理</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-fb03836ca925ae33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>与 ValueAnimator 不同的是最后一步，在 ValueAnimator 中，我们要通过添加监听器来监听当前数字值。而在 ObjectAnimator 中，则是先根据属性值拼装成对应的 set 函数的名字，比如这里的 scaleY 的拼装方法就是将属性的第一个字母强制大写后，与 set 拼接，所以就是 setScaleY 。然后通过反射找到对应控件的 setScaleY(float scaleY) 函数，将当前数字值做为 setScaleY(float scale) 的参数将其传入。</p><p>如果我们要自定义 ObjectAnimator 属性就要注意以下几个点：</p><ul><li>在命名时 set 之后的名字就是属性的名字。同时属性名字第一个字母不区分大小写，后面的名字必须与属性的名字相同。</li><li>在知道参数类型后我们才能确定我们是调用 ofFloat 还是 ofInt，这个参数是根据 setXXX 方法中的参数类型决定的。例如：setAlpha(float alpha) 其中参数类型是 float 所以上面我们使用的是 ofFloat，当然 ObjectAnimator 继承 ValueAnimatior 也有。ofObject() 支持任意类型，不过和前面我们讲到的一样这里我们就要自定义自己的估值器了。</li></ul><p><div id="jump3"></div></p><h3 id="3-4-3-自定义-ObjectAnimator-属性"><a href="#3-4-3-自定义-ObjectAnimator-属性" class="headerlink" title="3.4.3 自定义 ObjectAnimator 属性"></a>3.4.3 自定义 ObjectAnimator 属性</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7e772b9076b48c45.gif?imageMogr2/auto-orient/strip" alt=""></p><p>自定义 FallingBallImageView 和 Evaluator<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class FallingBallImageView extends AppCompatImageView &#123;</div><div class="line">    public FallingBallImageView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setFallingPos(Point pos) &#123;</div><div class="line">        layout(pos.x, pos.y, pos.x + getWidth(), pos.y + getHeight());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static class FallingBallEvaluator implements TypeEvaluator&lt;Point&gt; &#123;</div><div class="line">        private Point point = new Point();</div><div class="line">        @Override</div><div class="line">        public Point evaluate(float fraction, Point startValue, Point endValue) &#123;</div><div class="line">            point.x = (int)(startValue.x + fraction * (endValue.x - startValue.x));</div><div class="line">            if (fraction * 2 &lt; 1) &#123;</div><div class="line">                point.y = (int)(startValue.y + fraction*2*(endValue.y - startValue.y));</div><div class="line">            &#125; else &#123;</div><div class="line">                point.y = endValue.y;</div><div class="line">            &#125;</div><div class="line">            return point;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在代码中，开始动画：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        final FallingBallImageView view = findViewById(R.id.ball_img);</div><div class="line">        findViewById(R.id.start_btn).setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                ObjectAnimator animator = ObjectAnimator.ofObject(view, &quot;fallingPos&quot;,</div><div class="line">                        new FallingBallImageView.FallingBallEvaluator(),</div><div class="line">                        new Point(0, 0), new Point(500, 500));</div><div class="line">                animator.setDuration(2000);</div><div class="line">                animator.start();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>布局文件 act_main.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:layout_gravity=&quot;center_horizontal&quot;</div><div class="line">    android:orientation=&quot;horizontal&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.xxt.xtest.FallingBallImageView</div><div class="line">        android:id=&quot;@+id/ball_img&quot;</div><div class="line">        android:layout_width=&quot;50dp&quot;</div><div class="line">        android:layout_height=&quot;50dp&quot;</div><div class="line">        android:src=&quot;@drawable/circle&quot;/&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/start_btn&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_marginLeft=&quot;30dp&quot;</div><div class="line">        android:text=&quot;开启动画&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>其中，drawable/circle.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;shape</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:shape=&quot;oval&quot;&gt;</div><div class="line">    &lt;solid android:color=&quot;#FF0000&quot;/&gt;</div><div class="line">&lt;/shape&gt;</div></pre></td></tr></table></figure></p><p><div id="jump4"></div></p><h3 id="3-4-4-何时需要实现对应的-get-函数"><a href="#3-4-4-何时需要实现对应的-get-函数" class="headerlink" title="3.4.4 何时需要实现对应的 get 函数"></a>3.4.4 何时需要实现对应的 get 函数</h3><p>ObjectAnimator 有三个构造函数：ofInt()、ofFloat() 和 ofObject()，它们的最后一个参数都是可变长参数，用于指定动画值的变化区间。如果我们只定义一个值，如上例中改成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator = ObjectAnimator.ofObject(view, &quot;fallingPos&quot;,</div><div class="line">                        new FallingBallImageView.FallingBallEvaluator(),</div><div class="line">                        new Point(500, 500));</div></pre></td></tr></table></figure></p><p>则会发生异常，信息如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e4d89fda63bedd35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>当且仅当我们只给动画一个值时，程序才会调用属性对应的 get 函数来得到动画初始值。如果没有初始值，就会使用系统默认值。比如 ofInt() 函数中使用的参数类型是 int 类型，而 int 类型的默认值是 0，动画就会从 0 开始。所以上述自定义控件 FallingBallImageView 设置 get 函数，那么将会以 get 函数的返回值作为初始值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class FallingBallImageView extends AppCompatImageView &#123;</div><div class="line">    ...</div><div class="line">    public Point getFallingPos() &#123;</div><div class="line">        return new Point(0, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>总结：当且仅当动画只有一个过渡值时，系统才会调用属性对应的 get 函数来得到动画的初始值。当不存在 get 函数时，则会去动画参数类型的默认值作为初始值；当无法取得动画参数类型的默认值时，程序会直接崩溃。</p></blockquote><p><div id="jump5"></div></p><h3 id="3-4-5-常用函数"><a href="#3-4-5-常用函数" class="headerlink" title="3.4.5 常用函数"></a>3.4.5 常用函数</h3><p>用法和效果与 ValueAnimator 的函数是完全一样的。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f3beb3fb6e787aaa.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03.3 精通自定义 View 之属性动画——ofObject</title>
      <link href="/2019/07/03/05%20CUSTOM%20VIEW/03.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ofObject/"/>
      <url>/2019/07/03/05%20CUSTOM%20VIEW/03.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ofObject/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d060cebe309b6e38.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static ValueAnimator ofObject(TypeEvaluator evaluator, Object... values)</div></pre></td></tr></table></figure><p><div id="jump1"></div></p><h3 id="3-3-1-示例：字母从-A-变化到-Z"><a href="#3-3-1-示例：字母从-A-变化到-Z" class="headerlink" title="3.3.1 示例：字母从 A 变化到 Z"></a>3.3.1 示例：字母从 A 变化到 Z</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7be4c63a0f016955.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">private void startAnim() &#123;</div><div class="line">    ValueAnimator animator = ValueAnimator.ofObject(new CharEvaluator(),</div><div class="line">            Character.valueOf(&apos;A&apos;), Character.valueOf(&apos;Z&apos;));</div><div class="line">    animator.setDuration(3000);</div><div class="line">    animator.setInterpolator(new AccelerateInterpolator());</div><div class="line">    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">            char text = (Character) animation.getAnimatedValue();</div><div class="line">            mView.setText(String.valueOf(text));</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    animator.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class CharEvaluator implements TypeEvaluator&lt;Character&gt; &#123;</div><div class="line">    @Override</div><div class="line">    public Character evaluate(float fraction,Character startValue,Character endValue)&#123;</div><div class="line">        int startInt = (int) startValue;</div><div class="line">        int endInt = (int) endValue;</div><div class="line">        int value = (int) (startInt + fraction * (endInt - startInt));</div><div class="line">        return (char) value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><div id="jump2"></div></p><h3 id="3-3-2-示例：抛物动画"><a href="#3-3-2-示例：抛物动画" class="headerlink" title="3.3.2 示例：抛物动画"></a>3.3.2 示例：抛物动画</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-3e1482dc4d082b7f.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">private void startAnim() &#123;</div><div class="line">    ValueAnimator animator = ValueAnimator.ofObject(new FallingBallEvaluator(),</div><div class="line">            new Point(0, mTop), new Point(500, 500));</div><div class="line">    animator.setDuration(3000);</div><div class="line">    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">            Point p = (Point) animation.getAnimatedValue();</div><div class="line">            mView.layout(p.x, p.y, p.x + mView.getWidth(), p.y + mView.getHeight());</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    animator.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class FallingBallEvaluator implements TypeEvaluator&lt;Point&gt; &#123;</div><div class="line">    private Point point = new Point();</div><div class="line">    @Override</div><div class="line">    public Point evaluate(float fraction, Point startValue, Point endValue) &#123;</div><div class="line">        point.x = (int)(startValue.x + fraction * (endValue.x - startValue.x));</div><div class="line">        if (fraction * 2 &lt; 1) &#123;</div><div class="line">            point.y = (int)(startValue.y + fraction * 2 * (endValue.y - startValue.y));</div><div class="line">        &#125; else &#123;</div><div class="line">            point.y = endValue.y;</div><div class="line">        &#125;</div><div class="line">        return point;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14186083-dff045e96f257cca.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03.2 精通自定义 View 之属性动画——自定义插值器与 Evaluator</title>
      <link href="/2019/07/03/05%20CUSTOM%20VIEW/03.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E5%80%BC%E5%99%A8%E4%B8%8E%20Evaluator/"/>
      <url>/2019/07/03/05%20CUSTOM%20VIEW/03.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E5%80%BC%E5%99%A8%E4%B8%8E%20Evaluator/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-59a2e1bfd00150de.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p>视图动画，只能设置插值器；但对于 Animator 而言，不仅可以设置插值器，还可以设置 Evaluator。</p><p><div id="jump1"></div></p><h3 id="3-2-1-自定义插值器"><a href="#3-2-1-自定义插值器" class="headerlink" title="3.2.1 自定义插值器"></a>3.2.1 自定义插值器</h3><p>插值器就是用来控制动画的区间值如何被计算出来的。</p><h4 id="1、系统自带插值器"><a href="#1、系统自带插值器" class="headerlink" title="1、系统自带插值器"></a>1、系统自带插值器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class AccelerateDecelerateInterpolator extends BaseInterpolator  &#123;</div><div class="line">    public AccelerateDecelerateInterpolator() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @SuppressWarnings(&#123;&quot;UnusedDeclaration&quot;&#125;)</div><div class="line">    public AccelerateDecelerateInterpolator(Context context, AttributeSet attrs) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public float getInterpolation(float input) &#123;</div><div class="line">        return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">// 最终实现的接口：TimeInterpolator</div><div class="line">public interface TimeInterpolator &#123;</div><div class="line">    float getInterpolation(float input);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 TimeInterpolator 的代码里，它只有一个函数 float getInterpolation(float input)。</p><ul><li>参数 input：input 是 Float 类型的，它的取值范围是 0 ~ 1，表示当前动画的进度。取 0 时表示动画刚开始，取 1 时表示动画结束，取 0.5 时表示动画中间的位置，其他以此类推。它是时间概念。</li><li>返回值：表示当前实际想要显示的进度。取值可以超过 ，也可以小于 0。超过 1 表示已经超过目标值，小于 0 表示小于开始位置。</li></ul><p>而 AccelerateDecelerateInterpolator 返回的显示进度值为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f;</div></pre></td></tr></table></figure></p><p>input 是从 0 到 1，即cos(π) 到 cos(2π) 的结果值是从 -1 到 1。最终返回结果还是从 0 到 1，但是由于 Math.cos() 导致速率变化了，先加速后减速。</p><h4 id="2、自定义插值器示例"><a href="#2、自定义插值器示例" class="headerlink" title="2、自定义插值器示例"></a>2、自定义插值器示例</h4><p>想要先减速后加速的效果，可以重写 getInterpolation 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">float x = (-1 + input * 2.0f) / 4f; // -0.25 ~ 0.25</div><div class="line">float y = (float) Math.tan(x * Math.PI);</div><div class="line">return y / 2f + 0.5f;</div></pre></td></tr></table></figure></p><p>由于 tan 函数曲线变化不明显，导致加速减速效果也不明显，趋向于匀速。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class DecelerateAccelerateInterpolator implements TimeInterpolator &#123;</div><div class="line">    public DecelerateAccelerateInterpolator() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @SuppressWarnings(&#123;&quot;UnusedDeclaration&quot;&#125;)</div><div class="line">    public DecelerateAccelerateInterpolator(Context context, AttributeSet attrs) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public float getInterpolation(float input) &#123;</div><div class="line">        float x = (-1 + input * 2.0f) / 4f; // -0.25 ~ 0.25</div><div class="line">        float y = (float) Math.tan(x * Math.PI);</div><div class="line">        return y / 2f + 0.5f;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">animator.setInterpolator(new DecelerateAccelerateInterpolator());</div></pre></td></tr></table></figure></p><p><div id="jump2"></div></p><h3 id="3-2-2-Evaluator"><a href="#3-2-2-Evaluator" class="headerlink" title="3.2.2 Evaluator"></a>3.2.2 Evaluator</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p><img src="https://upload-images.jianshu.io/upload_images/9125154-ce9829a138c8d3c5.png?imageMogr2/auto-orient/strip|imageView2/2/w/949/format/webp" alt=""></p><p>上图所述的 4 个步骤的具体含义是：<br>1）ofInt（0，400）：表示指定动画的数值区间，从 0 运动到 400。<br>2）插值器：在动画开始后通过插值器会返回当前动画进度所对应的数值进度，这个数值进度是以小数表示的，如 0.2。<br>3）Evaluator：我们通过监听器拿到的是当前动画所对应的具体数值，而不是用小数表示的数值。那么必须有一个地方会根据当前的数值进度将其转换为对应的数值，这个地方就是 Evaluator。Evaluator 用于将从插值器返回的数值进度（小数，0 - 1.0）转换成对应的数值。<br>4）监听器返回：在 AnimatorUpdateListener 监听器中使用 animation.getAnimatedValue() 函数拿到 Evaluator 中返回的数值。</p><h4 id="2-各种-Evaluator"><a href="#2-各种-Evaluator" class="headerlink" title="2. 各种 Evaluator"></a>2. 各种 Evaluator</h4><p>插值器返回的小数值表示的是当前动画的数值进度，这对于无论是使用 ofFloat() 函数还是使用 ofInt() 函数定义的动画都是适用的。因为无论是什么动画，它的进度必然在 0～1 之间。0 表示还没开始，1 表示动画结束，这对于任何动画都是适用的。</p><p>而 Evaluator 则不一样，它把插值器返回的小数进度转换成当前数值进度所对应的值。如果使用 ofInt() 函数来定义动画，动画中的值应该都是 Integer 类型的，所对应的 Evaluator 在返回值时，必然返回 Integer 类型的值；如果使用 ofFloat() 函数来定义动画，动画中的值都是 Float 类型的，Evaluator 在返回值时，必然返回 Float 类型的值。</p><p>所以，每种定义方式所对应的 Evaluator 必然是它专用的。Evaluator 专用的原因在于动画数值类型不一样，在通过 Evaluator 返回时会报强转错误，所以只有在动画数值类型一样时，所对应的 Evaluator 才能通用。ofInt() 函数对应的 Evaluator 类名为 IntEvaluator，而 ofFloat() 函数对应的 Evaluator 类名为 FloatEvaluator。</p><p>通过 animator.setEvaluator() 函数来设置 Evaluator，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">private void startAnimationArgbEvaluator() &#123;</div><div class="line">    ValueAnimator animator = ValueAnimator.ofInt(0xffffff00, 0xff0000ff);</div><div class="line">    // 设置 Evaluator</div><div class="line">    animator.setEvaluator(new ArgbEvaluator());</div><div class="line">    animator.setDuration(3000);</div><div class="line"></div><div class="line">    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">            int curValue = (Integer) animation.getAnimatedValue();</div><div class="line">            tv_text.setBackgroundColor(curValue);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    animator.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ofInt() 函数的默认 Evaluator 是 IntEvaluator，而 ofFloat() 函数的默认 Evaluator 则是 FloatEvaluator。</p><p>可以继续看下 IntEvaluator 的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class IntEvaluator implements TypeEvaluator&lt;Integer&gt; &#123;</div><div class="line">    public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123;</div><div class="line">        int startInt = startValue;</div><div class="line">        // 当前的值 = 100 + (400 - 100) * 显示进度</div><div class="line">        return (int)(startInt + fraction * (endValue - startInt));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 IntEvaluator 中只有一个函数 evaluate(float fraction, Integer startValue, Integer endValue)：</p><ul><li>fraction 参数就是插值器中的返回值，表示当前动画的数值进度，以百分制的小数表示。</li><li>startValue 和 endValue 分别对应 ofInt(int start，int end) 函数中 start 和 end 的数值。假设当我们定义的动画 ofInt(100，400) 进行到数值进度 20% 的时候，那么此时在 evaluate() 函数中，fraction 的值就是 0.2，startValue 的值是 100，endValue 的值是 400。</li><li>返回值就是当前数值进度所对应的具体数值，这个数值就是我们在 AnimatorUpdateListener 监听器中通过 animation.getAnimatedValue() 函数得到的数值。</li></ul><p>总之：既可以通过重写插值器改变数值进度来改变数值位置，也可以通过改变 Evaluator 中数值进度所对应的具体数值来改变数值位置。</p><h4 id="3-简单实现-Evaluator"><a href="#3-简单实现-Evaluator" class="headerlink" title="3. 简单实现 Evaluator"></a>3. 简单实现 Evaluator</h4><p>自定义 MyEvaluator，并设定一个位移量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class MyEvaluator implements TypeEvaluator&lt;Integer&gt; &#123;</div><div class="line">    private int offset;</div><div class="line">    public MyEvaluator(int offset) &#123;</div><div class="line">        this.offset = offset;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123;</div><div class="line">        int startInt = startValue;</div><div class="line">        return (int) (startInt + (endValue - startInt) * fraction + offset);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">mView = findViewById(R.id.tv);</div><div class="line">ValueAnimator animator = ValueAnimator.ofInt(0, 400);</div><div class="line">animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">    @Override</div><div class="line">    public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">        int curValue = (Integer) animation.getAnimatedValue();</div><div class="line">        mView.layout(curValue, curValue,</div><div class="line">                curValue + mView.getWidth(),</div><div class="line">                curValue + mView.getHeight());</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">animator.setDuration(1000);</div><div class="line">animator.setEvaluator(new MyEvaluator(200));</div><div class="line">animator.start();</div></pre></td></tr></table></figure></p><h4 id="4-自定义-Evaluator-实现倒序输出"><a href="#4-自定义-Evaluator-实现倒序输出" class="headerlink" title="4. 自定义 Evaluator 实现倒序输出"></a>4. 自定义 Evaluator 实现倒序输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class ReverseEvaluator implements TypeEvaluator&lt;Integer&gt; &#123;</div><div class="line">    private boolean isReverse = true;</div><div class="line">    public MyEvaluator() &#123;</div><div class="line">    &#125;</div><div class="line">    public MyEvaluator(boolean isReverse) &#123;</div><div class="line">        this.isReverse = isReverse;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123;</div><div class="line">        int startInt = startValue;</div><div class="line">        if (isReverse) &#123;</div><div class="line">            return (int) (endValue - (endValue - startInt) * fraction);</div><div class="line">        &#125; else &#123;</div><div class="line">            return (int) (startInt + (endValue - startInt) * fraction);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="5-ArgbEvaluator"><a href="#5-ArgbEvaluator" class="headerlink" title="5. ArgbEvaluator"></a>5. ArgbEvaluator</h4><p>除 IntEvaluator 和 FloatEvaluator 外，在 android.animation 包下还有另一个 Evaluator，名为 ArgbEvaluator，它是用来实现颜色值过渡转换的。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2e9430c61cdc0015.gif?imageMogr2/auto-orient/strip" alt=""></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void startAnim(View v) &#123;</div><div class="line">    ValueAnimator animator = ValueAnimator.ofInt(0xFFFFFF00, 0xFF0000FF);</div><div class="line">    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">            int curValue = (Integer) animation.getAnimatedValue();</div><div class="line">            mView.setBackgroundColor(curValue);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    animator.setDuration(3000);</div><div class="line">    animator.setEvaluator(new ArgbEvaluator());</div><div class="line">    animator.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>实现原理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public class ArgbEvaluator implements TypeEvaluator &#123;</div><div class="line">    public Object evaluate(float fraction, Object startValue, Object endValue) &#123;</div><div class="line">        int startInt = (Integer) startValue;</div><div class="line">        float startA = ((startInt &gt;&gt; 24) &amp; 0xff) / 255.0f;</div><div class="line">        float startR = ((startInt &gt;&gt; 16) &amp; 0xff) / 255.0f;</div><div class="line">        float startG = ((startInt &gt;&gt;  8) &amp; 0xff) / 255.0f;</div><div class="line">        float startB = ( startInt        &amp; 0xff) / 255.0f;</div><div class="line"></div><div class="line">        int endInt = (Integer) endValue;</div><div class="line">        float endA = ((endInt &gt;&gt; 24) &amp; 0xff) / 255.0f;</div><div class="line">        float endR = ((endInt &gt;&gt; 16) &amp; 0xff) / 255.0f;</div><div class="line">        float endG = ((endInt &gt;&gt;  8) &amp; 0xff) / 255.0f;</div><div class="line">        float endB = ( endInt        &amp; 0xff) / 255.0f;</div><div class="line"></div><div class="line">        // convert from sRGB to linear</div><div class="line">        startR = (float) Math.pow(startR, 2.2);</div><div class="line">        startG = (float) Math.pow(startG, 2.2);</div><div class="line">        startB = (float) Math.pow(startB, 2.2);</div><div class="line"></div><div class="line">        endR = (float) Math.pow(endR, 2.2);</div><div class="line">        endG = (float) Math.pow(endG, 2.2);</div><div class="line">        endB = (float) Math.pow(endB, 2.2);</div><div class="line"></div><div class="line">        // compute the interpolated color in linear space</div><div class="line">        float a = startA + fraction * (endA - startA);</div><div class="line">        float r = startR + fraction * (endR - startR);</div><div class="line">        float g = startG + fraction * (endG - startG);</div><div class="line">        float b = startB + fraction * (endB - startB);</div><div class="line"></div><div class="line">        // convert back to sRGB in the [0..255] range</div><div class="line">        a = a * 255.0f;</div><div class="line">        r = (float) Math.pow(r, 1.0 / 2.2) * 255.0f;</div><div class="line">        g = (float) Math.pow(g, 1.0 / 2.2) * 255.0f;</div><div class="line">        b = (float) Math.pow(b, 1.0 / 2.2) * 255.0f;</div><div class="line"></div><div class="line">        return Math.round(a) &lt;&lt; 24 | Math.round(r) &lt;&lt; 16 </div><div class="line">             | Math.round(g) &lt;&lt; 8 | Math.round(b);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-6ecca4c57e372129.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03.1 精通自定义 View 之属性动画——ValueAnimator 的基本使用</title>
      <link href="/2019/07/03/05%20CUSTOM%20VIEW/03.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ValueAnimator%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/07/03/05%20CUSTOM%20VIEW/03.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ValueAnimator%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c9f76de4d1fc67a2.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="3-1-1-概述"><a href="#3-1-1-概述" class="headerlink" title="3.1.1 概述"></a>3.1.1 概述</h3><pre>Animation：    · View Animation（视图动画，API Level 1）        · Tween Animation（补间动画）        · Frame Animation（逐帧动画）    · Property Animation（属性动画，API Level 11）        · ValueAnimator        · ObjectAnimator</pre><p>视图动画仅能对指定的控件做动画，而属性动画是通过改变控件的某一属性值来做动画的。视图动画还有一个缺陷，就是只能点击原始区域才能响应事件。</p><p><div id="jump2"></div></p><h3 id="3-1-2-ValueAnimator-的简单使用"><a href="#3-1-2-ValueAnimator-的简单使用" class="headerlink" title="3.1.2 ValueAnimator 的简单使用"></a>3.1.2 ValueAnimator 的简单使用</h3><p>ValueAnimator 不会对控件执行任何操作，我们可以给它设定从哪个值运动到哪个值，通过监听这些值的渐变过程来使自己操作控件。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-17e5c9ef09ea60ec.gif?imageMogr2/auto-orient/strip" alt=""></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private TextView mView;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        mView = findViewById(R.id.tv);</div><div class="line">        findViewById(R.id.start_btn).setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                doAnimation();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        mView.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                Toast.makeText(MainActivity.this, &quot;你逮到我了&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void doAnimation() &#123;</div><div class="line">        final int left, top;</div><div class="line">        left = mView.getLeft();</div><div class="line">        top = mView.getTop();</div><div class="line"></div><div class="line">        ValueAnimator animator = ValueAnimator.ofInt(0, 400, 200);</div><div class="line">        animator.setDuration(2000);</div><div class="line">        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">                int curValue = (Integer) animation.getAnimatedValue();</div><div class="line">                mView.layout(curValue + left, curValue + top,</div><div class="line">                        curValue + left + mView.getWidth(),</div><div class="line">                        curValue + top + mView.getHeight());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        animator.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>ValueAnimator 只负责对指定值区间进行动画运算，我们需要对运算过程进行监听，然后自己对控件执行动画操作；动画结束后，控件仍然可以响应单击事件。</p></blockquote><p><div id="jump3"></div></p><h3 id="3-1-3-常用函数"><a href="#3-1-3-常用函数" class="headerlink" title="3.1.3 常用函数"></a>3.1.3 常用函数</h3><h4 id="1-ofInt-与-ofFloat"><a href="#1-ofInt-与-ofFloat" class="headerlink" title="1. ofInt 与 ofFloat"></a>1. ofInt 与 ofFloat</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ValueAnimator ofInt(int... values)</div><div class="line">public static ValueAnimator ofFloat(float... values)</div></pre></td></tr></table></figure><p>参数类型都是可变长参数，如上例中的 ofInt(0, 400, 200) 就表示从数字 0 变化到数字 400 再变化到 200。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public Object getAnimatedValue()</div></pre></td></tr></table></figure></p><p>上例中可以强转为 Integer 是因为使用的是 ofInt 方法设定动画初始值。当使用 ofFloat 函数设定初始值后，则需要强转为 Float 类型。后面介绍的 ofObject 函数也是如此。</p><h4 id="2-常用函数"><a href="#2-常用函数" class="headerlink" title="2. 常用函数"></a>2. 常用函数</h4><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">ValueAnimator setDuration(long duration)</td><td style="text-align:left">设置动画时长，单位是毫秒</td></tr><tr><td style="text-align:left">Object getAnimatedValue()</td><td style="text-align:left">获取 ValueAnimator 在运动时当前运动点的值</td></tr><tr><td style="text-align:left">void start()</td><td style="text-align:left">开始动画</td></tr><tr><td style="text-align:left">void cancel()</td><td style="text-align:left">取消动画</td></tr><tr><td style="text-align:left">void setRepeatCount(int value)</td><td style="text-align:left">循环次数，ValueAnimator.INFINITE 表示无线循环</td></tr><tr><td style="text-align:left">void setRepeatMode(int value)</td><td style="text-align:left">循环模式：ValueAnimator.RESTART、REVERSE</td></tr><tr><td style="text-align:left">void setStartDelay(long startDelay)</td><td style="text-align:left">延时多久开始，毫秒</td></tr><tr><td style="text-align:left">ValueAnimator clone()</td><td style="text-align:left">完全克隆一个 ValueAnimator 示例，包括所有设置和对监听器代码的处理。</td></tr></tbody></table></div><h4 id="3-监听器"><a href="#3-监听器" class="headerlink" title="3. 监听器"></a>3. 监听器</h4><p>1）添加监听器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 监听器一：监听动画过程中值的实时变化</div><div class="line">animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">    @Override</div><div class="line">    public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">        // doSomething</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 监听器二：监听动画变化时的 4 个状态</div><div class="line">animator.addListener(new Animator.AnimatorListener() &#123;</div><div class="line">    @Override</div><div class="line">    public void onAnimationStart(Animator animation) &#123;&#125;</div><div class="line">    @Override</div><div class="line">    public void onAnimationEnd(Animator animation) &#123;&#125;</div><div class="line">    @Override</div><div class="line">    public void onAnimationCancel(Animator animation) &#123;&#125;</div><div class="line">    @Override</div><div class="line">    public void onAnimationRepeat(Animator animation) &#123;&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>2）移除监听器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 移除 AnimatorUpdateListener</div><div class="line">void removeUpdateListener(AnimatorUpdateListener listener);</div><div class="line">void removeAllUpdateListeners();</div><div class="line"></div><div class="line">// 移除 AnimatorListener</div><div class="line">void removeListener(AnimatorListener listener);</div><div class="line">void removeAllListeners();</div></pre></td></tr></table></figure></p><p><div id="jump4"></div></p><h3 id="3-1-4-示例：弹跳加载中效果"><a href="#3-1-4-示例：弹跳加载中效果" class="headerlink" title="3.1.4 示例：弹跳加载中效果"></a>3.1.4 示例：弹跳加载中效果</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b02f17acf6a8f20a.gif?imageMogr2/auto-orient/strip" alt=""></p><p>自定义 LoadingImageView.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">public class LoadingImageView extends AppCompatImageView &#123;</div><div class="line"></div><div class="line">    private int mTop;</div><div class="line">    // 当前动画图片索引</div><div class="line">    private int mCurImgIndex = 0;</div><div class="line">    // 动画图片总张数</div><div class="line">    private static int mImgCount = 3;</div><div class="line"></div><div class="line">    public LoadingImageView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        ValueAnimator animator = ValueAnimator.ofInt(0, 200, 0);</div><div class="line">        animator.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">        animator.setRepeatMode(ValueAnimator.RESTART);</div><div class="line">        animator.setDuration(2000);</div><div class="line">        animator.setInterpolator(new AccelerateDecelerateInterpolator());</div><div class="line">        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">                int dx = (Integer) animation.getAnimatedValue();</div><div class="line">                setTop(mTop - dx);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        animator.addListener(new Animator.AnimatorListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationStart(Animator animation) &#123;</div><div class="line">                setImageDrawable(getResources().getDrawable(R.drawable.pic_1));</div><div class="line">            &#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationEnd(Animator animation) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationCancel(Animator animation) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationRepeat(Animator animation) &#123;</div><div class="line">                mCurImgIndex++;</div><div class="line">                switch (mCurImgIndex % mImgCount) &#123;</div><div class="line">                    case 0:</div><div class="line">                        setImageDrawable(ResourcesCompat.getDrawable(</div><div class="line">                                getResources(), R.drawable.pic_1, null));</div><div class="line">                        break;</div><div class="line">                    case 1:</div><div class="line">                        setImageDrawable(ResourcesCompat.getDrawable(</div><div class="line">                                getResources(), R.drawable.pic_2, null));</div><div class="line">                        break;</div><div class="line">                    case 2:</div><div class="line">                        setImageDrawable(ResourcesCompat.getDrawable(</div><div class="line">                                getResources(), R.drawable.pic_3, null));</div><div class="line">                        break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        animator.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onLayout(boolean changed, int left,int top,int right,int bottom) &#123;</div><div class="line">        super.onLayout(changed, left, top, right, bottom);</div><div class="line">        mTop = top;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>act_main.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:layout_gravity=&quot;center_horizontal&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line">    &lt;com.xxt.xtest.LoadingImageView</div><div class="line">        android:layout_width=&quot;50dp&quot;</div><div class="line">        android:layout_height=&quot;50dp&quot;</div><div class="line">        android:layout_marginTop=&quot;100dp&quot;</div><div class="line">        android:layout_gravity=&quot;center_horizontal&quot;</div><div class="line">        android:src=&quot;@drawable/pic_1&quot;/&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_gravity=&quot;center_horizontal&quot;</div><div class="line">        android:layout_marginTop=&quot;10dp&quot;</div><div class="line">        android:gravity=&quot;center&quot;</div><div class="line">        android:text=&quot;加载中...&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-dfda5df6e6971006.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02.5 精通自定义 View 之视图动画——逐帧动画</title>
      <link href="/2019/07/02/05%20CUSTOM%20VIEW/02.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E9%80%90%E5%B8%A7%E5%8A%A8%E7%94%BB/"/>
      <url>/2019/07/02/05%20CUSTOM%20VIEW/02.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E9%80%90%E5%B8%A7%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-50e5c1ae6f18c867.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="2-5-1-XML-实现"><a href="#2-5-1-XML-实现" class="headerlink" title="2.5.1 XML 实现"></a>2.5.1 XML 实现</h3><p>新建一个动画 XML 文件，在文件中使用 &lt;animation-list&gt; 标签来定义动画帧序列，使用 &lt;item&gt; 标签来定义动画的每一帧，并在其中指定帧的持续时间等属性。</p><h4 id="1）定义-XML-动画文件"><a href="#1）定义-XML-动画文件" class="headerlink" title="1）定义 XML 动画文件"></a>1）定义 XML 动画文件</h4><p>res/drawable/playing_anim.xml 或 res/anim/playing_anim.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:oneshot=&quot;false&quot;&gt;</div><div class="line">    &lt;item android:drawable=&quot;@mipmap/img00&quot; android:duration=&quot;120&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@mipmap/img01&quot; android:duration=&quot;120&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@mipmap/img02&quot; android:duration=&quot;120&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@mipmap/img03&quot; android:duration=&quot;120&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@mipmap/img04&quot; android:duration=&quot;120&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@mipmap/img05&quot; android:duration=&quot;120&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@mipmap/img06&quot; android:duration=&quot;120&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@mipmap/img07&quot; android:duration=&quot;120&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@mipmap/img08&quot; android:duration=&quot;120&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@mipmap/img10&quot; android:duration=&quot;120&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@mipmap/img11&quot; android:duration=&quot;120&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@mipmap/img12&quot; android:duration=&quot;120&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@mipmap/img13&quot; android:duration=&quot;120&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@mipmap/img14&quot; android:duration=&quot;120&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@mipmap/img15&quot; android:duration=&quot;120&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@mipmap/img16&quot; android:duration=&quot;120&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@mipmap/img17&quot; android:duration=&quot;120&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@mipmap/img18&quot; android:duration=&quot;120&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@mipmap/img19&quot; android:duration=&quot;120&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@mipmap/img20&quot; android:duration=&quot;120&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@mipmap/img21&quot; android:duration=&quot;120&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@mipmap/img22&quot; android:duration=&quot;120&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@mipmap/img23&quot; android:duration=&quot;120&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@mipmap/img24&quot; android:duration=&quot;120&quot; /&gt;</div><div class="line">&lt;/animation-list&gt;</div></pre></td></tr></table></figure></p><blockquote><p>oneshot 用来控制动画是否循环播放，如果取值为 true，表示动画不会循环播放，否则动画会循环播放；duration 用来指定每一帧的持续播放时间。</p></blockquote><h4 id="2）设置-ImageView"><a href="#2）设置-ImageView" class="headerlink" title="2）设置 ImageView"></a>2）设置 ImageView</h4><p>设置动画资源有两种方式：android:src、android:background。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;ImageView</div><div class="line">    android:id=&quot;@+id/frame_image&quot;</div><div class="line">    android:layout_width=&quot;wrap_content&quot;</div><div class="line">    android:layout_height=&quot;wrap_content&quot;</div><div class="line">    android:src=&quot;@drawable/playing_anim&quot;/&gt;</div></pre></td></tr></table></figure></p><h4 id="3）AnimationDrawable-开始动画"><a href="#3）AnimationDrawable-开始动画" class="headerlink" title="3）AnimationDrawable 开始动画"></a>3）AnimationDrawable 开始动画</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ImageView image = findViewById(R.id.frame_image);</div><div class="line">AnimationDrawable anim = (AnimationDrawable) image.getDrawable();</div><div class="line">anim.start();</div></pre></td></tr></table></figure><blockquote><p>注意：<br>android:src 对应 image.getDrawable()；<br>android:background 对应 image.getBackground();</p></blockquote><p><div id="jump2"></div></p><h3 id="2-5-2-代码实现"><a href="#2-5-2-代码实现" class="headerlink" title="2.5.2 代码实现"></a>2.5.2 代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">AnimationDrawable animationDrawable = new AnimationDrawable();</div><div class="line">int id = 0;</div><div class="line">for (int i = 0; i &lt; 24; i++) &#123;</div><div class="line">    if (i &lt; 10) &#123;</div><div class="line">        id = getResources().getIdentifier(&quot;img0&quot; + i, &quot;mipmap&quot;, getPackageName());</div><div class="line">    &#125; else  &#123;</div><div class="line">        id = getResources().getIdentifier(&quot;img&quot; + i, &quot;mipmap&quot;, getPackageName());</div><div class="line">    &#125;</div><div class="line">    Drawable drawable = getResources().getDrawable(id);</div><div class="line">    animationDrawable.addFrame(drawable, 120);</div><div class="line">&#125;</div><div class="line">image.setImageDrawable(animationDrawable);</div><div class="line">animationDrawable.setOneShot(false);</div><div class="line">animationDrawable.start();</div></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/6770217-058c430641bcb12d.gif?imageMogr2/auto-orient/strip|imageView2/2/w/360/format/webp" alt=""></p><blockquote><p>帧动画使用比较简单，但是容易引起 OOM，在使用帧动画时应该尽量避免使用过多尺寸较大的图片。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e8c744e62623472c.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02.4 精通自定义 View 之视图动画——动画示例</title>
      <link href="/2019/07/02/05%20CUSTOM%20VIEW/02.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E5%8A%A8%E7%94%BB%E7%A4%BA%E4%BE%8B/"/>
      <url>/2019/07/02/05%20CUSTOM%20VIEW/02.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E5%8A%A8%E7%94%BB%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-fc83dc54a4de316d.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="2-4-1-镜头由远及近效果"><a href="#2-4-1-镜头由远及近效果" class="headerlink" title="2.4.1 镜头由远及近效果"></a>2.4.1 镜头由远及近效果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        ScaleAnimation scaleAnim = new ScaleAnimation(1.0f, 3f, 1.0f, 3f,</div><div class="line">                Animation.RELATIVE_TO_SELF, 0.4f,</div><div class="line">                Animation.RELATIVE_TO_PARENT, 0.8f);</div><div class="line">        scaleAnim.setDuration(6000);</div><div class="line">        scaleAnim.setFillAfter(true);</div><div class="line">        scaleAnim.setInterpolator(new BounceInterpolator());</div><div class="line">        findViewById(R.id.image).startAnimation(scaleAnim);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>act_main.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/image&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        android:scaleType=&quot;fitXY&quot;</div><div class="line">        android:src=&quot;@drawable/meinv&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b65cc033055b387b.gif?imageMogr2/auto-orient/strip" alt=""></p><p><div id="jump2"></div></p><h3 id="2-4-2-加载框效果"><a href="#2-4-2-加载框效果" class="headerlink" title="2.4.2 加载框效果"></a>2.4.2 加载框效果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        RotateAnimation rotateAnim = new RotateAnimation(0, 360,</div><div class="line">                Animation.RELATIVE_TO_SELF, 0.5f, </div><div class="line">                Animation.RELATIVE_TO_SELF, 0.5f);</div><div class="line">        rotateAnim.setRepeatCount(Animation.INFINITE);</div><div class="line">        rotateAnim.setDuration(2000);</div><div class="line">        rotateAnim.setInterpolator(new LinearInterpolator());</div><div class="line">        findViewById(R.id.loading).startAnimation(rotateAnim);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;RelativeLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/loading&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_centerHorizontal=&quot;true&quot;</div><div class="line">        android:layout_marginTop=&quot;50dp&quot;</div><div class="line">        android:src=&quot;@drawable/loading&quot;/&gt;</div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure><p>效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-97840b9e023e724a.gif?imageMogr2/auto-orient/strip" alt=""></p><p><div id="jump3"></div></p><h3 id="2-4-3-扫描动画"><a href="#2-4-3-扫描动画" class="headerlink" title="2.4.3 扫描动画"></a>2.4.3 扫描动画</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-dda8bf5509252728.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        final Animation anim1 = AnimationUtils.loadAnimation(MainActivity.this, R.anim.scale_alpha_anim);</div><div class="line">        final Animation anim2 = AnimationUtils.loadAnimation(MainActivity.this, R.anim.scale_alpha_anim);</div><div class="line">        final Animation anim3 = AnimationUtils.loadAnimation(MainActivity.this, R.anim.scale_alpha_anim);</div><div class="line">        final Animation anim4 = AnimationUtils.loadAnimation(MainActivity.this, R.anim.scale_alpha_anim);</div><div class="line"></div><div class="line">        findViewById(R.id.start_can).setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                findViewById(R.id.circle1).startAnimation(anim1);</div><div class="line">                anim2.setStartOffset(500);</div><div class="line">                findViewById(R.id.circle2).startAnimation(anim2);</div><div class="line">                anim3.setStartOffset(1000);</div><div class="line">                findViewById(R.id.circle3).startAnimation(anim3);</div><div class="line">                anim4.setStartOffset(1500);</div><div class="line">                findViewById(R.id.circle4).startAnimation(anim4);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>act_main.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;RelativeLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line">    &lt;View</div><div class="line">        android:id=&quot;@+id/circle1&quot;</div><div class="line">        android:layout_width=&quot;130dp&quot;</div><div class="line">        android:layout_height=&quot;130dp&quot;</div><div class="line">        android:layout_centerHorizontal=&quot;true&quot;</div><div class="line">        android:layout_marginTop=&quot;70dp&quot;</div><div class="line">        android:background=&quot;@drawable/scan_circle&quot;/&gt;</div><div class="line">    &lt;View</div><div class="line">        android:id=&quot;@+id/circle2&quot;</div><div class="line">        android:layout_width=&quot;130dp&quot;</div><div class="line">        android:layout_height=&quot;130dp&quot;</div><div class="line">        android:layout_centerHorizontal=&quot;true&quot;</div><div class="line">        android:layout_marginTop=&quot;70dp&quot;</div><div class="line">        android:background=&quot;@drawable/scan_circle&quot;/&gt;</div><div class="line">    &lt;View</div><div class="line">        android:id=&quot;@+id/circle3&quot;</div><div class="line">        android:layout_width=&quot;130dp&quot;</div><div class="line">        android:layout_height=&quot;130dp&quot;</div><div class="line">        android:layout_centerHorizontal=&quot;true&quot;</div><div class="line">        android:layout_marginTop=&quot;70dp&quot;</div><div class="line">        android:background=&quot;@drawable/scan_circle&quot;/&gt;</div><div class="line">    &lt;View</div><div class="line">        android:id=&quot;@+id/circle4&quot;</div><div class="line">        android:layout_width=&quot;130dp&quot;</div><div class="line">        android:layout_height=&quot;130dp&quot;</div><div class="line">        android:layout_centerHorizontal=&quot;true&quot;</div><div class="line">        android:layout_marginTop=&quot;70dp&quot;</div><div class="line">        android:background=&quot;@drawable/scan_circle&quot;/&gt;</div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/start_can&quot;</div><div class="line">        android:layout_width=&quot;130dp&quot;</div><div class="line">        android:layout_height=&quot;130dp&quot;</div><div class="line">        android:layout_centerHorizontal=&quot;true&quot;</div><div class="line">        android:layout_marginTop=&quot;70dp&quot;</div><div class="line">        android:src=&quot;@drawable/music&quot;/&gt;</div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure></p><p>scan_circle.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:shape=&quot;oval&quot;&gt;</div><div class="line">    &lt;solid android:color=&quot;#FF6C2F&quot;/&gt;</div><div class="line">&lt;/shape&gt;</div></pre></td></tr></table></figure></p><p>scale_alpha_anim.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:duration=&quot;2000&quot;&gt;</div><div class="line">    &lt;alpha</div><div class="line">        android:repeatCount=&quot;infinite&quot;</div><div class="line">        android:fromAlpha=&quot;0.4&quot;</div><div class="line">        android:toAlpha=&quot;0&quot;/&gt;</div><div class="line">    &lt;scale</div><div class="line">        android:repeatCount=&quot;infinite&quot;</div><div class="line">        android:fromXScale=&quot;1.0&quot;</div><div class="line">        android:fromYScale=&quot;1.0&quot;</div><div class="line">        android:toXScale=&quot;3&quot;</div><div class="line">        android:toYScale=&quot;3&quot;</div><div class="line">        android:pivotX=&quot;50%&quot;</div><div class="line">        android:pivotY=&quot;50%&quot; /&gt;</div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-691593b1a494f2a8.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02.3 精通自定义 View 之视图动画——插值器初探</title>
      <link href="/2019/07/02/05%20CUSTOM%20VIEW/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/"/>
      <url>/2019/07/02/05%20CUSTOM%20VIEW/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a41f9111d9da0d20.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump0"></div></p><h3 id="2-3-0-概述"><a href="#2-3-0-概述" class="headerlink" title="2.3.0 概述"></a>2.3.0 概述</h3><p>有关动画的变化速率的问题是由 Interpolator 类来决定的。Interpolator 叫插值器，也叫加速器，是用来指定动画如何变化的变量。它只是一个接口，通过实现这个接口就可以自定义动画的变化速率。系统提供了如下几个实现了插值器的类：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Interpolator class</th><th style="text-align:left">Resource ID</th></tr></thead><tbody><tr><td style="text-align:left">AccelerateDecelerateInterpolator</td><td style="text-align:left">@android:anim/accelerate_decelerate_interpolator</td></tr><tr><td style="text-align:left">AccelerateInterpolator</td><td style="text-align:left">@android:anim/accelerate_interpolator</td></tr><tr><td style="text-align:left">DecelerateInterpolator</td><td style="text-align:left">@android:anim/decelerate_interpolator</td></tr><tr><td style="text-align:left">LinearInterpolator</td><td style="text-align:left">@android:anim/linear_interpolator</td></tr><tr><td style="text-align:left">BounceInterpolator</td><td style="text-align:left">@android:anim/bounce_interpolator</td></tr><tr><td style="text-align:left">AnticipateInterpolator</td><td style="text-align:left">@android:anim/anticipate_interpolator</td></tr><tr><td style="text-align:left">OvershootInterpolator</td><td style="text-align:left">@android:anim/overshoot_interpolator</td></tr><tr><td style="text-align:left">AnticipateOvershootInterpolator</td><td style="text-align:left">@android:anim/anticipate_overshoot_interpolator</td></tr><tr><td style="text-align:left">CycleInterpolator</td><td style="text-align:left">@android:anim/cycle_interpolator</td></tr></tbody></table></div><p>关于插值器，有两种使用方法。</p><h4 id="方法一、XML-引用"><a href="#方法一、XML-引用" class="headerlink" title="方法一、XML 引用"></a>方法一、XML 引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:fromAlpha=&quot;1.0&quot;</div><div class="line">    android:toAlpha=&quot;0.1&quot;</div><div class="line">    android:duration=&quot;3000&quot;</div><div class="line">    android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;/&gt;</div></pre></td></tr></table></figure><h4 id="方法二、setInterpolator"><a href="#方法二、setInterpolator" class="headerlink" title="方法二、setInterpolator()"></a>方法二、setInterpolator()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">AlphaAnimation alphaAnim = new AlphaAnimation(1.0f, 0.1f);</div><div class="line">alphaAnim.setDuration(3000);</div><div class="line">alphaAnim.setInterpolator(new LinearInterpolator());</div></pre></td></tr></table></figure><p><div id="jump1"></div></p><h3 id="2-3-1-AccelerateDecelerateInterpolator"><a href="#2-3-1-AccelerateDecelerateInterpolator" class="headerlink" title="2.3.1 AccelerateDecelerateInterpolator"></a>2.3.1 AccelerateDecelerateInterpolator</h3><p>加速减速插值器，表示在开始与结束的地方速率改变比较慢，在中间的时候加速。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">TranslateAnimation alphaAnim = new TranslateAnimation(</div><div class="line">        Animation.RELATIVE_TO_SELF, 0, Animation.RELATIVE_TO_PARENT, 0.5f,</div><div class="line">        Animation.RELATIVE_TO_SELF, 0, Animation.RELATIVE_TO_PARENT, 0.5f);</div><div class="line">alphaAnim.setDuration(2000);</div><div class="line">alphaAnim.setFillAfter(true);</div><div class="line">alphaAnim.setInterpolator(new AccelerateDecelerateInterpolator());</div><div class="line">view.startAnimation(alphaAnim);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1a5e986db80513d8.gif?imageMogr2/auto-orient/strip" alt=""></p><p><div id="jump2"></div></p><h3 id="2-3-2-AccelerateInterpolator"><a href="#2-3-2-AccelerateInterpolator" class="headerlink" title="2.3.2 AccelerateInterpolator"></a>2.3.2 AccelerateInterpolator</h3><p>加速插值器，表示在动画开始的地方速率比较慢，然后开始加速。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alphaAnim.setInterpolator(new AccelerateInterpolator());</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-908e70cfe467c264.gif?imageMogr2/auto-orient/strip" alt=""></p><p><div id="jump3"></div></p><h3 id="2-3-3-DecelerateInterpolator"><a href="#2-3-3-DecelerateInterpolator" class="headerlink" title="2.3.3 DecelerateInterpolator"></a>2.3.3 DecelerateInterpolator</h3><p>减速插值器，表示在动画开始的一瞬间加速到最大值，然后逐渐变慢。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alphaAnim.setInterpolator(new DecelerateInterpolator());</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-6d0ff5568b75446f.gif?imageMogr2/auto-orient/strip" alt=""></p><p><div id="jump4"></div></p><h3 id="2-3-4-LinearInterpolator"><a href="#2-3-4-LinearInterpolator" class="headerlink" title="2.3.4 LinearInterpolator"></a>2.3.4 LinearInterpolator</h3><p>线性插值器，也称匀速插值器，显然，它的速率是保持恒定的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alphaAnim.setInterpolator(new LinearInterpolator());</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-377ec8feea0f4d15.gif?imageMogr2/auto-orient/strip" alt=""></p><p><div id="jump5"></div></p><h3 id="2-3-5-BounceInterpolator"><a href="#2-3-5-BounceInterpolator" class="headerlink" title="2.3.5 BounceInterpolator"></a>2.3.5 BounceInterpolator</h3><p>弹跳插值器，模拟了控件自由落地后回弹的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alphaAnim.setInterpolator(new BounceInterpolator());</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-41e10e83f1b030b5.gif?imageMogr2/auto-orient/strip" alt=""></p><p><div id="jump6"></div></p><h3 id="2-3-6-AnticipateInterpolator"><a href="#2-3-6-AnticipateInterpolator" class="headerlink" title="2.3.6 AnticipateInterpolator"></a>2.3.6 AnticipateInterpolator</h3><p>初始偏移插值器，表示在动画开始的时候向前偏移一段距离，然后应用动画。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public AnticipateInterpolator()</div><div class="line">public AnticipateInterpolator(float tension)</div></pre></td></tr></table></figure></p><p>参数 float tension 对应的 XML 属性为 android:tension，表示张力值，默认值为 2。值越大，初始的偏移量越大，而且速度越快。0 表示不偏移。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alphaAnim.setInterpolator(new AnticipateInterpolator(4));</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-238aad363372258f.gif?imageMogr2/auto-orient/strip" alt=""></p><p><div id="jump7"></div></p><h3 id="2-3-7-OvershootInterpolator"><a href="#2-3-7-OvershootInterpolator" class="headerlink" title="2.3.7 OvershootInterpolator"></a>2.3.7 OvershootInterpolator</h3><p>结束偏移插值器，表示在动画结束的时候沿动画方向继续运动一段距离后再结束动画。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public OvershootInterpolator()</div><div class="line">public OvershootInterpolator(float tension)</div></pre></td></tr></table></figure></p><p>参数 float tension 对应的 XML 属性为 android:tension，表示张力值，默认值为 2。值越大，结束时的偏移量越大。0 表示不偏移。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alphaAnim.setInterpolator(new OvershootInterpolator());</div></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f1c535299a35ee11.gif?imageMogr2/auto-orient/strip" alt=""></p><p><div id="jump8"></div></p><h3 id="2-3-8-AnticipateOvershootInterpolator"><a href="#2-3-8-AnticipateOvershootInterpolator" class="headerlink" title="2.3.8 AnticipateOvershootInterpolator"></a>2.3.8 AnticipateOvershootInterpolator</h3><p>是 AnticipateInterpolator 和 OvershootInterpolator 的合体，即在动画开始时向前偏移一段距离后，在动画结束的时候沿动画方向继续运动一段距离后再结束动画。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public AnticipateOvershootInterpolator()</div><div class="line">public AnticipateOvershootInterpolator(float tension)</div><div class="line">public AnticipateOvershootInterpolator(float tension, float extraTension)</div></pre></td></tr></table></figure></p><ul><li>参数 float tension 对应的 XML 属性为 android:tension，表示张力值，默认值为 2。值越大，初始和结束的偏移量越大。0 表示不偏移。</li><li>参数 float extraTension 对应的 XML 属性为 android:extraTension，表示额外张力值，默认值为 1.5。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alphaAnim.setInterpolator(new AnticipateOvershootInterpolator());</div></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c3efadfe7e3bb00a.gif?imageMogr2/auto-orient/strip" alt=""></p><p><div id="jump9"></div></p><h3 id="2-3-9-CycleInterpolator"><a href="#2-3-9-CycleInterpolator" class="headerlink" title="2.3.9 CycleInterpolator"></a>2.3.9 CycleInterpolator</h3><p>循环插值器，表示动画循环播放特定的次数，速率沿正弦曲线改变。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">TranslateAnimation alphaAnim = new TranslateAnimation(</div><div class="line">        Animation.RELATIVE_TO_SELF, 0, Animation.RELATIVE_TO_PARENT, 0.5f,</div><div class="line">        Animation.RELATIVE_TO_SELF, 0, Animation.RELATIVE_TO_PARENT, 0.5f);</div><div class="line">alphaAnim.setDuration(2000);</div><div class="line">alphaAnim.setFillAfter(true);</div><div class="line">alphaAnim.setInterpolator(new CycleInterpolator());</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-5eb085b89d61c217.gif?imageMogr2/auto-orient/strip" alt=""></p><blockquote><p>虽然设置了 setFillAfter(true)，但对于 CycleInterpolator 而言并没有什么影响，动画结束后，视图还原到初始位置。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b26f8ab4613ce8d9.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02.2 精通自定义 View 之视图动画——视图动画的代码实现</title>
      <link href="/2019/07/02/05%20CUSTOM%20VIEW/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/07/02/05%20CUSTOM%20VIEW/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a4599069ba2de917.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="2-2-1-概述"><a href="#2-2-1-概述" class="headerlink" title="2.2.1 概述"></a>2.2.1 概述</h3><p>使用 XML 来添加动画可以很大限度地提高代码复用性，但有时只需要临时使用一个动画，就没有必要单独写一个 XML 动画文件了，可以使用代码的方法生成一个动画操作。</p><div class="table-container"><table><thead><tr><th style="text-align:center">标签</th><th style="text-align:center">类</th></tr></thead><tbody><tr><td style="text-align:center">scale</td><td style="text-align:center">ScaleAnimation</td></tr><tr><td style="text-align:center">alpha</td><td style="text-align:center">AlphaAnimation</td></tr><tr><td style="text-align:center">rotate</td><td style="text-align:center">RotateAnimation</td></tr><tr><td style="text-align:center">translate</td><td style="text-align:center">TranslateAnimation</td></tr><tr><td style="text-align:center">set</td><td style="text-align:center">AnimationSet</td></tr></tbody></table></div><p>Animation 类中共用的属性方法：</p><div class="table-container"><table><thead><tr><th style="text-align:left">标签属性</th><th style="text-align:left">方 法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">android:duration</td><td style="text-align:left">setDuration(long)</td><td style="text-align:left">动画的运行时间 (以毫秒为单位)；必须设置</td></tr><tr><td style="text-align:left">android:fillAfter</td><td style="text-align:left">setFillAfter(boolean)</td><td style="text-align:left">动画结束时是否保持动画最后的状态；默认为 false，优先于 fillBefore。</td></tr><tr><td style="text-align:left">android:fillBefore</td><td style="text-align:left">setFillBefore(boolean)</td><td style="text-align:left">动画结束时是否还原到开始动画前的状态；默认为 true。</td></tr><tr><td style="text-align:left">android:fillEnabled</td><td style="text-align:left">setFillEnabled(boolean)</td><td style="text-align:left">是否应用 fillBefore 的值，对 fillAfter 无影响；默认为true。</td></tr><tr><td style="text-align:left">android:repeatCount</td><td style="text-align:left">setRepeatCount(int)</td><td style="text-align:left">重复次数，取值为整数或 Animation.INFINITE。</td></tr><tr><td style="text-align:left">android:repeatMode</td><td style="text-align:left">setRepeatMode(int)</td><td style="text-align:left">重复类型有两个值，reverse 表示倒序回放，restart 表示从头播放</td></tr><tr><td style="text-align:left">android:interpolator</td><td style="text-align:left">setInterpolator(Interpolator)</td><td style="text-align:left">设定插值器（指定的动画效果，譬如回弹等）</td></tr><tr><td style="text-align:left">android:detachWallpaper</td><td style="text-align:left">setDetachWallpaper(boolean)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">android:startOffset</td><td style="text-align:left">setStartOffset(long)</td><td style="text-align:left">调用 start 函数之后等待开始运行的时间，单位为毫秒</td></tr><tr><td style="text-align:left">android:zAdjustment</td><td style="text-align:left">setZAdjustment(int)</td><td style="text-align:left">表示被设置动画的内容运行时在 Z 轴上的位置（top / bottom / normal），默认为 normal。</td></tr></tbody></table></div><p><div id="jump2"></div></p><h3 id="2-2-2-ScaleAnimation"><a href="#2-2-2-ScaleAnimation" class="headerlink" title="2.2.2 ScaleAnimation"></a>2.2.2 ScaleAnimation</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ScaleAnimation(float fromX, float toX, float fromY, float toY)</div><div class="line">ScaleAnimation(float fromX, float toX, float fromY, float toY, </div><div class="line">               float pivotX, float pivotY)</div><div class="line">ScaleAnimation(float fromX, float toX, float fromY, float toY,</div><div class="line">               int pivotXType, float pivotXValue, </div><div class="line">               int pivotYType, float pivotYValue)</div></pre></td></tr></table></figure><blockquote><p>pivotXType 取值为：<br>Animation.ABSOLUTE、Animation.RELATIVE_TO_SELF、Animation.RELATIVE_TO_PARENT。</p></blockquote><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:fromXScale=&quot;0.0&quot;</div><div class="line">    android:toXScale=&quot;1.4&quot;</div><div class="line">    android:fromYScale=&quot;0.0&quot;</div><div class="line">    android:toYScale=&quot;1.4&quot;</div><div class="line">    android:pivotX=&quot;50%&quot;</div><div class="line">    android:pivotY=&quot;50%&quot;</div><div class="line">    android:duration=&quot;700&quot;/&gt;</div></pre></td></tr></table></figure></p><p>对应代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ScaleAnimation scaleAnim = new ScaleAnimation(0.0f, 1.4f, 0.0f, 1.4f,</div><div class="line">        Animation.RELATIVE_TO_SELF, 0.5f,</div><div class="line">        Animation.RELATIVE_TO_SELF, 0.5f);</div><div class="line">scaleAnim.setDuration(700);</div><div class="line">tv.startAnimation(scaleAnim);</div></pre></td></tr></table></figure></p><p><div id="jump3"></div></p><h3 id="2-2-3-AlphaAnimation"><a href="#2-2-3-AlphaAnimation" class="headerlink" title="2.2.3 AlphaAnimation"></a>2.2.3 AlphaAnimation</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AlphaAnimation(float fromAlpha, float toAlpha)</div></pre></td></tr></table></figure><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:fromAlpha=&quot;1.0&quot;</div><div class="line">    android:toAlpha=&quot;0.1&quot;</div><div class="line">    android:fillBefore=&quot;true&quot;</div><div class="line">    android:duration=&quot;3000&quot;/&gt;</div></pre></td></tr></table></figure></p><p>对应代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">AlphaAnimation alphaAnim = new AlphaAnimation(1.0f, 0.1f);</div><div class="line">alphaAnim.setDuration(3000);</div><div class="line">alphaAnim.setFillBefore(true);</div></pre></td></tr></table></figure></p><p><div id="jump4"></div></p><h3 id="2-2-4-RotateAnimation"><a href="#2-2-4-RotateAnimation" class="headerlink" title="2.2.4 RotateAnimation"></a>2.2.4 RotateAnimation</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RotateAnimation(float fromDegrees, float toDegrees)</div><div class="line">RotateAnimation(float fromDegrees, float toDegrees, float pivotX, float pivotY)</div><div class="line">RotateAnimation(float fromDegrees, float toDegrees, </div><div class="line">                int pivotXType, float pivotXValue, </div><div class="line">                int pivotYType, float pivotYValue)</div></pre></td></tr></table></figure><blockquote><p>pivotXType 取值为：<br>Animation.ABSOLUTE、Animation.RELATIVE_TO_SELF、Animation.RELATIVE_TO_PARENT</p></blockquote><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:fromDegrees=&quot;0&quot;</div><div class="line">    android:toDegrees=&quot;-650&quot;</div><div class="line">    android:pivotX=&quot;50%&quot;</div><div class="line">    android:pivotY=&quot;50%&quot;</div><div class="line">    android:duration=&quot;3000&quot;</div><div class="line">    android:fillAfter=&quot;true&quot;/&gt;</div></pre></td></tr></table></figure></p><p>对应代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RotateAnimation alphaAnim = new RotateAnimation(0, -650, </div><div class="line">                Animation.RELATIVE_TO_SELF, 0.5f, </div><div class="line">                Animation.RELATIVE_TO_SELF, 0.5f);</div><div class="line">alphaAnim.setDuration(3000);</div><div class="line">alphaAnim.setFillAfter(true);</div></pre></td></tr></table></figure></p><p><div id="jump5"></div></p><h3 id="2-2-5-TranslateAnimation"><a href="#2-2-5-TranslateAnimation" class="headerlink" title="2.2.5 TranslateAnimation"></a>2.2.5 TranslateAnimation</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">TranslateAnimation(float fromXDelta,  float toXDelta, </div><div class="line">                   float fromYDelta, float toYDelta)</div><div class="line">TranslateAnimation(int fromXType, float fromXValue, </div><div class="line">                   int toXType, float toXValue,</div><div class="line">                   int fromYType, float fromYValue, </div><div class="line">                   int toYType, float toYValue)</div></pre></td></tr></table></figure><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:fromXDelta=&quot;0&quot;</div><div class="line">    android:toXDelta=&quot;-80&quot;</div><div class="line">    android:fromYDelta=&quot;0&quot;</div><div class="line">    android:toYDelta=&quot;-80&quot;</div><div class="line">    android:duration=&quot;2000&quot;</div><div class="line">    android:fillBefore=&quot;true&quot;/&gt;</div></pre></td></tr></table></figure></p><p>对应代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">TranslateAnimation alphaAnim = new TranslateAnimation(</div><div class="line">        Animation.ABSOLUTE, 0, Animation.ABSOLUTE, -80, </div><div class="line">        Animation.ABSOLUTE, 0, Animation.ABSOLUTE, -80);</div><div class="line">alphaAnim.setDuration(2000);</div><div class="line">alphaAnim.setFillBefore(true);</div></pre></td></tr></table></figure></p><p><div id="jump6"></div></p><h3 id="2-2-6-AnimationSet"><a href="#2-2-6-AnimationSet" class="headerlink" title="2.2.6 AnimationSet"></a>2.2.6 AnimationSet</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AnimationSet(boolean shareInterpolator)</div></pre></td></tr></table></figure><p>shareInterpolator 参数取值为 true 时，用于 AnimationSet 类中定义一个插值器，其下面的所有动画共用该插值器；取值为 false，则表示其下面的动画定义各自的插值器。增加动画的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void addAnimation(Animation a)</div></pre></td></tr></table></figure></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:duration=&quot;2000&quot;</div><div class="line">    android:fillAfter=&quot;true&quot;&gt;</div><div class="line">    &lt;alpha</div><div class="line">        android:fromAlpha=&quot;0.0&quot;</div><div class="line">        android:toAlpha=&quot;1.0&quot;/&gt;</div><div class="line">    &lt;scale</div><div class="line">        android:fromXScale=&quot;0.0&quot;</div><div class="line">        android:toXScale=&quot;1.4&quot;</div><div class="line">        android:fromYScale=&quot;0.0&quot;</div><div class="line">        android:toYScale=&quot;1.4&quot;</div><div class="line">        android:pivotX=&quot;50%&quot;</div><div class="line">        android:pivotY=&quot;50%&quot; /&gt;</div><div class="line">    &lt;rotate</div><div class="line">        android:fromDegrees=&quot;0&quot;</div><div class="line">        android:toDegrees=&quot;720&quot;</div><div class="line">        android:pivotX=&quot;50%&quot;</div><div class="line">        android:pivotY=&quot;50%&quot;/&gt;</div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure></p><p>对应代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Animation alphaAnim = new AlphaAnimation(0, 1.0f);</div><div class="line">Animation scaleAnim = new ScaleAnimation(0, 1.4f, 0, 1.4f,</div><div class="line">        Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);</div><div class="line">Animation rotateAnim = new RotateAnimation(0, 720, Animation.RELATIVE_TO_SELF, </div><div class="line">        0.5f, Animation.RELATIVE_TO_SELF, 0.5f);</div><div class="line"></div><div class="line">AnimationSet setAnim = new AnimationSet(true);</div><div class="line">setAnim.addAnimation(alphaAnim);</div><div class="line">setAnim.addAnimation(scaleAnim);</div><div class="line">setAnim.addAnimation(rotateAnim);</div><div class="line"></div><div class="line">setAnim.setDuration(3000);</div><div class="line">setAnim.setFillAfter(true);</div><div class="line"></div><div class="line">view.startAnimation(setAnim);</div></pre></td></tr></table></figure></p><p><div id="jump7"></div></p><h3 id="2-2-7-Animation"><a href="#2-2-7-Animation" class="headerlink" title="2.2.7 Animation"></a>2.2.7 Animation</h3><p>Animation 还有一些比较实用的方法介绍，如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">cancel()</td><td style="text-align:left">取消动画</td></tr><tr><td style="text-align:left">reset()</td><td style="text-align:left">将控件重置到动画开始前状态</td></tr><tr><td style="text-align:left">hasStarted()</td><td style="text-align:left">判断当前 Animation 是否开始</td></tr><tr><td style="text-align:left">hasEnded()</td><td style="text-align:left">判断当前 Animation 是否结束</td></tr><tr><td style="text-align:left">setAnimationListener()</td><td style="text-align:left">设置动画监听</td></tr></tbody></table></div><p>Animation.AnimationListener：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static interface AnimationListener &#123;</div><div class="line">    // 动画开始时调用</div><div class="line">    void onAnimationStart(Animation animation);</div><div class="line">    // 动画结束时调用</div><div class="line">    void onAnimationEnd(Animation animation);</div><div class="line">    // 动画重复时调用</div><div class="line">    void onAnimationRepeat(Animation animation);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">final RotateAnimation rotateAnim = new RotateAnimation(0, 720, </div><div class="line">        Animation.RELATIVE_TO_SELF, 0.5f,</div><div class="line">        Animation.RELATIVE_TO_SELF, 0.5f);</div><div class="line">rotateAnim.setDuration(2000);</div><div class="line">rotateAnim.setFillAfter(true);</div><div class="line"></div><div class="line">ScaleAnimation scaleAnim = new ScaleAnimation(0, 1.4f, 0, 1.4f,</div><div class="line">        Animation.RELATIVE_TO_SELF, 0.5f, </div><div class="line">        Animation.RELATIVE_TO_SELF, 0.5f);</div><div class="line">scaleAnim.setDuration(700);</div><div class="line">scaleAnim.setAnimationListener(new Animation.AnimationListener() &#123;</div><div class="line">    @Override</div><div class="line">    public void onAnimationStart(Animation animation) &#123;&#125;</div><div class="line">    @Override</div><div class="line">    public void onAnimationEnd(Animation animation) &#123;</div><div class="line">        view.startAnimation(rotateAnim);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void onAnimationRepeat(Animation animation) &#123; &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">view.startAnimation(scaleAnim);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1f482e16cf4cbca6.gif?imageMogr2/auto-orient/strip" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-8d53c1e4a56cc157.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02.1 精通自定义 View 之视图动画——视图动画标签</title>
      <link href="/2019/07/02/05%20CUSTOM%20VIEW/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/"/>
      <url>/2019/07/02/05%20CUSTOM%20VIEW/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a383e170026f212f.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><pre>Animation：    · View Animation（视图动画，API Level 1）        · Tween Animation（补间动画）        · Frame Animation（逐帧动画）    · Property Animation（属性动画，API Level 11）        · ValueAnimator        · ObjectAnimator</pre><p><div id="jump1"></div></p><h3 id="2-1-1-概述"><a href="#2-1-1-概述" class="headerlink" title="2.1.1 概述"></a>2.1.1 概述</h3><p>视图动画分为 5 种类型组成：<br>scale：渐变透明度动画效果<br>alpha：渐变尺寸伸缩动画效果<br>rotate：画面转移旋转动画效果<br>translate：画面变化位置移动动画效果<br>set：定义动画集</p><h4 id="1-配置-XML-动画文件"><a href="#1-配置-XML-动画文件" class="headerlink" title="1. 配置 XML 动画文件"></a>1. 配置 XML 动画文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&gt;</div><div class="line">&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:fromXScale=&quot;0.0&quot;</div><div class="line">    android:toXScale=&quot;1.4&quot;</div><div class="line">    android:fromYScale=&quot;0.0&quot;</div><div class="line">    android:toYScale=&quot;1.4&quot;</div><div class="line">    android:duration=&quot;700&quot;</div></pre></td></tr></table></figure><h4 id="2-动画文件存放位置"><a href="#2-动画文件存放位置" class="headerlink" title="2. 动画文件存放位置"></a>2. 动画文件存放位置</h4><p>存放在 res/anim 文件夹下，访问时使用 R.anim.XXX。<br>存放在 res/drawable 文件夹下，访问时使用 R.drawable.XXX。</p><h4 id="3-使用动画文件"><a href="#3-使用动画文件" class="headerlink" title="3. 使用动画文件"></a>3. 使用动画文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">View view = findViewById(R.id.view);</div><div class="line">Animation animation = AnimationUtils.loadAnimation(this, R.anim.scale_anim);</div><div class="line">view.startAnimation(animation);</div></pre></td></tr></table></figure><p><div id="jump2"></div></p><h3 id="2-1-2-scale-标签"><a href="#2-1-2-scale-标签" class="headerlink" title="2.1.2 scale 标签"></a>2.1.2 scale 标签</h3><p>scale 标签用于缩放动画，可以实现动态调整控件尺寸的效果：</p><ul><li>android:fromXScale：动画开始时，控件在 X 轴方向上相对自身的缩放比例，浮点值。1.0 代表自身无变化，0.5 表示缩小一倍，2.0 代表放大一倍。</li><li>android:toXScale：动画结束时，控件在 X 轴方向上相对自身的缩放比例，浮点值。</li><li>android:fromYScale：动画开始时，控件在 Y 轴方向上相对自身的缩放比例，浮点值。</li><li>android:toYScale：动画结束时，控件在 Y 轴方向上相对自身的缩放比例，浮点值。</li><li>android:pivotX：缩放起始点 X 轴坐标。是数值如 50，则表示在当前控件的左上角原点 X 轴坐标 + 50px，作为缩放起始点 X 轴坐标；是百分数如 50%，则表示在当前控件的左上角原点 X 轴坐标 + 自身宽度的 50%，作为缩放起始点 X 轴坐标；是百分数 p 如 50%p，则表示在当前控件的左上角原点 X 轴坐标 + 父控件宽度的 50%，作为缩放起始点 X 轴坐标；</li><li>android:pivotY：缩放起始点 Y 轴坐标。取值同上。</li></ul><p>示例：<br>缩放动画 scale1.xml：android:pivotX=”50”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:fromXScale=&quot;0.0&quot;</div><div class="line">    android:toXScale=&quot;1.0&quot;</div><div class="line">    android:fromYScale=&quot;0.0&quot;</div><div class="line">    android:toYScale=&quot;1.0&quot;</div><div class="line">    android:pivotX=&quot;50&quot;</div><div class="line">    android:duration=&quot;700&quot;/&gt;</div></pre></td></tr></table></figure></p><p>缩放动画 scale2.xml：android:pivotX=”50%”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:fromXScale=&quot;0.0&quot;</div><div class="line">    android:toXScale=&quot;1.0&quot;</div><div class="line">    android:fromYScale=&quot;0.0&quot;</div><div class="line">    android:toYScale=&quot;1.0&quot;</div><div class="line">    android:pivotX=&quot;50%&quot;</div><div class="line">    android:duration=&quot;700&quot;/&gt;</div></pre></td></tr></table></figure></p><p>缩放动画 scale3.xml：android:pivotX=”50%”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:fromXScale=&quot;0.0&quot;</div><div class="line">    android:toXScale=&quot;1.0&quot;</div><div class="line">    android:fromYScale=&quot;0.0&quot;</div><div class="line">    android:toYScale=&quot;1.0&quot;</div><div class="line">    android:pivotX=&quot;50%p&quot;</div><div class="line">    android:duration=&quot;700&quot;/&gt;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7756d7b6da97fa09.gif?imageMogr2/auto-orient/strip" alt=""></p><p><div id="jump3"></div></p><h3 id="2-1-3-Animation-继承属性"><a href="#2-1-3-Animation-继承属性" class="headerlink" title="2.1.3 Animation 继承属性"></a>2.1.3 Animation 继承属性</h3><p>所有的动画都继承自 Animation 类，它的内部实现了一些共用的动画属性：</p><ul><li>android:duration：一次动画的持续时间，单位毫秒。</li><li>android:fillAfter：为 true 表示控件动画结束时，将保持动画结束时的状态。</li><li>android:fillBefore：为 true 表示控件动画结束时，将还原到初始化状态。默认为 true。</li><li>android:fillEnabled：同 fillBefore。</li><li>android:repeatCount：指定动画的重复次数，取值为 infinite 时，表示无限循环。</li><li>android:repeatMode：设定重复的类型，有 reverse（倒序回放） 和 restart（重放） 两个值。与 repeatCount 一起使用才有效果。</li><li>android:interpolator：设定插值器，指定动画效果，比如弹跳效果。</li></ul><p><div id="jump4"></div></p><h3 id="2-1-4-alpha-标签"><a href="#2-1-4-alpha-标签" class="headerlink" title="2.1.4 alpha 标签"></a>2.1.4 alpha 标签</h3><p>alpha 标签用于实现渐变透明度动画效果。除从 Animation 类继承而来的属性外，自身所具有的属性如下：</p><ul><li>android:fromAlpha：动画开始的透明度，取值范围 0.0 ~ 1.0，0.0 表示完全透明，1.0 表示完全不透明。</li><li>android:toAlpha：动画结束的透明度，取值范围 0.0 ~ 1.0，0.0 表示完全透明，1.0 表示完全不透明。</li></ul><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:fromAlpha=&quot;1.0&quot;</div><div class="line">    android:toAlpha=&quot;0.5&quot;</div><div class="line">    android:repeatMode=&quot;reverse&quot;</div><div class="line">    android:repeatCount=&quot;infinite&quot;</div><div class="line">    android:duration=&quot;700&quot;/&gt;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-584dead53190f9d3.gif?imageMogr2/auto-orient/strip" alt=""></p><p><div id="jump5"></div></p><h3 id="2-1-5-rotate-标签"><a href="#2-1-5-rotate-标签" class="headerlink" title="2.1.5 rotate 标签"></a>2.1.5 rotate 标签</h3><p>rotate 标签用于实现画面转移旋转动画效果。除从 Animation 类继承而来的属性外，自身所具有的属性如下：</p><ul><li>android:fromDegrees：动画开始旋转时的角度位置，正值代表顺时针方向的度数，负值代表逆时针方向的度数。</li><li>android:toDegrees：动画结束时旋转到的角度位置，正值代表顺时针方向的度数，负值代表逆时针方向的度数。</li><li>android:pivotX：旋转中心点 X 轴坐标，默认旋转中心点为控件的坐标原点（左上角），可以是数值、百分数、百分数p 三种样式。</li><li>android:pivotY：旋转中心点 Y 轴坐标，同上。</li></ul><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:fromDegrees=&quot;0&quot;</div><div class="line">    android:toDegrees=&quot;180&quot;</div><div class="line">    android:pivotX=&quot;50%&quot;</div><div class="line">    android:pivotY=&quot;50%&quot;</div><div class="line">    android:repeatMode=&quot;restart&quot;</div><div class="line">    android:repeatCount=&quot;infinite&quot;</div><div class="line">    android:duration=&quot;700&quot;/&gt;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-dba6e63da35e2b0a.gif?imageMogr2/auto-orient/strip" alt=""></p><p><div id="jump6"></div></p><h3 id="2-1-6-translate-标签"><a href="#2-1-6-translate-标签" class="headerlink" title="2.1.6 translate 标签"></a>2.1.6 translate 标签</h3><p>translate 标签用于实现画面转移旋转动画效果。除从 Animation 类继承而来的属性外，自身所具有的属性如下：</p><ul><li>android:fromXDelta：起始点 X 轴坐标，可以是数值、百分数、百分数p。</li><li>android:fromYDelta：起始点 Y 轴坐标，同上。</li><li>android:toXDelta：终点 X 轴坐标。</li><li>android:toYDelta：终点 Y 轴坐标。</li></ul><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:fromXDelta=&quot;0&quot;</div><div class="line">    android:fromYDelta=&quot;0&quot;</div><div class="line">    android:toXDelta=&quot;-50%&quot;</div><div class="line">    android:toYDelta=&quot;-50%&quot;</div><div class="line">    android:duration=&quot;1500&quot;/&gt;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a869cc5df2429999.gif?imageMogr2/auto-orient/strip" alt=""></p><p><div id="jump7"></div></p><h3 id="2-1-7-set-标签"><a href="#2-1-7-set-标签" class="headerlink" title="2.1.7 set 标签"></a>2.1.7 set 标签</h3><p>set 标签是一个容器类标签，用于定义动画集。前面的 4 个标签只能完成特定的功能，而 set 标签则可以把这些动画效果组合起来，共同完成一个动画。set 标签自身没有属性，它的属性都是从 Animation 类继承而来的。当这些属性用于 set 标签时，就会对 set 标签下的所有子控件产生作用。但 repeateCount 属性是无效的，必须对每个动画单独设置才有作用。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:duration=&quot;2000&quot;</div><div class="line">    android:fillAfter=&quot;true&quot;&gt;</div><div class="line">    &lt;alpha</div><div class="line">        android:fromAlpha=&quot;0.0&quot;</div><div class="line">        android:toAlpha=&quot;1.0&quot;/&gt;</div><div class="line">    &lt;scale</div><div class="line">        android:fromXScale=&quot;0.0&quot;</div><div class="line">        android:toXScale=&quot;1.4&quot;</div><div class="line">        android:fromYScale=&quot;0.0&quot;</div><div class="line">        android:toYScale=&quot;1.4&quot;</div><div class="line">        android:pivotX=&quot;50%&quot;</div><div class="line">        android:pivotY=&quot;50%&quot; /&gt;</div><div class="line">    &lt;rotate</div><div class="line">        android:fromDegrees=&quot;0&quot;</div><div class="line">        android:toDegrees=&quot;720&quot;</div><div class="line">        android:pivotX=&quot;50%&quot;</div><div class="line">        android:pivotY=&quot;50%&quot;/&gt;</div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-bf4c19f3e714f6c4.gif?imageMogr2/auto-orient/strip" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c7f550282cb2b488.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01.6 精通自定义 View 之绘图基础——控件的使用方法</title>
      <link href="/2019/07/01/05%20CUSTOM%20VIEW/01.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2019/07/01/05%20CUSTOM%20VIEW/01.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-090024ac6b0ad281.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="1-6-1-控件概述"><a href="#1-6-1-控件概述" class="headerlink" title="1.6.1 控件概述"></a>1.6.1 控件概述</h3><p>在自定义一个派生自 View 或 ViewGroup 类的控件时，必须实现一个构造函数。有三个构造函数供我们选择。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class CustomView extends View &#123;</div><div class="line">    public CustomView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line">    public CustomView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line">    public CustomView(Context context, AttributeSet attrs, int defStyle) &#123; </div><div class="line">        super(context, attrs, defStyle);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其实每种构造函数都是在特定的使用情景下所必须实现的，否则将会报 inflate 错误。</p><p><div id="jump2"></div></p><h3 id="1-6-2-通过-XML-引入控件"><a href="#1-6-2-通过-XML-引入控件" class="headerlink" title="1.6.2 通过 XML 引入控件"></a>1.6.2 通过 XML 引入控件</h3><p>使用以下方式引入控件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout ...&gt;</div><div class="line">    &lt;com.xxt.xtest.CustomView ... /&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>就必须实现第二个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public CustomView(Context context, AttributeSet attrs) &#123;</div><div class="line">    super(context, attrs);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><div id="jump3"></div></p><h3 id="1-6-3-动态添加控件"><a href="#1-6-3-动态添加控件" class="headerlink" title="1.6.3 动态添加控件"></a>1.6.3 动态添加控件</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">LinearLayout rootView = (LinearLayout)findViewById(R.id.root);</div><div class="line">CustomView customView = new CustomView(this);</div><div class="line">LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams (</div><div class="line">                LinearLayout.LayoutParams.MATCH_PARENT, </div><div class="line">                LinearLayout.LayoutParams.MATCH_PARENT);</div><div class="line">rootView.addView(customView,layoutParams);</div></pre></td></tr></table></figure></p><h4 id="2-LayoutParams"><a href="#2-LayoutParams" class="headerlink" title="2. LayoutParams"></a>2. LayoutParams</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 第一个构造函数常用</div><div class="line">public LayoutParams(int width, int height)</div><div class="line">// 用于从 AttributeSet 中取出 layout_width、 layout_height 等各属性的值</div><div class="line">public LayoutParams(Context c, AttributeSet attrs)</div><div class="line">public LayoutParams(LayoutParams source)</div></pre></td></tr></table></figure><p>每个容器类控件都会实现一套 LayoutParams 类，而子类则用的是父容器的 LayoutParams 类。比如上述中父容器是 LinearLayout，所以使用 LinearLayout.LayoutParams。之所以不能共用，是因为各个容器所对应的布局属性是不一样的。</p><p>在 RelativeLayout 中，实现添加到 TextView 控件的右侧：addRule()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">RelativeLayout rootView = (RelativeLayout) findViewById(R.id.root); </div><div class="line">CustomView customView = new CustomView(this);</div><div class="line">RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(</div><div class="line">                RelativeLayout.LayoutParams.MATCH_PARENT, </div><div class="line">                RelativeLayout.LayoutParams.MATCH_ PARENT);</div><div class="line">layoutParams.addRule(RelativeLayout.RIGHT_OF,R.id.text); </div><div class="line">rootView.addView(customView, layoutParams);</div></pre></td></tr></table></figure></p><p>1）设置 margin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(</div><div class="line">                LinearLayout. LayoutParams.WRAP_CONTENT, </div><div class="line">                LinearLayout.LayoutParams.WRAP_CONTENT);</div><div class="line">lp.setMargins(10, 20, 30, 40);</div><div class="line">imageView.setLayoutParams(lp);</div></pre></td></tr></table></figure></p><p>2）设置 layout_weight (方法一)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">TextView tv_like = new TextView(this);</div><div class="line">LinearLayout.LayoutParams LP_LIKE_MW = new LinearLayout.LayoutParams (</div><div class="line">                LinearLayout.LayoutParams.MATCH_PARENT, </div><div class="line">                LinearLayout.LayoutParams.WRAP_ CONTENT, </div><div class="line">                1.0f);</div><div class="line">tv_like.setText(&quot;赞(8)&quot;); </div><div class="line">tv_like.setTextSize(16); </div><div class="line">layout_sub_Lin.addView(tv_like, LP_LIKE_MW);</div></pre></td></tr></table></figure></p><p>3）设置 layout_weight (方法二)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(</div><div class="line">                LinearLayout.LayoutParams.MATCH_PARENT,</div><div class="line">                LinearLayout.LayoutParams.MATCH_ PARENT);</div><div class="line">layoutParams.weight = 1.0f;</div><div class="line">rootView.addView(customView, layoutParams);</div></pre></td></tr></table></figure></p><p>4）设置 layout_gravity<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(</div><div class="line">                LinearLayout.LayoutParams.MATCH_PARENT,</div><div class="line">                LinearLayout.LayoutParams.MATCH_ PARENT);</div><div class="line">params.gravity = Gravity.TOP;</div><div class="line">Button button = new Button(this);</div><div class="line">rootView.addView(button, layoutParams);</div></pre></td></tr></table></figure></p><p>5）设置 android:gravity<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">RelativeLayout rootView = (RelativeLayout) findViewById(R.id.root);</div><div class="line">RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(</div><div class="line">                RelativeLayout.LayoutParams.WRAP_CONTENT,</div><div class="line">                200);</div><div class="line">layoutParams.addRule(RelativeLayout.RIGHT_OF, R.id.text);</div><div class="line"></div><div class="line">Button button = new Button(this); </div><div class="line">button.setGravity(Gravity.TOP);</div><div class="line">button.setText(&quot;btn&quot;);</div><div class="line">rootView.addView(button, layoutParams); </div><div class="line">rootView.setGravity(Gravity.TOP | Gravity.CENTER_HORIZONTAL);</div></pre></td></tr></table></figure></p><h4 id="3-addView"><a href="#3-addView" class="headerlink" title="3. addView"></a>3. addView</h4><p>动态添加控件都是通过 addView 来实现的，addView 是 ViewGroup 类中的一个函数，它有 5 个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 在节点末尾添加一个 View 控件，布局使用默认布局</div><div class="line">// layout_width = wrap_content、layout_height = wrap_content</div><div class="line">public void addView(View child)</div><div class="line"></div><div class="line">// 在指定位置添加一个 View 控件，index 的取值有-1、0 和正数。</div><div class="line">// -1：表示在末尾添加一个 View 控件</div><div class="line">// 0：表示在容器顶端添加一个 View 控件</div><div class="line">// 正数：表示在对应的索引位置插入一个 View 控件</div><div class="line">public void addView(View child, int index)</div><div class="line"></div><div class="line">// 使用自定义自定义布局参数，在节点末尾添加一个 View 控件</div><div class="line">public void addView(View child, LayoutParams params)</div><div class="line"></div><div class="line">// 使用自定义自定义布局参数，在指定位置添加一个 View 控件</div><div class="line">public void addView(View child, int index, LayoutParams params)</div><div class="line"></div><div class="line">// 只指定宽和高</div><div class="line">public void addView(View child, int width, int height)</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a3c09f1b30310d08.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01.5 精通自定义 View 之绘图基础——Canvas</title>
      <link href="/2019/07/01/05%20CUSTOM%20VIEW/01.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Canvas/"/>
      <url>/2019/07/01/05%20CUSTOM%20VIEW/01.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Canvas/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a5808b54741c6d38.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="1-5-1-Canvas-变换"><a href="#1-5-1-Canvas-变换" class="headerlink" title="1.5.1 Canvas 变换"></a>1.5.1 Canvas 变换</h3><h4 id="1-平移-Translate"><a href="#1-平移-Translate" class="headerlink" title="1. 平移 (Translate)"></a>1. 平移 (Translate)</h4><p>画布的原始状态是以左上角为原点，向右是 X 轴正方向，向下是 Y 轴正方向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void translate(float dx, float dy)</div></pre></td></tr></table></figure></p><p>参数:<br>float dx：水平方向平移的距离，正数为向正方向 (向右) 平移的量，负数为向负方向 (向左) 平移的量。<br>float dy：垂直方向平移的距离，正数为向正方向 (向下) 平移的量，负数为向负方向 (向上) 平移的量。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">paintGreen = generatePaint(Color.GREEN, Paint.Style.STROKE, 3);</div><div class="line">paintRed = generatePaint(Color.RED, Paint.Style.STROKE, 3);</div><div class="line">rect = new Rect(20,20,400,220);</div><div class="line"></div><div class="line">canvas.drawRect(rect, paintGreen);</div><div class="line">// 画布平移</div><div class="line">canvas.translate(100, 100);</div><div class="line">canvas.drawRect(rect, paintRed);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0c93c2d9c06d16a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>上述示例中，调用 canvas.translate(100, 100) 后，绿色矩形区域并没有随着画布移动。这是由于屏幕显示与 Canvas 根本不是一个概念！</p></blockquote><h4 id="2-屏幕显示与-Canvas-的关系"><a href="#2-屏幕显示与-Canvas-的关系" class="headerlink" title="2. 屏幕显示与 Canvas 的关系"></a>2. 屏幕显示与 Canvas 的关系</h4><p>Canvas 是一个很虚幻的概念，相当于一个透明图层。每次在 Canvas 上画图时 (调用 drawXXX 系列函数)，都会先产生一个透明图层，然后在这个图层上画图，画完之后覆盖在屏幕上显示。所以，上述结果是经以下几个步骤形成的：<br>(1) 在调用 canvas.drawRect(rect1, paint_green) 时，产生一个 Canvas 透明图层，由于当时还没有对坐标系进行平移，所以坐标原点是 (0,0)；在 Canvas 上画好之后，覆盖到屏幕上显示出来。过程如下图所示。<br><img src="https://upload-images.jianshu.io/upload_images/14186083-c891c073af2f3bd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>(2) 在调用 canvas.drawRect(rect1, paint_red) 时，又会产生一个全新的 Canvas 透明图层，但此时画布坐标已经改变了，即分别向右和向下移动了 100 像素，所以此时的绘图方式如下图所示 (合成视图，从上往下看的合成方式)。<br><img src="https://upload-images.jianshu.io/upload_images/14186083-21c34d62a6ad5d70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>总结：</p><ul><li>当每次调用 drawXXX 系列函数来绘图时，都会产生一个全新的 Canvas 透明图层。</li><li>如果在调用 drawXXX 系列函数前，调用平移、旋转等函数对 Canvas 进行了操作，那么这个操作是不可逆的。每次产生的画布的最新位置都是这些操作后的位置。</li><li>在 Canvas 图层与屏幕合成时，超出屏幕范围的图像是不会显示出来的。</li></ul><h4 id="3-旋转-Rotate"><a href="#3-旋转-Rotate" class="headerlink" title="3. 旋转 (Rotate)"></a>3. 旋转 (Rotate)</h4><p>画布的旋转默认是围绕坐标原点来进行的。这里容易产生错觉，看起来是图片旋转了，其实我们旋转的是画布，以后在此画布上绘制的图形显示出来的时候看起来都是旋转的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void rotate(float degrees)</div><div class="line">void rotate(float degrees, float px, float py)</div></pre></td></tr></table></figure></p><p>参数：</p><ul><li>float degrees：旋转的度数，正数指顺时针旋转。旋转中心点是 (0,0)。</li><li>float px, py：指定旋转的中心点坐标 (px,py)。</li></ul><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">    super(context, attrs);</div><div class="line">    mPaint = new Paint();</div><div class="line">    mPaint.setColor(Color.BLUE);</div><div class="line">    mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">    mRect = new RectF(300,50,500,150);</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    canvas.drawRect(mRect, mPaint);</div><div class="line">    mPaint.setColor(Color.RED);</div><div class="line">    mPaint.setStyle(Paint.Style.FILL);</div><div class="line">    canvas.rotate(30);</div><div class="line">    canvas.drawRect(mRect, mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b8a43538eb565d32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="旋转"></p><p>旋转原理：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-0763f5275574be3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第一次合成：canvas.drawRect(mRect, mPaint)"></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7605273e69198649.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="4-缩放-Scale"><a href="#4-缩放-Scale" class="headerlink" title="4. 缩放 (Scale)"></a>4. 缩放 (Scale)</h4><p>变更坐标轴密度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void scale(float sx, float sy)</div></pre></td></tr></table></figure></p><p>参数:<br>float sx：水平方向伸缩的比例。小数表示缩小，整数表示放大。<br>float sy：垂直方向伸缩的比例。小数表示缩小，整数表示放大。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mPaintBlue = generatePaint(Color.BLUE, Paint.Style.STROKE, 5);</div><div class="line">mPaintRed = generatePaint(Color.RED, Paint.Style.STROKE, 5);</div><div class="line">mRect = new RectF(100,50,500,150);</div><div class="line"></div><div class="line">canvas.drawRect(mRect, mPaintBlue);</div><div class="line">canvas.scale(0.5f, 1);</div><div class="line">canvas.drawRect(mRect, mPaintRed);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b57178b81b5327a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>蓝框是原坐标轴密度图形，红框是 X 轴密度缩小到 0.5 倍之后显示的图形。</p><h4 id="5-扭曲-Skew"><a href="#5-扭曲-Skew" class="headerlink" title="5. 扭曲 (Skew)"></a>5. 扭曲 (Skew)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void skew(float sx, float sy)</div></pre></td></tr></table></figure><p>参数：<br>float sx：将画布在 X 轴方向上倾斜相应的角度，sx 为倾斜角度的正切值。<br>float sy：将画布在 Y 轴方向上倾斜相应的角度，sy 为倾斜角度的正切值。</p><blockquote><p>注意：这里都是倾斜角度的正切值。比如，在 X 轴方向上倾斜 60°，tan60=1.732。</p></blockquote><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mRect = new RectF(100,100,300,300);</div><div class="line"></div><div class="line">canvas.drawRect(mRect, mPaintBlue);</div><div class="line">canvas.skew(0.5f, 0.5f);</div><div class="line">canvas.drawRect(mRect, mPaintRed);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-946974bf21dd5cb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="6-裁剪画布-clip-系列函数"><a href="#6-裁剪画布-clip-系列函数" class="headerlink" title="6. 裁剪画布 (clip 系列函数)"></a>6. 裁剪画布 (clip 系列函数)</h4><p>裁剪画布是指利用 clip 系列函数，通过与 Rect、Path、Region 取交、并、差等集合运算来获得最新的画布形状。除调用 save()、restore() 函数以外，这个操作是不可逆的，一旦 Canvas 被裁剪，就不能恢复。</p><blockquote><p>在使用裁剪画布系列函数时，需要禁用硬件加速功能。<br>setLayerType(LAYER_TYPE_SOFTWARE, null);</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">boolean clipPath(Path path)</div><div class="line">boolean clipPath(Path path, Region.Op op)</div><div class="line"></div><div class="line">boolean clipRect(RectF rect)</div><div class="line">boolean clipRect(Rect rect)</div><div class="line">boolean clipRect(Rect rect, Region.Op op)</div><div class="line">boolean clipRect(RectF rect, Region.Op op)</div><div class="line">boolean clipRect(int left, int top, int right, int bottom)</div><div class="line">boolean clipRect(float left, float top, float right, float bottom)</div><div class="line">boolean clipRect(float left, float top, float right, float bottom, </div><div class="line">                 Region.Op op) </div><div class="line"></div><div class="line">boolean clipRegion(Region region)</div><div class="line">boolean clipRegion(Region region, Region.Op op)</div></pre></td></tr></table></figure><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">canvas.drawColor(Color.RED);</div><div class="line">canvas.clipRect(new Rect(100, 100, 200, 200));</div><div class="line">canvas.drawColor(Color.GREEN);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-289bb5e9e5ff331a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>先把背景色涂成红色，显示在屏幕上，然后裁剪画布，最后将最新的画布涂成绿色。可见，绿色部分只有一小块，而不再是整个屏幕。</p><p><div id="jump2"></div></p><h3 id="1-5-2-画布的保存与恢复"><a href="#1-5-2-画布的保存与恢复" class="headerlink" title="1.5.2 画布的保存与恢复"></a>1.5.2 画布的保存与恢复</h3><h4 id="1-save-和-restore-函数"><a href="#1-save-和-restore-函数" class="headerlink" title="1. save() 和 restore() 函数"></a>1. save() 和 restore() 函数</h4><p>前面介绍的所有对画布的操作都是不可逆的，如果要对画布的大小和状态 (旋转角度、扭曲等) 进行实时保存和恢复，需要借助 save() 和 restore() 这两个函数。</p><p>save()：每次调用，都会先保存当前画布的状态，然后将其放入特定的栈中。<br>restore()：每次调用，都会把栈中顶层的画布状态取出来，并按照这个状态恢复当前的画布，然后在这个画布上作画。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">canvas.drawColor(Color.RED);</div><div class="line">// 保存当前画布大小，即整屏 </div><div class="line">canvas.save();</div><div class="line">canvas.clipRect(new Rect(100, 100, 800, 800));</div><div class="line">canvas.drawColor(Color.GREEN);</div><div class="line">// 恢复整屏画布 </div><div class="line">canvas.restore();</div><div class="line">canvas.drawColor(Color.BLUE);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-55913d706eaf3164.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="2-restoreToCount-int-saveCount-函数"><a href="#2-restoreToCount-int-saveCount-函数" class="headerlink" title="2. restoreToCount(int saveCount) 函数"></a>2. restoreToCount(int saveCount) 函数</h4><p>我们可以多次调用 save() 函数，但每次调用 restore() 函数，只会将顶层的画布状态出栈。有时可能只需要用到特定的画布，这就需要多次 出栈。为了解决这个问题，Google 提供了另一个出栈函数 restoreToCount(int saveCount)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public int save();</div></pre></td></tr></table></figure></p><p>在利用 save() 函数保存画布时，会有一个 int 类型的返回值。该返回值是当前所保存的画布所在栈的索引。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void restoreToCount(int saveCount);</div></pre></td></tr></table></figure></p><p>而 restoreToCount() 函数的用法就是一直出栈，直到指定索引的画布出栈为止，即将指定索引的画布作为当前画布。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line">    canvas.drawColor(Color.RED); </div><div class="line">    // 保存的画布大小为全屏幕大小</div><div class="line">    int c1 = canvas.save();</div><div class="line">    canvas.clipRect(new Rect(100, 100, 800, 800));</div><div class="line">    canvas.drawColor(Color.GREEN); </div><div class="line">    // 保存的画布大小为Rect(100, 100, 800, 800)</div><div class="line">    int c2 = canvas.save();</div><div class="line"></div><div class="line">    canvas.clipRect(new Rect(200, 200, 700, 700));</div><div class="line">    canvas.drawColor(Color.BLUE); </div><div class="line">    // 保存的画布大小为Rect(200, 200, 700, 700)</div><div class="line">    int c3 = canvas.save();</div><div class="line"></div><div class="line">    canvas.clipRect(new Rect(300, 300, 600, 600));</div><div class="line">    canvas.drawColor(Color.BLACK); </div><div class="line">    // 保存的画布大小为Rect(300, 300, 600, 600)</div><div class="line">    int c4 = canvas.save();</div><div class="line"></div><div class="line">    canvas.clipRect(new Rect(400, 400, 500, 500));</div><div class="line">    canvas.drawColor(Color.WHITE);</div><div class="line"></div><div class="line">    // 连续三次出栈，将最后一次出栈的画布状态</div><div class="line">    // 作为当前画布，并填充为黄色 </div><div class="line">    // canvas.restore();</div><div class="line">    // canvas.restore();</div><div class="line">    // canvas.restore();</div><div class="line">    canvas.restoreToCount(c2); </div><div class="line">    canvas.drawColor(Color.YELLOW);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><div id="jump3"></div></p><h3 id="1-5-3-示例一-圆形头像"><a href="#1-5-3-示例一-圆形头像" class="headerlink" title="1.5.3 示例一:圆形头像"></a>1.5.3 示例一:圆形头像</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e72dba62b99c9ddf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line">    private Bitmap mBmp;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        // 禁用硬件加速</div><div class="line">        // setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPath = new Path();</div><div class="line">        mBmp = BitmapFactory.decodeResource(getResources(), R.drawable.image);</div><div class="line">        int x = mBmp.getWidth() / 2;</div><div class="line">        int y = mBmp.getHeight() / 2;</div><div class="line">        int r = Math.min(x, y);</div><div class="line">        mPath.addCircle(x, y, r, Path.Direction.CCW);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.save();</div><div class="line">        canvas.clipPath(mPath);</div><div class="line">        canvas.drawBitmap(mBmp, 0, 0, mPaint);</div><div class="line">        canvas.restore();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>前面说过，在使用 clip 系列函数时，要禁用硬件加速功能。 setLayerType(LAYER_TYPE_SOFTWARE,null);<br>然而在手机型号 Pixel XL 上测试，是否禁用硬件加速功能并不影响 clip 函数。</p></blockquote><p><div id="jump4"></div></p><h3 id="1-5-4-示例二：裁剪动画"><a href="#1-5-4-示例二：裁剪动画" class="headerlink" title="1.5.4 示例二：裁剪动画"></a>1.5.4 示例二：裁剪动画</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-31634c0bd9bd9969.gif?imageMogr2/auto-orient/strip" alt=""></p><h4 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h4><p>动画原理就是每次将裁剪区域变大，在裁剪区域内的图像就会显示出来，而裁剪区域之外的图像不会显示。而关键问题在于如何计算裁剪区域。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a07fbe9ca6c6be10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>裁剪画布，在裁剪画布内的区域都是显示出来的，所以显示出来的区域才是裁剪区域。从图示中可以看出，有两个裁剪区域。</p><p>裁剪区域一：从左向右，逐渐变大。假设宽度是 clipWidth，高度是 CLIP_HEIGHT，那么裁剪区域一所对应的 Rect 对象如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Rect(0, 0, clipWidth, CLIP_HEIGHT);</div></pre></td></tr></table></figure></p><p>裁剪区域二：从右向左，同样逐渐变大，它的宽度、高度都与裁剪区域一相同。但它是从右向左变化的，假设图片的宽度是 width，那么裁剪区域二所对应的 Rect 对象如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Rect(width - clipWidth, CLIP_HEIGHT, width, 2* CLIP_HEIGHT);</div></pre></td></tr></table></figure></p><h4 id="2-示例代码"><a href="#2-示例代码" class="headerlink" title="2. 示例代码"></a>2. 示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap mBitmap;</div><div class="line">    private int clipWidth = 0;</div><div class="line">    private int width;</div><div class="line">    private int height;</div><div class="line">    private static final int CLIP_HEIGHT = 30;</div><div class="line">    private Path mPath;</div><div class="line">    private RectF mRect;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bg);</div><div class="line">        width = mBitmap.getWidth();</div><div class="line">        height = mBitmap.getHeight();</div><div class="line">        mPath = new Path();</div><div class="line">        mRect = new RectF();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        mPath.reset();</div><div class="line">        int i = 0;</div><div class="line">        while (i * CLIP_HEIGHT &lt;= height) &#123;</div><div class="line">            if (i % 2 == 0) &#123;</div><div class="line">                mRect.set(0, i * CLIP_HEIGHT, clipWidth, (i+1) * CLIP_HEIGHT);</div><div class="line">            &#125; else &#123;</div><div class="line">                mRect.set(width - clipWidth, i * CLIP_HEIGHT, width, (i+1) * CLIP_HEIGHT);</div><div class="line">            &#125;</div><div class="line">            // 替换 Region.union 方法</div><div class="line">            mPath.addRect(mRect, Path.Direction.CCW);</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 替换 canvas.clipRegion 方法</div><div class="line">        canvas.clipPath(mPath);</div><div class="line">        canvas.drawBitmap(mBitmap, 0, 0, mPaint);</div><div class="line">        if (clipWidth &gt; width) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        clipWidth += 5;</div><div class="line">        invalidate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7a5d519cb2676025.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01.4 精通自定义 View 之绘图基础——Region</title>
      <link href="/2019/07/01/05%20CUSTOM%20VIEW/01.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Region/"/>
      <url>/2019/07/01/05%20CUSTOM%20VIEW/01.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Region/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-25e3309e6425c834.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="1-4-1-构造-Region"><a href="#1-4-1-构造-Region" class="headerlink" title="1.4.1 构造 Region"></a>1.4.1 构造 Region</h3><h4 id="1-直接构造"><a href="#1-直接构造" class="headerlink" title="1. 直接构造"></a>1. 直接构造</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 复制一个 Region 的范围，不常用</div><div class="line">public Region(Region region) </div><div class="line">// 创建一个矩形区域</div><div class="line">public Region(Rect r) </div><div class="line">// 创建一个矩形区域</div><div class="line">public Region(int left, int top, int right, int bottom)</div></pre></td></tr></table></figure><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Region region = new Region(new Rect(50,50,200,100));</div><div class="line">drawRegion(canvas,region,paint);</div><div class="line"></div><div class="line">private void drawRegion (Canvas canvas, Region rgn, Paint paint) &#123;</div><div class="line">    RegionIterator iter = new RegionIterator(rgn);</div><div class="line">    Rect r = new Rect();</div><div class="line">    while (iter.next(r)) &#123;</div><div class="line">        canvas.drawRect(r, paint);</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-101edea89e88a9dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>Canvas 并没有提供针对 Region 的绘图方法，这就说明 Region 的本意并不是用来绘图的。对于上面构造的矩形填充，我们完全可以使用 Rect 来代替。</p><h4 id="2-间接构造"><a href="#2-间接构造" class="headerlink" title="2. 间接构造"></a>2. 间接构造</h4><p>间接构造主要是通过 public Region()的空构造函数与 set 系列函数相结合来实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 空构造函数</div><div class="line">public Region()</div><div class="line"></div><div class="line">// set 系列</div><div class="line">public void setEmpty() // 置空</div><div class="line">public boolean set(Region region)</div><div class="line">public boolean set(Rect r)</div><div class="line">public boolean set(int left, int top, int right, int bottom) </div><div class="line">public boolean setPath(Path path, Region clip)</div></pre></td></tr></table></figure></p><blockquote><p>无论调用 set 系列函数的 Region 是不是有区域值，当调用 set 系列函数后，原来的区域值就会被替换成 set 系列函数里的区域值。</p></blockquote><p>其他函数不表，重点介绍 setPath() 函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean setPath(Path path, Region clip)</div></pre></td></tr></table></figure></p><p>参数：<br>Path path：用来构造区域的路径。<br>Region clip：与前面的 path 所构成的路径取交集，并将该交集设置为最终的区域。</p><p>由于路径有很多种构造方法，而且可以轻易构造出非矩形的路径，因而摆脱了前面的构造函数只能构造矩形区域的限制。但这里有一个问题，即需要指定另一个区域来取交集。当然，如果想显示路径构造的区域，那么 Region clip 参数可以传入一个比 Path 范围大得多的区域，取完交集之后，当然就是 Path path 参数所对应的区域了。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class BaseView extends View &#123;</div><div class="line">    private Paint paint;</div><div class="line">    private Region region;</div><div class="line"></div><div class="line">    public BaseView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        paint = new Paint();</div><div class="line">        paint.setColor(Color.RED);</div><div class="line">        paint.setStyle(Paint.Style.FILL);</div><div class="line">        // 构造一条椭圆路径</div><div class="line">        Path ovalPath = new Path();</div><div class="line">        RectF rectF = new RectF(50, 50, 200, 500);</div><div class="line">        ovalPath.addOval(rectF, Path.Direction.CCW);</div><div class="line">        // 在 setPath 中传入一个比椭圆区域小的矩形区域，让其取交集</div><div class="line">        region = new Region();</div><div class="line">        region.setPath(ovalPath, new Region(50, 50, 200, 200));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        drawRegion(canvas, region, paint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void drawRegion(Canvas canvas, Region region, Paint paint) &#123;</div><div class="line">        RegionIterator iterator = new RegionIterator(region);</div><div class="line">        Rect rect = new Rect();</div><div class="line"></div><div class="line">        while (iterator.next(rect)) &#123;</div><div class="line">            canvas.drawRect(rect, paint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-660aa4a3d927e4e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>左侧分别画出了所构造的椭圆和矩形，二者相交之后，所画出的 Region 对象是如右侧图 像所示的椭圆上部分。</p><p><div id="jump2"></div></p><h3 id="1-4-2-枚举区域——RegionIterator-类"><a href="#1-4-2-枚举区域——RegionIterator-类" class="headerlink" title="1.4.2 枚举区域——RegionIterator 类"></a>1.4.2 枚举区域——RegionIterator 类</h3><p>对于特定的区域，可以使用多个矩形来表示其大致形状。事实上，如果矩形足够小，一定数量的矩形就能够精确表示区域的形状。也就是说，一定数量的矩形所合成的形状也可以代表区域的形状。RegionIterator 类就实现了获取组成区域的矩形集的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 构造函数：根据区域构建对应的矩形集。</div><div class="line">RegionIterator(Region region)</div><div class="line">// 获取下一个矩形,将结果保存在参数 Rect r 中。</div><div class="line">boolean next(Rect r)</div></pre></td></tr></table></figure></p><p>前面提到，由于在 Canvas 中没有直接绘制 Region 的函数，想要绘制一个区域，就只能通过 RegionIterator 类构造矩形集来逼近显示区域，所以 drawRegion() 函数的具体实现如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private void drawRegion (Canvas canvas, Region rgn, Paint paint) &#123;</div><div class="line">    RegionIterator iter = new RegionIterator(rgn);</div><div class="line">    Rect r = new Rect();</div><div class="line">    while (iter.next(r)) &#123;</div><div class="line">        canvas.drawRect(r, paint);</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>首先根据区域构造一个矩形集，然后利用 next(Rect r) 函数来逐个获取所有矩形并绘制出来，最终得到的就是整个区域。如果我们想画一个椭圆区域，并且把画笔样式从 FILL 改为 STROKE，则效果更清楚。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Paint paint = new Paint();</div><div class="line">paint.setColor(Color.RED);</div><div class="line">paint.setStyle(Paint.Style.STROKE);</div><div class="line">// 构造一条椭圆路径</div><div class="line">Path ovalPath = new Path();</div><div class="line">RectF rect = new RectF(50, 50, 200, 500); </div><div class="line">ovalPath.addOval(rect, Path.Direction.CCW);</div><div class="line">// 构造椭圆区域</div><div class="line">Region rgn = new Region();</div><div class="line">rgn.setPath(ovalPath, new Region(50, 50, 200, 500)); </div><div class="line">drawRegion(canvas,rgn,paint);</div></pre></td></tr></table></figure></p><p>在代码中，同样先构造了一条椭圆路径，然后在形成 Region 时传入一个与构造的椭圆区域相同大小的矩形，所以取交集之后的结果就是椭圆路径所对应的区域。效果如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-3701ef81c0abbaab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从效果图中可以明显看出，在绘制 Region 对象时，其实就是先将其转换成矩形集，然后利用画笔将每个矩形画出来而已。</p><p><div id="jump3"></div></p><h3 id="1-4-3-区域相交"><a href="#1-4-3-区域相交" class="headerlink" title="1.4.3 区域相交"></a>1.4.3 区域相交</h3><p>Region 不是用来绘图的，而是在区域的相交操作中。</p><h4 id="1-union-函数"><a href="#1-union-函数" class="headerlink" title="1. union() 函数"></a>1. union() 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean union(Rect r)</div></pre></td></tr></table></figure><p>该函数用于与指定矩形取并集，即将 Rect 所指定的矩形加入当前区域中。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">paint = new Paint();</div><div class="line">paint.setColor(Color.RED);</div><div class="line">paint.setStyle(Paint.Style.FILL);</div><div class="line">region = new Region(20, 20, 200, 100);</div><div class="line">region.union(new Rect(20, 20, 50, 300));</div><div class="line"></div><div class="line">drawRegion(canvas, region, paint);</div></pre></td></tr></table></figure></p><p>将横向、竖向两个矩形区域合并，效果图如下：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-b3ceac258f472065.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="2-区域操作"><a href="#2-区域操作" class="headerlink" title="2. 区域操作"></a>2. 区域操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">boolean op(Rect rect, Op op)</div><div class="line">boolean op(int left, int top, int right, int bottom, Op op)</div><div class="line">boolean op(Region, Op)</div></pre></td></tr></table></figure><p>操作结果赋给当前的 Region 对象。如果计算成功，返回 true；否则返回 false。</p><p>Op 参数值及含义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public enum Op &#123;</div><div class="line">    DIFFERENCE(0), // 最终区域为 region1 与 region2 不同的区域</div><div class="line">    INTERSECT(1), // 最终区域为 region1 与 region2 相交的区域</div><div class="line">    UNION(2), // 最终区域为 region1 与 region2 组合在一起的区域</div><div class="line">    XOR(3), // 最终区域为 region1 与 region2 相交之外的区域</div><div class="line">    REVERSE_DIFFERENCE(4), // 最终区域为 region2 与 region1 不同的区域</div><div class="line">    REPLACE(5); // 最终区域为 region2 的区域</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">public class BaseView extends View &#123;</div><div class="line">    private Paint paint, paintFill;</div><div class="line">    private Region region1,region2,region3,region4,region5,region6,region7,region8,region9,region10,region11,region12;</div><div class="line">    private Rect rect1,rect2,rect3,rect4,rect5,rect6,rect7,rect8,rect9,rect10,rect11,rect12;</div><div class="line"></div><div class="line">    public BaseView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        paint = generatePaint(Color.RED, Paint.Style.STROKE, 2);</div><div class="line">        paintFill = generatePaint(Color.GREEN, Paint.Style.FILL, 0);</div><div class="line"></div><div class="line">        rect1 = new Rect(100, 140, 400, 240);</div><div class="line">        rect2 = new Rect(200, 40, 300, 340);</div><div class="line">        rect3 = new Rect(500, 140, 800, 240);</div><div class="line">        rect4 = new Rect(600, 40, 700, 340);</div><div class="line">        rect5 = new Rect(900, 140, 1200, 240);</div><div class="line">        rect6 = new Rect(1000, 40, 1100, 340);</div><div class="line"></div><div class="line">        rect7 = new Rect(100, 540, 400, 640);</div><div class="line">        rect8 = new Rect(200, 440, 300, 740);</div><div class="line">        rect9 = new Rect(500, 540, 800, 640);</div><div class="line">        rect10 = new Rect(600, 440, 700, 740);</div><div class="line">        rect11 = new Rect(900, 540, 1200, 640);</div><div class="line">        rect12 = new Rect(1000, 440, 1100, 740);</div><div class="line"></div><div class="line">        region1 = new Region(rect1);</div><div class="line">        region2 = new Region(rect2);</div><div class="line">        region1.op(region2, Region.Op.DIFFERENCE);</div><div class="line">        region3 = new Region(rect3);</div><div class="line">        region4 = new Region(rect4);</div><div class="line">        region3.op(region4, Region.Op.INTERSECT);</div><div class="line">        region5 = new Region(rect5);</div><div class="line">        region6 = new Region(rect6);</div><div class="line">        region5.op(region6, Region.Op.UNION);</div><div class="line">        region7 = new Region(rect7);</div><div class="line">        region8 = new Region(rect8);</div><div class="line">        region7.op(region8, Region.Op.XOR);</div><div class="line">        region9 = new Region(rect9);</div><div class="line">        region10 = new Region(rect10);</div><div class="line">        region9.op(region10, Region.Op.REVERSE_DIFFERENCE);</div><div class="line">        region11 = new Region(rect11);</div><div class="line">        region12 = new Region(rect12);</div><div class="line">        region11.op(region12, Region.Op.REPLACE);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        canvas.drawRect(rect1, paint);</div><div class="line">        canvas.drawRect(rect2, paint);</div><div class="line">        drawRegion(canvas, region1, paintFill);</div><div class="line">        canvas.drawRect(rect3, paint);</div><div class="line">        canvas.drawRect(rect4, paint);</div><div class="line">        drawRegion(canvas, region3, paintFill);</div><div class="line">        canvas.drawRect(rect5, paint);</div><div class="line">        canvas.drawRect(rect6, paint);</div><div class="line">        drawRegion(canvas, region5, paintFill);</div><div class="line">        canvas.drawRect(rect7, paint);</div><div class="line">        canvas.drawRect(rect8, paint);</div><div class="line">        drawRegion(canvas, region7, paintFill);</div><div class="line">        canvas.drawRect(rect9, paint);</div><div class="line">        canvas.drawRect(rect10, paint);</div><div class="line">        drawRegion(canvas, region9, paintFill);</div><div class="line">        canvas.drawRect(rect11, paint);</div><div class="line">        canvas.drawRect(rect12, paint);</div><div class="line">        drawRegion(canvas, region11, paintFill);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void drawRegion(Canvas canvas, Region region, Paint paint) &#123;</div><div class="line">        RegionIterator iterator = new RegionIterator(region);</div><div class="line">        Rect rect = new Rect();</div><div class="line"></div><div class="line">        while (iterator.next(rect)) &#123;</div><div class="line">            canvas.drawRect(rect, paint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Paint generatePaint(int color, Paint.Style style, int width) &#123;</div><div class="line">        Paint paint = new Paint();</div><div class="line">        paint.setColor(color);</div><div class="line">        paint.setStyle(style);</div><div class="line">        paint.setStrokeWidth(width);</div><div class="line">        return paint;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-fced149dfa37297a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="依次为：DIFFERENCE、INTERSECT、UNION、XOR、REVERSE_DIFFERENCE、REPLACE"></p><h4 id="3-op-的重载"><a href="#3-op-的重载" class="headerlink" title="3. op 的重载"></a>3. op 的重载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">boolean op(Rect rect, Region region, Op op)</div><div class="line">boolean op(Region region1, Region region2, Region.Op op)</div></pre></td></tr></table></figure><p>这两个函数允许我们传入两个 Region 对象进行区域操作，并将操作结果赋给当前的 Region 对象。同样，当操作成功时，返回 true；否则返回 false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Region region1 = new Region(100,100,400,200);</div><div class="line">Region region2 = new Region(200,0,300,300);</div><div class="line">Region region = new Region();</div><div class="line">region.op(region1, region2, Region.Op.INTERSECT);</div></pre></td></tr></table></figure></p><p>在这里，将 region1、region2 相交的结果赋给 Region 对象。</p><p><div id="jump4"></div></p><h3 id="1-4-4-其他函数"><a href="#1-4-4-其他函数" class="headerlink" title="1.4.4 其他函数"></a>1.4.4 其他函数</h3><h4 id="1-几个判断方法"><a href="#1-几个判断方法" class="headerlink" title="1. 几个判断方法"></a>1. 几个判断方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 判断该区域是否为空</div><div class="line">public boolean isEmpty();</div><div class="line">// 判断该区域是否是一个矩阵</div><div class="line">public boolean isRect();</div><div class="line">// 判断该区域是否是多个矩阵的组合</div><div class="line">public boolean isComplex();</div></pre></td></tr></table></figure><h4 id="2-getBound-系列函数"><a href="#2-getBound-系列函数" class="headerlink" title="2. getBound 系列函数"></a>2. getBound 系列函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 返回能够包裹当前路径的最小矩形</div><div class="line">public Rect getBounds()</div><div class="line">public boolean getBounds(Rect r)</div><div class="line">// 返回当前矩形所对应的 Path 对象</div><div class="line">public Path getBoundaryPath()</div><div class="line">public boolean getBoundaryPath(Path path)</div></pre></td></tr></table></figure><h4 id="3-是否包含"><a href="#3-是否包含" class="headerlink" title="3. 是否包含"></a>3. 是否包含</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 判断该区域是否包含某个点</div><div class="line">public boolean contains(int x, int y);</div><div class="line">// 判断该区域是否包含某个矩形</div><div class="line">public boolean quickContains(Rect r)</div><div class="line">public boolean quickContains(int left, int top, int right,int bottom)</div></pre></td></tr></table></figure><h4 id="4-是否相交"><a href="#4-是否相交" class="headerlink" title="4. 是否相交"></a>4. 是否相交</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 判断该区域是否没有和指定矩形相交</div><div class="line">public boolean quickReject(Rect r)</div><div class="line">public boolean quickReject(int left, int top, int right, int bottom);</div><div class="line">// 判断该区域是否没有和指定区域相交</div><div class="line">public boolean quickReject(Region rgn)</div></pre></td></tr></table></figure><h4 id="5-平移变换"><a href="#5-平移变换" class="headerlink" title="5. 平移变换"></a>5. 平移变换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 将 Region 对象向 X 轴平移 dx 距离，向 Y 轴平移 dy 距离，</div><div class="line">// 并将结果赋给当前的 Region 对象。X 轴向右是正方向，Y 轴向下是正方向。</div><div class="line">public void translate(int dx, int dy)</div><div class="line">// 将 Region 对象向 X 轴平移 dx 距离，向 Y 轴平移 dy 距离。</div><div class="line">// 与上一个函数不同的是，该函数将结果赋给 dst 对象，</div><div class="line">// 而当前 Region 对象的值保持不变。</div><div class="line">public void translate(int dx, int dy, Region dst)</div></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1a02c6291f6c7225.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01.3 精通自定义 View 之绘图基础——文字</title>
      <link href="/2019/07/01/05%20CUSTOM%20VIEW/01.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/"/>
      <url>/2019/07/01/05%20CUSTOM%20VIEW/01.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0b16eae0dbf79241.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="1-3-1-Paint-设置"><a href="#1-3-1-Paint-设置" class="headerlink" title="1.3.1 Paint 设置"></a>1.3.1 Paint 设置</h3><p>Paint 与文字相关的设置方法有如下几个：</p><ul><li>普通设置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 设置画笔宽度</div><div class="line">paint.setStrokeWidth (5); </div><div class="line">// 指定是否使用抗锯齿功能。如果使用,则会使绘图速度变慢</div><div class="line">paint.setAntiAlias(true);</div><div class="line">// 绘图样式，对于文字和几何图形都有效</div><div class="line">paint.setStyle(Paint.Style.FILL);</div><div class="line">// 设置文字对齐方式： Align.CENTER、Align.LEFT、Align.RIGHT</div><div class="line">paint.setTextAlign(Align.CENTER);</div><div class="line">// 设置文字大小</div><div class="line">paint.setTextSize(12);</div></pre></td></tr></table></figure><ul><li>样式设置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 设置是否为粗体文字</div><div class="line">paint.setFakeBoldText(true); </div><div class="line">// 设置下画线</div><div class="line">paint.setUnderlineText(true); </div><div class="line">// 设置字体水平倾斜度，普通斜体字设为 -0.25，右为负左为正</div><div class="line">paint.setTextSkewX((float) -0.25); </div><div class="line">// 设置带有删除线效果</div><div class="line">paint.setStrikeThruText(true);</div></pre></td></tr></table></figure><ul><li>其他设置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 只会将水平方向拉伸,高度不会变</div><div class="line">paint.setTextScaleX(2);</div></pre></td></tr></table></figure><h4 id="1-填充样式的区别"><a href="#1-填充样式的区别" class="headerlink" title="1. 填充样式的区别"></a>1. 填充样式的区别</h4><p>paint.setStyle() 函数对文字和几何图形都有效。下面就来看看不同的填充样式对文字的影响：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">mPaint = new Paint();</div><div class="line">mPaint.setColor(Color.RED);</div><div class="line">mPaint.setStrokeWidth(5);</div><div class="line">mPaint.setAntiAlias(true);</div><div class="line">mPaint.setTextSize(100);</div><div class="line"></div><div class="line">mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">canvas.drawText(&quot;先小涛 STROKE&quot;, 100, 200, mPaint);</div><div class="line">mPaint.setStyle(Paint.Style.FILL);</div><div class="line">canvas.drawText(&quot;先小涛 FILL&quot;, 100, 320, mPaint);</div><div class="line">mPaint.setStyle(Paint.Style.FILL_AND_STROKE);</div><div class="line">canvas.drawText(&quot;先小涛 FILL_AND_STROKE&quot;, 100, 440, mPaint);</div></pre></td></tr></table></figure></p><p>效果图如下：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-16b11cc8b1731a0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字体填充样式"></p><h4 id="2-setTextAlign-函数"><a href="#2-setTextAlign-函数" class="headerlink" title="2. setTextAlign() 函数"></a>2. setTextAlign() 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void setTextAlign(Align align)</div></pre></td></tr></table></figure><p>用于设置所要绘制的字符串与起始点的相对位置。参数 Align align 的取值如下：</p><ul><li>Align.LEFT：居左绘制，即通过 drawText() 函数指定的起始点在最左侧，文字从起始点位置开始绘制。</li><li>Align.CENTER：居中绘制，即通过 drawText() 函数指定的起始点在文字中间位置。</li><li>Align.RIGHT：居右绘制，即通过 drawText() 函数指定的起始点在文字右侧位置。</li></ul><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">mLinePaint = new Paint();</div><div class="line">mLinePaint.setColor(Color.BLUE);</div><div class="line">mPaint = new Paint();</div><div class="line">mPaint.setColor(Color.RED);</div><div class="line">mPaint.setStrokeWidth(5);</div><div class="line">mPaint.setAntiAlias(true);</div><div class="line">mPaint.setTextSize(80);</div><div class="line"></div><div class="line">canvas.drawCircle(400, 100, 5, mLinePaint);</div><div class="line">canvas.drawLine(400, 100, 400, 300, mLinePaint);</div><div class="line">mPaint.setTextAlign(Paint.Align.LEFT);</div><div class="line">canvas.drawText(&quot;先小涛&quot;, 400, 100, mPaint);</div><div class="line">mPaint.setTextAlign(Paint.Align.CENTER);</div><div class="line">canvas.drawText(&quot;先小涛&quot;, 400, 200, mPaint);</div><div class="line">mPaint.setTextAlign(Paint.Align.RIGHT);</div><div class="line">canvas.drawText(&quot;先小涛&quot;, 400, 300, mPaint);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ff624351d68401c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="setTextAlign 效果图"></p><p>从效果图中可以看出，当居左对齐 (Align.LEFT) 时，整个字符串都在起始点 (400,100) 的右侧，也就是说,通过 drawText() 函数指定的起始点 (400,100) 是居左的。同样，当居右对齐 (Align.RIGHT) 时，起始点也是居右的，也就是说，所有文字都在起始点 (400,100) 的左侧。</p><h4 id="3-设置字体样式"><a href="#3-设置字体样式" class="headerlink" title="3. 设置字体样式"></a>3. 设置字体样式</h4><p>1）常规设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 设置是否粗体。当取 true 时，表示是粗体。</div><div class="line">void setFakeBoldText(boolean fakeBoldText)</div><div class="line">// 是否显示文字下画线。当取 true 时，显示下画线。</div><div class="line">void setUnderlineText(boolean underlineText)</div><div class="line">// 是否显示中间删除线。当取 true 时，显示中间删除线。</div><div class="line">void setStrikeThruText(boolean strikeThruText)</div></pre></td></tr></table></figure></p><p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">canvas.drawText(&quot;先小涛 DEFAULT&quot;, 100, 200, mPaint);</div><div class="line">mPaint.setFakeBoldText(true);</div><div class="line">mPaint.setUnderlineText(true);</div><div class="line">mPaint.setStrikeThruText(true);</div><div class="line">canvas.drawText(&quot;先小涛 SETTING&quot;, 100, 300, mPaint);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-16487debfb27c72b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字体设置效果图"></p><p>2）字体倾斜度设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void setTextSkewX(float skewX)</div></pre></td></tr></table></figure></p><p>该函数用于设置字体倾斜度。参数 float skewX 的默认值是 0，取负值时文字向右倾斜，取正值时文字向左倾斜，Word 文档中倾斜字体的倾斜度是 -0.25f。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">mPaint = new Paint();</div><div class="line">mPaint.setColor(Color.RED);</div><div class="line">mPaint.setTextSize(80);</div><div class="line"></div><div class="line">// 正常样式</div><div class="line">canvas.drawText(mName, 100, 200, mPaint);</div><div class="line">// 向右倾斜</div><div class="line">mPaint.setTextSkewX(-0.25f);</div><div class="line">canvas.drawText(mName, 100, 300, mPaint);</div><div class="line">// 向左倾斜</div><div class="line">mPaint.setTextSkewX(0.25f);</div><div class="line">canvas.drawText(mName, 100, 400, mPaint);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-5092c1c4b245d5fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字体倾斜度设置：正常、向右、向左"></p><h4 id="4-水平拉伸"><a href="#4-水平拉伸" class="headerlink" title="4. 水平拉伸"></a>4. 水平拉伸</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void setTextScaleX(float scaleX)</div></pre></td></tr></table></figure><p>该函数用于在水平方向拉伸文字。参数 float scaleX 表示拉伸倍数，当取值为 1 时，表示不拉伸。默认为不拉伸。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 正常样式</div><div class="line">canvas.drawText(mName, 100, 200, mPaint);</div><div class="line">// 拉伸两倍</div><div class="line">mPaint.setTextScaleX(2f);</div><div class="line">canvas.drawText(mName, 100, 300, mPaint);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f24aeccf2715d7a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字体水平拉伸"></p><p><div id="jump2"></div></p><h3 id="1-3-2-Canvas-绘制文本"><a href="#1-3-2-Canvas-绘制文本" class="headerlink" title="1.3.2 Canvas 绘制文本"></a>1.3.2 Canvas 绘制文本</h3><h4 id="1-普通绘制"><a href="#1-普通绘制" class="headerlink" title="1. 普通绘制"></a>1. 普通绘制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 该函数可以指定起始点 (x, y) 来绘制文字</div><div class="line">void drawText(String text, float x, float y, Paint paint)</div><div class="line">// 通过指定字符串中字符的起始和终止位置截取字符串的一部分绘制</div><div class="line">void drawText(String text, int start, int end, float x, float y, Paint paint)</div><div class="line">void drawText(char[] text, int index, int count, float x, float y, Paint paint)</div><div class="line">void drawText(CharSequence text, int start, </div><div class="line">              int end, float x, float y, Paint paint)</div></pre></td></tr></table></figure><p>参数：<br>int start：表示起始绘制字符所在字符串中的索引。<br>int end：表示结束绘制字符所在字符串中的索引。<br>int index：指定起始绘制字符的位置。<br>int count：指定从起始绘制字符开始绘制几个字符。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">canvas.drawText(&quot;先小涛后大浪&quot;, 1, 4, 100, 200, mPaint);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b6c9d809d7d02707.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="2-逐个指定文字位置"><a href="#2-逐个指定文字位置" class="headerlink" title="2. 逐个指定文字位置"></a>2. 逐个指定文字位置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void drawPosText(String text, float[] pos, Paint paint)</div><div class="line">void drawPosText(char[] text, int index, int count, float[] pos, Paint paint)</div></pre></td></tr></table></figure><p>参数：</p><ul><li>char[] text/String text：要绘制的字符串。</li><li>int index：第一个要绘制的文字的索引。</li><li>int count：要绘制的文字的个数，用来计算最后一个文字的位置，从第一个绘制的文字开始算起。</li><li>float[] pos：要绘制的每个文字的具体位置，同样两两一组，如 {x1,y1,x2,y2,x3,y3,…}。</li></ul><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private String mName = &quot;先小涛后大浪&quot;;</div><div class="line">    private float[] pos = &#123;80, 180, 80, 280, 80, 380,</div><div class="line">                           200, 180, 200, 280, 200, 380&#125;;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPaint.setTextSize(80);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        canvas.drawPosText(mName, pos, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1b7f44f3ba8837d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="3-沿路径绘制"><a href="#3-沿路径绘制" class="headerlink" title="3. 沿路径绘制"></a>3. 沿路径绘制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void drawTextOnPath (String text, Path path, float hOffset, </div><div class="line">                     float vOffset, Paint paint)</div><div class="line">void drawTextOnPath (char[] text, int index, int count, Path path, </div><div class="line">                     float hOffset, float vOffset, Paint paint)</div></pre></td></tr></table></figure><ul><li>float hOffset：与路径起始点的水平偏移量。 </li><li>float vOffset：与路径中心的垂直偏移量。</li></ul><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">mPaint = new Paint();</div><div class="line">mPaint.setColor(Color.RED);</div><div class="line">mPaint.setTextSize(50);</div><div class="line">mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">mName = &quot;先小涛后大浪&quot;;</div><div class="line">mPath1 = new Path();</div><div class="line">mPath1.addCircle(220, 300, 150, Path.Direction.CCW);</div><div class="line">mPath2 = new Path();</div><div class="line">mPath2.addCircle(600, 300, 150, Path.Direction.CCW);</div><div class="line"></div><div class="line">// 辅助中线</div><div class="line">canvas.drawLine(70, 300, 750, 300, mPaint);</div><div class="line">canvas.drawPath(mPath1, mPaint);</div><div class="line">canvas.drawPath(mPath2, mPaint);</div><div class="line">mPaint.setColor(Color.BLUE);</div><div class="line">canvas.drawTextOnPath(mName, mPath1, 0, 0, mPaint);</div><div class="line">canvas.drawTextOnPath(mName, mPath2, 80, 50, mPaint);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-3b672e6d1a2b4c3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><div id="jump3"></div></p><h3 id="1-3-3-设置字体样式"><a href="#1-3-3-设置字体样式" class="headerlink" title="1.3.3 设置字体样式"></a>1.3.3 设置字体样式</h3><p>在 Paint 中有一个函数是专门用来设置字体样式的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Typeface setTypeface(Typeface typeface)</div></pre></td></tr></table></figure></p><p>Typeface 是专门用来设置字体样式的类，通过 paint.setTypeface() 函数来指定即将绘制的文字的字体样式。可以指定系统中的字体样式，也可以在自定义的样式文件中获取。在构建 Typeface 类时，可以指定所用样式的正常体、斜体、粗体等。如果在指定样式中没有相关文字的样式，就会用系统默认的样式来显示，一般默认是宋体。</p><h4 id="1-使用系统中的字体样式"><a href="#1-使用系统中的字体样式" class="headerlink" title="1. 使用系统中的字体样式"></a>1. 使用系统中的字体样式</h4><p>1）使用 Android 自带的字体样式<br>在 Typeface 类中保存着三种自带的字体样式：Typeface.SANS_SERIF、Typeface.MONOSPACE 和 Typeface.SERIF。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 衬线字体</div><div class="line">mPaint.setTypeface(Typeface.SERIF);</div><div class="line">canvas.drawText(mName, 100, 100, mPaint);</div><div class="line">// 设置等宽字体</div><div class="line">mPaint.setTypeface(Typeface.MONOSPACE);</div><div class="line">canvas.drawText(mName, 100, 170, mPaint);</div><div class="line">// 无衬线字体</div><div class="line">mPaint.setTypeface(Typeface.SANS_SERIF);</div><div class="line">canvas.drawText(mName, 100, 240, mPaint);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-bcad462033b71603.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="系统字体样式"></p><p>由于这三种字体样式对中文的支持不是很好。所以，当遇到不支持的文字时，会使用系统默认的样式来写。对中国用户而言，系统默认的字体一般是 DroidSansFallback，所以用这三种样式的文字写中文时是看不到差别的，我们一般不会使用这三种字体样式。</p><p>2）defaultFromStyle() 函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Typeface defaultFromStyle(int style)</div></pre></td></tr></table></figure></p><p>该函数会根据字体样式获取对应的默认字体。参数 int style 的取值如下：</p><ul><li>Typeface.NORMAL：正常字体。</li><li>Typeface.BOLD：粗体。</li><li>Typeface.ITALIC：斜体。</li><li>Typeface.BOLD_ITALIC：粗斜体。</li></ul><p>如果系统默认的字体是宋体，那么当指定 defaultFromStyle(Typeface.BOLD_ITALIC) 时，获取的将是粗斜体的宋体样式。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mPaint = new Paint();</div><div class="line">mPaint.setColor(Color.RED);</div><div class="line">mPaint.setTextSize(50);</div><div class="line">mPaint.setAntiAlias(true);</div><div class="line">mName = &quot;先小涛 xian@163.com&quot;;</div><div class="line">Typeface typeface = Typeface.defaultFromStyle(Typeface.BOLD_ITALIC);</div><div class="line">mPaint.setTypeface(typeface);</div><div class="line"></div><div class="line">canvas.drawText(mName, 100, 100, mPaint);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b07302336ad691c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>3）create(String familyName, int style) 函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Typeface create(String familyName, int style)</div></pre></td></tr></table></figure></p><p>该函数直接通过指定字体名来加载系统中自带的字体样式。如果字体样式不存在，则会用系统样式替代并返回。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String familyName = &quot;宋体&quot;;</div><div class="line">Typeface font = Typeface.create(familyName, Typeface.NORMAL);</div><div class="line">mPaint.setTypeface(font);</div><div class="line"></div><div class="line">canvas.drawText(mName, 100, 100, mPaint);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2dc4d2f717e87dc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="2-自定义字体样式"><a href="#2-自定义字体样式" class="headerlink" title="2. 自定义字体样式"></a>2. 自定义字体样式</h4><p>一般而言，我们不会指定系统自带的字体样式。因为除 Android 自带的三种字体样式以外，其他字体样式并不一定在每款手机上都有预装。所以，我们一般会选择加载自定义的字体文件来绘制文字，这样才不至于在每款手机上的表现不一样。</p><p>如果要自定义字体样式，就需要从外部字体文件中加载我们所需的字形，这时所使用的 Typeface 构造函数有如下三个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Typeface createFromAsset(AssetManager mgr, String path)</div><div class="line">Typeface createFromFile(String path)</div><div class="line">Typeface createFromFile(File path)</div></pre></td></tr></table></figure></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AssetManager manager = context.getAssets();</div><div class="line">// 加载字体文件：assets/fonts/xian.ttf</div><div class="line">Typeface typeface = Typeface.createFromAsset(manager, &quot;fonts/xian.ttf&quot;);</div><div class="line">mPaint.setTypeface(typeface);</div><div class="line"></div><div class="line">canvas.drawText(mName, 100, 200, mPaint);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ee96a269fc0c1fe5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>加载 res/font/xian.ttf 字体文件方式：<br>Typeface typeface = ResourcesCompat.getFont(context, R.font.xian);</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4af7147edc1baff6.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01.2 精通自定义 View 之绘图基础——路径</title>
      <link href="/2019/07/01/05%20CUSTOM%20VIEW/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/"/>
      <url>/2019/07/01/05%20CUSTOM%20VIEW/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-824805b11af73719.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="1-2-1-概述"><a href="#1-2-1-概述" class="headerlink" title="1.2.1 概述"></a>1.2.1 概述</h3><p>画笔所画出来的一段不间断的曲线就是路径。在 Android 中，Path 类就代表路径。在 Canvas 中绘制路径的方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void drawPath(Path path, Paint paint)</div></pre></td></tr></table></figure></p><p><div id="jump2"></div></p><h3 id="1-2-2-直线路径"><a href="#1-2-2-直线路径" class="headerlink" title="1.2.2 直线路径"></a>1.2.2 直线路径</h3><p>画一条直线路径,一般涉及下面三个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// (x1,y1)是直线的起始点，即将直线路径的绘制点定在(x1,y1)位置</div><div class="line">void moveTo(float x1, float y1)</div><div class="line">// (x2,y2)是直线的终点，又是下一次绘制直线路径的起始点；lineTo()函数可以一直使用。</div><div class="line">void lineTo(float x2, float y2)</div><div class="line">// 如果连续画了几条直线，但没有形成闭环，</div><div class="line">// 那么调用 close()函数会将路径首尾点连接起来，形成闭环。</div><div class="line">void close()</div></pre></td></tr></table></figure></p><p>示例：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-8e38ddf81a7fe2a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="闭环 &amp; 不闭环三角形"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 初始化</div><div class="line">mPaint = new Paint();</div><div class="line">mPaint.setColor(Color.RED);</div><div class="line">mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">mPaint.setStrokeWidth(5);</div><div class="line">mPath = new Path();</div><div class="line"></div><div class="line">// 闭环</div><div class="line">mPath.moveTo(20, 20);</div><div class="line">mPath.lineTo(20, 120);</div><div class="line">mPath.lineTo(300, 120);</div><div class="line">mPath.close();</div><div class="line">canvas.drawPath(mPath, mPaint);</div><div class="line"></div><div class="line">// 不闭环</div><div class="line">mPath.moveTo(320, 20);</div><div class="line">mPath.lineTo(320, 120);</div><div class="line">mPath.lineTo(600, 120);</div><div class="line">canvas.drawPath(mPath, mPaint);</div></pre></td></tr></table></figure><p>闭合三角形：先沿逆时针方向画了两条直线，分别是从(20, 20)到(20, 120)和从(20, 120)到(300, 120)，然后利用 path.close()函数将路径闭合，路径的终点(300,120)就会自行向路径的起始点 (20,20)画一条闭合线，所以最终我们看到的是一个路径闭合的三角形。</p><p><div id="jump3"></div></p><h3 id="1-2-3-弧线路径"><a href="#1-2-3-弧线路径" class="headerlink" title="1.2.3 弧线路径"></a>1.2.3 弧线路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void arcTo(RectF oval, float startAngle, float sweepAngle)</div></pre></td></tr></table></figure><p>这是一个画弧线路径的方法，弧线是从椭圆上截取的一部分。<br>参数:</p><ul><li>RectF oval：生成椭圆的矩形。</li><li>float startAngle：弧开始的角度，以 X 轴正方向为 0°。 </li><li>float sweepAngle：弧持续的角度。</li></ul><p>示例：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-7331c6d8b5f45ab1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 初始化</div><div class="line">mPaint = new Paint();</div><div class="line">mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">mPaint.setStrokeWidth(5);</div><div class="line">mRect = new RectF(100, 20, 200, 100);</div><div class="line">mPath = new Path();</div><div class="line">mPath.moveTo(20, 20);</div><div class="line">mPath.arcTo(mRect, 0, 90);</div><div class="line"></div><div class="line">// onDraw</div><div class="line">mPaint.setColor(Color.LTGRAY);</div><div class="line">canvas.drawRect(mRect, mPaint);</div><div class="line">mPaint.setColor(Color.RED);</div><div class="line">canvas.drawPath(mPath, mPaint);</div></pre></td></tr></table></figure><p>上述示例中弧最终还是会和起始点(20,20)连接起来。因为在默认情况下路径都是连贯的，除非以下两种情况：</p><ul><li>调用 addXXX 系列函数(参见 1.2.4 节)，将直接添加固定形状的路径。</li><li>调用 moveTo()函数改变绘制起始位置。</li></ul><p>如果不想连接起来，需要使用 Path 类提供的另外两个重载方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void arcTo(float left, float top, float right, float bottom, </div><div class="line">           float startAngle, float sweepAngle, boolean forceMoveTo)</div><div class="line">void arcTo(RectF oval, float startAngle, float sweepAngle, boolean forceMoveTo)</div></pre></td></tr></table></figure></p><p>参数 boolean forceMoveTo 的含义是是否强制将弧的起始点作为绘制起始位置。</p><p>将上面的代码稍加改造：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// mPath.arcTo(mRect, 0, 90);</div><div class="line">mPath.arcTo(mRect, 0, 90, true);</div></pre></td></tr></table></figure></p><p>效果如下：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-df222124d40335a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><div id="jump4"></div></p><h3 id="1-2-4-addXXX系列函数"><a href="#1-2-4-addXXX系列函数" class="headerlink" title="1.2.4 addXXX系列函数"></a>1.2.4 addXXX系列函数</h3><p>路径一般都是连贯的，而 addXXX 系列函数可以让我们直接往 Path 中添加一些曲线，而不必考虑连贯性。</p><p>示例：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-37511e3dbeff4d95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">mPaint = new Paint();</div><div class="line">mPaint.setColor(Color.RED);</div><div class="line">mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">mPaint.setStrokeWidth(5);</div><div class="line"></div><div class="line">mPath = new Path();</div><div class="line">mPath.moveTo(40, 40);</div><div class="line">mPath.lineTo(100, 100);</div><div class="line">mRect = new RectF(100, 100, 200, 200);</div><div class="line">mPath.addArc(mRect, 0, 90);</div><div class="line"></div><div class="line">canvas.drawPath(mPath, mPaint);</div></pre></td></tr></table></figure><p>先绘制了从(40,40)到(100,100)的线段，但是在我们往路径中添加了一条弧线之后，弧线并没有与线段连接。除了 addArc()函数，Path 类还提供了一系列的 add 函数：</p><h4 id="1-添加矩形路径"><a href="#1-添加矩形路径" class="headerlink" title="1.添加矩形路径"></a>1.添加矩形路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void addRect(float left, float top, float right, float bottom, </div><div class="line">             Path.Direction dir)</div><div class="line">void addRect(RectF rect, Path.Direction dir)</div></pre></td></tr></table></figure><p>这里 Path 类创建矩形路径的参数与 Canvas 绘制矩形的参数差不多,唯一不同的是增加了 Path.Direction 参数。Path.Direction 参数有两个值。</p><ul><li>Path.Direction.CCW：是 counter-clockwise 的缩写，指创建逆时针方向的矩形路径。</li><li>Path.Direction.CW：是 clockwise 的缩写，指创建顺时针方向的矩形路径。</li></ul><p>示例：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-03911176aaff56ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">    super(context, attrs);</div><div class="line"></div><div class="line">    mPaint = new Paint();</div><div class="line">    mPaint.setColor(Color.LTGRAY);</div><div class="line">    mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">    mPaint.setStrokeWidth(5);</div><div class="line"></div><div class="line">    mTextPaint = new Paint();</div><div class="line">    mTextPaint.setColor(Color.BLUE);</div><div class="line">    mTextPaint.setTextSize(35);</div><div class="line"></div><div class="line">    mStr = &quot;苦心人天不负，有志者事竟成&quot;;</div><div class="line"></div><div class="line">    // 逆时针路径</div><div class="line">    mCCWPath = new Path();</div><div class="line">    RectF rect1 = new RectF(50, 50, 240, 200);</div><div class="line">    mCCWPath.addRect(rect1, Path.Direction.CCW);</div><div class="line">    // 顺时针路径</div><div class="line">    mCWPath = new Path();</div><div class="line">    RectF rect2 = new RectF(290, 50, 480, 200);</div><div class="line">    mCWPath.addRect(rect2, Path.Direction.CW);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    canvas.drawPath(mCCWPath, mPaint);</div><div class="line">    canvas.drawPath(mCWPath, mPaint);</div><div class="line">    canvas.drawTextOnPath(mStr, mCCWPath, 0, 18, mTextPaint);</div><div class="line">    canvas.drawTextOnPath(mStr, mCWPath, 0, 18, mTextPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>文字是可以依据路径排版的，文字的行走方向依据的就是路径的生成方向。</p><h4 id="2-添加圆角矩形路径"><a href="#2-添加圆角矩形路径" class="headerlink" title="2.添加圆角矩形路径"></a>2.添加圆角矩形路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void addRoundRect(RectF rect, float[] radii, Path.Direction dir)</div><div class="line">void addRoundRect(RectF rect, float rx, float ry, Path.Direction dir)</div></pre></td></tr></table></figure><p>矩形的圆角都是利用椭圆生成的。参数：</p><ul><li>RectF rect：是当前所构造路径的矩形。</li><li>Path.Direction dir：依然是指路径的生成方向，当然只对依据路径布局的文字有用。</li><li>float[] radii：必须传入 8 个数值，分 4 组，分别对应每个角所使用的椭圆的横轴半径和纵轴半径。如{x1,y1,x2,y2,x3,y3,x4,y4}，其中，x1,y1 对应第一个角(左上角)的用来生成圆角的椭圆的横轴半径和纵轴半径，其他类推……</li><li>float rx：生成统一的圆角的椭圆的横轴半径。</li><li>float ry：生成统一的圆角的椭圆的纵轴半径。</li></ul><p>示例：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-2f1e571e526983ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mCCWPath, mCWPath;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setAntiAlias(true);</div><div class="line">        mPaint.setStrokeWidth(5);</div><div class="line"></div><div class="line">        // 逆时针路径</div><div class="line">        mCCWPath = new Path();</div><div class="line">        RectF rect1 = new RectF(50, 50, 240, 200);</div><div class="line">        mCCWPath.addRoundRect(rect1, 10, 15, Path.Direction.CCW);</div><div class="line">        // 顺时针路径</div><div class="line">        mCWPath = new Path();</div><div class="line">        RectF rect2 = new RectF(290, 50, 480, 200);</div><div class="line">        float[] radii = &#123;10,15,20,25,30,35,40,45&#125;;</div><div class="line">        mCWPath.addRoundRect(rect2, radii, Path.Direction.CW);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        canvas.drawPath(mCCWPath, mPaint);</div><div class="line">        canvas.drawPath(mCWPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3-添加圆形路径"><a href="#3-添加圆形路径" class="headerlink" title="3.添加圆形路径"></a>3.添加圆形路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void addCircle(float x, float y, float radius, Path.Direction dir)</div></pre></td></tr></table></figure><p>参数:</p><ul><li>float x：圆心 X 轴坐标。 </li><li>float y：圆心 Y 轴坐标。 </li><li>float radius：圆半径。</li></ul><p>示例：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-d00e3789856b37a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mPath = new Path();</div><div class="line">mPath.addCircle(100, 100, 50, Path.Direction.CCW);</div><div class="line"></div><div class="line">canvas.drawPath(mPath, mPaint);</div></pre></td></tr></table></figure><h4 id="4-添加椭圆路径"><a href="#4-添加椭圆路径" class="headerlink" title="4.添加椭圆路径"></a>4.添加椭圆路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void addOval(RectF oval, Path.Direction dir)</div></pre></td></tr></table></figure><p>参数:</p><ul><li>RectF oval：生成椭圆的矩形。</li><li>Path.Direction：路径的生成方向。</li></ul><p>示例：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-4c670d0f471cfd02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mPath = new Path();</div><div class="line">mPath.addOval(new RectF(100, 100, 300, 200), Path.Direction.CCW);</div><div class="line"></div><div class="line">canvas.drawPath(mPath, mPaint);</div></pre></td></tr></table></figure><h4 id="5-添加弧形路径"><a href="#5-添加弧形路径" class="headerlink" title="5.添加弧形路径"></a>5.添加弧形路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void addArc(float left, float top, float right, float bottom, </div><div class="line">            float startAngle, float sweepAngle)</div><div class="line">void addArc(RectF oval, float startAngle, float sweepAngle)</div></pre></td></tr></table></figure><p>参数:</p><ul><li>RectF oval：弧是椭圆的一部分，这个参数就是生成椭圆的矩形。 </li><li>float startAngle：弧开始的角度，以 X 轴正方向为 0°。</li><li>float sweepAngel：弧持续的角度。</li></ul><p>示例：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-e199e6473c71e84a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mPath.addArc(new RectF(100, 100, 300, 200), 0, 180);</div><div class="line">canvas.drawPath(mPath, mPaint);</div></pre></td></tr></table></figure><p><div id="jump5"></div></p><h3 id="1-2-5-填充模式"><a href="#1-2-5-填充模式" class="headerlink" title="1.2.5 填充模式"></a>1.2.5 填充模式</h3><p>Path 的填充模式与 Paint 的填充模式不同。Path 的填充模式是指填充 Path 的哪部分。Path.FillType 表示 Path 的填充模式，它有 4 个枚举值。</p><ul><li>FillType.WINDING：默认值，当两个图形相交时，取相交和自身部分显示。 </li><li>FillType.EVEN_ODD：取 path 所在并不相交的区域。</li><li>FillType.INVERSE_WINDING：取 path 的外部区域。</li><li>FillType.INVERSE_EVEN_ODD：取 path 的外部和相交区域。</li></ul><p>Inverse 就是取反的意思，所以 FillType.INVERSE_WINDING 就是取 FillType.WINDING 的相反部分；同理，FillType.INVERSE_EVEN_ODD 就是取 FillType.EVEN_ODD 的相反部分。</p><p>示例：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-fa947014b8824235.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">mPaint = new Paint();</div><div class="line">mPaint.setColor(Color.RED);</div><div class="line">mPaint.setStyle(Paint.Style.FILL);</div><div class="line">mPaint.setAntiAlias(true);</div><div class="line"></div><div class="line">mPath = new Path();</div><div class="line">mPath.addRect(100, 100, 300, 300, Path.Direction.CW);</div><div class="line">mPath.addCircle(300, 300, 100, Path.Direction.CW);</div><div class="line">mPath.setFillType(Path.FillType.INVERSE_EVEN_ODD);</div><div class="line"></div><div class="line">canvas.drawPath(mPath, mPaint);</div></pre></td></tr></table></figure><p><div id="jump6"></div></p><h3 id="1-2-6-重置路径"><a href="#1-2-6-重置路径" class="headerlink" title="1.2.6 重置路径"></a>1.2.6 重置路径</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><p>当我们需要重绘一条全新的路径时，Android 开发人员为了重复利用空间，允许我们重置路径对象。路径对象一旦被重置，其中保存的所有路径都将被清空，这样我们就不需要重新定义一个路径对象了。重新定义路径对象的问题在于老对象的回收和新对象的内存分配，当然这些过程都是会消耗手机性能的。</p><p>系统提供了两个重置路径的方法，分别是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void reset();</div><div class="line">void rewind();</div></pre></td></tr></table></figure></p><p>这两个函数的共同点是都会清空内部所保存的所有路径，但二者也有区别。</p><ul><li>rewind()函数会清除 FillType 及所有的直线、曲线、点的数据等，但是会保留数据结构。 这样可以实现快速重用，提高一定的性能。例如，重复绘制一类线段，它们的点的数量都相等，那么使用 rewind()函数可以保留装载点数据的数据结构，效率会更高。一定要注意的是，只有在重复绘制相同的路径时，这些数据结构才是可以复用的。</li><li>reset()函数类似于新建一个路径对象，它的所有数据空间都会被回收并重新分配，但不会清除 FillType。</li></ul><h4 id="2-reset-与-FillType"><a href="#2-reset-与-FillType" class="headerlink" title="2.reset()与 FillType"></a>2.reset()与 FillType</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mPath.setFillType(Path.FillType.INVERSE_WINDING);</div><div class="line">mPath.reset();</div><div class="line">mPath.addCircle(100, 100, 50, Path.Direction.CW);</div><div class="line"></div><div class="line">canvas.drawPath(mPath, mPaint);</div></pre></td></tr></table></figure><p>效果如下：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-8148a61181bf97db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="reset 不清除 FillType"></p><p>把 reset()改成 rewind()。效果如下：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-8112a78ff86dbea8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="rewind 清除 FillType"></p><p><div id="jump7"></div></p><h3 id="1-2-7-示例：蜘蛛网状图"><a href="#1-2-7-示例：蜘蛛网状图" class="headerlink" title="1.2.7 示例：蜘蛛网状图"></a>1.2.7 示例：蜘蛛网状图</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-69b3cadcd1005e2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网游职业分析图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.content.Context;</div><div class="line">import android.graphics.Canvas;</div><div class="line">import android.graphics.Color;</div><div class="line">import android.graphics.Paint;</div><div class="line">import android.graphics.Path;</div><div class="line">import android.util.AttributeSet;</div><div class="line">import android.view.View;</div><div class="line"></div><div class="line">import androidx.annotation.Nullable;</div><div class="line"></div><div class="line">public class SpiderView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mRadarPaint;                  // 蜘蛛网</div><div class="line">    private Paint mRadarLinePaint;              // 蜘蛛网辐射的六根线</div><div class="line">    private Paint mValuePaint;                  // 数据</div><div class="line"></div><div class="line">    private float radius;                       // 网格最大半径</div><div class="line">    private int centerX;                        // 中心 X</div><div class="line">    private int centerY;                        // 中心 Y</div><div class="line"></div><div class="line">    private Path mPath;</div><div class="line">    private int mRadarPaintColor = 0xFF0099CC;  // 网格默认颜色</div><div class="line"></div><div class="line">    private int count = 6;                      // 多边形，默认值为 6</div><div class="line">    private double angle = 2*Math.PI / count;   // 角度，值为 2π / count，默认</div><div class="line"></div><div class="line">    private double[] data = &#123;2,3,1,3,4,3&#125;;      // 数据</div><div class="line">    private int maxValue = 4;                   // 最大值</div><div class="line"></div><div class="line">    public SpiderView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        mRadarPaint = generatePaint(mRadarPaintColor, Paint.Style.FILL);</div><div class="line">        mRadarLinePaint = generatePaint(Color.WHITE, Paint.Style.STROKE);</div><div class="line">        mValuePaint = generatePaint(0xAFFF0000, Paint.Style.FILL);</div><div class="line"></div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Paint generatePaint(int color, Paint.Style style) &#123;</div><div class="line">        Paint paint = new Paint();</div><div class="line">        paint.setColor(color);</div><div class="line">        paint.setStyle(style);</div><div class="line">        paint.setAntiAlias(true);</div><div class="line">        return paint;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</div><div class="line">        // 获得布局中心</div><div class="line">        centerX = w / 2;</div><div class="line">        centerY = h / 2;</div><div class="line">        radius = Math.min(w, h) / 2f * 0.8f;</div><div class="line">        postInvalidate();</div><div class="line">        super.onSizeChanged(w, h, oldw, oldh);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        // 绘制蜘蛛网格</div><div class="line">        drawPolygon(canvas);</div><div class="line">        // 绘制中线</div><div class="line">        drawLines(canvas);</div><div class="line">        // 画数据图</div><div class="line">        drawRegion(canvas);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void drawPolygon(Canvas canvas) &#123;</div><div class="line">        float r = radius / maxValue;            // r是蜘蛛丝之间的间距</div><div class="line">        for (int i = 1; i &lt;= maxValue; i++) &#123;   // 中心点不用绘制</div><div class="line">            float curR = r * i;                 // 当前半径</div><div class="line">            mPath.reset();</div><div class="line">            for (int j = 0; j &lt; count; j++) &#123;</div><div class="line">                if (j == 0) &#123;</div><div class="line">                    mPath.moveTo(centerX + curR, centerY);</div><div class="line">                &#125; else &#123;</div><div class="line">                    // 根据半径，计算出蜘蛛丝上每个点的坐标</div><div class="line">                    float x = (float) (centerX + curR * Math.cos(angle * j));</div><div class="line">                    float y = (float) (centerY + curR * Math.sin(angle * j));</div><div class="line">                    mPath.lineTo(x, y);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            mPath.close();                      // 闭合路径</div><div class="line">            mRadarPaint.setAlpha(getRadarPaintColor(i));</div><div class="line">            canvas.drawPath(mPath, mRadarPaint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void drawLines(Canvas canvas) &#123;</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            mPath.reset();</div><div class="line">            mPath.moveTo(centerX, centerY);</div><div class="line">            float x = (float) (centerX + radius * Math.cos(angle * i));</div><div class="line">            float y = (float) (centerY + radius * Math.sin(angle * i));</div><div class="line">            mPath.lineTo(x, y);</div><div class="line">            canvas.drawPath(mPath, mRadarLinePaint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void drawRegion(Canvas canvas) &#123;</div><div class="line">        mPath.reset();</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            double percent = data[i] / maxValue;</div><div class="line">            float x = (float) (centerX + radius * Math.cos(angle * i) * percent);</div><div class="line">            float y = (float) (centerY + radius * Math.sin(angle * i) * percent);</div><div class="line">            if (i == 0) &#123;</div><div class="line">                mPath.moveTo(x, centerY);</div><div class="line">            &#125; else &#123;</div><div class="line">                mPath.lineTo(x, y);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        canvas.drawPath(mPath, mValuePaint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 由内到外，增加透明度</div><div class="line">     * @param i 第几个网格，从中心点算起</div><div class="line">     * @return int alpha 值</div><div class="line">     */</div><div class="line">    private int getRadarPaintColor(int i) &#123;</div><div class="line">        if (i &gt; count || i &lt; 1) &#123;</div><div class="line">            return 0xFF;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int alpha = Color.alpha(mRadarPaintColor);</div><div class="line">        int colorStep = alpha / (maxValue - 1) - 10;</div><div class="line">        alpha = alpha - colorStep * (i - 1);</div><div class="line">        return alpha;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14186083-fe69087af1ef71e7.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01.1 精通自定义 View 之绘图基础——基本图形绘制</title>
      <link href="/2019/07/01/05%20CUSTOM%20VIEW/01.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/"/>
      <url>/2019/07/01/05%20CUSTOM%20VIEW/01.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-40be45da319968c1.gif?imageMogr2/auto-orient/strip" width="100%"></p><blockquote><p><a href="https://xianxiaotao.github.io/2200/01/01/05%20CUSTOM%20VIEW/00%20Android%20自定义控件%20目录/" target="_blank" rel="external">返回自定义 View 目录</a></p></blockquote><p><div id="jump1"></div></p><h3 id="1-1-1-概述"><a href="#1-1-1-概述" class="headerlink" title="1.1.1 概述"></a>1.1.1 概述</h3><p>画图需要两个工具：纸和笔。在 Android 中，Paint 类就是画笔，而 Canvas 类就是纸，在这里叫作画布。</p><p>凡是跟画笔设置相关的，比如画笔大小、粗细、画笔颜色、透明度、字体的样式等，都在 Paint 类里设置；同样，凡是要画出成品的东西，比如圆形、矩形、文字等，都调用 Canvas 类里的函数生成。</p><p>示例：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-feca6c269f8bed9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        // 设置画笔</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(50);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        // 画圆</div><div class="line">        canvas.drawCircle(200, 200, 150, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>直接在主布局中使用自定义控件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line">    &lt;com.xxt.xtest.TestView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot; /&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><blockquote><p>在 onDraw() 函数中不能创建变量。因为当需要重绘时就会调用 onDraw() 函数，这样会导致变量一直被重复创建，会引起频繁的程序 GC (回收内存)，进而引起程序卡顿。一般在构造函数中创建变量。</p></blockquote><p><div id="jump2"></div></p><h3 id="1-1-2-画笔的基本设置"><a href="#1-1-2-画笔的基本设置" class="headerlink" title="1.1.2 画笔的基本设置"></a>1.1.2 画笔的基本设置</h3><h4 id="1-setAntiAlias"><a href="#1-setAntiAlias" class="headerlink" title="1. setAntiAlias()"></a>1. setAntiAlias()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void setAntiAlias(boolean aa)</div></pre></td></tr></table></figure><p>表示是否打开抗锯齿功能。抗锯齿是依赖算法的，一般在绘制不规则的图形时使用，比如圆形、文字等。在绘制棱角分明的图像时，比如一个矩形、一张位图，是不需要打开抗锯齿功能的。</p><p>示例：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-8627a3c3392a00a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Anti Alias &amp; No Anti Alias"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint1, mPaint2;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint1 = new Paint();</div><div class="line">        mPaint1.setColor(Color.RED);</div><div class="line">        mPaint1.setStyle(Paint.Style.FILL);</div><div class="line">        mPaint1.setAntiAlias(true);</div><div class="line">        mPaint1.setStrokeWidth(50);</div><div class="line"></div><div class="line">        mPaint2 = new Paint();</div><div class="line">        mPaint2.setColor(Color.RED);</div><div class="line">        mPaint2.setStyle(Paint.Style.FILL);</div><div class="line">        mPaint2.setStrokeWidth(50);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        canvas.drawCircle(200, 200, 150, mPaint1);</div><div class="line">        canvas.drawCircle(540, 200, 150, mPaint2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2-setColor"><a href="#2-setColor" class="headerlink" title="2. setColor()"></a>2. setColor()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void setColor(int color)</div></pre></td></tr></table></figure><p>设置画笔颜色。一个颜色值是由红、绿、蓝三色合成出来的，所以，参数 color 只能取 8 位的 0xAARRGGBB 样式颜色值。其中:</p><ul><li>A 代表透明度(Alpha)，取值范围是 0~255(对应十六进制的 0x00~0xFF)，取值越小，透明度越高，图像也就越透明。当取 0 时，图像完全不可见。</li><li>R 代表红色值(Red)，取值范围是 0~255(对应十六进制的 0x00~0xFF)，取值越小，红色越少。当取 0 时，表示红色完全不可见；当取 255 时，红色完全显示。</li><li>G 代表绿色值(Green)，取值范围是 0~255(对应十六进制的 0x00~0xFF)，取值越小，绿色越少。当取 0 时，表示绿色完全不可见；当取 255 时，绿色完全显示。</li><li>B 代表蓝色值(Blue)，取值范围是 0~255(对应十六进制的 0x00~0xFF)，取值越小，蓝色越少。当取 0 时，表示蓝色完全不可见；当取 255 时，蓝色完全显示。</li></ul><p>示例：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-f74c4ebbbbb616fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint1, mPaint2;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint1 = generatePaint(Color.RED, Paint.Style.FILL, 50);</div><div class="line">        mPaint2 = generatePaint(0x7EFFFF00, Paint.Style.FILL, 50);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        canvas.drawCircle(200, 200, 150, mPaint1);</div><div class="line">        canvas.drawCircle(200, 200, 100, mPaint2);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Paint generatePaint(int color, Paint.Style style, int strokeWidth) &#123;</div><div class="line">        Paint paint = new Paint();</div><div class="line">        paint.setColor(color);</div><div class="line">        paint.setStyle(style);</div><div class="line">        paint.setStrokeWidth(strokeWidth);</div><div class="line">        return paint;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3-setStyle"><a href="#3-setStyle" class="headerlink" title="3. setStyle()"></a>3. setStyle()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void setStyle(Style style)</div></pre></td></tr></table></figure><p>设置填充样式，对于文字和几何图形都有效。style 的取值如下：</p><ul><li>Paint.Style.FILL：仅填充内部。</li><li>Paint.Style.FILL_AND_STROKE：填充内部和描边。 </li><li>Paint.Style.STROKE：仅描边。</li></ul><p>示例：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-b4907639e786fbe2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="依次是 FILL、STROKE、FILL_AND_STROKE "></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">paintF = generatePaint(Color.RED, Paint.Style.FILL, 50);</div><div class="line">paintS = generatePaint(Color.RED, Paint.Style.STROKE, 50);</div><div class="line">paintFS = generatePaint(Color.RED, Paint.Style.FILL_AND_STROKE, 50);</div><div class="line">paintLine = generatePaint(Color.BLACK, Paint.Style.STROKE, 1);</div><div class="line"></div><div class="line">canvas.drawCircle(225, 300, 150, paintF);</div><div class="line">canvas.drawCircle(600, 300, 150, paintS);</div><div class="line">canvas.drawCircle(1000, 300, 150, paintFS);</div><div class="line">canvas.drawLine(225, 150, 1000, 150, paintLine);</div></pre></td></tr></table></figure><h4 id="4-setStrokeWidth"><a href="#4-setStrokeWidth" class="headerlink" title="4. setStrokeWidth()"></a>4. setStrokeWidth()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void setStrokeWidth(float width)</div></pre></td></tr></table></figure><p>设置描边宽度值，单位是 px。当画笔的 Style 样式是 STROKE、FILL_AND_STROKE 时有效。当 Style 不起作用时，用于设置画笔宽度。</p><p><div id="jump3"></div></p><h3 id="1-1-3-Canvas使用基础"><a href="#1-1-3-Canvas使用基础" class="headerlink" title="1.1.3 Canvas使用基础"></a>1.1.3 Canvas使用基础</h3><h4 id="1-画布背景设置"><a href="#1-画布背景设置" class="headerlink" title="1. 画布背景设置"></a>1. 画布背景设置</h4><p>有三种方法可以实现画布背景设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void drawColor(int color)</div><div class="line">void drawARGB(int a, int r, int g, int b)</div><div class="line">void drawRGB(int r, int g, int b)</div></pre></td></tr></table></figure></p><p>drawColor() 函数中参数 color 的取值必须是 8 位的 0xAARRGGBB 样式颜色值。<br>drawARGB() 函数允许分别传入 A、R、G、B 分量，每个颜色值的取值范围都是 0~255(对应十六进制的 0x00~0xFF)，内部会通过这些颜色分量构造出对应的颜色值。 drawRGB() 函数只允许传入 R、G、B 分量，透明度 Alpha 的值取 255。</p><p>示例：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-b1bc19b811eb6ed6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="将画布默认填充为紫色"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">canvas.drawColor(0xFFFF00FF);</div><div class="line">canvas.drawARGB(0xFF, 0xFF, 0, 0xFF);</div><div class="line">canvas.drawRGB(255, 0, 255);</div></pre></td></tr></table></figure><h4 id="2-画直线"><a href="#2-画直线" class="headerlink" title="2. 画直线"></a>2. 画直线</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void drawLine(float startX, float startY, </div><div class="line">              float stopX, float stopY, Paint paint)</div></pre></td></tr></table></figure><p>参数:</p><ul><li>startX：起始点 X 坐标。 </li><li>startY：起始点 Y 坐标。 </li><li>stopX：终点 X 坐标。</li><li>stopY：终点 Y 坐标。</li></ul><p>示例：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-030dd0332aa4b222.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分别设置 Style：FILL、STROKE、FILL_AND_STROKE"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mPaintF = generatePaint(Color.RED, Paint.Style.FILL, 50);</div><div class="line">mPaintS = generatePaint(Color.RED, Paint.Style.STROKE, 50);</div><div class="line">mPaintFS = generatePaint(Color.RED, Paint.Style.FILL_AND_STROKE, 50);</div></pre></td></tr></table></figure><p>从效果图中可以明显看出，直线的粗细与画笔 Style 是没有关系的。当设置不同的 StrokeWidth 时，效果如下图所示。<br><img src="https://upload-images.jianshu.io/upload_images/14186083-db784ea910444557.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="width 分别是 ：5、25、50"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mPaintF = generatePaint(Color.RED, Paint.Style.FILL, 5);</div><div class="line">mPaintS = generatePaint(Color.RED, Paint.Style.STROKE, 25);</div><div class="line">mPaintFS = generatePaint(Color.RED, Paint.Style.FILL_AND_STROKE, 50);</div></pre></td></tr></table></figure><blockquote><p>可见，直线的粗细是与 paint.setStrokeWidth 有直接关系的。所以，一般而言，paint.setStrokeWidth 在 Style 起作用时，用于设置描边宽度；在 Style 不起作用时，用于设置画笔宽度。</p></blockquote><h4 id="3-多条直线"><a href="#3-多条直线" class="headerlink" title="3. 多条直线"></a>3. 多条直线</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void drawLines(float[] pts, Paint paint)</div></pre></td></tr></table></figure><p>参数：<br>pts：点的集合。从下面的代码中可以看到，这里不是形成连接线，而是每两个点形成一条直线，pts 的组织方式 {x1,y1,x2,y2,x3,y3,…}。</p><p>示例：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-39da8a748e08370e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mPaint = new Paint();</div><div class="line">mPaint.setColor(Color.RED);</div><div class="line">mPaint.setStrokeWidth(5);</div><div class="line">float []pts = &#123;10,10,100,100,200,200,400,400&#125;;</div><div class="line"></div><div class="line">// onDraw()</div><div class="line">canvas.drawLines(pts, mPaint);</div></pre></td></tr></table></figure><blockquote><p>上面有 4 个点，分别是(10,10)、(100,100)、(200,200)和(400,400)，两两连成一条直线。</p></blockquote><p>另一个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void drawLines(float[] pts, int offset, int count, Paint paint)</div></pre></td></tr></table></figure></p><p>相比上面的构造函数，这里多了两个参数。</p><ul><li>int offset：集合中跳过的数值个数。注意不是点的个数！一个点有两个数值。</li><li>int count：参与绘制的数值个数，指 pts 数组中数值的个数，而不是点的个数，因为一个点有两个数值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">float[] pts = &#123;10,10,100,100,200,200,400,400&#125;;</div><div class="line">canvas.drawLines(pts, 2, 4, paint);</div></pre></td></tr></table></figure><p>表示从 pts 数组中索引为 2 的数字开始绘图，有 4 个数值参与绘图，也就是点(100,100) 和(200,200)，所以效果图就是这两个点的连线。</p><h4 id="4-点"><a href="#4-点" class="headerlink" title="4. 点"></a>4. 点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void drawPoint(float x, float y, Paint paint)</div></pre></td></tr></table></figure><p>示例：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-ddcb9989afa74a0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mPaint = new Paint();</div><div class="line">mPaint.setColor(Color.RED);</div><div class="line">mPaint.setStrokeWidth(15);</div><div class="line"></div><div class="line">canvas.drawPoint(100, 100, mPaint);</div></pre></td></tr></table></figure><p>在(100,100)位置画一个点。同样，点的大小只与 paint.setStrokeWidth(width) 有关，而与 paint.setStyle 无关。</p><h4 id="5-多个点"><a href="#5-多个点" class="headerlink" title="5. 多个点"></a>5. 多个点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void drawPoints(@Size(multiple = 2) @NonNull float[] pts, @NonNull Paint paint)</div><div class="line">void drawPoints(@Size(multiple = 2) float[] pts, int offset, int count,</div><div class="line">                @NonNull Paint paint)</div></pre></td></tr></table></figure><p>这几个参数的含义与多条直线中的参数含义相同。</p><ul><li>float[] pts：点的合集，与上面的直线一致，样式为{x1,y1,x2,y2,x3,y3,…}。</li><li>int offset：集合中跳过的数值个数。注意不是点的个数！一个点有两个数值。</li><li>int count：参与绘制的数值个数，指 pts 数组中数值的个数，而不是点的个数。</li></ul><p>示例：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-c592a6c5a27809f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private Paint mPaint;</div><div class="line">float[] pts = &#123;10,10, 100,100, 200,200, 400,400&#125;;</div><div class="line"></div><div class="line">mPaint = new Paint();</div><div class="line">mPaint.setColor(Color.RED);</div><div class="line">mPaint.setStrokeWidth(15);</div><div class="line"></div><div class="line">canvas.drawPoints(pts, 2, 4, mPaint);</div></pre></td></tr></table></figure><p>同样是上面的 4 个点：(10,10)、(100,100)、(200,200)和(400,400)，在 drawPoints()函数里跳过前两个数值，即第一个点的横、纵坐标，画出后面 4 个数值代表的点，即第二、三个点，第四个点没画。</p><h4 id="6-RectF-amp-Rect"><a href="#6-RectF-amp-Rect" class="headerlink" title="6. RectF &amp; Rect"></a>6. RectF &amp; Rect</h4><p>这两个类都是矩形工具类，根据 4 个点构造出一个矩形结构。RectF 与 Rect 中的方法、 成员变量完全一样，唯一不同的是：RectF 是用来保存 float 类型数值的矩形结构的；而 Rect 是用来保存 int 类型数值的矩形结构的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// RectF 的构造函数有如下 4 个,但最常用的还是第二个</div><div class="line">RectF()</div><div class="line">RectF(float left, float top, float right, float bottom)</div><div class="line">RectF(RectF r)</div><div class="line">RectF(Rect r)</div><div class="line"></div><div class="line">// Rect 的构造函数有如下 3 个</div><div class="line">Rect()</div><div class="line">Rect(int left, int top, int right, int bottom)</div><div class="line">Rect(Rect r)</div></pre></td></tr></table></figure></p><p>一般而言，要构造一个矩形结构,可以通过以下两种方法来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 方法一：直接构造</div><div class="line">Rect rect = new Rect(10,10,100,100); </div><div class="line">// 方法二：间接构造</div><div class="line">Rect rect = new Rect(); </div><div class="line">rect.set(10,10,100,100);</div></pre></td></tr></table></figure></p><h4 id="7-矩形"><a href="#7-矩形" class="headerlink" title="7. 矩形"></a>7. 矩形</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void drawRect(float left, float top, float right, float bottom, Paint paint) </div><div class="line">void drawRect(RectF rect, Paint paint)</div><div class="line">void drawRect(Rect r, Paint paint)</div></pre></td></tr></table></figure><p>第一个函数是直接传入矩形的 4 个点来绘制矩形的；第二、三个函数是根据传入 RectF 或者 Rect 的矩形变量来指定所绘制的矩形的。</p><p>示例：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-d9020d42098b847c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mPaintS = generatePaint(Color.RED, Paint.Style.STROKE, 15);</div><div class="line">mPaintF = generatePaint(Color.RED, Paint.Style.FILL, 15);</div><div class="line">mRect = new RectF(210f, 10f, 300f, 100f);</div><div class="line"></div><div class="line">// 直接构造</div><div class="line">canvas.drawRect(10, 10, 100, 100, mPaintS);</div><div class="line">// 使用 RectF 构造</div><div class="line">canvas.drawRect(mRect, mPaintF);</div></pre></td></tr></table></figure><h4 id="8-圆角矩形"><a href="#8-圆角矩形" class="headerlink" title="8. 圆角矩形"></a>8. 圆角矩形</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void drawRoundRect(RectF rect, float rx, float ry, Paint paint)</div></pre></td></tr></table></figure><p>参数:</p><ul><li>RectF rect：要绘制的矩形。</li><li>float rx：生成圆角的椭圆的 X 轴半径。 </li><li>float ry：生成圆角的椭圆的 Y 轴半径。</li></ul><p>示例：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-404c86eeaca6b3fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="圆角矩形效果图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mPaintF = generatePaint(Color.RED, Paint.Style.FILL, 15);</div><div class="line">mRect = new RectF(100, 110, 300, 200);</div><div class="line"></div><div class="line">canvas.drawRoundRect(mRect, 20, 10, mPaintF);</div></pre></td></tr></table></figure><h4 id="9-圆形"><a href="#9-圆形" class="headerlink" title="9. 圆形"></a>9. 圆形</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void drawCircle(float cx, float cy, float radius, Paint paint)</div></pre></td></tr></table></figure><p>参数:</p><ul><li>float cx：圆心点的 X 轴坐标。 </li><li>float cy：圆心点的 Y 轴坐标。 </li><li>float radius：圆的半径。</li></ul><h4 id="10-椭圆"><a href="#10-椭圆" class="headerlink" title="10. 椭圆"></a>10. 椭圆</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void drawOval(RectF oval, Paint paint)</div></pre></td></tr></table></figure><p>参数:<br>RectF oval：用来生成椭圆的矩形。</p><p>椭圆是根据矩形生成的，以矩形的长为椭圆的 X 轴，以矩形的宽为椭圆的 Y 轴。</p><p>示例：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-eaaa7da91d7639af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用矩形画椭圆"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mPaintO = generatePaint(Color.RED, Paint.Style.STROKE, 5);</div><div class="line">mPaintR = generatePaint(Color.BLUE, Paint.Style.STROKE, 5);</div><div class="line">mRect = new RectF(100, 110, 300, 200);</div><div class="line"></div><div class="line">canvas.drawRect(mRect, mPaintR);    // 画矩形</div><div class="line">canvas.drawOval(mRect, mPaintO);    // 画椭圆</div></pre></td></tr></table></figure><h4 id="11-弧"><a href="#11-弧" class="headerlink" title="11. 弧"></a>11. 弧</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void drawArc(RectF oval, float startAngle, float sweepAngle, </div><div class="line">             boolean useCenter, Paint paint)</div></pre></td></tr></table></figure><p>参数:</p><ul><li>RectF oval：生成椭圆的矩形。</li><li>float startAngle：弧开始的角度，以 X 轴正方向为 0°。</li><li>float sweepAngle：弧持续的角度。</li><li>boolean useCenter：是否有弧的两边。为 true 时，表示带有两边；为 false 时，只有一条弧。</li></ul><p>示例：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-db6075c61545f92a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="弧 效果图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mPaint = generatePaint(Color.RED, Paint.Style.STROKE, 5);</div><div class="line">mRect1 = new RectF(100, 100, 200, 200);</div><div class="line">mRect2 = new RectF(220, 100, 320, 200);</div><div class="line"></div><div class="line">// 带弧的两边</div><div class="line">canvas.drawArc(mRect1, 0, 90, true, mPaint);</div><div class="line">// 不带弧的两边</div><div class="line">canvas.drawArc(mRect2, 0, 90, false, mPaint);</div></pre></td></tr></table></figure><p>上述代码中，仅将 paint 的样式设置为 FILL 。效果图如下：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-70fd46d585c02d0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="填充样式的弧"></p><blockquote><p>当画笔设为填充模式时，填充区域只限于圆弧的起始点和终点所形成的区域。当带有两边时，会将两边及圆弧内部全部填充；如果没有两边，则只填充圆弧部分。</p></blockquote><p><div id="jump4"></div></p><h3 id="1-1-4-Rect与RectF"><a href="#1-1-4-Rect与RectF" class="headerlink" title="1.1.4 Rect与RectF"></a>1.1.4 Rect与RectF</h3><h4 id="1-是否包含点、矩形"><a href="#1-是否包含点、矩形" class="headerlink" title="1.是否包含点、矩形"></a>1.是否包含点、矩形</h4><p>1）判断是否包含某个点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean contains(int x, int y)</div></pre></td></tr></table></figure></p><p>该函数用于判断某个点是否在当前矩形中。如果在，则返回 true；如果不在，则返回 false。 参数(x,y)就是当前要判断的点的坐标。</p><p>示例：绘制一个灰色矩形，当手指在这个矩形区域内时，矩形变为红色。<br><img src="https://upload-images.jianshu.io/upload_images/14186083-87a0fbfd0c9002cd.gif?imageMogr2/auto-orient/strip" alt="效果图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private float mX, mY;</div><div class="line">    private Paint mPaint;</div><div class="line">    private RectF mRect;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setStyle(Paint.Style.FILL);</div><div class="line">        mRect = new RectF(100, 100, 500, 350);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        if (mRect.contains(mX, mY)) &#123;</div><div class="line">            mPaint.setColor(Color.RED);</div><div class="line">        &#125; else &#123;</div><div class="line">            mPaint.setColor(Color.GRAY);</div><div class="line">        &#125;</div><div class="line">        canvas.drawRect(mRect, mPaint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        mX = event.getX();</div><div class="line">        mY = event.getY();</div><div class="line">        if (event.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">            invalidate();</div><div class="line">            return true;</div><div class="line">        &#125; else if (event.getAction() == MotionEvent.ACTION_UP) &#123;</div><div class="line">            mX = -1;</div><div class="line">            mY = -1;</div><div class="line">        &#125;</div><div class="line">        invalidate();</div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述代码注意两点：</p><ul><li><p>在 MotionEvent.ACTION_DOWN 中返回 true，因为当 MotionEvent. ACTION_DOWN 消息到来时，系统会判断返回值，当返回 true 时，表示当前控件已经在拦截 (消费)这个消息了，所以后续的 ACTION_MOVE、ACTION_UP 消息仍然继续传过来。如果返回 false(系统默认返回 false)，就表示当前控件不需要这个消息，那么后续的 ACTION_MOVE、ACTION_UP 消息就不会再传到这个控件。</p></li><li><p>postInvalidate() 和 invalidate() 函数都是用来重绘控件的，区别是 invalidate() 函数一定要在主线程中执行，否则就会报错；而 postInvalidate() 函数则没有那么多讲究，它可以在任何线程中执行，而不必一定是主线程。因为在 postInvalidate() 函数中就是利用 handler 给主线程发送刷新界面的消息来实现的，所以它可以在任何线程中执行而不会出错。而正因为它是通过发送消息来实现的，所以它的界面刷新速度可能没有直接调用 invalidate() 函数那么快。确定当前线程是主线程的情况下，以 invalidate() 函数为主。否则调用调用 postInvalidate() 函数为好。因为 onTouchEvent() 函数本来就是在主线程中的，所以使用 invalidate() 函数更合适。</p></li></ul><p>2）判断是否包含某个矩形<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 根据矩形的 4 个点或者一个 Rect 矩形对象来判断这个矩形是否在当前的矩形区域内。</div><div class="line">boolean contains(float left, float top, float right, float bottom)</div><div class="line">boolean contains(RectF r)</div></pre></td></tr></table></figure></p><h4 id="2-判断两个矩形是否相交"><a href="#2-判断两个矩形是否相交" class="headerlink" title="2.判断两个矩形是否相交"></a>2.判断两个矩形是否相交</h4><p>1）静态方法判断是否相交<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static boolean intersects(Rect a, Rect b)</div></pre></td></tr></table></figure></p><p>这是 Rect 类的一个静态方法，用来判断参数中所传入的两个 Rect 矩形是否相交，如果相交则返回 true，否则返回 false。<br>2）成员方法判断是否相交<br>判断当前 Rect 对象与其他矩形是否相交。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean intersects(int left, int top, int right, int bottom)</div></pre></td></tr></table></figure></p><p>使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Rect rect_1 = new Rect(10,10,200,200);</div><div class="line">boolean interset1_2 = rect_1.intersects(190, 10, 250, 200);</div></pre></td></tr></table></figure></p><p>3）判断相交并返回结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">boolean intersect(int left, int top, int right, int bottom)</div><div class="line">boolean intersect(Rect r)</div></pre></td></tr></table></figure></p><p>这两个成员方法与 intersects()方法的区别是，不仅会返回是否相交的结果，而且会把相交部分的矩形赋给当前 Rect 对象。如果两个矩形不相交，则当前 Rect 对象的值不变。</p><h4 id="3-合并"><a href="#3-合并" class="headerlink" title="3.合并"></a>3.合并</h4><p>1）合并两个矩形<br>合并两个矩形的意思就是将两个矩形合并成一个矩形，即无论这两个矩形是否相交，取两个矩形最小左上角点作为结果矩形的左上角点，取两个矩形最大右下角点作为结果矩形的右下角点。如果要合并的两个矩形有一方为空，则将有值的一方作为最终结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public void union(int left, int top, int right, int bottom)</div><div class="line">public void union(Rect r)</div></pre></td></tr></table></figure></p><p>示例：<br><img src="https://upload-images.jianshu.io/upload_images/14186083-03ed1ceee71fd5c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="绿色、红色矩形合并成蓝色矩形"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">mPaint = new Paint();</div><div class="line">mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">mRect1 = new RectF(200, 100, 500, 300);</div><div class="line">mRect2 = new RectF(100, 200, 300, 400);</div><div class="line"></div><div class="line">// 画出右上的红色矩形</div><div class="line">mPaint.setColor(Color.RED);</div><div class="line">canvas.drawRect(mRect1, mPaint);</div><div class="line">// 画出左下的绿色矩形</div><div class="line">mPaint.setColor(Color.GREEN);</div><div class="line">canvas.drawRect(mRect2, mPaint);</div><div class="line">// 矩形合并</div><div class="line">mRect1.union(mRect2);</div><div class="line">// 画出合并后的矩形（蓝色部分）</div><div class="line">mPaint.setColor(Color.BLUE);</div><div class="line">canvas.drawRect(mRect1, mPaint);</div></pre></td></tr></table></figure><p>2）合并矩形与某个点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void union(int x, int y)</div></pre></td></tr></table></figure></p><p>先判断当前矩形与目标合并点的关系。如果不相交，则根据目标点(x,y)的位置，将目标点设置为当前矩形的左上角点或者右下角点。如果当前矩形是一个空矩形，则最后的结果矩形为([0,0],[x,y])，即结果矩形的左上角点为[0,0]，右下角点为[x,y]。</p><p><div id="jump5"></div></p><h3 id="1-1-5-Color"><a href="#1-1-5-Color" class="headerlink" title="1.1.5 Color"></a>1.1.5 Color</h3><p>Color 是 Android 中与颜色处理有关的类。</p><h4 id="1-常量颜色"><a href="#1-常量颜色" class="headerlink" title="1. 常量颜色"></a>1. 常量颜色</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@ColorInt public static final int BLACK       = 0xFF000000;</div><div class="line">@ColorInt public static final int DKGRAY      = 0xFF444444;</div><div class="line">@ColorInt public static final int GRAY        = 0xFF888888;</div><div class="line">@ColorInt public static final int LTGRAY      = 0xFFCCCCCC;</div><div class="line">@ColorInt public static final int WHITE       = 0xFFFFFFFF;</div><div class="line">@ColorInt public static final int RED         = 0xFFFF0000;</div><div class="line">@ColorInt public static final int GREEN       = 0xFF00FF00;</div><div class="line">@ColorInt public static final int BLUE        = 0xFF0000FF;</div><div class="line">@ColorInt public static final int YELLOW      = 0xFFFFFF00;</div><div class="line">@ColorInt public static final int CYAN        = 0xFF00FFFF;</div><div class="line">@ColorInt public static final int MAGENTA     = 0xFFFF00FF;</div><div class="line">@ColorInt public static final int TRANSPARENT = 0;</div></pre></td></tr></table></figure><p>Color.XXX 来直接使用这些颜色，比如红色：Color.RED。</p><h4 id="2-构造颜色"><a href="#2-构造颜色" class="headerlink" title="2. 构造颜色"></a>2. 构造颜色</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 带有透明度的颜色</div><div class="line">static int argb(int alpha, int red, int green, int blue)</div><div class="line">// 不带透明度的颜色：alpha 值取 255</div><div class="line">static int rgb(int red, int green, int blue)</div></pre></td></tr></table></figure><p>argb() 函数的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static int argb(int alpha, int red, int green, int blue) &#123;</div><div class="line">    // 位运算，值得借鉴</div><div class="line">    return (alpha &lt;&lt; 24) | (red &lt;&lt; 16) | (green &lt;&lt; 8) | blue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="3-提取颜色分量"><a href="#3-提取颜色分量" class="headerlink" title="3. 提取颜色分量"></a>3. 提取颜色分量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static int alpha(int color)</div><div class="line">static int red(int color)</div><div class="line">static int green(int color)</div><div class="line">static int blue(int color)</div></pre></td></tr></table></figure><p>通过上面的 4 个函数提取出对应的 A、R、G、B 颜色分量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 得到的结果 green 的值就是 0x0F</div><div class="line">int green = Color.green(0xFF000F00);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-233538f41fd3a277.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Custom View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ANDROID 目录</title>
      <link href="/2017/06/03/03%20ANDROID/00Catalog/"/>
      <url>/2017/06/03/03%20ANDROID/00Catalog/</url>
      
        <content type="html"><![CDATA[<p>ANDROID 基础知识、中级知识结构目录…</p><h2 id="二、Android中级知识"><a href="#二、Android中级知识" class="headerlink" title="二、Android中级知识"></a>二、Android中级知识</h2><ul><li><a href="">01 Android安全系列篇一(加密、密钥、签名和证书)</a></li></ul><h2 id="一、Android基础知识"><a href="#一、Android基础知识" class="headerlink" title="一、Android基础知识"></a>一、Android基础知识</h2><ul><li><a href="https://xianxiaotao.github.io/2017/05/30/ANDROID/BASE/15%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6Layout/" target="_blank" rel="external">15 代码控制Layout</a></li><li><a href="https://xianxiaotao.github.io/2017/05/29/ANDROID/BASE/14Fragment" target="_blank" rel="external">14 Fragment</a></li><li><a href="https://xianxiaotao.github.io/2017/05/28/ANDROID/BASE/13Android6.0%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E5%A4%84%E7%90%86/" target="_blank" rel="external">13 Android6.0运行时权限处理</a></li><li><a href="https://xianxiaotao.github.io/2017/05/28/ANDROID/BASE/12%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F/" target="_blank" rel="external">12 权限系统</a></li><li><a href="https://xianxiaotao.github.io/2017/05/28/ANDROID/BASE/11%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/" target="_blank" rel="external">11 日志系统</a></li><li><a href="https://xianxiaotao.github.io/2017/05/28/ANDROID/BASE/10BroadcastReceiver/" target="_blank" rel="external">10 BroadcastReceiver</a></li><li><a href="https://xianxiaotao.github.io/2017/05/26/ANDROID/BASE/09Service%E6%80%BB%E7%BB%93%E7%AF%87/" target="_blank" rel="external">09 Service总结篇</a></li><li><a href="https://xianxiaotao.github.io/2017/05/26/ANDROID/BASE/08Service%E9%80%9A%E4%BF%A1/" target="_blank" rel="external">08 Service通信</a></li><li><a href="https://xianxiaotao.github.io/2017/05/26/ANDROID/BASE/07Service/" target="_blank" rel="external">07 Service</a></li><li><a href="https://xianxiaotao.github.io/2017/05/24/ANDROID/BASE/06Context/" target="_blank" rel="external">06 Context</a></li><li><a href="https://xianxiaotao.github.io/2017/05/24/ANDROID/BASE/05Intent%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BA%94%E7%94%A8/" target="_blank" rel="external">05 Intent概念及应用</a></li><li><a href="https://xianxiaotao.github.io/2017/05/23/ANDROID/BASE/04Activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">04 Activity启动模式</a></li><li><a href="https://xianxiaotao.github.io/2017/05/23/ANDROID/BASE/03Activity%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/" target="_blank" rel="external">03 Activity之间传递参数</a></li><li><a href="https://xianxiaotao.github.io/2017/05/23/ANDROID/BASE/02Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" target="_blank" rel="external">02 Activity生命周期</a></li><li><a href="https://xianxiaotao.github.io/2017/05/23/ANDROID/BASE/01%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="external">01 环境搭建</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ANDROID 目录</title>
      <link href="/2017/06/01/03%20ANDROID/INTERMEDIATE/01Android%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%E7%AF%87%E4%B8%80(%E5%8A%A0%E5%AF%86%E3%80%81%E5%AF%86%E9%92%A5%E3%80%81%E7%AD%BE%E5%90%8D%E4%B8%8E%E8%AF%81%E4%B9%A6)/"/>
      <url>/2017/06/01/03%20ANDROID/INTERMEDIATE/01Android%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%E7%AF%87%E4%B8%80(%E5%8A%A0%E5%AF%86%E3%80%81%E5%AF%86%E9%92%A5%E3%80%81%E7%AD%BE%E5%90%8D%E4%B8%8E%E8%AF%81%E4%B9%A6)/</url>
      
        <content type="html"><![CDATA[<h2 id="一、安全要解决什么问题"><a href="#一、安全要解决什么问题" class="headerlink" title="一、安全要解决什么问题"></a>一、安全要解决什么问题</h2><p>在典型的场景中，安全主要用于解决4类需求：</p><h4 id="保密（Security-Confidentiality）"><a href="#保密（Security-Confidentiality）" class="headerlink" title="保密（Security/Confidentiality）"></a>保密（Security/Confidentiality）</h4><p>不希望通信中的信息被第三方窥探；密码；公司机要文件等；</p><h4 id="鉴别-认证（Authentication）"><a href="#鉴别-认证（Authentication）" class="headerlink" title="鉴别/认证（Authentication）"></a>鉴别/认证（Authentication）</h4><p>明确通信对端的身份是你认为的身份。如打电话时通过声音语气等明确对方的身份；银行柜台办理业务时，银行业务员会仔细辨别身份证照片与本人相貌以及问一些能验证身份相关的问题。</p><h4 id="完整性（Integrity）"><a href="#完整性（Integrity）" class="headerlink" title="完整性（Integrity）"></a>完整性（Integrity）</h4><p>能确定信息是否被篡改或丢失。如借钱的收据一般用大写数字，或者阿拉伯数字之间没有空格等要求，防止收据被篡改。</p><h4 id="不可否认性（non-repudiation）"><a href="#不可否认性（non-repudiation）" class="headerlink" title="不可否认性（non-repudiation）"></a>不可否认性（non-repudiation）</h4><p>能明确是谁产生，且无法被“赖掉”。如手印、指纹、皇帝诏书等。</p><h4 id="二、你都会的密码术"><a href="#二、你都会的密码术" class="headerlink" title="二、你都会的密码术"></a>二、你都会的密码术</h4>]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15 代码控制Layout</title>
      <link href="/2017/05/31/03%20ANDROID/BASE/16RecyclerView/"/>
      <url>/2017/05/31/03%20ANDROID/BASE/16RecyclerView/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15 代码控制Layout</title>
      <link href="/2017/05/30/03%20ANDROID/BASE/15%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6Layout/"/>
      <url>/2017/05/30/03%20ANDROID/BASE/15%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6Layout/</url>
      
        <content type="html"><![CDATA[<p>虽然Google官方强烈建议我们视图应该在配置文件中定义，但是我们依然得掌握使用代码来控制布局文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">package com.xianxiaotao.layout;</div><div class="line"></div><div class="line">import android.support.v7.app.AppCompatActivity;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.view.View;</div><div class="line">import android.view.ViewGroup;</div><div class="line">import android.widget.Button;</div><div class="line">import android.widget.LinearLayout;</div><div class="line"></div><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private LinearLayout rootView;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">        rootView = new LinearLayout(this);</div><div class="line">        rootView.setOrientation(LinearLayout.VERTICAL);</div><div class="line">        <span class="built_in">set</span>ContentView(rootView);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">            Button button = new Button(this);</div><div class="line">            button.setAllCaps(<span class="literal">false</span>);</div><div class="line">            button.setText(<span class="string">"Click To Remove Me"</span>);</div><div class="line">            button.setOnClickListener(new View.<span class="function"><span class="title">OnClickListener</span></span>() &#123;</div><div class="line">                @Override</div><div class="line">                public void onClick(View v) &#123;</div><div class="line">                    rootView.removeView(v);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(</div><div class="line">                    LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT );</div><div class="line">            lp.weight = 1;</div><div class="line">            rootView.addView(button, lp);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14 Fragment</title>
      <link href="/2017/05/29/03%20ANDROID/BASE/14Fragment/"/>
      <url>/2017/05/29/03%20ANDROID/BASE/14Fragment/</url>
      
        <content type="html"><![CDATA[<h2 id="一、使用Fragment"><a href="#一、使用Fragment" class="headerlink" title="一、使用Fragment"></a>一、使用Fragment</h2><h4 id="1、自定义SecondFragment"><a href="#1、自定义SecondFragment" class="headerlink" title="1、自定义SecondFragment"></a>1、自定义SecondFragment</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">package com.xianxiaotao.fragment;</div><div class="line"></div><div class="line">import android.os.Bundle;</div><div class="line">import android.support.annotation.Nullable;</div><div class="line">import android.support.v4.app.Fragment;</div><div class="line">import android.view.LayoutInflater;</div><div class="line">import android.view.View;</div><div class="line">import android.view.ViewGroup;</div><div class="line"></div><div class="line">public class SecondFragment extends Fragment &#123;</div><div class="line"></div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123;</div><div class="line">        View root = inflater.inflate(R.layout.fragment_second, container, <span class="literal">false</span>);</div><div class="line">        root.findViewById(R.id.btnBackFirstFragment).setOnClickListener(new View.<span class="function"><span class="title">OnClickListener</span></span>() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                getActivity().getSupportFragmentManager().popBackStack();   // 返回</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="built_in">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2、自定义FirstFragment"><a href="#2、自定义FirstFragment" class="headerlink" title="2、自定义FirstFragment"></a>2、自定义FirstFragment</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">package com.xianxiaotao.fragment;</div><div class="line"></div><div class="line">import android.os.Bundle;</div><div class="line">import android.support.annotation.Nullable;</div><div class="line">import android.support.v4.app.Fragment;</div><div class="line">import android.view.LayoutInflater;</div><div class="line">import android.view.View;</div><div class="line">import android.view.ViewGroup;</div><div class="line"></div><div class="line">public class FirstFragment extends Fragment &#123;</div><div class="line"></div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123;</div><div class="line">        View root = inflater.inflate(R.layout.fragment_first, container, <span class="literal">false</span>);</div><div class="line">        root.findViewById(R.id.btnStartSecondFragment).setOnClickListener(new View.<span class="function"><span class="title">OnClickListener</span></span>() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;   // SecondFragment替换当前的FirstFragment</div><div class="line">                getActivity().getSupportFragmentManager().beginTransaction()</div><div class="line">                        .addToBackStack(null)   /* 返回键返回上一个Fragment */</div><div class="line">                        .replace(R.id.container, new SecondFragment())</div><div class="line">                        .commit();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="built_in">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3、MainActivity"><a href="#3、MainActivity" class="headerlink" title="3、MainActivity"></a>3、MainActivity</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package com.xianxiaotao.fragment;</div><div class="line"></div><div class="line">import android.support.v7.app.AppCompatActivity;</div><div class="line">import android.os.Bundle;</div><div class="line"></div><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        <span class="built_in">set</span>ContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (savedInstanceState == null) &#123;</div><div class="line">            getSupportFragmentManager().beginTransaction()</div><div class="line">                    .add(R.id.container, new FirstFragment())</div><div class="line">                    .commit();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="4、布局文件activity-main-xml、fragment-first-xml-和-fragment-second-xml"><a href="#4、布局文件activity-main-xml、fragment-first-xml-和-fragment-second-xml" class="headerlink" title="4、布局文件activity_main.xml、fragment_first.xml 和 fragment_second.xml"></a>4、布局文件activity_main.xml、fragment_first.xml 和 fragment_second.xml</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</div><div class="line">&lt;FrameLayout</div><div class="line">    xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    android:id=<span class="string">"@+id/container"</span></div><div class="line">    android:layout_width=<span class="string">"match_parent"</span></div><div class="line">    android:layout_height=<span class="string">"match_parent"</span>/&gt;</div><div class="line"></div><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    android:layout_width=<span class="string">"match_parent"</span></div><div class="line">    android:layout_height=<span class="string">"match_parent"</span></div><div class="line">    android:orientation=<span class="string">"vertical"</span>&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:text=<span class="string">"This is first fragment"</span></div><div class="line">        android:layout_width=<span class="string">"match_parent"</span></div><div class="line">        android:layout_height=<span class="string">"wrap_content"</span> /&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:text=<span class="string">"Start Second Fragment"</span></div><div class="line">        android:textAllCaps=<span class="string">"false"</span></div><div class="line">        android:layout_width=<span class="string">"wrap_content"</span></div><div class="line">        android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">        android:id=<span class="string">"@+id/btnStartSecondFragment"</span>/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div><div class="line"></div><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    android:layout_width=<span class="string">"match_parent"</span></div><div class="line">    android:layout_height=<span class="string">"match_parent"</span></div><div class="line">    android:orientation=<span class="string">"vertical"</span>&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:text=<span class="string">"This is second fragment"</span></div><div class="line">        android:layout_width=<span class="string">"match_parent"</span></div><div class="line">        android:layout_height=<span class="string">"wrap_content"</span> /&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:text=<span class="string">"Go Back"</span></div><div class="line">        android:textAllCaps=<span class="string">"false"</span></div><div class="line">        android:layout_width=<span class="string">"wrap_content"</span></div><div class="line">        android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">        android:id=<span class="string">"@+id/btnBackFirstFragment"</span>/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure><h4 id="5、静态使用Fragment"><a href="#5、静态使用Fragment" class="headerlink" title="5、静态使用Fragment"></a>5、静态使用Fragment</h4><p>上述为动态的使用Fragment，静态的使用方式是在布局文件里指定使用哪个Fragment：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;fragment  </div><div class="line">    android:id=<span class="string">"@+id/fragment_first"</span>  </div><div class="line">    android:name=<span class="string">"com.xianxiaotao.FirstFragment"</span>  </div><div class="line">    android:layout_width=<span class="string">"match_parent"</span>  </div><div class="line">    android:layout_height=<span class="string">"match_parent"</span> /&gt;</div></pre></td></tr></table></figure></p><h2 id="二、Fragment的生命周期"><a href="#二、Fragment的生命周期" class="headerlink" title="二、Fragment的生命周期"></a>二、Fragment的生命周期</h2><h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p>Fragment必须是依存与Activity而存在的，因此Activity的生命周期会直接影响到Fragment的生命周期。官网这张图很好的说明了两者生命周期的关系：<br><img src="http://ww1.sinaimg.cn/large/adc90466ly1fg27lza049j209g0irdgq.jpg" alt="Fragment的生命周期"><br>可以看到Fragment比Activity多了几个额外的生命周期回调方法：<br>onAttach(Activity)<br>当Fragment与Activity发生关联时调用。<br>onCreateView(LayoutInflater, ViewGroup,Bundle)<br>创建该Fragment的视图<br>onActivityCreated(Bundle)<br>当Activity的onCreate方法返回时调用<br>onDestoryView()<br>与onCreateView想对应，当该Fragment的视图被移除时调用<br>onDetach()<br>与onAttach相对应，当Fragment与Activity关联被取消时调用<br>注意：除了onCreateView，其他的所有方法如果你重写了，必须调用父类对于该方法的实现</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>在上述Demo中每个Fragment里重写所有的生命周期方法以及MainActivity，并输出日志信息。如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onAttach(Context context) &#123;</div><div class="line">    super.onAttach(context);</div><div class="line">    System.out.println(<span class="string">"FirstFragment onAttach"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="1、启动程序，在MainActivity的onCreate方法中引用了FirstFragment。日志如下："><a href="#1、启动程序，在MainActivity的onCreate方法中引用了FirstFragment。日志如下：" class="headerlink" title="1、启动程序，在MainActivity的onCreate方法中引用了FirstFragment。日志如下："></a>1、启动程序，在MainActivity的onCreate方法中引用了FirstFragment。日志如下：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">MainActivity onCreate</div><div class="line">FirstFragment onAttach</div><div class="line">FirstFragment onCreate</div><div class="line">FirstFragment onCreateView</div><div class="line">FirstFragment onActivityCreated</div><div class="line">FirstFragment onStart</div><div class="line">MainActivity onStart</div><div class="line">MainActivity onResume</div><div class="line">FirstFragment onResume</div></pre></td></tr></table></figure><h4 id="2、Start-Second-Fragment，使用SecondFragment替换FirstFragment。日志："><a href="#2、Start-Second-Fragment，使用SecondFragment替换FirstFragment。日志：" class="headerlink" title="2、Start Second Fragment，使用SecondFragment替换FirstFragment。日志："></a>2、Start Second Fragment，使用SecondFragment替换FirstFragment。日志：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">SecondFragment onAttach</div><div class="line">SecondFragment onCreate</div><div class="line">FirstFragment onPause</div><div class="line">FirstFragment onStop</div><div class="line">FirstFragment onDestroyView</div><div class="line">SecondFragment onCreateView</div><div class="line">SecondFragment onActivityCreated</div><div class="line">SecondFragment onStart</div><div class="line">SecondFragment onResume</div></pre></td></tr></table></figure><h4 id="3、Go-Back，由SecondFragment返回到FirstFragment。日志："><a href="#3、Go-Back，由SecondFragment返回到FirstFragment。日志：" class="headerlink" title="3、Go Back，由SecondFragment返回到FirstFragment。日志："></a>3、Go Back，由SecondFragment返回到FirstFragment。日志：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">SecondFragment onPause</div><div class="line">SecondFragment onStop</div><div class="line">SecondFragment onDestroyView</div><div class="line">SecondFragment onDestroy</div><div class="line">SecondFragment onDetach</div><div class="line">FirstFragment onCreateView</div><div class="line">FirstFragment onActivityCreated</div><div class="line">FirstFragment onStart</div><div class="line">FirstFragment onResume</div></pre></td></tr></table></figure><h4 id="4、返回，即退出应用程序。日志："><a href="#4、返回，即退出应用程序。日志：" class="headerlink" title="4、返回，即退出应用程序。日志："></a>4、返回，即退出应用程序。日志：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">FirstFragment onPause</div><div class="line">MainActivity onPause</div><div class="line">FirstFragment onStop</div><div class="line">MainActivity onStop</div><div class="line">FirstFragment onDestroyView</div><div class="line">FirstFragment onDestroy</div><div class="line">FirstFragment onDetach</div><div class="line">MainActivity onDestroy</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13 Android6.0运行时权限处理</title>
      <link href="/2017/05/29/03%20ANDROID/BASE/13Android6.0%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E5%A4%84%E7%90%86/"/>
      <url>/2017/05/29/03%20ANDROID/BASE/13Android6.0%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>参考文档：</p><ul><li><a href="http://developer.android.com/intl/zh-cn/about/versions/marshmallow/android-6.0-changes.html#behavior-runtime-permissions" target="_blank" rel="external">google官方文档</a></li><li><a href="http://blog.csdn.net/lmj623565791/article/details/50709663" target="_blank" rel="external">Android 6.0 运行时权限处理完全解析</a></li><li><a href="http://blog.csdn.net/andrexpert/article/details/53331836" target="_blank" rel="external">探讨Android 6.0及以上新权限系统的检测与处理</a></li></ul><h2 id="一、新的权限机制"><a href="#一、新的权限机制" class="headerlink" title="一、新的权限机制"></a>一、新的权限机制</h2><p>Google将权限分为两类，一类是Normal Permissions，这类权限一般不涉及用户隐私，是不需要用户进行授权的，比如手机震动、访问网络等；另一类是Dangerous Permissions,一般是涉及到用户隐私的，需要用户进行授权，比如读取sdcard、访问通讯录等。</p><h4 id="Normal-Permissions"><a href="#Normal-Permissions" class="headerlink" title="Normal Permissions"></a>Normal Permissions</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">ACCESS_LOCATION_EXTRA_COMMANDS</div><div class="line">ACCESS_NETWORK_STATE</div><div class="line">ACCESS_NOTIFICATION_POLICY</div><div class="line">ACCESS_WIFI_STATE</div><div class="line">BLUETOOTH</div><div class="line">BLUETOOTH_ADMIN</div><div class="line">BROADCAST_STICKY</div><div class="line">CHANGE_NETWORK_STATE</div><div class="line">CHANGE_WIFI_MULTICAST_STATE</div><div class="line">CHANGE_WIFI_STATE</div><div class="line">DISABLE_KEYGUARD</div><div class="line">EXPAND_STATUS_BAR</div><div class="line">GET_PACKAGE_SIZE</div><div class="line">INSTALL_SHORTCUT</div><div class="line">INTERNET</div><div class="line">KILL_BACKGROUND_PROCESSES</div><div class="line">MODIFY_AUDIO_SETTINGS</div><div class="line">NFC</div><div class="line">READ_SYNC_SETTINGS</div><div class="line">READ_SYNC_STATS</div><div class="line">RECEIVE_BOOT_COMPLETED</div><div class="line">REORDER_TASKS</div><div class="line">REQUEST_INSTALL_PACKAGES</div><div class="line">SET_ALARM</div><div class="line">SET_TIME_ZONE</div><div class="line">SET_WALLPAPER</div><div class="line">SET_WALLPAPER_HINTS</div><div class="line">TRANSMIT_IR</div><div class="line">UNINSTALL_SHORTCUT</div><div class="line">USE_FINGERPRINT</div><div class="line">VIBRATE</div><div class="line">WAKE_LOCK</div><div class="line">WRITE_SYNC_SETTINGS</div></pre></td></tr></table></figure><h4 id="Dangerous-Permissions"><a href="#Dangerous-Permissions" class="headerlink" title="Dangerous Permissions"></a>Dangerous Permissions</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">group:android.permission-group.CONTACTS</div><div class="line">    permission:android.permission.WRITE_CONTACTS</div><div class="line">    permission:android.permission.GET_ACCOUNTS</div><div class="line">    permission:android.permission.READ_CONTACTS</div><div class="line"></div><div class="line">group:android.permission-group.PHONE</div><div class="line">    permission:android.permission.READ_CALL_LOG</div><div class="line">    permission:android.permission.READ_PHONE_STATE</div><div class="line">    permission:android.permission.CALL_PHONE</div><div class="line">    permission:android.permission.WRITE_CALL_LOG</div><div class="line">    permission:android.permission.USE_SIP</div><div class="line">    permission:android.permission.PROCESS_OUTGOING_CALLS</div><div class="line">    permission:com.android.voicemail.permission.ADD_VOICEMAIL</div><div class="line"></div><div class="line">group:android.permission-group.CALENDAR</div><div class="line">    permission:android.permission.READ_CALENDAR</div><div class="line">    permission:android.permission.WRITE_CALENDAR</div><div class="line"></div><div class="line">group:android.permission-group.CAMERA</div><div class="line">    permission:android.permission.CAMERA</div><div class="line"></div><div class="line">group:android.permission-group.SENSORS</div><div class="line">    permission:android.permission.BODY_SENSORS</div><div class="line"></div><div class="line">group:android.permission-group.LOCATION</div><div class="line">    permission:android.permission.ACCESS_FINE_LOCATION</div><div class="line">    permission:android.permission.ACCESS_COARSE_LOCATION</div><div class="line"></div><div class="line">group:android.permission-group.STORAGE</div><div class="line">    permission:android.permission.READ_EXTERNAL_STORAGE</div><div class="line">    permission:android.permission.WRITE_EXTERNAL_STORAGE</div><div class="line"></div><div class="line">group:android.permission-group.MICROPHONE</div><div class="line">    permission:android.permission.RECORD_AUDIO</div><div class="line"></div><div class="line">group:android.permission-group.SMS</div><div class="line">    permission:android.permission.READ_SMS</div><div class="line">    permission:android.permission.RECEIVE_WAP_PUSH</div><div class="line">    permission:android.permission.RECEIVE_MMS</div><div class="line">    permission:android.permission.RECEIVE_SMS</div><div class="line">    permission:android.permission.SEND_SMS</div><div class="line">    permission:android.permission.READ_CELL_BROADCASTS</div></pre></td></tr></table></figure><p>Dangerous Permissions分组机制：如果你申请某个危险的权限，假设你的app早已被用户授权了同一组的某个危险权限，那么系统立即授权，而不需要用户点击授权。比如你的app对READ_CONTACTS已经授权了，当你的app申请WRITE_CONTACTS时，系统会直接授权通过。此外，对于申请时弹出的dialog上面的文本说明也是对整个权限组的说明，而不是单个权限的说明。</p><blockquote><p>不过需要注意的是，不要对权限组过多的依赖，尽可能对每个危险权限都进行正常流程的申请，因为在后期的版本中这个权限组可能会产生变化。</p></blockquote><h2 id="二、API的使用"><a href="#二、API的使用" class="headerlink" title="二、API的使用"></a>二、API的使用</h2><h4 id="1、在AndroidManifest文件中添加需要的权限："><a href="#1、在AndroidManifest文件中添加需要的权限：" class="headerlink" title="1、在AndroidManifest文件中添加需要的权限："></a>1、在AndroidManifest文件中添加需要的权限：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.READ_CONTACTS"</span>/&gt;</div></pre></td></tr></table></figure><h4 id="2、检查权限："><a href="#2、检查权限：" class="headerlink" title="2、检查权限："></a>2、检查权限：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) &#123;</div><div class="line">    // 未被授权，申请权限</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    // 已被授权</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ContextCompat.checkSelfPermission：主要用于检测某个权限是否已经被授予，方法返回值为PackageManager.PERMISSION_DENIED或者PackageManager.PERMISSION_GRANTED。当返回DENIED就需要进行申请授权了。</p><h4 id="3、申请权限授权"><a href="#3、申请权限授权" class="headerlink" title="3、申请权限授权"></a>3、申请权限授权</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ActivityCompat.requestPermissions(</div><div class="line">       thisActivity,   /* Context */</div><div class="line">       new String[]&#123;Manifest.permission.READ_CONTACTS&#125;,    /* 需要申请的权限的字符串数组 */</div><div class="line">       MY_PERMISSIONS_REQUEST_READ_CONTACTS    /* requestCode,用于回调时检测 */</div><div class="line">   );</div></pre></td></tr></table></figure><p>该方法是异步的，支持一次性申请多个权限授权，而系统会通过对话框逐一询问用户是否授权。</p><h4 id="4、处理申请回调"><a href="#4、处理申请回调" class="headerlink" title="4、处理申请回调"></a>4、处理申请回调</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onRequestPermissionResult(int requestCode, String[] permissions, int[] grantResult) &#123;</div><div class="line">    switch(requestCode) &#123;</div><div class="line">        // If request is cancelled, the result arrays are empty.</div><div class="line">        <span class="keyword">if</span> (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123;</div><div class="line">            // Permission was granted, yay! Do the contacts-related task you need to do.</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            // Permission denied, boo! Disable the functionality that depends on this permission.</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对于权限的申请结果，首先验证requestCode定位到你的申请，然后验证grantResults对应于申请的结果，这里的数组对应于申请时的第二个权限字符串数组。如果你同时申请两个权限，那么grantResults的length就为2，分别记录你两个权限的申请结果。如果申请成功，就可以做你的事情了~</p><h4 id="5、还有个API值得提一下："><a href="#5、还有个API值得提一下：" class="headerlink" title="5、还有个API值得提一下："></a>5、还有个API值得提一下：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// Should we show an explanation?</div><div class="line"><span class="keyword">if</span> (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity, Manifest.permission.READ_CONTACTS)) </div><div class="line">    // Show an expanation to the user *asynchronously* -- don<span class="string">'t block</span></div><div class="line">    // this thread waiting for the user's response! After the user</div><div class="line">    // sees the explanation, try again to request the permission.</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个API主要用于给用户一个申请权限的解释，该方法只有在用户在上一次已经拒绝过你的这个权限申请。也就是说，用户已经拒绝一次了，你又弹个授权框，你需要给用户一个解释，为什么要授权，则使用该方法。</p><h4 id="6、综合上述步骤："><a href="#6、综合上述步骤：" class="headerlink" title="6、综合上述步骤："></a>6、综合上述步骤：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// Here, thisActivity is the current activity</div><div class="line"><span class="keyword">if</span> (ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.READ_CONTACTS)</div><div class="line">        != PackageManager.PERMISSION_GRANTED) &#123;</div><div class="line"></div><div class="line">    // Should we show an explanation?</div><div class="line">    <span class="keyword">if</span> (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity,</div><div class="line">            Manifest.permission.READ_CONTACTS)) &#123;</div><div class="line"></div><div class="line">        // Show an expanation to the user *asynchronously* -- don<span class="string">'t block</span></div><div class="line">        // this thread waiting for the user's response! After the user</div><div class="line">        // sees the explanation, try again to request the permission.</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        // No explanation needed, we can request the permission.</div><div class="line"></div><div class="line">        ActivityCompat.requestPermissions(thisActivity,</div><div class="line">                new String[]&#123;Manifest.permission.READ_CONTACTS&#125;,</div><div class="line">                MY_PERMISSIONS_REQUEST_READ_CONTACTS);</div><div class="line"></div><div class="line">        // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an</div><div class="line">        // app-defined int constant. The callback method gets the</div><div class="line">        // result of the request.</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="三、Simple-Demo-：直接拨打电话"><a href="#三、Simple-Demo-：直接拨打电话" class="headerlink" title="三、Simple Demo ：直接拨打电话"></a>三、Simple Demo ：直接拨打电话</h2><h4 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</div><div class="line">&lt;manifest xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">          package=<span class="string">"com.xianxiaotao.callphone"</span>&gt;</div><div class="line"></div><div class="line">    &lt;uses-permission android:name=<span class="string">"android.permission.CALL_PHONE"</span>/&gt;</div><div class="line"></div><div class="line">    &lt;application</div><div class="line">        android:allowBackup=<span class="string">"true"</span></div><div class="line">        android:icon=<span class="string">"@mipmap/ic_launcher"</span></div><div class="line">        android:label=<span class="string">"@string/app_name"</span></div><div class="line">        android:supportsRtl=<span class="string">"true"</span></div><div class="line">        android:theme=<span class="string">"@style/AppTheme"</span>&gt;</div><div class="line">        &lt;activity android:name=<span class="string">".MainActivity"</span>&gt;</div><div class="line">            &lt;intent-filter&gt;</div><div class="line">                &lt;action android:name=<span class="string">"android.intent.action.MAIN"</span>/&gt;</div><div class="line">                &lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</div><div class="line">            &lt;/intent-filter&gt;</div><div class="line">        &lt;/activity&gt;</div><div class="line">    &lt;/application&gt;</div><div class="line"></div><div class="line">&lt;/manifest&gt;</div></pre></td></tr></table></figure><h4 id="MainActivity-java"><a href="#MainActivity-java" class="headerlink" title="MainActivity.java"></a>MainActivity.java</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">package com.xianxiaotao.callphone;</div><div class="line"></div><div class="line">import android.Manifest;</div><div class="line">import android.content.Intent;</div><div class="line">import android.content.pm.PackageManager;</div><div class="line">import android.net.Uri;</div><div class="line">import android.support.annotation.NonNull;</div><div class="line">import android.support.v4.app.ActivityCompat;</div><div class="line">import android.support.v4.content.ContextCompat;</div><div class="line">import android.support.v7.app.AppCompatActivity;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.view.View;</div><div class="line">import android.widget.Toast;</div><div class="line"></div><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private static final int MY_PERMISSIONS_REQUEST_CALL_PHONE = 1;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        <span class="built_in">set</span>ContentView(R.layout.activity_main);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void callPhone(View v) &#123;</div><div class="line">        <span class="keyword">if</span> (ContextCompat.checkSelfPermission(this, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) &#123;</div><div class="line">            ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.CALL_PHONE&#125;, MY_PERMISSIONS_REQUEST_CALL_PHONE);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            call();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void <span class="function"><span class="title">call</span></span>() &#123;</div><div class="line">        Intent intent = new Intent(Intent.ACTION_CALL);</div><div class="line">        Uri data = Uri.parse(<span class="string">"tel:"</span> + 10086);</div><div class="line">        intent.setData(data);</div><div class="line">        try &#123;</div><div class="line">            startActivity(intent);</div><div class="line">        &#125; catch (SecurityException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;</div><div class="line">        <span class="keyword">if</span> (requestCode == MY_PERMISSIONS_REQUEST_CALL_PHONE) &#123;</div><div class="line">            <span class="keyword">if</span> (grantResults[0] == PackageManager.PERMISSION_GRANTED)</div><div class="line">                call();</div><div class="line">            <span class="keyword">else</span></div><div class="line">                Toast.makeText(MainActivity.this, <span class="string">"Permission Denied"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">            <span class="built_in">return</span>;</div><div class="line">        &#125;</div><div class="line">        super.onRequestPermissionsResult(requestCode, permissions, grantResults);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在Android 6.x上运行是，点击testCall，即会弹出授权窗口，如何你Allow则直接拨打电话，如果Denied则Toast弹出”Permission Denied”。</p><blockquote><p>对于Intent这种方式，很多情况下是不需要授权的甚至权限都不需要的，比如以下情况就不需要申请权限：你是到拨号界面而不是直接拨打电话；打开系统图库去选择照片；调用系统相机app去拍照等。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12 权限系统</title>
      <link href="/2017/05/28/03%20ANDROID/BASE/12%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F/"/>
      <url>/2017/05/28/03%20ANDROID/BASE/12%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="请求权限"><a href="#请求权限" class="headerlink" title="请求权限"></a>请求权限</h4><p>代码中包含这样的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mWebView.loadUrl(<span class="string">"https://xianxiaotao.github.io/"</span>);</div></pre></td></tr></table></figure></p><p>我们需要为它请求网络权限，在AndroidMainfest.xml文件中添加以下权限：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.INTERNET"</span>/&gt;</div></pre></td></tr></table></figure></p><h4 id="为代码添加权限检查"><a href="#为代码添加权限检查" class="headerlink" title="为代码添加权限检查"></a>为代码添加权限检查</h4><p>在AndroidMainfest.xml文件中声明一个自定义权限：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;permission android:name=<span class="string">"com.xianxiaotao.checkpermission.permission.DO_SOMETHING"</span> /&gt;</div></pre></td></tr></table></figure></p><p>当我们需要在代码中为应用添加权限检查功能时，如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class CheckPermission &#123;</div><div class="line"></div><div class="line">    public static final String PERMISSION_DO_SOMETHING = <span class="string">"com.xianxiaotao.checkpermission.permission.DO_SOMETHING"</span>;</div><div class="line"></div><div class="line">    public static void <span class="keyword">do</span>Something(Context context) &#123;</div><div class="line">        int checkResult = context.checkCallingOrSelfPermission(PERMISSION_DO_SOMETHING);</div><div class="line">        <span class="keyword">if</span> (checkResult != PackageManager.PERMISSION_GRANTED) &#123;</div><div class="line">            throw new SecurityException(<span class="string">"doSomething need permission: "</span> + PERMISSION_DO_SOMETHING);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"If allowed, do something!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        <span class="built_in">set</span>ContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        CheckPermission.doSomething(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>此时运行程序，发生SecurityException。为此，我们需要添加权限：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=<span class="string">"com.xianxiaotao.checkpermission.permission.DO_SOMETHING"</span>/&gt;</div></pre></td></tr></table></figure></p><h4 id="为基本组件添加权限检查"><a href="#为基本组件添加权限检查" class="headerlink" title="为基本组件添加权限检查"></a>为基本组件添加权限检查</h4><p>这种自定义的权限通常是为其他应用访问本应用所设的限制。例如在AndroidMainfest.xml文件中声明一个自定义权限：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;permission android:name=<span class="string">"com.xianxiaotao.music.permission.PLAY_MUSIC"</span> /&gt;</div></pre></td></tr></table></figure></p><p>然后为PlayMusicActivity添加权限检查：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;activity </div><div class="line">    android:name=<span class="string">".activity.PlayMusicActivity"</span></div><div class="line">    android:permission=<span class="string">"com.xianxiaotao.music.permission.PLAY_MUSIC"</span>&gt;</div><div class="line">    &lt;intent-filter&gt;</div><div class="line">        &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</div><div class="line">        &lt;action android:name=<span class="string">"com.xianxiaotao.music.intent.action.PLAY_MUSIC"</span>/&gt;</div><div class="line">    &lt;/intent-filter&gt;</div><div class="line">&lt;/activity&gt;</div></pre></td></tr></table></figure></p><p>应用内部执行下列语句，则不需要做额外工作，在同一个应用内，对于四大组件来说默认拥有访问权限。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">startActivity(new Intent(MainActivity.this, PlayMusicActivity.class));</div></pre></td></tr></table></figure></p><p>但是对于其他应用，如果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">startActivity(new Intent(<span class="string">"com.xianxiaotao.music.permission.PLAY_MUSIC"</span>));</div></pre></td></tr></table></figure></p><p>就需要添加权限才能访问PlayMusicActivity：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=<span class="string">"com.xianxiaotao.music.permission.PLAY_MUSIC"</span>/&gt;</div></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11 日志系统</title>
      <link href="/2017/05/28/03%20ANDROID/BASE/11%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
      <url>/2017/05/28/03%20ANDROID/BASE/11%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="使用日志API"><a href="#使用日志API" class="headerlink" title="使用日志API"></a>使用日志API</h2><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private static final String TAG = <span class="string">"MainActivity"</span>;</div><div class="line"></div><div class="line">Log.e(TAG, <span class="string">"错误信息"</span>);</div><div class="line">Log.w(TAG, <span class="string">"警告信息"</span>);</div><div class="line">Log.i(TAG, <span class="string">"普通信息"</span>);</div><div class="line">Log.d(TAG, <span class="string">"调试信息"</span>);</div><div class="line">Log.v(TAG, <span class="string">"无用信息"</span>); // 便于程序猿唠叨</div></pre></td></tr></table></figure><p>Java日志：System.out对应Log.i；System.err对应Log.w</p><h4 id="日志分类"><a href="#日志分类" class="headerlink" title="日志分类"></a>日志分类</h4><p>在Android Studio中对日志进行分类呈现，便于开发调试：</p><ul><li>Android Monitor -&gt; 选择Log level: Verbose、Debug、Info、Warn、Error</li><li>Regex：进行搜索</li><li>Edit Filter Configuration</li></ul><h4 id="DDMS中查看日志"><a href="#DDMS中查看日志" class="headerlink" title="DDMS中查看日志"></a>DDMS中查看日志</h4><p>1) 使用Android Studio中的DDMS<br>Tools -&gt; Android -&gt; Android Device Monitor<br>2) 独立的 DDMS 查看日志<br>双击Mac电脑上文件：/xianxiaotao/Library/Android/SDK/tools/ddms</p><h2 id="日志工具类"><a href="#日志工具类" class="headerlink" title="日志工具类"></a>日志工具类</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">package com.xianxiaotao.utils;</div><div class="line"></div><div class="line">import android.util.Log;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Log统一管理类</div><div class="line"> */</div><div class="line">public class L &#123;</div><div class="line"></div><div class="line">    private <span class="function"><span class="title">L</span></span>() &#123;</div><div class="line">        /* cannot be instantiated */</div><div class="line">        throw new UnsupportedOperationException(<span class="string">"cannot be instantiated"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static boolean isDebug = <span class="literal">true</span>;   // 是否需要打印bug，可以在application的onCreate函数里面初始化</div><div class="line">    private static final String TAG = <span class="string">"xian"</span>;</div><div class="line"></div><div class="line">    // 下面四个是默认tag的函数</div><div class="line">    public static void v(String msg) &#123;</div><div class="line">        <span class="keyword">if</span> (isDebug)</div><div class="line">            Log.v(TAG, msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void d(String msg) &#123;</div><div class="line">        <span class="keyword">if</span> (isDebug)</div><div class="line">            Log.d(TAG, msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void i(String msg) &#123;</div><div class="line">        <span class="keyword">if</span> (isDebug)</div><div class="line">            Log.i(TAG, msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void w(String msg) &#123;</div><div class="line">        <span class="keyword">if</span> (isDebug)</div><div class="line">            Log.w(TAG, msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void e(String msg) &#123;</div><div class="line">        <span class="keyword">if</span> (isDebug)</div><div class="line">            Log.e(TAG, msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 下面是传入自定义tag的函数</div><div class="line"></div><div class="line">    public static void v(String tag, String msg) &#123;</div><div class="line">        <span class="keyword">if</span> (isDebug)</div><div class="line">            Log.v(tag, msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void d(String tag, String msg) &#123;</div><div class="line">        <span class="keyword">if</span> (isDebug)</div><div class="line">            Log.d(tag, msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void i(String tag, String msg) &#123;</div><div class="line">        <span class="keyword">if</span> (isDebug)</div><div class="line">            Log.i(tag, msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void w(String tag, String msg) &#123;</div><div class="line">        <span class="keyword">if</span> (isDebug)</div><div class="line">            Log.w(tag, msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void e(String tag, String msg) &#123;</div><div class="line">        <span class="keyword">if</span> (isDebug)</div><div class="line">            Log.e(tag, msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="以后进阶：奔溃日志收集与上传"><a href="#以后进阶：奔溃日志收集与上传" class="headerlink" title="以后进阶：奔溃日志收集与上传"></a>以后进阶：奔溃日志收集与上传</h2>]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10 BroadcastReceiver</title>
      <link href="/2017/05/28/03%20ANDROID/BASE/10BroadcastReceiver/"/>
      <url>/2017/05/28/03%20ANDROID/BASE/10BroadcastReceiver/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><ul><li>有序广播：被广播接收器接收后，可被终止，无法往下继续传达。</li><li>普通广播：发送至每一个已经注册（订阅）的广播接收器，无法被终止。</li></ul><h4 id="广播接收器"><a href="#广播接收器" class="headerlink" title="广播接收器"></a>广播接收器</h4><ul><li>静态注册广播接收器：在AndroidManifest.xml中设置，程序不用启动亦可接收。</li><li>动态注册广播接收器：代码中注册广播，程序未启动时，无法接收广播。</li></ul><h2 id="二、使用BroadcastReceiver"><a href="#二、使用BroadcastReceiver" class="headerlink" title="二、使用BroadcastReceiver"></a>二、使用BroadcastReceiver</h2><h4 id="创建MyReceiver-java"><a href="#创建MyReceiver-java" class="headerlink" title="创建MyReceiver.java"></a>创建MyReceiver.java</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">package com.xianxiaotao.learnreceiver;</div><div class="line"></div><div class="line">import android.content.BroadcastReceiver;</div><div class="line">import android.content.Context;</div><div class="line">import android.content.Intent;</div><div class="line"></div><div class="line">public class MyReceiver extends BroadcastReceiver &#123;</div><div class="line"></div><div class="line">    private static final String ARG = <span class="string">"data"</span>;</div><div class="line"></div><div class="line">    public <span class="function"><span class="title">MyReceiver</span></span>() &#123;&#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onReceive(Context context, Intent intent) &#123;</div><div class="line">        System.out.println(<span class="string">"My Receiver : "</span> + intent.getStringExtra(ARG));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 静态注册发送广播方式</div><div class="line">     */</div><div class="line">    public static Intent newIntent(Context context, String args) &#123;</div><div class="line">        Intent intent = new Intent(context, MyReceiver.class);</div><div class="line">        intent.putExtra(ARG, args);</div><div class="line">        <span class="built_in">return</span> intent;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;application&gt;</div><div class="line">    ...</div><div class="line"></div><div class="line">    &lt;receiver</div><div class="line">        android:name=<span class="string">".MyReceiver"</span></div><div class="line">        android:enabled=<span class="string">"true"</span></div><div class="line">        android:exported=<span class="string">"true"</span>&gt;</div><div class="line">    &lt;/receiver&gt;</div><div class="line">&lt;/application&gt;</div></pre></td></tr></table></figure><h4 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sendBroadcast(MyReceiver.newIntent(this, <span class="string">"xianxiaotao"</span>));</div></pre></td></tr></table></figure><h2 id="三、动态注册和注销BroadcastReceiver"><a href="#三、动态注册和注销BroadcastReceiver" class="headerlink" title="三、动态注册和注销BroadcastReceiver"></a>三、动态注册和注销BroadcastReceiver</h2><h4 id="动态注册不需要在AndroidMainfest-xml文件中配置"><a href="#动态注册不需要在AndroidMainfest-xml文件中配置" class="headerlink" title="动态注册不需要在AndroidMainfest.xml文件中配置"></a>动态注册不需要在AndroidMainfest.xml文件中配置</h4><p>删除AndroidMainfest.xml文件中对MyReceiver的声明</p><h4 id="为MyReceiver增加动新的发送广播方式"><a href="#为MyReceiver增加动新的发送广播方式" class="headerlink" title="为MyReceiver增加动新的发送广播方式"></a>为MyReceiver增加动新的发送广播方式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class MyReceiver extends BroadcastReceiver &#123;</div><div class="line"></div><div class="line">    private static final String ARG = <span class="string">"data"</span>;</div><div class="line">    public static final String ACTION = <span class="string">"MyReceiver.intent.action"</span>;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 动态注册发送广播方式</div><div class="line">     */</div><div class="line">    public static Intent newIntent(String args) &#123;</div><div class="line">        Intent intent = new Intent(MyReceiver.ACTION);</div><div class="line">        intent.putExtra(ARG, args);</div><div class="line">        <span class="built_in">return</span> intent;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="MainActivity中动态注册、发送广播和注销广播"><a href="#MainActivity中动态注册、发送广播和注销广播" class="headerlink" title="MainActivity中动态注册、发送广播和注销广播"></a>MainActivity中动态注册、发送广播和注销广播</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123;</div><div class="line"></div><div class="line">    private MyReceiver mMyReceiver = null;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onClick(View v) &#123;</div><div class="line">        switch (v.getId()) &#123;</div><div class="line">            <span class="keyword">case</span> R.id.btnSendBroadcast:// 发送广播</div><div class="line">                sendBroadcast(MyReceiver.newIntent(<span class="string">"xianxiaotao"</span>));</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">            <span class="keyword">case</span> R.id.btnRegBroadcast:// 注册广播</div><div class="line">                <span class="keyword">if</span> (mMyReceiver == null) &#123;</div><div class="line">                    mMyReceiver = new MyReceiver();</div><div class="line">                    registerReceiver(mMyReceiver, new IntentFilter(MyReceiver.ACTION));</div><div class="line">                &#125;</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">            <span class="keyword">case</span> R.id.btnUnregBroadcast:// 注销广播</div><div class="line">                <span class="keyword">if</span> (mMyReceiver != null) &#123;</div><div class="line">                    unregisterReceiver(mMyReceiver);</div><div class="line">                    mMyReceiver = null;</div><div class="line">                &#125;</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>实际开发中必须在onDestroy方法中注销广播，否则有内存泄漏的风险！！！</p></blockquote><h2 id="四、动态注册和静态注册的区别"><a href="#四、动态注册和静态注册的区别" class="headerlink" title="四、动态注册和静态注册的区别"></a>四、动态注册和静态注册的区别</h2><ul><li>动态注册的广播会受Activity的生命周期的影响，当Activity销毁的时候，广播就失效了。</li><li>而静态注册的广播，即使Activity销毁了，仍然可以收到广播。更牛掰的是即使杀死进程，仍然可以收到广播，关于这点不同的手机测试的结果是不同的。</li><li>静态注册的广播，必需单独成一个类，不能像动态注册那样写在某个界面里。</li></ul><blockquote><p>在Android中，有一些action是不支持静态注册的：</p><ul><li>android.intent.action.SCREEN_ON</li><li>android.intent.action.SCREEN_OFF</li><li>android.intent.action.BATTERY_CHANGED</li><li>android.intent.action.CONFIGURATION_CHANGED</li><li>android.intent.action.TIME_TICK</li></ul></blockquote><h2 id="五、BroadcastReceiver的优先级"><a href="#五、BroadcastReceiver的优先级" class="headerlink" title="五、BroadcastReceiver的优先级"></a>五、BroadcastReceiver的优先级</h2><h4 id="配置文件中可以设置优先级：android-priority-”10”"><a href="#配置文件中可以设置优先级：android-priority-”10”" class="headerlink" title="配置文件中可以设置优先级：android:priority=”10”"></a>配置文件中可以设置优先级：android:priority=”10”</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;manifest xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">          package=<span class="string">"com.xianxiaotao.learnreceiver"</span>&gt;</div><div class="line">    &lt;application&gt;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        &lt;receiver</div><div class="line">            android:name=<span class="string">".MyReceiver"</span></div><div class="line">            android:enabled=<span class="string">"true"</span></div><div class="line">            android:exported=<span class="string">"true"</span>&gt;</div><div class="line">            &lt;intent-filter android:priority=<span class="string">"10"</span>&gt;</div><div class="line">                &lt;action android:name=<span class="string">"com.xianxiaotao.learnreceiver.intent.action"</span>/&gt;</div><div class="line">            &lt;/intent-filter&gt;</div><div class="line">        &lt;/receiver&gt;</div><div class="line">    &lt;/application&gt;</div><div class="line">&lt;/manifest&gt;</div></pre></td></tr></table></figure><h4 id="发送、终止-拦截有序广播"><a href="#发送、终止-拦截有序广播" class="headerlink" title="发送、终止/拦截有序广播"></a>发送、终止/拦截有序广播</h4><ul><li>发送有序广播必须使用sendOrderedBroadcast()方法。</li><li>终止有序广播需要在onReceive()方法里使用abortBroadcast()。</li><li>终止的是普通广播则会发生RuntimeException。</li></ul><h4 id="有序广播优先级规则"><a href="#有序广播优先级规则" class="headerlink" title="有序广播优先级规则"></a>有序广播优先级规则</h4><ul><li>优先级高的先接收（数字越大，优先级越高，其范围有待研究）</li><li>同优先级的动静态广播接收器，动态优先于静态</li><li>同优先级的动态广播接收器，或者同优先级的静态广播接收器，按照注册顺序。即静态：先扫描的大于后扫描的，动态：先注册的大于后注册的。</li></ul><h4 id="普通广播优先级规则"><a href="#普通广播优先级规则" class="headerlink" title="普通广播优先级规则"></a>普通广播优先级规则</h4><ul><li>无视优先级，动态广播接收器优先于静态广播接收器。</li><li>按照注册顺序。静态：先扫描的大于后扫描的，动态：先注册的大于后注册的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09 Service总结篇</title>
      <link href="/2017/05/26/03%20ANDROID/BASE/09Service%E6%80%BB%E7%BB%93%E7%AF%87/"/>
      <url>/2017/05/26/03%20ANDROID/BASE/09Service%E6%80%BB%E7%BB%93%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>博客原文：<a href="http://www.cnblogs.com/lwbqqyumidi/p/4181185.html" target="_blank" rel="external">Android总结篇系列：Android Service</a></p><p>Service通常总是称之为“后台服务”，其中“后台”一词是相对于前台而言的，具体是指其本身的运行并不依赖于用户可视的UI界面，因此，从实际业务需求上来理解，Service的适用场景应该具备以下条件：<br>1.并不依赖于用户可视的UI界面（当然，这一条其实也不是绝对的，如前台Service就是与Notification界面结合使用的）；<br>2.具有较长时间的运行特性。</p><h3 id="1、Service-AndroidManifest-xml-声明"><a href="#1、Service-AndroidManifest-xml-声明" class="headerlink" title="1、Service AndroidManifest.xml 声明"></a>1、Service AndroidManifest.xml 声明</h3><p>一般而言，从Service的启动方式上，可以将Service分为Started Service和Bound Service。无论哪种具体的Service启动类型，都是通过继承Service基类自定义而来。在使用Service时，要想系统能够找到此自定义Service，无论哪种类型，都需要在AndroidManifest.xml中声明，语法格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;service android:enabled=[<span class="string">"true"</span> | <span class="string">"false"</span>]</div><div class="line">    android:exported=[<span class="string">"true"</span> | <span class="string">"false"</span>]</div><div class="line">    android:icon=<span class="string">"drawable resource"</span></div><div class="line">    android:isolatedProcess=[<span class="string">"true"</span> | <span class="string">"false"</span>]</div><div class="line">    android:label=<span class="string">"string resource"</span></div><div class="line">    android:name=<span class="string">"string"</span></div><div class="line">    android:permission=<span class="string">"string"</span></div><div class="line">    android:process=<span class="string">"string"</span> &gt;</div><div class="line">    . . .</div><div class="line">&lt;/service&gt;</div></pre></td></tr></table></figure></p><p>其中，android:name对应Service类名，android:permission是权限声明，android:process设置具体的进程名称。需要注意的是Service能否单独使用一个进程与其启动方式有关，本后下面会给出具体说明。其他的属性此处与其他组件基本相同，不再过多描述。</p><blockquote><p>如果自定义Service没有在AndroidManifest.xml中声明，当具体使用时，不会像Activity那样直接崩溃报错，对于显式Intent启动的Service，此时也会给出waring信息“IllegalArgumentException: Service not registered”，有时候不容易发现忘了声明而一时定位不到问题。</p></blockquote><h3 id="2、Started-Service"><a href="#2、Started-Service" class="headerlink" title="2、Started Service"></a>2、Started Service</h3><p>通过context.startService(Intent serviceIntent)启动Service，context.stopService(Intent serviceIntent)停止此Service。当然，在Service内部，也可以通过stopSelf(…)方式停止其本身。注意：如果服务是通过绑定服务开启的，stopSelf方法无效。<br>1) Started Service自定义<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class MyService extends Service &#123;</div><div class="line"></div><div class="line">    public static final String TAG = <span class="string">"MyService"</span>;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public IBinder onBind(Intent intent) &#123;</div><div class="line">        <span class="built_in">return</span> null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void <span class="function"><span class="title">onCreate</span></span>() &#123;</div><div class="line">        super.onCreate();</div><div class="line">        Log.w(TAG, <span class="string">"in onCreate"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int onStartCommand(Intent intent, int flags, int startId) &#123;</div><div class="line">        Log.w(TAG, <span class="string">"in onStartCommand"</span>);</div><div class="line">        Log.w(TAG, <span class="string">"MyService:"</span> + this);</div><div class="line">        String name = intent.getStringExtra(<span class="string">"name"</span>);</div><div class="line">        Log.w(TAG, <span class="string">"name:"</span> + name);</div><div class="line">        <span class="built_in">return</span> START_STICKY;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void <span class="function"><span class="title">onDestroy</span></span>() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">        Log.w(TAG, <span class="string">"in onDestroy"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其中，onBind(…)函数是Service基类中的唯一抽象方法，子类都必须重写实现，此函数的返回值是针对Bound Service类型的Service才有用的，在Started Service类型中，此函数直接返回 null 即可。onCreate(…)、onStartCommand(…)和onDestroy()都是Started Service相应生命周期阶段的回调函数。</p><p>2) Started Service使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends Activity &#123;</div><div class="line"></div><div class="line">    public static final String TAG = <span class="string">"MainActivity"</span>;</div><div class="line"></div><div class="line">    private Button startServiceBtn;</div><div class="line">    private Button stopServideBtn;</div><div class="line">    private Button goBtn;</div><div class="line"></div><div class="line">    private Intent serviceIntent;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        <span class="built_in">set</span>ContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        startServiceBtn = (Button) findViewById(R.id.start_service);</div><div class="line">        stopServideBtn = (Button) findViewById(R.id.stop_service);</div><div class="line">        goBtn = (Button) findViewById(R.id.go);</div><div class="line"></div><div class="line">        startServiceBtn.setOnClickListener(new View.<span class="function"><span class="title">OnClickListener</span></span>() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                serviceIntent = new Intent(MainActivity.this, MyService.class);</div><div class="line">                startService(serviceIntent);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        stopServideBtn.setOnClickListener(new View.<span class="function"><span class="title">OnClickListener</span></span>() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                stopService(serviceIntent);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        goBtn.setOnClickListener(new View.<span class="function"><span class="title">OnClickListener</span></span>() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                Intent intent = new Intent(MainActivity.this, BActivity.class);</div><div class="line">                startActivity(intent);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void <span class="function"><span class="title">onDestroy</span></span>() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">        Log.w(TAG, <span class="string">"in onDestroy"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当Client调用startService(Intent serviceIntent)后，如果MyService是第一次启动，首先会执行 onCreate()回调，然后再执行onStartCommand(Intent intent, int flags, int startId)，当Client再次调用startService(Intent serviceIntent)，将只执行onStartCommand(Intent intent, int flags, int startId)，因为此时Service已经创建了，无需执行onCreate()回调。无论多少次的startService，只需要一次stopService()即可将此Service终止，执行onDestroy()函数（其实很好理解，因为onDestroy()与onCreate()回调是相对的）。</p><p>下面重点关注下onStartCommand(Intent intent, int flags, int startId)方法：<br>其中参数flags默认情况下是0，对应的常量名为START_STICKY_COMPATIBILITY。startId是一个唯一的整型，用于表示此次Client执行startService(…)的请求请求标识，在多次startService(…)的情况下，呈现0,1,2….递增。另外，此函数具有一个int型的返回值，具体的可选值及含义如下：</p><ul><li>START_NOT_STICKY：当Service因为内存不足而被系统kill后，接下来未来的某个时间内，即使系统内存足够可用，系统也不会尝试重新创建此Service。除非程序中Client明确再次调用startService(…)启动此Service。</li><li>START_STICKY：当Service因为内存不足而被系统kill后，接下来未来的某个时间内，当系统内存足够可用的情况下，系统将会尝试重新创建此Service，一旦创建成功后将回调onStartCommand(…)方法，但其中的Intent将是null，pendingintent除外。</li><li>START_REDELIVER_INTENT：与START_STICKY唯一不同的是，回调onStartCommand(…)方法时，其中的Intent将是非空，将是最后一次调用startService(…)中的intent。</li><li>START_STICKY_COMPATIBILITY：compatibility version of {@link #START_STICKY} that does not guarantee that {@link #onStartCommand} will be called again after being killed。此值一般不会使用，所以注意前面三种情形就好。</li></ul><p>以上的描述中，”当Service因为内存不足而被系统kill后“一定要非常注意，因为此函数的返回值设定只是针对此种情况才有意义的，换言之，当人为的kill掉Service进程，此函数返回值无论怎么设定，接下来未来的某个时间内，即使系统内存足够可用，Service也不会重启。<br>另外，需要注意的是，小米手机针对此处做了一定的修改。在“自启动管理”中有一个自启动应用列表，默认情况下，只有少应用（如微信、QQ、YY、360等）默认是可以自启动的，其他应用默认都是禁止的。用户可以手动添加自启动应用，添加后的应用中如果Started Service onStartCommand(…)回调返回值是START_STICKY或START_REDELIVER_INTENT，当用户在小米手机上长按Home键结束App后，接下来未来的某个时间内，当系统内存足够可用时，Service依然可以按照上述规定重启。当然，如果用户在 设置 &gt;&gt; 应用 &gt;&gt; 强制kill掉App进程，此时Service是不会重启的。<br>注：以上实验结论基于小米2S亲测。</p><p>3) Started Service生命周期及进程相关<br>1.onCreate(Client首次startService(..)) &gt;&gt; onStartCommand &gt;&gt; onStartCommand - optional … &gt;&gt; onDestroy(Client调用stopService(..))<br>注：onStartCommand(..)可以多次被调用，onDestroy()与onCreate()想匹配，当用户强制kill掉进程时，onDestroy()是不会执行的。<br>2.对于同一类型的Service，Service实例一次永远只存在一个，而不管Client是否是相同的组件，也不管Client是否处于相同的进程中。<br>3.Service通过startService(..)启动Service后，此时Service的生命周期与Client本身的什么周期是没有任何关系的，只有Client调用stopService(..)或Service本身调用stopSelf(..)才能停止此Service。当然，当用户强制kill掉Service进程或系统因内存不足也可能kill掉此Service。<br>4.Client A 通过startService(..)启动Service后,可以在其他Client（如Client B、Client C）通过调用stopService(..)结束此Service。<br>5.Client调用stopService(..)时，如果当前Service没有启动，也不会出现任何报错或问题，也就是说，stopService(..)无需做当前Service是否有效的判断。<br>6.startService(Intent serviceIntent)，其中的intent既可以是显式Intent，也可以是隐式Intent，当Client与Service同处于一个App时，一般推荐使用显示Intent。当处于不同App时，只能使用隐式Intent。<br>当Service需要运行在单独的进程中，AndroidManifest.xml声明时需要通过android:process指明此进程名称，当此Service需要对其他App开放时，android:exported属性值需要设置为true(当然，在有intent-filter时默认值就是true)。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;service</div><div class="line">    android:name=<span class="string">".MyService"</span></div><div class="line">    android:exported=<span class="string">"true"</span></div><div class="line">    android:process=<span class="string">":MyCorn"</span> &gt;</div><div class="line">    &lt;intent-filter&gt;</div><div class="line">        &lt;action android:name=<span class="string">"com.example.androidtest.myservice"</span> /&gt;</div><div class="line">    &lt;/intent-filter&gt;</div><div class="line">&lt;/service&gt;</div></pre></td></tr></table></figure></p><p>4) Started Service Client与Service通信相关<br>当Client调用startService(Intent serviceIntent)启动Service时，Client可以将参数通过Intent直接传递给Service。Service执行过程中，如果需要将参数传递给Client，一般可以通过借助于发送广播的方式（此时，Client需要注册此广播）。</p><h3 id="3、Bound-Service"><a href="#3、Bound-Service" class="headerlink" title="3、Bound Service"></a>3、Bound Service</h3><p>相对于Started Service，Bound Service具有更多的知识点。Bound Service的主要特性在于Service的生命周期是依附于Client的生命周期的，当Client不存在时，Bound Service将执行onDestroy，同时通过Service中的Binder对象可以较为方便进行Client-Service通信。Bound Service一般使用过程如下：<br>1.自定义Service继承基类Service，并重写onBind(Intent intent)方法，此方法中需要返回具体的Binder对象；<br>2.Client通过实现ServiceConnection接口来自定义ServiceConnection，并通过bindService (Intent service, ServiceConnection sc, int flags)方法将Service绑定到此Client上；<br>3.自定义的ServiceConnection中实现onServiceConnected(ComponentName name, IBinder binder)方法，获取Service端Binder实例；<br>4.通过获取的Binder实例进行Service端其他公共方法的调用，以完成Client-Service通信；<br>5.当Client在恰当的生命周期（如onDestroy等）时，此时需要解绑之前已经绑定的Service，通过调用函数unbindService(ServiceConnection sc)。<br>在Bound Service具体使用过程中，根据onBind(Intent intent)方法放回的Binder对象的定义方式不同，又可以将其分为以下三种方式，且每种方式具有不同的特点和适用场景：<br>1）Extending the Binder class<br>就是上述Demo中的代码形式，这是Bound Service中最常见的一种使用方式，也是Bound Service中最简单的一种。<br>局限：Clinet与Service必须同属于同一个进程，不能实现进程间通信（IPC）。否则则会出现类似于“android.os.BinderProxy cannot be cast to xxx”错误。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line">public class MyBindService extends Service &#123;</div><div class="line"></div><div class="line">    public static final String TAG = <span class="string">"MyBindService"</span>;</div><div class="line"></div><div class="line">    private MyBinder mBinder = new MyBinder();</div><div class="line"></div><div class="line">    public class MyBinder extends Binder &#123;</div><div class="line">        MyBindService <span class="function"><span class="title">getService</span></span>() &#123;</div><div class="line">            <span class="built_in">return</span> MyBindService.this;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void <span class="function"><span class="title">onCreate</span></span>() &#123;</div><div class="line">        super.onCreate();</div><div class="line">        Log.w(TAG, <span class="string">"in onCreate"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public IBinder onBind(Intent intent) &#123;</div><div class="line">        Log.w(TAG, <span class="string">"in onBind"</span>);</div><div class="line">        <span class="built_in">return</span> mBinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onUnbind(Intent intent) &#123;</div><div class="line">        Log.w(TAG, <span class="string">"in onUnbind"</span>);</div><div class="line">        <span class="built_in">return</span> super.onUnbind(intent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void <span class="function"><span class="title">onDestroy</span></span>() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">        Log.w(TAG, <span class="string">"in onDestroy"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class BActivity extends Activity &#123;</div><div class="line"></div><div class="line">    public static final String TAG = <span class="string">"BActivity"</span>;</div><div class="line"></div><div class="line">    private Button <span class="built_in">bind</span>ServiceBtn;</div><div class="line">    private Button unbindServiceBtn;</div><div class="line"></div><div class="line">    private Button startIntentService;</div><div class="line"></div><div class="line">    private Intent serviceIntent;</div><div class="line"></div><div class="line">    private ServiceConnection sc = new MyServiceConnection();</div><div class="line">    private MyBinder mBinder;</div><div class="line">    private MyBindService mBindService;</div><div class="line">    private boolean mBound;</div><div class="line"></div><div class="line">    private class MyServiceConnection implements ServiceConnection &#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onServiceConnected(ComponentName name, IBinder binder) &#123;</div><div class="line">            Log.w(TAG, <span class="string">"in MyServiceConnection onServiceConnected"</span>);</div><div class="line">            mBinder = (MyBinder) binder;</div><div class="line">            mBindService = mBinder.getService();</div><div class="line"></div><div class="line">            mBound = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onServiceDisconnected(ComponentName name) &#123;</div><div class="line">            // This is called when the connection with the service has been</div><div class="line">            // unexpectedly disconnected -- that is, its process crashed.</div><div class="line">            Log.w(TAG, <span class="string">"in MyServiceConnection onServiceDisconnected"</span>);</div><div class="line">            mBound = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        <span class="built_in">set</span>ContentView(R.layout.b);</div><div class="line"></div><div class="line">        <span class="built_in">bind</span>ServiceBtn = (Button) findViewById(R.id.bind_service);</div><div class="line">        unbindServiceBtn = (Button) findViewById(R.id.unbind_service);</div><div class="line">        startIntentService = (Button) findViewById(R.id.start_intentservice);</div><div class="line"></div><div class="line">        <span class="built_in">bind</span>ServiceBtn.setOnClickListener(new View.<span class="function"><span class="title">OnClickListener</span></span>() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                Intent intent = new Intent(BActivity.this, MyBindService.class);</div><div class="line">                <span class="built_in">bind</span>Service(intent, sc, Context.BIND_AUTO_CREATE);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        unbindServiceBtn.setOnClickListener(new View.<span class="function"><span class="title">OnClickListener</span></span>() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                excuteUnbindService();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        startIntentService.setOnClickListener(new View.<span class="function"><span class="title">OnClickListener</span></span>() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                Intent intent = new Intent(BActivity.this, MyIntentService.class);</div><div class="line">                startService(intent);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void <span class="function"><span class="title">excuteUnbindService</span></span>() &#123;</div><div class="line">        <span class="keyword">if</span> (mBound) &#123;</div><div class="line">            unbindService(sc);</div><div class="line">            mBound = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void <span class="function"><span class="title">onDestroy</span></span>() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">        Log.w(TAG, <span class="string">"in onDestroy"</span>);</div><div class="line">        excuteUnbindService();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>首次点击bindServiceBtn进行bindService(..)时，依次回调顺序如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MyBindService(13457): <span class="keyword">in</span> onCreate</div><div class="line">MyBindService(13457): <span class="keyword">in</span> onBind</div><div class="line">BActivity(13457): <span class="keyword">in</span> MyServiceConnection onServiceConnected</div></pre></td></tr></table></figure></p><p>再次点击bindServiceBtn按钮时，发现没有任何输出，说明MyBindService没有进行任何回调。<br>点击unbindServiceBtn进行unbindService(..)时，回调顺序为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MyBindService(13457): <span class="keyword">in</span> onUnbind</div><div class="line">MyBindService(13457): <span class="keyword">in</span> onDestroy</div></pre></td></tr></table></figure></p><p>注：在四大基本组件中，需要注意的的是BroadcastReceiver不能作为Bound Service的Client，因为BroadcastReceiver的生命周期很短，当执行完onReceive(..)回调时，BroadcastReceiver生命周期完结。而Bound Service又与Client本身的生命周期相关，因此，Android中不允许BroadcastReceiver去bindService(..)，当有此类需求时，可以考虑通过startService(..)替代。</p><p>2）Using a Messenger<br>Messenger，在此可以理解成”信使“，通过Messenger方式返回Binder对象可以不用考虑Clinet - Service是否属于同一个进程的问题，并且，可以实现Client - Service之间的双向通信。极大方便了此类业务需求的实现。<br>局限：不支持严格意义上的多线程并发处理，实际上是以队列去处理。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">public class MyMessengerService extends Service &#123;</div><div class="line"></div><div class="line">    public static final String TAG = <span class="string">"MyMessengerService"</span>;</div><div class="line">    public static final int MSG_FROM_CLIENT_TO_SERVER = 1;</div><div class="line">    public static final int MSG_FROM_SERVER_TO_CLIENT = 2;</div><div class="line"></div><div class="line">    private Messenger mClientMessenger;</div><div class="line">    private Messenger mServerMessenger = new Messenger(new ServerHandler());</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public IBinder onBind(Intent intent) &#123;</div><div class="line">        Log.w(TAG, <span class="string">"in onBind"</span>);</div><div class="line">        <span class="built_in">return</span> mServerMessenger.getBinder();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class ServerHandler extends Handler &#123;</div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            Log.w(TAG, <span class="string">"thread name:"</span> + Thread.currentThread().getName());</div><div class="line">            switch (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> MSG_FROM_CLIENT_TO_SERVER:</div><div class="line">                Log.w(TAG, <span class="string">"receive msg from client"</span>);</div><div class="line">                mClientMessenger = msg.replyTo;</div><div class="line"></div><div class="line">                // service发送消息给client</div><div class="line">                Message toClientMsg = Message.obtain(null, MSG_FROM_SERVER_TO_CLIENT);</div><div class="line">                try &#123;</div><div class="line">                    Log.w(TAG, <span class="string">"server begin send msg to client"</span>);</div><div class="line">                    mClientMessenger.send(toClientMsg);</div><div class="line">                &#125; catch (RemoteException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">            default:</div><div class="line">                super.handleMessage(msg);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onUnbind(Intent intent) &#123;</div><div class="line">        Log.w(TAG, <span class="string">"in onUnbind"</span>);</div><div class="line">        <span class="built_in">return</span> super.onUnbind(intent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void <span class="function"><span class="title">onDestroy</span></span>() &#123;</div><div class="line">        Log.w(TAG, <span class="string">"in onDestroy"</span>);</div><div class="line">        super.onDestroy();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line">public class CActivity extends Activity &#123;</div><div class="line"></div><div class="line">    public static final String TAG = <span class="string">"CActivity"</span>;</div><div class="line"></div><div class="line">    private Button <span class="built_in">bind</span>ServiceBtn;</div><div class="line">    private Button unbindServiceBtn;</div><div class="line">    private Button sendMsgToServerBtn;</div><div class="line"></div><div class="line">    private ServiceConnection sc = new MyServiceConnection();</div><div class="line">    private boolean mBound;</div><div class="line"></div><div class="line">    private Messenger mServerMessenger;</div><div class="line"></div><div class="line">    private Handler mClientHandler = new MyClientHandler();</div><div class="line">    private Messenger mClientMessenger = new Messenger(mClientHandler);</div><div class="line"></div><div class="line">    private class MyClientHandler extends Handler &#123;</div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            <span class="keyword">if</span> (msg.what == MyMessengerService.MSG_FROM_SERVER_TO_CLIENT) &#123;</div><div class="line">                Log.w(TAG, <span class="string">"reveive msg from server"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class MyServiceConnection implements ServiceConnection &#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onServiceConnected(ComponentName name, IBinder binder) &#123;</div><div class="line">            Log.w(TAG, <span class="string">"in MyServiceConnection onServiceConnected"</span>);</div><div class="line">            mServerMessenger = new Messenger(binder);</div><div class="line"></div><div class="line">            mBound = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onServiceDisconnected(ComponentName name) &#123;</div><div class="line">            // This is called when the connection with the service has been</div><div class="line">            // unexpectedly disconnected -- that is, its process crashed.</div><div class="line">            Log.w(TAG, <span class="string">"in MyServiceConnection onServiceDisconnected"</span>);</div><div class="line"></div><div class="line">            mBound = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        <span class="built_in">set</span>ContentView(R.layout.c);</div><div class="line"></div><div class="line">        <span class="built_in">bind</span>ServiceBtn = (Button) findViewById(R.id.bind_service);</div><div class="line">        unbindServiceBtn = (Button) findViewById(R.id.unbind_service);</div><div class="line">        sendMsgToServerBtn = (Button) findViewById(R.id.send_msg_to_server);</div><div class="line"></div><div class="line">        <span class="built_in">bind</span>ServiceBtn.setOnClickListener(new View.<span class="function"><span class="title">OnClickListener</span></span>() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                Intent intent = new Intent(CActivity.this, MyMessengerService.class);</div><div class="line">                <span class="built_in">bind</span>Service(intent, sc, Context.BIND_AUTO_CREATE);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        unbindServiceBtn.setOnClickListener(new View.<span class="function"><span class="title">OnClickListener</span></span>() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                excuteUnbindService();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        sendMsgToServerBtn.setOnClickListener(new View.<span class="function"><span class="title">OnClickListener</span></span>() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                sayHello();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        new Handler().postDelayed(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">            @Override</div><div class="line">            public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">                Intent intent = new Intent(CActivity.this, MyAlarmBroadcastReceiver.class);</div><div class="line">                sendBroadcast(intent);</div><div class="line">            &#125;</div><div class="line">        &#125;, 3 * 1000);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void <span class="function"><span class="title">sayHello</span></span>() &#123;</div><div class="line">        <span class="keyword">if</span> (!mBound)</div><div class="line">            <span class="built_in">return</span>;</div><div class="line">        // Create and send a message to the service, using a supported <span class="string">'what'</span> value</div><div class="line">        Message msg = Message.obtain(null, MyMessengerService.MSG_FROM_CLIENT_TO_SERVER, 0, 0);</div><div class="line">        // 通过replyTo把client端的Messenger(信使)传递给service</div><div class="line">        msg.replyTo = mClientMessenger;</div><div class="line">        try &#123;</div><div class="line">            mServerMessenger.send(msg);</div><div class="line">        &#125; catch (RemoteException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void <span class="function"><span class="title">excuteUnbindService</span></span>() &#123;</div><div class="line">        <span class="keyword">if</span> (mBound) &#123;</div><div class="line">            unbindService(sc);</div><div class="line">            mBound = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void <span class="function"><span class="title">onDestroy</span></span>() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">        Log.w(TAG, <span class="string">"in onDestroy"</span>);</div><div class="line">        excuteUnbindService();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中，需要注意的几点是：<br>1.MyMessengerService自定中，通过new Messenger(new ServerHandler())创建Messenger对象，在onBind(..)回调中，通过调用Messenger对象的getBinder()方法，将Binder返回；<br>2.Client在ServiceConnection的onServiceConnected(..)的回调中，通过new Messenger(binder)获取到Service传递过来的mServerMessenger；<br>3.接下来，就可以通过mServerMessenger.send(msg)方法向Service发送message，Service中的Messenger构造器中的Handler即可接收到此信息，在handleMessage(..)回调中处理；<br>4.至此只是完成了从Client发送消息到Service，同样的道理，想实现Service发送消息到Client，可以在客户端定义一个Handler，并得到相应的Messenger，在Clinet发送消息给Service时，通过msg.replyTo = mClientMessenger方式将Client信使传递给Service；<br>5.Service接收到Client信使后，获取此信使，并通过mClientMessenger.send(toClientMsg)方式将Service消息发送给Client。</p><p>至此，完成了Client - Service之间的双向通信流程。</p><p>3）AIDL（Android Interface Definition Language）<br>一般情况下，Messenger这种方式都是可以满足需求的，当然，通过自定义AIDL方式相对更加灵活。<br>这种方式需要自己在项目中自定义xxx.aidl文件，然后系统会自动在gen目录下生成相应的接口类文件，接下来整个的流程与Messenger方式差别不大，网上也有不少实例，在此不再具体给出。<br>注：无论哪种方式的Bound Service，在进行unbind(..)操作时，都需要注意当前Service是否处于已经绑定状态，否则可能会因为当前Service已经解绑后继续执行unbind(..)会导致崩溃。这点与Started Service区别很大（如前文所述：stopService(..)无需做当前Service是否有效的判断）。</p><h3 id="4、Local-Service-VS-Remote-Service"><a href="#4、Local-Service-VS-Remote-Service" class="headerlink" title="4、Local Service VS Remote Service"></a>4、Local Service VS Remote Service</h3><p>Local Service：不少人又称之为”本地服务“，是指Client - Service同处于一个进程；<br>Remote Service：又称之为”远程服务“，一般是指Service处于单独的一个进程中。</p><h3 id="5、Service特性"><a href="#5、Service特性" class="headerlink" title="5、Service特性"></a>5、Service特性</h3><p>1.Service本身都是运行在其所在进程的主线程（如果Service与Clinet同属于一个进程，则是运行于UI线程），但Service一般都是需要进行”长期“操作，所以经常写法是在自定义Service中处理”长期“操作时需要新建线程，以免阻塞UI线程或导致ANR；<br>2.Service一旦创建，需要停止时都需要显示调用相应的方法（Started Service需要调用stopService(..)或Service本身调用stopSelf(..)， Bound Service需要调用unbindService(..)），否则对于Started Service将处于一直运行状态，对于Bound Service，当Client生命周期结束时也将因此问题。也就是说，Service执行完毕后，必须人为的去停止它</p><h3 id="6、IntentService"><a href="#6、IntentService" class="headerlink" title="6、IntentService"></a>6、IntentService</h3><p>IntentService是系统提供给我们的一个已经继承自Service类的特殊类，IntentService特殊性是相对于Service本身的特性而言的：<br>1.默认直接实现了onBind(..)方法，直接返回null，并定义了抽象方法onHandlerIntent(..)，用户自定义子类时，需要实现此方法；<br>2.onHandlerIntent(..)主要就是用来处于相应的”长期“任务的，并且已经自动在新的线程中，用户无需自定义新线程；<br>3.当”长期“任务执行完毕后（也就是onHandlerIntent(..)执行完毕后），此IntentService将自动结束，无需人为调用方法使其结束；<br>4.IntentService处于任务时，也是按照队列的方式一个个去处理，而非真正意义上的多线程并发方式。<br>下面是一个基本的继承自IntentService的自定义Service：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class MyIntentService extends IntentService &#123;</div><div class="line"></div><div class="line">    public static final String TAG = <span class="string">"MyIntentService"</span>;</div><div class="line"></div><div class="line">    public <span class="function"><span class="title">MyIntentService</span></span>() &#123;</div><div class="line">        super(TAG);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public MyIntentService(String name) &#123;</div><div class="line">        super(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onHandleIntent(Intent intent) &#123;</div><div class="line">        Log.w(TAG, <span class="string">"in onHandleIntent"</span>);</div><div class="line">        Log.w(TAG, <span class="string">"thread name:"</span> + Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="7、前台Service"><a href="#7、前台Service" class="headerlink" title="7、前台Service"></a>7、前台Service</h3><p>Android中Service接口中还提供了一个称之为”前台Service“的概念。通过Service.startForeground (int id, Notification notification)方法可以将此Service设置为前台Service。在UI显示上，notification将是一个处于onGoing状态的通知，使得前台Service拥有更高的进程优先级，并且Service可以直接notification通信。<br>下面是一个简单的前台Service使用实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public class MyService extends Service &#123;</div><div class="line"></div><div class="line">    public static final String TAG = <span class="string">"MyService"</span>;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public IBinder onBind(Intent intent) &#123;</div><div class="line">        <span class="built_in">return</span> null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void <span class="function"><span class="title">onCreate</span></span>() &#123;</div><div class="line">        super.onCreate();</div><div class="line">        Log.w(TAG, <span class="string">"in onCreate"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int onStartCommand(Intent intent, int flags, int startId) &#123;</div><div class="line">        Log.w(TAG, <span class="string">"in onStartCommand"</span>);</div><div class="line">        Log.w(TAG, <span class="string">"MyService:"</span> + this);</div><div class="line">        String name = intent.getStringExtra(<span class="string">"name"</span>);</div><div class="line">        Log.w(TAG, <span class="string">"name:"</span> + name);</div><div class="line"></div><div class="line">        </div><div class="line">        Notification notification = new Notification(R.drawable.ic_launcher, <span class="string">"test"</span>, System.currentTimeMillis());</div><div class="line">        Intent notificationIntent = new Intent(this, DActivity.class);</div><div class="line">        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntesnt, 0);</div><div class="line">        notification.setLatestEventInfo(this, <span class="string">"title"</span>, <span class="string">"content"</span>, pendingIntent);</div><div class="line">        startForeground(1, notification);</div><div class="line">        </div><div class="line"></div><div class="line">        <span class="built_in">return</span> START_REDELIVER_INTENT;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void <span class="function"><span class="title">onDestroy</span></span>() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">        Log.w(TAG, <span class="string">"in onDestroy"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08 Service通信</title>
      <link href="/2017/05/26/03%20ANDROID/BASE/08Service%E9%80%9A%E4%BF%A1/"/>
      <url>/2017/05/26/03%20ANDROID/BASE/08Service%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、应用内通信"><a href="#一、应用内通信" class="headerlink" title="一、应用内通信"></a>一、应用内通信</h2><h4 id="1、启动Service并传递数据"><a href="#1、启动Service并传递数据" class="headerlink" title="1、启动Service并传递数据"></a>1、启动Service并传递数据</h4><p>启动一个Service并且向该Service传递数据:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent(this, MyService.class);</div><div class="line">intent.putExtra(<span class="string">"data"</span>, mEditText.getText().toString().trim());</div><div class="line">startService(intent);</div></pre></td></tr></table></figure></p><p>MyService接收数据：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private String data = <span class="string">"MyService default info"</span>;</div><div class="line"></div><div class="line">@Override</div><div class="line">public int onStartCommand(Intent intent, int flags, int startId) &#123; </div><div class="line">    data = intent.getStringExtra(<span class="string">"data"</span>);</div><div class="line">    <span class="built_in">return</span> super.onStartCommand(intent, flags, startId);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="2、绑定Service进行通信——-gt"><a href="#2、绑定Service进行通信——-gt" class="headerlink" title="2、绑定Service进行通信——&gt;"></a>2、绑定Service进行通信——&gt;</h4><p>与被绑定的Service进行通信，首先自定义一个Binder的实现类，拥有setData(String data)方法，并在onBind方法中返回自定义类的对象：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class MyService extends Service &#123;</div><div class="line"></div><div class="line">    private String data = <span class="string">"MyService default info"</span>;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public IBinder onBind(Intent intent) &#123;</div><div class="line">        <span class="built_in">return</span> new MyBinder();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public class MyBinder extends Binder &#123;</div><div class="line">        public void <span class="built_in">set</span>Data(String data) &#123;</div><div class="line">            MyService.this.data = data;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在ServiceConnection实现类中onServiceConnected方法里获取服务绑定成功时返回的对象<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity implements View.OnClickListener, ServiceConnection &#123;</div><div class="line"></div><div class="line">    private MyService.MyBinder mMyBinder;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onServiceConnected(ComponentName name, IBinder service) &#123;</div><div class="line">        mMyBinder = (MyService.MyBinder) service;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后MainActivity就可以实时的想MyService同步数据了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (mMyBinder != null)</div><div class="line">    mMyBinder.setData(mEditText.getText().toString().trim());</div></pre></td></tr></table></figure></p><p>输出日志<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">I/System.out: MyService onCreate</div><div class="line">I/System.out: MyService default info</div><div class="line">I/System.out: MyService default info</div><div class="line">I/System.out: MyService default info</div><div class="line">I/System.out: MyService default info</div><div class="line">I/System.out: MainActivity say something</div><div class="line">I/System.out: MainActivity say something</div><div class="line">I/System.out: MainActivity say something</div><div class="line">I/System.out: MyService onDestroy</div></pre></td></tr></table></figure></p><h4 id="3、绑定Service进行通信-lt-——"><a href="#3、绑定Service进行通信-lt-——" class="headerlink" title="3、绑定Service进行通信&lt;——"></a>3、绑定Service进行通信&lt;——</h4><p>侦听被绑定的Service的内部状态，需要借助回调接口。首先定义回调接口并设置set(callBack)方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class MyService extends Service &#123;</div><div class="line"></div><div class="line">    private CallBack mCallBack;</div><div class="line"></div><div class="line">    public void <span class="built_in">set</span>CallBack(CallBack callBack) &#123;</div><div class="line">        mCallBack = callBack;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static interface CallBack &#123;</div><div class="line">        public void onDataChange(String data);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>自定义类MyBinder中增加一个方法，返回当前Service的对象，以便于外部客户端调用set(callBack)方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class MyBinder extends Binder &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    public MyService <span class="function"><span class="title">getService</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> MyService.this;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在Service中将状态信息通过回调接口通知外界<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">i++;</div><div class="line"><span class="keyword">if</span> (mCallBack != null)</div><div class="line">    mCallBack.onDataChange(i + <span class="string">" "</span> + data);</div></pre></td></tr></table></figure></p><p>ServiceConnection的实现类（此处为MainActivity）在onServiceConnected方法中获取Service对象，并将自定义的回调接口告知Service：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onServiceConnected(ComponentName name, IBinder service) &#123;</div><div class="line">    mMyBinder = (MyService.MyBinder) service;</div><div class="line">    mMyBinder.getService().setCallBack(new MyService.<span class="function"><span class="title">CallBack</span></span>() &#123;</div><div class="line">        @Override</div><div class="line">        public void onDataChange(String data) &#123;</div><div class="line">            Message msg = new Message();</div><div class="line">            Bundle bundle = new Bundle();</div><div class="line">            bundle.putString(<span class="string">"data"</span>, data);</div><div class="line">            msg.setData(bundle);</div><div class="line">            mHandler.sendMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>借助Handler，将数据同步到TextView上：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private Handler mHandler = new <span class="function"><span class="title">Handler</span></span>() &#123;</div><div class="line">    @Override</div><div class="line">    public void handleMessage(Message msg) &#123;</div><div class="line">        super.handleMessage(msg);</div><div class="line">        mTextView.setText(msg.getData().getString(<span class="string">"data"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="二、跨应用通信——AIDL"><a href="#二、跨应用通信——AIDL" class="headerlink" title="二、跨应用通信——AIDL"></a>二、跨应用通信——AIDL</h2><h4 id="1、跨应用启动Service"><a href="#1、跨应用启动Service" class="headerlink" title="1、跨应用启动Service"></a>1、跨应用启动Service</h4><p>从Android5.0以后，只能通过显示Intent来启动服务。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.xianxiaotao.firstapp;</div><div class="line"></div><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line">    private Intent mIntent;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        mIntent = new Intent();</div><div class="line">        mIntent.setComponent(new ComponentName(<span class="string">"com.xianxiaotao.secondapp"</span>, <span class="string">"com.xianxiaotao.secondapp.AppService"</span>));</div><div class="line">        startService(mIntent)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void <span class="function"><span class="title">onDestroy</span></span>() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">        stopService(mIntent);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="2、跨应用绑定Service"><a href="#2、跨应用绑定Service" class="headerlink" title="2、跨应用绑定Service"></a>2、跨应用绑定Service</h4><p>新建AIDL文件：New -&gt; AIDL -&gt; AIDL File -&gt; IAppServiceRemoteBinder.aidl<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">package com.xianxiaotao.secondapp;</div><div class="line"></div><div class="line">interface IAppServiceRemoteBinder &#123;</div><div class="line">    void basicTypes(int anInt, long aLong, boolean aBoolean, <span class="built_in">float</span> aFloat, double aDouble, String aString);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在Service里实现该接口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">package com.xianxiaotao.secondapp;</div><div class="line"></div><div class="line">public class AppService extends Service &#123;</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public IBinder onBind(Intent intent) &#123;</div><div class="line">        <span class="built_in">return</span> new IAppServiceRemoteBinder.<span class="function"><span class="title">Stub</span></span>() &#123;</div><div class="line">            @Override</div><div class="line">            public void basicTypes(int anInt, long aLong, boolean aBoolean, <span class="built_in">float</span> aFloat, double aDouble, String aString) &#123;</div><div class="line">                // TODO</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在第一个应用中绑定服务和解除绑定服务：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">bind</span>Service(mIntent, this, Context.BIND_AUTO_CREATE);</div><div class="line">unbindService(this);</div></pre></td></tr></table></figure></p><h4 id="3、跨应用绑定Service并通信"><a href="#3、跨应用绑定Service并通信" class="headerlink" title="3、跨应用绑定Service并通信"></a>3、跨应用绑定Service并通信</h4><p>在IAppServiceRemoteBinder接口中新增setData方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">interface IAppServiceRemoteBinder &#123;</div><div class="line">    void basicTypes(int anInt, long aLong, boolean aBoolean, <span class="built_in">float</span> aFloat, double aDouble, String aString);</div><div class="line">    void <span class="built_in">set</span>Data(String data);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其子类需要实现该方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public IBinder onBind(Intent intent) &#123;</div><div class="line">    <span class="built_in">return</span> new IAppServiceRemoteBinder.<span class="function"><span class="title">Stub</span></span>() &#123;</div><div class="line">        @Override</div><div class="line">        public void basicTypes(int anInt, long aLong, boolean aBoolean, <span class="built_in">float</span> aFloat, double aDouble, String aString) &#123;</div><div class="line">            // TODO</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void <span class="built_in">set</span>Data(String data) throws RemoteException &#123;</div><div class="line">            AppService.this.data = data;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在第一个应用里创同样的IAppServiceRemoteBinder.aidl文件，注意包名也要一致。</p><ul><li>firstApp -&gt; New -&gt; Folder -&gt; AIDL Folder</li><li>aidl -&gt; New -&gt; Package -&gt; com.xianxiaotao.secondapp -&gt; OK</li><li>在该文件夹里创建同样的IAppServiceRemoteBinder.aidl文件，测试时可以直接复制粘贴。<br>上述操作执行完毕后，该应用绑定secondapp的AppService时，可以获取到IBinder的实例了。<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private IAppServiceRemoteBinder binder = null;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void onServiceConnected(ComponentName name, IBinder service) &#123;</div><div class="line">    // 此处不能用强制类型转换，虽然类名相同，但两个类在内存中地址不一样</div><div class="line">    binder = IAppServiceRemoteBinder.Stub.asInterface(service);</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">if</span> (binder != null) &#123;</div><div class="line">    try &#123;</div><div class="line">        binder.setData(mEditText.getText().toString().trim());</div><div class="line">    &#125; catch (RemoteException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07 Service</title>
      <link href="/2017/05/26/03%20ANDROID/BASE/07Service/"/>
      <url>/2017/05/26/03%20ANDROID/BASE/07Service/</url>
      
        <content type="html"><![CDATA[<h2 id="一、初识Service"><a href="#一、初识Service" class="headerlink" title="一、初识Service"></a>一、初识Service</h2><h4 id="1、启动Service和停止Service"><a href="#1、启动Service和停止Service" class="headerlink" title="1、启动Service和停止Service"></a>1、启动Service和停止Service</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">startService(new Intent(MainActivity.this, MyService.class));// 启动服务</div><div class="line">stopService(new Intent(MainActivity.this, MyService.class));// 停止服务</div></pre></td></tr></table></figure><p>服务在系统中最多只有一个实例，即使上述代码中创建了两个不同的Intent实例，但是启动和停止的服务是同一个。只创建一个Intent实例也是可以的，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private Intent mIntent;</div><div class="line">...</div><div class="line">mIntent = new Intent(MainActivity.this, MyService.class);</div><div class="line">...</div><div class="line">startService(mIntent);</div><div class="line">...</div><div class="line">stopService(mIntent);</div></pre></td></tr></table></figure></p><p>Service代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">package com.xianxiaotao.learnservice;</div><div class="line"></div><div class="line">import android.app.Service;</div><div class="line">import android.content.Intent;</div><div class="line">import android.os.IBinder;</div><div class="line"></div><div class="line">public class MyService extends Service &#123;</div><div class="line">    public <span class="function"><span class="title">MyService</span></span>() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public IBinder onBind(Intent intent) &#123;</div><div class="line">        System.out.println(<span class="string">"MyService onBind"</span>);</div><div class="line">        <span class="built_in">return</span> new Binder();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void <span class="function"><span class="title">onCreate</span></span>() &#123;</div><div class="line">        super.onCreate();</div><div class="line">        System.out.println(<span class="string">"MyService onCreate"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int onStartCommand(Intent intent, int flags, int startId) &#123;</div><div class="line">        System.out.println(<span class="string">"MyService onStartCommand"</span>);</div><div class="line">        <span class="built_in">return</span> super.onStartCommand(intent, flags, startId);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void <span class="function"><span class="title">onDestroy</span></span>() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">        System.out.println(<span class="string">"MyService onDestroy"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="2、绑定Service和解除绑定服务"><a href="#2、绑定Service和解除绑定服务" class="headerlink" title="2、绑定Service和解除绑定服务"></a>2、绑定Service和解除绑定服务</h4><p>API:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 绑定服务的API</div><div class="line">public boolean <span class="built_in">bind</span>Service(Intent service, ServiceConnection conn, int flags) &#123;</div><div class="line"><span class="built_in">return</span> mBase.bindService(service, conn, flags);</div><div class="line">&#125;</div><div class="line">// 解除绑定服务的API</div><div class="line">public void unbindService(ServiceConnection conn) &#123;</div><div class="line">    mBase.unbindService(conn);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>实现接口ServiceConnection：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity implements ServiceConnection &#123;</div><div class="line"></div><div class="line">private Intent mIntent;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onServiceConnected(ComponentName name, IBinder service) &#123;</div><div class="line">        System.out.println(<span class="string">"Service Connected"</span>);// 服务被成功绑定之后执行</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onServiceDisconnected(ComponentName name) &#123;</div><div class="line">        System.out.println(<span class="string">"Service Disconnected"</span>);// 服务所在的进程崩溃时或者被<span class="built_in">kill</span>时执行</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>绑定Service和解除绑定Service：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">bind</span>Service(mIntent, MainActivity.this, Context.BIND_AUTO_CREATE);</div><div class="line">unbindService(MainActivity.this);</div></pre></td></tr></table></figure></p><h2 id="二、Service生命周期"><a href="#二、Service生命周期" class="headerlink" title="二、Service生命周期"></a>二、Service生命周期</h2><h4 id="1、启动服务生命周期"><a href="#1、启动服务生命周期" class="headerlink" title="1、启动服务生命周期"></a>1、启动服务生命周期</h4><p>第一次启动服务日志如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">I/System.out: MyService onCreate</div><div class="line">I/System.out: MyService onStartCommand</div></pre></td></tr></table></figure></p><p>第二、三次启动服务日志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">I/System.out: MyService onStartCommand</div><div class="line">I/System.out: MyService onStartCommand</div></pre></td></tr></table></figure></p><p>接着停止服务日志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">I/System.out: MyService onDestroy</div></pre></td></tr></table></figure></p><h4 id="2、启动服务后并退出"><a href="#2、启动服务后并退出" class="headerlink" title="2、启动服务后并退出"></a>2、启动服务后并退出</h4><p>启动服务后并退出当前程序的日志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">I/System.out: MyService onCreate</div><div class="line">I/System.out: MyService onStartCommand</div></pre></td></tr></table></figure></p><p>重新启动应用并停止服务：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">I/System.out: MyService onDestroy</div></pre></td></tr></table></figure></p><h4 id="3、绑定服务生命周期"><a href="#3、绑定服务生命周期" class="headerlink" title="3、绑定服务生命周期"></a>3、绑定服务生命周期</h4><p>第一次绑定服务日志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">I/System.out: MyService onCreate</div><div class="line">I/System.out: MyService onBind</div><div class="line">I/System.out: Service Connected</div></pre></td></tr></table></figure></p><p>第二、三次绑定服务无任何日志输出<br>解除绑定服务日志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">I/System.out: MyService onDestroy</div></pre></td></tr></table></figure></p><h4 id="4、绑定服务并退出"><a href="#4、绑定服务并退出" class="headerlink" title="4、绑定服务并退出"></a>4、绑定服务并退出</h4><p>成功绑定服务后并退出当前程序的日志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">I/System.out: MyService onCreate</div><div class="line">I/System.out: MyService onBind</div><div class="line">I/System.out: Service Connected</div><div class="line">E/ActivityThread: Activity com.xianxiaotao.learnservice.MainActivity has leaked ServiceConnection com.xianxiaotao.learnservice.MainActivity@f45fa7c that was originally bound here</div><div class="line">                  android.app.ServiceConnectionLeaked: Activity com.xianxiaotao.learnservice.MainActivity has leaked ServiceConnection com.xianxiaotao.learnservice.MainActivity@f45fa7c that was originally bound here</div><div class="line">                      at android.app.LoadedApk<span class="variable">$ServiceDispatcher</span>.&lt;init&gt;(LoadedApk.java:1336)</div><div class="line">                      at android.app.LoadedApk.getServiceDispatcher(LoadedApk.java:1231)</div><div class="line">                      at android.app.ContextImpl.bindServiceCommon(ContextImpl.java:1450)</div><div class="line">                      at android.app.ContextImpl.bindService(ContextImpl.java:1422)</div><div class="line">                      at android.content.ContextWrapper.bindService(ContextWrapper.java:636)</div><div class="line">                      at com.xianxiaotao.learnservice.MainActivity<span class="variable">$3</span>.onClick(MainActivity.java:39)</div><div class="line">                      at android.view.View.performClick(View.java:5637)</div><div class="line">                      at android.view.View<span class="variable">$PerformClick</span>.run(View.java:22429)</div><div class="line">                      at android.os.Handler.handleCallback(Handler.java:751)</div><div class="line">                      at android.os.Handler.dispatchMessage(Handler.java:95)</div><div class="line">                      at android.os.Looper.loop(Looper.java:154)</div><div class="line">                      at android.app.ActivityThread.main(ActivityThread.java:6121)</div><div class="line">                      at java.lang.reflect.Method.invoke(Native Method)</div><div class="line">                      at com.android.internal.os.ZygoteInit<span class="variable">$MethodAndArgsCaller</span>.run(ZygoteInit.java:889)</div><div class="line">                      at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:779)</div><div class="line">I/System.out: MyService onDestroy</div></pre></td></tr></table></figure></p><p>如果绑定服务后，请确保在异常情况下解除绑定服务。比如在Activity的onDestroy方法中解除绑定服务。</p><h4 id="5、启动服务后绑定服务"><a href="#5、启动服务后绑定服务" class="headerlink" title="5、启动服务后绑定服务"></a>5、启动服务后绑定服务</h4><p>启动服务：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">I/System.out: MyService onCreate</div><div class="line">I/System.out: MyService onStartCommand</div></pre></td></tr></table></figure></p><p>绑定服务：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">I/System.out: MyService onBind</div><div class="line">I/System.out: Service Connected</div></pre></td></tr></table></figure></p><p>解除绑定服务：无日志<br>停止服务：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">I/System.out: MyService onDestroy</div></pre></td></tr></table></figure></p><p>总结：</p><ul><li>启动服务后可以通过调用stopService()方法停止服务(也可以由其他应用程序调用、或者服务自身调用stopSelf()来停止服务）。</li><li>只有第一次启动服务时，系统会调用Service的onCreate和onStartCommand方法，其他只会调用onStartCommand方法。</li><li>绑定服务时，系统会调用Service的onCreate、onBind方法，以及ServiceConnection实现类的onServiceConnected方法。</li><li>如果绑定了服务，请在停止服务前或退出程序前必须解除服务绑定。</li></ul>]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06 Context</title>
      <link href="/2017/05/24/03%20ANDROID/BASE/06Context/"/>
      <url>/2017/05/24/03%20ANDROID/BASE/06Context/</url>
      
        <content type="html"><![CDATA[<p>本文参考阅读：<a href="http://www.jianshu.com/p/94e0f9ab3f1d" target="_blank" rel="external">Context都没弄明白，还怎么做Android开发？</a></p><h4 id="Activity-mActivity-new-Activity"><a href="#Activity-mActivity-new-Activity" class="headerlink" title="Activity mActivity = new Activity();"></a>Activity mActivity = new Activity();</h4><p>作为Android开发者，不知道你有没有思考过这个问题，Activity可以new吗？Android的应用程序开发采用JAVA语言，Activity本质上也是一个对象，那上面的写法有什么问题呢？估计很多人说不清道不明。Android程序不像Java程序一样，随便创建一个类，写个main()方法就能运行，Android应用模型是基于组件的应用设计模式，组件的运行要有一个完整的Android工程环境，在这个环境下，Activity、Service等系统组件才能够正常工作，而这些组件并不能采用普通的Java对象创建方式，new一下就能创建实例了，而是要有它们各自的上下文环境，也就是我们这里讨论的Context。可以这样讲，Context是维持Android程序中各组件能够正常工作的一个核心功能类。</p><h4 id="Context到底是什么"><a href="#Context到底是什么" class="headerlink" title="Context到底是什么"></a>Context到底是什么</h4><p>Context的中文翻译为：语境; 上下文; 背景; 环境，在开发中我们经常说称之为“上下文”，那么这个“上下文”到底是指什么意思呢？在语文中，我们可以理解为语境，在程序中，我们可以理解为当前对象在程序中所处的一个环境，一个与系统交互的过程。比如微信聊天，此时的“环境”是指聊天的界面以及相关的数据请求与传输，Context在加载资源、启动Activity、获取系统服务、创建View等操作都要参与。</p><p>那Context到底是什么呢？一个Activity就是一个Context，一个Service也是一个Context。Android程序员把“场景”抽象为Context类，他们认为用户和操作系统的每一次交互都是一个场景，比如打电话、发短信，这些都是一个有界面的场景，还有一些没有界面的场景，比如后台运行的服务（Service）。一个应用程序可以认为是一个工作环境，用户在这个环境中会切换到不同的场景，这就像一个前台秘书，她可能需要接待客人，可能要打印文件，还可能要接听客户电话，而这些就称之为不同的场景，前台秘书可以称之为一个应用程序。</p><h4 id="如何生动形象的理解Context"><a href="#如何生动形象的理解Context" class="headerlink" title="如何生动形象的理解Context"></a>如何生动形象的理解Context</h4><p>上面的概念中采用了通俗的理解方式，将Context理解为“上下文”或者“场景”，如果你仍然觉得很抽象，不好理解。在这里我给出一个可能不是很恰当的比喻，希望有助于大家的理解：一个Android应用程序，可以理解为一部电影或者一部电视剧，Activity，Service，Broadcast Receiver，Content Provider这四大组件就好比是这部戏里的四个主角：胡歌，霍建华，诗诗，Baby。他们是由剧组（系统）一开始就定好了的，整部戏就是由这四位主演领衔担纲的，所以这四位主角并不是大街上随随便便拉个人（new 一个对象）都能演的。有了演员当然也得有摄像机拍摄啊，他们必须通过镜头（Context）才能将戏传递给观众，这也就正对应说四大组件（四位主角）必须工作在Context环境下（摄像机镜头）。那Button，TextView，LinearLayout这些控件呢，就好比是这部戏里的配角或者说群众演员，他们显然没有这么重用，随便一个路人甲路人乙都能演（可以new一个对象），但是他们也必须要面对镜头（工作在Context环境下），所以Button mButton=new Button（Context）是可以的。虽然不很恰当，但还是很容易理解的，希望有帮助。</p><h4 id="源码中的Context"><a href="#源码中的Context" class="headerlink" title="源码中的Context"></a>源码中的Context</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Interface to global information about an application environment.  This is</div><div class="line"> * an abstract class whose implementation is provided by</div><div class="line"> * the Android system.  It</div><div class="line"> * allows access to application-specific resources and classes, as well as</div><div class="line"> * up-calls <span class="keyword">for</span> application-level operations such as launching activities,</div><div class="line"> * broadcasting and receiving intents, etc.</div><div class="line"> */</div><div class="line">public abstract class Context &#123;</div><div class="line">    /**</div><div class="line">     * File creation mode: the default mode, <span class="built_in">where</span> the created file can only</div><div class="line">     * be accessed by the calling application (or all applications sharing the</div><div class="line">     * same user ID).</div><div class="line">     */</div><div class="line">    public static final int MODE_PRIVATE = 0x0000;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>源码中的注释是这么来解释Context的：Context提供了关于应用环境全局信息的接口。它是一个抽象类，它的执行被Android系统所提供。它允许获取以应用为特征的资源和类型，是一个统领一些资源（应用程序环境变量等）的上下文。就是说，它描述一个应用程序环境的信息（即上下文）；是一个抽象类，Android提供了该抽象类的具体实现类；通过它我们可以获取应用程序的资源和类（包括应用级别操作，如启动Activity，发广播，接受Intent等）。既然上面Context是一个抽象类，那么肯定有他的实现类咯，我们在Context的源码中通过IDE可以查看到他的子类最终可以得到如下关系图：<br><img src="http://ww1.sinaimg.cn/large/adc90466ly1ffwafz832kj20hg0eejrg.jpg" alt="Context继承关系图"><br>Context类本身是一个纯abstract类，它有两个具体的实现子类：ContextImpl和ContextWrapper。其中ContextWrapper类，如其名所言，这只是一个包装而已，ContextWrapper构造函数中必须包含一个真正的Context引用，同时ContextWrapper中提供了attachBaseContext（）用于给ContextWrapper对象中指定真正的Context对象，调用ContextWrapper的方法都会被转向其所包含的真正的Context对象。ContextThemeWrapper类，如其名所言，其内部包含了与主题（Theme）相关的接口，这里所说的主题就是指在AndroidManifest.xml中通过android：theme为Application元素或者Activity元素指定的主题。当然，只有Activity才需要主题，Service是不需要主题的，因为Service是没有界面的后台场景，所以Service直接继承于ContextWrapper，Application同理。而ContextImpl类则真正实现了Context中的所以函数，应用程序中所调用的各种Context类的方法，其实现均来自于该类。一句话总结：Context的两个子类分工明确，其中ContextImpl是Context的具体实现类，ContextWrapper是Context的包装类。Activity，Application，Service虽都继承自ContextWrapper（Activity继承自ContextWrapper的子类ContextThemeWrapper），但它们初始化的过程中都会创建ContextImpl对象，由ContextImpl实现Context中的方法。</p><h4 id="一个应用程序有几个Context"><a href="#一个应用程序有几个Context" class="headerlink" title="一个应用程序有几个Context"></a>一个应用程序有几个Context</h4><p>其实这个问题本身并没有什么意义，关键还是在于对Context的理解，从上面的关系图我们已经可以得出答案了，在应用程序中Context的具体实现子类就是：Activity，Service，Application。那么Context数量=Activity数量+Service数量+应用进程数量(一般为1)。当然如果你足够细心，可能会有疑问：我们常说四大组件，这里怎么只有Activity，Service持有Context，那Broadcast Receiver，Content Provider呢？Broadcast Receiver，Content Provider并不是Context的子类，他们所持有的Context都是其他地方传过去的，所以并不计入Context总数。上面的关系图也从另外一个侧面告诉我们Context类在整个Android系统中的地位是多么的崇高，因为很显然Activity，Service，Application都是其子类，其地位和作用不言而喻。</p><h4 id="Context能干什么"><a href="#Context能干什么" class="headerlink" title="Context能干什么"></a>Context能干什么</h4><p>Context到底可以实现哪些功能呢？这个就实在是太多了，弹出Toast、启动Activity、启动Service、发送广播、操作数据库等等都需要用到Context。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">TextView tv = new TextView(getContext());</div><div class="line">ListAdapter adapter = new SimpleCursorAdapter(getApplicationContext(), ...);</div><div class="line">AudioManager am = (AudioManager) getContext().getSystemService(Context.AUDIO_SERVICE);getApplicationContext().getSharedPreferences(name, mode);</div><div class="line">getApplicationContext().getContentResolver().query(uri, ...);</div><div class="line">getContext().getResources().getDisplayMetrics().widthPixels * 5 / 8;</div><div class="line">getContext().startActivity(intent);</div><div class="line">getContext().startService(intent);</div><div class="line">getContext().sendBroadcast(intent);</div></pre></td></tr></table></figure></p><h4 id="Context作用域"><a href="#Context作用域" class="headerlink" title="Context作用域"></a>Context作用域</h4><p>虽然Context神通广大，但并不是随便拿到一个Context实例就可以为所欲为，它的使用还是有一些规则限制的。由于Context的具体实例是由ContextImpl类去实现的，因此在绝大多数场景下，Activity、Service和Application这三种类型的Context都是可以通用的。不过有几种场景比较特殊，比如启动Activity，还有弹出Dialog。出于安全原因的考虑，Android是不允许Activity或Dialog凭空出现的，一个Activity的启动必须要建立在另一个Activity的基础之上，也就是以此形成的返回栈。而Dialog则必须在一个Activity上面弹出（除非是System Alert类型的Dialog），因此在这种场景下，我们只能使用Activity类型的Context，否则将会出错。<br><img src="http://ww1.sinaimg.cn/large/adc90466ly1ffwalj4c9fj20gd0bk758.jpg" alt="Context作用域"><br>从上图我们可以发现Activity所持有的Context的作用域最广，无所不能。因为Activity继承自ContextThemeWrapper，而Application和Service继承自ContextWrapper，很显然ContextThemeWrapper在ContextWrapper的基础上又做了一些操作使得Activity变得更强大，这里我就不再贴源码给大家分析了，有兴趣的童鞋可以自己查查源码。上图中的YES和NO我也不再做过多的解释了，这里我说一下上图中Application和Service所不推荐的两种使用情况。<br>1：如果我们用ApplicationContext去启动一个LaunchMode为standard的Activity的时候会报错android.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?这是因为非Activity类型的Context并没有所谓的任务栈，所以待启动的Activity就找不到栈了。解决这个问题的方法就是为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候就为它创建一个新的任务栈，而此时Activity是以singleTask模式启动的。所有这种用Application启动Activity的方式不推荐使用，Service同Application。<br>2：在Application和Service中去layout inflate也是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。所以这种方式也不推荐使用。<br>一句话总结：凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。</p><h4 id="如何获取Context"><a href="#如何获取Context" class="headerlink" title="如何获取Context"></a>如何获取Context</h4><p>通常我们想要获取Context对象，主要有以下四种方法<br>1：View.getContext,返回当前View对象的Context对象，通常是当前正在展示的Activity对象。<br>2：Activity.getApplicationContext,获取当前Activity所在的(应用)进程的Context对象，通常我们使用Context对象时，要优先考虑这个全局的进程Context。<br>3：ContextWrapper.getBaseContext():用来获取一个ContextWrapper进行装饰之前的Context，可以使用这个方法，这个方法在实际开发中使用并不多，也不建议使用。<br>4：Activity.this 返回当前的Activity实例，如果是UI控件需要使用Activity作为Context对象，但是默认的Toast实际上使用ApplicationContext也可以。</p><h4 id="getApplication-和getApplicationContext"><a href="#getApplication-和getApplicationContext" class="headerlink" title="getApplication()和getApplicationContext()"></a>getApplication()和getApplicationContext()</h4><p>上面说到获取当前Application对象用getApplicationContext，不知道你有没有联想到getApplication()，这两个方法有什么区别？相信这个问题会难倒不少开发者。<br><img src="http://ww1.sinaimg.cn/large/adc90466ly1ffwao49ze7j20gv0cxdgp.jpg" alt="getApplication()&amp;getApplicationContext()"><br>程序是不会骗人的，我们通过上面的代码，打印得出两者的内存地址都是相同的，看来它们是同一个对象。其实这个结果也很好理解，因为前面已经说过了，Application本身就是一个Context，所以这里获取getApplicationContext()得到的结果就是Application本身的实例。那么问题来了，既然这两个方法得到的结果都是相同的，那么Android为什么要提供两个功能重复的方法呢？实际上这两个方法在作用域上有比较大的区别。getApplication()方法的语义性非常强，一看就知道是用来获取Application实例的，但是这个方法只有在Activity和Service中才能调用的到。那么也许在绝大多数情况下我们都是在Activity或者Service中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助getApplicationContext()方法了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class MyReceiver extends BroadcastReceiver&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    publicvoidonReceive(Contextcontext,Intentintent)&#123;</div><div class="line">        ApplicationmyApp=(Application)context.getApplicationContext();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="Context引起的内存泄露"><a href="#Context引起的内存泄露" class="headerlink" title="Context引起的内存泄露"></a>Context引起的内存泄露</h4><p>但Context并不能随便乱用，用的不好有可能会引起内存泄露的问题，下面就示例两种错误的引用方式。</p><h5 id="错误的单例模式"><a href="#错误的单例模式" class="headerlink" title="错误的单例模式:"></a>错误的单例模式:</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;</div><div class="line">    private static Singleton instance;</div><div class="line">    private Context mContext;</div><div class="line"></div><div class="line">    private Singleton(Context context) &#123;</div><div class="line">        this.mContext = context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Singleton getInstance(Context context) &#123;</div><div class="line">        <span class="keyword">if</span> (instance == null) &#123;</div><div class="line">            instance = new Singleton(context);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是一个非线程安全的单例模式，instance作为静态对象，其生命周期要长于普通的对象，其中也包含Activity，假如Activity A去getInstance获得instance对象，传入this，常驻内存的Singleton保存了你传入的Activity A对象，并一直持有，即使Activity被销毁掉，但因为它的引用还存在于一个Singleton中，就不可能被GC掉，这样就导致了内存泄漏。</p><h5 id="View持有Activity引用"><a href="#View持有Activity引用" class="headerlink" title="View持有Activity引用:"></a>View持有Activity引用:</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends Activity &#123;</div><div class="line">    private static Drawable mDrawable;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle saveInstanceState) &#123;</div><div class="line">        super.onCreate(saveInstanceState);</div><div class="line">        <span class="built_in">set</span>ContentView(R.layout.activity_main);</div><div class="line">        ImageView iv = new ImageView(this);</div><div class="line">        mDrawable = getResources().getDrawable(R.drawable.ic_launcher);</div><div class="line">        iv.setImageDrawable(mDrawable);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>有一个静态的Drawable对象当ImageView设置这个Drawable时，ImageView保存了mDrawable的引用，而ImageView传入的this是MainActivity的mContext，因为被static修饰的mDrawable是常驻内存的，MainActivity是它的间接引用，MainActivity被销毁时，也不能被GC掉，所以造成内存泄漏。</p><h4 id="正确使用Context"><a href="#正确使用Context" class="headerlink" title="正确使用Context"></a>正确使用Context</h4><p>一般Context造成的内存泄漏，几乎都是当Context销毁的时候，却因为被引用导致销毁失败，而Application的Context对象可以理解为随着进程存在的，所以我们总结出使用Context的正确姿势：<br>1：当Application的Context能搞定的情况下，并且生命周期长的对象，优先使用Application的Context。<br>2：不要让生命周期长于Activity的对象持有到Activity的引用。<br>3：尽量不要在Activity中使用非静态内部类，因为非静态内部类会隐式持有外部类实例的引用，如果使用静态内部类，将外部实例引用作为弱引用持有。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总之Context在Android系统中的地位很重要，它几乎无所不能，但它也不是你想用就能随便用的，谨防使用不当引起的内存问题。</p>]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05 Intent概念及应用</title>
      <link href="/2017/05/24/03%20ANDROID/BASE/05Intent%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>/2017/05/24/03%20ANDROID/BASE/05Intent%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>启动Activity分为两种，显示调用和隐式调用。显示调用通过指定Intent组件名称来实现的，它一般用在知道目标组件名称的前提下，一般是在相同的应用程序内部实现的。隐式调用通过Intent Filter来实现的，它一般用在没有明确指出目标组件名称的前提下，一般是用于在不同应用程序之间。</p><h4 id="显示调用"><a href="#显示调用" class="headerlink" title="显示调用"></a>显示调用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent=new Intent(MainActivity.this,SettingActivity.class);</div><div class="line">intent.putExtra(EXTRA,contentEditText.getText().toString());</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure><p>而Manifest文件描述为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;activity android:name=<span class="string">".MainActivity"</span> &gt; </div><div class="line">    &lt;intent-filter&gt; </div><div class="line">        &lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt; </div><div class="line">        &lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt; </div><div class="line">    &lt;/intent-filter&gt; </div><div class="line">&lt;/activity&gt; </div><div class="line">&lt;activity android:name=<span class="string">".SettingActivity"</span> /&gt;</div></pre></td></tr></table></figure></p><h4 id="隐式调用"><a href="#隐式调用" class="headerlink" title="隐式调用"></a>隐式调用</h4><p>隐式不明确指定启动哪个Activity，而是在Intent Filter中设置Action、Data、Category，让系统来筛选出合适的Activity。清单文件配置如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</div><div class="line">&lt;manifest xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    package=<span class="string">"com.king.bester.myapplication"</span>&gt;</div><div class="line"></div><div class="line">    &lt;application</div><div class="line">        android:allowBackup=<span class="string">"true"</span></div><div class="line">        android:icon=<span class="string">"@mipmap/ic_launcher"</span></div><div class="line">        android:supportsRtl=<span class="string">"true"</span></div><div class="line">        android:theme=<span class="string">"@style/AppTheme"</span>&gt;</div><div class="line">        &lt;activity android:name=<span class="string">".MainActivity"</span> &gt;</div><div class="line">            &lt;intent-filter&gt;</div><div class="line">                &lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</div><div class="line">                &lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</div><div class="line">            &lt;/intent-filter&gt;</div><div class="line">        &lt;/activity&gt;</div><div class="line"></div><div class="line">        &lt;activity</div><div class="line">            android:name=<span class="string">".TargetActivity"</span></div><div class="line">            android:launchMode=<span class="string">"singleTask"</span></div><div class="line">            android:taskAffinity=<span class="string">"com.king.bester.myapplication"</span> &gt;</div><div class="line">            &lt;intent-filter&gt;</div><div class="line">                &lt;action android:name=<span class="string">"android.intent.action.SEND"</span>/&gt;</div><div class="line">                &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</div><div class="line">                &lt;data android:mimeType=<span class="string">"text/plain"</span>/&gt;</div><div class="line">            &lt;/intent-filter&gt;</div><div class="line">            &lt;intent-filter&gt;</div><div class="line">                &lt;action android:name=<span class="string">"com.king.bester.demo"</span> /&gt;</div><div class="line">                &lt;action android:name=<span class="string">"com.king.bester.DEMO"</span> /&gt;</div><div class="line">                &lt;category android:name=<span class="string">"com.king.bester.a"</span> /&gt;</div><div class="line">                &lt;category android:name=<span class="string">"com.king.bester.b"</span> /&gt;</div><div class="line">                &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</div><div class="line">                &lt;data android:mimeType=<span class="string">"text/plain"</span>/&gt;</div><div class="line">            &lt;/intent-filter&gt;</div><div class="line">        &lt;/activity&gt;</div><div class="line">    &lt;/application&gt;</div><div class="line"></div><div class="line">&lt;/manifest&gt;</div></pre></td></tr></table></figure></p><p>代码调用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 匹配第一组intent-filter</div><div class="line">public void startA(View view) &#123;</div><div class="line">    Intent intent = new Intent();</div><div class="line">    intent.setAction(<span class="string">"android.intent.action.SEND"</span>);</div><div class="line">    intent.setType(<span class="string">"text/plain"</span>);</div><div class="line">    startActivity(intent);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 匹配第二组intent-filter</div><div class="line">public void startB(View view) &#123;</div><div class="line">    Intent intent = new Intent();</div><div class="line">    intent.setAction(<span class="string">"com.king.bester.demo"</span>);</div><div class="line">    intent.addCategory(<span class="string">"com.king.bester.a"</span>);</div><div class="line">    intent.setType(<span class="string">"text/plain"</span>);</div><div class="line">    startActivity(intent);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>1、startA()中没有设置category，是因为系统在调用startActivity或者startActivityForResult的时候会默认为Intent加上“android.intent.category.DEFAULT”这个category。所以，为了我们的Activity能接收隐式调用，必须在intent-filter中指定这个category。<br>2、action区分大小写<br>3、一个Activity可以有多个intent-filter，一个intent只要能匹配任何一组intent-filter即可启动对应的Activity。</p><h4 id="浏览器启动本地App"><a href="#浏览器启动本地App" class="headerlink" title="浏览器启动本地App"></a>浏览器启动本地App</h4><p>Intent的过滤器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;intent-filter&gt;</div><div class="line">    &lt;action android:name=<span class="string">"android.intent.action.VIEW"</span>/&gt;</div><div class="line">    &lt;category android:name=<span class="string">"android.intent.category.BROWSABLE"</span>/&gt;</div><div class="line">    &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</div><div class="line">    &lt;data android:scheme=<span class="string">"app"</span>/&gt;</div><div class="line">&lt;/intent-filter&gt;</div></pre></td></tr></table></figure></p><p>网页链接：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a href=<span class="string">"app://hello"</span>&gt;Launch My App&lt;/a&gt;</div></pre></td></tr></table></figure></p><p>代码获取网页传递过来的参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Uri uri = getIntent().getData();</div><div class="line">System.out.println(uri);</div></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app://hello</div></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04 Activity启动模式</title>
      <link href="/2017/05/23/03%20ANDROID/BASE/04Activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/05/23/03%20ANDROID/BASE/04Activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>ActivityManagerService（AMS）内部维护着一个ActivityStack栈，系统会将Activity实例一一放入栈内（先进后出），默认情况下创建一个实例压入栈内。如果多次创建同一个Activity，栈内将压入多个实例。为此，Android提供了启动模式来修改系统的默认行为。目前有四种启动模式：standard、singleTop、singleTask和singleInstance。</p><h2 id="一、代码"><a href="#一、代码" class="headerlink" title="一、代码"></a>一、代码</h2><p>BaseActivity:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">package com.xianxiaotao.launchmode;</div><div class="line"></div><div class="line">import android.content.Intent;</div><div class="line">import android.content.pm.ActivityInfo;</div><div class="line">import android.content.pm.PackageManager;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.support.v7.app.AppCompatActivity;</div><div class="line">import android.util.Log;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by xianxiaotao on 17/5/23.</div><div class="line"> *</div><div class="line"> * 基类：输出Activity实例信息及所属任务栈信息</div><div class="line"> */</div><div class="line"></div><div class="line">public class BaseActivity extends AppCompatActivity &#123;</div><div class="line">    private static final String TAG = <span class="string">"Xian Xiaotao"</span>;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">        // 区别类名，区别同类名是否同实例，区别任务栈</div><div class="line">        Log.i(TAG, <span class="string">"onCreate："</span> + getClass().getSimpleName() + <span class="string">" hasCode:"</span> + this.hashCode() + <span class="string">" TaskId: "</span> + getTaskId());</div><div class="line">        // 任务栈名称，默认为包名相关</div><div class="line">        dumpTaskAffinity();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onNewIntent(Intent intent) &#123;</div><div class="line">        super.onNewIntent(intent);</div><div class="line"></div><div class="line">        Log.i(TAG, <span class="string">"onNewIntent："</span> + getClass().getSimpleName() + <span class="string">" hasCode:"</span> + this.hashCode() + <span class="string">" TaskId: "</span> + getTaskId());</div><div class="line">        dumpTaskAffinity();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void <span class="function"><span class="title">dumpTaskAffinity</span></span>()&#123;</div><div class="line">        try &#123;</div><div class="line">            ActivityInfo info = this.getPackageManager().getActivityInfo(getComponentName(), PackageManager.GET_META_DATA);</div><div class="line">            Log.i(TAG, <span class="string">"taskAffinity:"</span> + info.taskAffinity);</div><div class="line">        &#125; catch (PackageManager.NameNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>MainActivity:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">package com.xianxiaotao.launchmode;</div><div class="line"></div><div class="line">import android.content.Intent;</div><div class="line">import android.support.v7.app.AppCompatActivity;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.view.View;</div><div class="line"></div><div class="line">public class MainActivity extends BaseActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        <span class="built_in">set</span>ContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        findViewById(R.id.startMainButton).setOnClickListener(new View.<span class="function"><span class="title">OnClickListener</span></span>() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                startActivity(new Intent(MainActivity.this, MainActivity.class));</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        findViewById(R.id.startOtherButton).setOnClickListener(new View.<span class="function"><span class="title">OnClickListener</span></span>() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                startActivity(new Intent(MainActivity.this, OtherActivity.class));</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>OtherActivity:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">package com.xianxiaotao.launchmode;</div><div class="line"></div><div class="line">import android.content.Intent;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.view.View;</div><div class="line"></div><div class="line">public class OtherActivity extends BaseActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        <span class="built_in">set</span>ContentView(R.layout.activity_other);</div><div class="line"></div><div class="line">        findViewById(R.id.startMainButton).setOnClickListener(new View.<span class="function"><span class="title">OnClickListener</span></span>() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                startActivity(new Intent(OtherActivity.this, MainActivity.class));</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        findViewById(R.id.startOtherButton).setOnClickListener(new View.<span class="function"><span class="title">OnClickListener</span></span>() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                startActivity(new Intent(OtherActivity.this, OtherActivity.class));</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>布局文件activity_main.xml，activity_other.xml文件与此类似<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    android:id=<span class="string">"@+id/activity_main"</span></div><div class="line">    android:layout_width=<span class="string">"match_parent"</span></div><div class="line">    android:layout_height=<span class="string">"match_parent"</span></div><div class="line">    android:orientation=<span class="string">"vertical"</span> &gt;</div><div class="line"></div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=<span class="string">"wrap_content"</span></div><div class="line">        android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">        android:text=<span class="string">"This is main activity"</span>/&gt;</div><div class="line"></div><div class="line">    &lt;Button</div><div class="line">        android:id=<span class="string">"@+id/startMainButton"</span></div><div class="line">        android:layout_width=<span class="string">"wrap_content"</span></div><div class="line">        android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">        android:textAllCaps=<span class="string">"false"</span></div><div class="line">        android:text=<span class="string">"Start Main Activity"</span>/&gt;</div><div class="line"></div><div class="line">    &lt;Button</div><div class="line">        android:id=<span class="string">"@+id/startOtherButton"</span></div><div class="line">        android:layout_width=<span class="string">"wrap_content"</span></div><div class="line">        android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">        android:textAllCaps=<span class="string">"false"</span></div><div class="line">        android:text=<span class="string">"Start Other Activity"</span>/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><h2 id="二、测试"><a href="#二、测试" class="headerlink" title="二、测试"></a>二、测试</h2><h4 id="1、standard"><a href="#1、standard" class="headerlink" title="1、standard"></a>1、standard</h4><p>两个Activity都没有设置启动模式，即默认为标准模式。然后启动App，点击Start Main Activity按钮，然后再点击Start Other Activity按钮，然后再点击Start Main Activity。日志输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">I/Xian Xiaotao: onCreate：MainActivity hasCode:110059330 TaskId: 523</div><div class="line">I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmode</div><div class="line">I/Xian Xiaotao: onCreate：MainActivity hasCode:250944109 TaskId: 523</div><div class="line">I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmode</div><div class="line">I/Xian Xiaotao: onCreate：OtherActivity hasCode:39080781 TaskId: 523</div><div class="line">I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmode</div><div class="line">I/Xian Xiaotao: onCreate：MainActivity hasCode:42988356 TaskId: 523</div><div class="line">I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmode</div></pre></td></tr></table></figure></p><p>上述日志中所有的hashCode都不相同，即每次启动Activity都创建一个新的实例。连续按四次返回键退出应用。<br>TaskId都相同，表明这些实例都在同一个任务栈里。</p><h4 id="2、singleTop"><a href="#2、singleTop" class="headerlink" title="2、singleTop"></a>2、singleTop</h4><p>在AndroidMainfest.xml文件中，为MainActivity添加属性：android:launchMode=”singleTop”。启动App、点击Start Main Activity按钮、再点击Start Other Activity按钮，再点击Start Main Activity。日志输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">I/Xian Xiaotao: onCreate：MainActivity hasCode:29797800 TaskId: 525</div><div class="line">I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmode</div><div class="line">I/Xian Xiaotao: onNewIntent：MainActivity hasCode:29797800 TaskId: 525</div><div class="line">I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmode</div><div class="line">I/Xian Xiaotao: onCreate：OtherActivity hasCode:42572600 TaskId: 525</div><div class="line">I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmode</div><div class="line">I/Xian Xiaotao: onCreate：MainActivity hasCode:97104763 TaskId: 525</div><div class="line">I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmode</div></pre></td></tr></table></figure></p><p>第一次点击Start Main Activity按钮时，调用了onNewIntent方法，且hashCode与之前的MainActivity实例的hashCode相同，即复用实例而不是重新创建。第二次点击Start Main Activity按钮时，也就是说从OtherActivity里启动MainActivity，此时调用了onCreate方法，而且hashCode与之前的不相同，即重新创建了MainActivity的实例。连续按三次返回键退出应用。<br>TaskId都相同，表明这些实例都在同一个任务栈里。</p><h4 id="3、singleTask"><a href="#3、singleTask" class="headerlink" title="3、singleTask"></a>3、singleTask</h4><p>将MainActivity设置为singleTop，然后执行之前相同的动作。日志输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">I/Xian Xiaotao: onCreate：MainActivity hasCode:29797800 TaskId: 527</div><div class="line">I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmode</div><div class="line">I/Xian Xiaotao: onNewIntent：MainActivity hasCode:29797800 TaskId: 527</div><div class="line">I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmode</div><div class="line">I/Xian Xiaotao: onCreate：OtherActivity hasCode:121783201 TaskId: 527</div><div class="line">I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmode</div><div class="line">I/Xian Xiaotao: onNewIntent：MainActivity hasCode:29797800 TaskId: 527</div><div class="line">I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmode</div></pre></td></tr></table></figure></p><p>此时发现MainActivity的实例都相同，即第一次创建后，后面的都是复用实例而不是重新创建。按一次返回键退出应用。<br>TaskId都相同，表明这些实例都在同一个任务栈里。</p><h4 id="4、singleInstance"><a href="#4、singleInstance" class="headerlink" title="4、singleInstance"></a>4、singleInstance</h4><p>将MainActivity设置为singleInstance，然后执行之前相同的动作。日志输出如下：<br>I/Xian Xiaotao: onCreate：MainActivity hasCode:29797800 TaskId: 529<br>I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmode<br>I/Xian Xiaotao: onNewIntent：MainActivity hasCode:29797800 TaskId: 529<br>I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmode<br>I/Xian Xiaotao: onCreate：OtherActivity hasCode:42572600 TaskId: 530<br>I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmode<br>I/Xian Xiaotao: onNewIntent：MainActivity hasCode:29797800 TaskId: 529<br>I/Xian Xiaotao: taskAffinity:com.xianxiaotao.launchmode<br>此时发现MainActivity的实例依然相同，即第一次创建后，后面的都是复用实例而不是重新创建。按两次返回键退出应用。<br>TaskId不同，即MainActivity与OtherActivity不在一个Activity中。</p><blockquote><p>读者可以通过多个Activity设置不同的启动模式进行复杂的测试。</p></blockquote><h2 id="三、结论"><a href="#三、结论" class="headerlink" title="三、结论"></a>三、结论</h2><h4 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h4><p>标准模式，也是系统默认模式。每次启动一个Activity都会重新创建一个新的实例，不管这个实例是否已经存在。谁启动了这个Activity，那么这个Activity就运行在启动它的那个Activity所在的栈中。ABCBB</p><h4 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h4><p>栈顶复用模式。如果新Activity已经位于任务栈的栈顶，那么只调用它的onNewIntent方法实现复用，而不会创建新的实例。如果新的Activity的实例已存在但不是位于栈顶，仍然重新创建。假设目前栈内情况为ABCD（ABCD为四个Activity，A位于栈底），此时再次启动，如果D的启动模式为singleTop，那么栈内仍然是ABCD；如果D的启动模式为standard，D将被重新创建，栈内情况变为ABCDD。</p><h4 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h4><p>栈内复用模式。在同一个栈内，它是单实例模式。在这种模式下，启动一个Activity A，系统首先会寻找是否存在A想要的任务栈，如果不存在，就重新创建一个任务栈，然后创建A的实例并压入栈内；如果存在所需的任务栈，这时要看A是否在栈中有实例存在，如果有，那么系统就会把A调到栈顶并调用它的onNewIntent方法，不存在就创建并压入栈中。<br>1、目前任务栈栈S1(ABC)，此时Activity D以singleTask模式请求启动，其所需的任务栈为S2，由于S2和D的实例均不存在，所以系统先创建任务栈S2，然后再创建D的实例并将其放入栈S2中。<br>2、另外一种情况，假设D所需的任务栈为S1，上述S1已存在，所以系统会直接创建D的实例并压入栈S1内。<br>3、如果D所需的任务栈为S1，其中为ADBC，此时系统将D上面的Activity出栈，把D切换到栈顶并调用onNewIntent方法，最终S1栈内为AD。</p><h4 id="singleInstance："><a href="#singleInstance：" class="headerlink" title="singleInstance："></a>singleInstance：</h4><p>该模式具备singleTask模式的所有特性外，与它的区别就是，这种模式下的Activity会单独占用一个Task栈，具有全局唯一性，即整个系统中就这么一个实例，由于栈内复用的特性，后续的请求均不会创建新的Activity实例，除非这个特殊的任务栈被销毁了。以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。</p><p><a href="http://blog.csdn.net/mynameishuangshuai/article/details/51491074" target="_blank" rel="external">启动模式参考博客</a></p>]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03 Activity之间传递参数</title>
      <link href="/2017/05/23/03%20ANDROID/BASE/03Activity%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/"/>
      <url>/2017/05/23/03%20ANDROID/BASE/03Activity%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="一、传递简单数据"><a href="#一、传递简单数据" class="headerlink" title="一、传递简单数据"></a>一、传递简单数据</h4><p>发送数据：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent(MainActivity.this, OtherActivity.class);</div><div class="line">intent.putExtra(<span class="string">"data"</span>, <span class="string">"data value"</span>);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p><p>接受数据：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String data = getIntent().getStringExtra(<span class="string">"data"</span>);</div><div class="line">textView.setText(data);</div></pre></td></tr></table></figure></p><p>优化代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">// 传递参数</div><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        <span class="built_in">set</span>ContentView(R.layout.activity_main);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void sendArgs(View view) &#123;</div><div class="line">        Intent intent = OtherActivity.newIntent(this, <span class="string">"data value"</span>);</div><div class="line">        startActivity(intent);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 接受参数</div><div class="line">public class OtherActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private static final String ARG = <span class="string">"data"</span>;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        <span class="built_in">set</span>ContentView(R.layout.activity_other);</div><div class="line"></div><div class="line">        TextView textView = (TextView) findViewById(R.id.tv);</div><div class="line">        String data = getIntent().getStringExtra(ARG);</div><div class="line">        textView.setText(data);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 解除参数名称<span class="string">"data"</span>带来的依赖性</div><div class="line">    public static Intent newIntent(Context context, String data) &#123;</div><div class="line">        Intent intent = new Intent(context, OtherActivity.class);</div><div class="line">        intent.putExtra(ARG, data);</div><div class="line">        <span class="built_in">return</span> intent;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="二、传递数据包Bundle"><a href="#二、传递数据包Bundle" class="headerlink" title="二、传递数据包Bundle"></a>二、传递数据包Bundle</h4><p>发送数据包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent(MainActivity.this, OtherActivity.class);</div><div class="line">Bundle bundle = new Bundle();</div><div class="line">bundle.putString(<span class="string">"name"</span>, <span class="string">"xian xiaotao"</span>);</div><div class="line">bundle.putInt(<span class="string">"age"</span>, 28);</div><div class="line">intent.putExtras(bundle);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p><p>接受数据包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Bundle data = getIntent().getExtras();</div><div class="line">textView.setText(String.format(Locale.getDefault(), <span class="string">"name=%s,age=%d"</span>, data.getString(<span class="string">"name"</span>), data.getInt(<span class="string">"age"</span>)));</div></pre></td></tr></table></figure></p><h4 id="三、传递值对象"><a href="#三、传递值对象" class="headerlink" title="三、传递值对象"></a>三、传递值对象</h4><p>实现Parcelable<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">import android.os.Parcel;</div><div class="line">import android.os.Parcelable;</div><div class="line"></div><div class="line">public class User implements Parcelable &#123;</div><div class="line">    private String mName;</div><div class="line">    private int mAge;</div><div class="line"></div><div class="line">    public User(String name, int age) &#123;</div><div class="line">        mName = name;</div><div class="line">        mAge = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String <span class="function"><span class="title">getName</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> mName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void <span class="built_in">set</span>Name(String name) &#123;</div><div class="line">        mName = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int <span class="function"><span class="title">getAge</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> mAge;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void <span class="built_in">set</span>Age(int age) &#123;</div><div class="line">        mAge = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int <span class="function"><span class="title">describeContents</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</div><div class="line">        // 更复杂的数据借用Bundle</div><div class="line">        dest.writeString(getName());</div><div class="line">        dest.writeInt(getAge());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        public User createFromParcel(Parcel <span class="built_in">source</span>) &#123;</div><div class="line">            <span class="built_in">return</span> new User(source.readString(), source.readInt());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public User[] newArray(int size) &#123;</div><div class="line">            <span class="built_in">return</span> new User[size];</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>传递参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent(MainActivity.this, OtherActivity.class);</div><div class="line">intent.putExtra(<span class="string">"user"</span>, new User(<span class="string">"xian xiaotao"</span>, 28));</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p><p>接收参数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">User user = getIntent().getParcelableExtra(<span class="string">"user"</span>);</div><div class="line">textView.setText(String.format(Locale.getDefault(), <span class="string">"name=%s,age=%d"</span>, user.getName(), user.getAge()));</div></pre></td></tr></table></figure></p><blockquote><p>Serializable的作用是为了保存对象的属性到本地文件、数据库、网络流、rmi以方便数据传输，当然这种传输可以是程序内的也可以是两个程序间的。而Android的Parcelable的设计初衷是因为Serializable效率过慢，为了在程序内不同组件间以及不同Android程序间(AIDL)高效的传输数据而设计，这些数据仅在内存中存在，Parcelable是通过IBinder通信的消息的载体。<br>Parcelable的性能比Serializable好，在内存开销方面较小，所以在内存间数据传输时推荐使用Parcelable，如activity间传输数据，而Serializable可将数据持久化方便保存，所以在需要保存或网络传输数据时选择Serializable，因为android不同版本Parcelable可能不同，所以不推荐使用Parcelable进行数据持久化</p></blockquote><h4 id="四、获取Activity返回参数"><a href="#四、获取Activity返回参数" class="headerlink" title="四、获取Activity返回参数"></a>四、获取Activity返回参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class QuizActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">private static final int REQUEST_CODE_CHEAT = 0;</div><div class="line"></div><div class="line">... </div><div class="line"></div><div class="line">// startActivityForResult代码</div><div class="line">Intent i = CheatActivity.newIntent(QuizActivity.this, answerIsTrue);</div><div class="line">    startActivityForResult(i, REQUEST_CODE_CHEAT);</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</div><div class="line">        <span class="keyword">if</span> (resultCode != Activity.RESULT_OK)</div><div class="line">            <span class="built_in">return</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (requestCode == REQUEST_CODE_CHEAT) &#123;</div><div class="line">            <span class="keyword">if</span> (data == null)</div><div class="line">                <span class="built_in">return</span>;</div><div class="line">            mIsCheater = CheatActivity.wasAnswerShown(data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class CheatActivity extends AppCompatActivity &#123;</div><div class="line">private static final String EXTRA_ANSWER_SHOWN = <span class="string">"com.xxtking.geoquiz.CheatActivity.answer_shown"</span>;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">private void <span class="built_in">set</span>AnswerShownResult(boolean isAnswerShown) &#123;</div><div class="line">        Intent data = new Intent();</div><div class="line">        data.putExtra(EXTRA_ANSWER_SHOWN, isAnswerShown);</div><div class="line">        <span class="built_in">set</span>Result(RESULT_OK, data);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">public static boolean wasAnswerShown(Intent result) &#123;</div><div class="line">        <span class="built_in">return</span> result.getBooleanExtra(EXTRA_ANSWER_SHOWN, <span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02 Activity生命周期</title>
      <link href="/2017/05/23/03%20ANDROID/BASE/02Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2017/05/23/03%20ANDROID/BASE/02Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>整个生命周期来说，成对出现的。onCreate和onDestroy是成对的，代表着创建与销毁；onStart和onStop表示Activity对于程序是否可见（后台）；onResume和onPause表示Activity对于用户是否可见（前台）。</p><p><img src="http://ww1.sinaimg.cn/large/adc90466gy1fcptk0wnt2j20e90ifmz4" alt=""></p><h2 id="正常生命周期"><a href="#正常生命周期" class="headerlink" title="正常生命周期"></a>正常生命周期</h2><h4 id="1、初次启动Activity"><a href="#1、初次启动Activity" class="headerlink" title="1、初次启动Activity"></a>1、初次启动Activity</h4><p>onCreate -&gt; onStart -&gt; onResume</p><h4 id="2、界面显示时按了返回键"><a href="#2、界面显示时按了返回键" class="headerlink" title="2、界面显示时按了返回键"></a>2、界面显示时按了返回键</h4><p>onPause -&gt; onStop -&gt; onDestroy</p><h4 id="3、界面显示时按了Home键"><a href="#3、界面显示时按了Home键" class="headerlink" title="3、界面显示时按了Home键"></a>3、界面显示时按了Home键</h4><p>onPause -&gt; onStop</p><h4 id="4、Home键之后再次启动"><a href="#4、Home键之后再次启动" class="headerlink" title="4、Home键之后再次启动"></a>4、Home键之后再次启动</h4><p>onRestart -&gt; onStart -&gt; onResume</p><h4 id="5、界面显示时按了锁屏键及解锁"><a href="#5、界面显示时按了锁屏键及解锁" class="headerlink" title="5、界面显示时按了锁屏键及解锁"></a>5、界面显示时按了锁屏键及解锁</h4><p>锁屏：onPause -&gt; onStop<br>解锁：onRestart -&gt; onStart -&gt; onResume</p><h4 id="6、从A-Activity启动-B-Activity"><a href="#6、从A-Activity启动-B-Activity" class="headerlink" title="6、从A Activity启动 B Activity"></a>6、从A Activity启动 B Activity</h4><p>A onPause -&gt; B onCreate -&gt; B onStart -&gt; B onResume -&gt; A onStop<br>返回：B onPause -&gt; A onRestart -&gt; A onStart -&gt; A onResume -&gt; B onStop -&gt; B onDestroy</p><h4 id="7、从A-Activity启动-B-Activity-android-theme-”-style-Base-Theme-AppCompat-Dialog”"><a href="#7、从A-Activity启动-B-Activity-android-theme-”-style-Base-Theme-AppCompat-Dialog”" class="headerlink" title="7、从A Activity启动 B Activity (android:theme=”@style/Base.Theme.AppCompat.Dialog”)"></a>7、从A Activity启动 B Activity (android:theme=”@style/Base.Theme.AppCompat.Dialog”)</h4><p>A onPause -&gt; B onCreate -&gt; B onStart -&gt; B onResume<br>返回：B onPause -&gt; A onResume -&gt; B onStop -&gt; B onDestroy</p><h2 id="切换横竖屏幕"><a href="#切换横竖屏幕" class="headerlink" title="切换横竖屏幕"></a>切换横竖屏幕</h2><p>targetSdkVersion 25，没有设置android:configChanges：<br>1、竖屏切横屏：onConfigurationChanged() -&gt; onPause() -&gt; onSaveInstanceState() -&gt; onStop() -&gt; onDestroy() -&gt; onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume()<br>2、横屏切竖屏：onConfigurationChanged() -&gt; onPause() -&gt; onSaveInstanceState() -&gt; onStop() -&gt; onDestroy() -&gt; onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume()</p><blockquote><p>本人使用的是模拟器（minSdkVersion 16 / targetSdkVersion 25）测试，无论是否设置Activity的android:configChanges，或者属性值设为orientation或orientation|keyboardHidden，无论是竖屏切横屏还是横屏切竖屏，流程都如上所述，当android:configChanges=”orientation|keyboardHidden|screenSize”时，只会调用onConfigurationChanged()。经过查资料，android:targetSdkVersion这个属性会影响横竖屏切换的生命周期。<a href="http://www.cnblogs.com/xiaoQLu/p/3324503.html" target="_blank" rel="external">详见xiaoQLud的博客</a></p></blockquote><h2 id="异常生命周期"><a href="#异常生命周期" class="headerlink" title="异常生命周期"></a>异常生命周期</h2><p>1、系统配置发生改变后，默认情况下Activity会被销毁然后重新创建，生命周期参考横竖屏切换。常用的系统配置只有local、orientation和keyboardHidden。<br>2、资源内存不足导致低优先级的Activity被杀死，生命周期参考横竖屏切换。<br>3、运行时发生了异常，程序直接崩溃。例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (int i = 10; i &gt;= 0; i++)</div><div class="line">    System.out.println(10 / i)</div></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01 环境搭建</title>
      <link href="/2017/05/23/03%20ANDROID/BASE/01%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2017/05/23/03%20ANDROID/BASE/01%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="一、JDK"><a href="#一、JDK" class="headerlink" title="一、JDK"></a>一、JDK</h2><p>1、<a href="https://www.oracle.com/index.html" target="_blank" rel="external">https://www.oracle.com/index.html</a><br>2、Menu -&gt; Downloads -&gt; Java -&gt; All Java Downloads -&gt; Java SE Downloads<br>3、<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a><br>4、JDK DOWNLOAD</p><h2 id="二、Mac平台搭建集成开发环境"><a href="#二、Mac平台搭建集成开发环境" class="headerlink" title="二、Mac平台搭建集成开发环境"></a>二、Mac平台搭建集成开发环境</h2><p>1、<a href="https://www.android.com/" target="_blank" rel="external">https://www.android.com/</a><br>2、底部 -&gt; DEVELOPERS -&gt; App Developer Resources -&gt; DEVELOP<br>3、获取Android Studio （<a href="https://developer.android.com/studio/index.html）" target="_blank" rel="external">https://developer.android.com/studio/index.html）</a><br>4、下载 ANDROID STUDIO FOR MAC</p><h2 id="三、Windows平台搭建"><a href="#三、Windows平台搭建" class="headerlink" title="三、Windows平台搭建"></a>三、Windows平台搭建</h2><p>1、在Windows平台上，按照Mac平台搭建环境的步骤进行下载即可</p><h2 id="四、Linux平台搭建"><a href="#四、Linux平台搭建" class="headerlink" title="四、Linux平台搭建"></a>四、Linux平台搭建</h2><p>1、在Linux平台上，按照Mac平台搭建环境的步骤进行下载即可<br>2、解压到opt目录下：sudo mv android-studio /opt/<br>3、输入密码<br>4、命令行：cd /opt/android-studio/bin/<br>5、命令行：./studio.sh<br>6、安装失败则需要下载解压JDK文件，与上述步骤雷同<br>7、配置JDK路径：sudo nano /etc/profile<br>8、文件末尾添加：export JDK_HOME=/opt/jdk1.8.0_40<br>9、退出保存并立即生效：source /etc/profile<br>10、验证：echo $JDK_HOME<br>11、重新安装：./studio.sh</p><p><a href="http://stormzhang.com/devtools/2014/11/25/android-studio-tutorial1/" target="_blank" rel="external">大神的下载安装教程</a></p>]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Note | 研发录之重构</title>
      <link href="/2017/04/13/03%20ANDROID/Note%20%E7%A0%94%E5%8F%91%E5%BD%95%E4%B9%8B%E9%87%8D%E6%9E%84/"/>
      <url>/2017/04/13/03%20ANDROID/Note%20%E7%A0%94%E5%8F%91%E5%BD%95%E4%B9%8B%E9%87%8D%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="一、重构项目结构"><a href="#一、重构项目结构" class="headerlink" title="一、重构项目结构"></a>一、重构项目结构</h2><h4 id="Step-1-自定义业务无关的基础类库"><a href="#Step-1-自定义业务无关的基础类库" class="headerlink" title="Step 1. 自定义业务无关的基础类库"></a>Step 1. 自定义业务无关的基础类库</h4><ul><li>com.baselib.activity: 封装业务无关的公用逻辑，如后面的BaseActivity代码</li><li>com.baselib.cache: 缓存数据和图片的处理</li><li>com.baselib.net: 网络底层封装库</li><li>com.baselib.ui: 自定义控件</li><li>com.baselib.utils: 业务无关的公用方法</li></ul><h4 id="Step-2-实际项目中类进行归类划分"><a href="#Step-2-实际项目中类进行归类划分" class="headerlink" title="Step 2. 实际项目中类进行归类划分"></a>Step 2. 实际项目中类进行归类划分</h4><ul><li>com.myapp.activity: 所有的Activity，其他三大组件同样如此</li><li>com.myapp.adapter: 所有的适配器</li><li>com.myapp.entity: 实体类</li><li>com.myapp.db: SQLite相关的逻辑封装</li><li>com.myapp.engine: 业务相关的类</li><li>com.myapp.ui: 自定义控件</li><li>com.myapp.utils: 工具类</li><li>com.myapp.interfaces: 接口，以I作为开头</li><li>com.myapp.listener: 基于Listener的接口，命名以On作为开头</li></ul><h2 id="二、Activity-模板"><a href="#二、Activity-模板" class="headerlink" title="二、Activity 模板"></a>二、Activity 模板</h2><h4 id="1-com-baselib-activity-BaseActivity"><a href="#1-com-baselib-activity-BaseActivity" class="headerlink" title="1. com.baselib.activity.BaseActivity"></a>1. com.baselib.activity.BaseActivity</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public abstract class BaseActivity extends Activity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">        initVariables();</div><div class="line">        initViews(savedInstanceState);</div><div class="line">        loadData();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 初始化变量，包括Intent带的数据和Activity内的变量</div><div class="line">    protected abstract void initVariables();</div><div class="line">    // 加载layout布局文件，初始化控件，为控件挂上事件方法</div><div class="line">    protected abstract void initViews(Bundle savedInstanceState);</div><div class="line">    // 获取数据</div><div class="line">    protected abstract void loadData();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2-com-myapp-activity-LoginActivity"><a href="#2-com-myapp-activity-LoginActivity" class="headerlink" title="2. com.myapp.activity.LoginActivity"></a>2. com.myapp.activity.LoginActivity</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class LoginActivity extends BaseActivity &#123;</div><div class="line">    private int loginTimes;</div><div class="line">    private String strEmail;</div><div class="line"></div><div class="line">    private EditText etPassword;</div><div class="line">    private EditText etEmail;</div><div class="line">    private Button btnLogin;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void <span class="function"><span class="title">initVariables</span></span>() &#123;</div><div class="line">        loginTimes = -1;</div><div class="line"></div><div class="line">        Bundle bundle = getIntent().getExtras();</div><div class="line">        strEmail = bundle.getString(AppConstants.Email);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void initViews(Bundle savedInstanceState) &#123;</div><div class="line">        <span class="built_in">set</span>ContentView(R.layout.activity_login);</div><div class="line"></div><div class="line">        etEmail = (EditText) findViewById(R.id.email);</div><div class="line">        etEmail.setText(strEmail);</div><div class="line">        etPassword = (EditText) findViewById(R.id.password);</div><div class="line"></div><div class="line">        // 登录事件</div><div class="line">        btnLogin = (Button) findViewById(R.id.sign_in_button);</div><div class="line">        btnLogin.setOnClickListener(</div><div class="line">            new View.<span class="function"><span class="title">OnClickListener</span></span>() &#123;</div><div class="line">                @Override</div><div class="line">                public void onClick(View v) &#123;</div><div class="line">                    gotoLoginActivity();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void <span class="function"><span class="title">gotoLoginActivity</span></span>() &#123;</div><div class="line">        startActivity(new Intent(LoginActivity.this, PersonCenterActivity.class));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void <span class="function"><span class="title">loadData</span></span>() &#123;</div><div class="line">        loadWeatherData();</div><div class="line">        loadCityData();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="三、Adapter-模板"><a href="#三、Adapter-模板" class="headerlink" title="三、Adapter 模板"></a>三、Adapter 模板</h2><h4 id="com-myapp-adapter-WeatherAdapter"><a href="#com-myapp-adapter-WeatherAdapter" class="headerlink" title="com.myapp.adapter.WeatherAdapter"></a>com.myapp.adapter.WeatherAdapter</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class WeatherAdapter extends BaseAdapter &#123;</div><div class="line">    private final ArrayList&lt;WeatherInfo&gt; weatherList;</div><div class="line">    private final BaseActivity context;</div><div class="line"></div><div class="line">    public WeatherAdapter(ArrayList&lt;WeatherInfo&gt; weatherList, BaseActivity context) &#123;</div><div class="line">        this.weatherList = weatherList;</div><div class="line">        this.context = context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int <span class="function"><span class="title">getCount</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> weatherList.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public WeatherInfo getItem(final int position) &#123;</div><div class="line">        <span class="built_in">return</span> weatherList.get(position);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public long getItemId(final int position) &#123;</div><div class="line">        <span class="built_in">return</span> position;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public View getView(final int position, View convertView, final ViewGroup parent) &#123;</div><div class="line">        final Holder holder;</div><div class="line">        <span class="keyword">if</span> (convertView == null) &#123;</div><div class="line">            holder = new Holder();</div><div class="line">            convertView = context.getLayoutInflater().inflate(R.layout.item_weatherlist, null);</div><div class="line">            holder.tvCity = (TextView) convertView.findViewById(R.id.tvCity);</div><div class="line">            convertView.setTag(holder);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">        holder = (Holder) convertView.getTag();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        WeatherInfo weatherInfo = weatherList.get(position);</div><div class="line">        holder.tvCity.setText(weatherInfo.getCity());</div><div class="line">        <span class="built_in">return</span> convertView;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class Holder &#123;</div><div class="line">        TextView tvCity;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="ListDemoActivity-onCreate"><a href="#ListDemoActivity-onCreate" class="headerlink" title="ListDemoActivity.onCreate()"></a>ListDemoActivity.onCreate()</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">lvWeatherList = (ListView) findViewById(R.id.lvWeatherlist);</div><div class="line">WeatherAdapter adapter = new WeatherAdapter(weatherList, ListDemoActivity.this);</div><div class="line">lvWeatherList.setAdapter(adapter);</div><div class="line">lvWeatherList.setOnItemClickListener(</div><div class="line">    new AdapterView.<span class="function"><span class="title">OnItemClickListener</span></span>() &#123;</div><div class="line">        @Override</div><div class="line">        public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123;</div><div class="line">            // <span class="keyword">do</span> something...</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure><h2 id="四、实体化编程"><a href="#四、实体化编程" class="headerlink" title="四、实体化编程"></a>四、实体化编程</h2><h4 id="1-JSON-数据"><a href="#1-JSON-数据" class="headerlink" title="1. JSON 数据"></a>1. JSON 数据</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="string">"weatherinfo"</span>:&#123;</div><div class="line">    <span class="string">"city"</span>:<span class="string">"北京"</span>,</div><div class="line">    <span class="string">"cityid"</span>:<span class="string">"101010100"</span>,</div><div class="line">    <span class="string">"temp"</span>:<span class="string">"24"</span>,</div><div class="line">    <span class="string">"WD"</span>:<span class="string">"南风"</span>,</div><div class="line">    <span class="string">"SD"</span>:<span class="string">"74%"</span>,</div><div class="line">    <span class="string">"time"</span>:<span class="string">"17:45"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2-生成实体类"><a href="#2-生成实体类" class="headerlink" title="2. 生成实体类"></a>2. 生成实体类</h4><p>可以使用插件，也可以使用公开的工具，如<a href="http://files.cnblogs.com/Jax/EntityGenerator.zip" target="_blank" rel="external">包建强提供的实体生成器下载地址</a><br><img src="http://ww1.sinaimg.cn/large/adc90466ly1fel1oooznaj20qh0hw74g.jpg" alt=""></p><h4 id="3-序列化"><a href="#3-序列化" class="headerlink" title="3. 序列化"></a>3. 序列化</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Weatherinfo implements Serializable &#123;</div><div class="line">    private static final long serialVersionUID = 1L;</div><div class="line"></div><div class="line">    private String city;</div><div class="line">    private String cityid;</div><div class="line">    private String temp;</div><div class="line">    private String WD;</div><div class="line">    private String SD;</div><div class="line">    private String time;</div><div class="line"></div><div class="line">    public String <span class="function"><span class="title">getCity</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> city;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void <span class="built_in">set</span>City(String city) &#123;</div><div class="line">        this.city = city;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="4-fastJSON"><a href="#4-fastJSON" class="headerlink" title="4. fastJSON"></a>4. fastJSON</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">WeatherEntity weatherEntity = JSON.parseObject(jsonContent, WeatherEntity.class);</div><div class="line">WeatherInfor weatherInfor = weatherEntity.getWeatherInfo();</div><div class="line"><span class="keyword">if</span> (weatherInfor != null) &#123;</div><div class="line">    tvCity.setText(weatherInfo.getCity());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果使用崩溃，试下在混淆文件中加以下两行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-keepattributes Signature     // 避免混淆泛型</div><div class="line">-keepattributes *Annotation*  // 不混淆注解</div></pre></td></tr></table></figure></p><h4 id="5-传递"><a href="#5-传递" class="headerlink" title="5. 传递"></a>5. 传递</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">intent.putExtra(AppContants.Weather, weatherInfo);</div></pre></td></tr></table></figure><h2 id="五、类型安全转换函数"><a href="#五、类型安全转换函数" class="headerlink" title="五、类型安全转换函数"></a>五、类型安全转换函数</h2><h4 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public final static int convertToInt(Object value, int defaultValue) &#123;</div><div class="line">    <span class="keyword">if</span> (value == null || <span class="string">""</span>.equals(value.toString().trim())) &#123;</div><div class="line">        <span class="built_in">return</span> defaultValue;</div><div class="line">    &#125;</div><div class="line">    try &#123;</div><div class="line">        <span class="built_in">return</span> Integer.valueOf(value.toString());</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        try &#123;</div><div class="line">            <span class="built_in">return</span> Double.valueOf(value.toString()).intValue();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            <span class="built_in">return</span> defaultValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String cityName = <span class="string">"T"</span>;</div><div class="line">String firstLetter = <span class="string">""</span>;</div><div class="line"><span class="keyword">if</span> (cityName.length() &gt; 1) &#123;</div><div class="line">    firstLetter = cityName.substring(1, 2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
            <tag> 研发录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ANDROID | 使用Fragment兼容平板与手机</title>
      <link href="/2017/04/10/03%20ANDROID/ANDROID%20Building%20a%20Dynamic%20UI%20with%20Fragments/"/>
      <url>/2017/04/10/03%20ANDROID/ANDROID%20Building%20a%20Dynamic%20UI%20with%20Fragments/</url>
      
        <content type="html"><![CDATA[<h2 id="界面效果"><a href="#界面效果" class="headerlink" title="界面效果"></a>界面效果</h2><p>在手机设备上，由于采用单窗格用户界面，因此可能更适合一次只显示一个片段。 相反，由于平板电脑屏幕尺寸较大，可以为用户显示更多信息，因此最好将片段设计为并排显示。<br><img src="http://ww1.sinaimg.cn/large/adc90466ly1fehnmn669ej20ga06djsm.jpg" alt=""></p><h2 id="布局文件"><a href="#布局文件" class="headerlink" title="布局文件"></a>布局文件</h2><h4 id="小屏布局文件，如手机"><a href="#小屏布局文件，如手机" class="headerlink" title="小屏布局文件，如手机"></a>小屏布局文件，如手机</h4><p>res/layout/news_articles.xml:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</div><div class="line">&lt;FrameLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    android:id=<span class="string">"@+id/fragment_container"</span></div><div class="line">    android:layout_width=<span class="string">"match_parent"</span></div><div class="line">    android:layout_height=<span class="string">"match_parent"</span> /&gt;</div></pre></td></tr></table></figure></p><h4 id="大屏布局文件，如平板电脑"><a href="#大屏布局文件，如平板电脑" class="headerlink" title="大屏布局文件，如平板电脑"></a>大屏布局文件，如平板电脑</h4><p>res/layout-large/news_articles.xml:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</div><div class="line"></div><div class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    android:orientation=<span class="string">"horizontal"</span></div><div class="line">    android:layout_width=<span class="string">"match_parent"</span></div><div class="line">    android:layout_height=<span class="string">"match_parent"</span>&gt;</div><div class="line"></div><div class="line">    &lt;fragment android:name=<span class="string">"com.king.demo.fragment.HeadlinesFragment"</span></div><div class="line">        android:id=<span class="string">"@+id/headlines_fragment"</span></div><div class="line">        android:layout_weight=<span class="string">"1"</span></div><div class="line">        android:layout_width=<span class="string">"0dp"</span></div><div class="line">        android:layout_height=<span class="string">"match_parent"</span> /&gt;</div><div class="line"></div><div class="line">    &lt;fragment android:name=<span class="string">"com.king.demo.fragment.ArticleFragment"</span></div><div class="line">        android:id=<span class="string">"@+id/article_fragment"</span></div><div class="line">        android:layout_weight=<span class="string">"2"</span></div><div class="line">        android:layout_width=<span class="string">"0dp"</span></div><div class="line">        android:layout_height=<span class="string">"match_parent"</span> /&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><h4 id="判断加载哪个布局文件"><a href="#判断加载哪个布局文件" class="headerlink" title="判断加载哪个布局文件"></a>判断加载哪个布局文件</h4><p>当设备屏幕尺寸小于large时加载第一个布局文件，否则加载第二个布局文件，是否large则由系统判断，而我们可以通过以下方法判断加载的是哪个布局：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (findViewById(R.id.fragment_container) != null) &#123;</div><div class="line">    // 此处加载了第一个布局文件</div><div class="line">&#125;</div><div class="line"></div><div class="line">ArticleFragment articleFrag = (ArticleFragment) getSupportFragmentManager().findFragmentById(R.id.article_fragment);</div><div class="line"><span class="keyword">if</span> (articleFrag != null) &#123;</div><div class="line">    // 此处加载了第二个布局</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="片段处理"><a href="#片段处理" class="headerlink" title="片段处理"></a>片段处理</h2><p>FragmentManager类提供的方法让您可以在运行时为 Activity 添加、移除和替换片段，从而营造出动态的用户体验。</p><h4 id="在运行时为-Activity-添加片段"><a href="#在运行时为-Activity-添加片段" class="headerlink" title="在运行时为 Activity 添加片段"></a>在运行时为 Activity 添加片段</h4><p>在您的 Activity 内，使用 Support Library API 调用 getSupportFragmentManager() 以获取 FragmentManager。然后，调用 beginTransaction() 创建一个 FragmentTransaction，并调用 add() 添加一个片段。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">import android.support.v4.app.FragmentActivity;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.support.v4.app.FragmentTransaction;</div><div class="line"></div><div class="line">import com.king.demo.R;</div><div class="line"></div><div class="line">public class DynamicFragmentsActivity extends FragmentActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        <span class="built_in">set</span>ContentView(R.layout.news_articles);</div><div class="line"></div><div class="line">        // Check whether the activity is using the layout version with</div><div class="line">        // the fragment_container FrameLayout. If so, we must add the first fragment</div><div class="line">        <span class="keyword">if</span> (findViewById(R.id.fragment_container) != null) &#123;</div><div class="line"></div><div class="line">            // However, <span class="keyword">if</span> we<span class="string">'re being restored from a previous state,</span></div><div class="line">            // then we don't need to <span class="keyword">do</span> anything and should <span class="built_in">return</span> or <span class="keyword">else</span></div><div class="line">            // we could end up with overlapping fragments.</div><div class="line">            <span class="keyword">if</span> (savedInstanceState != null) &#123;</div><div class="line">                <span class="built_in">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Create an instance of ExampleFragment</div><div class="line">            HeadlinesFragment firstFragment = new HeadlinesFragment();</div><div class="line"></div><div class="line">            // In <span class="keyword">case</span> this activity was started with special instructions from an Intent,</div><div class="line">            // pass the Intent<span class="string">'s extras to the fragment as arguments</span></div><div class="line">            firstFragment.setArguments(getIntent().getExtras());</div><div class="line"></div><div class="line">            // Add the fragment to the 'fragment_container<span class="string">' FrameLayout</span></div><div class="line">            getSupportFragmentManager().beginTransaction()</div><div class="line">                    .add(R.id.fragment_container, firstFragment).commit();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="替换片段"><a href="#替换片段" class="headerlink" title="替换片段"></a>替换片段</h4><p>替换片段的步骤与添加片段类似，只不过调用的方法从 add() 改为 replace()。<br>请谨记，当您执行替换或移除片段等片段事务时，通常最好让用户能够回退并“撤消”更改。 要让用户回退所执行的片段事务，您必须先调用 addToBackStack()，然后再提交 FragmentTransaction。<br>片段替换示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// Capture the article fragment from the activity layout</div><div class="line">ArticleFragment articleFrag = (ArticleFragment)</div><div class="line">        getSupportFragmentManager().findFragmentById(R.id.article_fragment);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (articleFrag != null) &#123;</div><div class="line">    // If article frag is available, we<span class="string">'re in two-pane layout...</span></div><div class="line"></div><div class="line">    // Call a method in the ArticleFragment to update its content</div><div class="line">    articleFrag.updateArticleView(position);</div><div class="line">&#125; else &#123;</div><div class="line">    // If the frag is not available, we're <span class="keyword">in</span> the one-pane layout and must swap frags...</div><div class="line"></div><div class="line">    // Create fragment and give it an argument <span class="keyword">for</span> the selected article</div><div class="line">    ArticleFragment newFragment = new ArticleFragment();</div><div class="line">    Bundle args = new Bundle();</div><div class="line">    args.putInt(ArticleFragment.ARG_POSITION, position);</div><div class="line">    newFragment.setArguments(args);</div><div class="line">    FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();</div><div class="line"></div><div class="line">    // Replace whatever is <span class="keyword">in</span> the fragment_container view with this fragment,</div><div class="line">    // and add the transaction to the back stack so the user can navigate back</div><div class="line">    transaction.replace(R.id.fragment_container, newFragment);</div><div class="line">    transaction.addToBackStack(null);</div><div class="line"></div><div class="line">    // Commit the transaction</div><div class="line">    transaction.commit();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="片段通信"><a href="#片段通信" class="headerlink" title="片段通信"></a>片段通信</h2><p>通常您希望一个片段与另一个片段进行通信，例如根据用户事件更改内容。所有片段到片段的通信是通过Activity完成的。两个片段不应该直接交流。若要允许片段与其Activity进行通信，您可以在片段类中定义接口并在Activity中实现它。片段捕捉接口实现其onattach()生命周期方法中可以调用接口的方法以进行交流活动。</p><h4 id="1、声明接口"><a href="#1、声明接口" class="headerlink" title="1、声明接口"></a>1、声明接口</h4><p>在HeadlinesFragment声明接口OnHeadlineSelectedListener：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class HeadlinesFragment extends ListFragment &#123;</div><div class="line">    OnHeadlineSelectedListener mCallback;</div><div class="line"></div><div class="line">    // Container Activity must implement this interface</div><div class="line">    public interface OnHeadlineSelectedListener &#123;</div><div class="line">        public void onArticleSelected(int position);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onAttach(Activity activity) &#123;</div><div class="line">        super.onAttach(activity);</div><div class="line"></div><div class="line">        // This makes sure that the container activity has implemented</div><div class="line">        // the callback interface. If not, it throws an exception</div><div class="line">        try &#123;</div><div class="line">            mCallback = (OnHeadlineSelectedListener) activity;</div><div class="line">        &#125; catch (ClassCastException e) &#123;</div><div class="line">            throw new ClassCastException(activity.toString()</div><div class="line">                    + <span class="string">" must implement OnHeadlineSelectedListener"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="2、实现接口"><a href="#2、实现接口" class="headerlink" title="2、实现接口"></a>2、实现接口</h4><p>在DynamicFragmentsActivity中实现接口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public static class DynamicFragmentsActivity extends Activity</div><div class="line">        implements HeadlinesFragment.OnHeadlineSelectedListener&#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    public void onArticleSelected(int position) &#123;</div><div class="line">        // The user selected the headline of an article from the HeadlinesFragment</div><div class="line">        // Do something here to display that article</div><div class="line"></div><div class="line">        ArticleFragment articleFrag = (ArticleFragment)</div><div class="line">                getSupportFragmentManager().findFragmentById(R.id.article_fragment);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (articleFrag != null) &#123;</div><div class="line">            // If article frag is available, we<span class="string">'re in two-pane layout...</span></div><div class="line"></div><div class="line">            // Call a method in the ArticleFragment to update its content</div><div class="line">            articleFrag.updateArticleView(position);</div><div class="line">        &#125; else &#123;</div><div class="line">            // Otherwise, we're <span class="keyword">in</span> the one-pane layout and must swap frags...</div><div class="line"></div><div class="line">            // Create fragment and give it an argument <span class="keyword">for</span> the selected article</div><div class="line">            ArticleFragment newFragment = new ArticleFragment();</div><div class="line">            Bundle args = new Bundle();</div><div class="line">            args.putInt(ArticleFragment.ARG_POSITION, position);</div><div class="line">            newFragment.setArguments(args);</div><div class="line"></div><div class="line">            FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();</div><div class="line"></div><div class="line">            // Replace whatever is <span class="keyword">in</span> the fragment_container view with this fragment,</div><div class="line">            // and add the transaction to the back stack so the user can navigate back</div><div class="line">            transaction.replace(R.id.fragment_container, newFragment);</div><div class="line">            transaction.addToBackStack(null);</div><div class="line"></div><div class="line">            // Commit the transaction</div><div class="line">            transaction.commit();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="3、回调"><a href="#3、回调" class="headerlink" title="3、回调"></a>3、回调</h4><p>在HeadlinesFragment回调接口中的方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class HeadlinesFragment extends ListFragment &#123;</div><div class="line">    OnHeadlineSelectedListener mCallback;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onListItemClick(ListView l, View v, int position, long id) &#123;</div><div class="line">        // Notify the parent activity of selected item</div><div class="line">        mCallback.onArticleSelected(position);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><a href="https://developer.android.com/training/basics/fragments/index.html" target="_blank" rel="external">参考文档链接</a><br><a href="https://github.com/xianxiaotao/AndroidDemo" target="_blank" rel="external">全部源码链接</a></p>]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ANDROID | 源码分析事件分发</title>
      <link href="/2017/03/28/03%20ANDROID/ANDROID%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
      <url>/2017/03/28/03%20ANDROID/ANDROID%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h4 id="1、Activity-——-gt-Window"><a href="#1、Activity-——-gt-Window" class="headerlink" title="1、Activity ——&gt; Window"></a>1、Activity ——&gt; Window</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Called to process touch screen events.  You can override this to</div><div class="line"> * intercept all touch screen events before they are dispatched to the</div><div class="line"> * window.  Be sure to call this implementation <span class="keyword">for</span> touch screen events</div><div class="line"> * that should be handled normally.</div><div class="line"> *</div><div class="line"> * @param ev The touch screen event.</div><div class="line"> * @<span class="built_in">return</span> boolean Return <span class="literal">true</span> <span class="keyword">if</span> this event was consumed.</div><div class="line"> */</div><div class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">        onUserInteraction();    // Empty method</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> onTouchEvent(ev);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先事件开始交给Activity所附属的Window进行分发，如果返回true，整个事件循环就结束了，返回false意味着没人处理，所有View的onTouchEvent都返回了false，此时就会调用Activity的onTouchEvent。</p><h4 id="2、Window-——-gt-PhoneWindow"><a href="#2、Window-——-gt-PhoneWindow" class="headerlink" title="2、Window ——&gt; PhoneWindow"></a>2、Window ——&gt; PhoneWindow</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Abstract base class <span class="keyword">for</span> a top-level window look and behavior policy.  An</div><div class="line"> * instance of this class should be used as the top-level view added to the</div><div class="line"> * window manager. It provides standard UI policies such as a background, title</div><div class="line"> * area, default key processing, etc.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;The only existing implementation of this abstract class is</div><div class="line"> * android.view.PhoneWindow, <span class="built_in">which</span> you should instantiate when needing a</div><div class="line"> * Window.</div><div class="line"> */</div><div class="line">public abstract class Window &#123;</div><div class="line">    /**</div><div class="line">     * Used by custom windows, such as Dialog, to pass the touch screen event</div><div class="line">     * further down the view hierarchy. Application developers should</div><div class="line">     * not need to implement or call this.</div><div class="line">     */</div><div class="line">    public abstract boolean superDispatchTouchEvent(MotionEvent event);</div><div class="line"></div><div class="line">    // other code ... </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Window为抽象类，superDispatchTouchEvent为抽象方法，而注释告知我们唯一实现类是PhoneWindow。</p><h4 id="3、PhoneWindow-——-gt-DecorView"><a href="#3、PhoneWindow-——-gt-DecorView" class="headerlink" title="3、PhoneWindow ——&gt; DecorView"></a>3、PhoneWindow ——&gt; DecorView</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class PhoneWindow extends Window implements MenuBuilder.Callback &#123;</div><div class="line"></div><div class="line">    // This is the top-level view of the window, containing the window decor.  </div><div class="line">    private DecorView mDecor;  </div><div class="line"></div><div class="line">    @Override  </div><div class="line">    public boolean superDispatchTouchEvent(MotionEvent event) &#123;  </div><div class="line">        <span class="built_in">return</span> mDecor.superDispatchTouchEvent(event);  </div><div class="line">    &#125; </div><div class="line"></div><div class="line">    // other code ... </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PhoneWindow将事件直接传递给了DecorView，那这个DecorView是什么呢？DecorView is the top-level view of the window, containing the window decor.</p><h4 id="4、DecorView-——-gt-ViewGroup"><a href="#4、DecorView-——-gt-ViewGroup" class="headerlink" title="4、DecorView ——&gt; ViewGroup"></a>4、DecorView ——&gt; ViewGroup</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/** @hide */</div><div class="line">public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks &#123;</div><div class="line">    public boolean superDispatchTouchEvent(MotionEvent event) &#123;</div><div class="line">        <span class="built_in">return</span> super.dispatchTouchEvent(event);     // ViewGroup.</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // other code ... </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>DecorView是一个顶级View，也叫根View，继承FrameLayout，也就是说DecorView是一个ViewGroup。接下来就是将事件分发到ViewGroup的Child。</p><h4 id="5、ViewGroup-——-gt-Children"><a href="#5、ViewGroup-——-gt-Children" class="headerlink" title="5、ViewGroup ——&gt; Children"></a>5、ViewGroup ——&gt; Children</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">public abstract class ViewGroup extends View implements ViewParent, ViewManager &#123;</div><div class="line">    @Override</div><div class="line">    public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class="line">        // other code ...</div><div class="line"></div><div class="line">        // Check <span class="keyword">for</span> interception.</div><div class="line">        final boolean intercepted;</div><div class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123;</div><div class="line">            final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</div><div class="line">            <span class="keyword">if</span> (!disallowIntercept) &#123;</div><div class="line">                intercepted = onInterceptTouchEvent(ev);</div><div class="line">                ev.setAction(action); // restore action <span class="keyword">in</span> <span class="keyword">case</span> it was changed</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                intercepted = <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // other code ...</div><div class="line"></div><div class="line">        final View[] children = mChildren;</div><div class="line">        <span class="keyword">for</span> (int i = childrenCount - 1; i &gt;= 0; i--) &#123;</div><div class="line">            final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);</div><div class="line">            final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123;</div><div class="line">                ev.setTargetAccessibilityFocus(<span class="literal">false</span>);</div><div class="line">                <span class="built_in">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            newTouchTarget = getTouchTarget(child);</div><div class="line">            <span class="keyword">if</span> (newTouchTarget != null) &#123;</div><div class="line">                // Child is already receiving touch within its bounds.</div><div class="line">                // Give it the new pointer <span class="keyword">in</span> addition to the ones it is handling.</div><div class="line">                newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            resetCancelNextUpFlag(child);</div><div class="line">            <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="literal">false</span>, child, idBitsToAssign)) &#123;</div><div class="line">                // Child wants to receive touch within its bounds.</div><div class="line">                mLastTouchDownTime = ev.getDownTime();</div><div class="line">                <span class="keyword">if</span> (preorderedList != null) &#123;</div><div class="line">                    // childIndex points into presorted list, find original index</div><div class="line">                    <span class="keyword">for</span> (int j = 0; j &lt; childrenCount; j++) &#123;</div><div class="line">                        <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</div><div class="line">                            mLastTouchDownIndex = j;</div><div class="line">                            <span class="built_in">break</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    mLastTouchDownIndex = childIndex;</div><div class="line">                &#125;</div><div class="line">                mLastTouchDownX = ev.getX();</div><div class="line">                mLastTouchDownY = ev.getY();</div><div class="line">                newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">                alreadyDispatchedToNewTouchTarget = <span class="literal">true</span>;</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    // other code ... </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述代码是ViewGroup中dispatchTouchEvent方法的主要分发代码：首先调用onInterceptTouchEvent()判断是否要拦截，如果是false则遍历ViewGroup的所有子元素，判断子元素是否能够接受点击事件以及事件坐标是否落在子元素的区域内；如果某个子元素满足这个条件，那么事件就会传递给它来处理；dispatchTransformedTouchEvent方法中有如下一段代码，即child不是null，就会调用子类的dispatchTouchEvent方法，就交给子元素处理，从而完成一轮事件分发。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (child == null) &#123;</div><div class="line">    handled = super.dispatchTouchEvent(event);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    handled = child.dispatchTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ViewGroup分发事件时，自带记忆功能，即如果某个子元素消耗了ACTION_DOWN事件，那么同一事件序列中的其他事件都会交给它来处理，否则将事件交给它的父类来处理（同样带记忆）。</p><h4 id="6、View"><a href="#6、View" class="headerlink" title="6、View"></a>6、View</h4><p>如果ViewGroup分发的子元素还是ViewGroup，则重复5，直到分发到的子元素是一个View。因为它没有子元素可以向下传递事件，所以只能自己处理。以下是View中的dispatchTouchEvent方法中核心代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Pass the touch screen motion event down to the target view, or this</div><div class="line"> * view <span class="keyword">if</span> it is the target.</div><div class="line"> *</div><div class="line"> * @param event The motion event to be dispatched.</div><div class="line"> * @<span class="built_in">return</span> True <span class="keyword">if</span> the event was handled by the view, <span class="literal">false</span> otherwise.</div><div class="line"> */</div><div class="line">public boolean dispatchTouchEvent(MotionEvent event) &#123;</div><div class="line">    // other code ...</div><div class="line"></div><div class="line">    boolean result = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</div><div class="line">        <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</div><div class="line">            result = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        //noinspection SimplifiableIfStatement</div><div class="line">        ListenerInfo li = mListenerInfo;</div><div class="line">        <span class="keyword">if</span> (li != null &amp;&amp; li.mOnTouchListener != null</div><div class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</div><div class="line">                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;</div><div class="line">            result = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</div><div class="line">            result = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>首先判断有没有设置OnTouchListener，如果没有设置或其中的onTouch方法返回false，就会调用onTouchEvent()方法了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Implement this method to handle touch screen motion events.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * If this method is used to detect click actions, it is recommended that</div><div class="line"> * the actions be performed by implementing and calling</div><div class="line"> * &#123;@link <span class="comment">#performClick()&#125;. This will ensure consistent system behavior,</span></div><div class="line"> * including:</div><div class="line"> * &lt;ul&gt;</div><div class="line"> * &lt;li&gt;obeying click sound preferences</div><div class="line"> * &lt;li&gt;dispatching OnClickListener calls</div><div class="line"> * &lt;li&gt;handling &#123;@link AccessibilityNodeInfo<span class="comment">#ACTION_CLICK ACTION_CLICK&#125; when</span></div><div class="line"> * accessibility features are enabled</div><div class="line"> * &lt;/ul&gt;</div><div class="line"> *</div><div class="line"> * @param event The motion event.</div><div class="line"> * @<span class="built_in">return</span> True <span class="keyword">if</span> the event was handled, <span class="literal">false</span> otherwise.</div><div class="line"> */</div><div class="line">public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">    final <span class="built_in">float</span> x = event.getX();</div><div class="line">    final <span class="built_in">float</span> y = event.getY();</div><div class="line">    final int viewFlags = mViewFlags;</div><div class="line">    final int action = event.getAction();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</div><div class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123;</div><div class="line">            <span class="built_in">set</span>Pressed(<span class="literal">false</span>);</div><div class="line">        &#125;</div><div class="line">        // A disabled view that is clickable still consumes the touch</div><div class="line">        // events, it just doesn<span class="string">'t respond to them.</span></div><div class="line">        return (((viewFlags &amp; CLICKABLE) == CLICKABLE</div><div class="line">                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</div><div class="line">                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</div><div class="line">    &#125;</div><div class="line">    if (mTouchDelegate != null) &#123;</div><div class="line">        if (mTouchDelegate.onTouchEvent(event)) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class="line">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</div><div class="line">            (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</div><div class="line">        switch (action) &#123;</div><div class="line">            case MotionEvent.ACTION_UP:</div><div class="line">                boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;</div><div class="line">                if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123;</div><div class="line">                    // take focus if we don't have it already and we should <span class="keyword">in</span></div><div class="line">                    // touch mode.</div><div class="line">                    boolean focusTaken = <span class="literal">false</span>;</div><div class="line">                    <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</div><div class="line">                        focusTaken = requestFocus();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (prepressed) &#123;</div><div class="line">                        // The button is being released before we actually</div><div class="line">                        // showed it as pressed.  Make it show the pressed</div><div class="line">                        // state now (before scheduling the click) to ensure</div><div class="line">                        // the user sees it.</div><div class="line">                        <span class="built_in">set</span>Pressed(<span class="literal">true</span>, x, y);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</div><div class="line">                        // This is a tap, so remove the longpress check</div><div class="line">                        removeLongPressCallback();</div><div class="line"></div><div class="line">                        // Only perform take click actions <span class="keyword">if</span> we were <span class="keyword">in</span> the pressed state</div><div class="line">                        <span class="keyword">if</span> (!focusTaken) &#123;</div><div class="line">                            // Use a Runnable and post this rather than calling</div><div class="line">                            // performClick directly. This lets other visual state</div><div class="line">                            // of the view update before click actions start.</div><div class="line">                            <span class="keyword">if</span> (mPerformClick == null) &#123;</div><div class="line">                                mPerformClick = new PerformClick();</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">if</span> (!post(mPerformClick)) &#123;</div><div class="line">                                performClick();</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (mUnsetPressedState == null) &#123;</div><div class="line">                        mUnsetPressedState = new UnsetPressedState();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (prepressed) &#123;</div><div class="line">                        postDelayed(mUnsetPressedState,</div><div class="line">                                ViewConfiguration.getPressedStateDuration());</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!post(mUnsetPressedState)) &#123;</div><div class="line">                        // If the post failed, unpress right now</div><div class="line">                        mUnsetPressedState.run();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    removeTapCallback();</div><div class="line">                &#125;</div><div class="line">                mIgnoreNextUpEvent = <span class="literal">false</span>;</div><div class="line">                <span class="built_in">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">                // ...</div><div class="line">                <span class="built_in">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</div><div class="line">                // ...</div><div class="line">                <span class="built_in">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">                // ...</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>首先不可用状态下的View照样会消耗点击事件并返回；接着，如果View设置了代理，那么还会执行TouchDelegate的onTouchEvent方法（机制与OnTouchListener类似）；然后具体处理点击事件：只要View的CLICKABLE、LONG_CLICKABLE和CONTEXT_CLICKABLE有一个为true，那么它就会消耗事件，即onTouchEvent方法返回true，不管它是不是DISABLE状态如何；然后当ACTION_UP事件发生时，会调用performClick方法，如果View设置了OnClickListener，那么performClick方法内部会调用它的onClick方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Call this view<span class="string">'s OnClickListener, if it is defined.  Performs all normal</span></div><div class="line"> * actions associated with clicking: reporting accessibility event, playing</div><div class="line"> * a sound, etc.</div><div class="line"> *</div><div class="line"> * @return True there was an assigned OnClickListener that was called, false</div><div class="line"> *         otherwise is returned.</div><div class="line"> */</div><div class="line">public boolean performClick() &#123;</div><div class="line">    final boolean result;</div><div class="line">    final ListenerInfo li = mListenerInfo;</div><div class="line">    if (li != null &amp;&amp; li.mOnClickListener != null) &#123;</div><div class="line">        playSoundEffect(SoundEffectConstants.CLICK);</div><div class="line">        li.mOnClickListener.onClick(this);          // 调用OnClickListener.onClick</div><div class="line">        result = true;</div><div class="line">    &#125; else &#123;</div><div class="line">        result = false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="传递规则"><a href="#传递规则" class="headerlink" title="传递规则"></a>传递规则</h2><ul><li>同一个事件序列是指从手指触摸屏幕那一刻开始，中间包含数量不定的 move 事件到手指离开屏幕那一刻（down-&gt;move…move-&gt;up)。</li><li>正常情况下一个事件序列只能被一个 View 拦截且消耗，每个 View 一旦决定拦截，同一个事件序列所有事件都会直接交给它处理，并且它的 onInterceptTouchEvent 不会再被调用。</li><li>某个View一旦开始处理事件，如果它不消耗ACTION_DOWN（onTouchEvent返回了false），那么同一事件序列中其他事件都不会再交给它来处理，事件将重新交给他的父元素处理，即父元素的 onTouchEvent 会被调用。</li><li>如果某个View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以收到后续事件，最终这些消失的点击事件会传递给Activity 处理。</li><li>View没有onInterceptTouchEvent方法，一旦有事件传递给它，那么它的onTouchEvent方法就会被调用。</li><li>View的onTouchEvent 方法默认消耗事件（返回true），除非他是不可点击的（clickable、longClickable和contextClickable同时为false）。View的longClickable 属性默认都为false，clickable属性分情况，Button默认为true，TextView默认为false。</li><li>onClick发生的前提是View可点击，并且它收到了down和up事件。</li><li>事件传递过程是由外而内，事件总是先传递给父元素，然后在由父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以在子元素干预父元素的事件分发过程，但ACTION_DOWN事件除外。</li></ul>]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ANDROID | 工具类</title>
      <link href="/2017/03/27/03%20ANDROID/ANDROID%20Activity/"/>
      <url>/2017/03/27/03%20ANDROID/ANDROID%20Activity/</url>
      
        <content type="html"><![CDATA[<h2 id="一、生命周期"><a href="#一、生命周期" class="headerlink" title="一、生命周期"></a>一、生命周期</h2><p><img src="http://ww1.sinaimg.cn/large/adc90466gy1fcptk0wnt2j20e90ifmz4" alt=""><br>整个生命周期来说，成对出现的。onCreate和onDestroy是成对的，代表着创建与销毁；onStart和onStop表示Activity对于程序是否可见（后台）；onResume和onPause表示Activity对于用户是否可见（前台）。</p><h4 id="正常生命周期"><a href="#正常生命周期" class="headerlink" title="正常生命周期"></a>正常生命周期</h4><p>1、启动ActivityA：onCreate() -&gt; onStart() -&gt; onResume()<br>2、按了back键返回：onPause() -&gt; onStop() -&gt; onDestroy()<br>3、用户按了Home键：onPause() -&gt; onStop()<br>4、启动ActivityB：A.onPause() -&gt; B.onCreate() -&gt; B.onStart() -&gt; B.onResume() -&gt; A.onStop()<br>5、ActivityB返回：B.onPause() -&gt; A.onRestart() -&gt; A.onStart() -&gt; A.onResume() -&gt; B.onStop()<br>-&gt; B.onDestroy()</p><h4 id="切换横竖屏幕"><a href="#切换横竖屏幕" class="headerlink" title="切换横竖屏幕"></a>切换横竖屏幕</h4><p>targetSdkVersion 25，没有设置android:configChanges：<br>1、竖屏切横屏：onConfigurationChanged() -&gt; onPause() -&gt; onSaveInstanceState() -&gt; onStop() -&gt; onDestroy() -&gt; onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume()<br>2、横屏切竖屏：onConfigurationChanged() -&gt; onPause() -&gt; onSaveInstanceState() -&gt; onStop() -&gt; onDestroy() -&gt; onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume()</p><p>本人使用的是模拟器（minSdkVersion 16 / targetSdkVersion 25）测试，无论是否设置Activity的android:configChanges，或者属性值设为orientation或orientation|keyboardHidden，无论是竖屏切横屏还是横屏切竖屏，流程都如上所述，当android:configChanges=”orientation|keyboardHidden|screenSize”时，只会调用onConfigurationChanged()。经过查资料，android:targetSdkVersion这个属性会影响横竖屏切换的生命周期。<a href="http://www.cnblogs.com/xiaoQLu/p/3324503.html" target="_blank" rel="external">详见xiaoQLud的博客</a></p><h4 id="异常生命周期"><a href="#异常生命周期" class="headerlink" title="异常生命周期"></a>异常生命周期</h4><p>1、系统配置发生改变后，默认情况下Activity会被销毁然后重新创建，生命周期参考横竖屏切换。常用的系统配置只有local、orientation和keyboardHidden。<br>2、资源内存不足导致低优先级的Activity被杀死，生命周期参考横竖屏切换。<br>3、运行时发生了异常，程序直接崩溃。例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (int i = 10; i &gt;= 0; i++)</div><div class="line">    System.out.println(10 / i)</div></pre></td></tr></table></figure></p><h2 id="二、数据存储"><a href="#二、数据存储" class="headerlink" title="二、数据存储"></a>二、数据存储</h2><p>当Activity在异常情况下被终止，在onStop之前，系统会调用onSaveInstanceState方法，来保存当前Activity状态。当Activity被重新创建后，系统会调用onRestoreInstanceState，并且把Activity销毁时onSaveInstanceState方法所保存的Bundle对象作为参数同时传递给onRestoreInstanceState和onCreate方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line">    <span class="built_in">set</span>ContentView(R.layout.activity_main);</div><div class="line">    <span class="keyword">if</span> (savedInstanceState != null) &#123;</div><div class="line">        String name = savedInstanceState.getString(<span class="string">"name"</span>);</div><div class="line">        Log.i(tag, <span class="string">"onCreate() name : "</span> + name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void onSaveInstanceState(Bundle outState) &#123;</div><div class="line">    super.onSaveInstanceState(outState);</div><div class="line">    Log.i(tag, <span class="string">"onSaveInstanceState()"</span>);</div><div class="line">    outState.putString(<span class="string">"name"</span>, <span class="string">"xianxiaotao"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void onRestoreInstanceState(Bundle savedInstanceState) &#123;</div><div class="line">    super.onRestoreInstanceState(savedInstanceState);</div><div class="line">    String name = savedInstanceState.getString(<span class="string">"name"</span>);</div><div class="line">    Log.i(tag, <span class="string">"onRestoreInstanceState() name : "</span> + name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>android提供的一些控件也实现了onSaveInstanceState和onRestoreInstanceState方法，如TextView。</p></blockquote><h2 id="三、启动模式"><a href="#三、启动模式" class="headerlink" title="三、启动模式"></a>三、启动模式</h2><p>ActivityManagerService（AMS）内部维护着一个ActivityStack栈，系统会将Activity实例一一放入栈内（先进后出），默认情况下创建一个实例压入栈内。如果多次创建同一个Activity，栈内将压入多个实例。为此，Android提供了启动模式来修改系统的默认行为。目前有四种启动模式：standard、singleTop、singleTask和singleInstance：</p><h4 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h4><p>标准模式，也是系统默认模式。每次启动一个Activity都会重新创建一个新的实例，不管这个实例是否已经存在。谁启动了这个Activity，那么这个Activity就运行在启动它的那个Activity所在的栈中。ABCBB</p><h4 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h4><p>栈顶复用模式。如果新Activity已经位于任务栈的栈顶，那么只调用它的onNewIntent方法实现复用，而不会创建新的实例。如果新的Activity的实例已存在但不是位于栈顶，仍然重新创建。假设目前栈内情况为ABCD（ABCD为四个Activity，A位于栈底），此时再次启动，如果D的启动模式为singleTop，那么栈内仍然是ABCD；如果D的启动模式为standard，D将被重新创建，栈内情况变为ABCDD。</p><h4 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h4><p>栈内复用模式。在同一个栈内，它是单实例模式。在这种模式下，启动一个Activity A，系统首先会寻找是否存在A想要的任务栈，如果不存在，就重新创建一个任务栈，然后创建A的实例并压入栈内；如果存在所需的任务栈，这时要看A是否在栈中有实例存在，如果有，那么系统就会把A调到栈顶并调用它的onNewIntent方法，不存在就创建并压入栈中。<br>1、目前任务栈栈S1(ABC)，此时Activity D以singleTask模式请求启动，其所需的任务栈为S2，由于S2和D的实例均不存在，所以系统先创建任务栈S2，然后再创建D的实例并将其放入栈S2中。<br>2、另外一种情况，假设D所需的任务栈为S1，上述S1已存在，所以系统会直接创建D的实例并压入栈S1内。<br>3、如果D所需的任务栈为S1，其中为ADBC，此时系统将D上面的Activity出栈，把D切换到栈顶并调用onNewIntent方法，最终S1栈内为AD。</p><h4 id="singleInstance："><a href="#singleInstance：" class="headerlink" title="singleInstance："></a>singleInstance：</h4><p>该模式具备singleTask模式的所有特性外，与它的区别就是，这种模式下的Activity会单独占用一个Task栈，具有全局唯一性，即整个系统中就这么一个实例，由于栈内复用的特性，后续的请求均不会创建新的Activity实例，除非这个特殊的任务栈被销毁了。以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。<br>以下代码是用于测试启动模式的BaseActivity，具体的Activity继承BaseActivity：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">package com.king.bester.demo;</div><div class="line"></div><div class="line">import android.content.Intent;</div><div class="line">import android.content.pm.ActivityInfo;</div><div class="line">import android.content.pm.PackageManager;</div><div class="line">import android.support.v7.app.AppCompatActivity;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.util.Log;</div><div class="line"></div><div class="line">public class BaseActivity extends AppCompatActivity &#123;</div><div class="line">    private static final String TAG = <span class="string">"Xian Xiaotao"</span>;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">        // 区别类名，区别同类名是否同实例，区别任务栈</div><div class="line">        Log.i(TAG, <span class="string">"onCreate："</span> + getClass().getSimpleName() + <span class="string">" hasCode:"</span> + this.hashCode() + <span class="string">" TaskId: "</span> + getTaskId());</div><div class="line">        // 任务栈名称，默认为包名相关</div><div class="line">        dumpTaskAffinity();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onNewIntent(Intent intent) &#123;</div><div class="line">        super.onNewIntent(intent);</div><div class="line"></div><div class="line">        Log.i(TAG, <span class="string">"onNewIntent："</span> + getClass().getSimpleName() + <span class="string">" hasCode:"</span> + this.hashCode() + <span class="string">" TaskId: "</span> + getTaskId());</div><div class="line">        dumpTaskAffinity();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void <span class="function"><span class="title">dumpTaskAffinity</span></span>()&#123;</div><div class="line">        try &#123;</div><div class="line">            ActivityInfo info = this.getPackageManager().getActivityInfo(getComponentName(), PackageManager.GET_META_DATA);</div><div class="line">            Log.i(TAG, <span class="string">"taskAffinity:"</span> + info.taskAffinity);</div><div class="line">        &#125; catch (PackageManager.NameNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>配置形式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;activity </div><div class="line">    android:name=<span class="string">".ActivitySingleTop"</span> </div><div class="line">    android:launchMode=<span class="string">"singleTop"</span> </div><div class="line">    android:taskAffinity=<span class="string">"com.king.bester.demo"</span>/&gt;</div></pre></td></tr></table></figure></p><p><a href="http://blog.csdn.net/mynameishuangshuai/article/details/51491074" target="_blank" rel="external">启动模式参考博客</a></p><h2 id="四、意图调用"><a href="#四、意图调用" class="headerlink" title="四、意图调用"></a>四、意图调用</h2><p>启动Activity分为两种，显示调用和隐式调用。显示调用通过指定Intent组件名称来实现的，它一般用在知道目标组件名称的前提下，一般是在相同的应用程序内部实现的。隐式调用通过Intent Filter来实现的，它一般用在没有明确指出目标组件名称的前提下，一般是用于在不同应用程序之间。</p><h4 id="显示调用"><a href="#显示调用" class="headerlink" title="显示调用"></a>显示调用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent=new Intent(MainActivity.this,SettingActivity.class);</div><div class="line">intent.putExtra(EXTRA,contentEditText.getText().toString());</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure><p>而Manifest文件描述为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;activity android:name=<span class="string">".MainActivity"</span> &gt; </div><div class="line">    &lt;intent-filter&gt; </div><div class="line">        &lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt; </div><div class="line">        &lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt; </div><div class="line">    &lt;/intent-filter&gt; </div><div class="line">&lt;/activity&gt; </div><div class="line">&lt;activity android:name=<span class="string">".SettingActivity"</span> /&gt;</div></pre></td></tr></table></figure></p><h4 id="隐式调用"><a href="#隐式调用" class="headerlink" title="隐式调用"></a>隐式调用</h4><p>隐式不明确指定启动哪个Activity，而是在Intent Filter中设置Action、Data、Category，让系统来筛选出合适的Activity。清单文件配置如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</div><div class="line">&lt;manifest xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    package=<span class="string">"com.king.bester.myapplication"</span>&gt;</div><div class="line"></div><div class="line">    &lt;application</div><div class="line">        android:allowBackup=<span class="string">"true"</span></div><div class="line">        android:icon=<span class="string">"@mipmap/ic_launcher"</span></div><div class="line">        android:supportsRtl=<span class="string">"true"</span></div><div class="line">        android:theme=<span class="string">"@style/AppTheme"</span>&gt;</div><div class="line">        &lt;activity android:name=<span class="string">".MainActivity"</span> &gt;</div><div class="line">            &lt;intent-filter&gt;</div><div class="line">                &lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</div><div class="line">                &lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</div><div class="line">            &lt;/intent-filter&gt;</div><div class="line">        &lt;/activity&gt;</div><div class="line"></div><div class="line">        &lt;activity</div><div class="line">            android:name=<span class="string">".TargetActivity"</span></div><div class="line">            android:launchMode=<span class="string">"singleTask"</span></div><div class="line">            android:taskAffinity=<span class="string">"com.king.bester.myapplication"</span> &gt;</div><div class="line">            &lt;intent-filter&gt;</div><div class="line">                &lt;action android:name=<span class="string">"android.intent.action.SEND"</span>/&gt;</div><div class="line">                &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</div><div class="line">                &lt;data android:mimeType=<span class="string">"text/plain"</span>/&gt;</div><div class="line">            &lt;/intent-filter&gt;</div><div class="line">            &lt;intent-filter&gt;</div><div class="line">                &lt;action android:name=<span class="string">"com.king.bester.demo"</span> /&gt;</div><div class="line">                &lt;action android:name=<span class="string">"com.king.bester.DEMO"</span> /&gt;</div><div class="line">                &lt;category android:name=<span class="string">"com.king.bester.a"</span> /&gt;</div><div class="line">                &lt;category android:name=<span class="string">"com.king.bester.b"</span> /&gt;</div><div class="line">                &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</div><div class="line">                &lt;data android:mimeType=<span class="string">"text/plain"</span>/&gt;</div><div class="line">            &lt;/intent-filter&gt;</div><div class="line">        &lt;/activity&gt;</div><div class="line">    &lt;/application&gt;</div><div class="line"></div><div class="line">&lt;/manifest&gt;</div></pre></td></tr></table></figure></p><p>代码调用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 匹配第一组intent-filter</div><div class="line">public void startA(View view) &#123;</div><div class="line">    Intent intent = new Intent();</div><div class="line">    intent.setAction(<span class="string">"android.intent.action.SEND"</span>);</div><div class="line">    intent.setType(<span class="string">"text/plain"</span>);</div><div class="line">    startActivity(intent);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 匹配第二组intent-filter</div><div class="line">public void startB(View view) &#123;</div><div class="line">    Intent intent = new Intent();</div><div class="line">    intent.setAction(<span class="string">"com.king.bester.demo"</span>);</div><div class="line">    intent.addCategory(<span class="string">"com.king.bester.a"</span>);</div><div class="line">    intent.setType(<span class="string">"text/plain"</span>);</div><div class="line">    startActivity(intent);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>1、startA()中没有设置category，是因为系统在调用startActivity或者startActivityForResult的时候会默认为Intent加上“android.intent.category.DEFAULT”这个category。所以，为了我们的Activity能接收隐式调用，必须在intent-filter中指定这个category。<br>2、action区分大小写<br>3、一个Activity可以有多个intent-filter，一个intent只要能匹配任何一组intent-filter即可启动对应的Activity。</p>]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
            <tag> util </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ANDROID | 自定义VIEW入门</title>
      <link href="/2017/02/01/03%20ANDROID/ANDROID%20%E8%87%AA%E5%AE%9A%E4%B9%89View%20%E5%85%A5%E9%97%A8/"/>
      <url>/2017/02/01/03%20ANDROID/ANDROID%20%E8%87%AA%E5%AE%9A%E4%B9%89View%20%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、自定义View"><a href="#一、自定义View" class="headerlink" title="一、自定义View"></a>一、自定义View</h2><p>Android系统内置的View无法满足业务需求，需要自定义。</p><h4 id="Step-1-继承View"><a href="#Step-1-继承View" class="headerlink" title="Step 1 : 继承View"></a>Step 1 : 继承View</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class CustomView extends View &#123;</div><div class="line">    public CustomView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public CustomView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>至少写2个构造函数</p></blockquote><h4 id="Step-2-自定义属性"><a href="#Step-2-自定义属性" class="headerlink" title="Step 2 : 自定义属性"></a>Step 2 : 自定义属性</h4><p>有些属性希望由用户指定，只有当用户不指定的时候才用我们硬编码的值，比如默认的宽高，在res/values/styles.xml文件里声明：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;resources&gt;</div><div class="line"></div><div class="line">    &lt;!-- suggestion：the name is the class name --&gt;</div><div class="line">    &lt;<span class="built_in">declare</span>-styleable name=<span class="string">"CustomView"</span>&gt;</div><div class="line">        &lt;attr name=<span class="string">"default_size"</span> format=<span class="string">"dimension"</span> /&gt;</div><div class="line">    &lt;/<span class="built_in">declare</span>-styleable&gt;</div><div class="line"></div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure></p><p>布局文件activity_main.xml中使用自定义的属性<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    xmlns:xian=<span class="string">"http://schemas.android.com/apk/res-auto"</span></div><div class="line">    android:layout_width=<span class="string">"match_parent"</span></div><div class="line">    android:layout_height=<span class="string">"match_parent"</span>&gt;</div><div class="line"></div><div class="line">    &lt;!-- xian为命名空间，名称随便定义，其值固定为<span class="string">"http://schemas.android.com/apk/res-auto"</span> --&gt;</div><div class="line">    &lt;com.king.demo.customview.CustomView</div><div class="line">        android:layout_width=<span class="string">"match_parent"</span></div><div class="line">        android:layout_height=<span class="string">"100dp"</span></div><div class="line">        xian:default_size=<span class="string">"100dp"</span> /&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>构造器中读取配置信息并初始化<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private int defaultSize;</div><div class="line">public CustomView(Context context, AttributeSet attrs) &#123;</div><div class="line">    super(context, attrs);</div><div class="line"></div><div class="line">    TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CustomView);</div><div class="line">    defaultSize = a.getDimensionPixelSize(R.styleable.CustomView_default_size, 100);</div><div class="line">    a.recycle();        // 回收TypedArray对象</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="Step-3-重写onMeasure"><a href="#Step-3-重写onMeasure" class="headerlink" title="Step 3 : 重写onMeasure()"></a>Step 3 : 重写onMeasure()</h4><p>测量宽高尺寸并设置需要的值。如果不需要制定自定义控件的宽高，无需重写此方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">    super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">    // 重构控件宽高，此处设宽高相等</div><div class="line">    int width = getMySize(100, widthMeasureSpec);</div><div class="line">    int height = getMySize(100, heightMeasureSpec);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (width &lt; height) </div><div class="line">        height = width;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        width = height;</div><div class="line"></div><div class="line">    <span class="built_in">set</span>MeasuredDimension(width, height);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 辅助方法，计算宽高</div><div class="line"> * @param defaultSize 设置宽高默认的值</div><div class="line"> * @param measureSpec </div><div class="line"> * @<span class="built_in">return</span></div><div class="line"> */</div><div class="line">private int getMySize(int defaultSize, int measureSpec) &#123;</div><div class="line">    int mySize = defaultSize;</div><div class="line"></div><div class="line">    int mode = MeasureSpec.getMode(measureSpec);</div><div class="line">    int size = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">    switch (mode) &#123;</div><div class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:   // 如果没有指定大小，就设置为默认大小</div><div class="line">            mySize = defaultSize;</div><div class="line">            <span class="built_in">break</span>;</div><div class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:       // 如果测量模式是最大取值为size</div><div class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:       // 如果是固定的大小，那就不要去改变它</div><div class="line">            mySize = size;</div><div class="line">            <span class="built_in">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> mySize;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><ul><li>onMeasure()至少会被调用两次，第一次读取xml文件中的参数layout_width和layout_width，它们可以不用指定具体的尺寸，如值为wrap_content或match_parent。为了更好的适配各种尺寸的屏幕，需要根据父类布局或子类控件宽高动态计算实际宽高，而不是在xml中指定具体的数值。</li><li>widthMeasureSpec和heightMeasureSpec都是int，前面2个bit用于区分不同的测量模式，后面30个bit存放的是尺寸的数据。测量模式分三种：UNSPECIFIED（父容器没有对当前View有任何限制，当前View可以任意取尺寸）、EXACTLY（当前的尺寸就是当前View应该取的尺寸，对应match_parent和固定值）、AT_MOST（当前尺寸是当前View能取的最大尺寸，对应wrap_content）</li></ul></blockquote><h4 id="Step-4-重写onDraw"><a href="#Step-4-重写onDraw" class="headerlink" title="Step 4 : 重写onDraw()"></a>Step 4 : 重写onDraw()</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line"></div><div class="line">    int r = getMeasuredWidth() / 2;</div><div class="line">    int centerX = getLeft() + r;</div><div class="line">    int centerY = getTop() + r;</div><div class="line"></div><div class="line">    Paint paint = new Paint();</div><div class="line">    paint.setColor(Color.RED);</div><div class="line">    canvas.drawCircle(centerX, centerY, r, paint);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p><img src="http://ww1.sinaimg.cn/large/adc90466ly1fdhnwpy6pgj206o0b4wek" alt=""></p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">package com.king.demo.customview;</div><div class="line"></div><div class="line">import android.content.Context;</div><div class="line">import android.content.res.TypedArray;</div><div class="line">import android.graphics.Canvas;</div><div class="line">import android.graphics.Color;</div><div class="line">import android.graphics.Paint;</div><div class="line">import android.util.AttributeSet;</div><div class="line">import android.view.View;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 继承View，至少写2个构造函数</div><div class="line"> */</div><div class="line">public class CustomView extends View &#123;</div><div class="line">    private int defaultSize;</div><div class="line"></div><div class="line">    public CustomView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public CustomView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CustomView);</div><div class="line">        defaultSize = a.getDimensionPixelSize(R.styleable.CustomView_default_size, 100);</div><div class="line">        a.recycle();        // 回收TypedArray对象</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 辅助方法，计算宽高</div><div class="line">     * @param defaultSize 设置宽高默认的值</div><div class="line">     * @param measureSpec</div><div class="line">     * @<span class="built_in">return</span></div><div class="line">     */</div><div class="line">    private int getMySize(int defaultSize, int measureSpec) &#123;</div><div class="line">        int mySize = defaultSize;</div><div class="line"></div><div class="line">        int mode = MeasureSpec.getMode(measureSpec);</div><div class="line">        int size = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">        switch (mode) &#123;</div><div class="line">            <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:   // 如果没有指定大小，就设置为默认大小</div><div class="line">                mySize = defaultSize;</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">            <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">            <span class="keyword">case</span> MeasureSpec.EXACTLY:       // 如果是固定的大小，那就不要去改变它</div><div class="line">                mySize = size;</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> mySize;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">        // 重构控件宽高</div><div class="line">        int width = getMySize(defaultSize, widthMeasureSpec);</div><div class="line">        int height = getMySize(defaultSize, heightMeasureSpec);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (width &lt; height) &#123;</div><div class="line">            height = width;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            width = height;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">set</span>MeasuredDimension(width, height);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        int r = getMeasuredWidth() / 2;</div><div class="line">        int centerX = getLeft() + r;</div><div class="line">        int centerY = getTop() + r;</div><div class="line"></div><div class="line">        Paint paint = new Paint();</div><div class="line">        paint.setColor(Color.RED);</div><div class="line">        canvas.drawCircle(centerX, centerY, r, paint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二、自定义ViewGroup"><a href="#二、自定义ViewGroup" class="headerlink" title="二、自定义ViewGroup"></a>二、自定义ViewGroup</h2><p>模拟一个简易垂直布局，详情可参考Android内置的LinearLayout源码。</p><h4 id="Step-1-继承ViewGroup"><a href="#Step-1-继承ViewGroup" class="headerlink" title="Step 1 : 继承ViewGroup"></a>Step 1 : 继承ViewGroup</h4><p>必须实现onLayout(boolean changed, int left, int top, int right, int bottom)方法，用于“摆放”各个子View。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by xianxiaotao on 17/3/11.</div><div class="line"> */</div><div class="line">public class SimpleLinearLayout extends ViewGroup &#123;</div><div class="line"></div><div class="line">    public SimpleLinearLayout(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public SimpleLinearLayout(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">    // TODO</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="Step-2-自定义属性（同上）"><a href="#Step-2-自定义属性（同上）" class="headerlink" title="Step 2 : 自定义属性（同上）"></a>Step 2 : 自定义属性（同上）</h4><h4 id="Step-3-重写onMeasure-1"><a href="#Step-3-重写onMeasure-1" class="headerlink" title="Step 3 : 重写onMeasure()"></a>Step 3 : 重写onMeasure()</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">    super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    measureChildren(widthMeasureSpec, heightMeasureSpec);   // 触发每个子View的onMeasure方法</div><div class="line"></div><div class="line">    int count = getChildCount();</div><div class="line">    int maxWidth = 0;</div><div class="line">    int height = 0;</div><div class="line">    <span class="keyword">for</span> (int i = 0; i &lt; count; i++) &#123;</div><div class="line">        View child = getChildAt(i);</div><div class="line">        <span class="keyword">if</span> (child == null || child.getVisibility() == View.GONE)</div><div class="line">            <span class="built_in">continue</span>;</div><div class="line"></div><div class="line">        int childWidth = child.getMeasuredWidth();</div><div class="line">        int childHeight = child.getMeasuredHeight();</div><div class="line">        maxWidth = childWidth &gt; maxWidth ? childWidth : maxWidth;</div><div class="line">        height += childHeight;  // 不考虑Margin</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.AT_MOST)</div><div class="line">        maxWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">    <span class="keyword">if</span> (MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.AT_MOST)</div><div class="line">        height = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line"></div><div class="line">    <span class="built_in">set</span>MeasuredDimension(maxWidth, height);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="Step-4-重写onLayout"><a href="#Step-4-重写onLayout" class="headerlink" title="Step 4 : 重写onLayout()"></a>Step 4 : 重写onLayout()</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">    int count = getChildCount();</div><div class="line"></div><div class="line">    int curHeight = t;  // 记录当前的高度位置</div><div class="line">    <span class="keyword">for</span> (int i = 0; i &lt; count; i++) &#123;</div><div class="line">        View child = getChildAt(i);</div><div class="line">        int height = child.getMeasuredHeight();</div><div class="line">        int width = child.getMeasuredWidth();</div><div class="line">        child.layout(l, curHeight, l + width, curHeight + height);</div><div class="line">        curHeight += height;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    xmlns:xian=<span class="string">"http://schemas.android.com/apk/res-auto"</span></div><div class="line">    android:layout_width=<span class="string">"match_parent"</span></div><div class="line">    android:layout_height=<span class="string">"match_parent"</span>&gt;</div><div class="line"></div><div class="line">    &lt;com.king.demo.customview.SimpleLinearLayout</div><div class="line">        android:layout_width=<span class="string">"wrap_content"</span></div><div class="line">        android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">        android:background=<span class="string">"#00FFFF"</span>&gt;</div><div class="line"></div><div class="line">        &lt;Button</div><div class="line">            android:layout_width=<span class="string">"100dp"</span></div><div class="line">            android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">            android:text=<span class="string">"btn"</span> /&gt;</div><div class="line"></div><div class="line">        &lt;Button</div><div class="line">            android:layout_width=<span class="string">"200dp"</span></div><div class="line">            android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">            android:text=<span class="string">"btn"</span> /&gt;</div><div class="line"></div><div class="line">        &lt;Button</div><div class="line">            android:layout_width=<span class="string">"75dp"</span></div><div class="line">            android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">            android:text=<span class="string">"btn"</span> /&gt;</div><div class="line">    &lt;/com.king.demo.customview.SimpleLinearLayout&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure><h4 id="效果图-1"><a href="#效果图-1" class="headerlink" title="效果图"></a>效果图</h4><p><img src="http://ww1.sinaimg.cn/large/adc90466ly1fdivvq0dpvj206o0b4aa5" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
            <tag> CUSTOM VIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ANDROID | 工具类</title>
      <link href="/2016/10/24/03%20ANDROID/ANDROID%20%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2016/10/24/03%20ANDROID/ANDROID%20%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>常用工具类：</p><ul><li>L.java 日志</li></ul><h3 id="一、日志工具类-L-java"><a href="#一、日志工具类-L-java" class="headerlink" title="一、日志工具类(L.java)"></a>一、日志工具类(L.java)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">package com.xxt.util;</div><div class="line"></div><div class="line">import android.util.Log;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Log统一管理类</div><div class="line"> *     isDebug  控制是否输出日志</div><div class="line"> *     level  控制输出日志等级</div><div class="line"> *     LV: VERBOSE</div><div class="line"> *     LD: DEBUG</div><div class="line"> *     LI: INFO</div><div class="line"> *     LW: WARN</div><div class="line"> *     LE: ERROR</div><div class="line"> *</div><div class="line"> * Created by xianxiaotao on 17/3/2.</div><div class="line"> */</div><div class="line">public class L &#123;</div><div class="line"></div><div class="line">    private static final String TAG = <span class="string">"LOG"</span>;</div><div class="line"></div><div class="line">    // 输出日志等级</div><div class="line">    public static final int LV = 1;</div><div class="line">    public static final int LD = 2;</div><div class="line">    public static final int LI = 3;</div><div class="line">    public static final int LW = 4;</div><div class="line">    public static final int LE = 5;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 输出日志总开关，可以在Application的onCreate方法中初始化</div><div class="line">     */</div><div class="line">    public static boolean isDebug = <span class="literal">true</span>;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 输出日志等级，值为LV，则输出所有日志，值为LE，则只输出Error日志</div><div class="line">     */</div><div class="line">    public static int level = LV;</div><div class="line"></div><div class="line">    private <span class="function"><span class="title">L</span></span>() &#123;&#125;  /* cannot be instantiated */</div><div class="line"></div><div class="line">    public static void v(String msg) &#123;</div><div class="line">        <span class="keyword">if</span> (isDebug &amp;&amp; level &lt;= LV)</div><div class="line">            Log.v(TAG, msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void d(String msg) &#123;</div><div class="line">        <span class="keyword">if</span> (isDebug &amp;&amp; level &lt;= LD)</div><div class="line">            Log.d(TAG, msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void i(String msg) &#123;</div><div class="line">        <span class="keyword">if</span> (isDebug &amp;&amp; level &lt;= LI)</div><div class="line">            Log.i(TAG, msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void w(String msg) &#123;</div><div class="line">        <span class="keyword">if</span> (isDebug &amp;&amp; level &lt;= LW)</div><div class="line">            Log.w(TAG, msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void e(String msg) &#123;</div><div class="line">        <span class="keyword">if</span> (isDebug &amp;&amp; level &lt;= LE)</div><div class="line">            Log.e(TAG, msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void v(String tag, String msg) &#123;</div><div class="line">        <span class="keyword">if</span> (isDebug &amp;&amp; level &lt;= LV)</div><div class="line">            Log.v(tag, msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void d(String tag, String msg) &#123;</div><div class="line">        <span class="keyword">if</span> (isDebug &amp;&amp; level &lt;= LD)</div><div class="line">            Log.d(tag, msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void i(String tag, String msg) &#123;</div><div class="line">        <span class="keyword">if</span> (isDebug &amp;&amp; level &lt;= LI)</div><div class="line">            Log.i(tag, msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void w(String tag, String msg) &#123;</div><div class="line">        <span class="keyword">if</span> (isDebug &amp;&amp; level &lt;= LW)</div><div class="line">            Log.w(tag, msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void e(String tag, String msg) &#123;</div><div class="line">        <span class="keyword">if</span> (isDebug &amp;&amp; level &lt;= LE)</div><div class="line">            Log.e(tag, msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
            <tag> util </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ANDROID | 动态权限</title>
      <link href="/2016/10/23/03%20ANDROID/ANDROID%206.0%20%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90/"/>
      <url>/2016/10/23/03%20ANDROID/ANDROID%206.0%20%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<p>在Android6.0及以上版本中，即使在AndroidManifest.xml文件里配置了如下权限：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.CALL_PHONE"</span>/&gt;</div></pre></td></tr></table></figure></p><p>运行时会也会报错：<br>java.lang.SecurityException: Permission Denial: starting Intent { act=android.intent.action.CALL dat=tel:xxxxxx cmp=com.android.server.telecom/.components.UserCallActivity } from ProcessRecord{ece7708 3894:com.test.xianxiaotao.test/u0a79} (pid=3894, uid=10079) with revoked permission android.permission.CALL_PHONE</p><p>这是因为Android6.0及以上版本增添了<a href="https://developer.android.com/training/permissions/requesting.html" target="_blank" rel="external">动态权限</a>。在哪个页面需要这个权限只需要直接去请求就行了，而且还有了相应的监听的方法供你来判断。具体使用参考如下代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private EditText editText;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        <span class="built_in">set</span>ContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        // 动态请求权限</div><div class="line">        ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.CALL_PHONE&#125;, 0x11);</div><div class="line">        editText = (EditText) findViewById(R.id.editText);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 拨打</div><div class="line">     * @param v 触发监听事件的view</div><div class="line">     */</div><div class="line">    public void call(View v) &#123;</div><div class="line">        String number = editText.getText().toString();</div><div class="line">        <span class="keyword">if</span> (null == number || number.length() == 0)</div><div class="line">            <span class="built_in">return</span>;</div><div class="line">        Intent intent = new Intent();</div><div class="line">        intent.setAction(Intent.ACTION_CALL);</div><div class="line">        intent.setData(Uri.parse(<span class="string">"tel://"</span> + number));</div><div class="line">        startActivity(intent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 监听权限是否允许</div><div class="line">     * @param requestCode</div><div class="line">     * @param permissions</div><div class="line">     * @param grantResults</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;</div><div class="line">        super.onRequestPermissionsResult(requestCode, permissions, grantResults);</div><div class="line">        <span class="keyword">if</span> (requestCode == 0x11) &#123;</div><div class="line">            <span class="keyword">if</span> (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)</div><div class="line">                Log.i(<span class="string">"CMCC"</span>, <span class="string">"权限被允许"</span>);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                Log.i(<span class="string">"CMCC"</span>, <span class="string">"权限被拒绝"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果：<br><img src="http://ww1.sinaimg.cn/large/adc90466ly1fd7n9a1fgpj20b605q3yu" alt=""></p><blockquote><p>使用权限的页面中弹出提示框并被允许，则以后不再弹出。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ANDROID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06 ImageLoader 项目源码</title>
      <link href="/1902/01/06/06%20THIRD%20PARY%20FRAMEWORK/06%20ImageLoader%20%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81/"/>
      <url>/1902/01/06/06%20THIRD%20PARY%20FRAMEWORK/06%20ImageLoader%20%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-6bff4d0834c7ce6f?imageMogr2/auto-orient/strip" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1902/01/01/03IMAGE%20LOADER/01%20ImageLoader%20基础框架/" target="_blank" rel="external">01 基础框架</a><br><a href="https://xianxiaotao.github.io/1902/01/02/03IMAGE%20LOADER/02%20ImageLoader%20请求队列/" target="_blank" rel="external">02 请求队列</a><br><a href="https://xianxiaotao.github.io/1902/01/03/03IMAGE%20LOADER/03%20ImageLoader%20三级缓存/" target="_blank" rel="external">03 三级缓存</a><br><a href="https://xianxiaotao.github.io/1902/01/04/03IMAGE%20LOADER/04%20ImageLoader%20图片加载/" target="_blank" rel="external">04 图片加载</a><br><a href="https://xianxiaotao.github.io/1902/01/05/03IMAGE%20LOADER/05%20ImageLoader%20常见问题/" target="_blank" rel="external">05 常见问题</a><br><a href="https://xianxiaotao.github.io/1902/01/06/03IMAGE%20LOADER/06%20ImageLoader%20项目源码/" target="_blank" rel="external">06 项目源码</a></p></blockquote><p>使用 ImageLoader 示例：初始化、调用、关闭。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">private void initImageLoader() &#123;</div><div class="line">    ImageLoaderConfig config = new ImageLoaderConfig.Builder()</div><div class="line">            .setCache(new DoubleCache(this))</div><div class="line">            .setThreadCount(4)</div><div class="line">            .setLoadPolicy(new ReversePolicy())</div><div class="line">            .create();</div><div class="line">    // 初始化</div><div class="line">    ImageLoader.getInstance().init(config);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public View getView(int position, View convertView, ViewGroup parent) &#123;</div><div class="line">    if (convertView == null) &#123;</div><div class="line">        convertView = getActivity().getLayoutInflater().inflate(</div><div class="line">                R.layout.image_item_layout, parent, false);</div><div class="line">    &#125;</div><div class="line">    ImageView imageview = convertView.findViewById(R.id.id_img);</div><div class="line">    // 加载图片</div><div class="line">    ImageLoader.getInstance().displayImage(getItem(position), imageview);</div><div class="line">    return convertView;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void onDestroy() &#123;</div><div class="line">    // 退出时关闭</div><div class="line">    ImageLoader.getInstance().stop();</div><div class="line">    super.onDestroy();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h3><hr><h4 id="ImageLoader-java"><a href="#ImageLoader-java" class="headerlink" title="ImageLoader.java"></a>ImageLoader.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line">    // ImageLoader 实例</div><div class="line">    private static ImageLoader sInstance;</div><div class="line">    // 图片内存缓存</div><div class="line">    private IBitmapCache mCache = new MemoryCache();</div><div class="line">    // 网络请求队列</div><div class="line">    private RequestQueue mImageQueue;</div><div class="line">    // 图片加载配置对象</div><div class="line">    private ImageLoaderConfig mConfig;</div><div class="line"></div><div class="line">    private ImageLoader() &#123;&#125;</div><div class="line"></div><div class="line">    public static ImageLoader getInstance() &#123;</div><div class="line">        if (sInstance == null) &#123;</div><div class="line">            synchronized (ImageLoader.class) &#123;</div><div class="line">                if (sInstance == null) &#123;</div><div class="line">                    sInstance = new ImageLoader();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void init(ImageLoaderConfig config) &#123;</div><div class="line">        mConfig = config;</div><div class="line">        mCache = mConfig.mCache;</div><div class="line">        checkConfig();</div><div class="line">        mImageQueue = new RequestQueue(mConfig.threadCount);</div><div class="line">        mImageQueue.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void checkConfig() &#123;</div><div class="line">        if (mConfig == null) &#123;</div><div class="line">            throw new RuntimeException(&quot;The config of SimpleImageLoader &quot; +</div><div class="line">                    &quot;is Null, please call the init(ImageLoaderConfig &quot; +</div><div class="line">                    &quot;config) method to initialize&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mConfig.loadPolicy == null) &#123;</div><div class="line">            mConfig.loadPolicy = new SerialPolicy();</div><div class="line">        &#125;</div><div class="line">        if (mCache == null) &#123;</div><div class="line">            mCache = new MemoryCache();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void stop() &#123;</div><div class="line">        mImageQueue.stop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public IBitmapCache getCache() &#123;</div><div class="line">        return mCache;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void displayImage(String uri, ImageView imageView) &#123;</div><div class="line">        BitmapRequest request = new BitmapRequest(imageView, uri);</div><div class="line">        request.mLoadPolicy = mConfig.loadPolicy;</div><div class="line">        mImageQueue.addRequest(request);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="RequestQueue-java"><a href="#RequestQueue-java" class="headerlink" title="RequestQueue.java"></a>RequestQueue.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">public class RequestQueue &#123;</div><div class="line">    // 请求队列 [ Thread-safe ]</div><div class="line">    private BlockingQueue&lt;BitmapRequest&gt; mBitmapRequestQueue =</div><div class="line">            new PriorityBlockingQueue&lt;&gt;();</div><div class="line">    // 请求的序列化生成器</div><div class="line">    private AtomicInteger mSerialNumGenerator = new AtomicInteger(0);</div><div class="line"></div><div class="line">    // 默认的核心数：CPU 核心数 + 1个分发线程数</div><div class="line">    public static int DEFAULT_CORE_NUM =</div><div class="line">            Runtime.getRuntime().availableProcessors() + 1;</div><div class="line">    private int mDispatcherNum;</div><div class="line">    private RequestDispatcher[] mDispatchers = null;</div><div class="line"></div><div class="line">    protected RequestQueue() &#123;</div><div class="line">        this(DEFAULT_CORE_NUM);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected RequestQueue(int coreNum) &#123;</div><div class="line">        mDispatcherNum = coreNum;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 维护线程池</div><div class="line">    private final void startDispatchers() &#123;</div><div class="line">        mDispatchers = new RequestDispatcher[mDispatcherNum];</div><div class="line">        for (int i = 0; i &lt; mDispatcherNum; i++) &#123;</div><div class="line">            mDispatchers[i] = new RequestDispatcher(mBitmapRequestQueue);</div><div class="line">            mDispatchers[i].start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void start() &#123;</div><div class="line">        stop();</div><div class="line">        startDispatchers();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void stop() &#123;</div><div class="line">        if (mDispatchers != null &amp;&amp; mDispatchers.length &gt; 0) &#123;</div><div class="line">            for (int i = 0; i &lt; mDispatchers.length; i++) &#123;</div><div class="line">                mDispatchers[i].interrupt();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void addRequest(BitmapRequest request) &#123;</div><div class="line">        if (!mBitmapRequestQueue.contains(request)) &#123;</div><div class="line">            request.serialNum = this.generateSerialNumber();</div><div class="line">            mBitmapRequestQueue.add(request);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 为每个请求生成一个系列号</div><div class="line">    private int generateSerialNumber() &#123;</div><div class="line">        return mSerialNumGenerator.incrementAndGet();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="RequestDispatcher-java"><a href="#RequestDispatcher-java" class="headerlink" title="RequestDispatcher.java"></a>RequestDispatcher.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class RequestDispatcher extends Thread &#123;</div><div class="line"></div><div class="line">    // 网络请求队列</div><div class="line">    private BlockingQueue&lt;BitmapRequest&gt; mBitmapRequestQueue;</div><div class="line"></div><div class="line">    public RequestDispatcher(BlockingQueue&lt;BitmapRequest&gt; queue) &#123;</div><div class="line">        mBitmapRequestQueue = queue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        try &#123;</div><div class="line">            while (!this.isInterrupted()) &#123;</div><div class="line">                final BitmapRequest request = mBitmapRequestQueue.take();</div><div class="line">                if (request.isCancel) &#123;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                Scheme scheme = Scheme.ofUri(request.imageUri);</div><div class="line">                ILoader loader = LoaderManager.getInstance().getLoader(scheme);</div><div class="line">                if (loader != null) &#123;</div><div class="line">                    loader.loadImage(request);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            Log.i(&quot;&quot;, &quot;### 请求分发器退出&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="BitmapRequest-java"><a href="#BitmapRequest-java" class="headerlink" title="BitmapRequest.java"></a>BitmapRequest.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">public class BitmapRequest implements Comparable&lt;BitmapRequest&gt; &#123;</div><div class="line">    private Reference&lt;ImageView&gt; mImageViewRef;</div><div class="line">    public String imageUri;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 是否取消该请求</div><div class="line">     */</div><div class="line">    public boolean isCancel = false;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 请求序列号</div><div class="line">     */</div><div class="line">    public int serialNum = 0;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 加载策略</div><div class="line">     */</div><div class="line">    public LoadPolicy mLoadPolicy = new SerialPolicy();</div><div class="line"></div><div class="line">    public BitmapRequest(ImageView imageView, String uri) &#123;</div><div class="line">        this.mImageViewRef = new WeakReference&lt;&gt;(imageView);</div><div class="line">        this.imageUri = uri;</div><div class="line">        imageView.setTag(uri);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ImageView getImageView() &#123;</div><div class="line">        return mImageViewRef.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // image view 的 tag 与 uri 是否相等</div><div class="line">    public boolean isImageViewTagValid() &#123;</div><div class="line">        return mImageViewRef.get() != null &amp;&amp; mImageViewRef.get().getTag().equals(imageUri);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getImageViewWidth() &#123;</div><div class="line">        return ImageViewHelper.getImageViewWidth(mImageViewRef.get());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getImageViewHeight() &#123;</div><div class="line">        return ImageViewHelper.getImageViewHeight(mImageViewRef.get());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int compareTo(BitmapRequest another) &#123;</div><div class="line">        return mLoadPolicy.compare(this, another);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int hashCode() &#123;</div><div class="line">        final int prime = 31;</div><div class="line">        int result = 1;</div><div class="line">        result = prime * result + ((imageUri == null) ? 0 : imageUri.hashCode());</div><div class="line">        result = prime * result + ((mImageViewRef.get() == null) ? 0 : mImageViewRef.get().hashCode());</div><div class="line">        result = prime * result + serialNum;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean equals(Object obj) &#123;</div><div class="line">        if (this == obj)</div><div class="line">            return true;</div><div class="line">        if (obj == null)</div><div class="line">            return false;</div><div class="line">        if (getClass() != obj.getClass())</div><div class="line">            return false;</div><div class="line">        BitmapRequest other = (BitmapRequest) obj;</div><div class="line">        if (imageUri == null) &#123;</div><div class="line">            if (other.imageUri != null)</div><div class="line">                return false;</div><div class="line">        &#125; else if (!imageUri.equals(other.imageUri))</div><div class="line">            return false;</div><div class="line">        if (mImageViewRef == null) &#123;</div><div class="line">            if (other.mImageViewRef != null)</div><div class="line">                return false;</div><div class="line">        &#125; else if (!mImageViewRef.get().equals(other.mImageViewRef.get()))</div><div class="line">            return false;</div><div class="line">        if (serialNum != other.serialNum)</div><div class="line">            return false;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><hr><h4 id="IBitmapCache-java"><a href="#IBitmapCache-java" class="headerlink" title="IBitmapCache.java"></a>IBitmapCache.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface IBitmapCache &#123;</div><div class="line">    void put(BitmapRequest key, Bitmap value);</div><div class="line">    Bitmap get(BitmapRequest key);</div><div class="line">    void remove(BitmapRequest key);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="MemoryCache-java"><a href="#MemoryCache-java" class="headerlink" title="MemoryCache.java"></a>MemoryCache.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class MemoryCache implements IBitmapCache &#123;</div><div class="line">    private static final int ONE_KB = 1024;</div><div class="line">    private static final int MAX_MEMORY_PERCENT = 4;</div><div class="line"></div><div class="line">    // 图片内存缓存</div><div class="line">    private LruCache&lt;BitmapRequest, Bitmap&gt; mImageCache;</div><div class="line"></div><div class="line">    public MemoryCache() &#123;</div><div class="line">        initImageCache();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 初始化缓存大小：取四分之一的可用内存作为缓存。</div><div class="line">    private void initImageCache() &#123;</div><div class="line">        int maxMemory = (int) (Runtime.getRuntime().maxMemory() / ONE_KB);</div><div class="line">        int cacheSize = maxMemory / MAX_MEMORY_PERCENT;</div><div class="line">        mImageCache = new LruCache&lt;BitmapRequest, Bitmap&gt;(cacheSize) &#123;</div><div class="line">            @Override</div><div class="line">            protected int sizeOf(BitmapRequest key, Bitmap bitmap) &#123;</div><div class="line">                return bitmap.getRowBytes() * bitmap.getHeight() / ONE_KB;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void put(BitmapRequest key, Bitmap value) &#123;</div><div class="line">        mImageCache.put(key, value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Bitmap get(BitmapRequest key) &#123;</div><div class="line">        return mImageCache.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void remove(BitmapRequest key) &#123;</div><div class="line">        mImageCache.remove(key);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="DiskCache-java"><a href="#DiskCache-java" class="headerlink" title="DiskCache.java"></a>DiskCache.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div></pre></td><td class="code"><pre><div class="line">public class DiskCache implements IBitmapCache &#123;</div><div class="line">    // 1 MB</div><div class="line">    private static final int MB = 1024 * 1024;</div><div class="line">    // cache dir</div><div class="line">    private static final String IMAGE_DISK_CACHE = &quot;bitmap&quot;;</div><div class="line">    // Disk LRU Cache</div><div class="line">    private DiskLruCache mDiskLruCache;</div><div class="line">    // Disk Cache Instance</div><div class="line">    private static DiskCache mDiskCache;</div><div class="line"></div><div class="line">    private String mCachePath;</div><div class="line"></div><div class="line">    private DiskCache(Context context) &#123;</div><div class="line">        initDiskCache(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initDiskCache(Context context) &#123;</div><div class="line">        try &#123;</div><div class="line">            File cacheDir = getDiskCacheDir(context, IMAGE_DISK_CACHE);</div><div class="line">            if (!cacheDir.exists()) &#123;</div><div class="line">                cacheDir.mkdirs();</div><div class="line">            &#125;</div><div class="line">            mDiskLruCache = DiskLruCache</div><div class="line">                    .open(cacheDir, getAppVersion(context), 1, 50 * MB);</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 单例</div><div class="line">    public static DiskCache getDiskCache(Context context) &#123;</div><div class="line">        if (mDiskCache == null) &#123;</div><div class="line">            synchronized (DiskCache.class) &#123;</div><div class="line">                if (mDiskCache == null) &#123;</div><div class="line">                    mDiskCache = new DiskCache(context);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return mDiskCache;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public synchronized Bitmap get(final BitmapRequest request) &#123;</div><div class="line">        // 图片解析器</div><div class="line">        BitmapDecoder decoder = new BitmapDecoder() &#123;</div><div class="line">            @Override</div><div class="line">            public Bitmap decodeBitmapWithOption(BitmapFactory.Options options) &#123;</div><div class="line">                final InputStream inputStream = getInputStream(Md5Helper.toMD5(request.imageUri));</div><div class="line">                Bitmap bitmap = BitmapFactory.decodeStream(inputStream, null, options);</div><div class="line">                IOUtil.closeQuietly(inputStream);</div><div class="line">                return bitmap;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        return decoder.decodeBitmap(request.getImageViewWidth(),</div><div class="line">                request.getImageViewHeight());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 将图片缓存到磁盘中</div><div class="line">    @Override</div><div class="line">    public void put(BitmapRequest request, Bitmap value) &#123;</div><div class="line">        DiskLruCache.Editor editor;</div><div class="line">        try &#123;</div><div class="line">            // 如果没有找到对应的缓存，则准备从网络上请求数据，并写入缓存</div><div class="line">            editor = mDiskLruCache.edit(Md5Helper.toMD5(request.imageUri));</div><div class="line">            if (editor != null) &#123;</div><div class="line">                OutputStream outputStream = editor.newOutputStream(0);</div><div class="line">                if (writeBitmapToDisk(value, outputStream)) &#123;</div><div class="line">                    // 写入disk缓存</div><div class="line">                    editor.commit();</div><div class="line">                &#125; else &#123;</div><div class="line">                    editor.abort();</div><div class="line">                &#125;</div><div class="line">                IOUtil.closeQuietly(outputStream);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void remove(BitmapRequest key) &#123;</div><div class="line">        try &#123;</div><div class="line">            mDiskLruCache.remove(Md5Helper.toMD5(key.imageUri));</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private InputStream getInputStream(String md5) &#123;</div><div class="line">        Snapshot snapshot;</div><div class="line">        try &#123;</div><div class="line">            snapshot = mDiskLruCache.get(md5);</div><div class="line">            if (snapshot != null) &#123;</div><div class="line">                return snapshot.getInputStream(0);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private File getDiskCacheDir(Context context, String name) &#123;</div><div class="line">        if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) &#123;</div><div class="line">            Log.d(&quot;&quot;, &quot;### context : &quot; + context + &quot;, dir = &quot; + context.getExternalCacheDir());</div><div class="line">            mCachePath = context.getExternalCacheDir().getPath();</div><div class="line">        &#125; else &#123;</div><div class="line">            mCachePath = context.getCacheDir().getPath();</div><div class="line">        &#125;</div><div class="line">        return new File(mCachePath + File.separator + name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private boolean writeBitmapToDisk(Bitmap bitmap, OutputStream outputStream) &#123;</div><div class="line">        BufferedOutputStream bos = new BufferedOutputStream(outputStream, 8 * 1024);</div><div class="line">        bitmap.compress(Bitmap.CompressFormat.JPEG, 100, bos);</div><div class="line">        boolean result = true;</div><div class="line">        try &#123;</div><div class="line">            bos.flush();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            result = false;</div><div class="line">        &#125; finally &#123;</div><div class="line">            IOUtil.closeQuietly(bos);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private int getAppVersion(Context context) &#123;</div><div class="line">        try &#123;</div><div class="line">            PackageInfo info = context.getPackageManager().getPackageInfo(context.getPackageName(),</div><div class="line">                    0);</div><div class="line">            return info.versionCode;</div><div class="line">        &#125; catch (NameNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="DoubleCache-java"><a href="#DoubleCache-java" class="headerlink" title="DoubleCache.java"></a>DoubleCache.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class DoubleCache implements IBitmapCache &#123;</div><div class="line">    private MemoryCache mMemoryCache = new MemoryCache();</div><div class="line">    private DiskCache mDiskCache;</div><div class="line"></div><div class="line">    public DoubleCache(Context context) &#123;</div><div class="line">        mDiskCache = DiskCache.getDiskCache(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Bitmap get(BitmapRequest key) &#123;</div><div class="line">        Bitmap value = mMemoryCache.get(key);</div><div class="line">        if (value == null) &#123;</div><div class="line">            value = mDiskCache.get(key);</div><div class="line">            // 存到内存缓存中</div><div class="line">            saveBitmapIntoMemory(key, value);</div><div class="line">        &#125;</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void put(BitmapRequest key, Bitmap bitmap) &#123;</div><div class="line">        mMemoryCache.put(key, bitmap);</div><div class="line">        mDiskCache.put(key, bitmap);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void remove(BitmapRequest key) &#123;</div><div class="line">        mMemoryCache.remove(key);</div><div class="line">        mDiskCache.remove(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void saveBitmapIntoMemory(BitmapRequest key, Bitmap bitmap) &#123;</div><div class="line">        // 如果 Value 从 disk 中读取，那么存入内存缓存</div><div class="line">        if (bitmap != null) &#123;</div><div class="line">            mMemoryCache.put(key, bitmap);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="NoCache-java"><a href="#NoCache-java" class="headerlink" title="NoCache.java"></a>NoCache.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class NoCache implements IBitmapCache &#123;</div><div class="line">    @Override</div><div class="line">    public Bitmap get(BitmapRequest key) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void put(BitmapRequest key, Bitmap value) &#123;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void remove(BitmapRequest key) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h3><hr><h4 id="ILoader-java"><a href="#ILoader-java" class="headerlink" title="ILoader.java"></a>ILoader.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface ILoader &#123;</div><div class="line">    void loadImage(BitmapRequest request);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="AbsLoader-java"><a href="#AbsLoader-java" class="headerlink" title="AbsLoader.java"></a>AbsLoader.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public abstract class AbsLoader implements ILoader &#123;</div><div class="line">    // 图片缓存</div><div class="line">    private IBitmapCache mCache;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void loadImage(BitmapRequest request) &#123;</div><div class="line">        if (null == request || null == request.getImageView()</div><div class="line">                || TextUtils.isEmpty(request.imageUri)) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mCache = ImageLoader.getInstance().getCache();</div><div class="line">        // 先从内存中读取</div><div class="line">        Bitmap bitmap = mCache.get(request);</div><div class="line">        // 没有就去加载网络图片</div><div class="line">        if (null == bitmap) &#123;</div><div class="line">            bitmap = onLoadImage(request);</div><div class="line">            cacheBitmap(request, bitmap);</div><div class="line">        &#125;</div><div class="line">        // 通知界面更新</div><div class="line">        deliveryToUIThread(request, bitmap);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected abstract Bitmap onLoadImage(BitmapRequest result);</div><div class="line"></div><div class="line">    private void cacheBitmap(BitmapRequest request, Bitmap bitmap) &#123;</div><div class="line">        // 缓存新的图片</div><div class="line">        if (bitmap != null &amp;&amp; mCache != null) &#123;</div><div class="line">            synchronized (mCache) &#123;</div><div class="line">                mCache.put(request, bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 更新视图控件，显示图片</div><div class="line">     * @param request   ImageView</div><div class="line">     * @param bitmap    Bitmap</div><div class="line">     */</div><div class="line">    private void deliveryToUIThread(final BitmapRequest request, final Bitmap bitmap) &#123;</div><div class="line">        final ImageView imageView = request.getImageView();</div><div class="line">        if (null != imageView) &#123;</div><div class="line">            imageView.post(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    updateImageView(request, bitmap);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 更新ImageView</div><div class="line">     */</div><div class="line">    private void updateImageView(BitmapRequest request, Bitmap result) &#123;</div><div class="line">        ImageView imageView = request.getImageView();</div><div class="line">        if (result != null &amp;&amp; request.isImageViewTagValid()) &#123;</div><div class="line">            imageView.setImageBitmap(result);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="LocalLoader-java"><a href="#LocalLoader-java" class="headerlink" title="LocalLoader.java"></a>LocalLoader.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class LocalLoader extends AbsLoader &#123;</div><div class="line">    @Override</div><div class="line">    public Bitmap onLoadImage(BitmapRequest request) &#123;</div><div class="line">        final String imagePath = Uri.parse(request.imageUri).getPath();</div><div class="line">        final File imgFile = new File(imagePath);</div><div class="line">        if (!imgFile.exists()) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 加载图片</div><div class="line">        BitmapDecoder decoder = new BitmapDecoder() &#123;</div><div class="line">            @Override</div><div class="line">            public Bitmap decodeBitmapWithOption(Options options) &#123;</div><div class="line">                return BitmapFactory.decodeFile(imagePath, options);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        return decoder.decodeBitmap(request.getImageViewWidth(),</div><div class="line">                request.getImageViewHeight());</div><div class="line">        // return BitmapFactory.decodeFile(imagePath);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="UrlLoader-java"><a href="#UrlLoader-java" class="headerlink" title="UrlLoader.java"></a>UrlLoader.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class UrlLoader extends AbsLoader &#123;</div><div class="line">    @Override</div><div class="line">    protected Bitmap onLoadImage(BitmapRequest request) &#123;</div><div class="line">        if (null == request || TextUtils.isEmpty(request.imageUri)) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Bitmap bitmap = null;</div><div class="line">        try &#123;</div><div class="line">            URL url = new URL(request.imageUri);</div><div class="line">            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="NullLoader-java"><a href="#NullLoader-java" class="headerlink" title="NullLoader.java"></a>NullLoader.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class NullLoader extends AbsLoader &#123;</div><div class="line">    @Override</div><div class="line">    public Bitmap onLoadImage(BitmapRequest requestBean) &#123;</div><div class="line">        Log.e(NullLoader.class.getSimpleName(), &quot;### wrong schema, &quot; +</div><div class="line">                &quot;your image uri is : &quot; + requestBean.imageUri);</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="LoaderManager-java"><a href="#LoaderManager-java" class="headerlink" title="LoaderManager.java"></a>LoaderManager.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class LoaderManager &#123;</div><div class="line">    private Map&lt;Scheme, ILoader&gt; mLoaderMap = new HashMap&lt;&gt;();</div><div class="line">    private ILoader mNullLoader = new NullLoader();</div><div class="line"></div><div class="line">    private static LoaderManager INSTANCE;</div><div class="line">    private LoaderManager() &#123;</div><div class="line">        register(Scheme.HTTP, new UrlLoader());</div><div class="line">        register(Scheme.HTTPS, new UrlLoader());</div><div class="line">        register(Scheme.FILE, new LocalLoader());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static LoaderManager getInstance() &#123;</div><div class="line">        if (INSTANCE == null) &#123;</div><div class="line">            synchronized (LoaderManager.class) &#123;</div><div class="line">                if (INSTANCE == null) &#123;</div><div class="line">                    INSTANCE = new LoaderManager();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 注册 Loader</div><div class="line">    public final synchronized void register(Scheme schema, ILoader loader) &#123;</div><div class="line">        mLoaderMap.put(schema, loader);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 根据 schema 获取对应的 Loader</div><div class="line">    public ILoader getLoader(Scheme schema) &#123;</div><div class="line">        if (mLoaderMap.containsKey(schema)) &#123;</div><div class="line">            return mLoaderMap.get(schema);</div><div class="line">        &#125;</div><div class="line">        return mNullLoader;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Policy"><a href="#Policy" class="headerlink" title="Policy"></a>Policy</h3><hr><h4 id="LoadPolicy-java"><a href="#LoadPolicy-java" class="headerlink" title="LoadPolicy.java"></a>LoadPolicy.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface LoadPolicy &#123;</div><div class="line">    int compare(BitmapRequest request1, BitmapRequest request2);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="SerialPolicy-java"><a href="#SerialPolicy-java" class="headerlink" title="SerialPolicy.java"></a>SerialPolicy.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class SerialPolicy implements LoadPolicy &#123;</div><div class="line">    @Override</div><div class="line">    public int compare(BitmapRequest request1, BitmapRequest request2) &#123;</div><div class="line">        return request1.serialNum - request2.serialNum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="ReversePolicy-java"><a href="#ReversePolicy-java" class="headerlink" title="ReversePolicy.java"></a>ReversePolicy.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class ReversePolicy implements LoadPolicy &#123;</div><div class="line">    @Override</div><div class="line">    public int compare(BitmapRequest request1, BitmapRequest request2) &#123;</div><div class="line">        return request2.serialNum - request1.serialNum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><hr><h4 id="BitmapDecoder-java"><a href="#BitmapDecoder-java" class="headerlink" title="BitmapDecoder.java"></a>BitmapDecoder.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">// 封装先加载图片 bound，计算出 inSmallSize 之后再加载图片的逻辑操作</div><div class="line">public abstract class BitmapDecoder &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param options 配置</div><div class="line">     * @return Bitmap</div><div class="line">     */</div><div class="line">    public abstract Bitmap decodeBitmapWithOption(Options options);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param width 图片的目标宽度</div><div class="line">     * @param height 图片的目标高度</div><div class="line">     * @return Bitmap</div><div class="line">     */</div><div class="line">    public final Bitmap decodeBitmap(int width, int height) &#123;</div><div class="line">        // 如果请求原图,则直接加载原图</div><div class="line">        if (width &lt;= 0 || height &lt;= 0) &#123;</div><div class="line">            return decodeBitmapWithOption(null);</div><div class="line">        &#125;</div><div class="line">        // 1、获取只加载Bitmap宽高等数据的Option, 即设置options.inJustDecodeBounds = true;</div><div class="line">        BitmapFactory.Options options = new BitmapFactory.Options();</div><div class="line">        // 设置为true,表示解析Bitmap对象，该对象不占内存</div><div class="line">        options.inJustDecodeBounds = true;</div><div class="line">        // 2、通过options加载bitmap，此时返回的bitmap为空,数据将存储在options中</div><div class="line">        decodeBitmapWithOption(options);</div><div class="line">        // 3、计算缩放比例, 并且将options.inJustDecodeBounds设置为false;</div><div class="line">        configBitmapOptions(options, width, height);</div><div class="line">        // 4、通过options设置的缩放比例加载图片</div><div class="line">        return decodeBitmapWithOption(options);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 加载原图</div><div class="line">    public Bitmap decodeOriginBitmap() &#123;</div><div class="line">        return decodeBitmapWithOption(null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void configBitmapOptions(Options options, int width, int height) &#123;</div><div class="line">        // 设置缩放比例</div><div class="line">        options.inSampleSize = computeInSmallSize(options, width, height);</div><div class="line"></div><div class="line">        Log.d(&quot;&quot;, &quot;$## inSampleSize = &quot; + options.inSampleSize</div><div class="line">                + &quot;, width = &quot; + width + &quot;, height= &quot; + height);</div><div class="line">        // 图片质量</div><div class="line">        options.inPreferredConfig = Config.RGB_565;</div><div class="line">        // 设置为false,解析Bitmap对象加入到内存中</div><div class="line">        options.inJustDecodeBounds = false;</div><div class="line">        options.inPurgeable = true;</div><div class="line">        options.inInputShareable = true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private int computeInSmallSize(BitmapFactory.Options options, int reqWidth, int reqHeight) &#123;</div><div class="line">        final int height = options.outHeight;</div><div class="line">        final int width = options.outWidth;</div><div class="line">        int inSampleSize = 1;</div><div class="line"></div><div class="line">        if (height &gt; reqHeight || width &gt; reqWidth) &#123;</div><div class="line">            final int heightRatio = Math.round((float) height / (float) reqHeight);</div><div class="line">            final int widthRatio = Math.round((float) width / (float) reqWidth);</div><div class="line">            inSampleSize = heightRatio &lt; widthRatio ? heightRatio : widthRatio;</div><div class="line">            final float totalPixels = width * height;</div><div class="line">            final float totalReqPixelsCap = reqWidth * reqHeight * 2;</div><div class="line"></div><div class="line">            while (totalPixels / (inSampleSize * inSampleSize) &gt; totalReqPixelsCap) &#123;</div><div class="line">                inSampleSize++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return inSampleSize;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="Scheme-java"><a href="#Scheme-java" class="headerlink" title="Scheme.java"></a>Scheme.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public enum Scheme &#123;</div><div class="line">    HTTP(&quot;http&quot;), HTTPS(&quot;https&quot;), FILE(&quot;file&quot;), CONTENT(&quot;content&quot;),</div><div class="line">    ASSETS(&quot;assets&quot;), DRAWABLE(&quot;drawable&quot;), UNKNOWN(&quot;&quot;);</div><div class="line"></div><div class="line">    private String scheme;</div><div class="line">    private String uriPrefix;</div><div class="line"></div><div class="line">    Scheme(String scheme) &#123;</div><div class="line">        this.scheme = scheme;</div><div class="line">        uriPrefix = scheme + &quot;://&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Scheme ofUri(String uri) &#123;</div><div class="line">        if (uri != null) &#123;</div><div class="line">            for (Scheme s : values()) &#123;</div><div class="line">                if (s.belongsTo(uri)) &#123;</div><div class="line">                    return s;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return UNKNOWN;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private boolean belongsTo(String uri) &#123;</div><div class="line">        return uri.toLowerCase(Locale.US).startsWith(uriPrefix);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String wrap(String path) &#123;</div><div class="line">        return uriPrefix + path;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String crop(String uri) &#123;</div><div class="line">        if (!belongsTo(uri)) &#123;</div><div class="line">            throw new IllegalArgumentException(String.format(&quot;URI [%1$s] &quot; +</div><div class="line">                    &quot;doesn&apos;t have expected scheme [%2$s]&quot;, uri, scheme));</div><div class="line">        &#125;</div><div class="line">        return uri.substring(uriPrefix.length());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Config-1"><a href="#Config-1" class="headerlink" title="Config"></a>Config</h3><hr><h4 id="ImageLoaderConfig-java"><a href="#ImageLoaderConfig-java" class="headerlink" title="ImageLoaderConfig.java"></a>ImageLoaderConfig.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">public class ImageLoaderConfig &#123;</div><div class="line">    // 图片缓存配置对象</div><div class="line">    IBitmapCache mCache = new MemoryCache();</div><div class="line">    // 图片加载中显示的图片 id</div><div class="line">    int loadingImageId;</div><div class="line">    // 加载失败时显示的图片 id</div><div class="line">    int loadFailedImageId;</div><div class="line">    // 图片加载策略</div><div class="line">    LoadPolicy loadPolicy;</div><div class="line">    // 线程数量，默认为 CPU 数量 + 1</div><div class="line">    int threadCount = Runtime.getRuntime().availableProcessors() + 1;</div><div class="line"></div><div class="line">    private ImageLoaderConfig() &#123;&#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 配置类的 Builder</div><div class="line">     */</div><div class="line">    public static class Builder &#123;</div><div class="line">        // 图片缓存配置对象</div><div class="line">        IBitmapCache mCache = new MemoryCache();</div><div class="line">        // 图片加载中显示的图片 id</div><div class="line">        int loadingImageId;</div><div class="line">        // 加载失败时显示的图片 id</div><div class="line">        int loadFailedImageId;</div><div class="line">        // 图片加载策略</div><div class="line">        LoadPolicy loadPolicy;</div><div class="line">        // 线程数量，默认为 CPU 数量 + 1</div><div class="line">        int threadCount = Runtime.getRuntime().availableProcessors() + 1;</div><div class="line"></div><div class="line">        // 设置缓存</div><div class="line">        public Builder setCache(IBitmapCache cache) &#123;</div><div class="line">            this.mCache = cache;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        // 设置正在加载中显示的图片</div><div class="line">        public Builder setLoadingImageId(int loadingImageId) &#123;</div><div class="line">            this.loadingImageId = loadingImageId;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        // 设置要加载的图片失败时显示的图片</div><div class="line">        public Builder setLoadFailedImageId(int loadingFailedImageId) &#123;</div><div class="line">            this.loadFailedImageId = loadingFailedImageId;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        // 设置加载策略</div><div class="line">        public Builder setLoadPolicy(LoadPolicy loadPolicy) &#123;</div><div class="line">            this.loadPolicy = loadPolicy;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        // 设置线程数量</div><div class="line">        public Builder setThreadCount(int threadCount) &#123;</div><div class="line">            this.threadCount = threadCount;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        void applyConfig(ImageLoaderConfig config) &#123;</div><div class="line">            config.mCache = this.mCache;</div><div class="line">            config.loadingImageId = this.loadingImageId;</div><div class="line">            config.loadFailedImageId = this.loadFailedImageId;</div><div class="line">            config.loadPolicy = this.loadPolicy;</div><div class="line">            config.threadCount = this.threadCount;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public ImageLoaderConfig create() &#123;</div><div class="line">            ImageLoaderConfig config = new ImageLoaderConfig();</div><div class="line">            applyConfig(config);</div><div class="line">            return config;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Utils"><a href="#Utils" class="headerlink" title="Utils"></a>Utils</h3><hr><h4 id="BitmapDecoder-java-1"><a href="#BitmapDecoder-java-1" class="headerlink" title="BitmapDecoder.java"></a>BitmapDecoder.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 封装先加载图片 bound，计算出 inSmallSize 之后再加载图片的逻辑操作</div><div class="line"> */</div><div class="line">public abstract class BitmapDecoder &#123;</div><div class="line">    public abstract Bitmap decodeBitmapWithOption(Options options);</div><div class="line">    public final Bitmap decodeBitmap(int width, int height) &#123;</div><div class="line">        // 如果请求原图,则直接加载原图</div><div class="line">        if (width &lt;= 0 || height &lt;= 0) &#123;</div><div class="line">            return decodeBitmapWithOption(null);</div><div class="line">        &#125;</div><div class="line">        // 1、获取只加载Bitmap宽高等数据的Option, 即设置options.inJustDecodeBounds = true;</div><div class="line">        BitmapFactory.Options options = new BitmapFactory.Options();</div><div class="line">        // 设置为true,表示解析Bitmap对象，该对象不占内存</div><div class="line">        options.inJustDecodeBounds = true;</div><div class="line">        // 2、通过options加载bitmap，此时返回的bitmap为空,数据将存储在options中</div><div class="line">        decodeBitmapWithOption(options);</div><div class="line">        // 3、计算缩放比例, 并且将options.inJustDecodeBounds设置为false;</div><div class="line">        configBitmapOptions(options, width, height);</div><div class="line">        // 4、通过options设置的缩放比例加载图片</div><div class="line">        return decodeBitmapWithOption(options);</div><div class="line">    &#125;</div><div class="line">    // 加载原图</div><div class="line">    public Bitmap decodeOriginBitmap() &#123;</div><div class="line">        return decodeBitmapWithOption(null);</div><div class="line">    &#125;</div><div class="line">    protected void configBitmapOptions(Options options, int width, int height) &#123;</div><div class="line">        // 设置缩放比例</div><div class="line">        options.inSampleSize = computeInSmallSize(options, width, height);</div><div class="line">        Log.d(&quot;&quot;, &quot;$## inSampleSize = &quot; + options.inSampleSize</div><div class="line">                + &quot;, width = &quot; + width + &quot;, height= &quot; + height);</div><div class="line">        // 图片质量</div><div class="line">        options.inPreferredConfig = Config.RGB_565;</div><div class="line">        // 设置为false,解析Bitmap对象加入到内存中</div><div class="line">        options.inJustDecodeBounds = false;</div><div class="line">        options.inPurgeable = true;</div><div class="line">        options.inInputShareable = true;</div><div class="line">    &#125;</div><div class="line">    private int computeInSmallSize(BitmapFactory.Options options, int reqWidth, int reqHeight) &#123;</div><div class="line">        final int height = options.outHeight;</div><div class="line">        final int width = options.outWidth;</div><div class="line">        int inSampleSize = 1;</div><div class="line">        if (height &gt; reqHeight || width &gt; reqWidth) &#123;</div><div class="line">            // Calculate ratios of height and width to requested height and</div><div class="line">            // width</div><div class="line">            final int heightRatio = Math.round((float) height / (float) reqHeight);</div><div class="line">            final int widthRatio = Math.round((float) width / (float) reqWidth);</div><div class="line">            inSampleSize = heightRatio &lt; widthRatio ? heightRatio : widthRatio;</div><div class="line">            final float totalPixels = width * height;</div><div class="line">            final float totalReqPixelsCap = reqWidth * reqHeight * 2;</div><div class="line">            while (totalPixels / (inSampleSize * inSampleSize) &gt; totalReqPixelsCap) &#123;</div><div class="line">                inSampleSize++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return inSampleSize;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="ImageViewHelper-java"><a href="#ImageViewHelper-java" class="headerlink" title="ImageViewHelper.java"></a>ImageViewHelper.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">public class ImageViewHelper &#123;</div><div class="line">    // todo : 配置类中</div><div class="line">    private static int DEFAULT_WIDTH = 200;</div><div class="line">    private static int DEFAULT_HEIGHT = 200;</div><div class="line"></div><div class="line">    public static int getImageViewWidth(ImageView imageView) &#123;</div><div class="line">        if (imageView != null) &#123;</div><div class="line">            final ViewGroup.LayoutParams params = imageView.getLayoutParams();</div><div class="line">            int width = 0;</div><div class="line">            if (params != null &amp;&amp; params.width != ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">                width = imageView.getWidth(); // Get actual image width</div><div class="line">            &#125;</div><div class="line">            if (width &lt;= 0 &amp;&amp; params != null) &#123;</div><div class="line">                width = params.width; // Get layout width parameter</div><div class="line">            &#125;</div><div class="line">            if (width &lt;= 0) &#123;</div><div class="line">                width = getImageViewFieldValue(imageView, &quot;mMaxWidth&quot;);</div><div class="line">            &#125;</div><div class="line">            return width;</div><div class="line">        &#125;</div><div class="line">        return DEFAULT_WIDTH;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static int getImageViewHeight(ImageView imageView) &#123;</div><div class="line">        if (imageView != null) &#123;</div><div class="line">            final ViewGroup.LayoutParams params = imageView.getLayoutParams();</div><div class="line">            int height = 0;</div><div class="line">            if (params != null</div><div class="line">                    &amp;&amp; params.height != ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">                height = imageView.getHeight(); // Get actual image height</div><div class="line">            &#125;</div><div class="line">            if (height &lt;= 0 &amp;&amp; params != null) &#123;</div><div class="line">                // Get layout height parameter</div><div class="line">                height = params.height;</div><div class="line">            &#125;</div><div class="line">            if (height &lt;= 0) &#123;</div><div class="line">                height = getImageViewFieldValue(imageView, &quot;mMaxHeight&quot;);</div><div class="line">            &#125;</div><div class="line">            return height;</div><div class="line">        &#125;</div><div class="line">        return DEFAULT_HEIGHT;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static int getImageViewFieldValue(Object object, String fieldName) &#123;</div><div class="line">        int value = 0;</div><div class="line">        try &#123;</div><div class="line">            Field field = ImageView.class.getDeclaredField(fieldName);</div><div class="line">            field.setAccessible(true);</div><div class="line">            int fieldValue = (Integer) field.get(object);</div><div class="line">            if (fieldValue &gt; 0 &amp;&amp; fieldValue &lt; Integer.MAX_VALUE) &#123;</div><div class="line">                value = fieldValue;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            Log.e(&quot;&quot;, e.getMessage());</div><div class="line">        &#125;</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="Md5Helper-java"><a href="#Md5Helper-java" class="headerlink" title="Md5Helper.java"></a>Md5Helper.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class Md5Helper &#123;</div><div class="line">    private static MessageDigest mDigest = null;</div><div class="line"></div><div class="line">    static&#123;</div><div class="line">        try &#123;</div><div class="line">            mDigest = MessageDigest.getInstance(&quot;MD5&quot;);</div><div class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 对 key 进行 MD5 加密，如果无 MD5 加密算法，</div><div class="line">    // 则直接使用key对应的hash值。</div><div class="line">    public static String toMD5(String key) &#123;</div><div class="line">        String cacheKey;</div><div class="line">        //获取MD5算法失败时，直接使用key对应的hash值</div><div class="line">        if ( mDigest == null ) &#123;</div><div class="line">            return String.valueOf(key.hashCode());</div><div class="line">        &#125;</div><div class="line">        mDigest.update(key.getBytes());</div><div class="line">        cacheKey = bytesToHexString(mDigest.digest());</div><div class="line">        return cacheKey;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static String bytesToHexString(byte[] bytes) &#123;</div><div class="line">        StringBuilder sb = new StringBuilder();</div><div class="line">        for (int i = 0; i &lt; bytes.length; i++) &#123;</div><div class="line">            String hex = Integer.toHexString(0xFF &amp; bytes[i]);</div><div class="line">            if (hex.length() == 1) &#123;</div><div class="line">                sb.append(&apos;0&apos;);</div><div class="line">            &#125;</div><div class="line">            sb.append(hex);</div><div class="line">        &#125;</div><div class="line">        return sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="IOUtil-java"><a href="#IOUtil-java" class="headerlink" title="IOUtil.java"></a>IOUtil.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class IOUtil &#123;</div><div class="line"></div><div class="line">    private IOUtil() &#123;&#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 关闭IO</div><div class="line">     * @param closeables closeables</div><div class="line">     */</div><div class="line">    public static void close(Closeable... closeables) &#123;</div><div class="line">        if (closeables == null) return;</div><div class="line">        for (Closeable closeable : closeables) &#123;</div><div class="line">            if (closeable != null) &#123;</div><div class="line">                try &#123;</div><div class="line">                    closeable.close();</div><div class="line">                &#125; catch (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 关闭IO，不输出日志</div><div class="line">     * @param closeables closeables</div><div class="line">     */</div><div class="line">    public static void closeQuietly(Closeable... closeables) &#123;</div><div class="line">        if (closeables == null) return;</div><div class="line">        for (Closeable closeable : closeables) &#123;</div><div class="line">            if (closeable != null) &#123;</div><div class="line">                try &#123; closeable.close(); &#125; catch (IOException e) &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14186083-eb877e4ad16b34bb.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05 ImageLoader 常见问题</title>
      <link href="/1902/01/05/06%20THIRD%20PARY%20FRAMEWORK/05%20ImageLoader%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/1902/01/05/06%20THIRD%20PARY%20FRAMEWORK/05%20ImageLoader%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-28769b509abbb24a?imageMogr2/auto-orient/strip" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1902/01/01/03IMAGE%20LOADER/01%20ImageLoader%20基础框架/" target="_blank" rel="external">01 基础框架</a><br><a href="https://xianxiaotao.github.io/1902/01/02/03IMAGE%20LOADER/02%20ImageLoader%20请求队列/" target="_blank" rel="external">02 请求队列</a><br><a href="https://xianxiaotao.github.io/1902/01/03/03IMAGE%20LOADER/03%20ImageLoader%20三级缓存/" target="_blank" rel="external">03 三级缓存</a><br><a href="https://xianxiaotao.github.io/1902/01/04/03IMAGE%20LOADER/04%20ImageLoader%20图片加载/" target="_blank" rel="external">04 图片加载</a><br><a href="https://xianxiaotao.github.io/1902/01/05/03IMAGE%20LOADER/05%20ImageLoader%20常见问题/" target="_blank" rel="external">05 常见问题</a><br><a href="https://xianxiaotao.github.io/1902/01/06/03IMAGE%20LOADER/06%20ImageLoader%20项目源码/" target="_blank" rel="external">06 项目源码</a></p></blockquote><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。</p><p>内存泄漏是造成应用程序 OOM 的主要原因之一。我们知道 Android 系统为每个应用程序分配的内存是有限的，而当一个应用中产生的内存泄漏比较多时，这就难免会导致应用所需要的内存超过系统分配的内存限额，这就造成了内存溢出从而导致应用 Crash。</p><p>由于单例的静态特性使得其生命周期和应用的生命周期一样长，如果一个对象已经不再需要使用了，而单例对象还持有该对象的引用，就会使得该对象不能被正常回收，从而导致了内存泄漏。我们的 ImageLoader 中就有几个单例对象，如 ImageLoader、LoaderManager，此时我们就要注意内存泄漏的可能性。</p><p>在 ImageLoader 中，持有的对象有 IBitmapCache、RequestQueue、ImageLoaderConfig，从业务上来讲它们的生命周期都是与 ImageLoader 一致的，不满足内存泄漏的定义，但这不代表不存在内存泄漏的可能。我们不但要检查直接的引用关系，还要检查引用链，即引用的引用所持有的对象引用。ImageLoader 持有的三个引用所指向的引用都直接或间接持有了 BitmapRequest，而 BitmapRequest 又持有了 ImageView 对象。也就是说当请求队列还在异步加载图片时，我们即使退出某个界面，但依然持有了（可能是大量的）ImageView 的对象引用，即发生了内存泄漏。</p><p>所以我们不能持有 ImageView 的强引用（StrongReference），它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误。使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收；只有在内存空间不足时，软引用才会被垃圾回收器回收。而具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列关联使用。</p><p>此处，我们选择使用弱引用，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class BitmapRequest implements Comparable&lt;BitmapRequest&gt; &#123;</div><div class="line">    // public ImageView imageView;</div><div class="line">    private Reference&lt;ImageView&gt; mImageViewRef;</div><div class="line"></div><div class="line">    public BitmapRequest(ImageView imageView, String uri) &#123;</div><div class="line">        this.mImageViewRef = new WeakReference&lt;&gt;(imageView);</div><div class="line">        this.imageUri = uri;</div><div class="line">        imageView.setTag(uri);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ImageView getImageView() &#123;</div><div class="line">        return mImageViewRef.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 代码省略...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其他类中 request.imageView 代码都要改成 request.getImageView()。</p><p>通过检查代码来找出内存泄漏的原因，是有一定的难度的，而且很是繁琐。我们可以使用 <a href="https://github.com/square/leakcanary" target="_blank" rel="external">Android LeakCanary</a> 工具，自动检测出内存泄漏。</p><p>直接集成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    debugImplementation &apos;com.squareup.leakcanary:leakcanary-android:1.6.3&apos;</div><div class="line">    releaseImplementation &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.6.3&apos;</div><div class="line">    // Optional, if you use support library fragments:</div><div class="line">    debugImplementation &apos;com.squareup.leakcanary:leakcanary-support-fragment:1.6.3&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>直接在Application中使用，然后运行APP就会自动检测，检测到会在另一个APP上通知，显示详情。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class TestApplication extends Application &#123;</div><div class="line">    @Override </div><div class="line">    public void onCreate() &#123;</div><div class="line">        super.onCreate();</div><div class="line">        if (LeakCanary.isInAnalyzerProcess(this)) &#123;</div><div class="line">            // This process is dedicated to LeakCanary for heap analysis.</div><div class="line">            // You should not init your app in this process.</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        LeakCanary.install(this);</div><div class="line">        // Normal app init code...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后在 AndroidManifest.xml 中配置自定义的 Application。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;application</div><div class="line">    android:name=&quot;.TestApplication&quot;</div><div class="line">    android:allowBackup=&quot;true&quot;</div><div class="line">    android:icon=&quot;@mipmap/ic_launcher&quot;</div><div class="line">    android:label=&quot;@string/app_name&quot;</div><div class="line">    android:roundIcon=&quot;@mipmap/ic_launcher&quot;</div><div class="line">    android:supportsRtl=&quot;true&quot;</div><div class="line">    android:theme=&quot;@style/AppTheme&quot;&gt;</div></pre></td></tr></table></figure></p><p>我们在 RequestDispatcher 的 run 方法中加入 Thread.sleep(100000); 然后退出当前界面。此时 LeakCanary 检测到内存泄漏，如下图所示。 </p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0a7a544ecd1ddef1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>我们在 Demo 中使用 ImageLoader 加载大量图片时，发生 OOM 异常。如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-6bde0d69c14b711d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在 Demo 中，使用了双缓存技术。由于内存不够，就去从 SD 卡中加载图片，而 DiskCache 中获取本地图片时没有使用图片解码器，这就容易导致加载一张大图就会发生 OOM 异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class DiskCache implements IBitmapCache &#123;</div><div class="line">    // 从 SD 卡缓存中获取图片</div><div class="line">    @Override</div><div class="line">    public Bitmap get(BitmapRequest request) &#123;</div><div class="line">        final InputStream inputStream = getInputStream(Md5Helper.toMD5(request.imageUri));</div><div class="line">        return BitmapFactory.decodeStream(inputStream);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用图片解码器修改上述代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public synchronized Bitmap get(final BitmapRequest request) &#123;</div><div class="line">    // 图片解析器</div><div class="line">    BitmapDecoder decoder = new BitmapDecoder() &#123;</div><div class="line">        @Override</div><div class="line">        public Bitmap decodeBitmapWithOption(BitmapFactory.Options options) &#123;</div><div class="line">            final InputStream inputStream = getInputStream(Md5Helper.toMD5(request.imageUri));</div><div class="line">            Bitmap bitmap = BitmapFactory.decodeStream(inputStream, null, options);</div><div class="line">            IOUtil.closeQuietly(inputStream);</div><div class="line">            return bitmap;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return decoder.decodeBitmap(request.getImageViewWidth(),</div><div class="line">            request.getImageViewHeight());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h3><hr><p>ImageLoader 系列到这里就算结束了，我们从基本架构、具体实现、设计上面详细的阐述了一个简单、可扩展性较好的 ImageLoader 实现过程。</p><p>我们一步一步地实现 ImageLoader 项目的过程中，多次出现代码重构，每次修改一处代码都会导致其他代码跟着修改。有能力有经验的架构师，几乎都是采用第一种思路，抽象出整体架构，画出架构图，如下所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-297e07ff1dc35b7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>参考上图，我们再来捋一遍整体流程。</p><p>ImageLoader 类是用户的入口，用户在通过配置类初始化ImageLoader 之后就可以向 ImageLoader 提交加载图片的请求了。ImageLoader 内部维护了一个请求队列，用户提交的加载图片的请求会在内部被封装成 BitmapRequest 对象，然后将这些对象放到请求队列中。在创建队列时会创建用户指定数量（默认为CPU个数 + 1）的线程来加载图片，这些线程在内部命名为 RequestDispatcher，它们在 run 函数中不断地获取队列中的加载请求，然后交给对应的 Loader 加载图片。</p><p>为了方便用户的扩展，我们引入了 Loader 这个抽象，因为在 ImageLoader 中只支持两种图片 uri 的加载，即网络图片 uri 和本地文件的 uri。网络图片一般以 “http://“ 或者 “https://“ 开头，而本地图片的 uri 格式却是 “file://“ 开头，ImageLoader 内部通过图片 uri 的格式的不同使用不同的 Loader 来加载图片，这样后续用户就可以注册 Loader 来实现其他格式的加载，例如 “drawable:// + 图片名” 来加载 res/drawable 中的图片等。这样保证了 ImageLoader 可加载图片 uri 格式的可扩展性。Loader 会通过 LoaderManager 来进行管理，如果需要注册自己的 Loader 实现，则调用 LoaderManager 的 register 函数即可。如果你传递进去的图片 uri 是无效，例如格式错误，那么 LoaderManager 会返回一个默认的 Loader，这个默认的 Loader 名为 NullLoader，它其实什么也不做，只是为了防止在外部进行判空而已，这种模式成为 Null Object 设计模式。当然，在加载图片之前我们会从缓存中读取，如果有缓存我们则不加载。</p><p>Loader 加载完图片之后会先更新 UI，即将图片显示到对应的 ImageView 上，在构造 BitmapRequest 时内部已经将图片的 uri 设置为 ImageView 的 tag 了。图片加载完成后判断 ImageView 的 tag 和 uri 是否相等，如果相等则将图片显示到 ImageView 上，否则不更新 ImageView。这一步很重要，很多朋友在使用 ImageLoader 时出现问题基本上就是由于没有设置 ImageView 的 tag。</p><p>加载图片的先后顺序是由加载策略决定的，策略相关的内容没有在架构图中给出。加载策略决定了请求在队列中的排序，在将请求添加到队列中时会给每个请求设置一个序号，队列将根据这个序号对请求进行排序。这样我们就可以知道哪个请求是先添加进来的，也可以很方便的实现自己的策略类来定制自己的加载策略，比如最后加载到队列中的请求最先加载。比如我们在 ListView 滚动时，最后添加到队列中的图片请求应该是我们最急需显示的，我们它们就在手机的当前屏幕，而前面的请求对应的 ImageView 已经被复用，即使它们加载完成它们也不会被显示，因为 ImageView 的 tag 已经变化了。因此，策略的灵活性依然很重要。</p><p>在加载完图片并且更新UI之后，我们会将图片缓存起来。内置的缓存类型有四种，无缓存、内存缓存、sd卡缓存、内存和sd卡的双缓存，这四种缓存都实现了 Cache 接口，如果你这四种缓存类型还不能满足你的需求，那么你可以实现 Cache 接口，然后实现自己的缓存逻辑，然后在配置 ImageLoader 时设置需要的缓存类型（具体配置后续说明），如果不配置则默认使用的是内存缓存。这里我们又看到了一个面向接口编程的例子，即 ImageLoader 只依赖于 Cache 接口的抽象，而不是说依赖于某个具体的缓存类，这样用户就可以很方面的实现自己的缓存逻辑，并且将缓存实现注入到sdk中。当然，上述的 Loader、加载策略实现也是基于同样的理论基础，就是说过很多遍的“面向接口编程”。</p><p>用户调用 displayImage 请求加载图片，ImageLoader 将这个加载图片请求封装成一个 Request，然后加入到队列中。几个色眯眯的调度子线程不断地从队列中获取请求，然后根据 uri 的格式获取到对应的 Loader 来加载图片。在加载图片之前首先会查看缓存中是否含有目标图片，如果有缓存则使用缓存，否则加载目标图片。获取到图片之后，我们会将图片投递给 ImageView 进行更新，如果该 ImageView 的 tag 与图片的 uri 是一样的，那么则更新 ImageView，否则不处理。使用 ImageView 的 tag 与图片的 uri 进行对比是为了防止图片错位显示的问题，这在 ImageLoader 中是很重要的一步。如果目标图片没有缓存，第一次从 uri 中加载后会加入缓存中，当然从 sdcard 中加载的图片我们只会缓存到内存中，而不会再缓存一份到 sd 卡的另一个目录中。这样，整个加载过程也就完成了。</p><p>参考链接：<br><a href="https://blog.csdn.net/bboyfeiyu/article/details/43195413" target="_blank" rel="external">https://blog.csdn.net/bboyfeiyu/article/details/43195413</a><br><a href="https://blog.csdn.net/bboyfeiyu/article/details/43195705" target="_blank" rel="external">https://blog.csdn.net/bboyfeiyu/article/details/43195705</a><br><a href="https://blog.csdn.net/bboyfeiyu/article/details/44155857" target="_blank" rel="external">https://blog.csdn.net/bboyfeiyu/article/details/44155857</a><br><a href="https://blog.csdn.net/bboyfeiyu/article/details/44172273" target="_blank" rel="external">https://blog.csdn.net/bboyfeiyu/article/details/44172273</a></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-9e6090118d280ec4.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04 ImageLoader 图片加载</title>
      <link href="/1902/01/04/06%20THIRD%20PARY%20FRAMEWORK/04%20ImageLoader%20%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD/"/>
      <url>/1902/01/04/06%20THIRD%20PARY%20FRAMEWORK/04%20ImageLoader%20%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-41435a76c80cf3ad.gif?imageMogr2/auto-orient/strip" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1902/01/01/03IMAGE%20LOADER/01%20ImageLoader%20基础框架/" target="_blank" rel="external">01 基础框架</a><br><a href="https://xianxiaotao.github.io/1902/01/02/03IMAGE%20LOADER/02%20ImageLoader%20请求队列/" target="_blank" rel="external">02 请求队列</a><br><a href="https://xianxiaotao.github.io/1902/01/03/03IMAGE%20LOADER/03%20ImageLoader%20三级缓存/" target="_blank" rel="external">03 三级缓存</a><br><a href="https://xianxiaotao.github.io/1902/01/04/03IMAGE%20LOADER/04%20ImageLoader%20图片加载/" target="_blank" rel="external">04 图片加载</a><br><a href="https://xianxiaotao.github.io/1902/01/05/03IMAGE%20LOADER/05%20ImageLoader%20常见问题/" target="_blank" rel="external">05 常见问题</a><br><a href="https://xianxiaotao.github.io/1902/01/06/03IMAGE%20LOADER/06%20ImageLoader%20项目源码/" target="_blank" rel="external">06 项目源码</a></p></blockquote><h3 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h3><p>上级博客的三级缓存只针对了网络图片加载的情况，如果我们要加载其他来源的图片该如何呢？比如本地图片（file://）、或者程序本身的图片（drawable://)，又或者用户需要读取指定外存的图片时该如何？所以我们加载图片的代码不能是硬编码，需要为后期扩展提供功能。要保证扩展性，就必须抽象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface ILoader &#123;</div><div class="line">    void loadImage(BitmapRequest result);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ILoader 只定义了一个接口，只用一个加载图片的方法。</p><p>我们再来看看现有的 Loader 的实现代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">public class Loader &#123;</div><div class="line">    private static Loader instance = new Loader();</div><div class="line">    private Loader() &#123;&#125;</div><div class="line">    public static Loader getInstance() &#123;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void load(BitmapRequest request) &#123;</div><div class="line">        if (null == request || null == request.imageView</div><div class="line">                || TextUtils.isEmpty(request.imageUri)) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String uri = request.imageUri;</div><div class="line">        // 先从内存中读取</div><div class="line">        Bitmap bitmap = ImageLoader.getInstance().getCache().get(request);</div><div class="line">        // 没有就去加载网络图片</div><div class="line">        if (null == bitmap) &#123;</div><div class="line">            bitmap = downloadImage(uri);</div><div class="line">            if (null != bitmap) &#123;</div><div class="line">                ImageLoader.getInstance().getCache().put(request, bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 通知界面更新</div><div class="line">        deliveryToUIThread(request, bitmap);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 加载网络图片</div><div class="line">     * @param imageUrl 图片地址</div><div class="line">     * @return Bitmap</div><div class="line">     */</div><div class="line">    private Bitmap downloadImage(String imageUrl) &#123;</div><div class="line">        if (TextUtils.isEmpty(imageUrl)) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Bitmap bitmap = null;</div><div class="line">        try &#123;</div><div class="line">            URL url = new URL(imageUrl);</div><div class="line">            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 更新视图控件，显示图片</div><div class="line">     * @param request   ImageView</div><div class="line">     * @param bitmap    Bitmap</div><div class="line">     */</div><div class="line">    private void deliveryToUIThread(final BitmapRequest request, final Bitmap bitmap) &#123;</div><div class="line">        final ImageView imageView = request.imageView;</div><div class="line">        if (null != imageView) &#123;</div><div class="line">            imageView.post(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    updateImageView(request, bitmap);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 更新ImageView</div><div class="line">    private void updateImageView(BitmapRequest request, Bitmap result) &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以见得加载图片的过程如下：</p><ol><li>判断缓存中是否含有该图片;</li><li>如果有则将图片直接投递到UI线程，并且更新UI；</li><li>如果没有缓存，则从对应的地方获取到图片，并且将图片缓存起来，然后再将结果投递给UI线程，更新UI；</li></ol><p>从本地、程序资源、assets 中加载图片的过程是怎样的呢？跟加载网络图片的过程有何区别。我们可以发现，不管从哪里加载图片，这些逻辑都是通用的，因此可以抽象一个 AbsLoader 类。它将这几个过程抽象起来，只将变化的部分交给子类处理，就相当于 AbsLoader 封装了一个逻辑框架( 模板方法模式)，大致代码如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public abstract class AbsLoader implements ILoader &#123;</div><div class="line">    // 图片缓存</div><div class="line">    private static IBitmapCache mCache = ImageLoader.getInstance().getCache();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void loadImage(BitmapRequest request) &#123;</div><div class="line">        if (null == request || null == request.imageView</div><div class="line">                || TextUtils.isEmpty(request.imageUri)) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 1、从缓存中获取</div><div class="line">        Bitmap bitmap = ImageLoader.getInstance().getCache().get(request);</div><div class="line">        // 2、没有缓存，调用 onLoaderImage 加载图片</div><div class="line">        if (null == bitmap) &#123;</div><div class="line">            bitmap = onLoadImage(request);</div><div class="line">            // 3、缓存图片</div><div class="line">            cacheBitmap(request, bitmap);</div><div class="line">        &#125;</div><div class="line">        // 4、将结果投递到UI线程</div><div class="line">        deliveryToUIThread(request, bitmap);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected abstract Bitmap onLoadImage(BitmapRequest result);</div><div class="line"></div><div class="line">    private void cacheBitmap(BitmapRequest request, Bitmap bitmap) &#123;</div><div class="line">        // 缓存新的图片</div><div class="line">        if (bitmap != null &amp;&amp; mCache != null) &#123;</div><div class="line">            synchronized (mCache) &#123;</div><div class="line">                mCache.put(request, bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 更新视图控件，显示图片</div><div class="line">     * @param request   ImageView</div><div class="line">     * @param bitmap    Bitmap</div><div class="line">     */</div><div class="line">    private void deliveryToUIThread(final BitmapRequest request, final Bitmap bitmap) &#123;</div><div class="line">        final ImageView imageView = request.imageView;</div><div class="line">        if (null != imageView) &#123;</div><div class="line">            imageView.post(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    updateImageView(request, bitmap);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 更新ImageView</div><div class="line">     */</div><div class="line">    private void updateImageView(BitmapRequest request, Bitmap result) &#123;</div><div class="line">        ImageView imageView = request.imageView;</div><div class="line">        if (result != null &amp;&amp; request.isImageViewTagValid()) &#123;</div><div class="line">            imageView.setImageBitmap(result);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>代码逻辑如上所述实现了一个模板函数，变化的部分就是 onLoadImage，子类在这里实现真正的加载图片的方法。比如从网络上加载图片。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class UrlLoader extends AbsLoader &#123;</div><div class="line">    @Override</div><div class="line">    protected Bitmap onLoadImage(BitmapRequest request) &#123;</div><div class="line">        if (null == request || TextUtils.isEmpty(request.imageUri)) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Bitmap bitmap = null;</div><div class="line">        try &#123;</div><div class="line">            URL url = new URL(request.imageUri);</div><div class="line">            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>按照上述代码，我们再一个本地图片加载实现类（LocalLoader）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class LocalLoader extends AbsLoader &#123;</div><div class="line">    @Override</div><div class="line">    public Bitmap onLoadImage(BitmapRequest request) &#123;</div><div class="line">        final String imagePath = Uri.parse(request.imageUri).getPath();</div><div class="line">        final File imgFile = new File(imagePath);</div><div class="line">        if (!imgFile.exists()) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return BitmapFactory.decodeFile(imagePath);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们的程序该根据什么条件来选择加载器呢？我们加载网络图片的 uri 格式统一为 <a href="http://xxx/image.jpg，或者" target="_blank" rel="external">http://xxx/image.jpg，或者</a> https 打头；而本地图片的 uri 为 file://sdcard/xxx/image.jpg。也就是说 uri 格式为 schema:// + 图片路径，而 schema 的值可能是：HTTP(“http”), HTTPS(“https”), FILE(“file”), CONTENT(“content”), ASSETS(“assets”), DRAWABLE(“drawable”), UNKNOWN(“”)。现在我们可以创建一个枚举类 Scheme，负责声明各个常量值以及解析图片 uri。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public enum Scheme &#123;</div><div class="line">    HTTP(&quot;http&quot;), HTTPS(&quot;https&quot;), FILE(&quot;file&quot;), CONTENT(&quot;content&quot;), </div><div class="line">    ASSETS(&quot;assets&quot;), DRAWABLE(&quot;drawable&quot;), UNKNOWN(&quot;&quot;);</div><div class="line"></div><div class="line">    private String scheme;</div><div class="line">    private String uriPrefix;</div><div class="line"></div><div class="line">    Scheme(String scheme) &#123;</div><div class="line">        this.scheme = scheme;</div><div class="line">        uriPrefix = scheme + &quot;://&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Scheme ofUri(String uri) &#123;</div><div class="line">        if (uri != null) &#123;</div><div class="line">            for (Scheme s : values()) &#123;</div><div class="line">                if (s.belongsTo(uri)) &#123;</div><div class="line">                    return s;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return UNKNOWN;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private boolean belongsTo(String uri) &#123;</div><div class="line">        return uri.toLowerCase(Locale.US).startsWith(uriPrefix);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String wrap(String path) &#123;</div><div class="line">        return uriPrefix + path;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String crop(String uri) &#123;</div><div class="line">        if (!belongsTo(uri)) &#123;</div><div class="line">            throw new IllegalArgumentException(String.format(&quot;URI [%1$s] &quot; +</div><div class="line">                    &quot;doesn&apos;t have expected scheme [%2$s]&quot;, uri, scheme));</div><div class="line">        &#125;</div><div class="line">        return uri.substring(uriPrefix.length());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果你要实现自己的 Loader 来加载特定的格式，那么它的 uri 格式必须以 schema:// 开头，否则解析会错误，例如可以为 drawable://image，然后你注册一个 schema 为 “drawable” 的Loader到 LoaderManager 中，ImageLoader 在加载图片时就会使用你注册的 Loader 来加载图片，这样就可以应对用户的多种多样的需求。如果不能拥抱变化那就不能称之为框架了，应该叫功能模块。</p><p>其中 LoaderManager 代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class LoaderManager &#123;</div><div class="line">    private Map&lt;Scheme, ILoader&gt; mLoaderMap = new HashMap&lt;&gt;();</div><div class="line">    private ILoader mNullLoader = new NullLoader();</div><div class="line"></div><div class="line">    private static LoaderManager INSTANCE;</div><div class="line">    private LoaderManager() &#123;</div><div class="line">        register(Scheme.HTTP, new UrlLoader());</div><div class="line">        register(Scheme.HTTPS, new UrlLoader());</div><div class="line">        register(Scheme.FILE, new LocalLoader());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static LoaderManager getInstance() &#123;</div><div class="line">        if (INSTANCE == null) &#123;</div><div class="line">            synchronized (LoaderManager.class) &#123;</div><div class="line">                if (INSTANCE == null) &#123;</div><div class="line">                    INSTANCE = new LoaderManager();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 注册 Loader</div><div class="line">    public final synchronized void register(Scheme schema, ILoader loader) &#123;</div><div class="line">        mLoaderMap.put(schema, loader);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 根据 schema 获取对应的 Loader</div><div class="line">    public ILoader getLoader(Scheme schema) &#123;</div><div class="line">        if (mLoaderMap.containsKey(schema)) &#123;</div><div class="line">            return mLoaderMap.get(schema);</div><div class="line">        &#125;</div><div class="line">        return mNullLoader;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>LoaderManager 负责管理 ILoader 的实现类，默认注册了 HTTP、HTTPS、FILE 三种 Scheme 及对应的实现加载类。如果用户自定义图片加载类，那么需要将它注册到 LoaderManager 中。注册方式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">LoaderManager.getInstance().register(Scheme.DRAWABLE, new DrawableLoader());</div><div class="line"></div><div class="line">LoaderManager.getInstance().register(Scheme.ASSETS, new ILoader() &#123;</div><div class="line">    @Override</div><div class="line">    public void loadImage(BitmapRequest result) &#123;</div><div class="line">        // 自定义图片加载</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>然后修改 RequestDispatcher 中相应的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class RequestDispatcher extends Thread &#123;</div><div class="line"></div><div class="line">    // ...</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        try &#123;</div><div class="line">            while (!this.isInterrupted()) &#123;</div><div class="line">                final BitmapRequest request = mBitmapRequestQueue.take();</div><div class="line">                if (request.isCancel) &#123;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">                Scheme scheme = Scheme.ofUri(request.imageUri);</div><div class="line">                ILoader loader = LoaderManager.getInstance().getLoader(scheme);</div><div class="line">                if (loader != null) &#123;</div><div class="line">                    loader.loadImage(request);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            Log.i(&quot;&quot;, &quot;### 请求分发器退出&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="图片解码"><a href="#图片解码" class="headerlink" title="图片解码"></a>图片解码</h3><p>我们定义的 UrlLoader 和 LocalLoader 都使用 BitmapFactory 默认的解码方式来获取位图（Bitmap）。如果用来展示图片的 ImageView 的宽高是位图的宽高的几分之一，那么直接加载原图而不进行缩放，明显浪费内存，甚至可能出现加载一张大图而导致 OOM 的极端情况。那么我们必须提供相关 API 以便用户选择某种方式对图片进行缩放。解析图片的一般过程如下：</p><ol><li>创建 BitmapFactory.Options options，设置 options.inJustDecodeBounds = true，使得只解析图片尺寸等信息;</li><li>根据 ImageView 的尺寸来检查是否需要缩小要加载的图片以及计算缩放比例;</li><li>设置 options.inJustDecodeBounds = false，然后按照 options 设置的缩小比例来加载图片。</li></ol><p>我们来创建一个类：BitmapDecoder，它使用 decodeBitmap 方法封装上述过程 ( 模板方法模式 )，用户只需要实现一个子类，并且覆写 BitmapDecoder 的 decodeBitmapWithOption 实现图片加载即可完成这个过程。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 封装先加载图片 bound，计算出 inSmallSize 之后再加载图片的逻辑操作</div><div class="line"> */</div><div class="line">public abstract class BitmapDecoder &#123;</div><div class="line"></div><div class="line">    public abstract Bitmap decodeBitmapWithOption(Options options);</div><div class="line"></div><div class="line">    public final Bitmap decodeBitmap(int width, int height) &#123;</div><div class="line">        // 如果请求原图,则直接加载原图</div><div class="line">        if (width &lt;= 0 || height &lt;= 0) &#123;</div><div class="line">            return decodeBitmapWithOption(null);</div><div class="line">        &#125;</div><div class="line">        // 1、获取只加载Bitmap宽高等数据的Option, 即设置options.inJustDecodeBounds = true;</div><div class="line">        BitmapFactory.Options options = new BitmapFactory.Options();</div><div class="line">        // 设置为true,表示解析Bitmap对象，该对象不占内存</div><div class="line">        options.inJustDecodeBounds = true;</div><div class="line">        // 2、通过options加载bitmap，此时返回的bitmap为空,数据将存储在options中</div><div class="line">        decodeBitmapWithOption(options);</div><div class="line">        // 3、计算缩放比例, 并且将options.inJustDecodeBounds设置为false;</div><div class="line">        configBitmapOptions(options, width, height);</div><div class="line">        // 4、通过options设置的缩放比例加载图片</div><div class="line">        return decodeBitmapWithOption(options);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 加载原图</div><div class="line">    public Bitmap decodeOriginBitmap() &#123;</div><div class="line">        return decodeBitmapWithOption(null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void configBitmapOptions(Options options, int width, int height) &#123;</div><div class="line">        // 设置缩放比例</div><div class="line">        options.inSampleSize = computeInSmallSize(options, width, height);</div><div class="line"></div><div class="line">        Log.d(&quot;&quot;, &quot;$## inSampleSize = &quot; + options.inSampleSize</div><div class="line">                + &quot;, width = &quot; + width + &quot;, height= &quot; + height);</div><div class="line">        // 图片质量</div><div class="line">        options.inPreferredConfig = Config.RGB_565;</div><div class="line">        // 设置为false,解析Bitmap对象加入到内存中</div><div class="line">        options.inJustDecodeBounds = false;</div><div class="line">        options.inPurgeable = true;</div><div class="line">        options.inInputShareable = true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private int computeInSmallSize(BitmapFactory.Options options, int reqWidth, int reqHeight) &#123;</div><div class="line">        final int height = options.outHeight;</div><div class="line">        final int width = options.outWidth;</div><div class="line">        int inSampleSize = 1;</div><div class="line"></div><div class="line">        if (height &gt; reqHeight || width &gt; reqWidth) &#123;</div><div class="line">            // Calculate ratios of height and width to requested height and</div><div class="line">            // width</div><div class="line">            final int heightRatio = Math.round((float) height / (float) reqHeight);</div><div class="line">            final int widthRatio = Math.round((float) width / (float) reqWidth);</div><div class="line"></div><div class="line">            inSampleSize = heightRatio &lt; widthRatio ? heightRatio : widthRatio;</div><div class="line"></div><div class="line">            final float totalPixels = width * height;</div><div class="line">            final float totalReqPixelsCap = reqWidth * reqHeight * 2;</div><div class="line"></div><div class="line">            while (totalPixels / (inSampleSize * inSampleSize) &gt; totalReqPixelsCap) &#123;</div><div class="line">                inSampleSize++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return inSampleSize;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 decodeBitmap 中，我们首先创建 BitmapFactory.Options 对象，并且设置 options.inJustDecodeBounds = true，然后第一次调用 decodeBitmapWithOption(options)，使得只解析图片尺寸等信息；然后调用 calculateInSmall 方法，该方法会调用 computeInSmallSize 来根据 ImageView 的尺寸来检查是否需要缩小要加载的图片以及计算缩放比例，在 calculateInSmall 方法的最后将<br> options.inJustDecodeBounds = false，使得下次再次 decodeBitmapWithOption(options) 时会加载图片；那最后一步必然就是调用 decodeBitmapWithOption(options)，这样图片就会按照按照 options 设置的缩小比例来加载图片。</p><p>我们使用这个辅助类封装了这个麻烦、重复的过程，在一定程度上简化了代码，也使得代码的可复用性更高，也是模板方法模式的一个较好的示例。</p><p>然后我们在 LocalLoader 类使用 BitmapDecoder，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class LocalLoader extends AbsLoader &#123;</div><div class="line">    @Override</div><div class="line">    public Bitmap onLoadImage(BitmapRequest request) &#123;</div><div class="line">        final String imagePath = Uri.parse(request.imageUri).getPath();</div><div class="line">        final File imgFile = new File(imagePath);</div><div class="line">        if (!imgFile.exists()) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 加载图片</div><div class="line">        BitmapDecoder decoder = new BitmapDecoder() &#123;</div><div class="line">            @Override</div><div class="line">            public Bitmap decodeBitmapWithOption(Options options) &#123;</div><div class="line">                return BitmapFactory.decodeFile(imagePath, options);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        return decoder.decodeBitmap(request.getImageViewWidth(),</div><div class="line">                request.getImageViewHeight());</div><div class="line">        // return BitmapFactory.decodeFile(imagePath);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c30600c8c260cfc2.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03 ImageLoader 三级缓存</title>
      <link href="/1902/01/03/06%20THIRD%20PARY%20FRAMEWORK/03%20ImageLoader%20%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
      <url>/1902/01/03/06%20THIRD%20PARY%20FRAMEWORK/03%20ImageLoader%20%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-75d24c5fb4177b6d.gif?imageMogr2/auto-orient/strip" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1902/01/01/03IMAGE%20LOADER/01%20ImageLoader%20基础框架/" target="_blank" rel="external">01 基础框架</a><br><a href="https://xianxiaotao.github.io/1902/01/02/03IMAGE%20LOADER/02%20ImageLoader%20请求队列/" target="_blank" rel="external">02 请求队列</a><br><a href="https://xianxiaotao.github.io/1902/01/03/03IMAGE%20LOADER/03%20ImageLoader%20三级缓存/" target="_blank" rel="external">03 三级缓存</a><br><a href="https://xianxiaotao.github.io/1902/01/04/03IMAGE%20LOADER/04%20ImageLoader%20图片加载/" target="_blank" rel="external">04 图片加载</a><br><a href="https://xianxiaotao.github.io/1902/01/05/03IMAGE%20LOADER/05%20ImageLoader%20常见问题/" target="_blank" rel="external">05 常见问题</a><br><a href="https://xianxiaotao.github.io/1902/01/06/03IMAGE%20LOADER/06%20ImageLoader%20项目源码/" target="_blank" rel="external">06 项目源码</a></p></blockquote><p>前面博客中使用了内存缓存，我们先来回答一个问题：为什么要使用缓存？</p><p>移动设备在使用网络时往往面临一个问题，那就是流量是需要收费的，这就需要软件开发者在开发时应当尽量避免流量的消耗，而流量消耗的大头就是图片。这时候本地缓存就是一个很好的解决方式。而且移动设备用户所处的网络环境也是不可知的，如果用户处于弱网络环境下，那图片加载所要消耗的时间将是不可忍受的，这也是使用本地缓存的原因之一。</p><p>同时，移动设备的内存是有限的，如果一个应用包含大量的图片，全部放到内存中必然会触发 OOM，可如果每次都要重新从本次磁盘加载的话，性能就会有很大的消耗。而且本地加载虽然比网络要快但也是需要时间的，这也往往造成界面的卡顿。这时候一个好的内存缓存策略就是不可或缺的。</p><p>明白了为什么使用，接下来就要考虑怎么实现了。大家先看一张图：</p><p><img src="https://upload-images.jianshu.io/upload_images/1929233-9303dc11ec83dab2.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/960/format/webp" alt=""></p><p>首先，程序会在内存缓存中查找 Bitmap，如果命中则直接显示，如果没有就会去本地磁盘缓存中查找缓存文件；如果在磁盘缓存中命中就将缓存文件转换为 Bitmap 再进行显示，这个过程中会将 Bitmap 加入内存缓存中；如果本地磁盘中没有就会从网络上进行下载，并且缓存在磁盘和内存中。</p><p>现在我们先来实现磁盘缓存（DiskCache）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">public class DiskCache &#123;</div><div class="line">    // 图片缓存 SD 卡目录</div><div class="line">    private static String CACHE_DIR =</div><div class="line">            Environment.getExternalStorageDirectory() + &quot;/&quot;;</div><div class="line"></div><div class="line">    // 从 SD 卡缓存中获取图片</div><div class="line">    public Bitmap get(BitmapRequest request) &#123;</div><div class="line">        return BitmapFactory.decodeFile(CACHE_DIR + urlToMd5(request.imageUri));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 将图片缓存到 SD 卡中</div><div class="line">    public void put(BitmapRequest request, Bitmap bitmap) &#123;</div><div class="line">        FileOutputStream fileOutputStream = null;</div><div class="line">        try &#123;</div><div class="line">            fileOutputStream = new FileOutputStream(CACHE_DIR + urlToMd5(request.imageUri));</div><div class="line">            bitmap.compress(Bitmap.CompressFormat.PNG, 100, fileOutputStream);</div><div class="line">        &#125; catch (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (fileOutputStream != null) &#123;</div><div class="line">                try &#123;</div><div class="line">                    fileOutputStream.close();</div><div class="line">                &#125; catch (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private String urlToMd5(String url) &#123;</div><div class="line">        if (TextUtils.isEmpty(url)) &#123;</div><div class="line">            return &quot;&quot;;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);</div><div class="line">            byte[] bytes = md5.digest(url.getBytes(&quot;UTF-8&quot;));</div><div class="line">            StringBuilder hex = new StringBuilder();</div><div class="line">            for (byte b : bytes) &#123;</div><div class="line">                hex.append(Integer.toHexString(b &amp; 0xff));</div><div class="line">            &#125;</div><div class="line">            hex.append(&quot;.png&quot;);</div><div class="line">            return hex.toString();</div><div class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</div><div class="line">            throw new RuntimeException(&quot;NoSuchAlgorithmException&quot;, e);</div><div class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</div><div class="line">            throw new RuntimeException(&quot;UnsupportedEncodingException&quot;, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后修改 ImageLoader.java 源码进行测试，可使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line">    // 图片缓存</div><div class="line">    // private ImageCache mImageCache = new ImageCache();</div><div class="line">    private DiskCache mImageCache = new DiskCache();</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>接下来要实现的是：首先使用内存缓存，如果内存缓存没有图片再使用 SD 卡缓存，如果 SD 卡中也没有图片，最后才从网络上获取。于是新建一个双缓存类 DoubleCache.java，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class DoubleCache &#123;</div><div class="line">    private ImageCache mMemoryCache = new ImageCache();</div><div class="line">    private DiskCache mDiskCache = new DiskCache();</div><div class="line"></div><div class="line">    public Bitmap get(BitmapRequest request) &#123;</div><div class="line">        Bitmap bitmap = mMemoryCache.get(request);</div><div class="line">        if (bitmap == null) &#123;</div><div class="line">            bitmap = mDiskCache.get(request);</div><div class="line">        &#125;</div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void put(BitmapRequest request, Bitmap bitmap) &#123;</div><div class="line">        mMemoryCache.put(request, bitmap);</div><div class="line">        mDiskCache.put(request, bitmap);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>很快就发现，ImageCache、DiskCache 和 DoubleCache，有共同的行为，那就是对 Bitmap 的存取操作，只是具体的实现细节不同。此处，我们可以对他们进行抽象出共同的接口 IBitmapCache，有 get、put 和 remove 方法。对于数据源，一般都是提供增删改查操作。此时 ImageCache 类名改为 MemoryCache 更恰当。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7bafced422bb3638.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>IBitmapCache.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface IBitmapCache &#123;</div><div class="line">    void put(BitmapRequest key, Bitmap value);</div><div class="line">    Bitmap get(BitmapRequest key);</div><div class="line">    void remove(BitmapRequest key);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>MemoryCache.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class MemoryCache implements IBitmapCache &#123;</div><div class="line"></div><div class="line">    private static final int ONE_KB = 1024;</div><div class="line">    private static final int MAX_MEMORY_PERCENT = 4;</div><div class="line"></div><div class="line">    // 图片内存缓存</div><div class="line">    private LruCache&lt;BitmapRequest, Bitmap&gt; mImageCache;</div><div class="line"></div><div class="line">    public MemoryCache() &#123;</div><div class="line">        initImageCache();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 初始化缓存大小：取四分之一的可用内存作为缓存。</div><div class="line">    private void initImageCache() &#123;</div><div class="line">        int maxMemory = (int) (Runtime.getRuntime().maxMemory() / ONE_KB);</div><div class="line">        int cacheSize = maxMemory / MAX_MEMORY_PERCENT;</div><div class="line">        mImageCache = new LruCache&lt;BitmapRequest, Bitmap&gt;(cacheSize) &#123;</div><div class="line">            @Override</div><div class="line">            protected int sizeOf(BitmapRequest key, Bitmap bitmap) &#123;</div><div class="line">                return bitmap.getRowBytes() * bitmap.getHeight() / ONE_KB;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void put(BitmapRequest key, Bitmap value) &#123;</div><div class="line">        mImageCache.put(key, value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Bitmap get(BitmapRequest key) &#123;</div><div class="line">        return mImageCache.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void remove(BitmapRequest key) &#123;</div><div class="line">        mImageCache.remove(key);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>DoubleCache.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class DoubleCache implements IBitmapCache &#123;</div><div class="line">    private MemoryCache mMemoryCache = new MemoryCache();</div><div class="line">    private DiskCache mDiskCache = new DiskCache();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Bitmap get(BitmapRequest key) &#123;</div><div class="line">        Bitmap bitmap = mMemoryCache.get(key);</div><div class="line">        if (bitmap == null) &#123;</div><div class="line">            bitmap = mDiskCache.get(key);</div><div class="line">        &#125;</div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void put(BitmapRequest key, Bitmap bitmap) &#123;</div><div class="line">        mMemoryCache.put(key, bitmap);</div><div class="line">        mDiskCache.put(key, bitmap);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void remove(BitmapRequest key) &#123;</div><div class="line">        mMemoryCache.remove(key);</div><div class="line">        mDiskCache.remove(key);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>DiskCache.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">public class DiskCache implements IBitmapCache &#123;</div><div class="line">    // 图片缓存 SD 卡目录</div><div class="line">    private static String CACHE_DIR =</div><div class="line">            Environment.getExternalStorageDirectory() + &quot;/&quot;;</div><div class="line"></div><div class="line">    // 从 SD 卡缓存中获取图片</div><div class="line">    public Bitmap get(BitmapRequest request) &#123;</div><div class="line">        return BitmapFactory.decodeFile(CACHE_DIR + urlToMd5(request.imageUri));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 将图片缓存到 SD 卡中</div><div class="line">    public void put(BitmapRequest request, Bitmap bitmap) &#123;</div><div class="line">        FileOutputStream fileOutputStream = null;</div><div class="line">        try &#123;</div><div class="line">            fileOutputStream = new FileOutputStream(CACHE_DIR + urlToMd5(request.imageUri));</div><div class="line">            bitmap.compress(Bitmap.CompressFormat.PNG, 100, fileOutputStream);</div><div class="line">        &#125; catch (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (fileOutputStream != null) &#123;</div><div class="line">                try &#123;</div><div class="line">                    fileOutputStream.close();</div><div class="line">                &#125; catch (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void remove(BitmapRequest request) &#123;</div><div class="line">        if (request != null &amp;&amp; !TextUtils.isEmpty(request.imageUri)) &#123;</div><div class="line">            File file = new File(CACHE_DIR + urlToMd5(request.imageUri));</div><div class="line">            if (file.exists()) &#123;</div><div class="line">                file.delete();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private String urlToMd5(String url) &#123;</div><div class="line">        if (TextUtils.isEmpty(url)) &#123;</div><div class="line">            return &quot;&quot;;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);</div><div class="line">            byte[] bytes = md5.digest(url.getBytes(&quot;UTF-8&quot;));</div><div class="line">            StringBuilder hex = new StringBuilder();</div><div class="line">            for (byte b : bytes) &#123;</div><div class="line">                hex.append(Integer.toHexString(b &amp; 0xff));</div><div class="line">            &#125;</div><div class="line">            hex.append(&quot;.png&quot;);</div><div class="line">            return hex.toString();</div><div class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</div><div class="line">            throw new RuntimeException(&quot;NoSuchAlgorithmException&quot;, e);</div><div class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</div><div class="line">            throw new RuntimeException(&quot;UnsupportedEncodingException&quot;, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>接下来重构 ImageLoader 类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line"></div><div class="line">    // 图片内存缓存</div><div class="line">    private IBitmapCache mCache = new MemoryCache();</div><div class="line"></div><div class="line">    // 代码省略...</div><div class="line"></div><div class="line">    public void init(ImageLoaderConfig config) &#123;</div><div class="line">        mConfig = config;</div><div class="line">        mCache = mConfig.imageCache;</div><div class="line">        checkConfig();</div><div class="line">        mImageQueue = new RequestQueue(mConfig.threadCount);</div><div class="line">        mImageQueue.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void checkConfig() &#123;</div><div class="line">        if (mCache == null) &#123;</div><div class="line">            mCache = new MemoryCache();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 代码省略...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public IBitmapCache getCache() &#123;</div><div class="line">        return mCache;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 代码省略...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ImageLoaderConfig 类修改同上，略。</p><p>经过此次重构，用户可以通过 setCache(IBitmapCache cache) 函数设置缓存实现，也就是通常说的依赖注入。具体如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">IBitmapCache cache1 = new MemoryCache();</div><div class="line">IBitmapCache cache2 = new DiskCache();</div><div class="line">IBitmapCache cache3 = new DoubleCache();</div><div class="line">IBitmapCache cache4 = new IBitmapCache() &#123;</div><div class="line">    @Override</div><div class="line">    public Bitmap get(BitmapRequest key) &#123;</div><div class="line">        return null; // 从缓存中获取图片</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void put(BitmapRequest key, Bitmap bitmap) &#123;</div><div class="line">        // 缓存图片</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void remove(BitmapRequest key) &#123;</div><div class="line">        // 删除</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>在上述代码中，通过 setCache(IBitmapCache cache) 方法注入不同的缓存实现，这样不仅能够使 ImageLoader 更简单、健壮，也使得 ImageLoader 的可扩展性、灵活性更高。MemoryCache、DiskCache、DoubleCache 缓存图片的具体实现完全不一样，但是，它们的一个特点是，都实现了 IBitmapCache 接口。当用户需要自定义实现缓存策略时，只需要新建一个实现 IBitmapCache 接口的类，然后构造该类的对象，并且通过 setCache 函数注入到 ImageLoaderConfig 中，这样 ImageLoader 就实现了千变万化的缓存策略，且扩展这些缓存策略并不会导致 ImageLoader 类的修改。</p><p>接下来，我们再新增一个缓存类 NoCache：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class NoCache implements IBitmapCache &#123;</div><div class="line">    @Override</div><div class="line">    public Bitmap get(BitmapRequest key) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void put(BitmapRequest key, Bitmap value) &#123;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void remove(BitmapRequest key) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后就没有然后了，因为不需要修改其他模块的任何代码，这就是<strong>抽象</strong>的魅力，而且几乎符合六大原则：功能单一，满足<a href="https://xianxiaotao.github.io/1901/01/03/02DESIGN%20PATTERN/00.1%20ANDROID%20面向对象的六大原则——单一职责原则/" target="_blank" rel="external">单一职责原则</a>；对扩展开放对修改关闭，满足<a href="https://xianxiaotao.github.io/1901/01/04/02DESIGN%20PATTERN/00.2%20ANDROID%20面向对象的六大原则——开闭原则/" target="_blank" rel="external">开闭原则</a>；setBitmapCache(IBitmapCache cache) 的用法同时满足<a href="https://xianxiaotao.github.io/1901/01/05/02DESIGN%20PATTERN/00.3%20ANDROID%20面向对象的六大原则——里氏替换原则/" target="_blank" rel="external">里氏替换原则</a>和<a href="https://xianxiaotao.github.io/1901/01/06/02DESIGN%20PATTERN/00.4%20ANDROID%20面向对象的六大原则——依赖倒置原则/" target="_blank" rel="external">依赖倒置原则</a>；IBitmapCache 接口类几乎不可拆分，满足<a href="https://xianxiaotao.github.io/1901/01/07/02DESIGN%20PATTERN/00.5%20ANDROID%20面向对象的六大原则——接口隔离原则/" target="_blank" rel="external">接口隔离原则</a>；对于 ImageLoader 来说最直接的朋友是 IBitmapCache，至于你依赖 LruCache 对象还是 File 文件系统，都与我无关，符合<a href="https://xianxiaotao.github.io/1901/01/08/02DESIGN%20PATTERN/00.6%20ANDROID%20面向对象的六大原则——迪米特原则/" target="_blank" rel="external">迪米特原则</a>。</p><p>在上面代码中，内存缓存我们使用了官方的 LruCache 类，对于磁盘缓存，我们选择 Jake Wharton 大神的 <a href="https://link.jianshu.com/?t=https://github.com/JakeWharton/DiskLruCache" target="_blank" rel="external">DiskLruCache</a> 类。先来看看 DiskCache 改造后的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line">public class DiskCache implements IBitmapCache &#123;</div><div class="line">    // 1 MB</div><div class="line">    private static final int MB = 1024 * 1024;</div><div class="line">    // cache dir</div><div class="line">    private static final String IMAGE_DISK_CACHE = &quot;bitmap&quot;;</div><div class="line">    // Disk LRU Cache</div><div class="line">    private DiskLruCache mDiskLruCache;</div><div class="line">    // Disk Cache Instance</div><div class="line">    private static DiskCache mDiskCache;</div><div class="line"></div><div class="line">    private String mCachePath;</div><div class="line"></div><div class="line">    private DiskCache(Context context) &#123;</div><div class="line">        initDiskCache(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initDiskCache(Context context) &#123;</div><div class="line">        try &#123;</div><div class="line">            File cacheDir = getDiskCacheDir(context, IMAGE_DISK_CACHE);</div><div class="line">            if (!cacheDir.exists()) &#123;</div><div class="line">                cacheDir.mkdirs();</div><div class="line">            &#125;</div><div class="line">            mDiskLruCache = DiskLruCache</div><div class="line">                    .open(cacheDir, getAppVersion(context), 1, 50 * MB);</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 单例</div><div class="line">    public static DiskCache getDiskCache(Context context) &#123;</div><div class="line">        if (mDiskCache == null) &#123;</div><div class="line">            synchronized (DiskCache.class) &#123;</div><div class="line">                if (mDiskCache == null) &#123;</div><div class="line">                    mDiskCache = new DiskCache(context);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return mDiskCache;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 从 SD 卡缓存中获取图片</div><div class="line">    @Override</div><div class="line">    public Bitmap get(BitmapRequest request) &#123;</div><div class="line">        final InputStream inputStream = getInputStream(Md5Helper.toMD5(request.imageUri));</div><div class="line">        return BitmapFactory.decodeStream(inputStream);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 将图片缓存到磁盘中</div><div class="line">    @Override</div><div class="line">    public void put(BitmapRequest request, Bitmap value) &#123;</div><div class="line">        DiskLruCache.Editor editor;</div><div class="line">        try &#123;</div><div class="line">            // 如果没有找到对应的缓存，则准备从网络上请求数据，并写入缓存</div><div class="line">            editor = mDiskLruCache.edit(Md5Helper.toMD5(request.imageUri));</div><div class="line">            if (editor != null) &#123;</div><div class="line">                OutputStream outputStream = editor.newOutputStream(0);</div><div class="line">                if (writeBitmapToDisk(value, outputStream)) &#123;</div><div class="line">                    // 写入disk缓存</div><div class="line">                    editor.commit();</div><div class="line">                &#125; else &#123;</div><div class="line">                    editor.abort();</div><div class="line">                &#125;</div><div class="line">                IOUtil.closeQuietly(outputStream);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void remove(BitmapRequest key) &#123;</div><div class="line">        try &#123;</div><div class="line">            mDiskLruCache.remove(Md5Helper.toMD5(key.imageUri));</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private InputStream getInputStream(String md5) &#123;</div><div class="line">        Snapshot snapshot;</div><div class="line">        try &#123;</div><div class="line">            snapshot = mDiskLruCache.get(md5);</div><div class="line">            if (snapshot != null) &#123;</div><div class="line">                return snapshot.getInputStream(0);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private File getDiskCacheDir(Context context, String name) &#123;</div><div class="line">        if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) &#123;</div><div class="line">            Log.d(&quot;&quot;, &quot;### context : &quot; + context + &quot;, dir = &quot; + context.getExternalCacheDir());</div><div class="line">            mCachePath = context.getExternalCacheDir().getPath();</div><div class="line">        &#125; else &#123;</div><div class="line">            mCachePath = context.getCacheDir().getPath();</div><div class="line">        &#125;</div><div class="line">        return new File(mCachePath + File.separator + name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private boolean writeBitmapToDisk(Bitmap bitmap, OutputStream outputStream) &#123;</div><div class="line">        BufferedOutputStream bos = new BufferedOutputStream(outputStream, 8 * 1024);</div><div class="line">        bitmap.compress(Bitmap.CompressFormat.JPEG, 100, bos);</div><div class="line">        boolean result = true;</div><div class="line">        try &#123;</div><div class="line">            bos.flush();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            result = false;</div><div class="line">        &#125; finally &#123;</div><div class="line">            IOUtil.closeQuietly(bos);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private int getAppVersion(Context context) &#123;</div><div class="line">        try &#123;</div><div class="line">            PackageInfo info = context.getPackageManager().getPackageInfo(context.getPackageName(),</div><div class="line">                    0);</div><div class="line">            return info.versionCode;</div><div class="line">        &#125; catch (NameNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其中有些方法已经放到其他工具类中，如 Md5Helper、IOUtil；有些没有，如 getDiskCacheDir()、getAppVersion() 等，这些细节暂不表。此处用了单例模式，没有持有 Context 对象，防止内存泄漏。如果必须持有 Context 对象，建议使用下面方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mContext = context.getApplicationContext();</div></pre></td></tr></table></figure></p><p>因为创建 DiskCache 需要 Context 对象，对它依赖的对象都要修改代码。在本项目中只有 DoubleCache 中持有磁盘缓存对象，所以修改代码不多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class DoubleCache implements IBitmapCache &#123;</div><div class="line">    private MemoryCache mMemoryCache = new MemoryCache();</div><div class="line">    private DiskCache mDiskCache;</div><div class="line"></div><div class="line">    public DoubleCache(Context context) &#123;</div><div class="line">        mDiskCache = DiskCache.getDiskCache(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Bitmap get(BitmapRequest key) &#123;</div><div class="line">        Bitmap value = mMemoryCache.get(key);</div><div class="line">        if (value == null) &#123;</div><div class="line">            value = mDiskCache.get(key);</div><div class="line">            // 存到内存缓存中</div><div class="line">            saveBitmapIntoMemory(key, value);</div><div class="line">        &#125;</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void put(BitmapRequest key, Bitmap bitmap) &#123;</div><div class="line">        mMemoryCache.put(key, bitmap);</div><div class="line">        mDiskCache.put(key, bitmap);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void remove(BitmapRequest key) &#123;</div><div class="line">        mMemoryCache.remove(key);</div><div class="line">        mDiskCache.remove(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void saveBitmapIntoMemory(BitmapRequest key, Bitmap bitmap) &#123;</div><div class="line">        // 如果 Value 从 disk 中读取，那么存入内存缓存</div><div class="line">        if (bitmap != null) &#123;</div><div class="line">            mMemoryCache.put(key, bitmap);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>另附工具类代码 IOUtil.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class IOUtil &#123;</div><div class="line"></div><div class="line">    private IOUtil() &#123;&#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 关闭IO</div><div class="line">     * @param closeables closeables</div><div class="line">     */</div><div class="line">    public static void close(Closeable... closeables) &#123;</div><div class="line">        if (closeables == null) return;</div><div class="line">        for (Closeable closeable : closeables) &#123;</div><div class="line">            if (closeable != null) &#123;</div><div class="line">                try &#123;</div><div class="line">                    closeable.close();</div><div class="line">                &#125; catch (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 关闭IO，不输出日志</div><div class="line">     * @param closeables closeables</div><div class="line">     */</div><div class="line">    public static void closeQuietly(Closeable... closeables) &#123;</div><div class="line">        if (closeables == null) return;</div><div class="line">        for (Closeable closeable : closeables) &#123;</div><div class="line">            if (closeable != null) &#123;</div><div class="line">                try &#123; closeable.close(); &#125; catch (IOException e) &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Md5Helper.java：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public class Md5Helper &#123;</div><div class="line">    /**</div><div class="line">     * 使用MD5算法对传入的key进行加密并返回。</div><div class="line">     */</div><div class="line">    private static MessageDigest mDigest = null;</div><div class="line"></div><div class="line">    static&#123;</div><div class="line">        try &#123;</div><div class="line">            mDigest = MessageDigest.getInstance(&quot;MD5&quot;);</div><div class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     *</div><div class="line">     * 对key进行MD5加密，如果无MD5加密算法，则直接使用key对应的hash值。&lt;/br&gt;</div><div class="line">     * @param key</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public static String toMD5(String key) &#123;</div><div class="line">        String cacheKey;</div><div class="line">        //获取MD5算法失败时，直接使用key对应的hash值</div><div class="line">        if ( mDigest == null ) &#123;</div><div class="line">            return String.valueOf(key.hashCode());</div><div class="line">        &#125;</div><div class="line">        mDigest.update(key.getBytes());</div><div class="line">        cacheKey = bytesToHexString(mDigest.digest());</div><div class="line">        return cacheKey;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param bytes</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    private static String bytesToHexString(byte[] bytes) &#123;</div><div class="line">        StringBuilder sb = new StringBuilder();</div><div class="line">        for (int i = 0; i &lt; bytes.length; i++) &#123;</div><div class="line">            String hex = Integer.toHexString(0xFF &amp; bytes[i]);</div><div class="line">            if (hex.length() == 1) &#123;</div><div class="line">                sb.append(&apos;0&apos;);</div><div class="line">            &#125;</div><div class="line">            sb.append(hex);</div><div class="line">        &#125;</div><div class="line">        return sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-10565cb3ac6d92e1.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02 ImageLoader 请求队列</title>
      <link href="/1902/01/02/06%20THIRD%20PARY%20FRAMEWORK/02%20ImageLoader%20%E8%AF%B7%E6%B1%82%E9%98%9F%E5%88%97/"/>
      <url>/1902/01/02/06%20THIRD%20PARY%20FRAMEWORK/02%20ImageLoader%20%E8%AF%B7%E6%B1%82%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-dd8c2e552e45d22e.gif?imageMogr2/auto-orient/strip" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1902/01/01/03IMAGE%20LOADER/01%20ImageLoader%20基础框架/" target="_blank" rel="external">01 基础框架</a><br><a href="https://xianxiaotao.github.io/1902/01/02/03IMAGE%20LOADER/02%20ImageLoader%20请求队列/" target="_blank" rel="external">02 请求队列</a><br><a href="https://xianxiaotao.github.io/1902/01/03/03IMAGE%20LOADER/03%20ImageLoader%20三级缓存/" target="_blank" rel="external">03 三级缓存</a><br><a href="https://xianxiaotao.github.io/1902/01/04/03IMAGE%20LOADER/04%20ImageLoader%20图片加载/" target="_blank" rel="external">04 图片加载</a><br><a href="https://xianxiaotao.github.io/1902/01/05/03IMAGE%20LOADER/05%20ImageLoader%20常见问题/" target="_blank" rel="external">05 常见问题</a><br><a href="https://xianxiaotao.github.io/1902/01/06/03IMAGE%20LOADER/06%20ImageLoader%20项目源码/" target="_blank" rel="external">06 项目源码</a></p></blockquote><h3 id="一、请求参数"><a href="#一、请求参数" class="headerlink" title="一、请求参数"></a>一、请求参数</h3><p>为了追求单一职责原则，上篇博客将 ImageLoader 类拆出 3 个类，这种情况往往导致方法调用层次加深，参数传递多次。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Client </div><div class="line">——&gt; ImageLoader.displayImage(url, imageView) </div><div class="line">——&gt; RequestThreadPool.addRequest(url, imageView) </div><div class="line">——&gt; Loader.load(url, imageView) </div><div class="line">——&gt; Loader.downloadImage(url)</div></pre></td></tr></table></figure></p><p>其中，参数 url 和 imageView 就传递了多次。如果后期需求变更，要新增参数，比如新增一个回调监听器 listener，那么整个方法调用链上的代码都要大幅修改。这时，我们一般将多个参数封装在一个对象里，这样就可以减少很多修改操作。此处。我们将参数 url 和 imageView 封装在请求参数 BitmapRequest 类中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class BitmapRequest &#123;</div><div class="line">    public ImageView imageView;</div><div class="line">    public String imageUri;</div><div class="line"></div><div class="line">    public BitmapRequest(ImageView imageView, String uri) &#123;</div><div class="line">        this.imageView = imageView;</div><div class="line">        this.imageUri = uri;</div><div class="line">        imageView.setTag(uri);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // image view 的 tag 与 uri 是否相等</div><div class="line">    public boolean isImageViewTagValid() &#123;</div><div class="line">        return imageView != null &amp;&amp; imageView.getTag().equals(imageUri);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>对应的方法调用链的参数也需要替换成 BitmapRequest，如 ImageLoader 的 displayImage 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void displayImage(String uri, ImageView imageView) &#123;</div><div class="line">    BitmapRequest request = new BitmapRequest(imageView, uri);</div><div class="line">    mThreadPool.addRequest(request);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ImageLoader 将用户传递的各种参数封装为 BitmapRequest 对象并沿着方法调用依次传递。为了保证程序的一致性，BitmapRequest 也作为缓存的 key。ImageCache 代码更改如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class ImageCache &#123;</div><div class="line">    private LruCache&lt;BitmapRequest, Bitmap&gt; mImageCache;</div><div class="line"></div><div class="line">    // 代码省略...</div><div class="line"></div><div class="line">    public void put(BitmapRequest key, Bitmap value) &#123;</div><div class="line">        mImageCache.put(key, value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Bitmap get(BitmapRequest key) &#123;</div><div class="line">        return mImageCache.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void remove(BitmapRequest key) &#123;</div><div class="line">        mImageCache.remove(key);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>避免啰嗦，就不再给出其他参数修改代码。</p><h3 id="二、请求队列"><a href="#二、请求队列" class="headerlink" title="二、请求队列"></a>二、请求队列</h3><p>在 RequestThreadPool 类中，我们使用了 ExecutorService.submit(new Runnable(){}) 方法。虽然使用了线程池，支持多个异步加载任务，但是我们无法控制它。比如取消加载任务，修改加载顺序等，而且我们这样的异步加载代码显得非常“丑陋”，阅读性差。具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class RequestThreadPool &#123;</div><div class="line">    // 线程池，线程数量为 CPU 的数量</div><div class="line">    private ExecutorService mExecutorService = Executors.newFixedThreadPool(</div><div class="line">            Runtime.getRuntime().availableProcessors());</div><div class="line"></div><div class="line">    public void addRequest(final BitmapRequest request) &#123;</div><div class="line">        mExecutorService.submit(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                Loader.getInstance().load(request);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>有没有更好的实现方式呢？当然有，而且 ANDROID 本身就提供了一个很棒的设计案例，那就是 Handler。那 Handler 的机制是什么样的呢？先来看下图。</p><p><img src="https://upload-images.jianshu.io/upload_images/1929233-da4e2b0025084839.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/960/format/webp" alt=""></p><p>在使用 Handler 的时候，在 Handler 所创建的线程需要维护一个唯一的 Looper 对象，每个线程对应一个 Looper，每个线程的 Looper 通过 ThreadLocal 来保证；Looper 对象的内部又维护有唯一的一个 MessageQueue，所以一个线程可以有多个 Handler，但是只能有一个 Looper 和一个 MessageQueue。</p><p>Message 在 MessageQueue 不是通过一个列表来存储的，而是将传入的 Message 存入到了上一个 Message 的 next 中，在取出的时候通过顶部的 Message 就能按放入的顺序依次取出 Message。</p><p>Looper 对象通过 loop() 方法开启了一个死循环，不断地从 looper 内的 MessageQueue 中取出 Message，然后通过 handler 将消息分发传回 handler 所在的线程。</p><p>阐述完 Handler 消息机制，接下来就是模仿它实现请求队列。如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-5bdf560f5cd8197b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>首先将 RequestThreadPool 改名为 RequestQueue，相当于 Looper，其内部维护一个存储图片加载请求（BitmapRequest）的队列（LinkedBlockingQueue），向外部提供一个添加图片加载请求的接口（addRequest）;</li><li>RequestQueue 再维护一个线程池（RequestDispatcher[]），数量默认为：CPU 核心数 + 1个分发线程数，其中每个线程 RequestDispatcher 相当于 Handler，不断地从请求队列中获取 BitmapRequest，并执行加载任务。</li><li>实现 RequestDispatcher 类，在相应的条件下无限轮询请求队列（LinkedBlockingQueue），拿到具体图片加载请求（BitmapRequest）后去执行网络加载任务。</li></ul><p>实现代码如下：</p><p>RequestDispatcher.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class RequestDispatcher extends Thread &#123;</div><div class="line"></div><div class="line">    // 网络请求队列</div><div class="line">    private BlockingQueue&lt;BitmapRequest&gt; mBitmapRequestQueue;</div><div class="line"></div><div class="line">    public RequestDispatcher(BlockingQueue&lt;BitmapRequest&gt; queue) &#123;</div><div class="line">        mBitmapRequestQueue = queue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        try &#123;</div><div class="line">            while (!this.isInterrupted()) &#123;</div><div class="line">                final BitmapRequest request = mBitmapRequestQueue.take();</div><div class="line">                if (request.isCancel) &#123;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                Loader.getInstance().load(request);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            Log.i(&quot;&quot;, &quot;### 请求分发器退出&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>RequestDispatcher 是一个线程实现类，主要负责轮询请求队列，获取到实际请求后，调用 Loader 实例去加载网络图片。</p><p>RequestQueue.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public class RequestQueue &#123;</div><div class="line"></div><div class="line">    private BlockingQueue&lt;BitmapRequest&gt; mBitmapRequestQueue =</div><div class="line">            new LinkedBlockingQueue&lt;&gt;();</div><div class="line"></div><div class="line">    // 默认的核心数：CPU 核心数 + 1个分发线程数</div><div class="line">    public static int DEFAULT_CORE_NUM =</div><div class="line">            Runtime.getRuntime().availableProcessors() + 1;</div><div class="line">    private int mDispatcherNum;</div><div class="line">    private RequestDispatcher[] mDispatchers = null;</div><div class="line"></div><div class="line">    protected RequestQueue() &#123;</div><div class="line">        this(DEFAULT_CORE_NUM);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected RequestQueue(int coreNum) &#123;</div><div class="line">        mDispatcherNum = coreNum;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 维护线程池</div><div class="line">    private final void startDispatchers() &#123;</div><div class="line">        mDispatchers = new RequestDispatcher[mDispatcherNum];</div><div class="line">        for (int i = 0; i &lt; mDispatcherNum; i++) &#123;</div><div class="line">            mDispatchers[i] = new RequestDispatcher(mBitmapRequestQueue);</div><div class="line">            mDispatchers[i].start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void start() &#123;</div><div class="line">        stop();</div><div class="line">        startDispatchers();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void stop() &#123;</div><div class="line">        if (mDispatchers != null &amp;&amp; mDispatchers.length &gt; 0) &#123;</div><div class="line">            for (int i = 0; i &lt; mDispatchers.length; i++) &#123;</div><div class="line">                mDispatchers[i].interrupt();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void addRequest(BitmapRequest request) &#123;</div><div class="line">        if (!mBitmapRequestQueue.contains(request)) &#123;</div><div class="line">            mBitmapRequestQueue.add(request);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>RequestQueue 维护一个请求队列和线程池，在添加加载请求之前必须调用 start 方法来初始化线程池并启动各个线程。</p><p>ImageLoader.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line">    // ImageLoader 实例</div><div class="line">    private static ImageLoader sInstance;</div><div class="line">    // 图片内存缓存</div><div class="line">    private ImageCache mImageCache = new ImageCache();</div><div class="line">    // 网络请求队列</div><div class="line">    private RequestQueue mImageQueue;</div><div class="line"></div><div class="line">    private ImageLoader() &#123;&#125;</div><div class="line">    </div><div class="line">    public static ImageLoader getInstance() &#123;</div><div class="line">        if (sInstance == null) &#123;</div><div class="line">            synchronized (ImageLoader.class) &#123;</div><div class="line">                if (sInstance == null) &#123;</div><div class="line">                    sInstance = new ImageLoader();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ImageLoader init() &#123;</div><div class="line">        mImageQueue = new RequestQueue();</div><div class="line">        mImageQueue.start();</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ImageCache getCache() &#123;</div><div class="line">        return mImageCache;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void displayImage(String uri, ImageView imageView) &#123;</div><div class="line">        BitmapRequest request = new BitmapRequest(imageView, uri);</div><div class="line">        mImageQueue.addRequest(request);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String url1 = &quot;https://mtl.gzhuibei.com/images/img/19816/1.jpg&quot;;</div><div class="line">String url2 = &quot;https://mtl.gzhuibei.com/images/img/19816/5.jpg&quot;;</div><div class="line">ImageLoader loader = ImageLoader.getInstance();</div><div class="line">loader.init().displayImage(url1, imageView1);</div><div class="line">loader.displayImage(url2, imageView2);</div></pre></td></tr></table></figure></p><h3 id="三、请求策略"><a href="#三、请求策略" class="headerlink" title="三、请求策略"></a>三、请求策略</h3><p>在上面实现的代码中，加载请求会被封装成一个 Request 对象添加到请求队列中，默认情况下 ImageLoader 会按照先后顺序加载图片。但是现实中，我们可能需要最后添加到队列的请求先被执行。例如，在滚动 ListView 时，最后一项肯定是最晚被加载的，此时它却显示在屏幕上的，而其它优先被加载的请求却不在屏幕显示范围。当需求是在屏幕上显示的 Item View 的图片优先被加载，我们就需要 ImageLoader 支持从请求队列的尾部开始加载。也就是，这里至少需要两种策略。</p><p>依照策略模式，代码实现如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 加载策略接口</div><div class="line"> */</div><div class="line">public interface LoadPolicy &#123;</div><div class="line">    int compare(BitmapRequest request1, BitmapRequest request2);</div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> * 顺序加载策略</div><div class="line"> */</div><div class="line">public class SerialPolicy implements LoadPolicy &#123;</div><div class="line">    @Override</div><div class="line">    public int compare(BitmapRequest request1, BitmapRequest request2) &#123;</div><div class="line">        return request1.serialNum - request2.serialNum;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> * 逆序加载策略</div><div class="line"> */</div><div class="line">public class ReversePolicy implements LoadPolicy &#123;</div><div class="line">    @Override</div><div class="line">    public int compare(BitmapRequest request1, BitmapRequest request2) &#123;</div><div class="line">        return request2.serialNum - request1.serialNum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>首先定义了一个 LoadPolicy 接口，在这个接口中有一个 compare 方法，用来对比两个请求。我们默认实现了顺序加载、逆序加载两个策略，因为每个请求都要有一个序列号，这个序列号以递增的形式增长，越晚加入队列的请求序列号越大，而我们的请求队列也必须是优先级队列；为实现对这些请求的排序处理，我们需要在图片加载请求类中实现 Comparable 接口。</p><p>使用 AtomicInteger 类给每一个请求分配一个序列号，再使用优先级队列（PriorityBlockingQueue）来维持图片加载队列，PriorityBlockingQueue 会根据 BitmapRequest 的 compare 策略来决定 BitmapRequest 的顺序。RequestQueue 内部会启动用户指定数量的线程来从请求队列中读取请求，分发线程不断地从队列中读取请求，然后进行图片加载处理。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class RequestQueue &#123;</div><div class="line">    // 请求队列 [ Thread-safe ]</div><div class="line">    private BlockingQueue&lt;BitmapRequest&gt; mBitmapRequestQueue =</div><div class="line">            new PriorityBlockingQueue&lt;&gt;();</div><div class="line">    // 请求的序列化生成器</div><div class="line">    private AtomicInteger mSerialNumGenerator = new AtomicInteger(0);</div><div class="line"></div><div class="line">    // 代码省略...</div><div class="line"></div><div class="line">    public void addRequest(BitmapRequest request) &#123;</div><div class="line">        if (!mBitmapRequestQueue.contains(request)) &#123;</div><div class="line">            request.serialNum = this.generateSerialNumber();</div><div class="line">            mBitmapRequestQueue.add(request);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 为每个请求生成一个系列号</div><div class="line">    private int generateSerialNumber() &#123;</div><div class="line">        return mSerialNumGenerator.incrementAndGet();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>BitmapRequest 增加请求序列号（serialNum）和加载策略（mLoadPolicy），并实现 Comparable 接口中的 compareTo 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">public class BitmapRequest implements Comparable&lt;BitmapRequest&gt; &#123;</div><div class="line"></div><div class="line">    // 代码省略...</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 请求序列号</div><div class="line">     */</div><div class="line">    public int serialNum = 0;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 加载策略</div><div class="line">     */</div><div class="line">    public LoadPolicy mLoadPolicy = new SerialPolicy();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int compareTo(BitmapRequest another) &#123;</div><div class="line">        return mLoadPolicy.compare(this, another);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int hashCode() &#123;</div><div class="line">        final int prime = 31;</div><div class="line">        int result = 1;</div><div class="line">        result = prime * result + ((imageUri == null) ? 0 : imageUri.hashCode());</div><div class="line">        result = prime * result + ((imageView == null) ? 0 : imageView.hashCode());</div><div class="line">        result = prime * result + serialNum;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean equals(Object obj) &#123;</div><div class="line">        if (this == obj)</div><div class="line">            return true;</div><div class="line">        if (obj == null)</div><div class="line">            return false;</div><div class="line">        if (getClass() != obj.getClass())</div><div class="line">            return false;</div><div class="line">        BitmapRequest other = (BitmapRequest) obj;</div><div class="line">        if (imageUri == null) &#123;</div><div class="line">            if (other.imageUri != null)</div><div class="line">                return false;</div><div class="line">        &#125; else if (!imageUri.equals(other.imageUri))</div><div class="line">            return false;</div><div class="line">        if (imageView == null) &#123;</div><div class="line">            if (other.imageView != null)</div><div class="line">                return false;</div><div class="line">        &#125; else if (!imageView.equals(other.imageView))</div><div class="line">            return false;</div><div class="line">        if (serialNum != other.serialNum)</div><div class="line">            return false;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>向外部提供设置请求加载接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line"></div><div class="line">    // 代码省略...</div><div class="line"></div><div class="line">    // 请求加载策略</div><div class="line">    private LoadPolicy mLoadPolicy;</div><div class="line"></div><div class="line">    public ImageLoader init() &#123;</div><div class="line">        init(new SerialPolicy());</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ImageLoader init(LoadPolicy policy) &#123;</div><div class="line">        mLoadPolicy = policy;</div><div class="line">        mImageQueue = new RequestQueue();</div><div class="line">        mImageQueue.start();</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void displayImage(String uri, ImageView imageView) &#123;</div><div class="line">        BitmapRequest request = new BitmapRequest(imageView, uri);</div><div class="line">        request.mLoadPolicy = mLoadPolicy;</div><div class="line">        mImageQueue.addRequest(request);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们在 init 方法中初始化了加载策略配置信息，后续我们额外提供配置参数，如加载中的图片、加载失败的图片、缓存策略等等，那么要重载多少个 init 方法？如果提供 setter 和 getter 方法，那么这些方法是不是都在 displayImage 方法调用之前调用？</p><h3 id="四、配置参数"><a href="#四、配置参数" class="headerlink" title="四、配置参数"></a>四、配置参数</h3><hr><p>前文提到 ImageLoader 初始化配置参数是，无论是重载 init 方法还是使用多个 setter 方法，都会使得用户的使用成本很高。暴露过多函数，会让用户在每次调用函数时都要仔细选择，还要把握函数调用时机。比如在已经初始化了一个指定线程数量的线程池的情况下，用户再调用 setThreadCount 时应该如何处理呢？为此我们需要对程序做一些限制，让用户只能在初始化时配置这些参数。</p><p>要封装参数，还要考虑初始化顺序等问题，只像 BitmapRequest 那样简单的封装参数是不行的。我们可以使用 Builder 模式来构建一个不可变的配置对象，并且将这个对象注入到 ImageLoader 中，也就是说它只能在构建时设置各个参数，一旦你调用 build() 或者类似方法构建对象后，它的属性就不可再修改，因为它没有 setter 方法，字段也都是隐藏的，用户只能在初始化时一次性构建这个配置对象，然后注入给 ImageLoader，ImageLoader 根据配置对象进行初始化。这样，像 setThreadCount、setLoadPolicy 等方法就不需要出现在 ImageLoader 中了，用户可见的函数就会少很多，ImageLoader 的使用成本也随之降低了。</p><p>修改后的 ImageLoader，其代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line"></div><div class="line">    // ...</div><div class="line"></div><div class="line">    // 图片加载配置对象</div><div class="line">    private ImageLoaderConfig mConfig;</div><div class="line"></div><div class="line">    public void init(ImageLoaderConfig config) &#123;</div><div class="line">        mConfig = config;</div><div class="line">        mCache = mConfig.imageCache;</div><div class="line">        checkConfig();</div><div class="line">        mImageQueue = new RequestQueue(mConfig.threadCount);</div><div class="line">        mImageQueue.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void checkConfig() &#123;</div><div class="line">        if (mConfig == null) &#123;</div><div class="line">            throw new RuntimeException(&quot;The config of SimpleImageLoader &quot; +</div><div class="line">                    &quot;is Null, please call the init(ImageLoaderConfig &quot; +</div><div class="line">                    &quot;config) method to initialize&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mConfig.loadPolicy == null) &#123;</div><div class="line">            mConfig.loadPolicy = new SerialPolicy();</div><div class="line">        &#125;</div><div class="line">        if (mCache == null) &#123;</div><div class="line">            mCache = new ImageCache();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其中的参数设置代码都封装到了 ImageLoaderConfig 和 Builder 对象中，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">public class ImageLoaderConfig &#123;</div><div class="line">    // 图片缓存配置对象</div><div class="line">    ImageCache imageCache = new ImageCache();</div><div class="line">    // 图片加载中显示的图片 id</div><div class="line">    int loadingImageId;</div><div class="line">    // 加载失败时显示的图片 id</div><div class="line">    int loadFailedImageId;</div><div class="line">    // 图片加载策略</div><div class="line">    LoadPolicy loadPolicy;</div><div class="line">    // 线程数量，默认为 CPU 数量 + 1</div><div class="line">    int threadCount = Runtime.getRuntime().availableProcessors() + 1;</div><div class="line"></div><div class="line">    private ImageLoaderConfig() &#123;&#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 配置类的 Builder</div><div class="line">     */</div><div class="line">    public static class Builder &#123;</div><div class="line">        // 图片缓存配置对象</div><div class="line">        ImageCache imageCache = new ImageCache();</div><div class="line">        // 图片加载中显示的图片 id</div><div class="line">        int loadingImageId;</div><div class="line">        // 加载失败时显示的图片 id</div><div class="line">        int loadFailedImageId;</div><div class="line">        // 图片加载策略</div><div class="line">        LoadPolicy loadPolicy;</div><div class="line">        // 线程数量，默认为 CPU 数量 + 1</div><div class="line">        int threadCount = Runtime.getRuntime().availableProcessors() + 1;</div><div class="line"></div><div class="line">        // 设置缓存</div><div class="line">        public Builder setCache(ImageCache imageCache) &#123;</div><div class="line">            this.imageCache = imageCache;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        // 设置正在加载中显示的图片</div><div class="line">        public Builder setLoadingImageId(int loadingImageId) &#123;</div><div class="line">            this.loadingImageId = loadingImageId;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        // 设置要加载的图片失败时显示的图片</div><div class="line">        public Builder setLoadFailedImageId(int loadingFailedImageId) &#123;</div><div class="line">            this.loadFailedImageId = loadingFailedImageId;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        // 设置加载策略</div><div class="line">        public Builder setLoadPolicy(LoadPolicy loadPolicy) &#123;</div><div class="line">            this.loadPolicy = loadPolicy;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        // 设置线程数量</div><div class="line">        public Builder setThreadCount(int threadCount) &#123;</div><div class="line">            this.threadCount = threadCount;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        void applyConfig(ImageLoaderConfig config) &#123;</div><div class="line">            config.imageCache = this.imageCache;</div><div class="line">            config.loadingImageId = this.loadingImageId;</div><div class="line">            config.loadFailedImageId = this.loadFailedImageId;</div><div class="line">            config.loadPolicy = this.loadPolicy;</div><div class="line">            config.threadCount = this.threadCount;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public ImageLoaderConfig create() &#123;</div><div class="line">            ImageLoaderConfig config = new ImageLoaderConfig();</div><div class="line">            applyConfig(config);</div><div class="line">            return config;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通过 ImageLoaderConfig 的构造函数、字段包级私有化，使得外部不能访问内部属性，用户唯一能够设置属性的地方就是通过 Builder 对象了，也就是说用户只能通过 Builder 对象构造 ImageLoaderConfig 对象，这就是构建和表示相分离。</p><p>用户的使用代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">String url1 = &quot;https://mtl.gzhuibei.com/images/img/19816/1.jpg&quot;;</div><div class="line">String url2 = &quot;https://mtl.gzhuibei.com/images/img/19816/5.jpg&quot;;</div><div class="line">ImageLoader loader = ImageLoader.getInstance();</div><div class="line">ImageLoaderConfig config = new ImageLoaderConfig.Builder()</div><div class="line">        .setThreadCount(4)</div><div class="line">        .setCache(new ImageCache())</div><div class="line">        .setLoadPolicy(new ReversePolicy())</div><div class="line">        .setLoadingImageId(R.drawable.loading)</div><div class="line">        .setLoadFailedImageId(R.drawable.not_found)</div><div class="line">        .create();</div><div class="line">loader.init(config);</div><div class="line">loader.displayImage(url1, imageView1);</div><div class="line">loader.displayImage(url2, imageView2);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-631b2a4e4de2e2b7.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01 ImageLoader 基础框架</title>
      <link href="/1902/01/01/06%20THIRD%20PARY%20FRAMEWORK/01%20ImageLoader%20%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/"/>
      <url>/1902/01/01/06%20THIRD%20PARY%20FRAMEWORK/01%20ImageLoader%20%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-26d7ceae40eb0bb9?imageMogr2/auto-orient/strip" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1902/01/01/03IMAGE%20LOADER/01%20ImageLoader%20基础框架/" target="_blank" rel="external">01 基础框架</a><br><a href="https://xianxiaotao.github.io/1902/01/02/03IMAGE%20LOADER/02%20ImageLoader%20请求队列/" target="_blank" rel="external">02 请求队列</a><br><a href="https://xianxiaotao.github.io/1902/01/03/03IMAGE%20LOADER/03%20ImageLoader%20三级缓存/" target="_blank" rel="external">03 三级缓存</a><br><a href="https://xianxiaotao.github.io/1902/01/04/03IMAGE%20LOADER/04%20ImageLoader%20图片加载/" target="_blank" rel="external">04 图片加载</a><br><a href="https://xianxiaotao.github.io/1902/01/05/03IMAGE%20LOADER/05%20ImageLoader%20常见问题/" target="_blank" rel="external">05 常见问题</a><br><a href="https://xianxiaotao.github.io/1902/01/06/03IMAGE%20LOADER/06%20ImageLoader%20项目源码/" target="_blank" rel="external">06 项目源码</a></p></blockquote><p>搭建项目，无非两个思路。一般情况下都是由上而下、从抽象到具体、先搭框架再实现细节，但是对人员的综合素养要求很高。我们选择另一条相反的思路，由下而上从细节到框架。等到对设计模式、组织架构等知识有一定的理解和实践经验之后，再在实际项目中采用第一种思路。</p><p>现在我们就拿使用范围广、难度也适中的图片加载器（ImageLoader）作为训练项目。</p><h3 id="一、核心功能"><a href="#一、核心功能" class="headerlink" title="一、核心功能"></a>一、核心功能</h3><hr><p>如果仅仅是为了实现加载图片的功能，那么下面的代码完全满足：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 图片加载类</div><div class="line"> * @author xianxiaotao</div><div class="line"> */</div><div class="line">public class ImageLoader &#123;</div><div class="line"></div><div class="line">    // UI Handler</div><div class="line">    private Handler mUiHandler = new Handler(Looper.getMainLooper());</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 加载图片并显示</div><div class="line">     * @param url       图片地址</div><div class="line">     * @param imageView 显示图片控件</div><div class="line">     */</div><div class="line">    public void displayImage(final String url, final ImageView imageView) &#123;</div><div class="line">        if (TextUtils.isEmpty(url) || null == imageView) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                final Bitmap bitmap = downloadImage(url);</div><div class="line">                if (null == bitmap) &#123;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">                updateImageView(imageView, bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 加载网络图片</div><div class="line">     * @param imageUrl 图片地址</div><div class="line">     * @return Bitmap</div><div class="line">     */</div><div class="line">    private Bitmap downloadImage(String imageUrl) &#123;</div><div class="line">        if (TextUtils.isEmpty(imageUrl)) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Bitmap bitmap = null;</div><div class="line">        try &#123;</div><div class="line">            URL url = new URL(imageUrl);</div><div class="line">            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 更新视图控件，显示图片</div><div class="line">     * @param imageView ImageView</div><div class="line">     * @param bitmap    Bitmap</div><div class="line">     */</div><div class="line">    private void updateImageView(final ImageView imageView, final Bitmap bitmap) &#123;</div><div class="line">        if (null == imageView || null == bitmap) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mUiHandler.post(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                imageView.setImageBitmap(bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String url = &quot;https://mtl.gzhuibei.com/images/img/19816/1.jpg&quot;;</div><div class="line">ImageLoader loader = new ImageLoader();</div><div class="line">loader.displayImage(url, imageView);</div></pre></td></tr></table></figure></p><p>效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-43b782941fa12c9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>实际开发过程中，往往不是只加载一张图就完事了，而是以列表的形式展现给用户，所以我们就需要考虑图片加载速度，节省用户流量，防止大图片引发 OOM，多线程等问题。</p><p>我们先对上面的示例增加内存缓存和线程池功能，内存缓存直接使用 ANDROID 提供的 LruCache 类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line"></div><div class="line">    // 图片内存缓存</div><div class="line">    private LruCache&lt;String, Bitmap&gt; mImageCache;</div><div class="line">    // 线程池，线程数量为 CPU 的数量</div><div class="line">    private ExecutorService mExecutorService = Executors.newFixedThreadPool(</div><div class="line">            Runtime.getRuntime().availableProcessors());</div><div class="line"></div><div class="line">    // UI Handler</div><div class="line">    private Handler mUiHandler = new Handler(Looper.getMainLooper());</div><div class="line"></div><div class="line">    public ImageLoader() &#123;</div><div class="line">        initImageCache();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 初始化缓存大小：取四分之一的可用内存作为缓存。</div><div class="line">     */</div><div class="line">    private void initImageCache() &#123;</div><div class="line">        int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);</div><div class="line">        int cacheSize = maxMemory / 4;</div><div class="line">        mImageCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class="line">            @Override</div><div class="line">            protected int sizeOf(String key, Bitmap bitmap) &#123;</div><div class="line">                return bitmap.getRowBytes() * bitmap.getHeight() / 1024;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 加载图片并显示</div><div class="line">     * @param url       图片地址</div><div class="line">     * @param imageView 显示图片控件</div><div class="line">     */</div><div class="line">    public void displayImage(final String url, final ImageView imageView) &#123;</div><div class="line">        if (TextUtils.isEmpty(url) || null == imageView) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 先从内存中读取</div><div class="line">        Bitmap bmp = mImageCache.get(url);</div><div class="line">        if (null != bmp) &#123;</div><div class="line">            imageView.setImageBitmap(bmp);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 内存中没有，去加载网络图片</div><div class="line">        imageView.setTag(url);</div><div class="line">        mExecutorService.submit(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                final Bitmap bitmap = downloadImage(url);</div><div class="line">                if (null == bitmap) &#123;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">                if (url.equals(imageView.getTag())) &#123;</div><div class="line">                    updateImageView(imageView, bitmap);</div><div class="line">                &#125;</div><div class="line">                mImageCache.put(url, bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 加载网络图片</div><div class="line">     * @param imageUrl 图片地址</div><div class="line">     * @return Bitmap</div><div class="line">     */</div><div class="line">    private Bitmap downloadImage(String imageUrl) &#123;</div><div class="line">        if (TextUtils.isEmpty(imageUrl)) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Bitmap bitmap = null;</div><div class="line">        try &#123;</div><div class="line">            URL url = new URL(imageUrl);</div><div class="line">            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 更新视图控件，显示图片</div><div class="line">     * @param imageView ImageView</div><div class="line">     * @param bitmap    Bitmap</div><div class="line">     */</div><div class="line">    private void updateImageView(final ImageView imageView, final Bitmap bitmap) &#123;</div><div class="line">        if (null == imageView || null == bitmap) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mUiHandler.post(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                imageView.setImageBitmap(bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>到目前为止，我们的 ImageLoader 中含有线程池、缓存系统、网络请求等，很消耗资源。因此，没有理由让它构造多个实例。使用单例模式来保证 ImageLoader 类只有一个实例存在。代码改造如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line">    // ImageLoader 实例</div><div class="line">    private static ImageLoader sInstance;</div><div class="line"></div><div class="line">    private ImageLoader() &#123;&#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取ImageLoader单例</div><div class="line">     * @return ImageLoader</div><div class="line">     */</div><div class="line">    public static ImageLoader getInstance() &#123;</div><div class="line">        if (sInstance == null) &#123;</div><div class="line">            synchronized (ImageLoader.class) &#123;</div><div class="line">                if (sInstance == null) &#123;</div><div class="line">                    sInstance = new ImageLoader();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 代码省略...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>现在我们再审视代码，发现 ImageLoader 的内存缓存、多线程、网络加载等功能之间严重耦合，缓存相关逻辑、图片加载显示逻辑、多线程切换逻辑严重混淆在一起。如果我们要对内存缓存功能进行扩展优化，实现二级缓存，那么我们只能在 ImageLoader 类修改，还要保证不影响其他功能。这样，随着功能的增多，ImageLoader 类会越来越大，代码也越来越复杂，更别谈扩展性、灵活性。</p><p>必须对 ImageLoader 进行拆分，让各个功能独立出来。比如内存初始化、存取逻辑可以单独抽出缓存类来 ImageCache；下载网络图片逻辑也是一样处理。</p><h3 id="二、职责拆分"><a href="#二、职责拆分" class="headerlink" title="二、职责拆分"></a>二、职责拆分</h3><hr><h4 id="ImageCache"><a href="#ImageCache" class="headerlink" title="ImageCache"></a>ImageCache</h4><p>首先我们先把 ImageCache 类拆分出来，它负责缓存相关的职责，比如初始化缓存大小，并提供存（put）、取（get）、移除（remove）接口。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">// 缓存类</div><div class="line">public class ImageCache &#123;</div><div class="line">    private static final int ONE_KB = 1024;</div><div class="line">    private static final int MAX_MEMORY_PERCENT = 4;</div><div class="line"></div><div class="line">    // 图片内存缓存</div><div class="line">    private LruCache&lt;String, Bitmap&gt; mImageCache;</div><div class="line"></div><div class="line">    public ImageCache() &#123;</div><div class="line">        initImageCache();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 初始化缓存大小：取四分之一的可用内存作为缓存。</div><div class="line">    private void initImageCache() &#123;</div><div class="line">        int maxMemory = (int) (Runtime.getRuntime().maxMemory() / ONE_KB);</div><div class="line">        int cacheSize = maxMemory / MAX_MEMORY_PERCENT;</div><div class="line">        mImageCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class="line">            @Override</div><div class="line">            protected int sizeOf(String key, Bitmap bitmap) &#123;</div><div class="line">                return bitmap.getRowBytes() * bitmap.getHeight() / ONE_KB;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void put(String key, Bitmap value) &#123;</div><div class="line">        mImageCache.put(key, value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Bitmap get(String key) &#123;</div><div class="line">        return mImageCache.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void remove(String key) &#123;</div><div class="line">        mImageCache.remove(key);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其中 LruCache 是线程安全地类，所以在多线程环境中，没有必要对 put、get 等使用 synchronized 关键字进行同步。</p><p>这样一来，ImageLoader 只需要持有 ImageCache 的对象即可，不必关心其中的细节。因为 ImageLoader 是单例对象，那么持有的缓存也是只有一个实例的。那么 ImageLoader 可以向其他功能提供统一的访问接口 getCache()。ImageLoader 需要的修改的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line">    // 图片内存缓存</div><div class="line">    private ImageCache mImageCache = new ImageCache();</div><div class="line"></div><div class="line">    public ImageCache getCache() &#123;</div><div class="line">        return mImageCache;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 代码省略...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="RequestThreadPool"><a href="#RequestThreadPool" class="headerlink" title="RequestThreadPool"></a>RequestThreadPool</h4><p>接下来把异步请求代码块移植到 RequestThreadPool 类中，由 RequestThreadPool 专门负责异步下载。这样 ImageLoader 类就非常简单了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line">    // ImageLoader 实例</div><div class="line">    private static ImageLoader sInstance;</div><div class="line">    // 图片内存缓存</div><div class="line">    private ImageCache mImageCache = new ImageCache();</div><div class="line">    // 线程池</div><div class="line">    private RequestThreadPool mThreadPool = new RequestThreadPool();</div><div class="line"></div><div class="line">    private ImageLoader() &#123;&#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取ImageLoader单例</div><div class="line">     * @return ImageLoader</div><div class="line">     */</div><div class="line">    public static ImageLoader getInstance() &#123;</div><div class="line">        if (sInstance == null) &#123;</div><div class="line">            synchronized (ImageLoader.class) &#123;</div><div class="line">                if (sInstance == null) &#123;</div><div class="line">                    sInstance = new ImageLoader();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ImageCache getCache() &#123;</div><div class="line">        return mImageCache;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 加载图片并显示</div><div class="line">     * @param url       图片地址</div><div class="line">     * @param imageView 显示图片控件</div><div class="line">     */</div><div class="line">    public void displayImage(String url, ImageView imageView) &#123;</div><div class="line">        mThreadPool.addRequest(url, imageView);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>毕竟大部分业务逻辑全迁移到 RequestThreadPool 类中，而 ImageLoader 只作为程序入口。RequestThreadPool 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">public class RequestThreadPool &#123;</div><div class="line"></div><div class="line">    // 线程池，线程数量为 CPU 的数量</div><div class="line">    private ExecutorService mExecutorService = Executors.newFixedThreadPool(</div><div class="line">            Runtime.getRuntime().availableProcessors());</div><div class="line">    // UI Handler</div><div class="line">    private Handler mUiHandler = new Handler(Looper.getMainLooper());</div><div class="line"></div><div class="line">    public void addRequest(final String url, final ImageView imageView) &#123;</div><div class="line">        if (TextUtils.isEmpty(url) || null == imageView) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 先从内存中读取</div><div class="line">        Bitmap bmp = ImageLoader.getInstance().getCache().get(url);</div><div class="line">        if (null != bmp) &#123;</div><div class="line">            imageView.setImageBitmap(bmp);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 内存中没有，去加载网络图片</div><div class="line">        imageView.setTag(url);</div><div class="line">        mExecutorService.submit(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                final Bitmap bitmap = downloadImage(url);</div><div class="line">                if (null == bitmap) &#123;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">                if (url.equals(imageView.getTag())) &#123;</div><div class="line">                    updateImageView(imageView, bitmap);</div><div class="line">                &#125;</div><div class="line">                ImageLoader.getInstance().getCache().put(url, bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 加载网络图片</div><div class="line">     * @param imageUrl 图片地址</div><div class="line">     * @return Bitmap</div><div class="line">     */</div><div class="line">    private Bitmap downloadImage(String imageUrl) &#123;</div><div class="line">        if (TextUtils.isEmpty(imageUrl)) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Bitmap bitmap = null;</div><div class="line">        try &#123;</div><div class="line">            URL url = new URL(imageUrl);</div><div class="line">            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 更新视图控件，显示图片</div><div class="line">     * @param imageView ImageView</div><div class="line">     * @param bitmap    Bitmap</div><div class="line">     */</div><div class="line">    private void updateImageView(final ImageView imageView, final Bitmap bitmap) &#123;</div><div class="line">        if (null == imageView || null == bitmap) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mUiHandler.post(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                imageView.setImageBitmap(bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h4><p>到这里结束了吗？没有，还可以继续拆，拆 RequestThreadPool 类，将其中下载模块拆成一个新类 Loader：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">public class Loader &#123;</div><div class="line"></div><div class="line">    public void load(String url, ImageView imageView) &#123;</div><div class="line">        // 先从内存中读取</div><div class="line">        Bitmap bitmap = ImageLoader.getInstance().getCache().get(url);</div><div class="line">        // 没有就去加载网络图片</div><div class="line">        if (null == bitmap) &#123;</div><div class="line">            bitmap = downloadImage(url);</div><div class="line">            if (null != bitmap) &#123;</div><div class="line">                ImageLoader.getInstance().getCache().put(request, bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 通知界面更新</div><div class="line">        deliveryToUIThread(imageView, bitmap, url);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 加载网络图片</div><div class="line">     * @param imageUrl 图片地址</div><div class="line">     * @return Bitmap</div><div class="line">     */</div><div class="line">    private Bitmap downloadImage(String imageUrl) &#123;</div><div class="line">        if (TextUtils.isEmpty(imageUrl)) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Bitmap bitmap = null;</div><div class="line">        try &#123;</div><div class="line">            URL url = new URL(imageUrl);</div><div class="line">            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 更新视图控件，显示图片</div><div class="line">     * @param imageView ImageView</div><div class="line">     * @param bitmap    Bitmap</div><div class="line">     */</div><div class="line">    private void deliveryToUIThread(final ImageView imageView,</div><div class="line">                                 final Bitmap bitmap, final String url) &#123;</div><div class="line">        if (null != imageView) &#123;</div><div class="line">            imageView.post(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    updateImageView(imageView, bitmap, url);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 更新ImageView</div><div class="line">     */</div><div class="line">    private void updateImageView(ImageView imageView, Bitmap result, String url) &#123;</div><div class="line">        if (result != null &amp;&amp; imageView != null &amp;&amp; !TextUtils.isEmpty(url)</div><div class="line">                &amp;&amp; url.equals(imageView.getTag())) &#123;</div><div class="line">            imageView.setImageBitmap(result);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从上述代码中可以看出 Loader 加载图片的过程有如下几个步骤：</p><ul><li>判断缓存中是否含有该图片;</li><li>如果有则将图片直接投递到UI线程，并且更新UI；</li><li>如果没有缓存，则从对应的地方获取到图片，并且将图片缓存起来，然后再将结果投递给UI线程，更新UI；</li></ul><p>既然 Loader 类承担了下载图片职责，那么 RequestThreadPool 类就只有调度异步任务的职责了，从 ImageLoader 接收到一个图片加载请求之后，创建/分配线程，调用 Loader 提供的接口执行图片加载程序。其代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class RequestThreadPool &#123;</div><div class="line">    // 线程池，线程数量为 CPU 的数量</div><div class="line">    private ExecutorService mExecutorService = Executors.newFixedThreadPool(</div><div class="line">            Runtime.getRuntime().availableProcessors());</div><div class="line"></div><div class="line">    public void addRequest(final String url, final ImageView imageView) &#123;</div><div class="line">        if (TextUtils.isEmpty(url) || null == imageView) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 内存中没有，去加载网络图片</div><div class="line">        imageView.setTag(url);</div><div class="line">        mExecutorService.submit(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                new Loader().load(url, imageView);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里有个问题，线程池每执行一个异步任务，都会创建新的 Loader 对象。很明显这是不合理的，我们可以使用单例模式来优化 Loader 类。代码不再给出，请大家参照 ImageLoader 的单例形式自行编写。</p><p>由一个类拆成 4 个类，虽然避免了将来 ImageLoader 类的臃肿膨胀，但也使得整个系统的变得复杂，这样做值得吗？我只想说，这才刚开始。欲知后事如何，请看下篇文章。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-cf2bb353b2badd7e.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>31 设计模式实际应用一</title>
      <link href="/1901/03/01/02%20DESIGN%20PATTERN/31%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%80/"/>
      <url>/1901/03/01/02%20DESIGN%20PATTERN/31%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-6b53c64493da84ce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="1、扫描二维码"><a href="#1、扫描二维码" class="headerlink" title="1、扫描二维码"></a>1、扫描二维码</h3><hr><p>众所周知，二维码的扫描结果其实就是一个字符串，我们拿到一个结果需要对内容进行校验，是否是我们需要的信息，然后做一些特殊的处理。比如先判断是不是一个url链接，是则打开这个链接，不是的话进行下一种判断，比如是否是项目中的约定的跳转某个功能的信息…依次下去。</p><p>普通的做法是使用 if-else 或者 switch-case，但是当有很多种情况需要处理，则会出现很多的 if-else，并且每增加一种处理，就需要改动代码新增一个 else，一点也不优雅。</p><p>这种情况其实可以使用责任链的模式来处理。</p><p>我们首先定义一个抽象类，封装一下通用逻辑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">public abstract class QRHandler &#123;</div><div class="line">    public QRHandler next;</div><div class="line">    Context context;</div><div class="line"></div><div class="line">    public QRHandler(Context context) &#123;</div><div class="line">        this(context, null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public QRHandler(Context context, QRHandler next) &#123;</div><div class="line">        this.next = next;</div><div class="line">        this.context = context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 对外暴露的调用方法</div><div class="line">     * @param msg</div><div class="line">     */</div><div class="line">    public final void handleRequest(String msg) &#123;</div><div class="line">        if (canHandle(msg)) &#123;</div><div class="line">            handle(msg);</div><div class="line">        &#125; else &#123;</div><div class="line">            passToNext(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void passToNext(String msg) &#123;</div><div class="line">        if (next != null) &#123;</div><div class="line">            next.handleRequest(msg);</div><div class="line">        &#125; else &#123;</div><div class="line">            onNotHandled(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void onNotHandled(String msg) &#123;</div><div class="line">        // 当无法处理结果，且没有下一个处理者时</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 处理的实现</div><div class="line">     * @param msg</div><div class="line">     */</div><div class="line">    protected abstract void handle(String msg);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 是否能够处理这个msg</div><div class="line">     * @param msg </div><div class="line">     * @return true or false</div><div class="line">     */</div><div class="line">    protected abstract boolean canHandle(String msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>即调用 handleRequest 后，先通过 canHandle 判断需要处理这个信息，是的话则调用 handle(String msg) 自己处理，否的话交给下一个 Handler 处理，没有下一个则调用 onNotHandled(String msg) 触发兜底逻辑。</p><p>其次根据需要，实现对应的处理者，如匹配链接跳转页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class URLHandler extends QRHandler &#123;</div><div class="line">    public URLHandler(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public URLHandler(Context context, QRHandler next) &#123;</div><div class="line">        super(context, next);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void handle(String msg) &#123;</div><div class="line">        Intent intent = new Intent();</div><div class="line">        intent.setAction(Intent.ACTION_VIEW);</div><div class="line">        Uri contentUrl = Uri.parse(msg);</div><div class="line">        intent.setData(contentUrl);</div><div class="line">        context.startActivity(intent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected boolean canHandle(String msg) &#123;</div><div class="line">        return RxRegTool.isURL(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>最后将处理者连接成链，调用链头的 Handler 开始处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public interface QRParser &#123;</div><div class="line">    void parser(String msg);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">public class QRParserImpl implements QRParser &#123;</div><div class="line">    private QRHandler start;</div><div class="line"></div><div class="line">    private QRParserImpl(Context context) &#123;</div><div class="line">        // 倒叙处理顺序</div><div class="line">        ...</div><div class="line">        URLHandler urlHandler = new URLHandler(context, lockerHandler);</div><div class="line">        InvoiceHandler invoiceHandler = new InvoiceHandler(context, urlHandler);</div><div class="line">        PrintHandler printHandler = new PrintHandler(context, invoiceHandler);</div><div class="line">        start = new Base64Handler(context, printHandler);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static QRParserImpl getInstance(Context context) &#123;</div><div class="line">        return new QRParserImpl(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void parser(String msg) &#123;</div><div class="line">        start.handleRequest(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用这种方式降低耦合度，便于拓展，提高代码灵活性。<br>之后如果新增加一种处理，只需要在增加对应的实现类，并添加到责任链中即可。对于处理优先级也可以通过改变责任链的顺序实现。任何改变都只需要变动责任链的初始化过程。</p><h3 id="2、登录迭代"><a href="#2、登录迭代" class="headerlink" title="2、登录迭代"></a>2、登录迭代</h3><hr><p>以登陆为例，比如外层需要调用一个 LoginService 进行登录，LoginService 又需要调用其他的 service 来进行比如密码校验，权限校验之类的操作。时序图见下：</p><p><img src="https://upload-images.jianshu.io/upload_images/15439830-688f3266c630f75e.png?imageMogr2/auto-orient/strip|imageView2/2/w/636/format/webp" alt="登录时序图"></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>有需求来了，增加指纹登录类型、增加校验内容，我们的 LoginService 显然必须要同步改变。具体就是，逻辑内部可能需要增加很多的 if-else，以及一些新的外部依赖。这么做，第一，违反开闭原则，测试难度加大，需要回归整个登录功能。第二，上线后如何生产验证？发现问题怎么办？只能回滚。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>工厂方法模式<br><img src="https://upload-images.jianshu.io/upload_images/15439830-93d79c08179fbdab.png?imageMogr2/auto-orient/strip|imageView2/2/w/884/format/webp" alt="工厂方法"></p><p>在设计时，增加 LoginServiceFactory，按照一定的规则，生成 LoginService，比如此图，LoginServiceV1 和 LoginServiceV2 都实现 LoginService 接口，client 调用 LoginService 接口即可，由 LoginServiceFactory 决定真正调用那个版本的 login 方法。</p><p>好处：增加新的 LoginService 实现时不用改之前的 LoginService 代码，降低测试难度。第二，上线后可以流控进行生产验证，发现问题，关闭即可，无需回滚，因为流控逻辑写在 LoginServiceFactory中。</p><h3 id="3、下单校验"><a href="#3、下单校验" class="headerlink" title="3、下单校验"></a>3、下单校验</h3><hr><p>以下单为例，我们的下单方法 OrderService 中，需要去调用其他一系列的服务来进行下单校验，比如限额校验，库存校验，权限校验。所有校验都通过，才能下单成功，时序图见下：</p><p><img src="https://upload-images.jianshu.io/upload_images/15439830-7744329379cf1c49.png?imageMogr2/auto-orient/strip|imageView2/2/w/828/format/webp" alt="下单时序图"></p><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>有需求来了，需要新增一些校验，或者下单环节增加了其他的外部依赖。那么我们的 OrderService 是不是需要同步的增加逻辑呢？随着业务的迭代，OrderService 会变的越来越臃肿。</p><h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p>责任链模式。</p><p><img src="https://upload-images.jianshu.io/upload_images/15439830-732871c825680e6a.png?imageMogr2/auto-orient/strip|imageView2/2/w/618/format/webp" alt=""></p><p>所有的校验都实现 orderFilter，形成一个 orderFilterList（责任链），新增或者删除某个校验的时候，只需要新增或者删除这个实现，同时维护这个责任链即可，维护这个责任链的同时不改代码的方式有：使用配置文件、初始化的时候动态的初始化责任链。</p><blockquote><p>注意，一般情况下使用责任链的场景是将处理对象连城一条链，并沿着这条链传递请求，直到有对象处理它为止。而我们这需要所有的对象都要处理并且校验通过。</p></blockquote><h3 id="4、下单流程"><a href="#4、下单流程" class="headerlink" title="4、下单流程"></a>4、下单流程</h3><hr><p>以下单为例，可能每个下单都需要经过，订单校验，订单落地，真正下单，失败处理等流程。</p><p>可以使用模版方法，首先将流程固定，其次将一些共用的逻辑抽取到模板方法里面。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b010a8f6aef522af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="5、条件判断"><a href="#5、条件判断" class="headerlink" title="5、条件判断"></a>5、条件判断</h3><p>这种代码经常可以见到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if (a) &#123;</div><div class="line">    handleA();</div><div class="line">&#125; else if(b) &#123;</div><div class="line">    handleB();</div><div class="line">&#125; else if(c) &#123;</div><div class="line">    handleC();</div><div class="line">&#125; else &#123;</div><div class="line">    handleD();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>随着时间的推移，需求的迭代，每一个分支会越来越来复杂，造成整体代码可读性变差。根据实际情况，可以使用策略模式或者责任链模式解决这个问题。责任链模式见前面案例。</p><p><img src="https://upload-images.jianshu.io/upload_images/15439830-d41a7f2a401af09a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt=""></p><p>参考链接：<br><a href="https://www.jianshu.com/p/22e8bb4fc737" target="_blank" rel="external">https://www.jianshu.com/p/22e8bb4fc737</a><br><a href="https://www.jianshu.com/p/0a8d84bf1ff1" target="_blank" rel="external">https://www.jianshu.com/p/0a8d84bf1ff1</a></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7a59dc481b10779b.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23 设计模式——桥接模式</title>
      <link href="/1901/02/03/02%20DESIGN%20PATTERN/23%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/1901/02/03/02%20DESIGN%20PATTERN/23%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-079023a47c871682.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>桥接（Bridge）模式：<strong>将抽象部分与实现部分分离，使它们都可以独立的变化</strong>。</p><p>在现实生活中，某些类具有两个或多个维度的变化，如图形既可按形状分，又可按颜色分。如何设计类似于 Photoshop 这样的软件，能画不同形状和不同颜色的图形呢？如果用继承方式，m 种形状和 n 种颜色的图形就有 m×n 种，不但对应的子类很多，而且扩展困难。</p><p>当然，这样的例子还有很多，如不同颜色和字体的文字、不同品牌和功率的汽车、不同性别和职业的男女、支持不同平台和不同文件格式的媒体播放器等。如果用桥接模式就能很好地解决这些问题。</p><p>当一个类存在两个独立变化的纬度，且这两个纬度都需要进行扩展，我们可以使用桥接模式。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>由于抽象与实现分离，所以扩展能力强；</li><li>其实现细节对客户透明。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>一个类存在两个或以上的独立维度的变化，且这些维度都需要进行拓展。</li><li>不希望使用继承或因为多层次继承导致类的个数急剧增加时。</li><li>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，可以通过桥接模式使他们在抽象层建立一个关联关系。</li></ul><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><hr><p>可以将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。</p><p>模式包含以下主要角色。</p><ul><li>Abstraction（抽象部分）：定义抽象类，并包含一个对实现化对象的引用。</li><li>RefinedAbstraction（扩展抽象部分）：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li><li>Implementor（实现部分）：定义实现化角色的接口，供扩展抽象化角色调用。</li><li>ConcreteImplementor（实现部分的具体实现）：给出实现化角色接口的具体实现。</li></ul><p>其结构图如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8298629-0ac6cb97b5dc1c6f.png?imageMogr2/auto-orient/strip|imageView2/2/w/893/format/webp" alt=""></p><p>Abstraction 和 Implementor 就是两个独立纬度变化的类，Implementor 相对于 Abstraction 是一个聚合的关系，也就是 Abstraction 可能拥有多个 Implementor，模板代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class BridgeTest &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Implementor implementor = new ConcreteImplementor();</div><div class="line">        Abstraction abs = new RefinedAbstraction(implementor);</div><div class="line">        abs.operation();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 实现化角色</div><div class="line">interface Implementor &#123;</div><div class="line">    void operationImpl();</div><div class="line">&#125;</div><div class="line">// 具体实现化角色</div><div class="line">class ConcreteImplementor implements Implementor &#123;</div><div class="line">    public void operationImpl() &#123;</div><div class="line">        System.out.println(&quot;具体实现化(Concrete Implementor)角色被访问&quot; );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 抽象化角色</div><div class="line">abstract class Abstraction &#123;</div><div class="line">    protected Implementor implementor;</div><div class="line">    protected Abstraction(Implementor implementor) &#123;</div><div class="line">        this.implementor = implementor;</div><div class="line">    &#125;</div><div class="line">    public abstract void operation();</div><div class="line">&#125;</div><div class="line">// 扩展抽象化角色</div><div class="line">class RefinedAbstraction extends Abstraction &#123;</div><div class="line">    protected RefinedAbstraction(Implementor implementor) &#123;</div><div class="line">        super(implementor);</div><div class="line">    &#125;</div><div class="line">    public void operation() &#123;</div><div class="line">        System.out.println(&quot;扩展抽象化(Refined Abstraction)角色被访问&quot; );</div><div class="line">        implementor.operationImpl();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>去咖啡馆喝咖啡一般分为 4 种，大杯加糖，大杯不加糖，小杯加糖和小杯不加糖。对于大杯和小杯，加糖和不加糖其实是两个相对独立纬度的变化。面先定一个咖啡类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public abstract class Coffee &#123;</div><div class="line">    protected CoffeeAdditives impl;</div><div class="line"></div><div class="line">    public Coffee(CoffeeAdditives impl) &#123;</div><div class="line">        this.impl = impl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 咖啡具体是什么样的由子类决定</div><div class="line">     */</div><div class="line">    public abstract void makeCoffee();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>CoffeeAdditives 是一种桥接的方式，咖啡分为大杯和小杯，下面继续看看大杯咖啡和小杯咖啡的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class LargeCoffee extends Coffee&#123;</div><div class="line"></div><div class="line">    public LargeCoffee(CoffeeAdditives impl) &#123;</div><div class="line">        super(impl);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void makeCoffee() &#123;</div><div class="line">        System.out.println(&quot;大杯的&quot;+impl.addSomething()+&quot;咖啡&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class SmallCoffee extends Coffee &#123;</div><div class="line">    public SmallCoffee(CoffeeAdditives impl) &#123;</div><div class="line">        super(impl);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void makeCoffee() &#123;</div><div class="line">        System.out.println(&quot;小杯的&quot;+impl.addSomething()+&quot;咖啡&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>至于加糖不加糖我们通过 CoffeeAdditives 这种桥接方式定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public abstract class CoffeeAdditives &#123;</div><div class="line">    public abstract String addSomething();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class Ordinary extends CoffeeAdditives &#123;</div><div class="line">    @Override</div><div class="line">    public String addSomething() &#123;</div><div class="line">        return &quot;原味&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class Sugar extends CoffeeAdditives &#123;</div><div class="line">    @Override</div><div class="line">    public String addSomething() &#123;</div><div class="line">        return &quot;加糖&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>最终调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        // 原汁原味</div><div class="line">        Ordinary ordinary = new Ordinary();</div><div class="line">        // 准备糖类</div><div class="line">        Sugar sugar = new Sugar();</div><div class="line"></div><div class="line">        // 大杯咖啡 原味</div><div class="line">        LargeCoffee largeCoffeeOrdinary = new LargeCoffee(ordinary);</div><div class="line">        largeCoffeeOrdinary.makeCoffee();</div><div class="line">        // 小杯咖啡 原味</div><div class="line">        SmallCoffee smallCoffeeOrdinary = new SmallCoffee(ordinary);</div><div class="line">        smallCoffeeOrdinary.makeCoffee();</div><div class="line">        // 大杯咖啡 加糖</div><div class="line">        LargeCoffee largeCoffeeSugar = new LargeCoffee(sugar);</div><div class="line">        largeCoffeeSugar.makeCoffee();</div><div class="line">        // 小杯咖啡 加糖</div><div class="line">        SmallCoffee smallCoffeeSugar = new SmallCoffee(sugar);</div><div class="line">        smallCoffeeSugar.makeCoffee();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果此时咖啡馆为了满足更多人的习惯，推出中杯的咖啡怎么办呢？对于本例来说，这种需求的变化其实就是 Coffee 类的变化，定义中杯扩展类 MiddleCoffee 类即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class MiddleCoffee extends Coffee &#123;</div><div class="line">    public MiddleCoffee(CoffeeAdditives impl) &#123;</div><div class="line">        super(impl);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void makeCoffee() &#123;</div><div class="line">        System.out.println(&quot;中杯的&quot;+impl.addSomething()+&quot;咖啡&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>同样地，为了增加咖啡类口味的种类，我们也可以让 CoffeeAdditives 类变化起来，增加更多的子类表示，诸如加奶、加蜂蜜等。</p><h3 id="ANDROID-源码中的实现"><a href="#ANDROID-源码中的实现" class="headerlink" title="ANDROID 源码中的实现"></a>ANDROID 源码中的实现</h3><hr><p>比较典型的是 Window 与 WindowManager 之间的关系，它们就用到了桥接这种模式。它们的关系如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-bfdcb127edb1c7ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在 framework 中 Window 和 PhoneWindow 构成窗口的抽象部分，其中 Window 类为该抽象部分的抽象接口，PhoneWindow 为抽象部分具体的实现及扩展。而 WindowManager 则为实现部分的基类，WindowManagerImpl 为实现部分具体的逻辑实现，其使用 WindowManagerGlobal 通过 IWindowManager 接口与 WindowManagerService 进行交互（简称 WMS），并由 WMS 完成具体的窗口管理工作. 如下是 Window 与 WindowManager 桥梁搭建的主要代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public abstract class Window &#123;</div><div class="line">    // 代码省略...</div><div class="line">    public void setWindowManager(WindowManager wm, IBinder appToken, String appName) &#123;</div><div class="line">        setWindowManager(wm, appToken, appName, false);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setWindowManager(WindowManager wm, IBinder appToken, String appName,</div><div class="line">            boolean hardwareAccelerated) &#123;</div><div class="line">        mAppToken = appToken;</div><div class="line">        mAppName = appName;</div><div class="line">        mHardwareAccelerated = hardwareAccelerated</div><div class="line">                || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false);</div><div class="line">        if (wm == null) &#123;</div><div class="line">            wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);</div><div class="line">        &#125;</div><div class="line">        mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);</div><div class="line">    &#125;</div><div class="line">    // 代码省略...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-8915cf69c38d7cc6.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22 设计模式——外观模式</title>
      <link href="/1901/02/02/02%20DESIGN%20PATTERN/22%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/1901/02/02/02%20DESIGN%20PATTERN/22%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d4dfee2cee8d8d6d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>外观（Facade）模式：<strong>要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。外观模式提供一个高层次的接口，使得子系统更易于使用</strong>。</p><p>在开发过程中的运用频率非常高，尤其是在现阶段各种第三方 SDK 充斥在我们的周边，而这些 SDK 很大概率会使用外观模式。通过一个外观类使得整个系统的接口只有一个统一的高层接口，这样能够降低用户的使用成本，也对用户屏蔽了很多实现细节。当然，在我们的开发过程中，外观模式也是我们封装 API 的常用手段，例如网络模块、ImageLoader模块等。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>外观模式是“迪米特法则”的典型应用，主要优点如下：</p><ul><li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li><li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li><li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>不能很好地限制客户使用子系统类。</li><li>增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>为一个复杂的子系统提供一个简单接口，对外隐藏子系统的具体实现、隔离变化。</li><li>使用外观模式可以将一个子系统和使用它的客户端以及其它的子系统分离开来，这就提高了子系统的独立性和可移植性。</li><li>在构建一个层次化结构的时候，可以使用外观模式定义每一个层次对外交互的接口。这样，层与层之间只需要通过外观进行通信，从而简化层与层之间的依赖关系。</li></ul><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><hr><p>模式包含以下主要角色。</p><ul><li>Facade（外观角色）：对外的统一入口。</li><li>Sub System（子系统）：一般由多个子系统构成，负责具体功能的实现。</li></ul><p>其结构图如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-5480c00b909b46a8.gif?imageMogr2/auto-orient/strip" alt=""></p><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class FacadePattern &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Facade f = new Facade();</div><div class="line">        f.method();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 外观角色</div><div class="line">class Facade &#123;</div><div class="line">    private SubSystem01 obj1 = new SubSystem01();</div><div class="line">    private SubSystem02 obj2 = new SubSystem02();</div><div class="line">    private SubSystem03 obj3 = new SubSystem03();</div><div class="line">    public void method() &#123;</div><div class="line">        obj1.method1();</div><div class="line">        obj2.method2();</div><div class="line">        obj3.method3();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 子系统角色</div><div class="line">class SubSystem01 &#123;</div><div class="line">    public  void method1() &#123;</div><div class="line">        System.out.println(&quot;子系统01的method1()被调用！&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 子系统角色</div><div class="line">class SubSystem02 &#123;</div><div class="line">    public  void method2() &#123;</div><div class="line">        System.out.println(&quot;子系统02的method2()被调用！&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 子系统角色</div><div class="line">class SubSystem03 &#123;</div><div class="line">    public  void method3() &#123;</div><div class="line">        System.out.println(&quot;子系统03的method3()被调用！&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>手机就是一个外观模式的例子，它集合了电话功能、短信功能、GPS、拍照等于一身，通过手机你就可以完成各种功能。如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-76e30b4caf60d679.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>下面模拟手机的外观模式实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">public interface Camera &#123;</div><div class="line">    void open();</div><div class="line">    void takePic();</div><div class="line">    void close();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class SamsungCamera implements Camera &#123;</div><div class="line">    @Override</div><div class="line">    public void open() &#123;</div><div class="line">        System.out.println(&quot;打开相机&quot;);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void takePic() &#123;</div><div class="line">        System.out.println(&quot;拍照&quot;);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void close() &#123;</div><div class="line">        System.out.println(&quot;关闭相机&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public interface Phone &#123;</div><div class="line">    // 打电话</div><div class="line">    void dail();</div><div class="line">    // 挂断</div><div class="line">    void hangup();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class PhoneImpl implements Phone&#123;</div><div class="line">    @Override</div><div class="line">    public void dail() &#123;</div><div class="line">        System.out.println(&quot;打电话&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void hangup() &#123;</div><div class="line">        System.out.println(&quot;挂断&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 外观类</div><div class="line">public class MobilePhone &#123;</div><div class="line">    private Phone mPhone = new PhoneImpl();</div><div class="line">    private Camera mCamera = new SamsungCamera();</div><div class="line"></div><div class="line">    public void dail()&#123;</div><div class="line">        mPhone.dail();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void videoChat()&#123;</div><div class="line">        System.out.println(&quot;--&gt;视频聊天接通中&quot;);</div><div class="line">        mCamera.open();</div><div class="line">        mPhone.dail();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void hangup()&#123;</div><div class="line">        mPhone.hangup();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void takePic()&#123;</div><div class="line">        mCamera.open();</div><div class="line">        mCamera.takePic();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void closeCamera()&#123;</div><div class="line">        mCamera.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        MobilePhone nexus6 = new MobilePhone();</div><div class="line">        // 拍照</div><div class="line">        nexus6.videoChat();</div><div class="line">        // 拍照</div><div class="line">        nexus6.takePic();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="ANDROID-源码中的实现"><a href="#ANDROID-源码中的实现" class="headerlink" title="ANDROID 源码中的实现"></a>ANDROID 源码中的实现</h3><hr><p>在用 Android 开发过程中，Context 是最重要的一个类型。Context 只是一个抽象类，它的真正实现在 ContextImpl 类中，ContextImpl 就是今天我们要分析的外观类。</p><p>在应用启动时，首先会 fork 一个子进程，并且调用 ActivityThread 的 main 方法启动该进程。ActivityThread 又会构建 Application 对象，然后和 Activity、ContextImpl 关联起来，最后会调用 Activity 的 onCreate、onStart、onResume 函数使 Activity 运行起来，此时应用的用户界面就呈现在我们面前。</p><p>main 函数会间接地调用 ActivityThread 中的 handleLaunchActivity 函数启动默认的 Activity。handleLaunchActivity 方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public Activity handleLaunchActivity(ActivityClientRecord r, </div><div class="line">                                     PendingTransactionActions pendingActions, </div><div class="line">                                     Intent customIntent) &#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    // 创建并且加载 Activity，调用它的 onCreate</div><div class="line">    final Activity a = performLaunchActivity(r, customIntent);</div><div class="line"></div><div class="line">    if (a != null) &#123;</div><div class="line">        r.createdConfig = new Configuration(mConfiguration);</div><div class="line">        reportSizeConfigurations(r);</div><div class="line">        if (!r.activity.mFinished &amp;&amp; pendingActions != null) &#123;</div><div class="line">            pendingActions.setOldState(r.state);</div><div class="line">            pendingActions.setRestoreInstanceState(true);</div><div class="line">            pendingActions.setCallOnPostCreate(true);</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        // If there was an error, for any reason, tell the activity manager to stop us.</div><div class="line">        try &#123;</div><div class="line">            ActivityManager.getService()</div><div class="line">                    .finishActivity(r.token, Activity.RESULT_CANCELED, null,</div><div class="line">                            Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</div><div class="line">        &#125; catch (RemoteException ex) &#123;</div><div class="line">            throw ex.rethrowFromSystemServer();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>performLaunchActivity 方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    // 构建 ContextImpl</div><div class="line">    ContextImpl appContext = createBaseContextForActivity(r);</div><div class="line">    Activity activity = null;</div><div class="line">    try &#123;</div><div class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</div><div class="line">        // 创建 Activity</div><div class="line">        activity = mInstrumentation.newActivity(</div><div class="line">                cl, component.getClassName(), r.intent);</div><div class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</div><div class="line">        r.intent.setExtrasClassLoader(cl);</div><div class="line">        r.intent.prepareToEnterProcess();</div><div class="line">        if (r.state != null) &#123;</div><div class="line">            r.state.setClassLoader(cl);</div><div class="line">        &#125;</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        if (!mInstrumentation.onException(activity, e)) &#123;</div><div class="line">            throw new RuntimeException(</div><div class="line">                    &quot;Unable to instantiate activity &quot; + component</div><div class="line">                            + &quot;: &quot; + e.toString(), e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        // 创建 Application</div><div class="line">        Application app = r.packageInfo.makeApplication(false, mInstrumentation);</div><div class="line"></div><div class="line">        if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r);</div><div class="line">        if (localLOGV) Slog.v(</div><div class="line">                TAG, r + &quot;: app=&quot; + app</div><div class="line">                        + &quot;, appName=&quot; + app.getPackageName()</div><div class="line">                        + &quot;, pkg=&quot; + r.packageInfo.getPackageName()</div><div class="line">                        + &quot;, comp=&quot; + r.intent.getComponent().toShortString()</div><div class="line">                        + &quot;, dir=&quot; + r.packageInfo.getAppDir());</div><div class="line"></div><div class="line">        if (activity != null) &#123;</div><div class="line">            // 获取 Activity 的 title</div><div class="line">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</div><div class="line">            Configuration config = new Configuration(mCompatConfiguration);</div><div class="line">            if (r.overrideConfig != null) &#123;</div><div class="line">                config.updateFrom(r.overrideConfig);</div><div class="line">            &#125;</div><div class="line">            if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot;</div><div class="line">                    + r.activityInfo.name + &quot; with config &quot; + config);</div><div class="line">            Window window = null;</div><div class="line">            if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) &#123;</div><div class="line">                window = r.mPendingRemoveWindow;</div><div class="line">                r.mPendingRemoveWindow = null;</div><div class="line">                r.mPendingRemoveWindowManager = null;</div><div class="line">            &#125;</div><div class="line">            appContext.setOuterContext(activity);</div><div class="line">            // Activity 与 Context、Application 关联起来</div><div class="line">            activity.attach(appContext, this, getInstrumentation(), r.token,</div><div class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</div><div class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</div><div class="line">                    r.referrer, r.voiceInteractor, window, r.configCallback);</div><div class="line"></div><div class="line">            if (customIntent != null) &#123;</div><div class="line">                activity.mIntent = customIntent;</div><div class="line">            &#125;</div><div class="line">            r.lastNonConfigurationInstances = null;</div><div class="line">            checkAndBlockForNetworkAccess();</div><div class="line">            activity.mStartedActivity = false;</div><div class="line">            int theme = r.activityInfo.getThemeResource();</div><div class="line">            if (theme != 0) &#123;</div><div class="line">                activity.setTheme(theme);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            activity.mCalled = false;</div><div class="line">            if (r.isPersistable()) &#123;</div><div class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</div><div class="line">            &#125; else &#123;</div><div class="line">                // 回调 Activity 的 onCreate 方法</div><div class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</div><div class="line">            &#125;</div><div class="line">            if (!activity.mCalled) &#123;</div><div class="line">                throw new SuperNotCalledException(</div><div class="line">                        &quot;Activity &quot; + r.intent.getComponent().toShortString() +</div><div class="line">                                &quot; did not call through to super.onCreate()&quot;);</div><div class="line">            &#125;</div><div class="line">            r.activity = activity;</div><div class="line">        &#125;</div><div class="line">        r.setState(ON_CREATE);</div><div class="line"></div><div class="line">        mActivities.put(r.token, r);</div><div class="line"></div><div class="line">    &#125; catch (SuperNotCalledException e) &#123;</div><div class="line">        throw e;</div><div class="line"></div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        if (!mInstrumentation.onException(activity, e)) &#123;</div><div class="line">            throw new RuntimeException(</div><div class="line">                    &quot;Unable to start activity &quot; + component</div><div class="line">                            + &quot;: &quot; + e.toString(), e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return activity;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 handleLaunchActivity 中会调用 perfromLaunchActivity 执行 Applicaton、ContextImpl、Activity 的创建工作，并且通过 Activity 的 attach 将这 3 者关联起来。</p><p>Activity 是 Context 的子类，因此，Activity 就具有了 Context 定义的所有方法。但 Activity 并不实现具体的功能，它只是继承了 Context 的接口，并且将相关的操作交给 ContextImpl。ContextImpl 存储在 Activity 的上两层父类 ContextWrapper 中，变量名为 mBase，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class ContextThemeWrapper extends ContextWrapper &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void attachBaseContext(Context newBase) &#123;</div><div class="line">        super.attachBaseContext(newBase);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">public class ContextWrapper extends Context &#123;</div><div class="line">    Context mBase;</div><div class="line"></div><div class="line">    public ContextWrapper(Context base) &#123;</div><div class="line">        mBase = base;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Set the base context for this ContextWrapper.  All calls will then be</div><div class="line">     * delegated to the base context.  Throws</div><div class="line">     * IllegalStateException if a base context has already been set.</div><div class="line">     *</div><div class="line">     * @param base The new base context for this wrapper.</div><div class="line">     */</div><div class="line">    protected void attachBaseContext(Context base) &#123;</div><div class="line">        if (mBase != null) &#123;</div><div class="line">            throw new IllegalStateException(&quot;Base context already set&quot;);</div><div class="line">        &#125;</div><div class="line">        mBase = base;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 ActivityThread 类的 perfromLaunchActivity 函数中会调用 Activity 的 attach 方法将 ContextImpl 等对象关联到 Activity 中，这个 ContextImpl 最终会被 ContentWrapper 类的 mBase 字段引用。Activity 的 attach 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">final void attach(Context context, ActivityThread aThread,</div><div class="line">                  Instrumentation instr, IBinder token, int ident,</div><div class="line">                  Application application, Intent intent, ActivityInfo info,</div><div class="line">                  CharSequence title, Activity parent, String id,</div><div class="line">                  NonConfigurationInstances lastNonConfigurationInstances,</div><div class="line">                  Configuration config, String referrer, IVoiceInteractor voiceInteractor,</div><div class="line">                  Window window, ActivityConfigCallback activityConfigCallback) &#123;</div><div class="line">    // 调用自身的 attachBaseContext</div><div class="line">    attachBaseContext(context);</div><div class="line"></div><div class="line">    mFragments.attachHost(null /*parent*/);</div><div class="line"></div><div class="line">    mWindow = new PhoneWindow(this, window, activityConfigCallback);</div><div class="line">    mWindow.setWindowControllerCallback(this);</div><div class="line">    mWindow.setCallback(this);</div><div class="line">    mWindow.setOnWindowDismissedCallback(this);</div><div class="line">    mWindow.getLayoutInflater().setPrivateFactory(this);</div><div class="line">    if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</div><div class="line">        mWindow.setSoftInputMode(info.softInputMode);</div><div class="line">    &#125;</div><div class="line">    if (info.uiOptions != 0) &#123;</div><div class="line">        mWindow.setUiOptions(info.uiOptions);</div><div class="line">    &#125;</div><div class="line">    mUiThread = Thread.currentThread();</div><div class="line"></div><div class="line">    mMainThread = aThread;</div><div class="line">    mInstrumentation = instr;</div><div class="line">    mToken = token;</div><div class="line">    mIdent = ident;</div><div class="line">    mApplication = application;</div><div class="line">    mIntent = intent;</div><div class="line">    mReferrer = referrer;</div><div class="line">    mComponent = intent.getComponent();</div><div class="line">    mActivityInfo = info;</div><div class="line">    mTitle = title;</div><div class="line">    mParent = parent;</div><div class="line">    mEmbeddedID = id;</div><div class="line">    mLastNonConfigurationInstances = lastNonConfigurationInstances;</div><div class="line">    if (voiceInteractor != null) &#123;</div><div class="line">        if (lastNonConfigurationInstances != null) &#123;</div><div class="line">            mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor;</div><div class="line">        &#125; else &#123;</div><div class="line">            mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this,</div><div class="line">                    Looper.myLooper());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mWindow.setWindowManager(</div><div class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</div><div class="line">            mToken, mComponent.flattenToString(),</div><div class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);</div><div class="line">    if (mParent != null) &#123;</div><div class="line">        mWindow.setContainer(mParent.getWindow());</div><div class="line">    &#125;</div><div class="line">    mWindowManager = mWindow.getWindowManager();</div><div class="line">    mCurrentConfig = config;</div><div class="line"></div><div class="line">    mWindow.setColorMode(info.colorMode);</div><div class="line"></div><div class="line">    setAutofillCompatibilityEnabled(application.isAutofillCompatibilityEnabled());</div><div class="line">    enableAutofillCompatibilityIfNeeded();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>attach 主要就是一些赋值操作。在 attach 中，调用了 attachBaseContext 函数。attachBaseContext 调用了父类 ContextWrapper 类，它就是简单地将 Context 参数传递给 mBase 字段。此时，我们的 Activity 内部就持有了 ContextImpl 的引用。</p><p>Activity 的 attachBaseContext：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void attachBaseContext(Context newBase) &#123;</div><div class="line">    // 调用了 ContextThemeWrapper 的 attachBaseContext</div><div class="line">    super.attachBaseContext(newBase);</div><div class="line">    if (newBase != null) &#123;</div><div class="line">        newBase.setAutofillClient(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Activity 在开发过程中部分充当了代理的角色，例如，当我们通过 Activity 对象调用 sendBroadcast、getResource 等函数时，实际上 Activity 只是代理了 ContextImpl 的操作，也就是内部都调用了 mBase 对象的相应方法来处理，这些方法被封装在 Activity 的父类 ContextWrapper 中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class ContextWrapper extends Context &#123;</div><div class="line">    Context mBase;</div><div class="line">    ...</div><div class="line">    @Override</div><div class="line">    public void sendBroadcast(Intent intent) &#123;</div><div class="line">        mBase.sendBroadcast(intent);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    @Override</div><div class="line">    public Resources getResources() &#123;</div><div class="line">        return mBase.getResources();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public PackageManager getPackageManager() &#123;</div><div class="line">        return mBase.getPackageManager();</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ContextImpl 的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">class ContextImpl extends Context &#123;</div><div class="line">    ...</div><div class="line">    @Override</div><div class="line">    public void sendBroadcast(Intent intent) &#123;</div><div class="line">        warnIfCallingFromSystemProcess();</div><div class="line">        String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</div><div class="line">        try &#123;</div><div class="line">            intent.prepareToLeaveProcess(this);</div><div class="line">            ActivityManager.getService().broadcastIntent(</div><div class="line">                    mMainThread.getApplicationThread(), intent, resolvedType, null,</div><div class="line">                    Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false,</div><div class="line">                    getUserId());</div><div class="line">        &#125; catch (RemoteException e) &#123;</div><div class="line">            throw e.rethrowFromSystemServer();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    @Override</div><div class="line">    public Resources getResources() &#123;</div><div class="line">        return mResources;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public PackageManager getPackageManager() &#123;</div><div class="line">        if (mPackageManager != null) &#123;</div><div class="line">            return mPackageManager;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        IPackageManager pm = ActivityThread.getPackageManager();</div><div class="line">        if (pm != null) &#123;</div><div class="line">            // Doesn&apos;t matter if we make more than one instance.</div><div class="line">            return (mPackageManager = new ApplicationPackageManager(this, pm));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ContextImpl 内部封装了很多不同子系统的操作，例如，Activity 的跳转、发送广播、启动服务、设置壁纸等，这些工作并不是在 ContextImpl 中实现，而是转交给了具体的子系统进行处理。通过 Context 这个抽象类定义了一组接口，ContextImpl 实现 Context 定义的接口，使得用户可以通过 Context 这个接口统一与 Android 系统进行交互，这样用户通常情况下就不需要对每个子系统进行了解，例如启动 Activity 时用户不需要手动调用 mMainThread.getInstrumentation().execStartActivity 启动 Activity。用户与系统服务的交互都通过 Context 的高层接口。这样对用户屏蔽了具体实现的细节，降低了使用成本。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e4cae7200a7c7d27.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21 设计模式——享元模式</title>
      <link href="/1901/02/01/02%20DESIGN%20PATTERN/21%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
      <url>/1901/02/01/02%20DESIGN%20PATTERN/21%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-3f71eb1c10df39c0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>享元（Flyweight）模式：<strong>使用共享对象可有效地支持大量的细粒度的对象</strong>。</p><p>享元模式是对象池的一种实现，代表轻量级的意思。用来尽可能减少内存使用量，它适合用于大量重复对象的场景，来缓存可共享的对象，达到对象共享，避免创建过多对象的效果，这样一来就可以提升性能，避免内存移除等。</p><p>享元模式中存在以下两种状态：</p><ul><li>内部状态，即不会随着环境的改变而改变的可共享部分；</li><li>外部状态，指随环境改变而改变的不可以共享的部分。</li></ul><p>享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。</li><li>读取享元模式的外部状态会使得运行时间稍微变长。</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>系统存在大量相似或相同的对象。</li><li>需要缓冲池时。</li><li>细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。</li></ul><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><hr><p>模式包含以下主要角色。</p><ul><li>Flyweight（抽象享元角色）：接口或抽象类，可以同时定义出对象的外部状态和内部状态的接口或实现。</li><li>ConcreteFlyweight（具体享元角色）：实现抽象享元角色中定义的业务。</li><li>UnsharedConcreteFlyweight（不可共享的享元角色）：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。该对象一般不会出现在享元工厂中。</li><li>FlyweightFactory（享元工厂）：管理对象池和创建享元对象。</li></ul><p>其结构图如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-5451ee2a3b8aa29f.gif?imageMogr2/auto-orient/strip" alt=""></p><p>享元模式的实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">// 非享元角色</div><div class="line">class UnsharedConcreteFlyweight &#123;</div><div class="line">    private String info;</div><div class="line">    UnsharedConcreteFlyweight(String info) &#123;</div><div class="line">        this.info = info;</div><div class="line">    &#125;</div><div class="line">    public String getInfo() &#123;</div><div class="line">        return info;</div><div class="line">    &#125;</div><div class="line">    public void setInfo(String info) &#123;</div><div class="line">        this.info = info;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 抽象享元角色</div><div class="line">interface Flyweight &#123;</div><div class="line">    void operation(UnsharedConcreteFlyweight state);</div><div class="line">&#125;</div><div class="line">// 具体享元角色</div><div class="line">class ConcreteFlyweight implements Flyweight &#123;</div><div class="line">    private String key;</div><div class="line">    ConcreteFlyweight(String key) &#123;</div><div class="line">        this.key = key;</div><div class="line">        System.out.println(&quot;具体享元&quot;+key+&quot;被创建！&quot;);</div><div class="line">    &#125;</div><div class="line">    public void operation(UnsharedConcreteFlyweight outState) &#123;</div><div class="line">        System.out.print(&quot;具体享元&quot;+key+&quot;被调用，&quot;);</div><div class="line">        System.out.println(&quot;非享元信息是:&quot;+outState.getInfo());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 享元工厂角色</div><div class="line">class FlyweightFactory &#123;</div><div class="line">    private HashMap&lt;String, Flyweight&gt; flyweights = new HashMap&lt;&gt;();</div><div class="line">    public Flyweight getFlyweight(String key) &#123;</div><div class="line">        Flyweight flyweight = (Flyweight)flyweights.get(key);</div><div class="line">        if(flyweight != null) &#123;</div><div class="line">            System.out.println(&quot;具体享元&quot;+key+&quot;已经存在，被成功获取！&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            flyweight = new ConcreteFlyweight(key);</div><div class="line">            flyweights.put(key, flyweight);</div><div class="line">        &#125;</div><div class="line">        return flyweight;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">FlyweightFactory factory = new FlyweightFactory();</div><div class="line">Flyweight f01 = factory.getFlyweight(&quot;a&quot;);</div><div class="line">Flyweight f02 = factory.getFlyweight(&quot;a&quot;);</div><div class="line">Flyweight f03 = factory.getFlyweight(&quot;a&quot;);</div><div class="line">Flyweight f11 = factory.getFlyweight(&quot;b&quot;);</div><div class="line">Flyweight f12 = factory.getFlyweight(&quot;b&quot;);       </div><div class="line">f01.operation(new UnsharedConcreteFlyweight(&quot;第1次调用a。&quot;));</div><div class="line">f02.operation(new UnsharedConcreteFlyweight(&quot;第2次调用a。&quot;));</div><div class="line">f03.operation(new UnsharedConcreteFlyweight(&quot;第3次调用a。&quot;));</div><div class="line">f11.operation(new UnsharedConcreteFlyweight(&quot;第1次调用b。&quot;));</div><div class="line">f12.operation(new UnsharedConcreteFlyweight(&quot;第2次调用b。&quot;));</div></pre></td></tr></table></figure></p><p>程序运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">具体享元a被创建！</div><div class="line">具体享元a已经存在，被成功获取！</div><div class="line">具体享元a已经存在，被成功获取！</div><div class="line">具体享元b被创建！</div><div class="line">具体享元b已经存在，被成功获取！</div><div class="line">具体享元a被调用，非享元信息是:第1次调用a。</div><div class="line">具体享元a被调用，非享元信息是:第2次调用a。</div><div class="line">具体享元a被调用，非享元信息是:第3次调用a。</div><div class="line">具体享元b被调用，非享元信息是:第1次调用b。</div><div class="line">具体享元b被调用，非享元信息是:第2次调用b。</div></pre></td></tr></table></figure></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>这个是一个买车票的例子，客户端通过输入起始地和目的地到服务器，服务器返回车票价格信息，一次请求总会产生一个车票价格信息对象，如果是成千上万的用户不停的请求势必会使得服务器产生大量的重复对象，为了避免不必要的内存开销，可以使用享元模式来优化这种情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">// 定义车票接口和展示车票信息的函数</div><div class="line">public interface Ticket &#123;</div><div class="line">    void showTicketInfo(String bunk);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 火车票实现类</div><div class="line">public class TrainTicket implements Ticket &#123;</div><div class="line">    public String from;  // 始发地：内部状态</div><div class="line">    public String to;    // 目的地：内部状态</div><div class="line">    public String bunk;  // 铺位：外部状态</div><div class="line">    public  int price;   // 价格：外部状态</div><div class="line">    public TrainTicket(String from, String to) &#123;</div><div class="line">        this.from = from;</div><div class="line">        this.to = to;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void showTicketInfo(String bunk) &#123;</div><div class="line">        price = new Random().nextInt(300);</div><div class="line">        System.out.println(&quot;购买 从 &quot;+from+&quot; 到 &quot;+to+&quot; 的 &quot;+bunk+&quot; 火车票&quot;+&quot;,价格 : &quot;+price);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// </div><div class="line">public class TicketFactory &#123;</div><div class="line">    static Map&lt;String,Ticket&gt; sTicketMap = new ConcurrentHashMap&lt;&gt;();</div><div class="line"></div><div class="line">    public static Ticket getTicket(String from, String to)&#123;</div><div class="line">        String key = from + &quot;-&quot; + to;</div><div class="line">        if (sTicketMap.containsKey(key))&#123;</div><div class="line">            System.out.println(&quot;使用缓存 ==&gt; &quot;+key);</div><div class="line">            return sTicketMap.get(key);</div><div class="line">        &#125; else &#123;</div><div class="line">            System.out.println(&quot;创建对象 ==&gt; &quot;+key);</div><div class="line">            Ticket ticket = new TrainTicket(from,to);</div><div class="line">            sTicketMap.put(key,ticket);</div><div class="line">            return ticket;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这种方式把对象缓存到了sTicketMap， key为 “from + “-“ + to”，这样避免了重复的起始地和目的地产生重复对象的情况。</p><h3 id="ANDROID-源码中的实现"><a href="#ANDROID-源码中的实现" class="headerlink" title="ANDROID 源码中的实现"></a>ANDROID 源码中的实现</h3><hr><p>Handler 消息机制中的 Message 消息池就是使用享元模式复用了 Message 对象。</p><p>使用 Message 时一般会用到 Message.obtain 来获取消息。如果使用 new Message() 会构造大量的 Message 对象。obtain 方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static Message obtain() &#123;</div><div class="line">    synchronized (sPoolSync) &#123;</div><div class="line">        if (sPool != null) &#123;</div><div class="line">            Message m = sPool;</div><div class="line">            sPool = m.next;</div><div class="line">            m.next = null;</div><div class="line">            // 清空 in-use 标记</div><div class="line">            m.flags = 0; // clear in-use flag</div><div class="line">            sPoolSize--;</div><div class="line">            return m;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return new Message();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>sPoolSync 和 sPool 定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *</div><div class="line"> * Defines a message containing a description and arbitrary data object that can be</div><div class="line"> * sent to a &#123;@link Handler&#125;.  This object contains two extra int fields and an</div><div class="line"> * extra object field that allow you to not do allocations in many cases.</div><div class="line"> *</div><div class="line"> * &lt;p class=&quot;note&quot;&gt;While the constructor of Message is public, the best way to get</div><div class="line"> * one of these is to call &#123;@link #obtain Message.obtain()&#125; or one of the</div><div class="line"> * &#123;@link Handler#obtainMessage Handler.obtainMessage()&#125; methods, which will pull</div><div class="line"> * them from a pool of recycled objects.&lt;/p&gt;</div><div class="line"> */</div><div class="line">public final class Message implements Parcelable &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    // sometimes we store linked lists of these things</div><div class="line">    /*package*/ Message next;</div><div class="line"></div><div class="line">    public static final Object sPoolSync = new Object();</div><div class="line">    private static Message sPool;</div><div class="line">    private static int sPoolSize = 0;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>sPoolSync 是一个对象锁，用于在获取 Message 对象时进行同步锁。<br>sPool 是一个静态的 Message 对象。<br>next 是一个 Message 对象，指向下一个 Message。</p><p>可以看出，Message 消息池没有使用 map 这样的容器，而是使用的链表。</p><p>那么这些 Message 是什么时候放入链表中的呢？我们在 obtain 函数中只看到了从链表中获取，并且看到存储。如果消息池链表中没有可用对象的时候，obtain 中则是直接返回一个通过 new 创建的 Message 对象，而且并没有存储到链表中。</p><p>Message 类有一个 recycle 方法，它用来回收消息，并且把回收掉的消息添加到对象池链表中。recycle 方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void recycle() &#123;</div><div class="line">    // 判断消息是否还在使用</div><div class="line">    if (isInUse()) &#123;</div><div class="line">        if (gCheckRecycle) &#123;</div><div class="line">            throw new IllegalStateException(&quot;This message cannot be recycled because it &quot;</div><div class="line">                    + &quot;is still in use.&quot;);</div><div class="line">        &#125;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    // 清空状态，并且将消息添加到消息池中</div><div class="line">    recycleUnchecked();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>recycleUnchecked 方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">void recycleUnchecked() &#123;</div><div class="line">    // Mark the message as in use while it remains in the recycled object pool.</div><div class="line">    // Clear out all other details.</div><div class="line">    // 清空消息状态，设置该消息 in-use flag</div><div class="line">    flags = FLAG_IN_USE;</div><div class="line">    what = 0;</div><div class="line">    arg1 = 0;</div><div class="line">    arg2 = 0;</div><div class="line">    obj = null;</div><div class="line">    replyTo = null;</div><div class="line">    sendingUid = -1;</div><div class="line">    when = 0;</div><div class="line">    target = null;</div><div class="line">    callback = null;</div><div class="line">    data = null;</div><div class="line"></div><div class="line">    // 回收消息到消息池中</div><div class="line">    synchronized (sPoolSync) &#123;</div><div class="line">        if (sPoolSize &lt; MAX_POOL_SIZE) &#123;</div><div class="line">            next = sPool;</div><div class="line">            sPool = this;</div><div class="line">            sPoolSize++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>recycle 会将一个 Message 回收到一个全局的池。如果消息在使用就抛出异常，否则调用 recycleUnchecked。</p><p>recycleUnchecked 先清空字段，然后回收消息，将 sPool 指向当前消息，同时 size 加一。</p><p>Message 通过在内部构建一个链表来维护一个被回收的 Message 对象的对象池，当用户调用 obtain 时会优先从池中取，如果池中没有可以复用的对象则创建这个新的 Message 对象。这些新创建的 Message 对象在被使用完之后会被回收到这个对象池中，当下次再调用 obtain 时，它们就会被复用。</p><p>因为 Android 应用是事件驱动的，因此，如果通过 new 创建 Message 会产生大量的重复的 Message 对象，导致内存占用率高、频繁 GC 等问题，通过享元模式创建一个大小为 50 的消息池，避免了上述问题。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b0f6a09df53153c6.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20 设计模式——装饰模式</title>
      <link href="/1901/01/28/02%20DESIGN%20PATTERN/20%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
      <url>/1901/01/28/02%20DESIGN%20PATTERN/20%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-9a925c604c5c9ede.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>装饰（Decorator）模式：<strong>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活</strong>。</p><p>装饰模式也称为包装模式，结构型设计模式之一，其使用一种对客户端透明的方式来动态地扩展对象地功能，同时它也是继承关系的一种替代方案之一。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>采用装饰模式扩展对象的功能比采用继承方式更加灵活。</li><li>可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>需要透明且动态地扩展类的功能。</p><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><hr><p>通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。下面来分析其基本结构和实现方法。</p><p>模式包含以下主要角色。</p><ul><li>Component（抽象组件）：接口或者抽象类，被装饰的最原始的对象。具体组件与抽象装饰角色的父类。</li><li>ConcreteComponent（具体组件）：实现抽象组件的接口。</li><li>Decorator（抽象装饰角色）：一般是抽象类，抽象组件的子类，同时持有一个被装饰者的引用，用来调用被装饰者的方法;同时可以给被装饰者增加新的职责。</li><li>ConcreteDecorator（具体装饰类）：抽象装饰角色的具体实现。</li></ul><p>其结构图如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-752e1b3cc271db8e.gif?imageMogr2/auto-orient/strip" alt=""></p><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class DecoratorPattern &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Component p = new ConcreteComponent();</div><div class="line">        p.operation();</div><div class="line">        System.out.println(&quot;---------------------------------&quot;);</div><div class="line">        Component d = new ConcreteDecorator(p);</div><div class="line">        d.operation();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽象构件角色</div><div class="line">interface Component &#123;</div><div class="line">    void operation();</div><div class="line">&#125;</div><div class="line">// 具体构件角色</div><div class="line">class ConcreteComponent implements Component &#123;</div><div class="line">    public ConcreteComponent() &#123;</div><div class="line">        System.out.println(&quot;创建具体构件角色&quot;);</div><div class="line">    &#125;</div><div class="line">    public void operation() &#123;</div><div class="line">        System.out.println(&quot;调用具体构件角色的方法 operation()&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 抽象装饰角色</div><div class="line">abstract class Decorator implements Component &#123;</div><div class="line">    private Component component;</div><div class="line">    public Decorator(Component component) &#123;</div><div class="line">        this.component = component;</div><div class="line">    &#125;</div><div class="line">    public void operation() &#123;</div><div class="line">        component.operation();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 具体装饰角色</div><div class="line">class ConcreteDecorator extends Decorator &#123;</div><div class="line">    public ConcreteDecorator(Component component) &#123;</div><div class="line">        super(component);</div><div class="line">    &#125;</div><div class="line">    public void operation() &#123;</div><div class="line">        super.operation();</div><div class="line">        addedFunction();</div><div class="line">    &#125;</div><div class="line">    public void addedFunction() &#123;</div><div class="line">        System.out.println(&quot;为具体构件角色增加额外的功能 addedFunction()&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">创建具体构件角色</div><div class="line">调用具体构件角色的方法 operation()</div><div class="line">---------------------------------</div><div class="line">调用具体构件角色的方法 operation()</div><div class="line">为具体构件角色增加额外的功能 addedFunction()</div></pre></td></tr></table></figure></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>人总是要穿衣服，我们将人定义为一个抽象类，将其穿衣服的行为定义为一个抽象方法，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public abstract class Person &#123;</div><div class="line">    // Person 下有一个穿着的抽象方法</div><div class="line">    public abstract void dressed();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Boy extends Person &#123;</div><div class="line">    @Override</div><div class="line">    public void dressed() &#123;</div><div class="line">        System.out.println(&quot;穿了内衣内裤&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PersonCloth 用来装饰 Person：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public abstract class PersonCloth extends Person &#123;</div><div class="line">    protected Person mPerson;   // 保持一个 Person 类的引用</div><div class="line"></div><div class="line">    public PersonCloth(Person person) &#123;</div><div class="line">        mPerson = person;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void dressed() &#123;</div><div class="line">        mPerson.dressed();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面两个是继承 PersonCloth 的实际装饰类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public class CheapCloth extends PersonCloth &#123;</div><div class="line">    public CheapCloth(Person person) &#123;</div><div class="line">        super(person);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void dressShorts() &#123;</div><div class="line">        System.out.println(&quot;穿条短裤&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void dressed() &#123;</div><div class="line">        super.dressed();</div><div class="line">        dressShorts()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">public class ExpensiveCloth extends PersonCloth &#123;</div><div class="line">    public ExpensiveCloth(Person person) &#123;</div><div class="line">        super(person);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 穿短袖</div><div class="line">     */</div><div class="line">    private void dressShirt() &#123;</div><div class="line">        System.out.println(&quot;穿件短袖&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 穿皮衣</div><div class="line">     */</div><div class="line">    private void dressLeather() &#123;</div><div class="line">        System.out.println(&quot;穿件皮衣&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 穿牛仔裤</div><div class="line">     */</div><div class="line">    private void dressJean() &#123;</div><div class="line">        System.out.println(&quot;穿条牛仔裤&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void dressed() &#123;</div><div class="line">        super.dressed();</div><div class="line">        dressShirt();</div><div class="line">        dressLeather();</div><div class="line">        dressJean();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 首先我们要有一个Boy</div><div class="line">Person person = new Boy();</div><div class="line"></div><div class="line">// 穿上便宜的衣服</div><div class="line">CheapCloth cheapCloth = new CheapCloth(person);</div><div class="line">cheapCloth.dressed();</div><div class="line"></div><div class="line">// 穿上昂贵的衣服</div><div class="line">ExpensiveCloth expensiveCloth = new ExpensiveCloth(person);</div><div class="line">expensiveCloth.dressed();</div></pre></td></tr></table></figure></p><h3 id="ANDROID-源码中的实现"><a href="#ANDROID-源码中的实现" class="headerlink" title="ANDROID 源码中的实现"></a>ANDROID 源码中的实现</h3><hr><p>Context 类在 Android 中被称为“上帝对象”，它本质是一个抽象类，其在我们装饰者模式里相当于抽象组件，而在其内部定义了大量的抽象方法，比如我们经常会用到的 startActivity 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public abstract class Context &#123;</div><div class="line">    ...</div><div class="line">    public abstract void startActivity(@RequiresPermission Intent intent);</div><div class="line">    ...</div><div class="line">    public abstract void startActivity(@RequiresPermission Intent intent,</div><div class="line">            @Nullable Bundle options);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>真正的实现是在 ContextImpl 中完成的，ContextImpl 继承自 Context 抽象类，并实现了 Context 中的抽象方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">class ContextImpl extends Context &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void startActivity(Intent intent) &#123;</div><div class="line">        warnIfCallingFromSystemProcess();</div><div class="line">        startActivity(intent, null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** @hide */</div><div class="line">    @Override</div><div class="line">    public void startActivityAsUser(Intent intent, UserHandle user) &#123;</div><div class="line">        startActivityAsUser(intent, null, user);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void startActivity(Intent intent, Bundle options) &#123;</div><div class="line">        warnIfCallingFromSystemProcess();</div><div class="line"></div><div class="line">        // Calling start activity from outside an activity without FLAG_ACTIVITY_NEW_TASK is</div><div class="line">        // generally not allowed, except if the caller specifies the task id the activity should</div><div class="line">        // be launched in. A bug was existed between N and O-MR1 which allowed this to work. We</div><div class="line">        // maintain this for backwards compatibility.</div><div class="line">        final int targetSdkVersion = getApplicationInfo().targetSdkVersion;</div><div class="line"></div><div class="line">        if ((intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NEW_TASK) == 0</div><div class="line">                &amp;&amp; (targetSdkVersion &lt; Build.VERSION_CODES.N</div><div class="line">                        || targetSdkVersion &gt;= Build.VERSION_CODES.P)</div><div class="line">                &amp;&amp; (options == null</div><div class="line">                        || ActivityOptions.fromBundle(options).getLaunchTaskId() == -1)) &#123;</div><div class="line">            throw new AndroidRuntimeException(</div><div class="line">                    &quot;Calling startActivity() from outside of an Activity &quot;</div><div class="line">                            + &quot; context requires the FLAG_ACTIVITY_NEW_TASK flag.&quot;</div><div class="line">                            + &quot; Is this really what you want?&quot;);</div><div class="line">        &#125;</div><div class="line">        mMainThread.getInstrumentation().execStartActivity(</div><div class="line">                getOuterContext(), mMainThread.getApplicationThread(), null,</div><div class="line">                (Activity) null, intent, -1, options);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里 ContextImpl 就相当于组件具体实现类，那么谁来承担装饰者的身份呢？</p><p>Activity 从类层次上来说本质是一个 Context。Activity 并非直接继承于 Context，而是继承于 ContextThemeWrapper。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Activity extends ContextThemeWrapper</div><div class="line">        implements LayoutInflater.Factory2,</div><div class="line">        Window.Callback, KeyEvent.Callback,</div><div class="line">        OnCreateContextMenuListener, ComponentCallbacks2,</div><div class="line">        Window.OnWindowDismissedCallback, WindowControllerCallback,</div><div class="line">        AutofillManager.AutofillClient &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>而这个 ContextThemeWrapper 又是继承于 ContextWrapper。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public class ContextThemeWrapper extends ContextWrapper &#123;&#125;</div></pre></td></tr></table></figure></p><p>最终这个 ContextWrapper 才继承于 Context。</p><p>为什么类层次会这么复杂呢？其实这里就是一个典型的装饰模式，ContextWrapper 就是我们要找的装饰者，在 ContextWrapper 中有一个 Context 的引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class ContextWrapper extends Context &#123;</div><div class="line">    Context mBase;</div><div class="line"></div><div class="line">    public ContextWrapper(Context base) &#123;</div><div class="line">        mBase = base;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * Set the base context for this ContextWrapper.  All calls will then be</div><div class="line">     * delegated to the base context.  Throws</div><div class="line">     * IllegalStateException if a base context has already been set.</div><div class="line">     * </div><div class="line">     * @param base The new base context for this wrapper.</div><div class="line">     */</div><div class="line">    protected void attachBaseContext(Context base) &#123;</div><div class="line">        if (mBase != null) &#123;</div><div class="line">            throw new IllegalStateException(&quot;Base context already set&quot;);</div><div class="line">        &#125;</div><div class="line">        mBase = base;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ContextWrapper 类的 startActivity 方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void startActivity(Intent intent) &#123;</div><div class="line">    mBase.startActivity(intent);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看出它调用了 ContextImpl 中对应的方法。</p><p>装饰模式应用的套路都是很相似的，对于具体方法的包装扩展则由 ContextWrapper 的具体子类完成，比如我们的 Activity、Service 和 Application。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-5ff182b8b9cc7877.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19 设计模式——适配器模式</title>
      <link href="/1901/01/27/02%20DESIGN%20PATTERN/19%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/1901/01/27/02%20DESIGN%20PATTERN/19%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-6253bd345bcac3e3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hello"></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>适配器（Adapter）模式：<strong>把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够一起工作</strong>。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p><p>适配器模式在我们开发中使用率极高，从代码中随处可见的 Adapter 可以判断出来。从最早的 ListView、GridView 到现在最新的 RecyclerView 都需要使用 Adapter。说到底，适配器是将两个不兼容的类融合在一起，它有点像粘合剂，将不同的东西通过一种转换使得它们能够协作起来。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>更好的复用性。系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。</li><li>更好的扩展性。在实现适配器功能的时候，可以调用自己开发的工功能，从而自然地扩展系统的功能。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>过多地使用适配器，会让系统非常零乱，不易整体把握。</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>当想使用一个已经存在的类，但它的接口不符合需求时。</li><li>当想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作。</li><li>需要一个统一的输出接口，而输入端的类型不可预知。</li></ul><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><hr><p>类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；Java 不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p><p>对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。现在来介绍它们的基本结构。</p><p>模式包含以下主要角色。</p><ul><li>Target：目标接口，当前系统业务所期待的接口，它可以是抽象类或接口。</li><li>Adaptee：适配者类，它是被访问和适配的现存组件库中的组件接口。</li><li>Adapter：适配器类，它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li></ul><p>其结构图如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d15db3d7111f6640.gif?imageMogr2/auto-orient/strip" alt="类适配器模式的结构图"></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a48b7aa9fffbb165.gif?imageMogr2/auto-orient/strip" alt="对象适配器模式的结构图"></p><p>类适配器模式的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// 目标接口</div><div class="line">interface Target &#123;</div><div class="line">    void request();</div><div class="line">&#125;</div><div class="line">// 适配者接口</div><div class="line">class Adaptee &#123;</div><div class="line">    public void specificRequest() &#123;</div><div class="line">        System.out.println(&quot;适配者中的业务代码被调用！&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 类适配器类</div><div class="line">class ClassAdapter extends Adaptee implements Target &#123;</div><div class="line">    public void request() &#123;</div><div class="line">        specificRequest();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 客户端代码</div><div class="line">public class ClassAdapterTest &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        System.out.println(&quot;类适配器模式测试：&quot;);</div><div class="line">        Target target = new ClassAdapter();</div><div class="line">        target.request();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>对象适配器模式的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 对象适配器类</div><div class="line">class ObjectAdapter implements Target &#123;</div><div class="line">    private Adaptee adaptee;</div><div class="line">    public ObjectAdapter(Adaptee adaptee) &#123;</div><div class="line">        this.adaptee = adaptee;</div><div class="line">    &#125;</div><div class="line">    public void request() &#123;</div><div class="line">        adaptee.specificRequest();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 客户端代码</div><div class="line">public class ObjectAdapterTest &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        System.out.println(&quot;对象适配器模式测试：&quot;);</div><div class="line">        Adaptee adaptee = new Adaptee();</div><div class="line">        Target target = new ObjectAdapter(adaptee);</div><div class="line">        target.request();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>说明：对象适配器模式中的“目标接口”和“适配者类”的代码同类适配器模式一样，只要修改适配器类和客户端的代码即可。<strong>与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到 Adaptee 类，而是使用代理关系</strong>。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>用电源接口做例子，笔记本电脑的电源一般在 5V 电压，但是在我们生活中的电线电压一般是 220V。这个时候出现了不匹配的状况，在软件开发中称为接口不兼容，此时就需要适配器来进行一个接口转换。此时需要用一个 Adapter 层来进行接口转换。即：5V 电压就是 Target 接口，220V 电压就是 Adaptee 类，而将电压从 220V 转换到 5V 就是 Adapter。</p><ul><li><strong>类适配器模式</strong>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// Target</div><div class="line">public interface FiveVolt &#123;</div><div class="line">    int getVolt5();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Adaptee</div><div class="line">public class Volt220 &#123;</div><div class="line">    public int getVolt220()&#123;</div><div class="line">        return 220;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Adapter</div><div class="line">public class VoltAdapter extends Volt220 implements FiveVolt &#123;</div><div class="line">    @Override</div><div class="line">    public int getVolt5() &#123;</div><div class="line">        return 5;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        VoltAdapter adapter = new VoltAdapter();</div><div class="line">        System.out.println(&quot;输出电压 : &quot; + adapter.getVolt5());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>对象适配器模式</strong>。<br>Target 和 Adaptee 同上，但 Adapter 类不继承 Adaptee 类，而是代理，这比类适配器方式更为灵活。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class VoltAdapter implements FiveVolt &#123;</div><div class="line">    private Volt220 mVolt220;</div><div class="line"></div><div class="line">    public VoltAdapter(Volt220 mVolt220) &#123;</div><div class="line">        this.mVolt220 = mVolt220;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getVolt220()&#123;</div><div class="line">        return mVolt220.getVolt220();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int getVolt5() &#123;</div><div class="line">        return 5;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        VoltAdapter adapter = new VoltAdapter(new Volt220());</div><div class="line">        System.out.println(&quot;输出电压 : &quot;+adapter.getVolt5());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="ANDROID-源码中的实现"><a href="#ANDROID-源码中的实现" class="headerlink" title="ANDROID 源码中的实现"></a>ANDROID 源码中的实现</h3><hr><p>在开发过程中，ListView 的 Adapter 是我们最常见的类型之一。ListView 中并没有 Adapter 相关的成员变量，其实 Adapter 在 ListView 的父类 AbsListView 中，AbsListView 是一个列表控件的抽象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">public abstract class AbsListView extends AdapterView&lt;ListAdapter&gt; implements TextWatcher,</div><div class="line">        ViewTreeObserver.OnGlobalLayoutListener, Filter.FilterListener,</div><div class="line">        ViewTreeObserver.OnTouchModeChangeListener,</div><div class="line">        RemoteViewsAdapter.RemoteAdapterConnectionCallback &#123;</div><div class="line">    ...</div><div class="line">    ListAdapter mAdapter;</div><div class="line">    ...</div><div class="line">    // 关联到 Window 时调用，获取调用 Adapter 中的 getCount 方法等</div><div class="line">    @Override</div><div class="line">    protected void onAttachedToWindow() &#123;</div><div class="line">        super.onAttachedToWindow();</div><div class="line"></div><div class="line">        final ViewTreeObserver treeObserver = getViewTreeObserver();</div><div class="line">        treeObserver.addOnTouchModeChangeListener(this);</div><div class="line">        if (mTextFilterEnabled &amp;&amp; mPopup != null &amp;&amp; !mGlobalLayoutListenerAddedFilter) &#123;</div><div class="line">            treeObserver.addOnGlobalLayoutListener(this);</div><div class="line">        &#125;</div><div class="line">        // 给适配器注册一个观察者</div><div class="line">        if (mAdapter != null &amp;&amp; mDataSetObserver == null) &#123;</div><div class="line">            mDataSetObserver = new AdapterDataSetObserver();</div><div class="line">            mAdapter.registerDataSetObserver(mDataSetObserver);</div><div class="line"></div><div class="line">            // Data may have changed while we were detached. Refresh.</div><div class="line">            mDataChanged = true;</div><div class="line">            mOldItemCount = mItemCount;</div><div class="line">            // 获取 Item 的数量，调用的是 mAdapter 的 getCount 方法</div><div class="line">            mItemCount = mAdapter.getCount();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    // 子类需要覆写 layoutChildren 函数来布局 child view，也就是 item view</div><div class="line">    @Override</div><div class="line">    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">        super.onLayout(changed, l, t, r, b);</div><div class="line"></div><div class="line">        mInLayout = true;</div><div class="line"></div><div class="line">        final int childCount = getChildCount();</div><div class="line">        if (changed) &#123;</div><div class="line">            for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">                getChildAt(i).forceLayout();</div><div class="line">            &#125;</div><div class="line">            mRecycler.markChildrenDirty();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 布局 Child View</div><div class="line">        layoutChildren();</div><div class="line"></div><div class="line">        mOverscrollMax = (b - t) / OVERSCROLL_LIMIT_DIVISOR;</div><div class="line"></div><div class="line">        // TODO: Move somewhere sane. This doesn&apos;t belong in onLayout().</div><div class="line">        if (mFastScroll != null) &#123;</div><div class="line">            mFastScroll.onItemCountChanged(getChildCount(), mItemCount);</div><div class="line">        &#125;</div><div class="line">        mInLayout = false;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ListView 实现了 layoutChildren 方法，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void layoutChildren() &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        super.layoutChildren();</div><div class="line"></div><div class="line">        invalidate();</div><div class="line"></div><div class="line">        ...</div><div class="line">        // 根据布局模式来布局 item view</div><div class="line">        switch (mLayoutMode) &#123;</div><div class="line">            ...</div><div class="line">            case LAYOUT_FORCE_TOP:</div><div class="line">            case LAYOUT_FORCE_BOTTOM:</div><div class="line">            case LAYOUT_SPECIFIC:</div><div class="line">            case LAYOUT_SYNC:</div><div class="line">                break;</div><div class="line">            case LAYOUT_MOVE_SELECTION:</div><div class="line">            default:</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ListView 覆写了 AbsListView 中的 layoutChildren 函数，在该函数中根据布局模式来布局 item view，例如，默认情况是从上到下开始布局，但是，也有从下到上开始布局的，例如 QQ 聊天窗口的气泡布局，最新的消息就会布局到窗口的最底部。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">// 从上往下填充 item view</div><div class="line">private View fillDown(int pos, int nextTop) &#123;</div><div class="line">    View selectedView = null;</div><div class="line"></div><div class="line">    int end = (mBottom - mTop);</div><div class="line">    if ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123;</div><div class="line">        end -= mListPadding.bottom;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    while (nextTop &lt; end &amp;&amp; pos &lt; mItemCount) &#123;</div><div class="line">        // is this the selected item?</div><div class="line">        boolean selected = pos == mSelectedPosition;</div><div class="line">        // 通过 makeAndAddView 获取 item view</div><div class="line">        View child = makeAndAddView(pos, nextTop, true, mListPadding.left, selected);</div><div class="line"></div><div class="line">        nextTop = child.getBottom() + mDividerHeight;</div><div class="line">        if (selected) &#123;</div><div class="line">            selectedView = child;</div><div class="line">        &#125;</div><div class="line">        pos++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    setVisibleRangeHint(mFirstPosition, mFirstPosition + getChildCount() - 1);</div><div class="line">    return selectedView;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 从下往上填充布局</div><div class="line">private View fillUp(int pos, int nextBottom) &#123;</div><div class="line">    View selectedView = null;</div><div class="line"></div><div class="line">    int end = 0;</div><div class="line">    if ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123;</div><div class="line">        end = mListPadding.top;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    while (nextBottom &gt; end &amp;&amp; pos &gt;= 0) &#123;</div><div class="line">        // is this the selected item?</div><div class="line">        boolean selected = pos == mSelectedPosition;</div><div class="line">        // 通过 makeAndAddView 获取 item view</div><div class="line">        View child = makeAndAddView(pos, nextBottom, false, mListPadding.left, selected);</div><div class="line">        nextBottom = child.getTop() - mDividerHeight;</div><div class="line">        if (selected) &#123;</div><div class="line">            selectedView = child;</div><div class="line">        &#125;</div><div class="line">        pos--;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mFirstPosition = pos + 1;</div><div class="line">    setVisibleRangeHint(mFirstPosition, mFirstPosition + getChildCount() - 1);</div><div class="line">    return selectedView;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>makeAndAddView 方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,</div><div class="line">                            boolean selected) &#123;</div><div class="line">    if (!mDataChanged) &#123;</div><div class="line">        // Try to use an existing view for this position.</div><div class="line">        final View activeView = mRecycler.getActiveView(position);</div><div class="line">        if (activeView != null) &#123;</div><div class="line">            // Found it. We&apos;re reusing an existing child, so it just needs</div><div class="line">            // to be positioned like a scrap view.</div><div class="line">            setupChild(activeView, position, y, flow, childrenLeft, selected, true);</div><div class="line">            return activeView;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 获取一个 item view</div><div class="line">    // Make a new view for this position, or convert an unused view if</div><div class="line">    // possible.</div><div class="line">    final View child = obtainView(position, mIsScrap);</div><div class="line"></div><div class="line">    // 将 item view 设置到对应的地方</div><div class="line">    // This needs to be positioned and measured.</div><div class="line">    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);</div><div class="line"></div><div class="line">    return child;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>makeAndAddView 分为两个步骤，第一个是根据 position 获取一个 item view，然后将这个 view 布局到特定的位置。获取一个 item view 调用的是 obtainView 方法。这个方法在 AbsListView 中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">View obtainView(int position, boolean[] outMetadata) &#123;</div><div class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;obtainView&quot;);</div><div class="line"></div><div class="line">    outMetadata[0] = false;</div><div class="line"></div><div class="line">    // Check whether we have a transient state view. Attempt to re-bind the</div><div class="line">    // data and discard the view if we fail.</div><div class="line">    final View transientView = mRecycler.getTransientStateView(position);</div><div class="line">    if (transientView != null) &#123;</div><div class="line">        final LayoutParams params = (LayoutParams) transientView.getLayoutParams();</div><div class="line"></div><div class="line">        // If the view type hasn&apos;t changed, attempt to re-bind the data.</div><div class="line">        if (params.viewType == mAdapter.getItemViewType(position)) &#123;</div><div class="line">            final View updatedView = mAdapter.getView(position, transientView, this);</div><div class="line"></div><div class="line">            // If we failed to re-bind the data, scrap the obtained view.</div><div class="line">            if (updatedView != transientView) &#123;</div><div class="line">                setItemViewLayoutParams(updatedView, position);</div><div class="line">                mRecycler.addScrapView(updatedView, position);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        outMetadata[0] = true;</div><div class="line"></div><div class="line">        // Finish the temporary detach started in addScrapView().</div><div class="line">        transientView.dispatchFinishTemporaryDetach();</div><div class="line">        return transientView;</div><div class="line">    &#125;</div><div class="line">    // 1. 从缓存的 item view 中获取，ListView 的复用机制就在这里</div><div class="line">    final View scrapView = mRecycler.getScrapView(position);</div><div class="line">    // 2. 注意，这里将 scrapView 设置给了 Adapter 的 getView 函数</div><div class="line">    final View child = mAdapter.getView(position, scrapView, this);</div><div class="line">    if (scrapView != null) &#123;</div><div class="line">        if (child != scrapView) &#123;</div><div class="line">            // Failed to re-bind the data, return scrap to the heap.</div><div class="line">            mRecycler.addScrapView(scrapView, position);</div><div class="line">        &#125; else if (child.isTemporarilyDetached()) &#123;</div><div class="line">            outMetadata[0] = true;</div><div class="line"></div><div class="line">            // Finish the temporary detach started in addScrapView().</div><div class="line">            child.dispatchFinishTemporaryDetach();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    return child;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>obtainView 方法定义了列表控件的 item view 的复用逻辑，首先会从 RecyclerBin 中获取一个缓存的 View。如果有缓存则将这个缓存的 View 传递到 Adapter 的 getView 的第二个参数中，这也就是我们对 Adapter 的最常见的优化方式，即判断 getView 的 convertView 是否为空。如果为空则从 xml 中创建视图，否则使用缓存的 View。这样避免了每次都从 xml 加载布局的消耗，能够显著提升 ListView 的效率。</p><p>在 ListView 的适配器模式中，target 角色就是 View，Adapter 就是将 item view 输出为 view 抽象的角色，adaptee 就是需要被处理的 item view。通过增加 adapter 一层来将 item view 的操作抽象起来，listView 等集合视图通过 adapter 对象获得 item 的个数、数据、item view 等，从而达到适配各种数据、各种 item 视图的效果。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-8675738b278ebeb5.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18 设计模式——组合模式</title>
      <link href="/1901/01/26/02%20DESIGN%20PATTERN/18%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
      <url>/1901/01/26/02%20DESIGN%20PATTERN/18%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0930f99c3b795f37.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>组合（Composite）模式：<strong>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性</strong>。</p><p>组合模式也是结构模式之一，组合模式比较简单，它将一组相似的对象看作一个对象处理，并根据一个树状结构来组合对象，然后提供一个统一的方法去访问相应的对象，以此忽略掉对象与对象之间的差别。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码。</li><li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>设计较复杂，客户端需要花更多时间理清类之间的层次关系。</li><li>不容易限制容器中的构件。</li><li>不容易用继承的方法来增加构件的新功能。</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>表示对象的部分-整体层次结构时。</li><li>从一个整体中能独立出部分模块或功能的场景。</li></ul><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><hr><p>模式包含以下主要角色。</p><ul><li>Component：抽象根节点，为组合中的对象声明接口。</li><li>Composite：定义有子节点的那些枝干节点的行为，存储子节点，在 Component 接口中实现与子节点有关的操作。</li><li>Leaf：在组合中表示叶子节点对象。</li><li>Client：通过 Component 接口操作组合节点的对象。</li></ul><p>其结构图如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8298629-8f5922c06863de28.png?imageMogr2/auto-orient/strip|imageView2/2/w/646/format/webp" alt=""></p><p>下面是它的模版代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">public abstract class Component &#123;</div><div class="line">    protected String name;</div><div class="line">    public Component(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    // 具体逻辑的方法由子类实现</div><div class="line">    public abstract void doSomething();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">public class Composite extends Component &#123;</div><div class="line">    /**</div><div class="line">     * 存储节点的容器</div><div class="line">     * @param name</div><div class="line">     */</div><div class="line">    private List&lt;Component&gt; components = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    public Composite(String name) &#123;</div><div class="line">        super(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void doSomething() &#123;</div><div class="line">        System.out.println(name);</div><div class="line">        if (null != components)&#123;</div><div class="line">            for (Component c : components) &#123;</div><div class="line">                c.doSomething();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 添加子节点</div><div class="line">     * @param child</div><div class="line">     */</div><div class="line">    public void addChild(Component child) &#123;</div><div class="line">        components.add(child);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 移除子节点</div><div class="line">     * @param child</div><div class="line">     */</div><div class="line">    public void removeChild(Component child) &#123;</div><div class="line">        components.remove(child);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取子节点</div><div class="line">     * @param index</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public Component getChildren(int index) &#123;</div><div class="line">        return components.get(index);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">public class Leaf extends Component &#123;</div><div class="line">    public Leaf(String name) &#123;</div><div class="line">        super(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void doSomething() &#123;</div><div class="line">        System.out.print(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>客户端测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // 构造一个根节点</div><div class="line">        Composite root = new Composite(&quot;Root&quot;);</div><div class="line"></div><div class="line">        // 构造两个枝干节点</div><div class="line">        Composite branch1 = new Composite(&quot;Branch1&quot;);</div><div class="line">        Composite branch2 = new Composite(&quot;Branch2&quot;);</div><div class="line"></div><div class="line">        // 构造两个叶子节点</div><div class="line">        Leaf leaf1 = new Leaf(&quot;Leaf1&quot;);</div><div class="line">        Leaf leaf2 = new Leaf(&quot;Leaf2&quot;);</div><div class="line"></div><div class="line">        // 将叶子节点添加至枝干节点中</div><div class="line">        branch1.addChild(leaf1);</div><div class="line">        branch2.addChild(leaf2);</div><div class="line"></div><div class="line">        // 将枝干节点添加至根节点中</div><div class="line">        root.addChild(branch1);</div><div class="line">        root.addChild(branch2);</div><div class="line"></div><div class="line">        // 执行方法</div><div class="line">        root.doSomething();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>下面我们以文件夹系统为例讲解一下组合模式的简单实现，整个文件夹系统如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8298629-445ff6bc22fcd625.png?imageMogr2/auto-orient/strip|imageView2/2/w/686/format/webp" alt=""></p><p>首先声明一个抽象类，表示文件或文件夹：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public abstract class Dir &#123;</div><div class="line">    /**</div><div class="line">     * 声明一个List成员变量存储文件夹下的所有元素</div><div class="line">     */</div><div class="line">    protected List&lt;Dir&gt; dirs = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    private String name; //当前文件夹名</div><div class="line"></div><div class="line">    public Dir(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 添加一个文件或文件夹</div><div class="line">     */</div><div class="line">    public abstract void addDir(Dir dir);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 移除一个文件或文件夹</div><div class="line">     */</div><div class="line">    public abstract void rmDir(Dir dir);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 清除文件夹下面的所有元素</div><div class="line">     */</div><div class="line">    public abstract void clear();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 清空文件夹下的所有元素</div><div class="line">     */</div><div class="line">    public abstract void print();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取文件夹下所有的文件或子文件夹</div><div class="line">     */</div><div class="line">    public abstract List&lt;Dir&gt; getFiles();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取文件或文件夹名</div><div class="line">     */</div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后定义文件夹类和文件类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">public class Folder extends Dir &#123;</div><div class="line">    public Folder(String name) &#123;</div><div class="line">        super(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void addDir(Dir dir) &#123;</div><div class="line">        dirs.add(dir);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void rmDir(Dir dir) &#123;</div><div class="line">        dirs.remove(dir);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void clear() &#123;</div><div class="line">        dirs.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void print() &#123;</div><div class="line">        System.out.print(getName()+&quot;(&quot;);</div><div class="line">        Iterator&lt;Dir&gt; iter = dirs.iterator();</div><div class="line">        while (iter.hasNext())&#123;</div><div class="line">            Dir dir = iter.next();</div><div class="line">            dir.print();</div><div class="line">            if (iter.hasNext())&#123;</div><div class="line">                System.out.print(&quot;,&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.print(&quot;)&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public List&lt;Dir&gt; getFiles() &#123;</div><div class="line">        return dirs;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">public class File extends Dir &#123;</div><div class="line">    public File(String name) &#123;</div><div class="line">        super(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void addDir(Dir dir) &#123;</div><div class="line">        throw new UnsupportedOperationException(&quot;文件对象不支持该操作&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void rmDir(Dir dir) &#123;</div><div class="line">        throw new UnsupportedOperationException(&quot;文件对象不支持该操作&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void clear() &#123;</div><div class="line">        throw new UnsupportedOperationException(&quot;文件对象不支持该操作&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void print() &#123;</div><div class="line">        System.out.print(getName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public List&lt;Dir&gt; getFiles() &#123;</div><div class="line">        throw new UnsupportedOperationException(&quot;文件对象不支持该操作&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>像这样将组合所使用的方法定义在抽象类的方式称为<strong>透明的组合模式</strong>，遵循了依赖倒置原则，但却违反了单一职责原则与接口隔离原则。</p><p>而前面模板代码中所描述的组合模式则称为<strong>安全地组合模式</strong>，这种模式客户端在使用的时候必须依赖具体的实现，这违反了依赖倒置原则，但遵循了单一职责原则与接口隔离原则。</p><p>测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // 构造一个目录对象表示 C 盘根目录</div><div class="line">        Dir diskC = new Folder(&quot;C&quot;);</div><div class="line"></div><div class="line">        // C 盘根目录下有一个文件 ImbaMallLog.txt</div><div class="line">        diskC.addDir(new File(&quot;ImbaMallLog.txt&quot;));</div><div class="line"></div><div class="line">        // C 盘目录下还有3个子目录 Windows,PrefLogs,Program File</div><div class="line">        Dir dirWin = new Folder(&quot;Windows&quot;);</div><div class="line"></div><div class="line">        // Windows 目录下有文件 explorer.exe</div><div class="line">        dirWin.addDir(new File(&quot;explorer.exe&quot;));</div><div class="line">        diskC.addDir(dirWin);</div><div class="line"></div><div class="line">        // PerfLogs 目录</div><div class="line">        Dir dirPer = new Folder(&quot;PerfLogs&quot;);</div><div class="line"></div><div class="line">        // PerfLogs 目录下有文件 null.txt</div><div class="line">        dirPer.addDir(new File(&quot;null.txt&quot;));</div><div class="line">        diskC.addDir(dirPer);</div><div class="line"></div><div class="line">        // Program File 目录</div><div class="line">        Dir dirPro = new Folder(&quot;Program File&quot;);</div><div class="line"></div><div class="line">        // Program File 目录下有文件 ftp.txt</div><div class="line">        dirPro.addDir(new File(&quot;ftp.txt&quot;));</div><div class="line">        diskC.addDir(dirPro);</div><div class="line"></div><div class="line">        // 打印出文件结构</div><div class="line">        diskC.print();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="ANDROID-源码中的实现"><a href="#ANDROID-源码中的实现" class="headerlink" title="ANDROID 源码中的实现"></a>ANDROID 源码中的实现</h3><hr><p>Android 中的 View 和 ViewGroup 的嵌套组合是一个典型的组合模式实现，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8298629-d908c3e49c7b7480.png?imageMogr2/auto-orient/strip|imageView2/2/w/605/format/webp" alt=""></p><p>在 Android 的这个视图层级中，容器一定是 ViewGroup，而且只有 ViewGroup 才能包含其他的 View，比如 LinearLayout 能包含 TextView、Button、CheckBox 等，但是反过来 TextView 是不能包含 LinearLayout 的，因为 TextView 直接继承于 View，其并非一个容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public abstract class ViewGroup extends View implements ViewParent, ViewManager &#123;</div><div class="line">    ...</div><div class="line">    public void addView(View child) &#123;</div><div class="line">        addView(child, -1);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    @Override</div><div class="line">    public void removeView(View view) &#123;</div><div class="line">        if (removeViewInternal(view)) &#123;</div><div class="line">            requestLayout();</div><div class="line">            invalidate(true);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    public View getChildAt(int index) &#123;</div><div class="line">        if (index &lt; 0 || index &gt;= mChildrenCount) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        return mChildren[index];</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ViewGroup 是继承于 View 类的，但为什么有容器的功能呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public abstract class ViewGroup extends View implements ViewParent, ViewManager &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从继承的角度来说，ViewGroup 拥有 View 类所有的非私有方法。既然如此，两者的差别就在于 ViewGroup 所实现的 ViewParent 和 ViewManager 接口上，而事实也是如此。</p><p>ViewManager 定义了 addView、removeView 等对子视图操作的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface ViewManager &#123;</div><div class="line">    public void addView(View view, ViewGroup.LayoutParams params);</div><div class="line">    public void updateViewLayout(View view, ViewGroup.LayoutParams params);</div><div class="line">    public void removeView(View view);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>而 ViewParent 则定义了刷新容器的接口 requestLayout 和其他一些焦点事件的处理的接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public interface ViewParent &#123;</div><div class="line">    // 请求重新布局</div><div class="line">    public void requestLayout();</div><div class="line"></div><div class="line">    // 是否已经请求布局。这里需要注意，当我们调用 requestLayout 请求布局后，</div><div class="line">    // 这一过程并非是立即执行的，Android 会将请求布局的操作以消息的形式发送</div><div class="line">    // 至主线程的 Handler 并由其分发处理。因此在调用 requestLayout 方法请</div><div class="line">    // 求布局到布局真正接收到重新布局的命令时需要一段时间间隔</div><div class="line">    public boolean isLayoutRequested();</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    // 获取当前 View 的 ViewParent</div><div class="line">    public ViewParent getParent();</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其中有一些方法比较常见，比如 requestLayout 和 bringChildToFront 等。</p><p>ViewGroup 除了所实现的这两个接口与 View 不一样外，还有重要的一点就是 ViewGroup 是抽象类，将 View 的 onLayout 重置为抽象方法。容器子类必须实现 onLayout 来布局定位。</p><p>除此之外，在 View 中比较重要的两个测绘流程的方法 onMeasure 和 onDraw 在 ViewGroup 中都没有被重写，相对于 onMeasure 方法，在 ViewGroup 中增加了一些计算子 View 的方法，如 measureChildren、measureChildrenWithMargins 等；而对于 onDraw 方法，ViewGroup 定义了一个 dispatchDraw 方法来调用其每一个子 View 的 onDraw 方法，由此可见，ViewGroup 真的就象一个容器一样，其职责只是负责对子元素的操作而非具体的个体行为。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0090889bea6c9885.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17 设计模式——代理模式</title>
      <link href="/1901/01/25/02%20DESIGN%20PATTERN/17%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/1901/01/25/02%20DESIGN%20PATTERN/17%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-21869d19b8cd2175.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>代理（Proxy）模式：<strong>为其他对象提供一种代理以控制这个对象的访问</strong>。代理模式也叫委托模式，属于结构型模式。</p><p>在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。</p><p>在软件设计中，使用代理模式的例子也很多。例如，要访问的远程对象比较大（如视频或大图像等），其下载要花很多时间。还有因为安全原因需要屏蔽客户端直接访问真实对象，如某单位的内部数据库等。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li><li>代理对象可以扩展目标对象的功能；</li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</li><li>增加了系统的复杂度；</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>当无法或不想直接访问某个对象或访问某个对象存在困难时，可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口。</p><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><hr><p>模式包含以下主要角色。</p><ul><li>Subject（抽象主题类）：接口或者抽象类，声明真实主题与代理的共同接口方法。</li><li>RealSubject（真实主题类）：也叫做被代理类或被委托类，定义了代理所表示的真实对象，负责具体业务逻辑的执行，客户端可以通过代理类间接的调用真实主题类的方法。</li><li>Proxy（代理类）：也叫委托类，持有对真实主题类的引用，在其所实现的接口方法中调用真实主题类中相应的接口方法执行。</li></ul><p>其结构图如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e57bd2ef4c75480d.gif?imageMogr2/auto-orient/strip" alt=""></p><p>代理模式的实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class ProxyTest &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Proxy proxy = new Proxy();</div><div class="line">        proxy.request();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽象主题</div><div class="line">interface Subject &#123;</div><div class="line">    void request();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 真实主题</div><div class="line">class RealSubject implements Subject &#123;</div><div class="line">    public void request() &#123;</div><div class="line">        System.out.println(&quot;访问真实主题方法...&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 代理</div><div class="line">class Proxy implements Subject &#123;</div><div class="line">    private RealSubject realSubject;</div><div class="line">    public void request() &#123;</div><div class="line">        if (realSubject == null) &#123;</div><div class="line">            realSubject = new RealSubject();</div><div class="line">        &#125;</div><div class="line">        preRequest();</div><div class="line">        realSubject.request();</div><div class="line">        postRequest();</div><div class="line">    &#125;</div><div class="line">    public void preRequest() &#123;</div><div class="line">        System.out.println(&quot;访问真实主题之前的预处理。&quot;);</div><div class="line">    &#125;</div><div class="line">    public void postRequest() &#123;</div><div class="line">        System.out.println(&quot;访问真实主题之后的后续处理。&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序运行的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">访问真实主题之前的预处理。</div><div class="line">访问真实主题方法...</div><div class="line">访问真实主题之后的后续处理。</div></pre></td></tr></table></figure></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>小明被拖欠工资，想走法律程序，找律师去申述这一个过程，使用代理模式律师就是代理者，小明就是被代理者，下面看看这样一个过程，代码应该怎样去实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">public interface ILawsuit &#123;</div><div class="line">    // 提交申请</div><div class="line">    void submit();</div><div class="line">    // 进行举证</div><div class="line">    void burden();</div><div class="line">    // 开始维护</div><div class="line">    void defend();</div><div class="line">    // 诉讼完成</div><div class="line">    void finish();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class XiaoMin implements ILawsuit &#123;</div><div class="line">    @Override</div><div class="line">    public void submit() &#123;</div><div class="line">        // 老板欠小民工资 小小民只好申请仲裁</div><div class="line">        System.out.println(&quot;老板拖欠工资，特此申请仲裁&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void burden() &#123;</div><div class="line">        // 小民证据充足，不怕告不赢</div><div class="line">        System.out.println(&quot;这是合同书和过去一年的银行工资流水&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void defend() &#123;</div><div class="line">        // 铁证如山，辩护也没什么好说的</div><div class="line">        System.out.println(&quot;证据确凿! 不需要再说什么了&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void finish() &#123;</div><div class="line">        // 结果也是肯定的,必赢</div><div class="line">        System.out.println(&quot;诉讼成功! 判决老板即日起七天内结算工资&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Lawyer implements ILawsuit &#123;</div><div class="line">    private ILawsuit mLawsuit;</div><div class="line"></div><div class="line">    public Lawyer(ILawsuit lawsuit) &#123;</div><div class="line">        this.mLawsuit = lawsuit;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void submit() &#123;</div><div class="line">        mLawsuit.submit();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void burden() &#123;</div><div class="line">        mLawsuit.burden();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void defend() &#123;</div><div class="line">        mLawsuit.defend();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void finish() &#123;</div><div class="line">        mLawsuit.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ILawsuit xiaomin = new XiaoMin();</div><div class="line">        // 构造代理律师</div><div class="line">        ILawsuit lawsuit = new Lawyer(xiaomin);</div><div class="line">        // 律师提交诉讼申请</div><div class="line">        lawsuit.submit();</div><div class="line">        // 律师进行举证</div><div class="line">        lawsuit.burden();</div><div class="line">        // 律师代替小民进行辩护</div><div class="line">        lawsuit.defend();</div><div class="line">        // 完成诉讼</div><div class="line">        lawsuit.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从代码的角度来分，代理可以分为两种：一种是<strong>静态代理</strong>，另一种是<strong>动态代理</strong>。</p><p><strong>静态代理</strong>就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。上面的例子实现就是静态代理。</p><p><strong>动态代理</strong>类的源码是在程序运行期间根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。</p><p>下面我们实现动态代理，Java 提供了动态的代理接口 InvocationHandler，实现该接口需要重写 invoke() 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class DynamicProxy implements InvocationHandler &#123;</div><div class="line"></div><div class="line">    private Object obj;    // 被代理的类引用</div><div class="line"></div><div class="line">    public DynamicProxy(Object obj) &#123;</div><div class="line">        this.obj = obj;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</div><div class="line">        // 调用被代理类对象的方法</div><div class="line">        Object result = method.invoke(obj, args);</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用这个动态代理修改小明案例中的客户类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // 构造一个小民</div><div class="line">        ILawsuit xiaomin = new XiaoMin();</div><div class="line">        // 构造一个动态代理</div><div class="line">        DynamicProxy proxy = new DynamicProxy(xiaomin);</div><div class="line">        // 获取被代理类小民的 ClassLoader</div><div class="line">        ClassLoader loader = xiaomin.getClass().getClassLoader();</div><div class="line">        // 动态构造一个代理者律师</div><div class="line">        ILawsuit lawyer = (ILawsuit) Proxy.newProxyInstance(loader, new Class[]&#123;ILawsuit.class&#125;, proxy);</div><div class="line">        // 律师提交诉讼申请</div><div class="line">        lawyer.submit();</div><div class="line">        // 律师进行举证</div><div class="line">        lawyer.burden();</div><div class="line">        // 律师代替小民进行辩护</div><div class="line">        lawyer.defend();</div><div class="line">        // 完成诉讼</div><div class="line">        lawyer.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>静态代理的缺点：</strong></p><ul><li>如果接口新增一个方法，除了所有实现类（真实主题类）需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。</li><li>代理对象只服务于一种类型的对象，如果要服务多类型的对象。必须要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。</li></ul><p><strong>动态代理的优点：</strong></p><ul><li>可以通过一个代理类完成全部的代理功能，接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。当接口方法数量较多时，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。</li><li>动态代理的应用使我们的类职责更加单一，复用性更强。</li></ul><p><strong>动态代理的缺点：</strong></p><ul><li>不能对类进行代理，只能对接口进行代理，如果我们的类没有实现任何接口，那么就不能使用这种方式进行动态代理。</li></ul><p>根据适用范围，代理模式可以分为以下几种：</p><ul><li><strong>远程代理</strong>：为一个对象在不同的地址空间提供局部代表，这样系统可以将Server部分的事项隐藏。</li><li><strong>虚拟代理</strong>：如果要创建一个资源消耗较大的对象，可以先用一个代理对象表示，在真正需要的时候才真正创建。</li><li><strong>保护代理</strong>：用代理对象控制对一个对象的访问，给不同的用户提供不同的访问权限。</li><li><strong>智能引用</strong>：在引用原始对象的时候附加额外操作，并对指向原始对象的引用增加引用计数。</li></ul><h3 id="ANDROID-源码中的实现"><a href="#ANDROID-源码中的实现" class="headerlink" title="ANDROID 源码中的实现"></a>ANDROID 源码中的实现</h3><hr><p>ANDROID 源码中多个地方都用到代理模式，比如 ActivityManagerProxy 这个代理类。其具体代理的是 ActivityManagerNative 的子类 ActivityManagerService。</p><p>ActivityManagerProxy 实现了 IActivityManager 接口，该接口定义了一些 Activity 相关的接口方法，其中有一些我们在应用开发中也时常接触到。IActivityManager 这个接口相当于代理模式中的抽象主题，那么真正的实现主题是 ActivityManagerNative 的子类 ActivityManagerService，这几个类大致的关系：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-111f2d408f5bfe44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>ActivityManagerProxy 实际上代理的是 ActivityManagerService，但是 ActivityManagerProxy 和 ActivityManagerService 是分别运行在不同的进程里（ActivityManagerProxy 是运行在应用的进程，而 ActivityManagerService 是运行在系统进程），所以它们之间的这个代理过程是跨进程的，这里跨进程是用到 Android 的 Binder 机制完成。不过 ActivityManagerProxy 在实际逻辑处理中并未过多地被外部类使用，因为在 Android 中管理与维护 Activity 相关信息的类是另外一个叫做 ActivityManager 的类，ActivityManager 虽然说管理着 Activity 信息，但是实质上大多数逻辑由 ActivityManagerProxy 承担，这里以其中的 getAppTasks 方法为例，在 ActivityManager 中 getAppTasks 方法逻辑如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public List&lt;ActivityManager.AppTask&gt; getAppTasks() &#123;</div><div class="line">    ArrayList&lt;AppTask&gt; tasks = new ArrayList&lt;AppTask&gt;();</div><div class="line">    List&lt;IBinder&gt; appTasks;</div><div class="line">    try &#123;</div><div class="line">        appTasks = getService().getAppTasks(mContext.getPackageName());</div><div class="line">    &#125; catch (RemoteException e) &#123;</div><div class="line">        throw e.rethrowFromSystemServer();</div><div class="line">    &#125;</div><div class="line">    int numAppTasks = appTasks.size();</div><div class="line">    for (int i = 0; i &lt; numAppTasks; i++) &#123;</div><div class="line">        tasks.add(new AppTask(IAppTask.Stub.asInterface(appTasks.get(i))));</div><div class="line">    &#125;</div><div class="line">    return tasks;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>getService() 其实返回的是一个 IActivityManager，那这个 IActivityManager 的实体类是什么呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public static IActivityManager getService() &#123;</div><div class="line">    return IActivityManagerSingleton.get();</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</div><div class="line">        new Singleton&lt;IActivityManager&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            protected IActivityManager create() &#123;</div><div class="line">                final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</div><div class="line">                final IActivityManager am = IActivityManager.Stub.asInterface(b);</div><div class="line">                return am;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div></pre></td></tr></table></figure></p><p>ServiceManager.getService() 返回的是一个系统级的 Service，这个 Service 实际上是 ActivityManagerService，这里也完成创建一个对 ActivityManagerService 的 Client 代理对象 ActivityManagerProxy 实例。ActivityManagerProxy 中的 getAppTasks 方法逻辑就很明确，将数据打包跨进程传递给 Server 端 ActivityManagerService 处理并返回结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public List&lt;IAppTask&gt; getAppTasks(String callingPackage) throws RemoteException &#123;</div><div class="line">    Parcel data = Parcel.obtain();</div><div class="line">    Parcel reply = Parcel.obtain();</div><div class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</div><div class="line">    data.writeString(callingPackage);</div><div class="line">    mRemote.transact(GET_APP_TASKS_TRANSACTION, data, reply, 0);</div><div class="line">    reply.readException();</div><div class="line">    ArrayList&lt;IAppTask&gt; list = null;</div><div class="line">    int N = reply.readInt();</div><div class="line">    if (N &gt;= 0) &#123;</div><div class="line">        list = new ArrayList&lt;&gt;();</div><div class="line">        while (N &gt; 0) &#123;</div><div class="line">            IAppTask task = IAppTask.Stub.asInterface(reply.readStrongBinder());</div><div class="line">            list.add(task);</div><div class="line">            N--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    data.recycle();</div><div class="line">    reply.recycle();</div><div class="line">    return list;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>再来看看 ActivityManagerService 中的 getAppTasks：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public List&lt;IAppTask&gt; getAppTasks(String callingPackage) &#123;</div><div class="line">    int callingUid = Binder.getCallingUid();</div><div class="line">    long ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    synchronized(this) &#123;</div><div class="line">        ArrayList&lt;IAppTask&gt; list = new ArrayList&lt;IAppTask&gt;();</div><div class="line">        try &#123;</div><div class="line">            if (DEBUG_ALL) Slog.v(TAG, &quot;getAppTasks&quot;);</div><div class="line"></div><div class="line">            final int N = mRecentTasks.size();</div><div class="line">            for (int i = 0; i &lt; N; i++) &#123;</div><div class="line">                TaskRecord tr = mRecentTasks.get(i);</div><div class="line">                // Skip tasks that do not match the caller.  We don&apos;t need to verify</div><div class="line">                // callingPackage, because we are also limiting to callingUid and know</div><div class="line">                // that will limit to the correct security sandbox.</div><div class="line">                if (tr.effectiveUid != callingUid) &#123;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">                Intent intent = tr.getBaseIntent();</div><div class="line">                if (intent == null ||</div><div class="line">                        !callingPackage.equals(intent.getComponent().getPackageName())) &#123;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">                ActivityManager.RecentTaskInfo taskInfo =</div><div class="line">                        createRecentTaskInfoFromTaskRecord(tr);</div><div class="line">                AppTaskImpl taskImpl = new AppTaskImpl(taskInfo.persistentId, callingUid);</div><div class="line">                list.add(taskImpl);</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            Binder.restoreCallingIdentity(ident);</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="Binder-跨进程通信机制"><a href="#Binder-跨进程通信机制" class="headerlink" title="Binder 跨进程通信机制"></a>Binder 跨进程通信机制</h3><hr><p>在 Android 中进程间通信我们通常使用到的是 binder 机制，binder 机制所使用到的四个基本模块是 Binder Client、Binder Server、ServerManager 和 Binder Driver。这四者之间的关系类似与网络访问，Binder Client 相当于我们的客户端 pc , Binder Server 相当于服务器，ServerManager 相当于 DNS 服务器，而 Binder Driver 则相当于一个路由器。其中 Binder Driver 实现在内核空间中，而其余的 3 者 Binder Client、Binder Server、ServerManager 实现在用户空间中。</p><p><img src="https://upload-images.jianshu.io/upload_images/8298629-53b95c66788842b7.png?imageMogr2/auto-orient/strip|imageView2/2/w/563/format/webp" alt=""></p><p>Binder Client 与 Binder Server 之间的跨进程通信统一通过 Binder Driver 处理转发，对于 Binder Client 来说，其只需要知道自己要使用的 Binder 的名字以及该 Binder 实体在 ServerManager 中的 0 号引用即可，访问原理也比较简单，Binder Client 先是通过 0 号引用去访问 ServerManager 获取 Binder 的引用，得到引用后就可以像普通方法那样调用 Binder 实体方法。最后我们的 ServerManager 则用来管理 Binder Server，Binder Client 可以通过它来查询 Binder Server接口，刚才提到过 Binder Client 可以通过 ServerManager 来获取 Binder 的引用，这个 Binder 引用就是由 ServerManager 来转换的。</p><p>可以想象成 Binder Driver 就是一个管道，ServerManager 是一个注册表，所有的 Binder Client 和 Binder Server 都要在它那里注册，Binder Client 也通过 ServerManager 去查找对应的 Binder Server。最后，Binder Client 和 Binder Server 其实实现的接口是一样的，所以大家可以联想到 Binder 机制其实也是一种代理模式。</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><hr><p>Notification 适配。通过代理模式解决各个版本的 Notification 碎片化问题，为每种不同的 Notification 样式定义一个类，这里以正常的 64dp Height、256dp Height 和 headsUpContentView 为例，先定义一个抽象类表示通知。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public abstract class Notify &#123;</div><div class="line">    protected Context context;</div><div class="line">    protected NotificationManager nm;</div><div class="line">    protected NotificationCompat.Builder builder;</div><div class="line"></div><div class="line">    public Notify(Context context) &#123;</div><div class="line">        this.context = context;</div><div class="line"></div><div class="line">        nm = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);</div><div class="line">        builder = new NotificationCompat.Builder(context, &quot;default&quot;);</div><div class="line">        PendingIntent intent = PendingIntent.getActivity(context, 0, </div><div class="line">                new Intent(context, TestActivity.class),</div><div class="line">                PendingIntent.FLAG_CANCEL_CURRENT);</div><div class="line">        builder.setSmallIcon(R.drawable.taiji)</div><div class="line">                .setContentIntent(intent);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public abstract void send();    // 发送一条通知</div><div class="line">    public abstract void cancel();  // 取消一条通知</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Notify 声明两个成员变量处理与通知相关的逻辑，且让所有子类共有。两个抽象方法 send 和 cancel 均有具体的子类去实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public class NotifyNormal extends Notify &#123;</div><div class="line"></div><div class="line">    public NotifyNormal(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void send() &#123;</div><div class="line">        Notification n = builder.build();</div><div class="line">        n.contentView = new RemoteViews(context.getPackageName(), R.layout.notify_normal);</div><div class="line">        nm.notify(0, n);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void cancel() &#123;</div><div class="line">        nm.cancel(0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class NotifyBig extends Notify &#123;</div><div class="line"></div><div class="line">    public NotifyBig(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void send() &#123;</div><div class="line">        Notification n = builder.build();</div><div class="line">        n.contentView = new RemoteViews(context.getPackageName(), R.layout.notify_normal);</div><div class="line">        n.bigContentView = new RemoteViews(context.getPackageName(), R.layout.notify_big);</div><div class="line">        nm.notify(0, n);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void cancel() &#123;</div><div class="line">        nm.cancel(0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class NotifyHeadsUp extends Notify &#123;</div><div class="line"></div><div class="line">    public NotifyHeadsUp(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void send() &#123;</div><div class="line">        Notification n = builder.build();</div><div class="line">        n.contentView = new RemoteViews(context.getPackageName(), R.layout.notify_normal);</div><div class="line">        n.bigContentView = new RemoteViews(context.getPackageName(), R.layout.notify_big);</div><div class="line">        n.headsUpContentView = new RemoteViews(context.getPackageName(), R.layout.notify_normal);</div><div class="line">        nm.notify(0, n);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void cancel() &#123;</div><div class="line">        nm.cancel(0);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>最后定义一个代理类来整合上面的几个类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class NotifyProxy extends Notify &#123;</div><div class="line">    private Notify notify;</div><div class="line"></div><div class="line">    public NotifyProxy(Context context) &#123;</div><div class="line">        super(context);</div><div class="line"></div><div class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</div><div class="line">            notify = new NotifyHeadsUp(context);</div><div class="line">        &#125; else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</div><div class="line">            notify = new NotifyBig(context);</div><div class="line">        &#125; else &#123;</div><div class="line">            notify = new NotifyNormal(context);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void send() &#123;</div><div class="line">        notify.send();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void cancel() &#123;</div><div class="line">        notify.cancel();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 NotifyProxy 类中定义一个 Notify 类型的成员变量，在构造方法里根据 SDK 版本的不同去实例化不同的 Notify 子类，最终由该类的 send 和 cancel 方法去调用不同的逻辑实现，这样一来，我们的客户端也就是我们的 Activity 类中就很简单了，直接调用 NotifyProxy 中的方法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new NotifyProxy(TestActivity.this).send();</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-9bffd90d57e1da38.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16 设计模式——中介者模式</title>
      <link href="/1901/01/24/02%20DESIGN%20PATTERN/16%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/1901/01/24/02%20DESIGN%20PATTERN/16%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e7290bbcd669c9f7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>中介者（Mediator）模式：<strong>定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互</strong>。中介者模式又叫调停模式，它是迪米特法则的典型应用。</p><p>在现实生活中，常常会出现好多对象之间存在复杂的交互关系，这种交互关系常常是“网状结构”，它要求每个对象都必须知道它需要交互的对象。例如，每个人必须记住他（她）所有朋友的电话；而且，朋友中如果有人的电话修改了，他（她）必须告诉其他所有的朋友修改，这叫作“牵一发而动全身”，非常复杂。</p><p>如果把这种“网状结构”改为“星形结构”的话，将大大降低它们之间的“耦合性”，这时只要找一个“中介者”就可以了。如前面所说的“每个人必须记住所有朋友电话”的问题，只要在网上建立一个每个朋友都可以访问的“通信录”就解决了。这样的例子还有很多，例如，你刚刚参力口工作想租房，可以找“房屋中介”；或者，自己刚刚到一个陌生城市找工作，可以找“人才交流中心”帮忙。</p><p>在软件的开发过程中，这样的例子也很多，例如，在 MVC 框架中，控制器（C）就是模型（M）和视图（V）的中介者；还有大家常用的 QQ 聊天程序的“中介者”是 QQ 服务器。所有这些，都可以采用“中介者模式”来实现，它将大大降低对象之间的耦合性，提高系统的灵活性。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>降低了对象之间的耦合性，使得对象易于独立地被复用。</li><li>将对象间的多对多关联转变为一对多的关联，提高系统的灵活性，使得系统易于维护和扩展。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>当程序存在大量的类时，多个对象之间存在着依赖的关系，呈现出网状结构，那么程序的可读性和可维护性就变差了，并且修改一个类需要牵涉到其他类，不符合开闭原则。</p><p><img src="https://upload-images.jianshu.io/upload_images/6163786-9895aed658c4cd0c.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/431/format/webp" alt="网状结构"></p><p>因此我们可以引入中介者，将网状结构转化成星型结构，可以降低程序的复杂性，并且可以减少各个对象之间的耦合。</p><p><img src="https://upload-images.jianshu.io/upload_images/6163786-9f940f9d6c3755a7.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/427/format/webp" alt="星型结构"></p><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><hr><p>模式包含以下主要角色。</p><ul><li>Mediator（抽象中介者角色）：抽象类或者接口，定义统一的接口，用于各同事角色之间的通信。</li><li>ConcreteMediator（具体中介者角色）：继承或者实现了抽象中介者，实现了父类定义的方法，协调各个具体同事进行通信。</li><li>Colleague（抽象同事角色）：抽象类或者接口，定义统一的接口，它只知道中介者而不知道其他同事对象。</li><li>ConcreteColleague（具体同事角色）：继承或者实现了抽象同事角色，每个具体同事类都知道自己本身的行为，其他的行为只能通过中介者去进行。</li></ul><p>其结构图如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1b7bcadcf0abb67a.gif?imageMogr2/auto-orient/strip" alt=""></p><p>中介者模式的实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">public class MediatorPattern &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Mediator md = new ConcreteMediator();</div><div class="line">        Colleague c1,c2;</div><div class="line">        c1 = new ConcreteColleague1();</div><div class="line">        c2 = new ConcreteColleague2();</div><div class="line">        md.register(c1);</div><div class="line">        md.register(c2);</div><div class="line">        c1.send();</div><div class="line">        System.out.println(&quot;-------------&quot;);</div><div class="line">        c2.send();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 抽象中介者</div><div class="line">abstract class Mediator &#123;</div><div class="line">    public abstract void register(Colleague colleague);</div><div class="line">    public abstract void relay(Colleague cl); // 转发</div><div class="line">&#125;</div><div class="line">// 具体中介者</div><div class="line">class ConcreteMediator extends Mediator &#123;</div><div class="line">    private List&lt;Colleague&gt; colleagues = new ArrayList&lt;&gt;();</div><div class="line">    public void register(Colleague colleague) &#123;</div><div class="line">        if (!colleagues.contains(colleague)) &#123;</div><div class="line">            colleagues.add(colleague);</div><div class="line">            colleague.setMedium(this);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public void relay(Colleague cl) &#123;</div><div class="line">        for (Colleague ob : colleagues) &#123;</div><div class="line">            if (!ob.equals(cl)) &#123;</div><div class="line">                ob.receive();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 抽象同事类</div><div class="line">abstract class Colleague &#123;</div><div class="line">    protected Mediator mediator;</div><div class="line">    public void setMedium(Mediator mediator) &#123;</div><div class="line">        this.mediator = mediator;</div><div class="line">    &#125;</div><div class="line">    public abstract void receive();</div><div class="line">    public abstract void send();</div><div class="line">&#125;</div><div class="line">// 具体同事类</div><div class="line">class ConcreteColleague1 extends Colleague &#123;</div><div class="line">    public void receive() &#123;</div><div class="line">        System.out.println(&quot;具体同事类1收到请求。&quot;);</div><div class="line">    &#125;</div><div class="line">    public void send() &#123;</div><div class="line">        System.out.println(&quot;具体同事类1发出请求。&quot;);</div><div class="line">        mediator.relay(this); // 请中介者转发</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 具体同事类</div><div class="line">class ConcreteColleague2 extends Colleague &#123;</div><div class="line">    public void receive() &#123;</div><div class="line">        System.out.println(&quot;具体同事类2收到请求。&quot;);</div><div class="line">    &#125;</div><div class="line">    public void send() &#123;</div><div class="line">        System.out.println(&quot;具体同事类2发出请求。&quot;);</div><div class="line">        mediator.relay(this); //请中介者转发</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序的运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">具体同事类1发出请求。</div><div class="line">具体同事类2收到请求。</div><div class="line">-------------</div><div class="line">具体同事类2发出请求。</div><div class="line">具体同事类1收到请求。</div></pre></td></tr></table></figure></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>我们的电脑组件异常之多，读取一个 CD 光盘需要使用 CPU 、光驱、声卡、显卡、内存等一系列组件。如果我们不使用设计模式，那我们每个组件都要保持其他组件的引用，这就会造成我们的类结构复杂难懂，变成一个网状结构。</p><p>解决方法：使用中介者模式可以使一系列组件只和我们的中介（主板）打交道，这就将网状结构变成星型结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line">public abstract class Mediator &#123;</div><div class="line">    /**</div><div class="line">     * 同事对象改变时通知中介者的方法</div><div class="line">     * 同事对象改变时由中介者去通知其他同事。</div><div class="line">     * @param c Colleague</div><div class="line">     */</div><div class="line">    public abstract void changed(Colleague c);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//主板</div><div class="line">public class MainBoard extends Mediator &#123;</div><div class="line">    private CDDevice cd;                // 光驱设备</div><div class="line">    private CPU cpu;                    // CPU</div><div class="line">    private SoundCard soundCard;        // 声卡设备</div><div class="line">    private GraphicsCard graphicsCard;  // 显卡设备</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void changed(Colleague c) &#123;</div><div class="line">        // 如果 CD 读取到数据</div><div class="line">        if (c == cd) &#123;</div><div class="line">            handleCD((CDDevice) c);</div><div class="line">        &#125; else if (c == cpu) &#123;</div><div class="line">            handleCPU((CPU) c);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void handleCD(CDDevice c) &#123;</div><div class="line">        cpu.setData(c.read());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void handleCPU(CPU c) &#123;</div><div class="line">        soundCard.videoPlay(c.getDataSound());</div><div class="line">        graphicsCard.videoPlay(c.getDataVideo());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setCpu(CPU cpu) &#123;</div><div class="line">        this.cpu = cpu;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setSoundCard(SoundCard soundCard) &#123;</div><div class="line">        this.soundCard = soundCard;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setgCard(GraphicsCard graphicsCard) &#123;</div><div class="line">        this.graphicsCard = graphicsCard;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setCd(CDDevice cd) &#123;</div><div class="line">        this.cd = cd;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public abstract class Colleague &#123;</div><div class="line">    private Mediator mediator;</div><div class="line"></div><div class="line">    public Colleague(Mediator mediator) &#123;</div><div class="line">        this.mediator = mediator;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class CDDevice extends Colleague &#123;</div><div class="line"></div><div class="line">    private String data;</div><div class="line"></div><div class="line">    public CDDevice(Mediator mediator) &#123;</div><div class="line">        super(mediator);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String read() &#123;</div><div class="line">        return data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 加载视频数据</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public void load() &#123;</div><div class="line">        data = &quot;视频数据，音频数据&quot;;</div><div class="line">        mediator.changed(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class CPU extends Colleague &#123;</div><div class="line"></div><div class="line">    private String dataVideo, dataSound;    // 视频和音频数据</div><div class="line"></div><div class="line">    public CPU(Mediator mediator) &#123;</div><div class="line">        super(mediator);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getDataVideo() &#123;</div><div class="line">        return dataVideo;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getDataSound() &#123;</div><div class="line">        return dataSound;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setData(String data) &#123;</div><div class="line">        // 分割音、视频数据</div><div class="line">        String[] tmp = data.split(&quot;,&quot;);</div><div class="line">        this.dataVideo = tmp[0];</div><div class="line">        this.dataSound =  tmp[1];</div><div class="line">        // 告诉中介者自身状态改变</div><div class="line">        mediator.changed(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class GraphicsCard extends Colleague &#123;</div><div class="line">    public GraphicsCard(Mediator mediator) &#123;</div><div class="line">        super(mediator);</div><div class="line">    &#125;</div><div class="line">    public void videoPlay(String data)&#123;</div><div class="line">        System.out.println(&quot;视频：&quot;+ data);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class SoundCard extends Colleague &#123;</div><div class="line">    public SoundCard(Mediator mediator) &#123;</div><div class="line">        super(mediator);</div><div class="line">    &#125;</div><div class="line">    public void videoPlay(String data)&#123;</div><div class="line">        System.out.println(&quot;音频：&quot;+ data);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>每个对象只需要关心自己的职责，自己事情处理完成后通知中介者，让中介者调节指导下一步操作。</p><p>客户端代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        MainBoard mainBoard = new MainBoard();</div><div class="line"></div><div class="line">        CDDevice cd = new CDDevice(mainBoard);</div><div class="line">        CPU cpu = new CPU(mainBoard);</div><div class="line">        GCard gc = new GCard(mainBoard);</div><div class="line">        SoundCard sc = new SoundCard(mainBoard);</div><div class="line"></div><div class="line">        mainBoard.setCd(cd);</div><div class="line">        mainBoard.setCpu(cpu);</div><div class="line">        mainBoard.setgCard(gc);</div><div class="line">        mainBoard.setSoundCard(sc);</div><div class="line"></div><div class="line">        cd.load();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="ANDROID-源码中的实现"><a href="#ANDROID-源码中的实现" class="headerlink" title="ANDROID 源码中的实现"></a>ANDROID 源码中的实现</h3><hr><p>ANDROID 中的锁屏功能就用到了中介者模式，KeyguardService（锁屏服务）通过 KeyguardViewMediator（锁屏中介者）来协调各种 Manager 的状态以达到锁屏的功能。这里各种 Manager 都充当了同事的角色。源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">// 锁屏服务，同事角色</div><div class="line">public class KeyguardService extends Service &#123;</div><div class="line">    // 锁屏中介者</div><div class="line">    private KeyguardViewMediator mKeyguardViewMediator;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate() &#123;</div><div class="line">        ((SystemUIApplication) getApplication()).startServicesIfNeeded();</div><div class="line">        // 初始化中介者</div><div class="line">        mKeyguardViewMediator = ((SystemUIApplication) getApplication()).getComponent(KeyguardViewMediator.class);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private final IKeyguardService.Stub mBinder = new IKeyguardService.Stub() &#123;</div><div class="line"></div><div class="line">        @Override // Binder interface</div><div class="line">        public void addStateMonitorCallback(IKeyguardStateCallback callback) &#123;</div><div class="line">            checkPermission();</div><div class="line">            // 调用中介者的接口</div><div class="line">            mKeyguardViewMediator.addStateMonitorCallback(callback);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override // Binder interface</div><div class="line">        public void verifyUnlock(IKeyguardExitCallback callback) &#123;</div><div class="line">            checkPermission();</div><div class="line">            // 调用中介者的接口</div><div class="line">            mKeyguardViewMediator.verifyUnlock(callback);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 其他代码略</div><div class="line"></div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 锁屏中介者</div><div class="line">public class KeyguardViewMediator extends SystemUI &#123;</div><div class="line">    // 各种 Manager，同事角色</div><div class="line">    private AlarmManager mAlarmManager;</div><div class="line">    private AudioManager mAudioManager;</div><div class="line">    private StatusBarManager mStatusBarManager;</div><div class="line">    private PowerManager mPM;</div><div class="line">    private IWindowManager mWM;</div><div class="line">    private TrustManager mTrustManager;</div><div class="line">    private SearchManager mSearchManager;</div><div class="line">    private PowerManager.WakeLock mShowKeyguardWakeLock;</div><div class="line">    private StatusBarKeyguardViewManager mStatusBarKeyguardViewManager;</div><div class="line"></div><div class="line">    //其他代码略</div><div class="line"></div><div class="line">    // 通过 AudioManager 去播放声音</div><div class="line">    private void playSound(int soundId) &#123;</div><div class="line">        if (soundId == 0) return;</div><div class="line">        final ContentResolver cr = mContext.getContentResolver();</div><div class="line">        if (Settings.System.getInt(cr, Settings.System.LOCKSCREEN_SOUNDS_ENABLED, 1) == 1) &#123;</div><div class="line"></div><div class="line">            mLockSounds.stop(mLockSoundStreamId);</div><div class="line">            // Init mAudioManager</div><div class="line">            if (mAudioManager == null) &#123;</div><div class="line">                mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);</div><div class="line">                if (mAudioManager == null) return;</div><div class="line">                mUiSoundsStreamType = mAudioManager.getUiSoundsStreamType();</div><div class="line">            &#125;</div><div class="line">            // If the stream is muted, don&apos;t play the sound</div><div class="line">            if (mAudioManager.isStreamMute(mUiSoundsStreamType)) return;</div><div class="line"></div><div class="line">            mLockSoundStreamId = mLockSounds.play(soundId,</div><div class="line">                    mLockSoundVolume, mLockSoundVolume, 1/*priortiy*/, 0/*loop*/, 1.0f/*rate*/);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>KeyguardViewMediator 中通过 playSound 方法能够协调 AudioManager 去控制声音的播放等等，其他 Manager 同理。</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><hr><p>登录界面运用中介者模式，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ea27b82b9898512f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>一个简单的登录界面，包含两个文本框、两个复选框、两个按钮。只有 6 个元素，但要实现如下逻辑：<br>1）当用户名没有输入时，除了账户文本输入框、取消按钮外均不可用；当有用户名输入时，记住账号也可用。<br>2）当密码文本框有输入时，自动登录、确定按钮皆可用，否则皆不可用。<br>3）勾选自动登录，那么记住账号会被同时勾选。<br>4）清空密码，取消自动登录选中状态并且不可用；清空账号则取消两个复选框的状态并且都不可用。<br>5）……</p><p>这是一个多 UI 控件交互的情景，此时很适合让 Activity 来充当一个中介者并在其中处理相关逻辑。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div></pre></td><td class="code"><pre><div class="line">public class LoginActivity extends BaseActivity &#123;</div><div class="line"></div><div class="line">    private EditText etAccount, etPassword;</div><div class="line">    private CheckBox cbRemember, cbAuto;</div><div class="line">    private Button btnEnsure, btnCancel;</div><div class="line"></div><div class="line">    private String strAccount, strPassword; // 账户、密码</div><div class="line">    private boolean isRemember, isAuto;     // 是否记住账号、自动登录</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_test);</div><div class="line"></div><div class="line">        initViews();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initViews() &#123;</div><div class="line">        etAccount = findViewById(R.id.login_account_et);</div><div class="line">        etPassword = findViewById(R.id.login_password_et);</div><div class="line"></div><div class="line">        cbRemember = findViewById(R.id.login_remember_cb);</div><div class="line">        cbAuto = findViewById(R.id.login_auto_cb);</div><div class="line"></div><div class="line">        btnEnsure = findViewById(R.id.login_ensure_btn);</div><div class="line">        btnCancel = findViewById(R.id.login_cancel_btn);</div><div class="line"></div><div class="line">        // 账户</div><div class="line">        etAccount.addTextChangedListener(new TextWatcher() &#123;</div><div class="line">            @Override</div><div class="line">            public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onTextChanged(CharSequence s, int start, int before, int count) &#123;</div><div class="line">                // 回传数据</div><div class="line">                strAccount = s.toString();</div><div class="line">                // 通知 Activity 状态改变</div><div class="line">                change();</div><div class="line">            &#125;</div><div class="line">            @Override</div><div class="line">            public void afterTextChanged(Editable s) &#123;&#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        // 密码</div><div class="line">        etPassword.setEnabled(false);</div><div class="line">        etPassword.addTextChangedListener(new TextWatcher() &#123;</div><div class="line">            @Override</div><div class="line">            public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onTextChanged(CharSequence s, int start, int before, int count) &#123;</div><div class="line">                // 回传数据</div><div class="line">                strPassword = s.toString();</div><div class="line">                // 通知 Activity 状态改变</div><div class="line">                change();</div><div class="line">            &#125;</div><div class="line">            @Override</div><div class="line">            public void afterTextChanged(Editable s) &#123;&#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        // 记住账户</div><div class="line">        cbRemember.setEnabled(false);</div><div class="line">        cbRemember.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123;</div><div class="line">                // 回传数据</div><div class="line">                isRemember = isChecked;</div><div class="line">                // 通知 Activity 状态改变</div><div class="line">                change();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        // 自动登录</div><div class="line">        cbAuto.setEnabled(false);</div><div class="line">        cbAuto.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123;</div><div class="line">                // 回传数据</div><div class="line">                isAuto = isChecked;</div><div class="line">                isRemember = isAuto || isRemember;</div><div class="line">                // 通知 Activity 状态改变</div><div class="line">                change();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        // 确定按钮</div><div class="line">        btnEnsure.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                Toast.makeText(LoginActivity.this, &quot;登录成功&quot;, Toast.LENGTH_LONG).show();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        // 取消按钮</div><div class="line">        btnCancel.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                Toast.makeText(LoginActivity.this, &quot;取消登录&quot;, Toast.LENGTH_LONG).show();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 各控件状态改变后协调各控件状态显示</div><div class="line">     */</div><div class="line">    private void change() &#123;</div><div class="line">        if (TextUtils.isEmpty(strAccount)) &#123;</div><div class="line">            etPassword.setEnabled(false);</div><div class="line">            cbRemember.setEnabled(false);</div><div class="line">            cbAuto.setEnabled(false);</div><div class="line">            btnEnsure.setEnabled(false);</div><div class="line">            btnCancel.setEnabled(true);</div><div class="line">            isRemember = false;</div><div class="line">            isAuto = false;</div><div class="line">        &#125; else if (!TextUtils.isEmpty(strAccount)</div><div class="line">                &amp;&amp; TextUtils.isEmpty(strPassword)) &#123;</div><div class="line">            etPassword.setEnabled(true);</div><div class="line">            cbRemember.setEnabled(true);</div><div class="line">            cbAuto.setEnabled(false);</div><div class="line">            btnEnsure.setEnabled(false);</div><div class="line">            btnCancel.setEnabled(true);</div><div class="line">            isAuto = false;</div><div class="line">        &#125; else if (!TextUtils.isEmpty(strAccount)</div><div class="line">                &amp;&amp; !TextUtils.isEmpty(strPassword)) &#123;</div><div class="line">            etPassword.setEnabled(true);</div><div class="line">            cbRemember.setEnabled(true);</div><div class="line">            cbAuto.setEnabled(true);</div><div class="line">            btnEnsure.setEnabled(true);</div><div class="line">            btnCancel.setEnabled(true);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        cbRemember.setChecked(isRemember);</div><div class="line">        cbAuto.setChecked(isAuto);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d34b4cd324ee4526.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15 设计模式——访问者模式</title>
      <link href="/1901/01/23/02%20DESIGN%20PATTERN/15%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/1901/01/23/02%20DESIGN%20PATTERN/15%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b81ac1f5833e5fef.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>访问者（Visitor）模式：<strong>封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作</strong>。</p><p>访问者模式是一种将数据操作与数据结构分离的设计模式，它是 23 种设计模式中最复杂的一个，但是它的使用频率并不高，正如《设计模式》的作者 GOF 对访问者模式的描述：大多数情况下，并不需要使用访问者模式，但是当你一旦需要使用它时，那你就是真的需要它了。</p><p>访问者模式的基本想法是，软件系统中拥有一个由许多对象构成的、比较稳定的对象结构，这些对象的类都拥有一个 accept 方法用来接受访问者对象的访问。访问者是一个接口，它拥有一个 visit 方法，这个方法对访问到的对象结构中不同类型的元素做出不同的处理。在对象结构的每一次访问过程中，我们遍历整个对象结构，对每一个元素都实施 accept 方法，在每一个元素的 accept 方法中会调用访问者的 visit 方法，从而使访问者得以处理对象结构的每一个元素，我们可以针对对象结构设计不同的访问者类来完成不同的操作，达到区别对待的效果。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>各角色职责分离，符合单一职责原则。</li><li>具有优秀的扩展性。</li><li>使得数据结构和作用于结构上的操作解耦，使得操作集合可以独立变化。</li><li>灵活性。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>具体元素对访问者公布细节，违反了迪米特原则。</li><li>违反了依赖倒置原则，为了达到“区别对待”而依赖了具体类，没有依赖抽象。</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>对象结构比较稳定，但经常需要在此对象结构上定义新的操作。</li><li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。</li></ul><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><hr><p>模式包含以下主要角色。</p><ul><li>Visitor（抽象访问者）：接口或者抽象类，为每一个元素（Element）声明一个访问的方法。</li><li>ConcreteVisitor（具体访问者）：实现抽象访问者中的方法，即对每一个元素都有其具体的访问行为。</li><li>Element（抽象元素）：接口或者抽象类，定义一个accept方法，能够接受访问者（Visitor）的访问。</li><li>ConcreteElementA、ConcreteElementB（具体元素）：实现抽象元素中的accept方法，通常是调用访问者提供的访问该元素的方法。</li><li>Object Structure（对象结构）：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。</li><li>Client（客户端类）：即要使用访问者模式的地方。</li></ul><p>其结构图如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-fbc56ff0dc65be02.gif?imageMogr2/auto-orient/strip" alt=""></p><p>访问者模式的实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">public class VisitorPattern &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ObjectStructure os = new ObjectStructure();</div><div class="line">        os.add(new ConcreteElementA());</div><div class="line">        os.add(new ConcreteElementB());</div><div class="line">        Visitor visitor = new ConcreteVisitorA();</div><div class="line">        os.accept(visitor);</div><div class="line">        System.out.println(&quot;------------------------&quot;);</div><div class="line">        visitor = new ConcreteVisitorB();</div><div class="line">        os.accept(visitor);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 抽象访问者</div><div class="line">interface Visitor &#123;</div><div class="line">    void visit(ConcreteElementA element);</div><div class="line">    void visit(ConcreteElementB element);</div><div class="line">&#125;</div><div class="line">// 具体访问者 A 类</div><div class="line">class ConcreteVisitorA implements Visitor &#123;</div><div class="line">    public void visit(ConcreteElementA element) &#123;</div><div class="line">        System.out.println(&quot;具体访问者A访问--&gt;&quot;+element.operationA());</div><div class="line">    &#125;</div><div class="line">    public void visit(ConcreteElementB element) &#123;</div><div class="line">        System.out.println(&quot;具体访问者A访问--&gt;&quot;+element.operationB());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 具体访问者 B 类</div><div class="line">class ConcreteVisitorB implements Visitor &#123;</div><div class="line">    public void visit(ConcreteElementA element) &#123;</div><div class="line">        System.out.println(&quot;具体访问者B访问--&gt;&quot;+element.operationA());</div><div class="line">    &#125;</div><div class="line">    public void visit(ConcreteElementB element) &#123;</div><div class="line">        System.out.println(&quot;具体访问者B访问--&gt;&quot;+element.operationB());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 抽象元素类</div><div class="line">interface Element &#123;</div><div class="line">    void accept(Visitor visitor);</div><div class="line">&#125;</div><div class="line">// 具体元素 A 类</div><div class="line">class ConcreteElementA implements Element &#123;</div><div class="line">    public void accept(Visitor visitor) &#123;</div><div class="line">        visitor.visit(this);</div><div class="line">    &#125;</div><div class="line">    public String operationA() &#123;</div><div class="line">        return &quot;具体元素A的操作。&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 具体元素 B 类</div><div class="line">class ConcreteElementB implements Element &#123;</div><div class="line">    public void accept(Visitor visitor) &#123;</div><div class="line">        visitor.visit(this);</div><div class="line">    &#125;</div><div class="line">    public String operationB() &#123;</div><div class="line">        return &quot;具体元素B的操作。&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 对象结构角色</div><div class="line">class ObjectStructure &#123;</div><div class="line">    private List&lt;Element&gt; list = new ArrayList&lt;Element&gt;();</div><div class="line">    public void accept(Visitor visitor) &#123;</div><div class="line">        Iterator&lt;Element&gt; i= list.iterator();</div><div class="line">        while (i.hasNext()) &#123;</div><div class="line">            ((Element) i.next()).accept(visitor);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public void add(Element element) &#123;</div><div class="line">        list.add(element);</div><div class="line">    &#125;</div><div class="line">    public void remove(Element element) &#123;</div><div class="line">        list.remove(element);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序的运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">具体访问者A访问--&gt;具体元素A的操作。</div><div class="line">具体访问者A访问--&gt;具体元素B的操作。</div><div class="line">------------------------</div><div class="line">具体访问者B访问--&gt;具体元素A的操作。</div><div class="line">具体访问者B访问--&gt;具体元素B的操作。</div></pre></td></tr></table></figure></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>利用“访问者（Visitor）模式”模拟艺术公司与造币公司的功能。</p><p>分析：艺术公司利用“铜”可以设计出铜像，利用“纸”可以画出图画；造币公司利用“铜”可以印出铜币，利用“纸”可以印出纸币。对“铜”和“纸”这两种元素，两个公司的处理方法不同，所以该实例用访问者模式来实现比较适合。</p><p>首先，定义一个公司（Company）接口，它是抽象访问者，提供了两个根据纸（Paper）或铜（Cuprum）这两种元素创建作品的方法；再定义艺术公司（ArtCompany）类和造币公司（Mint）类，它们是具体访问者，实现了父接口的方法；然后，定义一个材料（Material）接口，它是抽象元素，提供了 accept（Company visitor）方法来接受访问者（Company）对象访问；再定义纸（Paper）类和铜（Cuprum）类，它们是具体元素类，实现了父接口中的方法；最后，定义一个材料集（SetMaterial）类，它是对象结构角色，拥有保存所有元素的容器 List，并提供让访问者对象遍历容器中的所有元素的 accept（Company visitor）方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">// 抽象访问者：公司</div><div class="line">interface Company &#123;</div><div class="line">    String create(Paper element);</div><div class="line">    String create(Cuprum element);</div><div class="line">&#125;</div><div class="line">// 具体访问者：艺术公司</div><div class="line">class ArtCompany implements Company &#123;</div><div class="line">    public String create(Paper element) &#123;</div><div class="line">        return &quot;讲学图&quot;;</div><div class="line">    &#125;</div><div class="line">    public String create(Cuprum element) &#123;</div><div class="line">        return &quot;朱熹铜像&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 具体访问者：造币公司</div><div class="line">class Mint implements Company &#123;</div><div class="line">    public String create(Paper element) &#123;</div><div class="line">        return &quot;纸币&quot;;</div><div class="line">    &#125;</div><div class="line">    public String create(Cuprum element) &#123;</div><div class="line">        return &quot;铜币&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 抽象元素：材料</div><div class="line">interface Material &#123;</div><div class="line">    String accept(Company visitor);</div><div class="line">&#125;</div><div class="line">// 具体元素：纸</div><div class="line">class Paper implements Material &#123;</div><div class="line">    public String accept(Company visitor) &#123;</div><div class="line">        return (visitor.create(this));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 具体元素：铜</div><div class="line">class Cuprum implements Material &#123;</div><div class="line">    public String accept(Company visitor) &#123;</div><div class="line">        return (visitor.create(this));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 对象结构角色:材料集</div><div class="line">class SetMaterial &#123;</div><div class="line">    private List&lt;Material&gt; list = new ArrayList&lt;&gt;();</div><div class="line">    public String accept(Company visitor) &#123;</div><div class="line">        Iterator&lt;Material&gt; iterator = list.iterator();</div><div class="line">        StringBuilder sb = new StringBuilder();</div><div class="line">        String temp;</div><div class="line">        while(iterator.hasNext()) &#123;</div><div class="line">            temp = iterator.next().accept(visitor);</div><div class="line">            sb.append(temp).append(&quot; &quot;);</div><div class="line">        &#125;</div><div class="line">        return sb.toString(); // 返回某公司的作品集</div><div class="line">    &#125;</div><div class="line">    public void add(Material element) &#123;</div><div class="line">        list.add(element);</div><div class="line">    &#125;</div><div class="line">    public void remove(Material element) &#123;</div><div class="line">        list.remove(element);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="ANDROID-源码中的实现"><a href="#ANDROID-源码中的实现" class="headerlink" title="ANDROID 源码中的实现"></a>ANDROID 源码中的实现</h3><hr><p>Android 的编译时注解是一种访问者模式。编译时注解的核心原理依赖 APT （Annotation Processing Tools）实现。</p><p>编译时注解解析的基本原理是，在某些代码元素上（如类型、函数、字段等）添加注解，在编译时编译器会检查 AbstractProcessor 的子类，并且调用该类型的 process 函数，然后将添加了注解的所有元素都传递到 process 函数中，使得开发人员可以在编译期进行相应的处理。</p><p>编写注解处理器的核心是 AnnotationProcessorFactory 和 AnnotationProcessor 两个接口，后者表示的是注解处理器，而前者则是为某些注解类型创建注解处理器的工厂。</p><p>对于编译器来说，代码中的元素结构是基本不变的，例如，组成代码的基本元素由包、类、函数、字段、类型参数、变量。JDK 中为这些元素定义了一个基类，也就是 Element 类，它有如下几个子类：</p><ul><li>PackageElement 包元素，包含了某个包下的信息，可以获取到包名等；</li><li>TypeElement：类型元素，如某个字段属于某种类型；</li><li>ExecutableElement：可执行元素，代表了函数类型的元素；</li><li>VariableElement：变量元素；</li><li>TypeParameterElement：类型参数元素。</li></ul><p>因为注解可以指定作用在哪些元素上，因此，通过上述的抽象来对应这些元素，例如下面这个注解，指定的是只能作用于方法上面，并且这个注解只能保留在 class 文件中（编译时注解）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Target(ElementType. METHOD)</div><div class="line">@Retention(RetentionPolicy.CLASS)</div><div class="line">public @interface Test &#123;</div><div class="line">    String value();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>该注解因为只能作用于函数类型，因此，它对应的元素类型就是 ExecutableElement，当我们想通过 APT 处理这个注解时就可以获取目标对象上的 Test 注解，并将所有这些元素转换为 ExecutableElement 元素，以便获取到它们对应的信息。</p><p>我们看看元素基类的实现，完整的路径为 javax.lang.model.element.Element。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public interface Element extends AnnotatedConstruct &#123;</div><div class="line">    TypeMirror asType();</div><div class="line">    // 获取元素类型</div><div class="line">    ElementKind getKind();</div><div class="line">    // 获取元素修饰符，如 public、static、final 等</div><div class="line">    Set&lt;Modifier&gt; getModifiers();</div><div class="line"></div><div class="line">    // 代码省略</div><div class="line"></div><div class="line">    List&lt;? extends Element&gt; getEnclosedElements();</div><div class="line">    // 接受访问者的访问</div><div class="line">    &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看到 Element 定义了一个代码元素的一些通用接口，其中很显眼的就是 accept 函数，这个函数接收一个 ElementVisitor 和类型为 P 的参数，ElementVisitor 就是访问者类型，而 P 则用于传递一些额外的参数给 visitor。这是一个典型的访问者模式。</p><p>ElementVisitor 定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 元素访问者</div><div class="line">public interface ElementVisitor&lt;R, P&gt; &#123;</div><div class="line">    // 访问元素</div><div class="line">    R visit(Element var1, P var2);</div><div class="line"></div><div class="line">    R visit(Element var1);</div><div class="line">    // 访问包元素</div><div class="line">    R visitPackage(PackageElement var1, P var2);</div><div class="line">    // 访问类型元素</div><div class="line">    R visitType(TypeElement var1, P var2);</div><div class="line">    // 访问变量元素</div><div class="line">    R visitVariable(VariableElement var1, P var2);</div><div class="line">    // 访问可执行元素</div><div class="line">    R visitExecutable(ExecutableElement var1, P var2);</div><div class="line">    // 访问参数元素</div><div class="line">    R visitTypeParameter(TypeParameterElement var1, P var2);</div><div class="line">    // 访问位置元素，为后续扩展预留的接口</div><div class="line">    R visitUnknown(Element var1, P var2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当 Visitor 对元素结构进行访问时，就可以针对不同的类型进行不同的处理。例如 SimpleElementVisitor6 就是其中一个访问者，它基本上没做什么操作，直接返回了元素的默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">@SupportedSourceVersion(SourceVersion.RELEASE_6)</div><div class="line">public class SimpleElementVisitor6&lt;R, P&gt; extends AbstractElementVisitor6&lt;R, P&gt; &#123;</div><div class="line">    protected final R DEFAULT_VALUE;</div><div class="line"></div><div class="line">    protected SimpleElementVisitor6() &#123;</div><div class="line">        this.DEFAULT_VALUE = null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected SimpleElementVisitor6(R var1) &#123;</div><div class="line">        this.DEFAULT_VALUE = var1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected R defaultAction(Element var1, P var2) &#123;</div><div class="line">        return this.DEFAULT_VALUE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public R visitPackage(PackageElement var1, P var2) &#123;</div><div class="line">        return this.defaultAction(var1, var2);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public R visitType(TypeElement var1, P var2) &#123;</div><div class="line">        return this.defaultAction(var1, var2);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public R visitVariable(VariableElement var1, P var2) &#123;</div><div class="line">        return var1.getKind() != ElementKind.RESOURCE_VARIABLE ? this.defaultAction(var1, var2) : this.visitUnknown(var1, var2);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public R visitExecutable(ExecutableElement var1, P var2) &#123;</div><div class="line">        return this.defaultAction(var1, var2);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public R visitTypeParameter(TypeParameterElement var1, P var2) &#123;</div><div class="line">        return this.defaultAction(var1, var2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>另一个提取元素类型的访问者是 ElementKindVisitor6：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">@SupportedSourceVersion(SourceVersion.RELEASE_6)</div><div class="line">public class ElementKindVisitor6&lt;R, P&gt; extends SimpleElementVisitor6&lt;R, P&gt; &#123;</div><div class="line">    protected ElementKindVisitor6() &#123;</div><div class="line">        super((Object)null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected ElementKindVisitor6(R var1) &#123;</div><div class="line">        super(var1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public R visitPackage(PackageElement var1, P var2) &#123;</div><div class="line">        assert var1.getKind() == ElementKind.PACKAGE : &quot;Bad kind on PackageElement&quot;;</div><div class="line"></div><div class="line">        return this.defaultAction(var1, var2);</div><div class="line">    &#125;</div><div class="line">    // 访问类型元素，比如类、注解、枚举、接口</div><div class="line">    public R visitType(TypeElement var1, P var2) &#123;</div><div class="line">        ElementKind var3 = var1.getKind();</div><div class="line">        switch(var3) &#123;</div><div class="line">        case ANNOTATION_TYPE:</div><div class="line">            return this.visitTypeAsAnnotationType(var1, var2);</div><div class="line">        case CLASS:</div><div class="line">            return this.visitTypeAsClass(var1, var2);</div><div class="line">        case ENUM:</div><div class="line">            return this.visitTypeAsEnum(var1, var2);</div><div class="line">        case INTERFACE:</div><div class="line">            return this.visitTypeAsInterface(var1, var2);</div><div class="line">        default:</div><div class="line">            throw new AssertionError(&quot;Bad kind &quot; + var3 + &quot; for TypeElement&quot; + var1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public R visitTypeAsAnnotationType(TypeElement var1, P var2) &#123;</div><div class="line">        return this.defaultAction(var1, var2);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public R visitTypeAsClass(TypeElement var1, P var2) &#123;</div><div class="line">        return this.defaultAction(var1, var2);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public R visitTypeAsEnum(TypeElement var1, P var2) &#123;</div><div class="line">        return this.defaultAction(var1, var2);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public R visitTypeAsInterface(TypeElement var1, P var2) &#123;</div><div class="line">        return this.defaultAction(var1, var2);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ElementKindVisitor6 对于不同的类型进行不同的处理，提取各个元素的类型信息，例如，上述代码中对于 Type 类型的元素将分别进行处理，如类、枚举、接口、注解等。</p><p>首先，编译器将代码抽象成一个代码元素的树，然后再编译时对整棵树进行遍历访问，每个元素都有一个 accept 函数接受访问者的访问，每个访问者中都有对应的 visit 函数，例如，visitType 函数就是对类型元素的访问，在每个 visit 函数中对不同的类型进行不同的处理，这样就达到了差异处理的效果，同时将数据结构和数据操作分离，使得每个类型的职责单一，易于升级维护。JDK 还特意预留了 visitUnknown 接口来应对 Java 语言后续发展可能添加元素类型的问题，灵活地将访问者模式的缺点优化。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-62fa194db5869cc7.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14 设计模式——模板方法模式</title>
      <link href="/1901/01/22/02%20DESIGN%20PATTERN/14%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/1901/01/22/02%20DESIGN%20PATTERN/14%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1d89e09424b40dce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>模板方法（Template Method）模式：<strong>定义一个操作中的算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</strong>。</p><p>在面向对象开发过程中，通常会遇到这样的一个问题，我们知道一个算法所需的关键步骤，并确定了这些步骤的执行顺序，但是某些步骤的具体实现是未知的，或者说某些步骤的实现是会随着环境的变化而改变的。</p><p>例如，执行程序的流程大致如下：<br>1）检查代码的正确性；<br>2）链接相关的类库；<br>3）编译相关代码；<br>4）执行程序。</p><p>对于不同的程序设计语言，上述 4 个步骤都是不一样的，但是它们的执行流程都是固定的，这类问题的解决方案就是模板方法模式。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li><li>它在父类中提取了公共的部分代码，便于代码复用。</li><li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li><li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>多个子类有公有的方法，并且逻辑基本相同时。</li><li>重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能由各个子类实现。</li><li>重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为。</li></ul><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><hr><p>模板方法模式需要注意抽象类与具体子类之间的协作。它用到了虚函数的多态性技术以及“不用调用我，让我来调用你”的反向控制技术。现在来介绍它们的基本结构。</p><p>模式包含以下主要角色。</p><ul><li>AbstractClass：抽象类，定义了一整套算法框架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。<ul><li>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</li><li>基本方法：是整个算法中的一个步骤，包含以下几种类型。<ul><li>抽象方法：在抽象类中申明，由具体子类实现。</li><li>具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。</li><li>钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</li></ul></li></ul></li><li>ConcreteClass：具体实现类，根据需要去实现抽象类中的方法。</li></ul><p>其结构图如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0df76e430f09a758.gif?imageMogr2/auto-orient/strip" alt=""></p><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class TemplateMethodPattern &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        AbstractClass tm = new ConcreteClass();</div><div class="line">        tm.TemplateMethod();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 抽象类</div><div class="line">abstract class AbstractClass &#123;</div><div class="line">    // 模板方法，不允许覆写</div><div class="line">    public final void TemplateMethod() &#123;</div><div class="line">        SpecificMethod();</div><div class="line">        abstractMethod1();</div><div class="line">        abstractMethod2();</div><div class="line">    &#125;</div><div class="line">    // 具体方法</div><div class="line">    public void SpecificMethod() &#123;</div><div class="line">        System.out.println(&quot;抽象类中的具体方法被调用...&quot;);</div><div class="line">    &#125;</div><div class="line">    public abstract void abstractMethod1(); // 抽象方法1</div><div class="line">    public abstract void abstractMethod2(); // 抽象方法2</div><div class="line">&#125;</div><div class="line">// 具体子类</div><div class="line">class ConcreteClass extends AbstractClass &#123;</div><div class="line">    public void abstractMethod1() &#123;</div><div class="line">        System.out.println(&quot;抽象方法1的实现被调用...&quot;);</div><div class="line">    &#125;</div><div class="line">    public void abstractMethod2() &#123;</div><div class="line">        System.out.println(&quot;抽象方法2的实现被调用...&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>以送快递为例，快递员送快递基本就是一套固定的流程：收到快递 &gt;&gt; 准备派送 &gt;&gt; 联系收货人 &gt;&gt; 确定结果。</p><p>定义算法框架，这里是快递员派送快递的步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">// 抽象快递员类</div><div class="line">public abstract class Postman &#123;</div><div class="line">    // 派送流程</div><div class="line">    // 这里申明为final，不希望子类覆盖这个方法，防止更改流程的执行顺序</div><div class="line">    public final void post() &#123;</div><div class="line">        prepare();      // 准备派送</div><div class="line">        call();         // 联系收货人</div><div class="line">        if (isSign()) &#123; // 是否签收</div><div class="line">            sign();     // 签收</div><div class="line">        &#125; else &#123;</div><div class="line">            refuse();   //拒签</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 准备操作，固定流程，父类实现</div><div class="line">    protected void prepare() &#123;</div><div class="line">        System.out.println(&quot;快递已达到，准备派送&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 联系收货人，联系人不一样，所以为抽象方法，子类实现</div><div class="line">    protected abstract void call();</div><div class="line"></div><div class="line">    // 是否签收,这个是钩子方法，用来控制流程的走向</div><div class="line">    protected boolean isSign() &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 签收，这个是固定流程，父类实现</div><div class="line">    protected void sign() &#123;</div><div class="line">        System.out.println(&quot;客户已签收，上报系统&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 拒签，空实现，这个也是钩子方法，子类可以跟进实际来决定是否去实现这个方法</div><div class="line">    protected void refuse() &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>根据需要去实现抽象类中的方法，下面以派送给两个不同的人为例，其中一个签收，另一个拒收：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 派送给 A 先生</div><div class="line">public class PostA extends Postman &#123;</div><div class="line">    // 联系收货，实现父类的抽象方法</div><div class="line">    @Override</div><div class="line">    protected void call() &#123;</div><div class="line">        System.out.println(&quot;联系A先生并送到门口&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 派送给 B 先生</div><div class="line">public class PostB extends Postman &#123;</div><div class="line">    // 联系收货，实现父类的抽象方法</div><div class="line">    @Override</div><div class="line">    protected void call() &#123;</div><div class="line">        System.out.println(&quot;联系B先生并送到门口&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 是否签收，覆盖父类的钩子方法，控制流程的走向</div><div class="line">    @Override</div><div class="line">    protected boolean isSign() &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 拒签，覆盖父类的钩子方法</div><div class="line">    @Override</div><div class="line">    protected void refuse() &#123;</div><div class="line">        System.out.println(&quot;拒绝签收：商品不符&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>客户端测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void test()&#123;</div><div class="line">    System.out.println(&quot;----派送A----&quot;);</div><div class="line">    Postman postA=new PostA();</div><div class="line">    postA.post();</div><div class="line">    System.out.println(&quot;----派送B----&quot;);</div><div class="line">    Postman postB=new PostB();</div><div class="line">    postB.post();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">----派送A----</div><div class="line">快递已达到，准备派送</div><div class="line">联系A先生并送到门口</div><div class="line">客户已签收，上报系统</div><div class="line">----派送B----</div><div class="line">快递已达到，准备派送</div><div class="line">联系B先生并送到门口</div><div class="line">拒绝签收：商品不符</div></pre></td></tr></table></figure></p><h3 id="ANDROID-源码中的实现"><a href="#ANDROID-源码中的实现" class="headerlink" title="ANDROID 源码中的实现"></a>ANDROID 源码中的实现</h3><hr><p>在 ANDROID 中，使用模板方法模式的示例有很多。例如：Activity 的生命周期函数、View 的 draw 方法 和 AsyncTask 类。</p><p>AsyncTask 的整个执行过程其实是一个框架，具体的实现都需要子类来完成，而且它执行的算法框架是固定的，调用 execute 后会依次执行 onPreExecute、doInBackground、onPostExecute，当然也可以通过 onProgressUpdate 来更新进度。</p><p>AsyncTask 的 execute 方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">@MainThread</div><div class="line">public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</div><div class="line">    return executeOnExecutor(sDefaultExecutor, params);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@MainThread</div><div class="line">public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,</div><div class="line">                                                                   Params... params) &#123;</div><div class="line">    if (mStatus != Status.PENDING) &#123;</div><div class="line">        switch (mStatus) &#123;</div><div class="line">            case RUNNING:</div><div class="line">                throw new IllegalStateException(&quot;Cannot execute task:&quot;</div><div class="line">                        + &quot; the task is already running.&quot;);</div><div class="line">            case FINISHED:</div><div class="line">                throw new IllegalStateException(&quot;Cannot execute task:&quot;</div><div class="line">                        + &quot; the task has already been executed &quot;</div><div class="line">                        + &quot;(a task can be executed only once)&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mStatus = Status.RUNNING;</div><div class="line">    onPreExecute();</div><div class="line"></div><div class="line">    mWorker.mParams = params;</div><div class="line">    exec.execute(mFuture);</div><div class="line"></div><div class="line">    return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看到 execute 方法是一个 final 方法，它调用了 executeOnExecutor 方法。如果不是 Pending 状态会抛出异常，这也解释了为什么 AsyncTask 只能被执行一次，因为 AsyncTask 的 Running 和 Finished 状态都会抛出异常，因此每次使用 AsyncTask 时都需要重新创建一个对象。</p><p>继续往下看，在 executeOnExecutor 方法中首先执行了 onPreExecute 方法，因为 AsyncTask 的要求是需要在 UI 线程中调用 execute 方法。因此，onPreExecute 方法也在 UI 线程中执行，然后将 params 参数传递给 mWorker 对象的 mParams 字段，并且执行了 exec.execute(mFuture) 方法。而 mWorker 和 mFuture 这两个字段都是在构造函数中初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public AsyncTask(@Nullable Looper callbackLooper) &#123;</div><div class="line">    // 构建一个 Worker 对象</div><div class="line">    mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">        public Result call() throws Exception &#123;</div><div class="line">            mTaskInvoked.set(true);</div><div class="line">            Result result = null;</div><div class="line">            try &#123;</div><div class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">                // 调用 doInBackground</div><div class="line">                result = doInBackground(mParams);</div><div class="line">                Binder.flushPendingCommands();</div><div class="line">            &#125; catch (Throwable tr) &#123;</div><div class="line">                mCancelled.set(true);</div><div class="line">                throw tr;</div><div class="line">            &#125; finally &#123;</div><div class="line">                postResult(result);</div><div class="line">            &#125;</div><div class="line">            return result;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">        @Override</div><div class="line">        protected void done() &#123;</div><div class="line">            try &#123;</div><div class="line">                postResultIfNotInvoked(get());</div><div class="line">            &#125; </div><div class="line">            // 代码省略</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>mWorker 的 call 方法会调用 doInBackground，并且在 finally 方法里面将 result 通过 postResult 方法传递出去。</p><p>mFuture 包装了 mWorker 对象，在这个 mFuture 对象的 run 函数中又会调用 mWorker 对象的 call 方法，在 call 方法中调用了 doInBackground 函数。因为 mFuture 提交给了线程池来执行，所以使得 doInBackground 执行在非 UI 线程。得到 doInBackground 的结果后，通过 postResult 传递结果给 UI 线程。</p><p>postResult 方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private Result postResult(Result result) &#123;</div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</div><div class="line">            new AsyncTaskResult&lt;Result&gt;(this, result));</div><div class="line">    message.sendToTarget();</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>postResult 方法把一个消息（MESSAGE_POST_RESULT）发送给 Handler 执行。Handler 是 InternalHandler 类型。当 InternalHandler 接到 MESSAGE_POST_RESULT 类型的消息时，就会调用 result.mTask.finish() 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">private static class InternalHandler extends Handler &#123;</div><div class="line">    public InternalHandler(Looper looper) &#123;</div><div class="line">        super(looper);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</div><div class="line">    @Override</div><div class="line">    public void handleMessage(Message msg) &#123;</div><div class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class="line">        switch (msg.what) &#123;</div><div class="line">            case MESSAGE_POST_RESULT:</div><div class="line">                // There is only one result</div><div class="line">                // 调用了 AsyncTask 的 finish 方法</div><div class="line">                result.mTask.finish(result.mData[0]);</div><div class="line">                break;</div><div class="line">            case MESSAGE_POST_PROGRESS:</div><div class="line">                result.mTask.onProgressUpdate(result.mData);</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void finish(Result result) &#123;</div><div class="line">        if (isCancelled()) &#123;</div><div class="line">            onCancelled(result);</div><div class="line">        &#125; else &#123;</div><div class="line">            // 结果通过 onPostExecute 回调给用户</div><div class="line">            onPostExecute(result);</div><div class="line">        &#125;</div><div class="line">        mStatus = Status.FINISHED;  // 修改状态</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>AsyncTask 的 finish 方法又调用了 onPostExecute ，这个时候执行过程就完成了。</p><p>总之，execute 方法内部封装了 onPreExecute、doInBackground、onPostExecute 这个逻辑流程，用户可以根据自己的需求再覆写这几个方法，使得用户可以很方便地使用异步任务来完成耗时地操作以及更新UI，这其实就是通过线程池来执行耗时地任务，得到结果之后，通过 Handler 将结果传递到 UI 线程来执行。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2274b201d2a52bbf.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13 设计模式——迭代器模式</title>
      <link href="/1901/01/21/02%20DESIGN%20PATTERN/13%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/1901/01/21/02%20DESIGN%20PATTERN/13%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f1c834af424cb656.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>迭代器（Iterator）模式：<strong>提供一种方法顺序访问一个容器对象中的各个元素，而又不需暴露该对象的内部细节</strong>。</p><p>在程序设计中，经常要访问一个聚合对象中的各个元素，如数据结构中的链表遍历，通常的做法是将链表的创建和遍历都放在同一个类中，但这种方式不利于程序的扩展，如果要更换遍历方法就必须修改程序源代码，这违背了 “开闭原则”。</p><p>既然将遍历方法封装在聚合类中不可取，那么聚合类中不提供遍历方法，将遍历方法由用户自己实现是否可行呢？答案是同样不可取，因为这种方式会存在两个缺点：暴露了聚合类的内部表示，使其数据不安全；增加了客户的负担。</p><p><strong>迭代器模式</strong>能较好地克服以上缺点，它在客户访问类与聚合类之间插入一个迭代器，这分离了聚合对象与其遍历行为，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则”，如 Java 中的 Collection、List、Set、Map 等都包含了迭代器。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>访问一个聚合对象的内容而无须暴露它的内部表示。</li><li>遍历任务交由迭代器完成，这简化了聚合类。</li><li>它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。</li><li>增加新的聚合类和迭代器类都很方便，无须修改原有代码。</li><li>封装性良好，为遍历不同的聚合结构提供一个统一的接口。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>增加了类的个数，这在一定程度上增加了系统的复杂性。</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>遍历一个容器对象时。</li></ul><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><hr><p>迭代器模式是通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现的，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明地访问聚合的内部数据。现在我们来分析其基本结构与实现方法。</p><p>模式包含以下主要角色。</p><ul><li>Iterator（迭代器接口）：负责定义、访问和遍历元素的接口。</li><li>ConcreteIterator（具体迭代器类）：实现迭代器接口。</li><li>Aggregate（容器接口）：定义容器的基本功能以及提供创建迭代器的接口。</li><li>ConcreteAggregate（具体容器类）：实现容器接口中的功能。</li><li>Client（客户端类）：即要使用迭代器模式的地方。</li></ul><p>其结构图如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f3ac7a8df08cf0bf.gif?imageMogr2/auto-orient/strip" alt=""></p><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public class IteratorPattern &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Aggregate&lt;String&gt; aggregate = new ConcreteAggregate&lt;&gt;(); </div><div class="line">        aggregate.add(&quot;中山大学&quot;); </div><div class="line">        aggregate.add(&quot;华南理工&quot;); </div><div class="line">        aggregate.add(&quot;韶关学院&quot;);</div><div class="line">        System.out.print(&quot;聚合的内容有：&quot;);</div><div class="line">        Iterator&lt;String&gt; it = aggregate.getIterator(); </div><div class="line">        while (it.hasNext()) &#123;</div><div class="line">            System.out.print(it.next() + &quot;\t&quot;); </div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;\nFirst：&quot; + it.first());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 抽象聚合</div><div class="line">interface Aggregate&lt;T&gt; &#123; </div><div class="line">    void add(T obj); </div><div class="line">    void remove(T obj); </div><div class="line">    Iterator&lt;T&gt; iterator(); </div><div class="line">&#125;</div><div class="line">// 具体聚合，具体容器</div><div class="line">class ConcreteAggregate&lt;T&gt; implements Aggregate&lt;T&gt; &#123; </div><div class="line">    private List&lt;T&gt; list = new ArrayList&lt;T&gt;(); </div><div class="line">    public void add(T obj) &#123; </div><div class="line">        list.add(obj); </div><div class="line">    &#125;</div><div class="line">    public void remove(T obj) &#123; </div><div class="line">        list.remove(obj); </div><div class="line">    &#125;</div><div class="line">    public Iterator&lt;T&gt; getIterator() &#123; </div><div class="line">        return(new ConcreteIterator&lt;T&gt;(list)); </div><div class="line">    &#125;     </div><div class="line">&#125;</div><div class="line">// 抽象迭代器</div><div class="line">interface Iterator&lt;T&gt; &#123;</div><div class="line">    T first();</div><div class="line">    T next();</div><div class="line">    boolean hasNext();</div><div class="line">&#125;</div><div class="line">// 具体迭代器</div><div class="line">class ConcreteIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123; </div><div class="line">    private List&lt;T&gt; list; </div><div class="line">    private int index = -1; </div><div class="line">    public ConcreteIterator(List&lt;T&gt; list) &#123; </div><div class="line">        this.list = list; </div><div class="line">    &#125; </div><div class="line">    public boolean hasNext() &#123; </div><div class="line">        return index &lt; list.size() - 1;</div><div class="line">    &#125;</div><div class="line">    public T first() &#123;</div><div class="line">        index = 0;</div><div class="line">        return list.get(index);</div><div class="line">    &#125;</div><div class="line">    public T next() &#123; </div><div class="line">        T obj = null; </div><div class="line">        if (this.hasNext()) &#123; </div><div class="line">            obj = list.get(++index); </div><div class="line">        &#125; </div><div class="line">        return obj; </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>用迭代器模式编写一个浏览婺源旅游风景图的程序。</p><p>分析：婺源的名胜古迹较多，要设计一个查看相关景点图片和简介的程序，用“迭代器模式”设计比较合适。</p><p>首先，设计一个婺源景点（WyViewSpot）类来保存每张图片的名称与简介；再设计一个景点集（ViewSpotSet）接口，它是抽象聚合类，提供了增加和删除婺源景点的方法，以及获取迭代器的方法。</p><p>然后，定义一个婺源景点集（WyViewSpotSet）类，它是具体聚合类，用 ArrayList 来保存所有景点信息，并实现父类中的抽象方法；再定义婺源景点的抽象迭代器（ViewSpotltemtor）接口，其中包含了查看景点信息的相关方法。</p><p>最后，定义婺源景点的具体迭代器（WyViewSpotlterator）类，它实现了父类的抽象方法。</p><p>程序代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">// 婺源景点类</div><div class="line">class WyViewSpot &#123;</div><div class="line">    private String name;</div><div class="line">    private String introduce;</div><div class="line">    WyViewSpot(String name, String Introduce) &#123;</div><div class="line">        this.name = name;</div><div class="line">        this.introduce = introduce;</div><div class="line">    &#125;</div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line">    public String getIntroduce() &#123;</div><div class="line">        return introduce;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽象聚合：婺源景点集接口</div><div class="line">interface ViewSpotSet &#123;</div><div class="line">    void add(WyViewSpot obj);</div><div class="line">    void remove(WyViewSpot obj);</div><div class="line">    ViewSpotIterator iterator();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体聚合：婺源景点集</div><div class="line">class WyViewSpotSet implements ViewSpotSet &#123;</div><div class="line">    private List&lt;WyViewSpot&gt; list = new ArrayList&lt;&gt;();</div><div class="line">    public void add(WyViewSpot obj) &#123;</div><div class="line">        list.add(obj);</div><div class="line">    &#125;</div><div class="line">    public void remove(WyViewSpot obj) &#123;</div><div class="line">        list.remove(obj);</div><div class="line">    &#125;</div><div class="line">    public ViewSpotIterator iterator() &#123;</div><div class="line">        return(new WyViewSpotIterator(list));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽象迭代器：婺源景点迭代器接口</div><div class="line">interface ViewSpotIterator &#123;</div><div class="line">    boolean hasNext();</div><div class="line">    WyViewSpot next();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体迭代器：婺源景点迭代器</div><div class="line">class WyViewSpotIterator implements ViewSpotIterator &#123;</div><div class="line">    private List&lt;WyViewSpot&gt; list;</div><div class="line">    private int index = -1;</div><div class="line">    public WyViewSpotIterator(List&lt;WyViewSpot&gt; list) &#123;</div><div class="line">        this.list = list;</div><div class="line">    &#125;</div><div class="line">    public boolean hasNext() &#123;</div><div class="line">        return index &lt; list.size() - 1;</div><div class="line">    &#125;</div><div class="line">    public WyViewSpot next() &#123;</div><div class="line">        return list.get(++index);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>由于聚合与迭代器的关系非常密切，所以大多数语言在实现聚合类时都提供了迭代器类，因此大数情况下使用语言中已有的聚合类的迭代器就已经够了。</p><h3 id="ANDROID-源码中的实现"><a href="#ANDROID-源码中的实现" class="headerlink" title="ANDROID 源码中的实现"></a>ANDROID 源码中的实现</h3><hr><p>ANDROID 中典型的迭代器模式例子是数据库查询使用 Cursor，当我们使用 SQLiteDatabase 的 query 方法查询数据时，会返回一个 Cursor 游标对象，该游标对象实质就是一个具体的迭代器，我们可以使用它遍历数据库查询所得到的结果集。</p><p>首先定义一个 SQLiteOpenHelper：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class DBHelper extends SQLiteOpenHelper &#123;</div><div class="line"></div><div class="line">    public DBHelper(Context context) &#123;</div><div class="line">        super(context, &quot;DB_AIGE&quot;, null, 1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(SQLiteDatabase db) &#123;</div><div class="line">        db.execSQL(&quot;CREATE TABLE table_aige (_id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, sex TEXT)&quot;);</div><div class="line">        db.execSQL(&quot;INSERT INTO table_aige (name, sex) values (&apos;Aige&apos;, &apos;man&apos;)&quot;);</div><div class="line">        db.execSQL(&quot;INSERT INTO table_aige (name, sex) values (&apos;SMBrother&apos;, &apos;man&apos;)&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>构造 ContentProvider：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public class DataProvider extends ContentProvider &#123;</div><div class="line"></div><div class="line">    private DBHelper dbHelper;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onCreate() &#123;</div><div class="line">        dbHelper = new DBHelper(getContext());</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) &#123;</div><div class="line">        SQLiteDatabase db = dbHelper.getReadableDatabase();</div><div class="line">        return db.query(&quot;table_aige&quot;, projection, null, null, null, null, null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public String getType(@NonNull Uri uri) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 Activity 使用 ContentProvider：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class IteratorActivity extends ListActivity &#123;</div><div class="line"></div><div class="line">    private static final Uri URI = Uri.parse(&quot;content://com.android.androidsamples.dataprovider/table_aige&quot;);</div><div class="line"></div><div class="line">    private static final String[] PROJECTION = new String[]&#123;&quot;name&quot;, &quot;sex&quot;&#125;;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        Cursor cursor = getContentResolver().query(URI, PROJECTION, null, null, null);</div><div class="line"></div><div class="line">        List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;&gt;();</div><div class="line">        cursor.moveToFirst();</div><div class="line">        do &#123;</div><div class="line">            Map&lt;String, String&gt; item = new HashMap&lt;&gt;();</div><div class="line">            item.put(&quot;name&quot;, cursor.getString(0));</div><div class="line">            item.put(&quot;sex&quot;, cursor.getString(1));</div><div class="line">            list.add(item);</div><div class="line">        &#125; while (cursor.moveToNext());</div><div class="line">        cursor.close();</div><div class="line">        setListAdapter(new SimpleAdapter(this, list, android.R.layout.simple_list_item_2,</div><div class="line">                new String[]&#123;&quot;name&quot;, &quot;sex&quot;&#125;, new int[]&#123;android.R.id.text1, android.R.id.text2&#125;));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注册组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;activity android:name=&quot;.iterator.IteratorActivity&quot; /&gt;</div><div class="line">&lt;provider android:authorities=&quot;com.android.androidsamples.dataprovider&quot; </div><div class="line">        android:name=&quot;.iterator.DataProvider&quot;/&gt;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-6c604e14e02137f4.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12 设计模式——备忘录模式</title>
      <link href="/1901/01/20/02%20DESIGN%20PATTERN/12%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/1901/01/20/02%20DESIGN%20PATTERN/12%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7aceace8d79b1688.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>备忘录（Memento）模式：<strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将该对象恢复到先前保存的状态</strong>。</p><p>其实很多应用软件都使用了该模式，如 Word、记事本、Photoshop、Eclipse 等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 IE 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。</p><p>备忘录模式能记录一个对象的内部状态，当用户后悔时能撤销当前操作，使数据恢复到它原先的状态。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</li><li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li><li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>需要保存一个对象在某一时刻的状态或部分状态。</li><li>如果用一个接口来让其他对象得到这些状态，将会暴露对象的实现细节并破坏对象的封装性，一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态。</li></ul><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><hr><p>模式包含以下主要角色。</p><ul><li>Originator（发起人角色）：负责创建一个备忘录（Memoto），能够记录内部状态，以及恢复原来记录的状态。并且能够决定哪些状态是需要备忘的。</li><li>Memoto（备忘录角色）：将发起人（Originator）对象的内部状态存储起来；并且可以防止发起人（Originator）之外的对象访问备忘录（Memoto）。</li><li>Caretaker（负责人角色）：负责保存备忘录（Memoto），不能对备忘录（Memoto）的内容进行操作和访问，只能将备忘录传递给其他对象。</li></ul><p>其结构图如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-3ab336b83af0aa4f.gif?imageMogr2/auto-orient/strip" alt=""></p><p>备忘录模式的实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public class MementoPattern &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Originator originator = new Originator();</div><div class="line">        Caretaker caretaker = new Caretaker();       </div><div class="line">        originator.setState(&quot;S0&quot;); </div><div class="line">        System.out.println(&quot;初始状态:&quot; + originator.getState());           </div><div class="line">        caretaker.setMemento(originator.createMemento()); // 保存状态      </div><div class="line">        originator.setState(&quot;S1&quot;); </div><div class="line">        System.out.println(&quot;新的状态:&quot; + originator.getState());        </div><div class="line">        originator.restoreMemento(caretaker.getMemento()); // 恢复状态</div><div class="line">        System.out.println(&quot;恢复状态:&quot; + originator.getState());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 备忘录</div><div class="line">class Memento &#123; </div><div class="line">    private String state; </div><div class="line">    public Memento(String state) &#123; </div><div class="line">        this.state=state; </div><div class="line">    &#125;     </div><div class="line">    public void setState(String state) &#123; </div><div class="line">        this.state=state; </div><div class="line">    &#125;</div><div class="line">    public String getState() &#123; </div><div class="line">        return state; </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 发起人</div><div class="line">class Originator &#123; </div><div class="line">    private String state;     </div><div class="line">    public void setState(String state) &#123; </div><div class="line">        this.state=state; </div><div class="line">    &#125;</div><div class="line">    public String getState() &#123; </div><div class="line">        return state; </div><div class="line">    &#125;</div><div class="line">    public Memento createMemento() &#123; </div><div class="line">        return new Memento(state); </div><div class="line">    &#125; </div><div class="line">    public void restoreMemento(Memento m) &#123; </div><div class="line">        this.setState(m.getState()); </div><div class="line">    &#125; </div><div class="line">&#125;</div><div class="line">// 管理者</div><div class="line">class Caretaker &#123; </div><div class="line">    private Memento memento;       </div><div class="line">    public void setMemento(Memento m) &#123; </div><div class="line">        memento=m; </div><div class="line">    &#125;</div><div class="line">    public Memento getMemento() &#123; </div><div class="line">        return memento; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>以游戏存档为例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Originator</div><div class="line"> * 这里则是游戏类，游戏类提供存档和读档的功能</div><div class="line"> */</div><div class="line">public class Game &#123;</div><div class="line">    private int mLevel = 1; // 等级</div><div class="line">    private int mCoin = 0;  // 金币数量</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;game&#123;&quot; +</div><div class="line">                &quot;mLevel=&quot; + mLevel +</div><div class="line">                &quot;, mCoin=&quot; + mCoin +</div><div class="line">                &apos;&#125;&apos;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void play() &#123;</div><div class="line">        System.out.println(&quot;升级了&quot;);</div><div class="line">        mLevel++;</div><div class="line">        System.out.println(&quot;当前等级为:&quot; + mLevel);</div><div class="line">        System.out.println(&quot;获得金币:32&quot;);</div><div class="line">        mCoin += 32;</div><div class="line">        System.out.println(&quot;当前金币数量为:&quot; + mCoin);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void exit() &#123;</div><div class="line">        System.out.println(&quot;退出游戏&quot;);</div><div class="line">        System.out.println(&quot;退出游戏时的属性 : &quot; + toString());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 创建备忘录,即游戏存档</div><div class="line">    public Memento createMemento() &#123;</div><div class="line">        Memento memento = new Memento();</div><div class="line">        memento.level = mLevel;</div><div class="line">        memento.coin = mCoin;</div><div class="line">        return memento;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setMemento(Memento memento) &#123;</div><div class="line">        mLevel = memento.level;</div><div class="line">        mCoin = memento.coin;</div><div class="line">        System.out.println(&quot;读取存档信息:&quot; + toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Memento</div><div class="line"> * 负责将游戏类的内部状态存储起来</div><div class="line"> */</div><div class="line">public class Memento &#123;</div><div class="line">    public int level;   // 等级</div><div class="line">    public int coin;    // 金币数量</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Caretaker</div><div class="line"> * 备忘录管理类</div><div class="line"> */</div><div class="line">public class Caretaker &#123;</div><div class="line">    private Memento mMemento;</div><div class="line"></div><div class="line">    public void setMemento(Memento memento) &#123;</div><div class="line">        mMemento = memento;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Memento getMemento() &#123;</div><div class="line">        return mMemento;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>客户端测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void test() &#123;</div><div class="line">    System.out.println(&quot;首次进入游戏&quot;);</div><div class="line">    Game game = new Game();</div><div class="line">    game.play();</div><div class="line">    Memento memento = game.createMemento(); // 创建存档</div><div class="line">    Caretaker caretaker = new Caretaker();</div><div class="line">    caretaker.setMemento(memento);          // 保存存档</div><div class="line">    game.exit();</div><div class="line"></div><div class="line">    System.out.println(&quot;-------------&quot;);</div><div class="line">    System.out.println(&quot;二次进入游戏&quot;);</div><div class="line">    Game secondGame = new Game();</div><div class="line">    secondGame.setMemento(caretaker.getMemento()); // 读取存档</div><div class="line">    secondGame.play(); </div><div class="line">    secondGame.exit();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">首次进入游戏</div><div class="line">升级了</div><div class="line">当前等级为:2</div><div class="line">获得金币:32</div><div class="line">当前金币数量为:32</div><div class="line">退出游戏</div><div class="line">退出游戏时的属性 : game&#123;mLevel=2, mCoin=32&#125;</div><div class="line">-------------</div><div class="line">二次进入游戏</div><div class="line">读取存档信息:game&#123;mLevel=2, mCoin=32&#125;</div><div class="line">升级了</div><div class="line">当前等级为:3</div><div class="line">获得金币:32</div><div class="line">当前金币数量为:64</div><div class="line">退出游戏</div><div class="line">退出游戏时的属性 : game&#123;mLevel=3, mCoin=64&#125;</div></pre></td></tr></table></figure></p><h3 id="ANDROID-源码中的实现"><a href="#ANDROID-源码中的实现" class="headerlink" title="ANDROID 源码中的实现"></a>ANDROID 源码中的实现</h3><hr><p>状态保存是 ANDROID 中备忘录模式的典型使用，主要对应 Activity的两个回调方法 onSaveInstanceState() 和 onRestoreInstanceState()。</p><p>onSaveInstanceState 方法的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">protected void onSaveInstanceState(Bundle outState) &#123;</div><div class="line">    // 存储当前窗口的视图树的状态</div><div class="line">    outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());</div><div class="line"></div><div class="line">    outState.putInt(LAST_AUTOFILL_ID, mLastAutofillId);</div><div class="line">    // 存储 fragment 的状态</div><div class="line">    Parcelable p = mFragments.saveAllState();</div><div class="line">    if (p != null) &#123;</div><div class="line">        outState.putParcelable(FRAGMENTS_TAG, p);</div><div class="line">    &#125;</div><div class="line">    // 存储自动填充的字段</div><div class="line">    if (mAutoFillResetNeeded) &#123;</div><div class="line">        outState.putBoolean(AUTOFILL_RESET_NEEDED, true);</div><div class="line">        getAutofillManager().onSaveInstanceState(outState);</div><div class="line">    &#125;</div><div class="line">    // 如果用户还设置了 Activity 的 ActivityLifecycleCallbacks，</div><div class="line">    // 那么调用这些 ActivityLifecycleCallbacks 的 onSaveInstanceState 进行存储状态</div><div class="line">    getApplication().dispatchActivitySaveInstanceState(this, outState);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上述 onSaveInstanceState 函数中，主要分为如下 3 步：<br>1）存储窗口的视图树的状态；<br>2）存储 Fragment 的状态<br>3）调用 ActivityLifecycleCallbacks 的 onSaveInstanceState 函数进行状态存储。</p><p>我们先看第一步，在这一步将 Window 对象中的视图树中欧冠各个 View 状态存储到 Bundle 中。这样一来，当用户重新进入到该 Activity 时，用户 UI 的结构、状态才会被重新恢复，以此来保证用户界面的一致性。Window 类的具体实现类是 PhoneWindow，其中 saveHierarchyState 方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public Bundle saveHierarchyState() &#123;</div><div class="line">    Bundle outState = new Bundle();</div><div class="line">    if (mContentParent == null) &#123;</div><div class="line">        return outState;</div><div class="line">    &#125;</div><div class="line">    // 通过 SparseArray 类来存储，这相当于一个 key 为整型的 map</div><div class="line">    SparseArray&lt;Parcelable&gt; states = new SparseArray&lt;Parcelable&gt;();</div><div class="line">    // 调用 mContentParent 的 saveHierarchyState 方法，这个 mContentParent 就是调用 Activity 的 </div><div class="line">    // setContentView 函数设置的内容视图，它是内容视图的根节点，在这里存储整棵视图树的结构。</div><div class="line">    mContentParent.saveHierarchyState(states);</div><div class="line">    // 将视图树结构放到 outState 中</div><div class="line">    outState.putSparseParcelableArray(VIEWS_TAG, states);</div><div class="line"></div><div class="line">    // 保存当前界面中获取了焦点的 View</div><div class="line">    // Save the focused view ID.</div><div class="line">    final View focusedView = mContentParent.findFocus();</div><div class="line">    if (focusedView != null &amp;&amp; focusedView.getId() != View.NO_ID) &#123;</div><div class="line">        // 持有焦点的 View 必须要设置 id，否则重新进入该界面时不会恢复它的焦点状态</div><div class="line">        outState.putInt(FOCUSED_ID_TAG, focusedView.getId());</div><div class="line">    &#125;</div><div class="line">    // 存储整个面板的状态</div><div class="line">    // save the panels</div><div class="line">    SparseArray&lt;Parcelable&gt; panelStates = new SparseArray&lt;Parcelable&gt;();</div><div class="line">    savePanelState(panelStates);</div><div class="line">    if (panelStates.size() &gt; 0) &#123;</div><div class="line">        outState.putSparseParcelableArray(PANELS_TAG, panelStates);</div><div class="line">    &#125;</div><div class="line">    // 存储 ActionBar 的状态</div><div class="line">    if (mDecorContentParent != null) &#123;</div><div class="line">        SparseArray&lt;Parcelable&gt; actionBarStates = new SparseArray&lt;Parcelable&gt;();</div><div class="line">        mDecorContentParent.saveToolbarHierarchyState(actionBarStates);</div><div class="line">        outState.putSparseParcelableArray(ACTION_BAR_TAG, actionBarStates);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return outState;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 saveHierarchyState 中，主要时存储了与当前 UI、ActionBar 相关的 View 状态，这里用 mContentParent 来分析。这个 mContentParent 就是我们通过 Activity 的 setContentView 函数设置的内容视图，它是整个内容视图的根节点，存储它层级结构中的 View 状态也就存储了用户界面的状态。mContentParent 是一个 ViewGroup 对象，但是，saveHierarchyState 并不是在 ViewGroup 中，而是在 ViewGroup 的父类 View。</p><p>View 的 saveHierarchyState 方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public void saveHierarchyState(SparseArray&lt;Parcelable&gt; container) &#123;</div><div class="line">    dispatchSaveInstanceState(container);</div><div class="line">&#125;</div><div class="line"></div><div class="line">protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) &#123;</div><div class="line">    // 注意：如果 View 没有设置 id，那么这个 View 的状态将不会被存储。</div><div class="line">    if (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == 0) &#123;</div><div class="line">        mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;</div><div class="line">        // 调用 onSaveInstanceState 获取自身的状态</div><div class="line">        Parcelable state = onSaveInstanceState();</div><div class="line">        if ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == 0) &#123;</div><div class="line">            throw new IllegalStateException(</div><div class="line">                    &quot;Derived class did not call super.onSaveInstanceState()&quot;);</div><div class="line">        &#125;</div><div class="line">        if (state != null) &#123;</div><div class="line">            // 将自身状态放到 container 中，key 为 id、value 为自身状态。</div><div class="line">            container.put(mID, state);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// View 类默认存储的状态为空</div><div class="line">protected Parcelable onSaveInstanceState() &#123;</div><div class="line">    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;</div><div class="line">    ...</div><div class="line">    return BaseSavedState.EMPTY_STATE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 View 类中的 saveHierarchyState 函数调用了 dispatchSaveInstanceState 函数来存储自身的状态，而 ViewGroup 则覆写了 dispatchSaveInstanceState 函数来存储自身以及子视图的状态，函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) &#123;</div><div class="line">    super.dispatchSaveInstanceState(container);</div><div class="line">    final int count = mChildrenCount;</div><div class="line">    final View[] children = mChildren;</div><div class="line">    for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">        View c = children[i];</div><div class="line">        if ((c.mViewFlags &amp; PARENT_SAVE_DISABLED_MASK) != PARENT_SAVE_DISABLED) &#123;</div><div class="line">            c.dispatchSaveInstanceState(container);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>dispatchSaveInstanceState 会首先调用 super 的方法存储自身的状态，然后调用每个子视图的 dispatchSaveInstanceState。</p><blockquote><p>注意：如果 View 没有设置 id，那么这个 View 的状态将不会被存储。设置了这个 id 也要保证在一个 Activity 的布局中必须是唯一的，否则会出现状态覆盖的情况。</p></blockquote><p>这些被存储的状态通过 onSaveInstanceState 函数得到，但在 View 类中我们看到返回的是一个空状态。这就意味着，当我们需要存储 View 状态是，需要覆写 onSaveInstanceState 方法，将要存储的数据放到 Parcelable 对象中，并且将它返回。我们看看 TextView 的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public Parcelable onSaveInstanceState() &#123;</div><div class="line">    Parcelable superState = super.onSaveInstanceState();</div><div class="line">    </div><div class="line">    // 代码省略</div><div class="line">    </div><div class="line">    // 存储 TextView 的 start、end 以及文本内容</div><div class="line">    if (freezesText || hasSelection) &#123;</div><div class="line">        SavedState ss = new SavedState(superState);</div><div class="line"></div><div class="line">        if (freezesText) &#123;</div><div class="line">            if (mText instanceof Spanned) &#123;</div><div class="line">                final Spannable sp = new SpannableStringBuilder(mText);</div><div class="line"></div><div class="line">                if (mEditor != null) &#123;</div><div class="line">                    removeMisspelledSpans(sp);</div><div class="line">                    sp.removeSpan(mEditor.mSuggestionRangeSpan);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ss.text = sp;</div><div class="line">            &#125; else &#123;</div><div class="line">                ss.text = mText.toString();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (hasSelection) &#123;</div><div class="line">            // XXX Should also save the current scroll position!</div><div class="line">            ss.selStart = start;</div><div class="line">            ss.selEnd = end;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 代码省略</div><div class="line"></div><div class="line">        return superState;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>存储完 Window 的视图树状态后，会存储每个 Fragment 的状态，调用它们的 onSaveInstanceState 方法。最后调用 ActivityLifecycleCallbacks 的 onSaveInstanceState。</p><p>P 版本（Android 9）之前，onSaveInstanceState 会在 onStop 之前调用。P 版本（Android 9）之后，onSaveInstanceState 会在 onStop 之后调用。ActivityThread 的 performStopActivity 会调用 callActivityOnStop。callActivityOnStop 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">private void callActivityOnStop(ActivityClientRecord r, boolean saveState, String reason) &#123;</div><div class="line">    // Before P onSaveInstanceState was called before onStop, starting with P it&apos;s</div><div class="line">    // called after. Before Honeycomb state was always saved before onPause.</div><div class="line">    final boolean shouldSaveState = saveState &amp;&amp; !r.activity.mFinished &amp;&amp; r.state == null</div><div class="line">            &amp;&amp; !r.isPreHoneycomb();</div><div class="line">    final boolean isPreP = r.isPreP();</div><div class="line">    if (shouldSaveState &amp;&amp; isPreP) &#123;</div><div class="line">        callActivityOnSaveInstanceState(r);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        r.activity.performStop(false /*preserveWindow*/, reason);</div><div class="line">    &#125; catch (SuperNotCalledException e) &#123;</div><div class="line">        throw e;</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        if (!mInstrumentation.onException(r.activity, e)) &#123;</div><div class="line">            throw new RuntimeException(</div><div class="line">                    &quot;Unable to stop activity &quot;</div><div class="line">                            + r.intent.getComponent().toShortString()</div><div class="line">                            + &quot;: &quot; + e.toString(), e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    r.setState(ON_STOP);</div><div class="line"></div><div class="line">    if (shouldSaveState &amp;&amp; !isPreP) &#123;</div><div class="line">        callActivityOnSaveInstanceState(r);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>callActivityOnSaveInstanceState 方法会将状态信息存储到 ActivityClientRecord 对象的 state 字段中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private void callActivityOnSaveInstanceState(ActivityClientRecord r) &#123;</div><div class="line">    r.state = new Bundle();</div><div class="line">    r.state.setAllowFds(false);</div><div class="line">    if (r.isPersistable()) &#123;</div><div class="line">        r.persistentState = new PersistableBundle();</div><div class="line">        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state,</div><div class="line">                r.persistentState);</div><div class="line">    &#125; else &#123;</div><div class="line">        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 ActivityThread 类的 performLaunchActivity 方法会回调 onCreate，将 ActivityClientRecord 对象的 state 字段传递给 onCreate。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</div><div class="line">    ...</div><div class="line">    if (r.isPersistable()) &#123;</div><div class="line">        mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</div><div class="line">    &#125; else &#123;</div><div class="line">        mInstrumentation.callActivityOnCreate(activity, r.state);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    return activity;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 ActivityThread 类的 handleStartActivity 方法中会调用 callActivityOnRestoreInstanceState 恢复 InstanceState。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void handleStartActivity(ActivityClientRecord r,</div><div class="line">                                PendingTransactionActions pendingActions) &#123;</div><div class="line">    ...</div><div class="line">    // Restore instance state</div><div class="line">    if (pendingActions.shouldRestoreInstanceState()) &#123;</div><div class="line">        if (r.isPersistable()) &#123;</div><div class="line">            if (r.state != null || r.persistentState != null) &#123;</div><div class="line">                mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</div><div class="line">                        r.persistentState);</div><div class="line">            &#125;</div><div class="line">        &#125; else if (r.state != null) &#123;</div><div class="line">            mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>总结：</p><ul><li>Bundle 对应备忘录：Android 的状态，包括视图树状态和 Fragment 状态以及生命周期状态都是通过 Bundle 这个数据结构存储键值对的 Parcel 对象保存的，特别注意一点，对于同一个 Activity的视图放到一个 Bundle 中用 SparceArray（类似 HashMap 不过空间使用效率更高，内部查找二分法，而且键只能是整数）来存储。键：ViewId。值：对应的 Parcel 对象，所以 ViewId 不能重复，不然会覆盖。</li><li>Activity 对应备忘录管理类。严格来说应该是 Activity 中的内部属性。mActivities 实际是一个 ActivityClientRecord 集合，每个 Activity 的信息对应一个 ActivityClientRecord，相应的键是 Token。ActivityClientRecord 的 Bundle 类型的 State 对应 Bundle（备忘录）。</li><li>View 和 Fragment 等都对应 Originator 类，他们都需要伴随 Activity 的生命周期函数 onSaveInstanceState() 和 OnRestoreInstanceState() 通过 Bundle 这种数据结构完成自己状态的管理。</li></ul><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><hr><p>简化版记事本：保存、撤销、重做。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">public class NoteEditText extends AppCompatEditText &#123;</div><div class="line">    public NoteEditText(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public NoteEditText(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public NoteEditText(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 创建备忘录对象，即存储编辑器的指定数据</div><div class="line">    public Memo createMemo() &#123;</div><div class="line">        Memo memo = new Memo();</div><div class="line">        memo.text = getText().toString();</div><div class="line">        memo.cursor = getSelectionStart();</div><div class="line">        return memo;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 从备忘录中恢复数据，设置光标位置</div><div class="line">    public void restore(Memo memo) &#123;</div><div class="line">        setText(memo.text);</div><div class="line">        setSelection(memo.cursor);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Memo &#123;</div><div class="line">    public String text;</div><div class="line">    public int cursor;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 负责管理 Memo 对象</div><div class="line">public class NoteCaretaker &#123;</div><div class="line">    // 最大存储数量</div><div class="line">    private static final int MAX = 30;</div><div class="line">    // 存储 30 条记录</div><div class="line">    private List&lt;Memo&gt; mMemos = new ArrayList&lt;&gt;(MAX);</div><div class="line">    private int mIndex = 0;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 保存备忘录到记录列表中</div><div class="line">     * @param memo Memo</div><div class="line">     */</div><div class="line">    public void saveMemo(Memo memo) &#123;</div><div class="line">        if (mMemos.size() &gt; MAX) &#123;</div><div class="line">            mMemos.remove(0);</div><div class="line">        &#125;</div><div class="line">        mMemos.add(memo);</div><div class="line">        mIndex = mMemos.size() - 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 获取上一个存档信息，相当于撤销功能</div><div class="line">    public Memo getPrevMemo() &#123;</div><div class="line">        mIndex = mIndex &gt; 0 ? --mIndex : mIndex;</div><div class="line">        return mMemos.get(mIndex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 获取下一个存档信息，相当于重做功能</div><div class="line">    public Memo getNextMemo() &#123;</div><div class="line">        mIndex = mIndex &lt; mMemos.size() - 1 ? ++mIndex : mIndex;</div><div class="line">        return mMemos.get(mIndex);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 TestActivity 的代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public class TestActivity extends BaseActivity &#123;</div><div class="line"></div><div class="line">    private NoteEditText mNoteEditText;</div><div class="line">    private TextView mSaveBtn;</div><div class="line">    private ImageView mUndoBtn;</div><div class="line">    private ImageView mRedoBtn;</div><div class="line">    private NoteCaretaker mCaretaker = new NoteCaretaker();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_test);</div><div class="line"></div><div class="line">        initViews();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initViews() &#123;</div><div class="line">        mNoteEditText = findViewById(R.id.et_note);</div><div class="line">        mSaveBtn = findViewById(R.id.btn_save);</div><div class="line">        mUndoBtn = findViewById(R.id.btn_undo);</div><div class="line">        mRedoBtn = findViewById(R.id.btn_redo);</div><div class="line"></div><div class="line">        mSaveBtn.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                mCaretaker.saveMemo(mNoteEditText.createMemo());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        mUndoBtn.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                mNoteEditText.restore(mCaretaker.getPrevMemo());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        mRedoBtn.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                mNoteEditText.restore(mCaretaker.getNextMemo());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>附 res/layout/test.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.xxt.xtest.demo.NoteEditText</div><div class="line">        android:id=&quot;@+id/et_note&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;0dp&quot;</div><div class="line">        android:layout_weight=&quot;1&quot;</div><div class="line">        android:gravity=&quot;left&quot;</div><div class="line">        android:hint=&quot;写点嘛~&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;RelativeLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:paddingLeft=&quot;50dp&quot;</div><div class="line">        android:paddingRight=&quot;50dp&quot;</div><div class="line">        android:paddingBottom=&quot;10dp&quot;&gt;</div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/btn_undo&quot;</div><div class="line">            android:layout_width=&quot;30dp&quot;</div><div class="line">            android:layout_height=&quot;30dp&quot;</div><div class="line">            android:layout_alignParentLeft=&quot;true&quot;</div><div class="line">            android:layout_alignParentStart=&quot;true&quot;</div><div class="line">            android:src=&quot;@drawable/undo&quot;/&gt;</div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/btn_save&quot;</div><div class="line">            android:layout_width=&quot;wrap_content&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:layout_centerInParent=&quot;true&quot;</div><div class="line">            android:text=&quot;保存&quot;</div><div class="line">            android:textSize=&quot;20sp&quot;</div><div class="line">            android:textColor=&quot;#000&quot;/&gt;</div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/btn_redo&quot;</div><div class="line">            android:layout_width=&quot;30dp&quot;</div><div class="line">            android:layout_height=&quot;30dp&quot;</div><div class="line">            android:layout_alignParentRight=&quot;true&quot;</div><div class="line">            android:layout_alignParentEnd=&quot;true&quot;</div><div class="line">            android:src=&quot;@drawable/redo&quot;/&gt;</div><div class="line">    &lt;/RelativeLayout&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a2925a1807fb7c36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f4724d63e7190ec7.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11 设计模式——观察者模式</title>
      <link href="/1901/01/19/02%20DESIGN%20PATTERN/11%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/1901/01/19/02%20DESIGN%20PATTERN/11%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-74160c8607ec238d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>观察者（Observer）模式：<strong>定义对象间的一种一个对多的依赖关系，当一个对象的状态发送改变时，所以依赖于它的对象都得到通知并被自动更新</strong>。这种模式有时又称作发布—订阅模式、模型—视图模式，它是对象行为型模式。</p><p>观察者模式是一个使用率非常高的模式，它最常用的地方是 GUI 系统、订阅——发布系统。因为这个模式的一个重要作用就是解耦，将被观察者和观察者解耦，使得它们之间的依赖性更小，甚至做到毫无依赖。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li><li>目标与观察者之间建立了一套触发机制。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li><li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>关联行为场景。需要注意的是，关联行为是可拆分的，而不是“组合”关系。</li><li>事件多级触发场景。</li><li>跨系统的信息交换场景，如消息队列、事件总线的处理机制。</li></ul><h4 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h4><ul><li>常见的发布—订阅模式。</li><li>ListView 的 Adapter 的 notifyDataSetChanged 更新方法。</li><li>BroadcastReceiver。</li><li>开源库 EventBus。</li><li>RxJava。</li></ul><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><hr><p>观察者模式包含以下主要角色。</p><ul><li>抽象主题（Subject）：也就是被观察（Observable）的角色。它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</li><li>具体主题（ConcreteSubject）：也就是具体被观察者（ConcreteObservable）。它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li><li>抽象观察者（Observer）：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</li><li>具体观察者（ConcreteObserver）：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</li></ul><p>其结构图如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ef244b435a52a1b5.gif?imageMogr2/auto-orient/strip" alt=""></p><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">public class ObserverPattern &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Subject subject = new ConcreteSubject();</div><div class="line">        Observer observer1 = new ConcreteObserver1();</div><div class="line">        Observer observer2 = new ConcreteObserver2();</div><div class="line">        subject.add(observer1);</div><div class="line">        subject.add(observer2);</div><div class="line">        subject.notifyObserver();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//  抽象目标，被观察者</div><div class="line">abstract class Subject &#123;</div><div class="line">    // 观察者集合</div><div class="line">    protected List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;();   </div><div class="line">    // 增加观察者方法</div><div class="line">    public void add(Observer observer) &#123;</div><div class="line">        observers.add(observer);</div><div class="line">    &#125;    </div><div class="line">    // 删除观察者方法</div><div class="line">    public void remove(Observer observer) &#123;</div><div class="line">        observers.remove(observer);</div><div class="line">    &#125;   </div><div class="line">    public abstract void notifyObserver(); // 通知观察者方法</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体目标，具体被观察者</div><div class="line">class ConcreteSubject extends Subject &#123;</div><div class="line">    public void notifyObserver() &#123;</div><div class="line">        System.out.println(&quot;具体目标发生改变...&quot;);</div><div class="line">        System.out.println(&quot;--------------&quot;);       </div><div class="line">       </div><div class="line">        for(Object obs:observers) &#123;</div><div class="line">            // 通知所有观察者</div><div class="line">            ((Observer)obs).response();</div><div class="line">        &#125;</div><div class="line">    &#125;          </div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽象观察者</div><div class="line">interface Observer &#123;</div><div class="line">    void response(); // 反应</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体观察者 1</div><div class="line">class ConcreteObserver1 implements Observer &#123;</div><div class="line">    public void response() &#123;</div><div class="line">        System.out.println(&quot;具体观察者1作出反应！&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体观察者1</div><div class="line">class ConcreteObserver2 implements Observer &#123;</div><div class="line">    public void response() &#123;</div><div class="line">        System.out.println(&quot;具体观察者2作出反应！&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们也可以利用 JDK 中 Observable 类和 Observer 接口实现。观察者实现 Observer 接口，被观察者继承 Observable 类。被观察者通过 Observable 类的 addObserver 方法添加观察者。其代码形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">// 具体观察者</div><div class="line">public class MyObserver implements Observer &#123;</div><div class="line">    private String mName;</div><div class="line"></div><div class="line">    public MyObserver(String name) &#123;</div><div class="line">        mName = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void update(Observable o, Object arg) &#123;</div><div class="line">        System.out.println(mName + &quot;--&gt;&quot; + &quot;update: &quot; + arg);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体被观察者</div><div class="line">public class MyObservable extends Observable &#123;</div><div class="line">    public void sendChangeMsg(String content) &#123;</div><div class="line">        // 方法继承自 Observable，标示状态或是内容发生改变</div><div class="line">        setChanged();</div><div class="line"></div><div class="line">        // 方法继承自 Observable，通知所有观察者，最后会调用每个 Observer 的 update 方法</div><div class="line">        notifyObservers(content);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试</div><div class="line">public class ObserverPatternTest &#123;</div><div class="line">    @Test</div><div class="line">    public void test1() throws Exception &#123;</div><div class="line">        MyObservable myObservable = new MyObservable();</div><div class="line"></div><div class="line">        MyObserver myObserver1 = new MyObserver(&quot;observer-1&quot;);</div><div class="line">        MyObserver myObserver2 = new MyObserver(&quot;observer-2&quot;);</div><div class="line">        myObservable.addObserver(myObserver1);</div><div class="line">        myObservable.addObserver(myObserver2);</div><div class="line"></div><div class="line">        // 发布消息</div><div class="line">        myObservable.sendChangeMsg(&quot;发布更新啦&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>被观察者通过 setChanged() 方法标示改变，通过 notifyObservers 方法通知所有观察者。notifyObservers 方法会遍历所有的观察者 Observer，并调用它们的 update 方法。notifyObservers 方法中的参数就是最后传到观察者 update 方法的参数 Object arg。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>利用观察者模式设计一个程序，分析“人民币汇率”的升值或贬值对进口公司的进口产品成本或出口公司的出口产品收入以及公司的利润率的影响。</p><p>分析：当“人民币汇率”升值时，进口公司的进口产品成本降低且利润率提升，出口公司的出口产品收入降低且利润率降低；当“人民币汇率”贬值时，进口公司的进口产品成本提升且利润率降低，出口公司的出口产品收入提升且利润率提升。</p><p>这里的汇率（Rate）类是抽象目标类，它包含了保存观察者（Company）的 List 和增加/删除观察者的方法，以及有关汇率改变的抽象方法 change(int number)；而人民币汇率（RMBRate）类是具体目标， 它实现了父类的 change(int number) 方法，即当人民币汇率发生改变时通过相关公司；公司（Company）类是抽象观察者，它定义了一个有关汇率反应的抽象方法 response(int number)；进口公司（ImportCompany）类和出口公司（ExportCompany）类是具体观察者类，它们实现了父类的 response(int number) 方法，即当它们接收到汇率发生改变的通知时作为相应的反应。下图所示是其结构图。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-04bef627a9b8c679.gif?imageMogr2/auto-orient/strip" alt=""></p><p>程序代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public class RMBRateTest &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Rate rate = new RMBRate();</div><div class="line">        Company watcher1 = new ImportCompany();</div><div class="line">        Company watcher2 = new ExportCompany();          </div><div class="line">        rate.add(watcher1); </div><div class="line">        rate.add(watcher2);      </div><div class="line">        rate.change(10);</div><div class="line">        rate.change(-9);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽象目标：汇率</div><div class="line">abstract class Rate &#123;</div><div class="line">    protected List&lt;Company&gt; companies = new ArrayList&lt;Company&gt;();   </div><div class="line">    // 增加观察者方法</div><div class="line">    public void add(Company company) &#123;</div><div class="line">        companies.add(company);</div><div class="line">    &#125;</div><div class="line">    // 删除观察者方法</div><div class="line">    public void remove(Company company) &#123;</div><div class="line">        companies.remove(company);</div><div class="line">    &#125;</div><div class="line">    public abstract void change(int number);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体目标：人民币汇率</div><div class="line">class RMBRate extends Rate &#123;</div><div class="line">    public void change(int number) &#123;       </div><div class="line">        for(Company observer : companies) &#123;</div><div class="line">            ((Company) observer).response(number);</div><div class="line">        &#125;       </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽象观察者：公司</div><div class="line">interface Company &#123;</div><div class="line">    void response(int number);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体观察者1：进口公司 </div><div class="line">class ImportCompany implements Company &#123;</div><div class="line">    public void response(int number) &#123;</div><div class="line">        if (number&gt;0) &#123;</div><div class="line">            System.out.println(&quot;人民币汇率升值&quot;+number+&quot;个基点，降低了进口产品成本，提升了进口公司利润率。&quot;); </div><div class="line">        &#125; else if (number&lt;0) &#123;</div><div class="line">            System.out.println(&quot;人民币汇率贬值&quot;+(-number)+&quot;个基点，提升了进口产品成本，降低了进口公司利润率。&quot;); </div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125; </div><div class="line"></div><div class="line">// 具体观察者2：出口公司</div><div class="line">class ExportCompany implements Company &#123;</div><div class="line">    public void response(int number) &#123;</div><div class="line">        if (number&gt;0) &#123;</div><div class="line">            System.out.println(&quot;人民币汇率升值&quot;+number+&quot;个基点，降低了出口产品收入，降低了出口公司的销售利润率。&quot;); </div><div class="line">        &#125; else if(number&lt;0) &#123;</div><div class="line">            System.out.println(&quot;人民币汇率贬值&quot;+(-number)+&quot;个基点，提升了出口产品收入，提升了出口公司的销售利润率。&quot;); </div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">人民币汇率升值10个基点，降低了进口产品成本，提升了进口公司利润率。</div><div class="line">人民币汇率升值10个基点，降低了出口产品收入，降低了出口公司的销售利润率。</div><div class="line">人民币汇率贬值9个基点，提升了进口产品成本，降低了进口公司利润率。</div><div class="line">人民币汇率贬值9个基点，提升了出口产品收入，提升了出口公司的销售利润率。</div></pre></td></tr></table></figure></p><h3 id="ANDROID-源码中的实现"><a href="#ANDROID-源码中的实现" class="headerlink" title="ANDROID 源码中的实现"></a>ANDROID 源码中的实现</h3><hr><p>ListView 是 ANDROID 中最重要的控件之一，而 ListView 最重要的一个功能就是 Adapter。当我们往 ListView 添加数据后，都会调用 Adapter 的 notifyDataSetChanged() 方法，通知界面刷新。这是一个典型的观察者模式案例。我们追踪 notifyDataSetChanged() 这个方法，它定义在 BaseAdapter 中，具体代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public abstract class BaseAdapter implements ListAdapter, SpinnerAdapter &#123;</div><div class="line">    // 数据集（被观察者）</div><div class="line">    private final DataSetObservable mDataSetObservable = new DataSetObservable();</div><div class="line">    </div><div class="line">    // 代码省略</div><div class="line"></div><div class="line">    public void registerDataSetObserver(DataSetObserver observer) &#123;</div><div class="line">        mDataSetObservable.registerObserver(observer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void unregisterDataSetObserver(DataSetObserver observer) &#123;</div><div class="line">        mDataSetObservable.unregisterObserver(observer);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 当数据集变化时，通知所有观察者</div><div class="line">     */</div><div class="line">    public void notifyDataSetChanged() &#123;</div><div class="line">        mDataSetObservable.notifyChanged();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>追踪 mDataSetObservable.notifyChanged() 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 数据集被观察者</div><div class="line"> */</div><div class="line">public class DataSetObservable extends Observable&lt;DataSetObserver&gt; &#123;</div><div class="line">    // 调用每个观察者的 onChange 函数来通知它们被观察者发生了变化</div><div class="line">    public void notifyChanged() &#123;</div><div class="line">        synchronized (mObservers) &#123;</div><div class="line">            for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123;</div><div class="line">                mObservers.get(i).onChanged();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 代码省略</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>而这些观察者是 ListView 通过 setAdapter 方法产生的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void setAdapter(ListAdapter adapter) &#123;</div><div class="line">    // 如果已经有了一个 Adapter，那么先注销该 Adapter 对应的观察者</div><div class="line">    if (mAdapter != null &amp;&amp; mDataSetObserver != null) &#123;</div><div class="line">        mAdapter.unregisterDataSetObserver(mDataSetObserver);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 代码省略</div><div class="line"></div><div class="line">    super.setAdapter(adapter);</div><div class="line"></div><div class="line">    if (mAdapter != null) &#123;</div><div class="line">        mAreAllItemsSelectable = mAdapter.areAllItemsEnabled();</div><div class="line">        mOldItemCount = mItemCount;</div><div class="line">        // 获取数据的数量</div><div class="line">        mItemCount = mAdapter.getCount();</div><div class="line">        checkFocus();</div><div class="line">        // 注意这里：创建一个数据集观察者</div><div class="line">        mDataSetObserver = new AdapterDataSetObserver();</div><div class="line">        // 将这个观察者注册到 Adapter 中，实际上是注册到 DataSetObservable 中</div><div class="line">        mAdapter.registerDataSetObserver(mDataSetObserver);</div><div class="line"></div><div class="line">        // 代码省略</div><div class="line">    &#125; else &#123;</div><div class="line">        // 代码省略</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    requestLayout();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>观察者 AdapterDataSetObserver 定义在 ListView 的父类 AbsListView 中，具体代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public abstract class AbsListView extends AdapterView&lt;ListAdapter&gt; implements TextWatcher,</div><div class="line">        ViewTreeObserver.OnGlobalLayoutListener, Filter.FilterListener,</div><div class="line">        ViewTreeObserver.OnTouchModeChangeListener,</div><div class="line">        RemoteViewsAdapter.RemoteAdapterConnectionCallback &#123;</div><div class="line"></div><div class="line">    // 代码省略</div><div class="line"></div><div class="line">    class AdapterDataSetObserver extends AdapterView&lt;ListAdapter&gt;.AdapterDataSetObserver &#123;</div><div class="line">        @Override</div><div class="line">        public void onChanged() &#123;</div><div class="line">            super.onChanged();</div><div class="line">            if (mFastScroll != null) &#123;</div><div class="line">                mFastScroll.onSectionsChanged();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onInvalidated() &#123;</div><div class="line">            super.onInvalidated();</div><div class="line">            if (mFastScroll != null) &#123;</div><div class="line">                mFastScroll.onSectionsChanged();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通过 super.onChanged() 继续跟踪。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public abstract class AdapterView&lt;T extends Adapter&gt; extends ViewGroup &#123;</div><div class="line"></div><div class="line">    // 代码省略</div><div class="line"></div><div class="line">    class AdapterDataSetObserver extends DataSetObserver &#123;</div><div class="line"></div><div class="line">        private Parcelable mInstanceState = null;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onChanged() &#123;</div><div class="line">            mDataChanged = true;</div><div class="line">            mOldItemCount = mItemCount;</div><div class="line">            mItemCount = getAdapter().getCount();</div><div class="line"></div><div class="line">            // Detect the case where a cursor that was previously invalidated has</div><div class="line">            // been repopulated with new data.</div><div class="line">            if (AdapterView.this.getAdapter().hasStableIds() &amp;&amp; mInstanceState != null</div><div class="line">                    &amp;&amp; mOldItemCount == 0 &amp;&amp; mItemCount &gt; 0) &#123;</div><div class="line">                AdapterView.this.onRestoreInstanceState(mInstanceState);</div><div class="line">                mInstanceState = null;</div><div class="line">            &#125; else &#123;</div><div class="line">                rememberSyncState();</div><div class="line">            &#125;</div><div class="line">            checkFocus();</div><div class="line">            // 重新布局 ListView、GridView 等 AdapterView 组件</div><div class="line">            requestLayout();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 代码省略</div><div class="line">    </div><div class="line">        public void clearSavedState() &#123;</div><div class="line">            mInstanceState = null;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>到这里我们就知道了，当 ListView 的数据发生变化时，调用 Adapter 的 notifyDataSetChanged 函数，这个函数又会调用 DataSetObservable 的 notifyChanged 函数，这个函数会调用所有观察者（AdapterDataSetObserver）的 onChanged 方法，在 onChanged 函数中又会调用 ListView  重新布局的函数使得 ListView 刷新界面。这就是一个观察者模式！</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><hr><p>利用观察者模式设计一个学校铃声的事件处理程序。</p><p>分析：在本实例中，学校的“铃”是事件源和目标，“老师”和“学生”是事件监听器和具体观察者，“铃声”是事件类。学生和老师来到学校的教学区，都会注意学校的铃，这叫事件绑定；当上课时间或下课时间到，会触发铃发声，这时会生成“铃声”事件；学生和老师听到铃声会开始上课或下课，这叫事件处理。这个实例非常适合用观察者模式实现，下图给出了学校铃声的事件模型。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-495f8bd557e07c06.gif?imageMogr2/auto-orient/strip" alt=""></p><p>现在用“观察者模式”来实现该事件处理模型。首先，定义一个铃声事件（RingEvent）类，它记录了铃声的类型（上课铃声/下课铃声）；再定义一个学校的铃（BellEventSource）类，它是事件源，是观察者目标类，该类里面包含了监听器容器 listener，可以绑定监听者（学生或老师），并且有产生铃声事件和通知所有监听者的方法；然后，定义一声事件监听者（BellEventListener）类，它是抽象观察者，它包含了铃声事件处理方法 heardBell(RingEvent e)；最后，定义老师类（TeachEventListener）和学生类（StuEventListener），它们是事件监听器，是具体观察者，听到铃声会去上课或下课。下图给出了学校铃声事件处理程序的结构。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4fc93200df08a7c0.gif?imageMogr2/auto-orient/strip" alt=""></p><p>程序代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">public class BellEventTest &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        BellEventSource bell = new BellEventSource();    // 铃（事件源）    </div><div class="line">        bell.addPersonListener(new TeachEventListener()); // 注册监听器（老师）</div><div class="line">        bell.addPersonListener(new StudentEventListener());    // 注册监听器（学生）</div><div class="line">        bell.ring(true);   // 打上课铃声</div><div class="line">        System.out.println(&quot;------------&quot;);</div><div class="line">        bell.ring(false);  // 打下课铃声</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 铃声事件类：用于封装事件源及一些与事件相关的参数</div><div class="line">class RingEvent extends EventObject &#123;   </div><div class="line">    private static final long serialVersionUID = 1L;</div><div class="line">    private boolean sound;    // true 表示上课铃声，false 表示下课铃声</div><div class="line">    public RingEvent(Object source,boolean sound) &#123;</div><div class="line">        super(source);</div><div class="line">        this.sound=sound;</div><div class="line">    &#125;   </div><div class="line">    public void setSound(boolean sound) &#123;</div><div class="line">        this.sound=sound;</div><div class="line">    &#125;</div><div class="line">    public boolean getSound() &#123;</div><div class="line">        return this.sound;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 目标类：事件源，铃</div><div class="line">class BellEventSource &#123;    </div><div class="line">    private List&lt;BellEventListener&gt; listener; // 监听器容器</div><div class="line">    public BellEventSource() &#123; </div><div class="line">        listener = new ArrayList&lt;BellEventListener&gt;();        </div><div class="line">    &#125;</div><div class="line">    // 给事件源绑定监听器 </div><div class="line">    public void addPersonListener(BellEventListener ren) &#123; </div><div class="line">        listener.add(ren); </div><div class="line">    &#125;</div><div class="line">    // 事件触发器：敲钟，当铃声 sound 的值发生变化时，触发事件。</div><div class="line">    public void ring(boolean sound) &#123;</div><div class="line">        String type = sound? &quot;上课铃&quot; : &quot;下课铃&quot;;</div><div class="line">        System.out.println(type+&quot;响！&quot;);</div><div class="line">        RingEvent event = new RingEvent(this, sound);     </div><div class="line">        notifies(event);    // 通知注册在该事件源上的所有监听器                </div><div class="line">    &#125;   </div><div class="line">    // 当事件发生时,通知绑定在该事件源上的所有监听器做出反应（调用事件处理方法）</div><div class="line">    protected void notifies(RingEvent e) &#123; </div><div class="line">        BellEventListener person; </div><div class="line">        Iterator&lt;BellEventListener&gt; iterator = listener.iterator(); </div><div class="line">        while(iterator.hasNext()) &#123; </div><div class="line">            person = iterator.next(); </div><div class="line">            person.heardBell(e); </div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽象观察者类：铃声事件监听器</div><div class="line">interface  BellEventListener extends EventListener &#123;</div><div class="line">    // 事件处理方法，听到铃声</div><div class="line">    void heardBell(RingEvent e);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//具体观察者类：老师事件监听器</div><div class="line">class TeachEventListener implements BellEventListener &#123;</div><div class="line">    public void heardBell(RingEvent e) &#123;        </div><div class="line">        if (e.getSound()) &#123;</div><div class="line">            System.out.println(&quot;老师上课了...&quot;);           </div><div class="line">        &#125; else &#123;</div><div class="line">            System.out.println(&quot;老师下课了...&quot;);   </div><div class="line">        &#125;          </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体观察者类：学生事件监听器</div><div class="line">class StudentEventListener implements BellEventListener &#123;</div><div class="line">    public void heardBell(RingEvent e) &#123;        </div><div class="line">        if (e.getSound()) &#123;</div><div class="line">            System.out.println(&quot;同学们，上课了...&quot;);           </div><div class="line">        &#125; else &#123;</div><div class="line">            System.out.println(&quot;同学们，下课了...&quot;);   </div><div class="line">        &#125;          </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">上课铃响！</div><div class="line">老师上课了...</div><div class="line">同学们，上课了...</div><div class="line">------------</div><div class="line">下课铃响！</div><div class="line">老师下课了...</div><div class="line">同学们，下课了...</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-408fc2285c446d63.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10 设计模式——命令模式</title>
      <link href="/1901/01/18/02%20DESIGN%20PATTERN/10%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
      <url>/1901/01/18/02%20DESIGN%20PATTERN/10%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0ee8ad0f5556aa8e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>命令（Command）模式：<strong>将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作</strong>。</p><p>在软件开发系统中，常常出现“方法的请求者”与“方法的实现者”之间存在紧密的耦合关系。这不利于软件功能的扩展与维护。例如，想对行为进行“撤销、重做、记录”等处理都很不方便，因此“如何将方法的请求者与方法的实现者解耦？”变得很重要，命令模式能很好地解决这个问题。</p><p>在现实生活中，这样的例子也很多，例如，电视机遥控器（命令发送者）通过按钮（具体命令）来遥控电视机（命令接收者），还有计算机键盘上的“功能键”等。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>对于大多数请求——响应模式的功能，比较适合使用命令模式。</p><ul><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li><li>系统需要在不同的时间指定请求、将请求排队（如：线程池+工作队列）和执行请求。</li><li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作（比如系统挂掉之后重启做一些恢复操作，还有数据库的事务等）。</li><li>系统需要将一组操作组合在一起，即支持宏命令。</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。</li><li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。</li><li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li><li>方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>可能产生大量具体命令类。因为计对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。</p><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><hr><p>命令模式包含以下主要角色。</p><ul><li>抽象命令类（Command）：声明执行命令的接口，拥有执行命令的抽象方法 execute()。</li><li>具体命令角色（Concrete Command）：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。</li><li>实现者/接收者（Receiver）：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li><li>调用者/请求者（Invoker）：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li></ul><p>其结构图如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-cfc7f6f783091bfa.gif?imageMogr2/auto-orient/strip" alt=""></p><p>命令模式的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public class CommandPattern &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Receiver receiver = new Receiver();</div><div class="line">        Command cmd = new ConcreteCommand(receiver);</div><div class="line">        Invoker invoker = new Invoker(cmd);</div><div class="line">        invoker.call();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 调用者</div><div class="line">class Invoker &#123;</div><div class="line">    private Command command;</div><div class="line">    public Invoker(Command command) &#123;</div><div class="line">        this.command=command;</div><div class="line">    &#125;</div><div class="line">    public void setCommand(Command command) &#123;</div><div class="line">        this.command=command;</div><div class="line">    &#125;</div><div class="line">    public void call() &#123;</div><div class="line">        // 调用具体命令对象的相关方法，执行具体命令</div><div class="line">        command.execute();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽象命令</div><div class="line">interface Command &#123;</div><div class="line">    void execute();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体命令</div><div class="line">class ConcreteCommand implements Command &#123;</div><div class="line">    private Receiver receiver;</div><div class="line">    ConcreteCommand(Receiver receiver) &#123;</div><div class="line">        this.receiver = receiver;</div><div class="line">    &#125;</div><div class="line">    public void execute() &#123;</div><div class="line">        receiver.action();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 接收者</div><div class="line">class Receiver &#123;</div><div class="line">    // 真正执行具体命令逻辑的方法</div><div class="line">    public void action() &#123;</div><div class="line">        System.out.println(&quot;接收者执行具体操作&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>用命令模式实现客户去餐馆吃早餐的实例。</p><p>分析：客户去餐馆可选择的早餐有肠粉、河粉和馄饨等，客户可向服务员选择以上早餐中的若干种，服务员将客户的请求交给相关的厨师去做。这里的点早餐相当于“命令”，服务员相当于“调用者”，厨师相当于“接收者”，所以用命令模式实现比较合适。</p><p>首先，定义一个早餐类（Breakfast），它是抽象命令类，有抽象方法 cooking()，说明要做什么；再定义其子类肠粉类（ChangFen）、馄饨类（HunTun）和河粉类（HeFen），它们是具体命令类，实现早餐类的 cooking() 方法，但它们不会具体做，而是交给具体的厨师去做；具体厨师类有肠粉厨师（ChangFenChef）、馄蚀厨师（HunTunChef）和河粉厨师（HeFenChef），他们是命令的接收者，所以把每个厨师类定义为 JFrame 的子类；最后，定义服务员类（Waiter），它接收客户的做菜请求，并发出做菜的命令。客户类是通过服务员类来点菜的，下图所示是其结构图。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-fe94a57ee9420e84.gif?imageMogr2/auto-orient/strip" alt=""></p><p>程序代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line">public class CookingCommand &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Breakfast food1 = new ChangFen();</div><div class="line">        Breakfast food2 = new HunTun();</div><div class="line">        Breakfast food3 = new HeFen();</div><div class="line">        Waiter waiter = new Waiter();</div><div class="line">        waiter.setChangFen(food1);//设置肠粉菜单</div><div class="line">        waiter.setHunTun(food2);  //设置河粉菜单</div><div class="line">        waiter.setHeFen(food3);   //设置馄饨菜单</div><div class="line">        waiter.chooseChangFen();  //选择肠粉</div><div class="line">        waiter.chooseHeFen();     //选择河粉</div><div class="line">        waiter.chooseHunTun();    //选择馄饨</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 调用者：服务员</div><div class="line">class Waiter &#123;</div><div class="line">    private Breakfast changFen, hunTun, heFen;</div><div class="line">    public void setChangFen(Breakfast f) &#123;</div><div class="line">        changFen = f;</div><div class="line">    &#125;</div><div class="line">    public void setHunTun(Breakfast f) &#123;</div><div class="line">        hunTun=f;</div><div class="line">    &#125;</div><div class="line">    public void setHeFen(Breakfast f) &#123;</div><div class="line">        heFen=f;</div><div class="line">    &#125;</div><div class="line">    public void chooseChangFen() &#123;</div><div class="line">        changFen.cooking();</div><div class="line">    &#125;</div><div class="line">    public void chooseHunTun() &#123;</div><div class="line">        hunTun.cooking();</div><div class="line">    &#125;</div><div class="line">    public void chooseHeFen() &#123;</div><div class="line">        heFen.cooking();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽象命令：早餐</div><div class="line">interface Breakfast &#123;</div><div class="line">    void cooking();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体命令：肠粉</div><div class="line">class ChangFen implements Breakfast &#123;</div><div class="line">    private ChangFenChef receiver;</div><div class="line">    ChangFen() &#123;</div><div class="line">        receiver = new ChangFenChef();</div><div class="line">    &#125;</div><div class="line">    public void cooking() &#123;       </div><div class="line">        receiver.cooking();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体命令：馄饨</div><div class="line">class HunTun implements Breakfast &#123;</div><div class="line">    private HunTunChef receiver;</div><div class="line">    HunTun() &#123;</div><div class="line">        receiver=new HunTunChef();</div><div class="line">    &#125;</div><div class="line">    public void cooking() &#123;</div><div class="line">        receiver.cooking();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体命令：河粉</div><div class="line">class HeFen implements Breakfast &#123;</div><div class="line">    private HeFenChef receiver;</div><div class="line">    HeFen() &#123;</div><div class="line">        receiver=new HeFenChef();</div><div class="line">    &#125;</div><div class="line">    public void cooking() &#123;</div><div class="line">        receiver.cooking();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 接收者：肠粉厨师</div><div class="line">class ChangFenChef extends JFrame &#123;   </div><div class="line">    private static final long serialVersionUID = 1L;</div><div class="line">    JLabel l = new JLabel();</div><div class="line">    ChangFenChef() &#123;</div><div class="line">        super(&quot;煮肠粉&quot;);</div><div class="line">        l.setIcon(new ImageIcon(&quot;src/command/ChangFen.jpg&quot;));</div><div class="line">        this.add(l);</div><div class="line">        this.setLocation(30, 30);</div><div class="line">        this.pack();</div><div class="line">        this.setResizable(false);</div><div class="line">        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);   </div><div class="line">    &#125;</div><div class="line">    public void cooking() &#123;</div><div class="line">        this.setVisible(true);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 接收者：馄饨厨师</div><div class="line">class HunTunChef extends JFrame &#123;</div><div class="line">    private static final long serialVersionUID=1L;</div><div class="line">    JLabel l = new JLabel();</div><div class="line">    HunTunChef() &#123;</div><div class="line">        super(&quot;煮馄饨&quot;);</div><div class="line">        l.setIcon(new ImageIcon(&quot;src/command/HunTun.jpg&quot;));</div><div class="line">        this.add(l);</div><div class="line">        this.setLocation(350, 50);</div><div class="line">        this.pack();</div><div class="line">        this.setResizable(false);</div><div class="line">        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    </div><div class="line">    &#125;</div><div class="line">    public void cooking() &#123;</div><div class="line">        this.setVisible(true);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 接收者：河粉厨师</div><div class="line">class HeFenChef extends JFrame &#123;</div><div class="line">    private static final long serialVersionUID=1L;</div><div class="line">    JLabel l = new JLabel();</div><div class="line">    HeFenChef() &#123;</div><div class="line">        super(&quot;煮河粉&quot;);</div><div class="line">        l.setIcon(new ImageIcon(&quot;src/command/HeFen.jpg&quot;));</div><div class="line">        this.add(l);</div><div class="line">        this.setLocation(200, 280);</div><div class="line">        this.pack();</div><div class="line">        this.setResizable(false);</div><div class="line">        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</div><div class="line">    &#125;</div><div class="line">    public void cooking() &#123;</div><div class="line">        this.setVisible(true);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><hr><p>命令模式在 GUI 上应用广泛，比如手写签名功能，需要提供撤销或重做等功能。</p><ul><li>首先声明一个抽象接口 IBrush，用它定义不同笔触需要实现的方法。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public interface IBrush &#123;</div><div class="line">    /**</div><div class="line">     * 触点接触时</div><div class="line">     * @param path  路径对象</div><div class="line">     * @param x     当前位置的 x 坐标</div><div class="line">     * @param y     当前位置的 y 坐标</div><div class="line">     */</div><div class="line">    void down(Path path, float x, float y);</div><div class="line">    /**</div><div class="line">     * 触点移动时</div><div class="line">     * @param path  路径对象</div><div class="line">     * @param x     当前位置的 x 坐标</div><div class="line">     * @param y     当前位置的 y 坐标</div><div class="line">     */</div><div class="line">    void move(Path path, float x, float y);</div><div class="line">    /**</div><div class="line">     * 触点离开时</div><div class="line">     * @param path  路径对象</div><div class="line">     * @param x     当前位置的 x 坐标</div><div class="line">     * @param y     当前位置的 y 坐标</div><div class="line">     */</div><div class="line">    void up(Path path, float x, float y);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>为了简便起见，这里只定义两种类型的笔触，一种为普通的线条，另一种为由圆点组成的线条轨迹。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// 普通笔触</div><div class="line">public class NormalBrush implements IBrush &#123;</div><div class="line">    @Override</div><div class="line">    public void down(Path path, float x, float y) &#123;</div><div class="line">        path.moveTo(x, y);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void move(Path path, float x, float y) &#123;</div><div class="line">        path.lineTo(x, y);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void up(Path path, float x, float y) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 圆形笔触</div><div class="line">public class CircleBrush implements IBrush &#123;</div><div class="line">    @Override</div><div class="line">    public void down(Path path, float x, float y) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void move(Path path, float x, float y) &#123;</div><div class="line">        path.addCircle(x, y, 10, Path.Direction.CCW);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void up(Path path, float x, float y) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>对于每一次路径的绘制，都可以有两个命令，一个是绘制命令，另一个是撤销命令，我们将其封装为一个命令接口。注意，这里结合命令模式去构思。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public interface IDraw &#123;</div><div class="line">    /**</div><div class="line">     * 绘制命令</div><div class="line">     * @param canvas  画布对象</div><div class="line">     */</div><div class="line">    void draw(Canvas canvas);</div><div class="line">    /**</div><div class="line">     * 撤销命令</div><div class="line">     */</div><div class="line">    void undo();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>这里只有一种绘制路径方法，即一个具体命令。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class DrawPath implements IDraw &#123;</div><div class="line">    public Path path;      // 需要绘制的路径</div><div class="line">    public Paint paint;    // 绘制画笔</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void draw(Canvas canvas) &#123;</div><div class="line">        canvas.drawPath(path, paint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void undo() &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>需要一个请求者角色（Invoker）来对命令做进一步封装。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">public class DrawInvoker &#123;</div><div class="line">    // 绘制列表</div><div class="line">    private List&lt;DrawPath&gt; drawList = Collections.synchronizedList(new ArrayList&lt;DrawPath&gt;());</div><div class="line">    // 重做列表</div><div class="line">    private List&lt;DrawPath&gt; redoList = Collections.synchronizedList(new ArrayList&lt;DrawPath&gt;());</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 增加一个命令</div><div class="line">     * @param command DrawPath</div><div class="line">     */</div><div class="line">    public void add(DrawPath command) &#123;</div><div class="line">        redoList.clear();</div><div class="line">        drawList.add(command);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 撤销上一步命令</div><div class="line">     */</div><div class="line">    public void undo() &#123;</div><div class="line">        if (drawList.size() &gt; 0) &#123;</div><div class="line">            int index = drawList.size() - 1;</div><div class="line">            DrawPath undo = drawList.get(index);</div><div class="line">            drawList.remove(index);</div><div class="line">            undo.undo();</div><div class="line">            redoList.add(undo);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 重做上一步撤销的命令</div><div class="line">     */</div><div class="line">    public void redo() &#123;</div><div class="line">        if (redoList.size() &gt; 0) &#123;</div><div class="line">            int index = redoList.size() - 1;</div><div class="line">            DrawPath redoCommand = redoList.get(index);</div><div class="line">            redoList.remove(index);</div><div class="line">            drawList.add(redoCommand);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 执行命令</div><div class="line">     */</div><div class="line">    public void execute(Canvas canvas) &#123;</div><div class="line">        if (drawList != null) &#123;</div><div class="line">            for (DrawPath tmp : drawList) &#123;</div><div class="line">                tmp.draw(canvas);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 是否可以重做</div><div class="line">     */</div><div class="line">    public boolean canRedo() &#123;</div><div class="line">        return  redoList.size() &gt; 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 是否可以撤销</div><div class="line">     */</div><div class="line">    public boolean canUndo() &#123;</div><div class="line">        return  drawList.size() &gt; 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>需要一个具体的接收者，这里承担重任的是一个 SurfaceView 对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line">public class DrawCanvas extends SurfaceView implements SurfaceHolder.Callback &#123;</div><div class="line">    // 标识是否可以绘制、绘制线程是否可以运行</div><div class="line">    public boolean isDrawing, isRunning;</div><div class="line"></div><div class="line">    private Bitmap mBitmap;         // 绘制到的位图对象</div><div class="line">    private DrawInvoker mInvoker;   // 绘制命令请求对象</div><div class="line">    private DrawThread mThread;     // 绘制线程</div><div class="line"></div><div class="line">    public DrawCanvas(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mInvoker = new DrawInvoker();</div><div class="line">        mThread = new DrawThread();</div><div class="line"></div><div class="line">        getHolder().addCallback(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void surfaceCreated(SurfaceHolder holder) &#123;</div><div class="line">        isRunning = true;</div><div class="line">        mThread.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123;</div><div class="line">        mBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.RGB_565);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void surfaceDestroyed(SurfaceHolder holder) &#123;</div><div class="line">        boolean retry = true;</div><div class="line">        isRunning = false;</div><div class="line">        while (retry) &#123;</div><div class="line">            try &#123;</div><div class="line">                mThread.join();</div><div class="line">                retry = false;</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 增加一条绘制路径</div><div class="line">     * @param path DrawPath</div><div class="line">     */</div><div class="line">    public void add(DrawPath path) &#123;</div><div class="line">        mInvoker.add(path);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 撤销上一步的绘制</div><div class="line">     */</div><div class="line">    public void undo() &#123;</div><div class="line">        isDrawing = true;</div><div class="line">        mInvoker.undo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 重做上一步撤销的绘制</div><div class="line">     */</div><div class="line">    public void redo() &#123;</div><div class="line">        isDrawing = true;</div><div class="line">        mInvoker.redo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 是否可以重做</div><div class="line">     */</div><div class="line">    public boolean canRedo() &#123;</div><div class="line">        return mInvoker.canRedo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 是否可以撤销</div><div class="line">     */</div><div class="line">    public boolean canUndo() &#123;</div><div class="line">        return mInvoker.canUndo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class DrawThread extends Thread &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            Canvas canvas = null;</div><div class="line">            while (isRunning) &#123;</div><div class="line">                if (isDrawing) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        canvas = getHolder().lockCanvas();</div><div class="line">                        if (mBitmap == null) &#123;</div><div class="line">                            mBitmap = Bitmap.createBitmap(1, 1, Bitmap.Config.ARGB_8888);</div><div class="line">                        &#125;</div><div class="line">                        Canvas c = new Canvas(mBitmap);</div><div class="line">                        c.drawColor(0, PorterDuff.Mode.CLEAR);</div><div class="line"></div><div class="line">                        canvas.drawColor(0, PorterDuff.Mode.CLEAR);</div><div class="line">                        mInvoker.execute(c);</div><div class="line">                        canvas.drawBitmap(mBitmap, 0, 0, null);</div><div class="line">                    &#125; finally &#123;</div><div class="line">                        getHolder().unlockCanvasAndPost(canvas);</div><div class="line">                    &#125;</div><div class="line">                    isDrawing = false;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>最后在 Activity 中整合各个功能模块。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.graphics.Paint;</div><div class="line">import android.graphics.Path;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.view.MotionEvent;</div><div class="line">import android.view.View;</div><div class="line">import android.widget.Button;</div><div class="line"></div><div class="line">import com.xxt.xtest.demo.CircleBrush;</div><div class="line">import com.xxt.xtest.demo.DrawCanvas;</div><div class="line">import com.xxt.xtest.demo.DrawPath;</div><div class="line">import com.xxt.xtest.demo.IBrush;</div><div class="line">import com.xxt.xtest.demo.NormalBrush;</div><div class="line"></div><div class="line">public class TestActivity extends BaseActivity &#123;</div><div class="line">    private DrawCanvas mCanvas; // 绘制画布</div><div class="line">    private DrawPath mPath;     // 路径绘制命令</div><div class="line">    private Paint mPaint;       // 画笔对象</div><div class="line">    private IBrush mBrush;      // 笔触对象</div><div class="line"></div><div class="line">    private Button btnRedo, btnUndo;    // 重做、撤销按钮</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_test);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(0xFFFFFFFF);</div><div class="line">        mPaint.setStrokeWidth(3);</div><div class="line"></div><div class="line">        mBrush = new NormalBrush();</div><div class="line"></div><div class="line">        mCanvas = findViewById(R.id.draw_canvas);</div><div class="line">        mCanvas.setOnTouchListener(new DrawTouchListener());</div><div class="line"></div><div class="line">        btnRedo = findViewById(R.id.redo_btn);</div><div class="line">        btnRedo.setEnabled(false);</div><div class="line">        btnUndo = findViewById(R.id.undo_btn);</div><div class="line">        btnUndo.setEnabled(false);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void onClick(View view) &#123;</div><div class="line">        switch (view.getId()) &#123;</div><div class="line">            case R.id.red_btn:</div><div class="line">                mPaint = new Paint();</div><div class="line">                mPaint.setStrokeWidth(3);</div><div class="line">                mPaint.setColor(0xFFFF0000);</div><div class="line">                break;</div><div class="line">            case R.id.green_btn:</div><div class="line">                mPaint = new Paint();</div><div class="line">                mPaint.setStrokeWidth(3);</div><div class="line">                mPaint.setColor(0xFF00FF00);</div><div class="line">                break;</div><div class="line">            case R.id.blue_btn:</div><div class="line">                mPaint = new Paint();</div><div class="line">                mPaint.setStrokeWidth(3);</div><div class="line">                mPaint.setColor(0xFF0000FF);</div><div class="line">                break;</div><div class="line">            case R.id.normal_brush_btn:</div><div class="line">                mBrush = new NormalBrush();</div><div class="line">                break;</div><div class="line">            case R.id.circle_brush_btn:</div><div class="line">                mBrush = new CircleBrush();</div><div class="line">                break;</div><div class="line">            case R.id.undo_btn:</div><div class="line">                mCanvas.undo();</div><div class="line">                if (!mCanvas.canUndo()) &#123;</div><div class="line">                    btnUndo.setEnabled(false);</div><div class="line">                &#125;</div><div class="line">                btnRedo.setEnabled(true);</div><div class="line">                break;</div><div class="line">            case R.id.redo_btn:</div><div class="line">                mCanvas.redo();</div><div class="line">                if (!mCanvas.canRedo()) &#123;</div><div class="line">                    btnRedo.setEnabled(false);</div><div class="line">                &#125;</div><div class="line">                btnUndo.setEnabled(true);</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class DrawTouchListener implements View.OnTouchListener &#123;</div><div class="line">        @Override</div><div class="line">        public boolean onTouch(View v, MotionEvent event) &#123;</div><div class="line">            if (MotionEvent.ACTION_DOWN == event.getAction()) &#123;</div><div class="line">                mPath = new DrawPath();</div><div class="line">                mPath.paint = mPaint;</div><div class="line">                mPath.path = new Path();</div><div class="line">                mBrush.down(mPath.path, event.getX(), event.getY());</div><div class="line">            &#125; else if (MotionEvent.ACTION_MOVE == event.getAction()) &#123;</div><div class="line">                mBrush.move(mPath.path, event.getX(), event.getY());</div><div class="line">            &#125; else if (MotionEvent.ACTION_UP == event.getAction()) &#123;</div><div class="line">                mBrush.up(mPath.path, event.getX(), event.getY());</div><div class="line">                mCanvas.add(mPath);</div><div class="line">                mCanvas.isDrawing = true;</div><div class="line">                btnUndo.setEnabled(true);</div><div class="line">                btnRedo.setEnabled(false);</div><div class="line">            &#125;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>res/layout/act_test.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line">    &lt;com.xxt.xtest.demo.DrawCanvas</div><div class="line">        android:id=&quot;@+id/draw_canvas&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;0dp&quot;</div><div class="line">        android:layout_weight=&quot;1&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;&gt;</div><div class="line">        &lt;Button</div><div class="line">            android:id=&quot;@+id/red_btn&quot;</div><div class="line">            android:layout_width=&quot;0dp&quot;</div><div class="line">            android:layout_weight=&quot;1&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:onClick=&quot;onClick&quot;</div><div class="line">            android:textColor=&quot;#FF0000&quot;</div><div class="line">            android:text=&quot;红色&quot; /&gt;</div><div class="line">        &lt;Button</div><div class="line">            android:id=&quot;@+id/green_btn&quot;</div><div class="line">            android:layout_width=&quot;0dp&quot;</div><div class="line">            android:layout_weight=&quot;1&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:onClick=&quot;onClick&quot;</div><div class="line">            android:textColor=&quot;#00FF00&quot;</div><div class="line">            android:text=&quot;绿色&quot; /&gt;</div><div class="line">        &lt;Button</div><div class="line">            android:id=&quot;@+id/blue_btn&quot;</div><div class="line">            android:layout_width=&quot;0dp&quot;</div><div class="line">            android:layout_weight=&quot;1&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:onClick=&quot;onClick&quot;</div><div class="line">            android:textColor=&quot;#0000FF&quot;</div><div class="line">            android:text=&quot;蓝色&quot; /&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;&gt;</div><div class="line">        &lt;Button</div><div class="line">            android:id=&quot;@+id/normal_brush_btn&quot;</div><div class="line">            android:layout_width=&quot;0dp&quot;</div><div class="line">            android:layout_weight=&quot;1&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:onClick=&quot;onClick&quot;</div><div class="line">            android:text=&quot;普通笔刷&quot; /&gt;</div><div class="line">        &lt;Button</div><div class="line">            android:id=&quot;@+id/circle_brush_btn&quot;</div><div class="line">            android:layout_width=&quot;0dp&quot;</div><div class="line">            android:layout_weight=&quot;1&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:onClick=&quot;onClick&quot;</div><div class="line">            android:text=&quot;圆形笔刷&quot; /&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;&gt;</div><div class="line">        &lt;Button</div><div class="line">            android:id=&quot;@+id/undo_btn&quot;</div><div class="line">            android:layout_width=&quot;0dp&quot;</div><div class="line">            android:layout_weight=&quot;1&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:onClick=&quot;onClick&quot;</div><div class="line">            android:text=&quot;撤销&quot; /&gt;</div><div class="line">        &lt;Button</div><div class="line">            android:id=&quot;@+id/redo_btn&quot;</div><div class="line">            android:layout_width=&quot;0dp&quot;</div><div class="line">            android:layout_weight=&quot;1&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:onClick=&quot;onClick&quot;</div><div class="line">            android:text=&quot;重做&quot; /&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>效果图如下</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-57d2cfc82b98e8cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7040adb17a0b23bb.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09 设计模式——解释器模式</title>
      <link href="/1901/01/17/02%20DESIGN%20PATTERN/09%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/1901/01/17/02%20DESIGN%20PATTERN/09%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-3b5d27662d756003.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>解释器（Interpreter）模式：<strong>给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文</strong>。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>在软件开发中，会遇到有些问题多次重复出现，而且有一定的相似性和规律性。如果将它们归纳成一种简单的语言，那么这些问题实例将是该语言的一些句子，这样就可以用“编译原理”中的解释器模式来实现了。</p><p>虽然使用解释器模式的实例不是很多，但对于满足以上特点，且对运行效率要求不是很高的应用实例，如果用解释器模式来实现，其效果是非常好的。比如<strong>正则表达式、XML文档解释</strong>等领域。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。</li><li>容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。</li><li>会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。</li><li>可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。</li></ul><h3 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h3><hr><h4 id="文法、句子、语法树"><a href="#文法、句子、语法树" class="headerlink" title="文法、句子、语法树"></a>文法、句子、语法树</h4><p>解释器模式常用于对简单语言的编译或分析实例中，为了掌握好它的结构与实现，必须先了解编译原理中的“文法、句子、语法树”等相关概念。</p><h5 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h5><p>文法是用于描述语言的语法结构的形式规则。没有规矩不成方圆，例如，有些人认为完美爱情的准则是“相互吸引、感情专一、任何一方都没有恋爱经历”，虽然最后一条准则较苛刻，但任何事情都要有规则，语言也一样，不管它是机器语言还是自然语言，都有它自己的文法规则。例如，中文中的“句子”的文法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">〈主语〉::=〈代词〉|〈名词〉</div><div class="line">〈谓语〉::=〈动词〉</div><div class="line">〈宾语〉::=〈代词〉|〈名词〉</div><div class="line">〈代词〉你|我|他</div><div class="line">〈名词〉7大学生I筱霞I英语</div><div class="line">〈动词〉::=是|学习</div></pre></td></tr></table></figure></p><p>这里的符号“::=”表示“定义为”的意思，用“〈”和“〉”括住的是非终结符，没有括住的是终结符。</p><h5 id="句子"><a href="#句子" class="headerlink" title="句子"></a>句子</h5><p>句子是语言的基本单位，是语言集中的一个元素，它由终结符构成，能由“文法”推导出。例如，上述文法可以推出“我是大学生”，所以它是句子。</p><h5 id="语法树"><a href="#语法树" class="headerlink" title="语法树"></a>语法树</h5><p>语法树是句子结构的一种树型表示，它代表了句子的推导结果，它有利于理解句子语法结构的层次。下图所示是“我是大学生”的语法树。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7e95a18623742e1e.gif?imageMogr2/auto-orient/strip" alt=""></p><h4 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>解释器模式包含以下主要角色。</p><ul><li>抽象表达式（Abstract Expression）：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</li><li>终结符表达式（Terminal    Expression）：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</li><li>非终结符表达式（Nonterminal Expression）：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</li><li>环境（Context）：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</li><li>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d96ee97e5419f1a7.gif?imageMogr2/auto-orient/strip" alt="解释器模式的结构图"></p><h4 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>解释器模式实现的关键是定义文法规则、设计终结符类与非终结符类、画出结构图，必要时构建语法树，其代码结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 抽象表达式类</div><div class="line">interface AbstractExpression &#123;</div><div class="line">    public Object interpret(String info);    // 解释方法</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 终结符表达式类</div><div class="line">class TerminalExpression implements AbstractExpression &#123;</div><div class="line">    public Object interpret(String info) &#123;</div><div class="line">        // 对终结符表达式的处理</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 非终结符表达式类</div><div class="line">class NonterminalExpression implements AbstractExpression &#123;</div><div class="line">    private AbstractExpression exp1;</div><div class="line">    private AbstractExpression exp2;</div><div class="line">    public Object interpret(String info) &#123;</div><div class="line">        // 非对终结符表达式的处理</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 环境类</div><div class="line">class Context &#123;</div><div class="line">    private AbstractExpression exp;</div><div class="line">    public Context() &#123;</div><div class="line">        // 数据初始化</div><div class="line">    &#125;</div><div class="line">    public void operation(String info) &#123;</div><div class="line">        // 调用相关表达式类的解释方法</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>需求：比如算数表达式 m + n + p。代表数字的m、n、p三个字符看成终结符号，+ 看做非终结符号。</p><p>1、抽象的算术运算解释器，为所有解释器共性的提取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public abstract class ArithmeticExpression &#123;</div><div class="line">    /**</div><div class="line">     * 抽象的解析方法</div><div class="line">     * 具体的解析逻辑由具体的子类实现</div><div class="line">     * @return 解析得到具体的值</div><div class="line">     */</div><div class="line">    public abstract int interpret();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>2、数字解释器，仅仅为了解释数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class NumExpression extends ArithmeticExpression &#123;</div><div class="line">    private int num;</div><div class="line"></div><div class="line">    public NumExpression(int num) &#123;</div><div class="line">        this.num = num;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int interpret() &#123;</div><div class="line">        return num;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>3、运算符号抽象解释器，为所有运算符号解释器共性的提取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public abstract class OperatorExpression extends ArithmeticExpression &#123;</div><div class="line">    // 声明两个成员变量存储运算符号两边的数字解释器</div><div class="line">    protected ArithmeticExpression exp1, exp2;</div><div class="line"></div><div class="line">    public OperatorExpression(ArithmeticExpression exp1, ArithmeticExpression exp2) &#123;</div><div class="line">        this.exp1 = exp1;</div><div class="line">        this.exp2 = exp2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>4、加法运算抽象解释器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class AdditionExpression extends OperatorExpression &#123;</div><div class="line">    public AdditionExpression(ArithmeticExpression exp1, ArithmeticExpression exp2) &#123;</div><div class="line">        super(exp1, exp2);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int interpret() &#123;</div><div class="line">        return exp1.interpret() + exp2.interpret();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>5、处理与解释相关的一些业务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class Calculator &#123;</div><div class="line">    // 声明一个 Stack 栈存储并操作所有相关的解释器</div><div class="line">    private Stack&lt;ArithmeticExpression&gt; mExpStack = new Stack&lt;&gt;();</div><div class="line"></div><div class="line">    public Calculator(String expression) &#123;</div><div class="line">        // 声明两个 TerminalExpression 类型的临时变量，存储运算符左右两边的数字解释器</div><div class="line">        ArithmeticExpression exp1, exp2;</div><div class="line"></div><div class="line">        String[] elements = expression.split(&quot; &quot;);</div><div class="line"></div><div class="line">        // 循环遍历表达式元素数组</div><div class="line">        for (int i = 0; i &lt; elements.length; i++) &#123;</div><div class="line">            // 判断运算符号</div><div class="line">            switch (elements[i].charAt(0)) &#123;</div><div class="line">                case &apos;+&apos;:   // 如果是加号</div><div class="line">                    // 将栈中的解释器弹出作为运算符号右边的解释器</div><div class="line">                    exp1 = mExpStack.pop();</div><div class="line">                    // 同时将运算符号数组下标下一个元素构造为一个数字解释器</div><div class="line">                    exp2 = new NumExpression(Integer.valueOf(elements[++i]));</div><div class="line">                    // 通过尚明两个数字解释器构造加法运算解释器</div><div class="line">                    mExpStack.push(new AdditionExpression(exp1, exp2));</div><div class="line">                    break;    </div><div class="line">                default:    // 如果是数字</div><div class="line">                    // 直接构造数字解释器并压入栈</div><div class="line">                    mExpStack.push(new NumExpression(Integer.valueOf(elements[i])));</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int calculate() &#123;</div><div class="line">        return mExpStack.pop().interpret();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>6、客户类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Calculator calculator = new Calculator(&quot;1 + 2 + 3 + 10&quot;);</div><div class="line">        System.out.println(calculator.calculate());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>此时只是定义了加法运算，如果需要增加减法运算，则可以在 Calculator 中增加以下分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">case &apos;-&apos;:   //如果是减号</div><div class="line">    exp1 = mExpStack.pop();</div><div class="line">    exp2 = new NumExpression(Integer.valueOf(elements[++i]));</div><div class="line">    mExpStack.push(new SubtractionExpression(exp1, exp2));</div><div class="line">    break;</div></pre></td></tr></table></figure></p><p>此时，在 Client 中就可以开始使用了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Calculator calculator = new Calculator(&quot;1 - 2 - 3 + 10&quot;);</div><div class="line">        System.out.println(calculator.calculate());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="ANDROID-源码中的实现"><a href="#ANDROID-源码中的实现" class="headerlink" title="ANDROID 源码中的实现"></a>ANDROID 源码中的实现</h3><hr><p>AndroidManifest.xml 配置文件的读取。源代码追踪关键词：PackageParser 类的 parseSplitApk()、parseSplitApplication() 方法。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-db1c250de134f85f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="parseSplitApplication"></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><hr><p>用解释器模式设计一个“韶粵通”公交车卡的读卡器程序。</p><p>说明：假如“韶粵通”公交车读卡器可以判断乘客的身份，如果是“韶关”或者“广州”的“老人” “妇女”“儿童”就可以免费乘车，其他人员乘车一次扣 2 元。</p><p>分析：本实例用“解释器模式”设计比较适合，首先设计其文法规则如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;expression&gt; ::= &lt;city&gt;的&lt;person&gt;</div><div class="line">&lt;city&gt; ::= 韶关|广州</div><div class="line">&lt;person&gt; ::= 老人|妇女|儿童</div></pre></td></tr></table></figure></p><p>然后，根据文法规则按以下步骤设计公交车卡的读卡器程序的类图。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b44052f9073ec65a.gif?imageMogr2/auto-orient/strip" alt=""></p><p>程序代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">/*文法规则</div><div class="line">  &lt;expression&gt; ::= &lt;city&gt;的&lt;person&gt;</div><div class="line">  &lt;city&gt; ::= 韶关|广州</div><div class="line">  &lt;person&gt; ::= 老人|妇女|儿童</div><div class="line">*/</div><div class="line">public class InterpreterPatternDemo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Context bus = new Context();</div><div class="line">        bus.freeRide(&quot;韶关的老人&quot;);</div><div class="line">        bus.freeRide(&quot;韶关的年轻人&quot;);</div><div class="line">        bus.freeRide(&quot;广州的妇女&quot;);</div><div class="line">        bus.freeRide(&quot;广州的儿童&quot;);</div><div class="line">        bus.freeRide(&quot;山东的儿童&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽象表达式类</div><div class="line">interface Expression &#123;</div><div class="line">    public boolean interpret(String info);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 终结符表达式类</div><div class="line">class TerminalExpression implements Expression &#123;</div><div class="line">    private Set&lt;String&gt; set = new HashSet&lt;String&gt;();</div><div class="line">    public TerminalExpression(String[] data) &#123;</div><div class="line">        for(int i=0; i&lt;data.length; i++) set.add(data[i]);</div><div class="line">    &#125;</div><div class="line">    public boolean interpret(String info) &#123;</div><div class="line">        if (set.contains(info)) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 非终结符表达式类</div><div class="line">class AndExpression implements Expression &#123;</div><div class="line">    private Expression city;    </div><div class="line">    private Expression person;</div><div class="line">    public AndExpression(Expression city,Expression person) &#123;</div><div class="line">        this.city=city;</div><div class="line">        this.person=person;</div><div class="line">    &#125;</div><div class="line">    public boolean interpret(String info) &#123;</div><div class="line">        String s[] = info.split(&quot;的&quot;);       </div><div class="line">        return city.interpret(s[0]) &amp;&amp; person.interpret(s[1]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 环境类</div><div class="line">class Context &#123;</div><div class="line">    private String[] cities = &#123;&quot;韶关&quot;,&quot;广州&quot;&#125;;</div><div class="line">    private String[] persons = &#123;&quot;老人&quot;,&quot;妇女&quot;,&quot;儿童&quot;&#125;;</div><div class="line">    private Expression cityPerson;</div><div class="line">    public Context() &#123;</div><div class="line">        Expression city = new TerminalExpression(cities);</div><div class="line">        Expression person = new TerminalExpression(persons);</div><div class="line">        cityPerson = new AndExpression(city,person);</div><div class="line">    &#125;</div><div class="line">    public void freeRide(String info) &#123;</div><div class="line">        boolean ok = cityPerson.interpret(info);</div><div class="line">        if (ok) System.out.println(&quot;您是&quot;+info+&quot;，您本次乘车免费！&quot;);</div><div class="line">        else System.out.println(info+&quot;，您不是免费人员，本次乘车扣费2元！&quot;);   </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">您是韶关的老人，您本次乘车免费！</div><div class="line">韶关的年轻人，您不是免费人员，本次乘车扣费2元！</div><div class="line">您是广州的妇女，您本次乘车免费！</div><div class="line">您是广州的儿童，您本次乘车免费！</div><div class="line">山东的儿童，您不是免费人员，本次乘车扣费2元！</div></pre></td></tr></table></figure></p><h4 id="数学公式解析器"><a href="#数学公式解析器" class="headerlink" title="数学公式解析器"></a>数学公式解析器</h4><p>在项目开发中，如果要对数据表达式进行分析与计算，无须再用解释器模式进行设计了，Java 提供了以下强大的数学公式解析器：Expression4J、MESP(Math Expression String Parser) 和 Jep 等，它们可以解释一些复杂的文法，功能强大，使用简单。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class JepDemo &#123;</div><div class="line">    public static void main(String[] args) throws JepException &#123;</div><div class="line">        Jep jep = new Jep();</div><div class="line">        // 定义要计算的数据表达式</div><div class="line">        String 存款利息 = &quot;本金*利率*时间&quot;;</div><div class="line">        // 给相关变量赋值</div><div class="line">        jep.addVariable(&quot;本金&quot;,10000);</div><div class="line">        jep.addVariable(&quot;利率&quot;,0.038);</div><div class="line">        jep.addVariable(&quot;时间&quot;,2);</div><div class="line">        jep.parse(存款利息);    // 解析表达式</div><div class="line">        Object accrual=jep.evaluate();    // 计算</div><div class="line">        System.out.println(&quot;存款利息：&quot; + accrual);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">存款利息：760.0</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-5c4b7fe62558bd23.gif?imageMogr2/auto-orient/strip" alt=""></p><p>参考链接：<br><a href="https://www.jianshu.com/p/331f47bb8e26" target="_blank" rel="external">设计模式 | 解释器模式及典型应用</a><br><a href="http://c.biancheng.net/view/1402.html" target="_blank" rel="external">解释器模式（详解版）</a></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08 设计模式——责任链模式</title>
      <link href="/1901/01/16/02%20DESIGN%20PATTERN/08%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
      <url>/1901/01/16/02%20DESIGN%20PATTERN/08%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-aa12644eed96d71e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>责任链模式：<strong>使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连城一条链，并沿着这条链传递该请求，直到有对象处理它为止</strong>。</p><p>它是行为型设计模式之一。我们将多个节点首尾相连构成的模型称为链，而每个节点都可以拆开再连接。因此，链式结构具有很好的灵活性。将这样一种结构应用于编程领域，将每一个节点看作是一个对象，每一个对象拥有不同的处理逻辑，将一个请求从链式的首端发出，沿着链的路径依次传递给每一个节点对象，直至有对象处理这个请求为止。我们将这样的一种模式称为<strong>责任链模式</strong>。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>多个对象可以处理同一请求，但具体由哪个对象处理则在运行时动态决定。<br>在请求处理者不明确的情况下向多个对象中的一个提交一个请求。<br>需要动态指定一组对象处理请求。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong>：对请求者和处理者关系解耦，提高代码的灵活性。<br><strong>缺点</strong>：如果处理者太多，那么遍历必定会影响性能。</p><h4 id="UML-关系图"><a href="#UML-关系图" class="headerlink" title="UML 关系图"></a>UML 关系图</h4><h5 id="简化版-UML-类图"><a href="#简化版-UML-类图" class="headerlink" title="简化版 UML 类图"></a>简化版 UML 类图</h5><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e1892ae495a60100.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>根据类图我们可以得出如下简化版的通用模板代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">// 抽象处理者</div><div class="line">abstract class Handler &#123;</div><div class="line">    protected Handler successor;    // 下一个节点的处理者</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 请求处理</div><div class="line">     * @param condition 请求条件</div><div class="line">     */</div><div class="line">    public abstract void handleRequest(String condition);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体的处理者 1</div><div class="line">class ConcreteHandler1 extends Handler &#123;</div><div class="line">    @Override</div><div class="line">    public void handleRequest(String condition) &#123;</div><div class="line">        if (&quot;ConcreteHandler1&quot;.equals(condition)) &#123;</div><div class="line">            System.out.println(&quot;ConcreteHandler1 handled&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            successor.handleRequest(condition);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体的处理者 2</div><div class="line">class ConcreteHandler2 extends Handler &#123;</div><div class="line">    @Override</div><div class="line">    public void handleRequest(String condition) &#123;</div><div class="line">        if (&quot;ConcreteHandler2&quot;.equals(condition)) &#123;</div><div class="line">            System.out.println(&quot;ConcreteHandler2 handled&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            successor.handleRequest(condition);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 客户类</div><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ConcreteHandler1 handler1 = new ConcreteHandler1();</div><div class="line">        ConcreteHandler2 handler2 = new ConcreteHandler2();</div><div class="line">        handler1.successor = handler2;</div><div class="line">        handler2.successor = handler1;</div><div class="line">        handler1.handleRequest(&quot;ConcreteHandler2&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>角色介绍：</p><ul><li>Handler：抽象处理者角色，声明一个请求处理的方法，并在其中保持一个对下一个处理节点 Handler 对象的引用。</li><li>ConcreteHandler：具体处理者角色，对请求进行处理，如果不能处理则将该请求转发给下一个节点上的处理对象。</li></ul><h5 id="完整版-UML-类图"><a href="#完整版-UML-类图" class="headerlink" title="完整版 UML 类图"></a>完整版 UML 类图</h5><p>上面的请求形式为固定的字符串，处理规则为该字符串是否与之匹配。然而在大多数情况下，责任链中的请求和对应的处理规则是不尽相同的，在这种情况下可以将请求进行封装，同时对请求的处理规则也进行封装作为一个独立的对象。类图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-bb2f101a9bf496a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对应模板代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line">// 抽象处理者</div><div class="line">abstract class AbstractHandler &#123;</div><div class="line">    protected AbstractHandler nextHandler;    // 下一个节点上的处理者对象</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 处理请求</div><div class="line">     * @param request 请求对象</div><div class="line">     */</div><div class="line">    public final void handleRequest(AbstractRequest request) &#123;</div><div class="line">        if (getHandlerLevel() == request.getRequestLevel()) &#123;</div><div class="line">            // 一致则由该处理对象处理</div><div class="line">            handle(request);</div><div class="line">        &#125; else &#123;</div><div class="line">            // 否则将该请求转发给下一个节点上的请求对象</div><div class="line">            if (nextHandler != null) &#123;</div><div class="line">                nextHandler.handleRequest(request);</div><div class="line">            &#125; else &#123;</div><div class="line">                System.out.println(&quot;All of handler can not handle the request&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected abstract int getHandlerLevel();</div><div class="line">    // 每个处理者对象的具体处理方式</div><div class="line">    protected abstract void handle(AbstractRequest request);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽象请求者</div><div class="line">abstract class AbstractRequest &#123;</div><div class="line">    private Object obj; // 处理对象</div><div class="line"></div><div class="line">    public AbstractRequest(Object obj) &#123;</div><div class="line">        this.obj = obj;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Object getContent() &#123;</div><div class="line">        return obj;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 获取请求级别</div><div class="line">    public abstract int getRequestLevel();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体处理者</div><div class="line">class Handler1 extends AbstractHandler &#123;</div><div class="line">    @Override</div><div class="line">    protected int getHandlerLevel() &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void handle(AbstractRequest request) &#123;</div><div class="line">        System.out.println(&quot;Handler1 handle request: &quot;</div><div class="line">                + request.getRequestLevel());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Handler2 extends AbstractHandler &#123;</div><div class="line">    @Override</div><div class="line">    protected int getHandlerLevel() &#123;</div><div class="line">        return 2;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void handle(AbstractRequest request) &#123;</div><div class="line">        System.out.println(&quot;Handler2 handle request: &quot;</div><div class="line">                + request.getRequestLevel());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Handler3 extends AbstractHandler &#123;</div><div class="line">    @Override</div><div class="line">    protected int getHandlerLevel() &#123;</div><div class="line">        return 3;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void handle(AbstractRequest request) &#123;</div><div class="line">        System.out.println(&quot;Handler3 handle request: &quot;</div><div class="line">                + request.getRequestLevel());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体请求者</div><div class="line">class ConcreteRequest1 extends AbstractRequest &#123;</div><div class="line">    public ConcreteRequest1(Object obj) &#123;</div><div class="line">        super(obj);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public int getRequestLevel() &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ConcreteRequest2 extends AbstractRequest &#123;</div><div class="line">    public ConcreteRequest2(Object obj) &#123;</div><div class="line">        super(obj);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public int getRequestLevel() &#123;</div><div class="line">        return 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ConcreteRequest3 extends AbstractRequest &#123;</div><div class="line">    public ConcreteRequest3(Object obj) &#123;</div><div class="line">        super(obj);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public int getRequestLevel() &#123;</div><div class="line">        return 3;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面是客户类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // 构造 3 个处理者对象</div><div class="line">        AbstractHandler handler1 = new Handler1();</div><div class="line">        AbstractHandler handler2 = new Handler2();</div><div class="line">        AbstractHandler handler3 = new Handler3();</div><div class="line">        // 设置当前处理者对象的下一个节点的处理者对象</div><div class="line">        handler1.nextHandler = handler2;</div><div class="line">        handler2.nextHandler = handler3;</div><div class="line">        // 构造 3 个请求者对象</div><div class="line">        AbstractRequest request1 = new ConcreteRequest1(&quot;Request1&quot;);</div><div class="line">        AbstractRequest request2 = new ConcreteRequest2(&quot;Request2&quot;);</div><div class="line">        AbstractRequest request3 = new ConcreteRequest3(&quot;Request3&quot;);</div><div class="line">        // 总是从链式的首端发起请求</div><div class="line">        handler1.handleRequest(request1);</div><div class="line">        handler1.handleRequest(request2);</div><div class="line">        // 不从链式的首端发起请求</div><div class="line">        handler2.handleRequest(request3);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>对于责任链中的一个处理者对象，其只有两个行为：一是处理请求，而是将请求转发给下一个节点。不允许某个处理者对象在处理了请求后又将请求转发给上一个节点的情况。对于一条责任链来说，一个请求最终只有两种情况：一是被某个处理对象所处理，另一个是所有对象均未对其处理。前一种情况称之为纯的责任链，后一种情况称之为不纯的责任链。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>小先向组长报销 5 万元费用，组长一看是笔不小的数目，他没有权限审批，于是组长拿着票据去找部门主管；主管的权限内只能批五千以下的费用，于是主管又跑去找经理；经理权限也不够直接奔向老板的办公室。使用责任链模式的代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">// 抽象领导者</div><div class="line">abstract class Leader &#123;</div><div class="line">    protected Leader nextHandler;    // 上一级领导处理者</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 处理报账请求</div><div class="line">     * @param money 能批复的报账额度</div><div class="line">     */</div><div class="line">    public final void handleRequest(int money) &#123;</div><div class="line">        if (money &lt;= limit()) &#123;</div><div class="line">            handle(money);</div><div class="line">        &#125; else &#123;</div><div class="line">            if (nextHandler != null) &#123;</div><div class="line">                nextHandler.handleRequest(money);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 自身能批复的额度权限</div><div class="line">    protected abstract int limit();</div><div class="line">    // 处理报账行为</div><div class="line">    protected abstract void handle(int money);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 各个具体的领导者</div><div class="line">class GroupLeader extends Leader &#123;</div><div class="line">    @Override</div><div class="line">    protected int limit() &#123;</div><div class="line">        return 1000;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void handle(int money) &#123;</div><div class="line">        System.out.println(&quot;组长批复报销&quot; + money + &quot;元&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Director extends Leader &#123;</div><div class="line">    @Override</div><div class="line">    protected int limit() &#123;</div><div class="line">        return 5000;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void handle(int money) &#123;</div><div class="line">        System.out.println(&quot;主管批复报销&quot; + money + &quot;元&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Manager extends Leader &#123;</div><div class="line">    @Override</div><div class="line">    protected int limit() &#123;</div><div class="line">        return 10000;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void handle(int money) &#123;</div><div class="line">        System.out.println(&quot;经理批复报销&quot; + money + &quot;元&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Boss extends Leader &#123;</div><div class="line">    @Override</div><div class="line">    protected int limit() &#123;</div><div class="line">        return Integer.MAX_VALUE;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void handle(int money) &#123;</div><div class="line">        System.out.println(&quot;老板批复报销&quot; + money + &quot;元&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 客户类</div><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // 构造各个领导对象</div><div class="line">        GroupLeader groupLeader = new GroupLeader();</div><div class="line">        Director director = new Director();</div><div class="line">        Manager manager = new Manager();</div><div class="line">        Boss boss = new Boss();</div><div class="line">        // 设置上一级领导处理对象</div><div class="line">        groupLeader.nextHandler = director;</div><div class="line">        director.nextHandler = manager;</div><div class="line">        manager.nextHandler = boss;</div><div class="line">        // 发起报账请求</div><div class="line">        groupLeader.handleRequest(50000);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>责任链模式的灵活之处在于请求的发起可以从责任链的任何一个节点处开始，同时也可以改变责任链内部传递的规则。比如，直接越过组长找主管报账，或者直接将经理设置为组长的上一级节点。</p><h3 id="ANDROID-源码中的责任链模式实现"><a href="#ANDROID-源码中的责任链模式实现" class="headerlink" title="ANDROID 源码中的责任链模式实现"></a>ANDROID 源码中的责任链模式实现</h3><hr><p>责任链模式在 ANDROID 源码中比较类似的实现莫过于对事件的分发处理，每当用户接触屏幕时，ANDROID 都会将对应的事件包装成一个事件对象从 ViewTree 的顶部自上而下地分发传递。而 ViewGroup 中执行事件派发的方法是 dispatchTouchEvent，在该方法中其对事件进行了统一的分发。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div></pre></td><td class="code"><pre><div class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class="line">    if (mInputEventConsistencyVerifier != null) &#123;</div><div class="line">        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 对于辅助功能的事件处理</div><div class="line">    if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</div><div class="line">        ev.setTargetAccessibilityFocus(false);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    boolean handled = false;</div><div class="line">    if (onFilterTouchEventForSecurity(ev)) &#123;</div><div class="line">        final int action = ev.getAction();</div><div class="line">        final int actionMasked = action &amp; MotionEvent.ACTION_MASK;</div><div class="line"></div><div class="line">        // 处理原始的 DOWN 事件</div><div class="line">        if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">            // 这里主要是在新事件开始时处理完上一个事件</div><div class="line">            cancelAndClearTouchTargets(ev);</div><div class="line">            resetTouchState();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 检查事件拦截</div><div class="line">        final boolean intercepted;</div><div class="line">        if (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">                || mFirstTouchTarget != null) &#123;</div><div class="line">            final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</div><div class="line">            if (!disallowIntercept) &#123;</div><div class="line">                intercepted = onInterceptTouchEvent(ev);</div><div class="line">                ev.setAction(action); // 恢复事件防止其改变</div><div class="line">            &#125; else &#123;</div><div class="line">                intercepted = false;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            intercepted = true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 如果事件被拦截了，则进行正常的事件分发</div><div class="line">        if (intercepted || mFirstTouchTarget != null) &#123;</div><div class="line">            ev.setTargetAccessibilityFocus(false);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 检查事件是否取消</div><div class="line">        final boolean canceled = resetCancelNextUpFlag(this)</div><div class="line">                || actionMasked == MotionEvent.ACTION_CANCEL;</div><div class="line"></div><div class="line">        // 如果有必要的话，为 DOWN 事件检查所有的目标对象</div><div class="line">        final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;</div><div class="line">        TouchTarget newTouchTarget = null;</div><div class="line">        boolean alreadyDispatchedToNewTouchTarget = false;</div><div class="line">        // 如果事件未被取消且未被拦截</div><div class="line">        if (!canceled &amp;&amp; !intercepted) &#123;</div><div class="line">            // 如果有辅助功能的参与，则直接将事件投递到对应的 View</div><div class="line">            // 否则将事件分发给所有的子 View</div><div class="line">            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</div><div class="line">                    ? findChildWithAccessibilityFocus() : null;</div><div class="line">            // 如果事件为起始事件</div><div class="line">            if (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</div><div class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</div><div class="line">                final int actionIndex = ev.getActionIndex(); // always 0 for down</div><div class="line">                final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)</div><div class="line">                        : TouchTarget.ALL_POINTER_IDS;</div><div class="line"></div><div class="line">                removePointersFromTouchTargets(idBitsToAssign);</div><div class="line"></div><div class="line">                final int childrenCount = mChildrenCount;</div><div class="line">                // 如果 newTouchTarget 为空且子元素不为 0</div><div class="line">                if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123;</div><div class="line">                    final float x = ev.getX(actionIndex);</div><div class="line">                    final float y = ev.getY(actionIndex);</div><div class="line">                    // 自上而下去寻找一个可以接收该事件的子 View</div><div class="line">                    final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</div><div class="line">                    final boolean customOrder = preorderedList == null</div><div class="line">                            &amp;&amp; isChildrenDrawingOrderEnabled();</div><div class="line">                    final View[] children = mChildren;</div><div class="line">                    // 遍历子元素</div><div class="line">                    for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;</div><div class="line">                        final int childIndex = getAndVerifyPreorderedIndex(</div><div class="line">                                childrenCount, i, customOrder);</div><div class="line">                        final View child = getAndVerifyPreorderedView(</div><div class="line">                                preorderedList, children, childIndex);</div><div class="line"></div><div class="line">                        if (childWithAccessibilityFocus != null) &#123;</div><div class="line">                            if (childWithAccessibilityFocus != child) &#123;</div><div class="line">                                continue;</div><div class="line">                            &#125;</div><div class="line">                            childWithAccessibilityFocus = null;</div><div class="line">                            i = childrenCount - 1;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        // 如果子元素无法接收 PointerEvent 或这个事件点压根就没有</div><div class="line">                        // 落在子元素的边界范围内，那么就跳出该次循环继续遍历</div><div class="line">                        if (!canViewReceivePointerEvents(child)</div><div class="line">                                || !isTransformedTouchPointInView(x, y, child, null)) &#123;</div><div class="line">                            ev.setTargetAccessibilityFocus(false);</div><div class="line">                            continue;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        // 找到 Event 该由哪个子元素持有</div><div class="line">                        newTouchTarget = getTouchTarget(child);</div><div class="line">                        if (newTouchTarget != null) &#123;</div><div class="line">                            newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">                            break;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        resetCancelNextUpFlag(child);</div><div class="line">                        // 投递事件执行触摸操作</div><div class="line">                        // 如果子元素还是一个 ViewGroup，则递归调用重复此过程</div><div class="line">                        // 如果子元素是一个 View，那么会调用 View 的 dispatchTouchEvent，</div><div class="line">                        // 并最终由 onTouchEvent 处理</div><div class="line">                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</div><div class="line">                            // 子 View 在其边界范围内接收该事件</div><div class="line">                            mLastTouchDownTime = ev.getDownTime();</div><div class="line">                            if (preorderedList != null) &#123;</div><div class="line">                                for (int j = 0; j &lt; childrenCount; j++) &#123;</div><div class="line">                                    if (children[childIndex] == mChildren[j]) &#123;</div><div class="line">                                        mLastTouchDownIndex = j;</div><div class="line">                                        break;</div><div class="line">                                    &#125;</div><div class="line">                                &#125;</div><div class="line">                            &#125; else &#123;</div><div class="line">                                mLastTouchDownIndex = childIndex;</div><div class="line">                            &#125;</div><div class="line">                            mLastTouchDownX = ev.getX();</div><div class="line">                            mLastTouchDownY = ev.getY();</div><div class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">                            alreadyDispatchedToNewTouchTarget = true;</div><div class="line">                            break;</div><div class="line">                        &#125;</div><div class="line">                        ev.setTargetAccessibilityFocus(false);</div><div class="line">                    &#125;</div><div class="line">                    if (preorderedList != null) preorderedList.clear();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // 如果没有发现子元素可以持有该次事件</div><div class="line">                if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123;</div><div class="line">                    newTouchTarget = mFirstTouchTarget;</div><div class="line">                    while (newTouchTarget.next != null) &#123;</div><div class="line">                        newTouchTarget = newTouchTarget.next;</div><div class="line">                    &#125;</div><div class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mFirstTouchTarget == null) &#123;</div><div class="line">            // 重点：dispatchTransformedTouchEvent</div><div class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, null,</div><div class="line">                    TouchTarget.ALL_POINTER_IDS);</div><div class="line">        &#125; else &#123;</div><div class="line">            TouchTarget predecessor = null;</div><div class="line">            TouchTarget target = mFirstTouchTarget;</div><div class="line">            while (target != null) &#123;</div><div class="line">                final TouchTarget next = target.next;</div><div class="line">                if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</div><div class="line">                    handled = true;</div><div class="line">                &#125; else &#123;</div><div class="line">                    final boolean cancelChild = resetCancelNextUpFlag(target.child)</div><div class="line">                            || intercepted;</div><div class="line">                    // 重点：dispatchTransformedTouchEvent</div><div class="line">                    if (dispatchTransformedTouchEvent(ev, cancelChild,</div><div class="line">                            target.child, target.pointerIdBits)) &#123;</div><div class="line">                        handled = true;</div><div class="line">                    &#125;</div><div class="line">                    if (cancelChild) &#123;</div><div class="line">                        if (predecessor == null) &#123;</div><div class="line">                            mFirstTouchTarget = next;</div><div class="line">                        &#125; else &#123;</div><div class="line">                            predecessor.next = next;</div><div class="line">                        &#125;</div><div class="line">                        target.recycle();</div><div class="line">                        target = next;</div><div class="line">                        continue;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                predecessor = target;</div><div class="line">                target = next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">    </div><div class="line">    return handled;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里我们主要看看 dispatchTransformedTouchEvent 方法是如何调度子元素 dispatchTouchEvent 方法的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,</div><div class="line">                                              View child, int desiredPointerIdBits) &#123;</div><div class="line">    final boolean handled;</div><div class="line">    final int oldAction = event.getAction();</div><div class="line">    // 如果事件被取消</div><div class="line">    if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</div><div class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</div><div class="line">        // 如果没有子元素，则会调用父类的 dispatchTouchEvent。这里的父类终会为 View 类</div><div class="line">        if (child == null) &#123;</div><div class="line">            handled = super.dispatchTouchEvent(event);</div><div class="line">        &#125; else &#123;</div><div class="line">            // 如果有子元素则传递 cancel 事件</div><div class="line">            handled = child.dispatchTouchEvent(event);</div><div class="line">        &#125;</div><div class="line">        event.setAction(oldAction);</div><div class="line">        return handled;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 计算即将被传递的点的数量</div><div class="line">    final int oldPointerIdBits = event.getPointerIdBits();</div><div class="line">    final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</div><div class="line"></div><div class="line">    // 如果没有相应的点，那么就丢弃该事件</div><div class="line">    if (newPointerIdBits == 0) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 声明临时变量保存坐标转换后的 MotionEvent</div><div class="line">    final MotionEvent transformedEvent;</div><div class="line">    if (newPointerIdBits == oldPointerIdBits) &#123;</div><div class="line">        // 如果子元素为空或者有一个单位矩阵</div><div class="line">        if (child == null || child.hasIdentityMatrix()) &#123;</div><div class="line">            if (child == null) &#123;</div><div class="line">                // 为空则调用父类 dispatchTouchEvent</div><div class="line">                handled = super.dispatchTouchEvent(event);</div><div class="line">            &#125; else &#123;</div><div class="line">                // 否则尝试获取 xy 方向上的偏移量（如果通过 scrollTo 或 scrollBy</div><div class="line">                // 对子视图进行滚动的话）</div><div class="line">                final float offsetX = mScrollX - child.mLeft;</div><div class="line">                final float offsetY = mScrollY - child.mTop;</div><div class="line">                // 将 MotionEvent 进行坐标变换</div><div class="line">                event.offsetLocation(offsetX, offsetY);</div><div class="line">                // 再将变换后的 MotionEvent 传递给子元素</div><div class="line">                handled = child.dispatchTouchEvent(event);</div><div class="line">                // 复位 MotionEvent 以便以后再次使用</div><div class="line">                event.offsetLocation(-offsetX, -offsetY);</div><div class="line">            &#125;</div><div class="line">            // 如果通过以上的逻辑判断，当前事件被持有则可以直接返回</div><div class="line">            return handled;</div><div class="line">        &#125;</div><div class="line">        transformedEvent = MotionEvent.obtain(event);</div><div class="line">    &#125; else &#123;</div><div class="line">        transformedEvent = event.split(newPointerIdBits);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Perform any necessary transformations and dispatch.</div><div class="line">    if (child == null) &#123;</div><div class="line">        handled = super.dispatchTouchEvent(transformedEvent);</div><div class="line">    &#125; else &#123;</div><div class="line">        final float offsetX = mScrollX - child.mLeft;</div><div class="line">        final float offsetY = mScrollY - child.mTop;</div><div class="line">        transformedEvent.offsetLocation(offsetX, offsetY);</div><div class="line">        if (! child.hasIdentityMatrix()) &#123;</div><div class="line">            transformedEvent.transform(child.getInverseMatrix());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        handled = child.dispatchTouchEvent(transformedEvent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Done.</div><div class="line">    transformedEvent.recycle();</div><div class="line">    return handled;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ViewGroup 事件投递的递归调用就类似于一条责任链，一旦其寻找到责任者，那么将由责任者持有并消费掉该次事件，具体地体现在 View 的 onTouchEvent 方法中返回值的设置，如果 onTouchEvent 返回 false，那么意味着当前 View 不会是该次事件的责任人，将不会持有；如果为 true 则相反，此时 View 会持有该事件并不再向外传递。</p><h3 id="责任链模式实战"><a href="#责任链模式实战" class="headerlink" title="责任链模式实战"></a>责任链模式实战</h3><hr><p>ANDROID 中的 BroastCast 分为两种，一种是普通广播，另一种是有序广播。普通广播是异步的，发出时可以被所有的接收者收到。而有序广播是根据优先级依次传播的，直到有接收者将其终止或者所有接收者都不终止它。有序广播的这一特性与我们的责任链模式很相近，我们可以轻松地实现一种全局的责任链事件处理。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-9090a30349de4f66.gif?imageMogr2/auto-orient/strip" alt="1bba81880d9c47348a0ea7877326c4f5.gif"></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07 设计模式——状态模式</title>
      <link href="/1901/01/15/02%20DESIGN%20PATTERN/07%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
      <url>/1901/01/15/02%20DESIGN%20PATTERN/07%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d9469e2d08a0fddd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>状态模式：<strong>当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类</strong>。</p><p>状态模式中的行为是由状态来决定的，不同的状态下有不同的行为。状态模式和策略模式的结构几乎完全一样，但它们的目的、本质却完全不一样。状态模式的行为是平行的、不可替换的，策略模式的行为是彼此独立、可相互替换的。用一句话来表述，状态模式把对象的行为包装在不同状态对象里，每一个状态对象都有一个共同的抽象状态基类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为。</li><li>代码中包含大量与对象状态有关的条件语句，例如，一个操作中含有庞大的多分支语句（if-else 或 switch-case），且这些分支依赖于该对象的状态。</li></ul><p>状态模式将每一个条件分支放入一个独立的类中，这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化，这样通过多态来去除过多的、重复的 if-else 等分支语句。</p><h4 id="UML-关系图"><a href="#UML-关系图" class="headerlink" title="UML 关系图"></a>UML 关系图</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-050ce5696b445d29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图中的角色介绍：</p><ul><li>Context：环境类，定义客户端感兴趣的接口，维护一个 State 子类的实例，这个实例定义了对象当前状态。</li><li>State：抽象状态类或状态接口，定义一个或一组接口，表示该状态下的行为。</li><li>ConcreteStateA、ConcreteStateB：具体状态类，每个具体状态类实现抽象状态类中定义的接口，从而达到不同状态下的不同行为。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>以电视遥控器为例来演示一下状态模式的实现。我们先将电视的状态简单分为开机状态和关机状态，在开机状态下可以通过遥控器进行频道切换、调整音量等操作，但是，此时重复按开机键是无效的；而在关机状态下，频道切换、调整音量、关机都是无效的操作，只有按开机按钮时会生效。</p><h4 id="未使用状态模式"><a href="#未使用状态模式" class="headerlink" title="未使用状态模式"></a>未使用状态模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">// 电视遥控器,含有 开机,关机,下一个频道,上一个频道,调高音量,调低音量</div><div class="line">public class TVController &#123;</div><div class="line">    // 开机状态</div><div class="line">    private final static int POWER_ON = 1;</div><div class="line"></div><div class="line">    // 关机状态</div><div class="line">    private final static int POWER_OFF = 2;</div><div class="line"></div><div class="line">    private int state = POWER_OFF;</div><div class="line"></div><div class="line">    public void powerOn() &#123;</div><div class="line">        if (state == POWER_OFF) &#123;</div><div class="line">            System.out.println(&quot;开机啦&quot;);</div><div class="line">        &#125;</div><div class="line">        state = POWER_ON;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void powerOff() &#123;</div><div class="line">        if (state == POWER_ON) &#123;</div><div class="line">            System.out.println(&quot;关机啦&quot;);</div><div class="line">        &#125;</div><div class="line">        state = POWER_OFF;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void nextChannel() &#123;</div><div class="line">        if (state == POWER_ON) &#123;</div><div class="line">            System.out.println(&quot;下一个频道&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            System.out.println(&quot;两个红灯提示没有开机&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void prevChannel() &#123;</div><div class="line">        if (state == POWER_ON) &#123;</div><div class="line">            System.out.println(&quot;上一个频道&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            System.out.println(&quot;两个红灯提示没有开机&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void turnUp() &#123;</div><div class="line">        if (state == POWER_ON) &#123;</div><div class="line">            System.out.println(&quot;调高音量&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            System.out.println(&quot;两个红灯提示没有开机&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void turnDown() &#123;</div><div class="line">        if (state == POWER_ON) &#123;</div><div class="line">            System.out.println(&quot;调低音量&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            System.out.println(&quot;两个红灯提示没有开机&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，在 TVController 类中，通过 state 字段存储了电视的状态，并且在各个操作中根据状态来判断是否该执行。这就导致了在每个功能中都需要使用 if-else，代码重复、相对较为混乱，这是在只有两个状态和几个简单功能函数的情况下，那么当状态变成 5 个、功能函数变为 10 个呢？每个函数中都要用 if-else 进行判断，而这些代码都充斥在一个类中，这些重复的代码无法被提取出来，这使得这个类变得越来越难以维护。</p><h4 id="使用状态模式"><a href="#使用状态模式" class="headerlink" title="使用状态模式"></a>使用状态模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">// 电视状态接口，定义电视操作的函数</div><div class="line">public interface TvState &#123;</div><div class="line">    public void nextChannel();</div><div class="line">    public void prevChannel();</div><div class="line">    public void turnUp();</div><div class="line">    public void turnDown();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 关机状态，此时只有开机功能是有效的</div><div class="line">public class PowerOffStatus implements TvState&#123;</div><div class="line">    @Override</div><div class="line">    public void nextChannel() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void prevChannel() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void turnUp() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void turnDown() &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 开机状态，此时再按开机功能不能做任何操作</div><div class="line">public class PowerOnState implements TvState &#123;</div><div class="line">    @Override</div><div class="line">    public void nextChannel() &#123;</div><div class="line">        System.out.println(&quot;下一个频道&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void prevChannel() &#123;</div><div class="line">        System.out.println(&quot;上一个频道&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void turnUp() &#123;</div><div class="line">        System.out.println(&quot;声音调大&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void turnDown() &#123;</div><div class="line">        System.out.println(&quot;声音调小&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 电源操作接口</div><div class="line">public interface PowerController &#123;</div><div class="line">    public void powerOn();</div><div class="line">    public void powerOff();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 电视遥控器，类似于经典状态模式中的 Context</div><div class="line">public class TvController implements PowerController &#123;</div><div class="line">    TvState tvState;</div><div class="line"></div><div class="line">    public void setTvState(TvState tvState) &#123;</div><div class="line">        this.tvState = tvState;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void powerOn() &#123;</div><div class="line">        setTvState(new PowerOnState());</div><div class="line">        System.out.println(&quot;开机啦&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void powerOff() &#123;</div><div class="line">        setTvState(new PowerOffStatus());</div><div class="line">        System.out.println(&quot;关机啦&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void nextChannel()&#123;</div><div class="line">        tvState.nextChannel();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void prevChannel()&#123;</div><div class="line">        tvState.prevChannel();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void turnUp()&#123;</div><div class="line">        tvState.turnUp();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void turnDown()&#123;</div><div class="line">        tvState.turnDown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>客户端调用代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    TvController tvController = new TvController();</div><div class="line">    // 设置开机状态</div><div class="line">    tvController.powerOn();</div><div class="line">    // 下一个频道</div><div class="line">    tvController.nextChannel();</div><div class="line">    // 调高音量</div><div class="line">    tvController.turnUp();</div><div class="line">    // 设置关机状态</div><div class="line">    tvController.powerOff();</div><div class="line">    // 调低音量，此时不会生效</div><div class="line">    tvController.turnDown();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">开机啦</div><div class="line">下一个频道</div><div class="line">声音调大</div><div class="line">关机啦</div></pre></td></tr></table></figure></p><h3 id="状态模式实战"><a href="#状态模式实战" class="headerlink" title="状态模式实战"></a>状态模式实战</h3><hr><p>在开发过程中，我们用到状态模式最常见的地方应该是用户登录系统。在用户已登录和未登录的情况下，对于同一事件的处理行为是不一样的。例如，在新浪微博中，用户在未登录的情况下点击转发或评论按钮，此时会先让用户登录，然后再执行操作；如果是已登录的情况下，那么用户可以直接进行操作。</p><p>首先抽象出状态类，定义两个操作接口：转发和评论。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public interface UserState &#123;</div><div class="line">    /**</div><div class="line">     * 转发</div><div class="line">     */</div><div class="line">    public void forward(Context context);</div><div class="line">    /**</div><div class="line">     * 评论</div><div class="line">     */</div><div class="line">    public void comment(Context context);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后实现两个状态子类：已登录状态类、未登录状态类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 已登录状态</div><div class="line">public class LoggedState implements UserState &#123;</div><div class="line">    @Override</div><div class="line">    public void forward(Context context) &#123;</div><div class="line">        Toast.makeText(context, &quot;转发成功&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void comment(Context context) &#123;</div><div class="line">        Toast.makeText(context, &quot;评论成功&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 未登录状态</div><div class="line">public class LogoutState implements UserState &#123;</div><div class="line">    @Override</div><div class="line">    public void forward(Context context) &#123;</div><div class="line">        gotoLoginActivity(context);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void comment(Context context) &#123;</div><div class="line">        gotoLoginActivity(context);</div><div class="line">    &#125;</div><div class="line">    private void gotoLoginActivity(Context context) &#123;</div><div class="line">        Intent intent = new Intent(context, LoginActivity.class)</div><div class="line">        startActivity(context);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>最后实现 Context 角色，即用户的操作对象和状态管理对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class LoginContext &#123;</div><div class="line">    // 用户状态，默认为未登录状态</div><div class="line">    private UserState userState = new LogoutState();</div><div class="line">    // 单例</div><div class="line">    private static LoginContext loginContext = new LoginContext();</div><div class="line">    private LoginContext() &#123;&#125;</div><div class="line"></div><div class="line">    public LoginContext getLoginContext() &#123;</div><div class="line">        return loginContext;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setUserState(UserState userState) &#123;</div><div class="line">        this.userState = userState;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void forward(Context context) &#123;</div><div class="line">        userState.forward(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void comment(Context context) &#123;</div><div class="line">        userState.comment(context);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>客户端调用样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 转发微博</div><div class="line">LoginContext.getLoginContext().forward(MainActivity.this)</div><div class="line">// 分享微博</div><div class="line">LoginContext.getLoginContext().comment(MainActivity.this)</div><div class="line">// 登录成功后修改为已登录状态</div><div class="line">LoginContext.getLoginContext().setUserState(new LoggedState())</div><div class="line">// 注销登录，修改为未登录状态</div><div class="line">LoginContext.getLoginContext().setUserState(new LogoutState());</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-041d48853a87a313.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06 设计模式——策略模式</title>
      <link href="/1901/01/14/02%20DESIGN%20PATTERN/06%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/1901/01/14/02%20DESIGN%20PATTERN/06%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-6c52cc4855f03dc5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>策略模式：<strong>策略模式定义了一系列算法，并将每一个算法封装起来，而且使它们可以相互替换。策略模式让算法独立于使用它的客户端而独立变化</strong>。</p><p>在软件开发中常常遇到这样的情况：实现某一功能可以有多种算法或者策略，我们根据实际情况选择不同的算法或者策略来完成该功能。例如，排序算法，可以使用插入排序、归并排序、冒泡排序等。</p><p>针对这种情况，一种常规的方法是将多种算法写到一个类中。例如，需要提供多种排序算法，可以将这些算法写到一个类中，每一个方法对应一个具体的排序算法；当然，也可以将这些排序算法封装在一个统一的方法中，通过 if…else… 或者 case 等条件判断语句来选择具体的算法。这两种实现方法我们都可以称为硬编码。然而，当很多算法集中在一个类中时，这个类就会变得臃肿，维护成本会变高，在维护时也更容易引发错误。如果我们需要增加一种新的排序算法，需要修改封装算法类的源代码。这就明显违反了开闭原则和单一职责原则。</p><p>如果将这些算法或者策略抽象出来，提供一个统一的接口，不同的算法或者策略有不同的实现类，这样在程序客户端就可以通过注入不同的实现对象来实现算法或者策略的动态替换，这种模式的可扩展性、可维护性也就更高，也就是我们要说的<strong>策略模式</strong>。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>结构清晰明了、使用简单直观；</li><li>耦合度相对而言较低，扩展方便；</li><li>操作封装也更为彻底，数据更为安全。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>随着策略的增加，子类也会变得繁多。</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>针对同一类型问题的多种处理方式，仅仅是具体行为有差别时。</li><li>需要安全地封装多种同一类型的操作时。</li><li>出现同一抽象类有多个子类，而又需要使用 if-else 或者 switch-case 来选择具体子类时。</li></ul><h4 id="UML-关系图"><a href="#UML-关系图" class="headerlink" title="UML 关系图"></a>UML 关系图</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b576235c8d49057c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图中的角色介绍：</p><ul><li>Context：用来操作策略的上下文环境；</li><li>Strategy：策略的抽象；</li><li>ConcreteStrategyA、ConcreteStrategyB：具体的策略实现。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>下面我们以计算不同交通工具的车费来简单看看策略模式的实现。</p><h4 id="常规实现"><a href="#常规实现" class="headerlink" title="常规实现"></a>常规实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public class PriceCalculator &#123;</div><div class="line">    // 公交车类型</div><div class="line">    private static final int BUS = 1;</div><div class="line">    // 地铁类型</div><div class="line">    private static final int SUBWAY = 2;</div><div class="line"></div><div class="line">    public int calculatePrice(int km, int type) &#123;</div><div class="line">        if (type == BUS) &#123;</div><div class="line">            return busPrice(km);</div><div class="line">        &#125; else if (type == SUBWAY) &#123;</div><div class="line">            return subwayPrice(km);</div><div class="line">        &#125;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 十公里之内一元，超过十公里之后每加一元钱可以乘 5 公里</div><div class="line">     * @param km 公里数</div><div class="line">     * @return 公交车车费</div><div class="line">     */</div><div class="line">    private int busPrice(int km) &#123;</div><div class="line">        // 超过十公里的总距离</div><div class="line">        int extraTotal = km - 10;</div><div class="line">        // 超过的距离是 5 公里的倍数</div><div class="line">        int extraFactor = extraTotal / 5;</div><div class="line">        // 超过的距离对 5 公里取余</div><div class="line">        int fraction = extraTotal % 5;</div><div class="line">        // 价格计算</div><div class="line">        int price = 1 + extraFactor * 1 ;</div><div class="line">        return fraction &gt; 0 ? ++price : price;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 6 公里（含）内 3 元；6 ~ 12 公里（含）4 元；</div><div class="line">     * 12 ~ 22 公里（含）5元；22 ~ 32 公里（含）6元；</div><div class="line">     * @param km 公里数</div><div class="line">     * @return 地铁车费</div><div class="line">     */</div><div class="line">    private int subwayPrice(int km) &#123;</div><div class="line">        if (km &lt;= 6) &#123;</div><div class="line">            return 3;</div><div class="line">        &#125; else if (km &lt;= 12) &#123;</div><div class="line">            return 4;</div><div class="line">        &#125; else if (km &lt;= 22) &#123;</div><div class="line">            return 5;</div><div class="line">        &#125; else if (km &lt;= 32) &#123;</div><div class="line">            return 6;</div><div class="line">        &#125;</div><div class="line">        // 其他距离简化为 7 元</div><div class="line">        return 7;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PriceCalculator 类很明显地问题就是并不是单一职责，首先他承担了计算公交车和地铁乘坐价格的职责；另一个问题就是通过 if-else 的形式来判断使用哪种计算形式。当我们增加一种出行方式时，如出租车，那么我们就需要在 PriceCalculator 中增加一个方法来计算出租车出行的价格，并且再 calculatePrice(int km, int type) 函数中增加一个判断，代码添加后大致如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class PriceCalculator &#123;</div><div class="line">    // 公交车类型</div><div class="line">    private static final int BUS = 1;</div><div class="line">    // 地铁类型</div><div class="line">    private static final int SUBWAY = 2;</div><div class="line">    // 出租车类型</div><div class="line">    private static final int TEXI = 3;</div><div class="line"></div><div class="line">    public int calculatePrice(int km, int type) &#123;</div><div class="line">        if (type == BUS) &#123;</div><div class="line">            return busPrice(km);</div><div class="line">        &#125; else if (type == SUBWAY) &#123;</div><div class="line">            return subwayPrice(km);</div><div class="line">        &#125; else if (type == TEXI) &#123;</div><div class="line">            return taxiPrice(km);</div><div class="line">        &#125;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 简单计算为每公里 2 元钱</div><div class="line">     * @param km 公里数</div><div class="line">     * @return 出租车费</div><div class="line">     */</div><div class="line">    private int taxiPrice(int km) &#123;</div><div class="line">        return km * 2;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 其他代码</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>此时代码已经比较混乱，各种 if-else 缠绕其中。当价格的计算方法变化时，需要直接修改这个类中的代码，那么很可能有一段代码是其他几个计算方法所共同使用的，这就容易引入错误。另外，在增加出行方式时，需要手动修改，添加 if-else。这类代码必然是难以应对变化的，难以维护的。下面我们对上述示例用策略模式进行重构。</p><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>首先需要定义一个抽象的价格计算接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public interface CalculateStrategy &#123;</div><div class="line">    /**</div><div class="line">     * 按距离来计算价格</div><div class="line">     * @param km 公里数</div><div class="line">     * @return 价格</div><div class="line">     */</div><div class="line">    int calculatePrice(int km);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>对于每一种出行方式我们都有一个独立的计算策略类，这些策略类都实现了 CalculateStrategy 接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">// 公交车价格计算策略</div><div class="line">public class BusStrategy implements CalculateStrategy &#123;</div><div class="line">    /**</div><div class="line">     * 十公里之内一元，超过十公里之后每加一元钱可以乘 5 公里</div><div class="line">     * @param km 公里数</div><div class="line">     * @return 公交车车费</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public int calculatePrice(int km) &#123;</div><div class="line">        // 超过十公里的总距离</div><div class="line">        int extraTotal = km - 10;</div><div class="line">        // 超过的距离是 5 公里的倍数</div><div class="line">        int extraFactor = extraTotal / 5;</div><div class="line">        // 超过的距离对 5 公里取余</div><div class="line">        int fraction = extraTotal % 5;</div><div class="line">        // 价格计算</div><div class="line">        int price = 1 + extraFactor * 1 ;</div><div class="line">        return fraction &gt; 0 ? ++price : price;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 地铁价格计算策略</div><div class="line">public class SubwayStrategy implements CalculateStrategy &#123;</div><div class="line">    /**</div><div class="line">     * 6 公里（含）内 3 元；6 ~ 12 公里（含）4 元；</div><div class="line">     * 12 ~ 22 公里（含）5元；22 ~ 32 公里（含）6元；</div><div class="line">     * @param km 公里数</div><div class="line">     * @return 地铁车费</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public int calculatePrice(int km) &#123;</div><div class="line">        if (km &lt;= 6) &#123;</div><div class="line">            return 3;</div><div class="line">        &#125; else if (km &lt;= 12) &#123;</div><div class="line">            return 4;</div><div class="line">        &#125; else if (km &lt;= 22) &#123;</div><div class="line">            return 5;</div><div class="line">        &#125; else if (km &lt;= 32) &#123;</div><div class="line">            return 6;</div><div class="line">        &#125;</div><div class="line">        // 其他距离简化为 7 元</div><div class="line">        return 7;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>再创建一个扮演 Context 角色的类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class TrafficCalculator &#123;</div><div class="line">    private CalculateStrategy mStrategy;</div><div class="line"></div><div class="line">    public CalculateStrategy getStrategy() &#123;</div><div class="line">        return mStrategy;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setStrategy(CalculateStrategy strategy) &#123;</div><div class="line">        this.mStrategy = strategy;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        TrafficCalculator calculator = new TrafficCalculator();</div><div class="line">        calculator.setStrategy(new BusStrategy());</div><div class="line">        calculator.calculatePrice(16);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这种方案在隐藏实现的同时，可扩展性变得很强。例如，当我们需要增加出租车的计算策略时，只需要添加一个出租车计算策略类，然后将该策略设置给 TrafficCalculator。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 出租车价格计算策略</div><div class="line">public class TaxiStrategy implements CalculateStrategy &#123;</div><div class="line">    /**</div><div class="line">     * 简单计算为每公里 2 元钱</div><div class="line">     * @param km 公里数</div><div class="line">     * @return 出租车费</div><div class="line">     */</div><div class="line">    private int taxiPrice(int km) &#123;</div><div class="line">        return km * 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>将策略注入到 TrafficCalculator 中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">TrafficCalculator calculator = new TrafficCalculator();</div><div class="line">calculator.setmStrategy(new TaxiStrategy());</div><div class="line">calculator.calculatePrice(16);</div></pre></td></tr></table></figure></p><h3 id="模式在-ANDROID-中的应用"><a href="#模式在-ANDROID-中的应用" class="headerlink" title="模式在 ANDROID 中的应用"></a>模式在 ANDROID 中的应用</h3><hr><p>ANDROID 中属性动画的时间差值器有线性差值器、加速减速差值器等，这些差值器里面就用到了策略模式来隔离不同的动画速率计算算法。源码追踪关键方法依次为：</p><ul><li>View：<br>boolean draw(Canvas canvas, ViewGroup parent, long drawingTime)<br>private boolean applyLegacyAnimation(ViewGroup parent, long drawingTime, Animation a, boolean scalingRequired)</li><li>Animation：<br>public boolean getTransformation(long currentTime, Transformation outTransformation,float scale)<br>public boolean getTransformation(long currentTime, Transformation outTransformation)</li><li>Interpolator：<br>float getInterpolation(float input)</li></ul><p>插值器在属性动画中扮演了很重要的角色。它将动画的速率计算封装到一个抽象中，也就是 Interpolator 中，该接口只有一个 getInterpolation(float input) 方法，通过这个方法来修改动画的流逝时间比，依次达到动画的加速、减速等效果，结构如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-594f6a6d59530211.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>Interpolator 就是这个计算策略的抽象，LinearInterpolator、CycleInterpolator 等插值器就是具体的实现策略，通过注入不同的插值器实现不同的动态效果。</p><h3 id="策略模式实战"><a href="#策略模式实战" class="headerlink" title="策略模式实战"></a>策略模式实战</h3><hr><p>在我们加载图片项目 ImageLoader 中，加载请求会被封装成一个 Request 对象添加到请求队列中，ImageLoader 会为每个请求分配一个序列号，越晚加入的请求序列号值越大，默认情况下 ImageLoader 会按照先后顺序加载图片。但是现实中，我们可能需要最后添加到队列的请求先被执行。例如，在滚动 ListView 时，最后一项肯定是最晚被加载的，此时它却显示在屏幕上的，而其它优先被加载的请求却不在屏幕显示范围。当需求是在屏幕上显示的 Item View 的图片优先被加载，我们就需要 ImageLoader 支持从请求队列的尾部开始加载。也就是，这里至少需要两种策略。</p><p>依照策略模式，代码实现如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 加载策略接口</div><div class="line"> */</div><div class="line">public interface LoadPolicy &#123;</div><div class="line">    int compare(BitmapRequest request1, BitmapRequest request2);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 顺序加载策略</div><div class="line"> */</div><div class="line">public class SerialPolicy implements LoadPolicy &#123;</div><div class="line">    @Override</div><div class="line">    public int compare(BitmapRequest request1, BitmapRequest request2) &#123;</div><div class="line">        return request1.serialNum - request2.serialNum;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 逆序加载策略</div><div class="line"> */</div><div class="line">public class SerialPolicy implements LoadPolicy &#123;</div><div class="line">    @Override</div><div class="line">    public int compare(BitmapRequest request1, BitmapRequest request2) &#123;</div><div class="line">        return request2.serialNum - request1.serialNum;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class BitmapRequest implements Comparable&lt;BitmapRequest&gt; &#123;</div><div class="line">    // 加载策略，默认顺序加载策略</div><div class="line">    private LoadPolicy mLoadPolicy = new SerialPolicy();</div><div class="line"></div><div class="line">    public void setLoadPolicy(LoadPolicy loadPolicy) &#123;</div><div class="line">        this.mLoadPolicy = loadPolicy;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int compareTo(BitmapRequest another) &#123;</div><div class="line">        return mLoadPolicy.compare(this, another);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2132fdace67518c0.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05 设计模式——抽象工厂模式</title>
      <link href="/1901/01/13/02%20DESIGN%20PATTERN/05%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/1901/01/13/02%20DESIGN%20PATTERN/05%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-9ae895b8457fb7e0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>抽象工厂模式：<strong>为创建一组相关或者相互依赖的对象提供一个接口，而无需指定它们的具体类</strong>。</p><p>可以说是工厂方法模式的升级版，当需要创建的产品有多个产品线（产品族）时使用抽象工厂模式是比较好的选择。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。</li><li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。</li><li>增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。</li><li>开闭原则的倾斜性<br>1）增加产品族：对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。<br>2）增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。</li></ul><blockquote><p>正因为抽象工厂模式存在“开闭原则”的倾斜性，它以一种倾斜的方式来满足“开闭原则”，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。</p></blockquote><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>在以下情况下可以考虑使用抽象工厂模式：</p><ul><li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。</li><li>系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。</li><li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一制作水果蛋糕用的水果—草莓和芒果，草莓和芒果之间没有直接关系，但它们都是属于水果。</li><li>产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</li></ul><h4 id="UML关系图"><a href="#UML关系图" class="headerlink" title="UML关系图"></a>UML关系图</h4><p><img src="https://upload-images.jianshu.io/upload_images/5733856-9e2f3e0a0a90ca9f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt=""></p><p>抽象工厂模式中有如下角色：</p><ul><li>AbstractFactory：抽象工厂，它声明了用来创建不同产品的方法。</li><li>ConcreteFactory：具体工厂，实现抽象工厂中定义的创建产品的方法。</li><li>AbstractProduct：抽象产品，为每种产品声明业务方法。比如上图的AbstractProductA和 AbstractProductB。</li><li>ConcreteProduct：具体产品，定义具体工厂生产的具体产品，并实现抽象产品中定义的业务方法。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>联想和惠普生产的电脑分为了两个产品线，一个台式机，一个是笔记本。为了解决增加产品线的问题，我们用抽象工厂模式来进行实现。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7a0c61e51d5048f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p><strong>抽象产品</strong><br>两个抽象产品类分别为 DesktopComputer 和 NotebookComputer ，用来定义两个产品线：台式机和笔记本。它们都定义了start方法，用来启动电脑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public abstract class DesktopComputer &#123;</div><div class="line">  public abstract void start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public abstract class NotebookComputer &#123;</div><div class="line">   public abstract void start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p><strong>具体产品</strong><br>具体产品为联想和惠普旗下的台式机和笔记本，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class LenovoDesktopComputer extends DesktopComputer &#123;</div><div class="line">    @Override</div><div class="line">    public void start() &#123;</div><div class="line">        System.out.println(&quot;联想台式电脑启动&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class HpDesktopComputer extends DesktopComputer &#123;</div><div class="line">    @Override</div><div class="line">    public void start() &#123;</div><div class="line">        System.out.println(&quot;惠普台式电脑启动&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class LenovoNotebookComputer extends NotebookComputer &#123;</div><div class="line">    @Override</div><div class="line">    public void start() &#123;</div><div class="line">        System.out.println(&quot;联想笔记本电脑启动&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class HpNotebookComputer extends NotebookComputer &#123;</div><div class="line">    @Override</div><div class="line">    public void start() &#123;</div><div class="line">        System.out.println(&quot;惠普笔记本电脑启动&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p><strong>抽象工厂</strong><br>定义了两个方法，分别用来生产台式电脑和笔记本电脑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public abstract class ComputerFactory &#123;</div><div class="line">    public abstract DesktopComputer createDesktopComputer();</div><div class="line">    public abstract NotebookComputer createNotebookComputer();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p><strong>具体工厂</strong><br>联想工厂和惠普工厂用来生产台式机和笔记本这两个不同产品线的电脑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class LenovoFactory extends ComputerFactory &#123;</div><div class="line">    @Override</div><div class="line">    public DesktopComputer createDesktopComputer() &#123;</div><div class="line">        return new LenovoDesktopComputer();</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public NotebookComputer createNotebookComputer() &#123;</div><div class="line">        return new LenovoNotebookComputer();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class HpFactory extends ComputerFactory &#123;</div><div class="line">    @Override</div><div class="line">    public DesktopComputer createDesktopComputer() &#123;</div><div class="line">        return new HpDesktopComputer();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public NotebookComputer createNotebookComputer() &#123;</div><div class="line">        return new HpNotebookComputer();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>客户端调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[]args) &#123;</div><div class="line">        ComputerFactory lenocoFactory = new LenovoFactory();</div><div class="line">        lenocoFactory.createDesktopComputer().start();</div><div class="line">        lenocoFactory.createNotebookComputer().start();</div><div class="line">        ComputerFactory hpFactory = new HpFactory();</div><div class="line">        hpFactory.createDesktopComputer().start();</div><div class="line">        hpFactory.createNotebookComputer().start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="模式在-ANDROID-中的应用"><a href="#模式在-ANDROID-中的应用" class="headerlink" title="模式在 ANDROID 中的应用"></a>模式在 ANDROID 中的应用</h3><hr><p>对于 ANDROID 来说，抽象工厂的一个更好的应用是在主题修改上。比如我们的应用中有两套主题，分别为亮色主题 LightTheme 和 暗色主题 DarkTheme。这两种主题我们可以通过一个抽象的类或接口来定义，而在对应主题下我们又有各类不同的 UI 元素，比如 Button、TextView、Dialog、ActionBar 等，这些 UI 元素都会分别对应不同的主题，这些 UI 元素我们也可以通过抽象的类或接口，抽象的主题、具体的主题、抽象的 UI 元素和具体的 UI 元素之间的关系就是抽象工厂模式最好的体现。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-701a3c0b435c4aa9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>代码略…</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-355d9b278f91a7f1.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04 设计模式——工厂方法模式</title>
      <link href="/1901/01/12/02%20DESIGN%20PATTERN/04%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/1901/01/12/02%20DESIGN%20PATTERN/04%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-070871023762dcac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>工厂方法模式：<strong>定义一个用于创建对象的接口，让子类决定实例化哪个类</strong>。</p><p>工厂方法模式（FACTORY METHOD）是一种常用的类创建型设计模式，此模式的核心精神是封装类中变化的部分，提取其中个性化善变的部分为独立类，通过依赖注入以达到解耦、复用和方便后期维护拓展的目的。在任何需要生成复杂对象的地方，都可以使用工厂方法模式。复杂对象适合使用工厂模式，用 new 就可以完成创建的对象无需使用工厂模式。</p><p>它的核心结构有四个角色，分别是抽象工厂、具体工厂、抽象产品、具体产品。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-057281a7dd7e2590.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>通用模式代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">// 抽象产品类</div><div class="line">public abstract class Product &#123;</div><div class="line">    /**</div><div class="line">     * 产品类的抽象方法，由具体的产品类去实现</div><div class="line">     */</div><div class="line">    public abstract void method();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 具体产品类 A</div><div class="line">public class ConcreteProductA extends Product &#123;</div><div class="line">    @Override</div><div class="line">    public void method() &#123;</div><div class="line">        System.out.println(&quot;产品 A&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体产品类 B</div><div class="line">public class ConcreteProductB extends Product &#123;</div><div class="line">    @Override</div><div class="line">    public void method() &#123;</div><div class="line">        System.out.println(&quot;产品 B&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 抽象工厂类</div><div class="line">public abstract class Factory &#123;</div><div class="line">    /**</div><div class="line">     * 抽象工厂方法，具体由子类去实现</div><div class="line">     * @return 具体的产品类型</div><div class="line">     */</div><div class="line">    public abstract Product createProduct();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 具体工厂类</div><div class="line">public class ConcreteFactory extends Factory &#123;</div><div class="line">    @Override</div><div class="line">    public Product createProduct() &#123;</div><div class="line">        return new ConcreteProductA();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Factory factory = new ConcreteFactory();</div><div class="line">Product p = factory.createProduct();</div><div class="line">p.method();</div></pre></td></tr></table></figure></p><p>这里我们得到的产品对象时 ConcreteProductA 的实例，如果想得到 ConcreteProductB 的实例，更改 ConcreteFactory 中的逻辑即可；或者是新建一个 Factory 的具体实现子类，专门生产 ConcreteProductB 的实例。当然，我们也可以利用反射的方式来简化操作。具体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public abstract class Factory &#123;</div><div class="line">    /**</div><div class="line">     * @param clz 产品对象类型</div><div class="line">     * @return 具体的产品类型</div><div class="line">     */</div><div class="line">    public abstract &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; clz);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ConcreteFactory extends Factory &#123;</div><div class="line">    @Override</div><div class="line">    public &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; clz) &#123;</div><div class="line">        Product p = null;</div><div class="line">        try &#123;</div><div class="line">            p = (Product) Class.forName(clz.getName()).newInstance();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return (T) p;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Factory factory = new ConcreteFactory();</div><div class="line">Product productA = factory.createProduct(ConcreteProductA.class);</div><div class="line">Product productB = factory.createProduct(ConcreteProductB.class);</div><div class="line">productA.method();</div><div class="line">productB.method();</div></pre></td></tr></table></figure></p><p>当我们的工厂只有一个的时候，可以简化掉抽象工厂类，并提供一个静态方法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Factory &#123;</div><div class="line">    public static Product createProduct() &#123;</div><div class="line">        return new ConcreteProductA();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>工厂方法模式是完全符合设计原则的，其降低了对象之间的耦合度。而且，工厂方法模式依赖于抽象的架构，其将实例化的任务交由子类去完成，有非常好的扩展性。</p><h3 id="ANDROID-源码中的工厂方法模式"><a href="#ANDROID-源码中的工厂方法模式" class="headerlink" title="ANDROID 源码中的工厂方法模式"></a>ANDROID 源码中的工厂方法模式</h3><hr><p>大家平时开发中经常会使用到的数据结构中其实也隐藏着对工厂方法模式的应用，以 List 和 Set 为例，List 和 Set 继承自 Collection 接口，而 Collection 接口继承于 Iterable 接口，Iterable 接口很简单，就一个 iterator 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Iterable&lt;T&gt; &#123;</div><div class="line">    Iterator&lt;T&gt; iterator();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这意味着 List 和 Set 接口也会继承该方法，平时比较常用的两个间接实现类 ArrayList 和 HashSet 中的 iterator 方法的实现就是构造并返回一个迭代器对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements Cloneable, </div><div class="line">        Serializable, RandomAccess &#123;</div><div class="line"></div><div class="line">    @Override </div><div class="line">    public Iterator&lt;E&gt; iterator() &#123;</div><div class="line">        return new ArrayListIterator();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class ArrayListIterator implements Iterator&lt;E&gt; &#123;</div><div class="line">        /** Number of elements remaining in this iteration */</div><div class="line">        private int remaining = size;</div><div class="line"></div><div class="line">        /** Index of element that remove() would remove, or -1 if no such elt */</div><div class="line">        private int removalIndex = -1;</div><div class="line"></div><div class="line">        /** The expected modCount value */</div><div class="line">        private int expectedModCount = modCount;</div><div class="line"></div><div class="line">        public boolean hasNext() &#123;</div><div class="line">            return remaining != 0;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123;</div><div class="line">            ArrayList&lt;E&gt; ourList = ArrayList.this;</div><div class="line">            int rem = remaining;</div><div class="line">            if (ourList.modCount != expectedModCount) &#123;</div><div class="line">                throw new ConcurrentModificationException();</div><div class="line">            &#125;</div><div class="line">            if (rem == 0) &#123;</div><div class="line">                throw new NoSuchElementException();</div><div class="line">            &#125;</div><div class="line">            remaining = rem - 1;</div><div class="line">            return (E) ourList.array[removalIndex = ourList.size - rem];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void remove() &#123;</div><div class="line">            Object[] a = array;</div><div class="line">            int removalIdx = removalIndex;</div><div class="line">            if (modCount != expectedModCount) &#123;</div><div class="line">                throw new ConcurrentModificationException();</div><div class="line">            &#125;</div><div class="line">            if (removalIdx &lt; 0) &#123;</div><div class="line">                throw new IllegalStateException();</div><div class="line">            &#125;</div><div class="line">            System.arraycopy(a, removalIdx + 1, a, removalIdx, remaining);</div><div class="line">            a[--size] = null;  // Prevent memory leak</div><div class="line">            removalIndex = -1;</div><div class="line">            expectedModCount = ++modCount;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ArrayList 中的 iterator 方法其实就相当于一个工厂方法，专为 new 对象而生，这里的 iterator 方法是构造并返回一个具体的迭代器。再看看下面的对应关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Iterator ————&gt; Product;       ArrayListIteratorr ————&gt; ConcreteProduct。</div><div class="line">Iterable/List ————&gt; Factory;  ArrayList ————&gt; ConcreteFactory。</div></pre></td></tr></table></figure></p><p>当然，Java 源码中对工厂方法的应用范例也不少，大家可以自己查看 Set 的源码。ANDROID 中对工厂方法模式的应用更多，读者其实第一次接触 ANDROID 时就已经遇到了但未察觉到，相信以下代码对一个 ANDROID 新手来说都不陌生。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class TestActivity extends Activity &#123;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(new LinearLayout(this));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里构造一个线性布局 LinearLayout 对象并设置为当前 Activity 的根布局，这段代码看似再平常不过了，实质上，onCreate 方法就相当于一个工厂方法，为什么呢？因为我们知道 LinearLayout 是一个 ViewGroup，而 ViewGroup 又继承于 View，简单地说就是，所有控件都是 View 的子类，上面的代码中，我们在 TestActivity 的 onCreate 方法中构造一个 View 对象，并设置为当前界面的 ContentView 返回给 framework 处理，如果现在又有一个 LoginActivity，这时我们又在其 onCreate 方法中通过 setContentView 方法设置另外不同的 View，这是不是就是一个工厂模式的结构呢？其实设计模式离我们非常近。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-97a4eb1aa1ae8528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="示例：数据持久化"><a href="#示例：数据持久化" class="headerlink" title="示例：数据持久化"></a>示例：数据持久化</h3><hr><p>ANDROID 中数据持久化为我们提供了 SharePreference、 SQLite 和普通的文件存储等方式。但是对数据的操作都是增删改查，可以把这些共同的操作抽象出来作为抽象产品类，然后每一种持久化方法作为具体产品。</p><p>抽象产品中定义操作的方法，即增删改查。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public abstract class AbstractIoHandler &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 添加个人信息</div><div class="line">     *</div><div class="line">     * @param id 身份证号码</div><div class="line">     * @param name 姓名</div><div class="line">     */</div><div class="line">    public abstract void add(String id, String name);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 根据ID删除一条信息</div><div class="line">     *</div><div class="line">     * @param id 身份证</div><div class="line">     */</div><div class="line">    public abstract void remove(String id);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 更新个人信息</div><div class="line">     *</div><div class="line">     * @param id 身份证</div><div class="line">     * @param name 姓名</div><div class="line">     */</div><div class="line">    public abstract void update(String id, String name);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 查询ID对应的信息</div><div class="line">     *</div><div class="line">     * @param id 身份证</div><div class="line">     * @return 人名</div><div class="line">     */</div><div class="line">    public abstract String query(String id);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>具体的产品，持久化的类型，比如利用文件来持久化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class FileHandler extends AbstractIoHandler &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void add(String id, String name)&#123;</div><div class="line">        // 业务处理</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void remove(String id) &#123;</div><div class="line">        // 业务处理</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void update(String id, String name) &#123;</div><div class="line">        // 业务处理</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String query(String id) &#123;</div><div class="line">        return &quot;&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后是我们的工厂方法，这里仍然采用反射的方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class IoFactory &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取IoHandler</div><div class="line">     *</div><div class="line">     * @param clz AbstractIoHandler类型的类</div><div class="line">     * @return AbstractIoHandler对象</div><div class="line">     */</div><div class="line">    public static &lt;T extends AbstractIoHandler&gt; T getIoHandler(Class&lt;T&gt; clz) &#123;</div><div class="line">        AbstractIoHandler handler = null;</div><div class="line">        try &#123;</div><div class="line">            handler = (AbstractIoHandler) Class.forName(clz.getName()).newInstance();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return (T) handler;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在需要进行数据持久化的地方调用工厂方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">AbstractIoHandler ioHandler = IoFactory.getIoHandler(FileHandler.class);</div><div class="line">System.out.println(ioHandler.query(&quot;123456&quot;));</div></pre></td></tr></table></figure></p><p>这里的例子简化了很多，还有数据库 SQLite 以及 SharePreference 的持久化的类就没有写了。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1e51fc5cb0167d71.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03 设计模式——原型模式</title>
      <link href="/1901/01/11/02%20DESIGN%20PATTERN/03%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/1901/01/11/02%20DESIGN%20PATTERN/03%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a64c95041609bda8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>原型模式：<strong>用原型实例指定创建对象的种类，并通过复制这些原型创建新的对象</strong>。</p><p>原型模式是一个创建型的模式。该模式应该有一个样板实例，用户从这个样板对象中复制出一个内部属性一致的对象，这个过程也就是我们俗称的“克隆”。被复制的实例就是我们所称的“原型”，这个原型是可定制的。原型模式多用于创建复杂的或者构造耗时的实例，因为这种情况下，复制一个已经存在的实例可使程序运行更高效。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>类初始化需要消耗非常多的资源，这个资源包括数据、硬件资源等，通过原型复制避免这些消耗。</li><li>通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，这时可以使用原型模式。</li><li>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式复制多个对象供调用者使用，即保护性拷贝。</li></ul><blockquote><p>需要注意的是，通过实现 Cloneable 接口的原型模式在调用 clone 函数构造实例时并不一定比通过 new 操作速度快，只有当通过 new 构造对象较为耗时或者成本高时，通过 clone 方法才能够获得效率上的提升。因此，在使用 Cloneable 接口时需要考虑构建对象的成本以及做一些效率上的测试。当然，实现原型模式不一定非要实现 Cloneable 接口，也有其他的实现方式，见后文。</p></blockquote><h4 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0f7404098cf4ccf9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>Client：客户端用户。</li><li>Prototype：抽象类或者接口，声明具备 clone 能力。</li><li>ConcretePrototype：具体的原型类。</li></ul><h3 id="示例：文档拷贝"><a href="#示例：文档拷贝" class="headerlink" title="示例：文档拷贝"></a>示例：文档拷贝</h3><hr><p>在这个例子中，首先创建了一个文档对象，即 WordDocument，这个文档中含有文字和图片。用户经过了长时间的编辑后，打算对该文档做进一步的编辑。但是，这个编辑后的文档是否会被采用还不确定。因此，为了安全起见，用户需要将当前文档拷贝一份，然后再在文档副本上进行修改。如此，这个原始文档就是我们上述所说的样板实例，也就是将要被“克隆”的对象，我们称为“原型”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public class WordDocument implements Cloneable &#123;</div><div class="line">    // 文本</div><div class="line">    private String text;</div><div class="line">    // 图片</div><div class="line">    private ArrayList&lt;String&gt; images = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    public WordDocument() &#123;</div><div class="line">        System.out.println(&quot;---WordDocument 构造函数---&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected WordDocument clone() &#123;</div><div class="line">        try &#123;</div><div class="line">            WordDocument document = (WordDocument) super.clone();</div><div class="line">            document.text = this.text;</div><div class="line">            document.images = this.images;</div><div class="line">            return document;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getText() &#123;</div><div class="line">        return text;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setText(String text) &#123;</div><div class="line">        this.text = text;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ArrayList&lt;String&gt; getImages() &#123;</div><div class="line">        return images;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void addImage(String img) &#123;</div><div class="line">        images.add(img);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 打印文档内容</div><div class="line">     */</div><div class="line">    public void showDocument() &#123;</div><div class="line">        System.out.println(&quot;---Word content start---&quot;);</div><div class="line">        System.out.println(&quot;Text : &quot; + text);</div><div class="line">        System.out.println(&quot;images list : &quot;);</div><div class="line">        for (String name : images) &#123;</div><div class="line">            System.out.println(&quot;image name : &quot; + name);</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;---Word content end---&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通过 WordDocument 类模拟了 Word 文档中的基本元素，即文字和图片。WordDocument 在该原型模式示例中扮演的角色为 ConcretePrototype，而 Cloneable 的角色则为 Prototype。WordDocument 中的 clone 方法用以实现对象克隆。注意，<strong>这个方法并不是 Cloneable 接口的，而是 Object 中的方法</strong>。Cloneable 也是一个标识接口，它表明这个类的对象是可拷贝的。如果没有实现 Cloneable 接口却调用了 clone() 函数将抛出异常。在这个示例中，我们通过实现 Cloneable 接口和覆写 clone 方法实现原型模式。</p><p>下面看看 Client 端的调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">WordDocument originDoc = new WordDocument();</div><div class="line">originDoc.setText(&quot;这是一篇文档&quot;);</div><div class="line">originDoc.addImage(&quot;图片1&quot;);</div><div class="line">originDoc.addImage(&quot;图片2&quot;);</div><div class="line">originDoc.addImage(&quot;图片3&quot;);</div><div class="line">originDoc.showDocument();</div><div class="line"></div><div class="line">WordDocument doc2 = originDoc.clone();</div><div class="line">doc2.showDocument();</div><div class="line"></div><div class="line">doc2.setText(&quot;这是修改过的文档&quot;);</div><div class="line">doc2.addImage(&quot;图片4&quot;);</div><div class="line">doc2.showDocument();</div><div class="line"></div><div class="line">originDoc.showDocument();</div></pre></td></tr></table></figure></p><p>输出结果如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">---WordDocument 构造函数---</div><div class="line">---Word content start---</div><div class="line">Text : 这是一篇文档</div><div class="line">images list : </div><div class="line">image name : 图片1</div><div class="line">image name : 图片2</div><div class="line">image name : 图片3</div><div class="line">---Word content end---</div><div class="line">---Word content start---</div><div class="line">Text : 这是一篇文档</div><div class="line">images list : </div><div class="line">image name : 图片1</div><div class="line">image name : 图片2</div><div class="line">image name : 图片3</div><div class="line">---Word content end---</div><div class="line">---Word content start---</div><div class="line">Text : 这是修改过的文档</div><div class="line">images list : </div><div class="line">image name : 图片1</div><div class="line">image name : 图片2</div><div class="line">image name : 图片3</div><div class="line">image name : 图片4</div><div class="line">---Word content end---</div><div class="line">---Word content start---</div><div class="line">Text : 这是一篇文档</div><div class="line">images list : </div><div class="line">image name : 图片1</div><div class="line">image name : 图片2</div><div class="line">image name : 图片3</div><div class="line">image name : 图片4</div><div class="line">---Word content end---</div></pre></td></tr></table></figure></p><p>从上面可以看到，doc2 是通过 originDoc.clone() 创建的，并且 doc2 第一次输出的时候和 originDoc 输出是一样的，即 doc2 是 originDoc 的一份拷贝，它们的内容是一样的，而 doc2 修改了文本内容以后并不影响 originDoc 的文本内容，这就保证了 originDoc 的安全性。还需要注意的是，通过 clone 拷贝对象时并不会执行构造函数。</p><p>但是，originDoc 的图片列表内容（images）被更改了，这是为什么呢？因为上述示例只是一个<strong>浅拷贝</strong>。</p><h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><hr><ul><li>浅拷贝又叫影子拷贝，上面我们在拷贝文档时并没有把原文档中的字段都重新构造了一遍，而只是拷贝了引用，也就是副文档的字段引用原始文档的字段，这样的话修改副文档中的内容就会连原始文档也改掉了，这就是浅拷贝。</li><li>深拷贝就是在浅拷贝的基础上，对于引用类型的字段也要采用拷贝的形式，比如上面的 images，而像 String、int 这些基本数据类型则没关系</li></ul><p>所以在运用原型模式时建议大家还是用深拷贝。下面我们把上面的浅拷贝改成深拷贝，clone 方法修改如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected WordDocument clone() &#123;</div><div class="line">    try &#123;</div><div class="line">        WordDocument document = (WordDocument) super.clone();</div><div class="line">        document.text = this.text;</div><div class="line">        // document.images = this.images;</div><div class="line">        // 对 images 对象也调用 clone() 函数，进行深拷贝</div><div class="line">        document.images = (ArrayList&lt;String&gt;) this.images.clone();</div><div class="line">        return document;</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="ANDROID-源码中的原型模式"><a href="#ANDROID-源码中的原型模式" class="headerlink" title="ANDROID 源码中的原型模式"></a>ANDROID 源码中的原型模式</h3><hr><p>在 Android 中，Intent 可能是我们最早接触的几个类型之一，它用于跳转 Activity、启动服务、发布广播等功能，它是 Android 系统各组件之间的纽带，也是组件之间传递数据的载体，正式 Intent 的存在才使得 Android 各个组件之间的耦合性很低，Android 的组件才如此灵活。</p><p>下面以 Intent 来分析源码中的原型模式，首先看如下示例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Uri uri = Uri.parse(&quot;smsto:0800000123&quot;);</div><div class="line">Intent shareIntent = new Intent(Intent.ACTION_SENDTO, uri);</div><div class="line">shareIntent.putExtra(&quot;sms_body&quot;, &quot;The SMS text&quot;);</div><div class="line">// 克隆副本</div><div class="line">Intent intent = (Intent) shareIntent.clone();</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p><p>通过 shareIntent.clone 方法拷贝了一个对象 Intent，然后执行 startActivity(intent)，随即就进入了短信页面，号码为 0800000123，文本内容为 The SMS text，即这些内容都与 shareIntent 一致。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-35fea9630edfbef6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>我们看看 Intent 的 clone() 方法是如何实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public class Intent implements Parcelable, Cloneable &#123;</div><div class="line">    @Override</div><div class="line">    public Object clone() &#123;</div><div class="line">        return new Intent(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Copy constructor.</div><div class="line">     */</div><div class="line">    public Intent(Intent o) &#123;</div><div class="line">        this(o, COPY_MODE_ALL);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Intent(Intent o, @CopyMode int copyMode) &#123;</div><div class="line">        this.mAction = o.mAction;</div><div class="line">        this.mData = o.mData;</div><div class="line">        this.mType = o.mType;</div><div class="line">        this.mPackage = o.mPackage;</div><div class="line">        this.mComponent = o.mComponent;</div><div class="line"></div><div class="line">        if (o.mCategories != null) &#123;</div><div class="line">            this.mCategories = new ArraySet&lt;&gt;(o.mCategories);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (copyMode != COPY_MODE_FILTER) &#123;</div><div class="line">            this.mFlags = o.mFlags;</div><div class="line">            this.mContentUserHint = o.mContentUserHint;</div><div class="line">            this.mLaunchToken = o.mLaunchToken;</div><div class="line">            if (o.mSourceBounds != null) &#123;</div><div class="line">                this.mSourceBounds = new Rect(o.mSourceBounds);</div><div class="line">            &#125;</div><div class="line">            if (o.mSelector != null) &#123;</div><div class="line">                this.mSelector = new Intent(o.mSelector);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (copyMode != COPY_MODE_HISTORY) &#123;</div><div class="line">                if (o.mExtras != null) &#123;</div><div class="line">                    this.mExtras = new Bundle(o.mExtras);</div><div class="line">                &#125;</div><div class="line">                if (o.mClipData != null) &#123;</div><div class="line">                    this.mClipData = new ClipData(o.mClipData);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                if (o.mExtras != null &amp;&amp; !o.mExtras.maybeIsEmpty()) &#123;</div><div class="line">                    this.mExtras = Bundle.STRIPPED;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 代码省略</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>clone 方法并没有调用 super.clone() 来实现对象拷贝，而是调用了 new Intent(this)。在上文中我们提到过，使用 clone 和 new 需要根据构造对象的成本来决定。如果对象的构造成本比较高或者构造较为麻烦，那么使用 clone() 函数效率较高，否则可以使用 new 的形式。</p><h3 id="原型模式实战"><a href="#原型模式实战" class="headerlink" title="原型模式实战"></a>原型模式实战</h3><hr><p>在开发中，我们有时候会满足一些需求，就是有的对象的内容只允许客户端程序读取，而不允许修改，比如用户登录信息。我们通常会用 LoginSession 保存用户的登录信息，这些用户信息可能在 APP 的其他模块被用来做登录校验、用户个人信息显示等。但是，这些信息在客户端程序是不允许修改的。此时，就需要使用原型模式来进行保护性拷贝。表现形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">// 用户实体类</div><div class="line">public class User implements Cloneable &#123;</div><div class="line">    private int age;</div><div class="line">    private String name;</div><div class="line">    private String phoneNum;</div><div class="line">    private Address address;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected Object clone() &#123;</div><div class="line">        User user = null;</div><div class="line">        try &#123;</div><div class="line">            user = (User) super.clone();</div><div class="line">            // 深拷贝</div><div class="line">            user.address = (Address) this.address.clone();</div><div class="line">        &#125; catch (CloneNotSupportedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return user;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // setter &amp; getter</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 用户地址类</div><div class="line">public class Address implements Cloneable &#123;</div><div class="line">    private String city;</div><div class="line">    private String district;</div><div class="line">    private String street;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected Object clone() &#123;</div><div class="line">        Address address = new Address();</div><div class="line">        address.city = this.city;</div><div class="line">        address.district = this.district;</div><div class="line">        address.street = this.street;</div><div class="line"></div><div class="line">        return address;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // setter &amp; getter</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 登录接口</div><div class="line">public interface ILogin &#123;</div><div class="line">    void login();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 登录实现</div><div class="line">public class LoginImpl implements ILogin &#123;</div><div class="line">    @Override</div><div class="line">    public void login() &#123;</div><div class="line">        User loggedUser = new User();</div><div class="line"></div><div class="line">        // 获取用户信息</div><div class="line">        // ...</div><div class="line"></div><div class="line">        // 成功登录后，将用户信息保存到 Session 中</div><div class="line">        LoginSession.getInstance().setLoggedUser(loggedUser);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 登录 Session</div><div class="line">public class LoginSession &#123;</div><div class="line">    // 已登录用户信息</div><div class="line">    private User loggedUser;</div><div class="line"></div><div class="line">    private LoginSession() &#123;&#125;</div><div class="line">    private static class LoginSessionHolder &#123;</div><div class="line">        private static final LoginSession sLoginSession = new LoginSession();</div><div class="line">    &#125;</div><div class="line">    public static LoginSession getInstance() &#123;</div><div class="line">        return LoginSessionHolder.sLoginSession;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 设置已登录的用户信息，不对外开放</div><div class="line">    void setLoggedUser(User user) &#123;</div><div class="line">        loggedUser = user;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public User getLoggedUser() &#123;</div><div class="line">        if (null == loggedUser) return null;</div><div class="line">        return (User)loggedUser.clone();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这就使得在任何地方调用 getLoggedUser 函数获取到的用户对象都是一个拷贝对象，即使客户端代码一不小心修改了这个拷贝对象，也不会影响最初的已登录用户对象，对已登录用户信息的修改只能通过 setLoggedUser 这个方法，而只有与 LoginSession 在同一个包下的类才能访问这个包级私有方法。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-20967628ed253ab5.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02 设计模式——建造者模式</title>
      <link href="/1901/01/10/02%20DESIGN%20PATTERN/02%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/1901/01/10/02%20DESIGN%20PATTERN/02%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e67e5b988e0da65f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>建造者模式：<strong>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</strong>。</p><p>Builder 模式是一步一步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更精细地控制对象的构造流程。该模式是为了将构建复杂对象的过程和它的部件解耦，使得构建过程和部件的表示隔离开来。</p><p>因为一个负责对象有大量组成部分，如汽车有车轮、方向盘、发动机、车盘，还有各种小零件，如何将这些部件装配成一辆汽车，这个装配过程很漫长，也很复杂，对于这种情况，为了在构建过程中对外部隐藏实现细节，就可以使用 Builder 模式将部件和组装过程分离，使得构建过程和部件都可以自由扩展，两者之间的耦合也降到最低。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>相同的方法，不同的执行顺序，产生不同的事件结果时。</li><li>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时。</li><li>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的作用，这个时候使用建造者模式非常合适。</li><li>当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值时。</li></ul><h4 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-3ce7e4cc79db97a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从上图可以看到，经典 Buider 模式中有四个角色：</p><ul><li>Product 产品类 —— 产品的抽象类；</li><li>Builder —— 抽象 Builder 类，规范产品的组建，一般是由子类实现具体的组建过程；</li><li>ConcreteBuilder —— 具体的 Builder 类；</li><li>Director —— 统一组装过程。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>计算机的组装过程较为复杂，并且组装顺序是不固定的，为了易于理解，我们把计算机组装的过程简化为构建主机、设置操作系统、设置显示器 3 个部分，然后通过 Director 和具体的 Builder 来构建计算机对象。请看下面示例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">// 计算机抽象类，即 Product 角色</div><div class="line">public abstract class Computer &#123;</div><div class="line">    protected String mBoard;</div><div class="line">    protected String mDisplay;</div><div class="line">    protected String mOS;</div><div class="line"></div><div class="line">    protected Computer() &#123;&#125;</div><div class="line"></div><div class="line">    public void setBoard(String board) &#123;</div><div class="line">        this.mBoard = board;</div><div class="line">    &#125;</div><div class="line">    public void setDisplay(String display) &#123;</div><div class="line">        this.mDisplay = display;</div><div class="line">    &#125;</div><div class="line">    public abstract void setOS();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;Computer [&quot; + &quot;mBoard=&apos;&quot; + mBoard + &apos;\&apos;&apos; +</div><div class="line">                &quot;, mDisplay=&apos;&quot; + mDisplay + &apos;\&apos;&apos; + &quot;, mOS=&apos;&quot; + mOS + &apos;]&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体的 Computer 类，Macbook</div><div class="line">public class Macbook extends Computer &#123;</div><div class="line">    protected Macbook() &#123;&#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void setOS() &#123;</div><div class="line">        mOS = &quot;Mac OS X 10.10&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽象 Builder 类</div><div class="line">public abstract class Builder &#123;</div><div class="line">    public abstract void buildBoard(String board);</div><div class="line">    public abstract void buildDisplay(String display);</div><div class="line">    public abstract void buildOS();</div><div class="line">    public abstract Computer create();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体的 Builder 类，MacbookBuilder</div><div class="line">public class MacbookBuilder extends Builder &#123;</div><div class="line">    private Computer mComputer = new Macbook();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildBoard(String board) &#123;</div><div class="line">        mComputer.setBoard(board);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void buildDisplay(String display) &#123;</div><div class="line">        mComputer.setDisplay(display);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void buildOS() &#123;</div><div class="line">        mComputer.setOS();</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public Computer create() &#123;</div><div class="line">        return mComputer;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Director 类，负责构造 Computer</div><div class="line">public class Director &#123;</div><div class="line">    Builder mBuilder = null;</div><div class="line"></div><div class="line">    public Director(Builder builder) &#123;</div><div class="line">        this.mBuilder = builder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void construct(String board, String display) &#123;</div><div class="line">        mBuilder.buildBoard(board);</div><div class="line">        mBuilder.buildDisplay(display);</div><div class="line">        mBuilder.buildOS();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试代码</div><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Builder builder = new MacbookBuilder();</div><div class="line">        Director pcDirector = new Director(builder);</div><div class="line">        pcDirector.construct(&quot;英特尔主板&quot;, &quot;Retina 显示器&quot;);</div><div class="line">        System.out.println(&quot;Computer Info : &quot; + builder.create().toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>输出结果：</p><blockquote><p>Computer Info : Computer [mBoard=英特尔主板, mDisplay=Retina 显示器, mOS=Mac OS X 10.10]</p></blockquote><p>上述示例中，通过具体的 MacbookBuilder 来构建 Macbook 对象，而 Director 封装了构建复杂产品对象的过程，对外隐藏构建细节。Builder 与 Director 一起将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的对象。</p><p>值得注意的是，在现实开发过程当中，Director 角色经常会被省略。而直接使用一个 Builder 来进行对象的组装，这个 Builder 通常为链式调用，它的关键点是每个 setter 方法都返回自身，也就是 return this，这样就使得 setter 方法可以链式调用，代码大致如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new TestBuilder().setA(&quot;A&quot;).setB(&quot;B&quot;).create();</div></pre></td></tr></table></figure></p><p>通过这种形式不仅去除了 Director 角色，整个结构也更加简单，也能对 Product 对象的组装过程有更精细的控制。</p><h3 id="ANDROID-源码中的-Builder-模式"><a href="#ANDROID-源码中的-Builder-模式" class="headerlink" title="ANDROID 源码中的 Builder 模式"></a>ANDROID 源码中的 Builder 模式</h3><hr><p>在 ANDROID 源码中，最常用到的 Builder 模式就是 AlertDialog.Builder，使用该 Builder 来构建复杂的 AlertDialog 对象。在开发过程中，我们经常用到 AlertDialog，具体示例如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">private void showDialog(final Context context) &#123;</div><div class="line">    AlertDialog.Builder builder = new AlertDialog.Builder(context);</div><div class="line">    builder.setIcon(R.drawable.taiji)</div><div class="line">            .setTitle(&quot;Title&quot;)</div><div class="line">            .setMessage(&quot;Message&quot;)</div><div class="line">            .setPositiveButton(&quot;Button1&quot;, new DialogInterface.OnClickListener() &#123;</div><div class="line">                @Override</div><div class="line">                public void onClick(DialogInterface dialog, int which) &#123;</div><div class="line">                    Toast.makeText(context, &quot;Button1&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">            .setNeutralButton(&quot;Button2&quot;, new DialogInterface.OnClickListener() &#123;</div><div class="line">                @Override</div><div class="line">                public void onClick(DialogInterface dialog, int which) &#123;</div><div class="line">                    Toast.makeText(context, &quot;Button2&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">            .setNegativeButton(&quot;Button3&quot;, new DialogInterface.OnClickListener() &#123;</div><div class="line">                @Override</div><div class="line">                public void onClick(DialogInterface dialog, int which) &#123;</div><div class="line">                    Toast.makeText(context, &quot;Button3&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">            .create()</div><div class="line">            .show();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>显示结果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-aada48ecfbd9eca5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从类名就可以看出这就是一个 Builder 模式，通过 Builder 对象来组装 Dialog 的各个部分，如 title、buttons、message 等，将 Dialog 的构造和表示进行分离。下面看看 AlertDialog 的相关源码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">public class AlertDialog extends AppCompatDialog implements DialogInterface &#123;</div><div class="line">    // AlertController 接收 Builder 成员变量 p 中的各个参数</div><div class="line">    final AlertController mAlert;</div><div class="line"></div><div class="line">    protected AlertDialog(@NonNull Context context, @StyleRes int themeResId) &#123;</div><div class="line">        super(context, resolveDialogTheme(context, themeResId));</div><div class="line">        // 构造 AlertController</div><div class="line">        mAlert = new AlertController(getContext(), this, getWindow());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void setTitle(CharSequence title) &#123;</div><div class="line">        super.setTitle(title);</div><div class="line">        mAlert.setTitle(title);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setMessage(CharSequence message) &#123;</div><div class="line">        mAlert.setMessage(message);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 代码省略</div><div class="line"></div><div class="line">    public static class Builder &#123;</div><div class="line">        // 1、存储 AlertDialog 的各个参数，如 title、message、icon 等</div><div class="line">        private final AlertController.AlertParams P;</div><div class="line">        private final int mTheme;</div><div class="line"></div><div class="line">        public Builder(@NonNull Context context) &#123;</div><div class="line">            this(context, resolveDialogTheme(context, 0));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public Builder(@NonNull Context context, @StyleRes int themeResId) &#123;</div><div class="line">            P = new AlertController.AlertParams(new ContextThemeWrapper(</div><div class="line">                    context, resolveDialogTheme(context, themeResId)));</div><div class="line">            mTheme = themeResId;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 代码省略</div><div class="line"></div><div class="line">        // 2、设置各种参数</div><div class="line">        public Builder setTitle(@Nullable CharSequence title) &#123;</div><div class="line">            P.mTitle = title;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        public Builder setMessage(@StringRes int messageId) &#123;</div><div class="line">            P.mMessage = P.mContext.getText(messageId);</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        public Builder setView(View view) &#123;</div><div class="line">            P.mView = view;</div><div class="line">            P.mViewLayoutResId = 0;</div><div class="line">            P.mViewSpacingSpecified = false;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 3、构建 AlertDialog，传递参数</div><div class="line">        public AlertDialog create() &#123;</div><div class="line">            // 4、调用 new AlertDialog 构造对象，并且将参数传递给个体 AlertDialog</div><div class="line">            final AlertDialog dialog = new AlertDialog(P.mContext, mTheme);</div><div class="line">            // 5、将 P 中的参数应用到 dialog 中的 mAlert 对象中</div><div class="line">            P.apply(dialog.mAlert);</div><div class="line">            dialog.setCancelable(P.mCancelable);</div><div class="line">            if (P.mCancelable) &#123;</div><div class="line">                dialog.setCanceledOnTouchOutside(true);</div><div class="line">            &#125;</div><div class="line">            dialog.setOnCancelListener(P.mOnCancelListener);</div><div class="line">            dialog.setOnDismissListener(P.mOnDismissListener);</div><div class="line">            if (P.mOnKeyListener != null) &#123;</div><div class="line">                dialog.setOnKeyListener(P.mOnKeyListener);</div><div class="line">            &#125;</div><div class="line">            return dialog;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上述代码中，Builder 类可以设置 AlertDialog 中的 title、message、button 等参数，这些参数都存储在类型为 AlertController.AlertParams 的成员变量 P 中，AlertController.AlertParams 中包含了与 AlertDialog 视图中对应的成员变量。在调用 Builder 类的 create 函数时会创建 AlertDialog，并且将 Builder 成员变量 P 中保存的参数应用到 AlertDialog 的 mAlert 对象中，即 P.apply(dialog.mAlert) 代码段。我们再看看 apply 函数的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public void apply(AlertController dialog) &#123;</div><div class="line">    if (mCustomTitleView != null) &#123;</div><div class="line">        dialog.setCustomTitle(mCustomTitleView);</div><div class="line">    &#125; else &#123;</div><div class="line">        if (mTitle != null) &#123;</div><div class="line">            dialog.setTitle(mTitle);</div><div class="line">        &#125;</div><div class="line">        if (mIcon != null) &#123;</div><div class="line">            dialog.setIcon(mIcon);</div><div class="line">        &#125;</div><div class="line">        if (mIconId != 0) &#123;</div><div class="line">            dialog.setIcon(mIconId);</div><div class="line">        &#125;</div><div class="line">        if (mIconAttrId != 0) &#123;</div><div class="line">            dialog.setIcon(dialog.getIconAttributeResId(mIconAttrId));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (mMessage != null) &#123;</div><div class="line">        dialog.setMessage(mMessage);</div><div class="line">    &#125;</div><div class="line">    if (mPositiveButtonText != null || mPositiveButtonIcon != null) &#123;</div><div class="line">        dialog.setButton(DialogInterface.BUTTON_POSITIVE, mPositiveButtonText,</div><div class="line">                mPositiveButtonListener, null, mPositiveButtonIcon);</div><div class="line">    &#125;</div><div class="line">    if (mNegativeButtonText != null || mNegativeButtonIcon != null) &#123;</div><div class="line">        dialog.setButton(DialogInterface.BUTTON_NEGATIVE, mNegativeButtonText,</div><div class="line">                mNegativeButtonListener, null, mNegativeButtonIcon);</div><div class="line">    &#125;</div><div class="line">    if (mNeutralButtonText != null || mNeutralButtonIcon != null) &#123;</div><div class="line">        dialog.setButton(DialogInterface.BUTTON_NEUTRAL, mNeutralButtonText,</div><div class="line">                mNeutralButtonListener, null, mNeutralButtonIcon);</div><div class="line">    &#125;</div><div class="line">    // For a list, the client can either supply an array of items or an</div><div class="line">    // adapter or a cursor</div><div class="line">    if ((mItems != null) || (mCursor != null) || (mAdapter != null)) &#123;</div><div class="line">        createListView(dialog);</div><div class="line">    &#125;</div><div class="line">    if (mView != null) &#123;</div><div class="line">        if (mViewSpacingSpecified) &#123;</div><div class="line">            dialog.setView(mView, mViewSpacingLeft, mViewSpacingTop, </div><div class="line">                    mViewSpacingRight, mViewSpacingBottom);</div><div class="line">        &#125; else &#123;</div><div class="line">            dialog.setView(mView);</div><div class="line">        &#125;</div><div class="line">    &#125; else if (mViewLayoutResId != 0) &#123;</div><div class="line">        dialog.setView(mViewLayoutResId);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 apply 函数中，只是将 AlertParams 参数设置到 AlertController 中，例如，将标题设置到 Dialog 对应的标题视图中，将 Message 设置到内容视图中等。当我们获取到 AlertDialog 对象后，通过 show 函数就可以显示这个对话框。而 show 函数最终调用的是 Dialog 类的 show 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class Dialog implements DialogInterface, Window.Callback,</div><div class="line">        KeyEvent.Callback, OnCreateContextMenuListener, </div><div class="line">        Window.OnWindowDismissedCallback &#123;</div><div class="line">    </div><div class="line">    // 代码省略</div><div class="line">    </div><div class="line">    public void show() &#123;</div><div class="line">        // 已经是显示状态，则return</div><div class="line">        if (mShowing) &#123;</div><div class="line">            if (mDecor != null) &#123;</div><div class="line">                if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123;</div><div class="line">                    mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);</div><div class="line">                &#125;</div><div class="line">                mDecor.setVisibility(View.VISIBLE);</div><div class="line">            &#125;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mCanceled = false;</div><div class="line"></div><div class="line">        // 1、onCreate 调用</div><div class="line">        if (!mCreated) &#123;</div><div class="line">            dispatchOnCreate(null);</div><div class="line">        &#125;</div><div class="line">        // 2、onStart</div><div class="line">        onStart();</div><div class="line">        // 3、获取 DecorView</div><div class="line">        mDecor = mWindow.getDecorView();</div><div class="line"></div><div class="line">        // 代码省略</div><div class="line"></div><div class="line">        // 4、获取布局参数</div><div class="line">        WindowManager.LayoutParams l = mWindow.getAttributes();</div><div class="line"></div><div class="line">        // 5、将 mDecor 添加到 WindowManager 中</div><div class="line">        mWindowManager.addView(mDecor, l);</div><div class="line">        mShowing = true;</div><div class="line">        // 发送一个显示 Dialog 的消息</div><div class="line">        sendShowMessage();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 show 函数中主要做了如下几个事情：</p><ul><li>通过 dispatchOnCreate 函数来调用 AlertDialog 的 onCreate 函数；</li><li>然后调用 AlertDialog 的 onStart 函数；</li><li>最后将 Dialog 的 DecorView 添加到 WindowManager 中。</li></ul><blockquote><p>这里的 AlertDialog.Builder 同时扮演了上文中提到的 Builder、ConcreteBuilder、Director 的角色，简化了 Builder 模式的设计。当模块比较稳定，不存在一些变化时，可以在经典模式实现的基础上做出一些精简，而不是照搬 GOF 上的经典实现，更不要生搬硬套，使程序失去架构之美。</p></blockquote><h3 id="Builder-模式实战"><a href="#Builder-模式实战" class="headerlink" title="Builder 模式实战"></a>Builder 模式实战</h3><hr><p>配置 ImageLoader 的参数：缓存、图片加载中显示的图片、加载失败后显示的图片、图片加载策略、线程数等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line">    // 图片加载配置对象</div><div class="line">    private ImageLoaderConfig mConfig;</div><div class="line">    </div><div class="line">    // 省略单例模式代码</div><div class="line">    </div><div class="line">    // 初始化 ImageLoader</div><div class="line">    public void init(ImageLoaderConfig config) &#123;</div><div class="line">        mConfig = config;</div><div class="line">        // 检测配置的合法性，内部会根据配置做一些初始化操作</div><div class="line">        checkConfig();</div><div class="line">        // 代码省略</div><div class="line">    &#125;</div><div class="line">    // 代码省略</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>把配置的代码基本上都封装到了 ImageLoaderConfig 和 Builder 对象中。其代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">public class ImageLoaderConfig &#123;</div><div class="line">    // 图片缓存配置</div><div class="line">    private BitmapCache bitmapCache = new MemoryCache();</div><div class="line">    // 加载图片时的 loading 和加载失败的图片配置对象</div><div class="line">    private DisplayConfig displayConfig = new DisplayConfig();</div><div class="line">    // 加载策略</div><div class="line">    private LoadPolicy loadPolicy = new SerialPolicy();</div><div class="line">    // 线程数量，默认为 CPU 数量 + 1</div><div class="line">    private int threadCount = Runtime.getRuntime().availableProcessors() + 1;</div><div class="line"></div><div class="line">    private ImageLoaderConfig() &#123;&#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 配置类的 Builder</div><div class="line">     */</div><div class="line">    public static class Builder &#123;</div><div class="line">        BitmapCache bitmapCache = new MemoryCache();</div><div class="line">        DisplayConfig displayConfig = new DisplayConfig();</div><div class="line">        LoadPolicy loadPolicy = new SerialPolicy();</div><div class="line">        int threadCount = Runtime.getRuntime().availableProcessors() + 1;</div><div class="line"></div><div class="line">        public Builder setThreadCount(int threadCount) &#123;</div><div class="line">            this.threadCount = threadCount;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        public Builder setCache(BitmapCache bitmapCache) &#123;</div><div class="line">            this.bitmapCache = bitmapCache;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        public Builder setLoadingPlaceholder(int resId) &#123;</div><div class="line">            displayConfig.loadingResId = resId;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        public Builder setNotFoundPlaceholder(int resId) &#123;</div><div class="line">            displayConfig.failedResId = resId;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public Builder setLoadPolicy(LoadPolicy loadPolicy) &#123;</div><div class="line">            if (loadPolicy != null) &#123;</div><div class="line">                loadPolicy = loadPolicy;</div><div class="line">            &#125;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        void applyConfig(ImageLoaderConfig config) &#123;</div><div class="line">            config.bitmapCache = this.bitmapCache;</div><div class="line">            config.displayConfig = this.displayConfig;</div><div class="line">            config.loadPolicy = this.loadPolicy;</div><div class="line">            config.threadCount = this.threadCount;</div><div class="line">        &#125;</div><div class="line">        // 根据已经设置好的属性创建配置对象</div><div class="line">        public ImageLoaderConfig create() &#123;</div><div class="line">            ImageLoaderConfig config = new ImageLoaderConfig();</div><div class="line">            applyConfig(config);</div><div class="line">            return config;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通过将 ImageLoaderConfig 的构造函数、字段私有化，使得外部不能访问内部属性，用户唯一能够设置属性的地方就是通过 Builder 对象了，也就是说用户只能通过 Builder 对象构造 ImageLoaderConfig 对象，这就是构建和表示相分离。</p><p>用户的使用代码如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private void initImageLoader() &#123;</div><div class="line">    ImageLoaderConfig config = new ImageLoaderConfig.Builder()</div><div class="line">            .setLoadingPlaceholder(R.drawable.loading)</div><div class="line">            .setNotFoundPlaceholder(R.drawable.not_found)</div><div class="line">            .setCache(new DoubleCache(this))</div><div class="line">            .setThreadCount(4)</div><div class="line">            .setLoadPolicy(new ReversePolicy()).create();</div><div class="line">    ImageLoader.getInstance().init(config);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-34aef10a605bcc48.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01 设计模式——单例模式</title>
      <link href="/1901/01/09/02%20DESIGN%20PATTERN/01%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/1901/01/09/02%20DESIGN%20PATTERN/01%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-43484e39b5984f6c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>单例模式：<strong>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例</strong>。</p><p>确保某个类有且只有一个对象的场景，避免产生多个对象消耗过多的资源，或者某种类型的对象只应该有且只有一个。例如，创建一个对象需要消耗的资源过多，如要访问 IO 和数据库等资源，这是就要考虑使用单例模式。</p><p>实现单例模式主要有如下几个关键点：</p><blockquote><ul><li>构造函数不对外开放，一般为 private；</li><li>通过一个静态方法或者枚举返回单例类对象；</li><li>确保单例类的对象有且只有一个，尤其是在多线程环境下；</li><li>确保单例类对象在反序列化时不会重新构建对象。</li></ul><p>单例对象如果持有 Context，那么很容易引发内存泄漏，此时需要注意传递给单例对象的 Context 最好是 Application Context。</p></blockquote><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p>在一个应用中，应该只有一个 ImageLoader 实例，这个 ImageLoader 中又含有线程池、缓存系统、网络请求等，很消耗资源。因此，没有理由让它构造多个实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line">    private static ImageLoader sInstance = new ImageLoader();</div><div class="line">    private ImageLoader() &#123;&#125;</div><div class="line">    public static ImageLoader getInstance() &#123;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上述写法又被称为<strong>饿汉式单例模式</strong>，在声明静态对象时就已经初始化，符合前面三条关键点，但在反序列化的情况下它们会重新创建对象。</p><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>我们知道通过序列化可以将一个单例的实例对象写到磁盘，然后再读回来，从而有效地获得一个实例。即使构造函数是私有的，反序列化时依然可以通过特殊的途径去创建类的一个新的实例，相当于调用该类的构造函数。反序列化操作提供了一个很特别的钩子函数，类中具有一个私有的 readResolve() 函数，这个函数可以让开发人员控制对象的反序列化。例如，如果要杜绝上述示例中的单例对象在反序列化时重新生成对象，那么必须加入 readResolve 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader implements Serializable &#123;</div><div class="line">    private static final long serialVersionUID = 0L;</div><div class="line">    private static ImageLoader sInstance = new ImageLoader();</div><div class="line">    </div><div class="line">    private ImageLoader() &#123;&#125;</div><div class="line">    </div><div class="line">    public static ImageLoader getInstance() &#123;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Object readResolve() throws ObjectStreamException &#123;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>也就是在 readResolve 方法中将单例对象返回，而不是重新生成一个新的对象。而对于枚举类，并不存在这个问题，因为即使反序列化它也不会重新生成新的实例。另外有两点需要注意：</p><ul><li>可序列化类中的字段类型不是 Java 的内置类型，那么该字段类型也需要实现 Serializable 接口；</li><li>如果调整了可序列化类的内部结构，例如新增、去除某个字段，但没有修改 serialVersionUID，那么会引发 java.io.InvalidClassException 异常或者导致某个属性为 0 或者 null。此时最好的方案是我们直接将 serialVersionUID 设置为 0L，这样即使修改了类的内部结构，我们反序列化不会抛出该异常，只是那些新修改的字段会为 0 或者 null。</li></ul><h3 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h3><hr><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><p>懒汉模式是声明一个静态变量，并且在用户第一次调用 getInstance 时进行初始化，而上述的恶汉模式是在声明静态对象时就已经初始化。实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line">    private static ImageLoader sInstance;</div><div class="line">    private ImageLoader() &#123;&#125;</div><div class="line"></div><div class="line">    public static ImageLoader getInstance() &#123;</div><div class="line">        if (sInstance == null) &#123;</div><div class="line">            sInstance = new ImageLoader();</div><div class="line">        &#125;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这种模式不能保证在多线程环境下确保单例类的对象有且只有一个，所以我们会添加 synchronized 关键字进行同步。但若是将 synchronized 添加到 getInstance 函数上，会出现每次调用该方法都进行同步的情况，造成不必要的同步开销。代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line">    private static ImageLoader sInstance;</div><div class="line">    private ImageLoader() &#123;&#125;</div><div class="line"></div><div class="line">    public static synchronized ImageLoader getInstance() &#123;</div><div class="line">        if (sInstance == null) &#123;</div><div class="line">            sInstance = new ImageLoader();</div><div class="line">        &#125;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>上述方式不建议使用，但在它的基础上添加双重检查锁定机制（Double Check Lock，DCL）进行优化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line">    private static ImageLoader sInstance;</div><div class="line">    private ImageLoader() &#123;&#125;</div><div class="line"></div><div class="line">    public static ImageLoader getInstance() &#123;</div><div class="line">        if (sInstance == null) &#123;</div><div class="line">            synchronized (ImageLoader.class) &#123;</div><div class="line">                if (sInstance == null) &#123;</div><div class="line">                    sInstance = new ImageLoader();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样一来，DCL 解决了资源消耗、多余同步、线程安全等问题，似乎很完美，但笔者也不推荐这种写法。它还是会在某种情况下出现失效的问题，这个问题被称为双重检查锁定失效，在《Java 并发编程实践》一书的最后谈到了这个问题，并指出这种“优化”是丑陋的，不赞成使用。</p><h4 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h4><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line">    private ImageLoader() &#123;&#125;</div><div class="line">    public static ImageLoader getInstance() &#123;</div><div class="line">        return ImageLoaderHolder.sInstance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 静态内部类</div><div class="line">    private static class ImageLoaderHolder &#123;</div><div class="line">        private static final ImageLoader sInstance = new ImageLoader();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当第一次加载 ImageLoader 类时并不会初始化 sInstance，只有在第一次调用 ImageLoader 的 getInstance 方法时才会导致 sInstance 被初始化。因此，第一次调用 getInstance 方法会导致虚拟机加载 ImageLoaderHolder 类，这种方式不仅能确保线程安全，也能够保证单例对象的唯一性，同时也延迟了单例的实例化，所以这是推荐使用的单例模式实现方式。如果有反序列化的情况下，要加入 readResolve 方法，具体代码参考饿汉式反序列章节。</p><h4 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h4><p>前面讲解的单例模式实现方式不是稍显麻烦就是会在某些情况下出现问题，还有没有更简单的实现方式呢？我们看看下面的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public enum SingletonEnum &#123;</div><div class="line">    INSTANCE;</div><div class="line">    public void doSomething() &#123;</div><div class="line">        System.out.println(&quot;do sth.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>写法简单，而且保证线程安全、序列化与反序列化安全、反射安全。奈何 ANDROID 官方不建议使用 Enums，因为占用内存多（Enums often require more than twice as much memory as static constants.）。<a href="https://www.liaohuqiu.net/cn/posts/android-enum-memory-usage/" target="_blank" rel="external">关于 Enum 的使用博客</a>。</p><h4 id="使用容器实现单例模式"><a href="#使用容器实现单例模式" class="headerlink" title="使用容器实现单例模式"></a>使用容器实现单例模式</h4><p>具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class SingletonManager &#123;</div><div class="line">    private static Map&lt;String, Object&gt; objMap = new HashMap&lt;&gt;();</div><div class="line">    </div><div class="line">    private SingletonManager() &#123;&#125;</div><div class="line">    </div><div class="line">    public static void registerService(String key, Object instance) &#123;</div><div class="line">        if (!objMap.containsKey(key)) &#123;</div><div class="line">            objMap.put(key, instance);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static Object getService(String key) &#123;</div><div class="line">        return objMap.get(key);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在程序的初始，将多种单例类型注入到一个统一的管理类中，在使用时根据 key 获取对象对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合。</p><h3 id="ANDROID-源码中的单例模式"><a href="#ANDROID-源码中的单例模式" class="headerlink" title="ANDROID 源码中的单例模式"></a>ANDROID 源码中的单例模式</h3><hr><p>在 ANDROID 系统中，我们经常会通过 Context 获取系统级别的服务，如 WindowsManagerService、ActivityManagerService 等，更常用的是一个 LayoutInflater 的类。这些服务会在合适的时候以单例的形式注册在系统中，在我们需要的时候就通过 Context 的 getSystemService(String name) 获取。我们以 LayoutInflater 为例来说明，平时我们使用 LayoutInflater 较为常见的地方是在 ListView 的 getView 方法中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void getView(int position, View convertView, ViewGroup parent) &#123;</div><div class="line">    View itemView = null;</div><div class="line">    if (convertView == null) &#123;</div><div class="line">        itemView = LayoutInflater.from(mContext).inflate(mLayoutId, null);</div><div class="line">        ...</div><div class="line">    &#125; else &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通常我们使用 LayoutInflater.from(Context) 来获取 LayoutInflater 服务，下面看看 LayoutInflater.from(Context) 的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static LayoutInflater from(Context context) &#123;</div><div class="line">    LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(</div><div class="line">            Context.LAYOUT_INFLATER_SERVICE);</div><div class="line">    if (LayoutInflater == null) &#123;</div><div class="line">        throw new AssertionError(&quot;LayoutInflater not found.&quot;);</div><div class="line">    &#125;</div><div class="line">    return LayoutInflater;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看到 from(Context) 函数内部调用的是 Context 类的 getSystemService(String key) 方法，我们跟踪到 Context 类看到，该类是抽象类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public abstract class Context &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>getView 中使用的 Context 对象的具体实现类是什么呢？其实在 Application、Activity、Service 中都会存在一个 Context 对象，即 Context 的总个数为 Activity 个数 + Service 个数 + 1。而 ListView 通常都是显示在 Activity 中，那么我们就以 Activity 中的 Context 来分析。</p><p>我们知道，一个 Activity 的入口是 ActivityThread 的 main 函数，在 main 函数中创建一个新的 ActivityThread 对象，并且启动消息循环（UI 线程），创建新的 Activity、新的 Context 对象，然后将该 Context 对象传递给 Activity。下面我们看看 ActivityThread 源代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    </div><div class="line">    // 代码省略</div><div class="line"></div><div class="line">    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</div><div class="line">    // 主线程消息循环</div><div class="line">    Looper.prepareMainLooper();</div><div class="line">    // 创建 ActivityThread 对象</div><div class="line">    ActivityThread thread = new ActivityThread();</div><div class="line">    thread.attach(false, startSeq);</div><div class="line"></div><div class="line">    if (sMainThreadHandler == null) &#123;</div><div class="line">        sMainThreadHandler = thread.getHandler();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Looper.loop();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">private void attach(boolean system, long startSeq) &#123;</div><div class="line">    sCurrentActivityThread = this;</div><div class="line">    mSystemThread = system;</div><div class="line">    // 不是系统应用</div><div class="line">    if (!system) &#123;</div><div class="line">        ViewRootImpl.addFirstDrawHandler(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                ensureJitEnabled();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;,</div><div class="line">                UserHandle.myUserId());</div><div class="line">        RuntimeInit.setApplicationObject(mAppThread.asBinder());</div><div class="line">        final IActivityManager mgr = ActivityManager.getService();</div><div class="line">        try &#123;</div><div class="line">            // 关联 mAppThread</div><div class="line">            mgr.attachApplication(mAppThread, startSeq);</div><div class="line">        &#125; catch (RemoteException ex) &#123;</div><div class="line">            throw ex.rethrowFromSystemServer();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 代码省略</div><div class="line">    &#125;</div><div class="line">    // 代码省略</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 main 方法中，我们创建一个 ActivityThread 对象后，调用了其 attach 函数，并且参数为 false，即非系统应用，会通过 Binder 机制与 ActivityManagerService 通信，并且最终调用 handleLaunchActivity 函数，该函数的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public Activity handleLaunchActivity(ActivityClientRecord r,</div><div class="line">            PendingTransactionActions pendingActions, Intent customIntent) &#123;</div><div class="line">    // 代码省略</div><div class="line">    final Activity a = performLaunchActivity(r, customIntent);</div><div class="line">    // 代码省略</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</div><div class="line">    // 代码省略</div><div class="line">    // 1、获取 Context 对象</div><div class="line">    ContextImpl appContext = createBaseContextForActivity(r);</div><div class="line">    Activity activity = null;</div><div class="line">    try &#123;</div><div class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</div><div class="line">        // 2、创建 Activity</div><div class="line">        activity = mInstrumentation.newActivity(</div><div class="line">                cl, component.getClassName(), r.intent);</div><div class="line">        // 代码省略</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        // 代码省略</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        // 创建 Application</div><div class="line">        Application app = r.packageInfo.makeApplication(false, mInstrumentation);</div><div class="line">        if (activity != null) &#123;</div><div class="line">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</div><div class="line">            Configuration config = new Configuration(mCompatConfiguration);</div><div class="line">            // 3、将 appContext 等对象 attach 到 activity 中</div><div class="line">            activity.attach(appContext, this, getInstrumentation(), r.token,</div><div class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</div><div class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</div><div class="line">                    r.referrer, r.voiceInteractor, window, r.configCallback);</div><div class="line">            // 代码省略</div><div class="line">            // 4、调用 Activity 的 onCreate 方法</div><div class="line">            if (r.isPersistable()) &#123;</div><div class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</div><div class="line">            &#125; else &#123;</div><div class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</div><div class="line">            &#125;</div><div class="line">            // 代码省略</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125; catch (SuperNotCalledException e) &#123;</div><div class="line">        throw e;</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        // 代码省略</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return activity;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">private ContextImpl createBaseContextForActivity(ActivityClientRecord r) &#123;</div><div class="line">    // 5、创建 Context 对象，实现类是 ContextImpl</div><div class="line">    ContextImpl appContext = ContextImpl.createActivityContext(</div><div class="line">            this, r.packageInfo, r.activityInfo, r.token, displayId, r.overrideConfig);</div><div class="line">    // 代码省略</div><div class="line">    return appContext;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通过上面 1~5 注释处的代码分析可以知道，Context 的实现类为 ContextImpl。继续跟踪 ContextImpl 类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class ContextImpl extends Context &#123;</div><div class="line">    // The system service cache for the system services that are cached per-ContextImpl.</div><div class="line">    final Object[] mServiceCache = SystemServiceRegistry.createServiceCache();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object getSystemService(String name) &#123;</div><div class="line">        return SystemServiceRegistry.getSystemService(this, name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 代码省略</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>继续跟踪 SystemServiceRegistry 类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">final class SystemServiceRegistry &#123;</div><div class="line">    // 1、Service 容器</div><div class="line">    private static final HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =</div><div class="line">            new HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();</div><div class="line"></div><div class="line">    // 2、注册服务器</div><div class="line">    private static &lt;T&gt; void registerService(String serviceName, Class&lt;T&gt; serviceClass,</div><div class="line">            ServiceFetcher&lt;T&gt; serviceFetcher) &#123;</div><div class="line">        SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);</div><div class="line">        SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 静态语句块，第一次加载该类时执行（只执行一次，保证实例的唯一性）</div><div class="line">    static &#123;</div><div class="line">        // 代码省略</div><div class="line">        // 注册 LayoutInflater Service</div><div class="line">        registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</div><div class="line">                new CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public LayoutInflater createService(ContextImpl ctx) &#123;</div><div class="line">                return new PhoneLayoutInflater(ctx.getOuterContext());</div><div class="line">            &#125;&#125;);</div><div class="line">        // 代码省略</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 根据 key 获取对应的服务</div><div class="line">    public static Object getSystemService(ContextImpl ctx, String name) &#123;</div><div class="line">        ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</div><div class="line">        return fetcher != null ? fetcher.getService(ctx) : null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 代码省略</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从 SystemServiceRegistry 类的部分代码中可以看到，在虚拟机第一次加载该类时会注册各种 ServiceFetcher，其中就包含了 LayoutInflater Service。将这些服务以键值对的形式储存在一个 HashMap 中，用户使用时只需要根据 key 来获取到对应的 ServiceFetcher，然后通过 ServiceFetcher 对象的 getService 函数来获取具体的服务对象。当第一次获取时，会调用 ServiceFetcher 的 createService 函数创建服务对象，然后将该对象缓存到一个列表中，下次再取时直接从缓存中获取，避免重复创建对象，从而达到单例的效果。这种模式就是前文描述的通过容器实现单例模式。系统核心服务以单例形式存在，减少了资源消耗。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-5c52b5b016c415ef.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>00.6 ANDROID 面向对象的六大原则——迪米特原则</title>
      <link href="/1901/01/08/02%20DESIGN%20PATTERN/00.6%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99/"/>
      <url>/1901/01/08/02%20DESIGN%20PATTERN/00.6%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-65cf0529831b949d.gif?imageMogr2/auto-orient/strip" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a><br>|<br><a href="https://xianxiaotao.github.io/1901/01/03/02%20DESIGN%20PATTERN/00.1%20ANDROID%20面向对象的六大原则——单一职责原则/" target="_blank" rel="external">第一篇：单一职责原则</a><br><a href="https://xianxiaotao.github.io/1901/01/04/02%20DESIGN%20PATTERN/00.2%20ANDROID%20面向对象的六大原则——开闭原则/" target="_blank" rel="external">第二篇：开闭原则</a><br><a href="https://xianxiaotao.github.io/1901/01/05/02%20DESIGN%20PATTERN/00.3%20ANDROID%20面向对象的六大原则——里氏替换原则/" target="_blank" rel="external">第三篇：里氏替换原则</a><br><a href="https://xianxiaotao.github.io/1901/01/06/02%20DESIGN%20PATTERN/00.4%20ANDROID%20面向对象的六大原则——依赖倒置原则/" target="_blank" rel="external">第四篇：依赖倒置原则</a><br><a href="https://xianxiaotao.github.io/1901/01/07/02%20DESIGN%20PATTERN/00.5%20ANDROID%20面向对象的六大原则——接口隔离原则/" target="_blank" rel="external">第五篇：接口隔离原则</a><br><a href="https://xianxiaotao.github.io/1901/01/08/02%20DESIGN%20PATTERN/00.6%20ANDROID%20面向对象的六大原则——迪米特原则/" target="_blank" rel="external">第六篇：迪米特原则</a></p></blockquote><hr><h3 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h3><hr><p>英文全称为 Law of Demeter，LOD，也称为最少知识原则，意思都是<strong>一个对象应该对其他对象有最少的了解</strong>。通俗的讲，一个类应该对自己需要耦合或调用的类知道得最少，类的内部如何实现与调用者或者依赖者没关系，调用者或者依赖者只需要知道它需要的方法即可，其他的可一概不用管。类与类之间的关系越密切，耦合越大，当一个类发生变化时，对另一个类的影响也越大。</p><p>迪米特原则还有一个英文解释是 Only talk to your immediate friends，翻译过来就是：<strong>只与直接的朋友通信。</strong>什么叫做直接的朋友？每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就成为了朋友关系，这种关系的类型有很多，如组合、聚合、依赖等。</p><p>下面我们就以租房为例来讲讲迪米特原则的应用。</p><hr><h3 id="举例：在北京租房"><a href="#举例：在北京租房" class="headerlink" title="举例：在北京租房"></a>举例：在北京租房</h3><hr><p>在北京租房绝大多数都是通过中介找房。我们设定的情况为：我只要求房间的面积和租金，其他的一概不管，中介将符合我们要求的房子提供给我就可以。下面我们看看这个示例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 房间</div><div class="line"> */</div><div class="line">public class Room &#123;</div><div class="line">    public float area;</div><div class="line">    public float price;</div><div class="line"></div><div class="line">    public Room(float area, float price) &#123;</div><div class="line">        this.area = area;</div><div class="line">        this.price = price;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;Room&#123;&quot; + &quot;area=&quot; + area + &quot;, price=&quot; + price + &apos;&#125;&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 中介</div><div class="line"> */</div><div class="line">public class Mediator &#123;</div><div class="line">    List&lt;Room&gt; mRooms = new ArrayList&lt;&gt;();</div><div class="line">    </div><div class="line">    public Mediator() &#123;</div><div class="line">        for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">            mRooms.add(new Room(14 + i, (14 + i) * 150));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public List&lt;Room&gt; getAllRooms() &#123;</div><div class="line">        return mRooms;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 租户</div><div class="line"> */</div><div class="line">public class Tenant &#123;</div><div class="line">    public void rentRoom(float roomArea, float roomPrice, Mediator mediator) &#123;</div><div class="line">        List&lt;Room&gt; rooms = mediator.getAllRooms();</div><div class="line">        for (Room room : rooms) &#123;</div><div class="line">            if (isSuitable(roomArea, roomPrice, room)) &#123;</div><div class="line">                System.out.println(&quot;租到房间啦！&quot; + room);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private boolean isSuitable(float roomArea, float roomPrice, Room room) &#123;</div><div class="line">        return room.area &gt;= roomArea &amp;&amp; room.price &lt;= roomPrice;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从上面的代码可以看到，Tenant 不仅依赖了 Mediator 类，还需要频繁地与 Room 类打交道。租户类的要求只是通过中介找到一间适合自己的房间罢了，如果把这些检测条件都放在 Tenant 类中，那么中介类的功能就被弱化，而且导致了 Tenant 与 Room 的耦合较高，因为 Tenant 必须知道许多关于 Room 的细节。当 Room 变化时 Tenant 也必须跟着变化。Tenant 又与 Mediator 耦合，这就出现了纠缠不清的关系。这个时候就需要我们分清谁才是我们真正的“朋友”，在我们所设定的情况下，显然是 Mediator。上述代码的结构下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ef06a9294f269c90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>既然是耦合太严重，那我们就只能解耦了。首先要明确的是，我们只和我们的朋友通信，这里就是指 Mediator 对象。必须将 Room 相关的操作从 Tenant 中移除，而这些操作案例应该属于 Mediator。我们进行如下重构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 中介</div><div class="line"> */</div><div class="line">public class Mediator &#123;</div><div class="line">    List&lt;Room&gt; mRooms = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    public Mediator() &#123;</div><div class="line">        for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">            mRooms.add(new Room(14 + i, (14 + i) * 150));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Room rentOut(float area, float price) &#123;</div><div class="line">        for (Room room : mRooms) &#123;</div><div class="line">            if (isSuitable(area, price, room)) &#123;</div><div class="line">                return room;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private boolean isSuitable(float roomArea, float roomPrice, Room room) &#123;</div><div class="line">        return room.area &gt;= roomArea &amp;&amp; room.price &lt;= roomPrice;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 租户</div><div class="line"> */</div><div class="line">public class Tenant &#123;</div><div class="line">    public void rentRoom(float roomArea, float roomPrice, Mediator mediator) &#123;</div><div class="line">        mediator.rentOut(roomArea, roomPrice);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>重构后的结构图如下所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7c0beb82a0d5073c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>只是将对于 Room 的判定操作移到了 Mediator 类中，这本应该是 Mediator 的职责，根据租户设定的条件查找符合要求的房子，并且将结果交给租户就可以了。租户并不需要知道太多关于 Room 的细节，比如与房东签合同，房东的房产证是不是真的，房内的设施坏了之后要找谁谁修等。当我们通过我们的“朋友”——中介租了房之后，所有的事情我们都通过与中介沟通就好了，房东、维修师傅等这些角色并不是我们直接的“朋友”。“只与直接的朋友通信”这简单的几个字就能够将我们从复杂的关系网中抽离出来，使程序耦合度更低、稳定性更好。</p><hr><h3 id="举例二：ImageCache"><a href="#举例二：ImageCache" class="headerlink" title="举例二：ImageCache"></a>举例二：ImageCache</h3><hr><p>前面博客中的图片加载器项目，ImageCache 就是用户的直接朋友，而 SD 卡缓存内部使用了 FileOutputStream，这个 FileOutputStream 就不属于用户的直接朋友了。因此，用户完全不知道它的存在，用户只需要与 ImageCache 对象打交的即可。将图片存到 SD 卡中的代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// SD 卡缓存 DiskCache 类</div><div class="line">public class DiskCache implements ImageCache &#123;</div><div class="line">    private static String CACHE_DIR =</div><div class="line">            Environment.getExternalStorageDirectory() + &quot;/&quot;;</div><div class="line"></div><div class="line">    public Bitmap get(String url) &#123;</div><div class="line">        return BitmapFactory.decodeFile(CACHE_DIR</div><div class="line">                + ImageUtil.urlToMd5(url));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void put(String url, Bitmap bitmap) &#123;</div><div class="line">        FileOutputStream fileOutputStream = null;</div><div class="line">        try &#123;</div><div class="line">            fileOutputStream = new FileOutputStream(CACHE_DIR</div><div class="line">                    + ImageUtil.urlToMd5(url));</div><div class="line">            bitmap.compress(Bitmap.CompressFormat.PNG, 100, fileOutputStream);</div><div class="line">        &#125; catch (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            CloseUtils.closeQuietly(fileOutputStream);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>现在领导要求使用 jake wharton 的 DiskLruCache 来替换 FileOutputStream。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public void put(String url, Bitmap bitmap) &#123;</div><div class="line">    DiskLruCache.Editor editor = null;</div><div class="line">    try &#123;</div><div class="line">        editor = mDiskLruCache.edit(url);</div><div class="line">        if (null != editor) &#123;</div><div class="line">            OutputStream outputStream = editor.newOutputStream(0);</div><div class="line">            if (writeBitmapToDisk(bitmap, outputStream)) &#123;</div><div class="line">                // 写入 Disk 缓存</div><div class="line">                editor.commit();</div><div class="line">            &#125; else &#123;</div><div class="line">                editor.abort();</div><div class="line">            &#125;</div><div class="line">            CloseUtils.closeQuietly(outputStream);</div><div class="line">        &#125;</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>SD 卡缓存的具体实现虽然被替换了，但用户根本不会感知到。因为用户根本不知道 FileOutputStream 和 DiskLruCache 的存在，他们没有与 FileOutputStream 或 DiskLruCache 进行通信，他们只认识直接“朋友”——ImageCache，ImageCache 将一切细节隐藏在直接“朋友”的外衣之下，使得系统具有更低的耦合性和更好的可扩展性。</p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>00.5 ANDROID 面向对象的六大原则——接口隔离原则</title>
      <link href="/1901/01/07/02%20DESIGN%20PATTERN/00.5%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/"/>
      <url>/1901/01/07/02%20DESIGN%20PATTERN/00.5%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-8773342cded8d9df.gif?imageMogr2/auto-orient/strip" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a><br>|<br><a href="https://xianxiaotao.github.io/1901/01/03/02%20DESIGN%20PATTERN/00.1%20ANDROID%20面向对象的六大原则——单一职责原则/" target="_blank" rel="external">第一篇：单一职责原则</a><br><a href="https://xianxiaotao.github.io/1901/01/04/02%20DESIGN%20PATTERN/00.2%20ANDROID%20面向对象的六大原则——开闭原则/" target="_blank" rel="external">第二篇：开闭原则</a><br><a href="https://xianxiaotao.github.io/1901/01/05/02%20DESIGN%20PATTERN/00.3%20ANDROID%20面向对象的六大原则——里氏替换原则/" target="_blank" rel="external">第三篇：里氏替换原则</a><br><a href="https://xianxiaotao.github.io/1901/01/06/02%20DESIGN%20PATTERN/00.4%20ANDROID%20面向对象的六大原则——依赖倒置原则/" target="_blank" rel="external">第四篇：依赖倒置原则</a><br><a href="https://xianxiaotao.github.io/1901/01/07/02%20DESIGN%20PATTERN/00.5%20ANDROID%20面向对象的六大原则——接口隔离原则/" target="_blank" rel="external">第五篇：接口隔离原则</a><br><a href="https://xianxiaotao.github.io/1901/01/08/02%20DESIGN%20PATTERN/00.6%20ANDROID%20面向对象的六大原则——迪米特原则/" target="_blank" rel="external">第六篇：迪米特原则</a></p></blockquote><hr><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><hr><p>英文全称是 Interface Segregation Principles，ISP。其定义是：<strong>客户端不应该依赖它不需要的接口</strong>。另一种定义是：<strong>类间的依赖关系应该建立在最小的接口上</strong>。接口隔离原则将非常庞大、臃肿的接口拆分成更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。接口隔离原则的目的是系统解开耦合，从而容易重构、更改和重新部署。</p><p>说白了就是，让客户端依赖的接口尽可能地小。这样说可能还有点抽象，我们还是以一个示例来说明一下。在此之前我们来说一个场景，在 Java 6 及之前的 JDK 版本，有一个非常讨厌的问题，那就是在使用了 OutputStream 或者其他可关闭的对象之后，我们必须保证他们最终被关闭了，我们的 SD 卡缓存类中就有这样的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public void put(String url, Bitmap bitmap) &#123;</div><div class="line">    FileOutputStream fileOutputStream = null;</div><div class="line">    try &#123;</div><div class="line">        fileOutputStream = new FileOutputStream(CACHE_DIR</div><div class="line">                + ImageUtil.urlToMd5(url));</div><div class="line">        bitmap.compress(Bitmap.CompressFormat.PNG, 100, fileOutputStream);</div><div class="line">    &#125; catch (FileNotFoundException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; finally &#123;</div><div class="line">        if (fileOutputStream != null) &#123;</div><div class="line">            try &#123;</div><div class="line">                fileOutputStream.close();</div><div class="line">            &#125; catch (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们看到的这段代码可读性非常差，各种 try…catch 嵌套都是些简单的代码，但是会严重影响代码的可读性，并且多层次的大括号很容易将代码写到错误的层级中。</p><p>在 Java 中有一个 Closeable 接口，该接口标识了一个可关闭的对象，它只有一个 close 方法。如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0f0d41101412f87c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>我们要讲的 FileOutputStream 类就实现了这个接口。我们从上图可以看到，还有 100 多个类实现了 Closeable 这个接口。这意味着，在关闭这 100 多个类型的对象时，都需要写出像 put 方法中 finally 代码段那样的代码。这还了得，反正我是不能忍。既然都是实现了 Closeable 接口，那只要一个方法统一来关闭这些对象不就可以了么？于是写来来如下的工具类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line">import java.io.Closeable;</div><div class="line"></div><div class="line">public class CloseUtils &#123;</div><div class="line"></div><div class="line">    private CloseUtils() &#123;&#125;</div><div class="line"></div><div class="line">    public static void closeQuietly(Closeable closeable) &#123;</div><div class="line">        if (null != closeable) &#123;</div><div class="line">            try &#123;</div><div class="line">                closeable.close();</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们再看看把这段代码运用到上述的 put 方法中的效果如何。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void put(String url, Bitmap bitmap) &#123;</div><div class="line">    FileOutputStream fileOutputStream = null;</div><div class="line">    try &#123;</div><div class="line">        fileOutputStream = new FileOutputStream(CACHE_DIR</div><div class="line">                + ImageUtil.urlToMd5(url));</div><div class="line">        bitmap.compress(Bitmap.CompressFormat.PNG, 100, fileOutputStream);</div><div class="line">    &#125; catch (FileNotFoundException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; finally &#123;</div><div class="line">        CloseUtils.closeQuietly(fileOutputStream);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>代码简洁了很多！而且这个 closeQuietly 方法可以运用到各类可关闭的对象中，保证了代码的重用性。CloseUtils 的 closeQuietly 方法的基本原理就是依赖于 Closeable 抽象而不是具体实现，并且建立在最小化依赖原则的基础上，它只需要知道这个对象是可关闭的，其他的一概不关心，也就是这里的接口隔离原则。</p><p>试想一下，如果在只是需要关闭一个对象时，它却暴露了其他的接口函数，如 OutputStream 的 write 方法，这就使得更多的细节暴露在客户端代码面前，不仅没有很好地隐藏实现，还增加了接口的使用难度。而通过 Closeable 接口将可关闭的对象抽象起来，这样只需要客户端依赖于 Closeable 就可以对客户端隐藏其他的接口信息，客户端代码只需要知道这个对象可关闭（只可调用 close 方法）即可。</p><p>之前博客中设计的 ImageLoader 持有的 ImageCache 就是接口隔离原则的运用。ImageLoader 只需要知道该缓存对象有存、取缓存图片的接口即可，其他的一概不管，这就使得缓存功能的具体实现对 ImageLoader 隐藏。这就是用最小化接口隔离了实现类的细节，也促使我们将庞大的接口拆分到更细粒度的接口当中，这使得我们的系统具有更低的耦合性、更高的灵活性。</p><hr><h3 id="举例：拆分接口"><a href="#举例：拆分接口" class="headerlink" title="举例：拆分接口"></a>举例：拆分接口</h3><hr><p>依据接口隔离原则，将下图中臃肿的接口 I 拆分为独立的几个接口。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1cd2d3c76d59ad0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>类 A 依赖接口 I 中的方法1、方法2、方法3，类 PA 是对类 A 依赖的实现。类 B 依赖接口 I 中的方法1、方法4、方法5，类 PB 是对类 B 依赖的实现。对于类 PA 和类 PB 来说，虽然他们都存在着用不到的方法（也就是图中划红线的方法），但由于实现了接口 I，所以也必须要实现这些用不到的方法。用代码表示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">interface I &#123;</div><div class="line">    void method1();</div><div class="line">    void method2();</div><div class="line">    void method3();</div><div class="line">    void method4();</div><div class="line">    void method5();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class A &#123;</div><div class="line">    public void depend1(I i)&#123;</div><div class="line">        i.method1();</div><div class="line">    &#125;</div><div class="line">    public void depend2(I i)&#123;</div><div class="line">        i.method2();</div><div class="line">    &#125;</div><div class="line">    public void depend3(I i)&#123;</div><div class="line">        i.method3();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class B &#123;</div><div class="line">    public void depend1(I i)&#123;</div><div class="line">        i.method1();</div><div class="line">    &#125;</div><div class="line">    public void depend2(I i)&#123;</div><div class="line">        i.method4();</div><div class="line">    &#125;</div><div class="line">    public void depend3(I i)&#123;</div><div class="line">        i.method5();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class PA implements I &#123;</div><div class="line">    public void method1() &#123;</div><div class="line">        System.out.println(&quot;类 PA 实现接口 I 的方法1&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method2() &#123;</div><div class="line">        System.out.println(&quot;类 PA 实现接口 I 的方法2&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method3() &#123;</div><div class="line">        System.out.println(&quot;类 PA 实现接口 I 的方法3&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 对于类 PA 来说，method4 和 method5 不是必需的，但是由于接口 I 中有这两个方法</div><div class="line">    // 所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现</div><div class="line">    public void method4() &#123;&#125;</div><div class="line">    public void method5() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class PB implements I &#123;</div><div class="line">    public void method1() &#123;</div><div class="line">        System.out.println(&quot;类 PB 实现接口 I 的方法1&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 对于类 PB 来说，method2 和 method3 不是必需的，但是由于接口 I 中有这两个方法</div><div class="line">    // 所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现</div><div class="line">    public void method2() &#123;&#125;</div><div class="line">    public void method3() &#123;&#125;</div><div class="line"></div><div class="line">    public void method4() &#123;</div><div class="line">        System.out.println(&quot;类 PB 实现接口 I 的方法4&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method5() &#123;</div><div class="line">        System.out.println(&quot;类 PB 实现接口 I 的方法5&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        A a = new A();</div><div class="line">        a.depend1(new PA());</div><div class="line">        a.depend2(new PA());</div><div class="line">        a.depend3(new PA());</div><div class="line"></div><div class="line">        B b = new B();</div><div class="line">        b.depend1(new PB());</div><div class="line">        b.depend2(new PB());</div><div class="line">        b.depend3(new PB());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口 I 进行拆分。在这里我们将原有的接口 I 拆分为三个接口，拆分后的设计如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-83e0173046673597.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>代码更改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">interface I1 &#123;</div><div class="line">    void method1();</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface I2 &#123;</div><div class="line">    void method2();</div><div class="line">    void method3();</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface I3 &#123;</div><div class="line">    void method4();</div><div class="line">    void method5();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class A &#123;</div><div class="line">    public void depend1(I1 i)&#123;</div><div class="line">        i.method1();</div><div class="line">    &#125;</div><div class="line">    public void depend2(I2 i)&#123;</div><div class="line">        i.method2();</div><div class="line">    &#125;</div><div class="line">    public void depend3(I2 i)&#123;</div><div class="line">        i.method3();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class B &#123;</div><div class="line">    public void depend1(I1 i)&#123;</div><div class="line">        i.method1();</div><div class="line">    &#125;</div><div class="line">    public void depend2(I3 i)&#123;</div><div class="line">        i.method4();</div><div class="line">    &#125;</div><div class="line">    public void depend3(I3 i)&#123;</div><div class="line">        i.method5();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class PA implements I1, I2 &#123;</div><div class="line">    public void method1() &#123;</div><div class="line">        System.out.println(&quot;类 PA 实现接口 I1 的方法1&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method2() &#123;</div><div class="line">        System.out.println(&quot;类 PA 实现接口 I2 的方法2&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method3() &#123;</div><div class="line">        System.out.println(&quot;类 PA 实现接口 I2 的方法3&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class PB implements I1, I3 &#123;</div><div class="line">    public void method1() &#123;</div><div class="line">        System.out.println(&quot;类 PB 实现接口 I1 的方法1&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method4() &#123;</div><div class="line">        System.out.println(&quot;类 PB 实现接口 I2 的方法4&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method5() &#123;</div><div class="line">        System.out.println(&quot;类 PB 实现接口 I2 的方法5&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为 3 个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p><p>说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</p><p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p><ul><li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化，所以一定要适度。</li><li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><p>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>00.4 ANDROID 面向对象的六大原则——依赖倒置原则</title>
      <link href="/1901/01/06/02%20DESIGN%20PATTERN/00.4%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/"/>
      <url>/1901/01/06/02%20DESIGN%20PATTERN/00.4%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1e0883d470138e7b.gif?imageMogr2/auto-orient/strip" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a><br>|<br><a href="https://xianxiaotao.github.io/1901/01/03/02%20DESIGN%20PATTERN/00.1%20ANDROID%20面向对象的六大原则——单一职责原则/" target="_blank" rel="external">第一篇：单一职责原则</a><br><a href="https://xianxiaotao.github.io/1901/01/04/02%20DESIGN%20PATTERN/00.2%20ANDROID%20面向对象的六大原则——开闭原则/" target="_blank" rel="external">第二篇：开闭原则</a><br><a href="https://xianxiaotao.github.io/1901/01/05/02%20DESIGN%20PATTERN/00.3%20ANDROID%20面向对象的六大原则——里氏替换原则/" target="_blank" rel="external">第三篇：里氏替换原则</a><br><a href="https://xianxiaotao.github.io/1901/01/06/02%20DESIGN%20PATTERN/00.4%20ANDROID%20面向对象的六大原则——依赖倒置原则/" target="_blank" rel="external">第四篇：依赖倒置原则</a><br><a href="https://xianxiaotao.github.io/1901/01/07/02%20DESIGN%20PATTERN/00.5%20ANDROID%20面向对象的六大原则——接口隔离原则/" target="_blank" rel="external">第五篇：接口隔离原则</a><br><a href="https://xianxiaotao.github.io/1901/01/08/02%20DESIGN%20PATTERN/00.6%20ANDROID%20面向对象的六大原则——迪米特原则/" target="_blank" rel="external">第六篇：迪米特原则</a></p></blockquote><hr><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><hr><p>英文全称是 Dependence Inversion Principle，缩写 DIP。它指代了一种特定的解耦形式，使得高层次的模块不依赖于低层次模块的实现细节，即依赖模块被颠倒了。它包含了以下几个含义：</p><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象；</li><li>抽象不应该依赖细节；</li><li>细节应该依赖抽象。</li></ul><p>在 Java 语言中，抽象就是指接口或抽象类，两者都是不能直接被实例化的；细节就是实现类，实现接口或继承抽象类而产生的类就是细节，可以被直接实例化 (new)。高层模块就是调用端，底层模块就是具体实现类。依赖倒置原则在 Java 语言中的表现就是：<strong>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。</strong>概括的说就是<strong>面向接口编程</strong>，或者说面向抽象编程，这里的抽象指的是接口或者抽象类。</p><p>如果类与类直接依赖于细节，那么它们直接就有直接的耦合，当具体实现变化时，意味着要同时修改依赖者的代码，这限制了系统的可扩展性。</p><p>在下面的代码中，ImageLoader 直接依赖于 MemoryCache，这个 MemoryCache 是一个具体实现，而不是一个抽象类或者接口。这导致了 ImageLoader 直接依赖了具体细节，当 MemoryCache 不能满足 ImageLoader 而需要被其他缓存实现替换时，此时就必须修改 ImageLoader 的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line">    // 内存缓存（直接依赖于细节）</div><div class="line">    MemoryCache mMemoryCache = new MemoryCache();</div><div class="line">    </div><div class="line">    // 加载图片到 ImageView 中</div><div class="line">    public void displayImage(String url, ImageView imageView) &#123;</div><div class="line">        Bitmap bitmap = mMemoryCache.get(url);</div><div class="line">        if (bitmap == null) &#123;</div><div class="line">            downloadImage(url, imageView);</div><div class="line">        &#125; else &#123;</div><div class="line">            imageView.setImageBitmap(bitmap);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void setImageCache(MemoryCache cache) &#123;</div><div class="line">        mMemoryCache = cache;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>随着产品的升级，用户发现 MemoryCache 已经不能满足需求，用户需要的 ImageLoader 可以将图片同时缓存到内存和 SD 卡中，或者可以让用户自定义实现缓存。修改原有代码也不符合开闭原则。</p><p>正确的做法是依照依赖倒置原则依赖抽象，而不依赖具体实现。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public interface ImageCache &#123;</div><div class="line">    Bitmap get(String url);</div><div class="line">    void put(String url, Bitmap bitmap);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ImageLoader &#123;</div><div class="line">    // 图片缓存类，依赖于抽象，并且有一个默认的实现</div><div class="line">    ImageCache mImageCache = new MemoryCache();</div><div class="line"></div><div class="line">    // 加载图片到 ImageView 中</div><div class="line">    public void displayImage(String url, ImageView imageView) &#123;</div><div class="line">        Bitmap bitmap = mMemoryCache.get(url);</div><div class="line">        if (bitmap == null) &#123;</div><div class="line">            downloadImage(url, imageView);</div><div class="line">        &#125; else &#123;</div><div class="line">            imageView.setImageBitmap(bitmap);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 注入缓存实现</div><div class="line">    public void setImageCache(ImageCache cache) &#123;</div><div class="line">        mImageCache = cache;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里，我们建立了 ImageCache 抽象，并且让 ImageLoader 依赖于抽象而不是具体细节。当需求发生变化时，我们只需要实现 ImageCache 类或者继承其他已有的 ImageCache 子类完成相应的缓存功能，然后将具体的实现注入到 ImageLoader 即可实现缓存功能的替换，这就保证了缓存系统的可扩展性，有了拥抱变化的能力，这就是依赖倒置原则。</p><hr><h3 id="举例：涛哥开奔驰"><a href="#举例：涛哥开奔驰" class="headerlink" title="举例：涛哥开奔驰"></a>举例：涛哥开奔驰</h3><hr><p>先不考虑依赖倒置原则，看一下如下的设计：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2b425fd147530af4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从上面的类图中可以看出，司机类和奔驰车类都属于细节，并没有实现或继承抽象，它们是对象级别的耦合。通过类图可以看出司机有一个 drive() 方法，用来开车，奔驰车有一个 run() 方法，用来表示车辆运行，并且奔驰车类依赖于司机类，用户模块表示高层模块，负责调用司机类和奔驰车类。</p><p>可用以下代码表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class Driver &#123;</div><div class="line">    // 司机的主要职责就是驾驶汽车</div><div class="line">    public void drive(Benz benz)&#123;</div><div class="line">        benz.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Benz &#123;</div><div class="line">    // 汽车肯定会跑</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(&quot;奔驰汽车开始运行...&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 高层模块</div><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Driver taoGe = new Driver();</div><div class="line">        Benz benz = new Benz();</div><div class="line">        // 司机开奔驰车</div><div class="line">        taoGe.drive(benz);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样的设计乍一看好像也没有问题，涛哥只管开着他的奔驰车就好。但是假如有一天他不想开奔驰了，想换一辆宝马车玩玩怎么办呢？我们当然可以新建一个宝马车类，也给它弄一个 run() 方法，但问题是，这辆车有是有了，但是涛哥却不能开啊，因为司机类里面并没有宝马车的依赖。要想解决问题，只能修改代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class BMW &#123;</div><div class="line">    public void run()&#123;</div><div class="line">        System.out.println(&quot;宝马汽车开始运行...&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面的设计没有使用依赖倒置原则，我们已经发现，模块与模块之间耦合度太高，生产力太低，只要需求一变就需要大面积重构，说明这样的设计是不合理。现在我们引入依赖倒置原则，重新设计的类图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-22580545a2617fb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可用以下代码表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">// 将司机模块抽象为一个接口</div><div class="line">public interface IDriver &#123;</div><div class="line">    void drive(ICar car);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Driver implements IDriver &#123;</div><div class="line">    public void drive(ICar car)&#123;</div><div class="line">        car.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 将汽车模块抽象为一个接口：可以是奔驰汽车，也可以是宝马汽车</div><div class="line">public interface ICar &#123;</div><div class="line">    void run();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Benz implements ICar &#123;</div><div class="line">    public void run()&#123;</div><div class="line">        System.out.println(&quot;奔驰汽车开始运行...&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class BMW implements ICar &#123;</div><div class="line">    public void run()&#123;</div><div class="line">        System.out.println(&quot;宝马汽车开始运行...&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 高层模块</div><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        IDriver taoGe = new Driver();</div><div class="line">        ICar benz = new Benz();</div><div class="line">        // 涛哥开奔驰</div><div class="line">        taoGe.drive(benz);</div><div class="line">        // 涛哥开宝马</div><div class="line">        taoGe.drive(new BMW());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如此设计，涛哥再也不怕有新车不能开的情况了。</p><hr><h3 id="依赖的三种方法"><a href="#依赖的三种方法" class="headerlink" title="依赖的三种方法"></a>依赖的三种方法</h3><hr><p><strong>接口声明依赖对象</strong>： 在接口的方法中声明依赖对象，就如上面的例子。<br><strong>构造函数传递依赖对象</strong>：在类中通过构造函数声明依赖对象，按照依赖注入的说法，这种方式叫做构造函数注入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public interface IDriver &#123;</div><div class="line">    void drive();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Driver implements IDriver&#123;</div><div class="line">    private ICar car;</div><div class="line"></div><div class="line">    // 构造函数注入</div><div class="line">    public Driver(ICar car)&#123;</div><div class="line">        this.car = car;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void drive(ICar car)&#123;</div><div class="line">        this.car.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>Setter 方法传递依赖对象</strong>：在抽象中设置 Setter 方法声明依赖对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public interface IDriver&#123;</div><div class="line">    // 注入依赖</div><div class="line">    void setCar(ICar car);</div><div class="line">    void drive();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Driver implements IDriver &#123;</div><div class="line">    private ICar car;</div><div class="line"></div><div class="line">    public void setCar(ICar car)&#123;</div><div class="line">        this.car = car;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void drive()&#123;</div><div class="line">        this.car.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><hr><h3 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h3><hr><p>依赖倒置原则的本质就是通过抽象（抽象类或接口）使各个类或模块实现彼此独立，不互相影响，实现模块间的松耦合。在项目中使用这个规则需要以下原则：</p><ul><li><strong>每个类尽量都要有接口或抽象类，或者抽象类和接口都有。</strong></li><li><strong>变量的表面类型尽量是接口或者抽象类。</strong></li><li><strong>任何类都不应该从具体类派生。</strong></li><li><strong>尽量不要重写基类已经写好的方法</strong>（里式替换原则）。<br>如果基类是一个抽象类，而这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会有一定的影响。</li><li><strong>结合里式替换原则来使用</strong>： 结合里式替换原则和依赖倒置原则我们可以得出一个通俗的规则，接口负责定义 public 属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化。</li></ul><blockquote><p>总结：<strong>依赖倒置原则的核心就是面向抽象（抽象类或者接口）编程</strong>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>00.3 ANDROID 面向对象的六大原则——里氏替换原则</title>
      <link href="/1901/01/05/02%20DESIGN%20PATTERN/00.3%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/"/>
      <url>/1901/01/05/02%20DESIGN%20PATTERN/00.3%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-6e7e90e86fe53371.gif?imageMogr2/auto-orient/strip" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a><br>|<br><a href="https://xianxiaotao.github.io/1901/01/03/02%20DESIGN%20PATTERN/00.1%20ANDROID%20面向对象的六大原则——单一职责原则/" target="_blank" rel="external">第一篇：单一职责原则</a><br><a href="https://xianxiaotao.github.io/1901/01/04/02%20DESIGN%20PATTERN/00.2%20ANDROID%20面向对象的六大原则——开闭原则/" target="_blank" rel="external">第二篇：开闭原则</a><br><a href="https://xianxiaotao.github.io/1901/01/05/02%20DESIGN%20PATTERN/00.3%20ANDROID%20面向对象的六大原则——里氏替换原则/" target="_blank" rel="external">第三篇：里氏替换原则</a><br><a href="https://xianxiaotao.github.io/1901/01/06/02%20DESIGN%20PATTERN/00.4%20ANDROID%20面向对象的六大原则——依赖倒置原则/" target="_blank" rel="external">第四篇：依赖倒置原则</a><br><a href="https://xianxiaotao.github.io/1901/01/07/02%20DESIGN%20PATTERN/00.5%20ANDROID%20面向对象的六大原则——接口隔离原则/" target="_blank" rel="external">第五篇：接口隔离原则</a><br><a href="https://xianxiaotao.github.io/1901/01/08/02%20DESIGN%20PATTERN/00.6%20ANDROID%20面向对象的六大原则——迪米特原则/" target="_blank" rel="external">第六篇：迪米特原则</a></p></blockquote><p>前一篇博文中的图片加载器项目，MemoryCache、DiskCache、DoubleCache 都可以替换 ImageCache 的工作，并且能够保证行为的正确性。ImageCache 建立了获取缓存图片、保存缓存图片的接口规范，MemoryCache 等根据接口规范实现了相应的功能，用户只需要在使用时指定具体的缓存对象就可以动态地替换 ImageLoader 中的缓存策略。这就使得 ImageLoader 的缓存系统具有了无限的可能性，也就是保证了可扩展性。</p><p>想象一种情况，当 ImageLoader 中的 setImageCache(ImageCache cache) 中的 cache 对象不能被子类所替换，那么用户如何设置不同的缓存对象，以及用户如何定义自己的缓存实现，通过前文中的 useDiskCache 方法吗？显然不是的，里氏替换原则就为这类问题提供了指导原则，也就是建立抽象，通过抽象建立规范，具体的实现在运行时替换掉抽象，保证系统的扩展性、灵活性。</p><p>开闭原则和里氏替换原则往往是生死相依、不离不弃的，通过里氏替换来达到对扩展开放，对修改关闭的效果。然而，这两个原则都同时强调了一个 OOP 的重要特性——抽象。因此，在开发过程中运用抽象是走向代码优化的重要一步。</p><hr><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><hr><p>里氏替换原则（Liskov Substitution Principle，LSP）有两种定义：<br>● <strong>If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.</strong>（如果对每一个类型为 S 的对象 o1，都有类型为 T 的对象 o2，使得以 T 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 S 是类型 T 的子类型。）</p><p>● <strong>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.</strong>（所有引用基类的地方必须能透明地使用其子类的对象。）</p><hr><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><hr><p>里氏替换原则的核心原理是抽象，抽象又依赖于继承这个特性。继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。</p><p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。</p><p>问题描述：<strong>有一功能 P1，由类 A 完成。现需要将功能 P1 进行扩展，扩展后的功能为 P，其中 P 由原有功能 P1 与新功能 P2 组成。新功能 P 由类 A 的子类 B 来完成，则子类 B 在完成新功能 P2 的同时，有可能会导致原有功能 P1 发生故障。</strong></p><p>解决方案：<strong>当使用继承时，遵循里氏替换原则</strong>。类 B 继承类 A 时，除添加新的方法完成新增功能 P2 外，尽量不要重写父类 A 的方法，也尽量不要重载父类 A 的方法。</p><p>举例说明：我们需要完成一个两数相减的功能 P1，由类 A 来负责。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class A &#123;</div><div class="line">    public int func1(int a, int b) &#123;</div><div class="line">        return a - b;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        A a = new A();</div><div class="line">        System.out.println(&quot;100-50=&quot; + a.func1(100, 50));</div><div class="line">        System.out.println(&quot;100-80=&quot; + a.func1(100, 80));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>运行结果：<br>100-50=50<br>100-80=20</p></blockquote><p>后来，我们需要增加一个新的功能 P2：完成两数相加，然后再与100求和，由类 B 来负责。即类 B 需要完成两个功能：</p><ul><li>P1：两数相减。</li><li>P2：两数相加，然后再加100。</li></ul><p>由于类 A 已经实现了第一个功能，所以类 B 继承类 A 后，只需要再完成第二个功能就可以了，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class B extends A &#123;</div><div class="line">    public int func1(int a, int b) &#123;</div><div class="line">        return a + b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int func2(int a, int b) &#123;</div><div class="line">        return func1(a, b) + 100;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        B b = new B();</div><div class="line">        System.out.println(&quot;100-50=&quot; + b.func1(100, 50));</div><div class="line">        System.out.println(&quot;100-80=&quot; + b.func1(100, 80));</div><div class="line">        System.out.println(&quot;100+20+100=&quot; + b.func2(100, 20));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>运行结果：<br>100-50=150<br>100-80=180<br>100+20+100=220</p></blockquote><p>我们发现原本运行正常的相减功能发生了错误。原因就是类 B 在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类 B 重写后的方法，造成原本运行正常的功能出现了错误。</p><p>在本例中，引用基类 A 完成的功能，换成子类 B 之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：<strong>原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。</strong></p><p>里氏替换原则通俗的来讲就是：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能。</strong>它包含以下4层含义：</p><ul><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法；</li><li>子类中可以增加自己特有的方法；</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松；</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li></ul><hr><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><hr><p>ANDROID 中的 Window 与 View 的关系，可以写成一个简单的示例，其 UML 图如下所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ae70d1d61a1d7785.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>具体的代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">// 窗口类</div><div class="line">public class Window &#123;</div><div class="line">    public void show(View child) &#123;</div><div class="line">        child.draw();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 建立视图抽象，测量视图的宽高为公用代码，绘制实现交给具体的子类</div><div class="line">public abstract class view &#123;</div><div class="line">    public abstract void draw();</div><div class="line">    public void measure(int width, int height) &#123;</div><div class="line">        // 测量视图大小</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 文本控件类的具体实现</div><div class="line">public class TextView extends View &#123;</div><div class="line">    public void draw() &#123;</div><div class="line">        // 绘制文本</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ImageView 的具体实现</div><div class="line">public class ImageView extends View &#123;</div><div class="line">    public void draw() &#123;</div><div class="line">        // 绘制图片</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上述示例中，Window 依赖于 View，而 View 定义了一个视图抽象，measure 是各个子类共享的方法，子类通过覆写 View 的 draw 方法实现具有各自特色的功能。在这里，这个功能就是绘制自身的内容。任何继承自 View 的子类都可以传递给 show 函数，就是所说的里氏替换。通过里氏替换，就可以自定义各式各样、千变万化的 View，然后传递给 Window，Window 负责组织 View，并将 View 显示到屏幕上。</p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>00.2 ANDROID 面向对象的六大原则——开闭原则</title>
      <link href="/1901/01/04/02%20DESIGN%20PATTERN/00.2%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"/>
      <url>/1901/01/04/02%20DESIGN%20PATTERN/00.2%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-73b422a93f178c2b.gif?imageMogr2/auto-orient/strip" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a><br>|<br><a href="https://xianxiaotao.github.io/1901/01/03/02%20DESIGN%20PATTERN/00.1%20ANDROID%20面向对象的六大原则——单一职责原则/" target="_blank" rel="external">第一篇：单一职责原则</a><br><a href="https://xianxiaotao.github.io/1901/01/04/02%20DESIGN%20PATTERN/00.2%20ANDROID%20面向对象的六大原则——开闭原则/" target="_blank" rel="external">第二篇：开闭原则</a><br><a href="https://xianxiaotao.github.io/1901/01/05/02%20DESIGN%20PATTERN/00.3%20ANDROID%20面向对象的六大原则——里氏替换原则/" target="_blank" rel="external">第三篇：里氏替换原则</a><br><a href="https://xianxiaotao.github.io/1901/01/06/02%20DESIGN%20PATTERN/00.4%20ANDROID%20面向对象的六大原则——依赖倒置原则/" target="_blank" rel="external">第四篇：依赖倒置原则</a><br><a href="https://xianxiaotao.github.io/1901/01/07/02%20DESIGN%20PATTERN/00.5%20ANDROID%20面向对象的六大原则——接口隔离原则/" target="_blank" rel="external">第五篇：接口隔离原则</a><br><a href="https://xianxiaotao.github.io/1901/01/08/02%20DESIGN%20PATTERN/00.6%20ANDROID%20面向对象的六大原则——迪米特原则/" target="_blank" rel="external">第六篇：迪米特原则</a></p></blockquote><p><strong>请使用双缓存技术（内存、SD 卡）继续优化图片加载器？</strong></p><p>第一篇中已经实现了内存缓存类 ImageCache.java，我们还需要增加一个 SD 卡缓存类 DiskCache.java。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.graphics.Bitmap;</div><div class="line">import android.graphics.BitmapFactory;</div><div class="line">import android.os.Environment;</div><div class="line">import android.text.TextUtils;</div><div class="line"></div><div class="line">import java.io.FileNotFoundException;</div><div class="line">import java.io.FileOutputStream;</div><div class="line">import java.io.IOException;</div><div class="line">import java.io.UnsupportedEncodingException;</div><div class="line">import java.security.MessageDigest;</div><div class="line">import java.security.NoSuchAlgorithmException;</div><div class="line"></div><div class="line">public class DiskCache &#123;</div><div class="line"></div><div class="line">    // 图片缓存 SD 卡目录</div><div class="line">    private static String CACHE_DIR =</div><div class="line">            Environment.getExternalStorageDirectory() + &quot;/&quot;;</div><div class="line"></div><div class="line">    // 从 SD 卡缓存中获取图片</div><div class="line">    public Bitmap get(String url) &#123;</div><div class="line">        return BitmapFactory.decodeFile(CACHE_DIR + urlToMd5(url));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 将图片缓存到 SD 卡中</div><div class="line">    public void put(String url, Bitmap bitmap) &#123;</div><div class="line">        FileOutputStream fileOutputStream = null;</div><div class="line">        try &#123;</div><div class="line">            fileOutputStream = new FileOutputStream(CACHE_DIR + urlToMd5(url));</div><div class="line">            bitmap.compress(Bitmap.CompressFormat.PNG, 100, fileOutputStream);</div><div class="line">        &#125; catch (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (fileOutputStream != null) &#123;</div><div class="line">                try &#123;</div><div class="line">                    fileOutputStream.close();</div><div class="line">                &#125; catch (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private String urlToMd5(String url) &#123;</div><div class="line">        if (TextUtils.isEmpty(url)) &#123;</div><div class="line">            return &quot;&quot;;</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">            MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);</div><div class="line">            byte[] bytes = md5.digest(url.getBytes(&quot;UTF-8&quot;));</div><div class="line">            StringBuilder hex = new StringBuilder();</div><div class="line">            for (byte b : bytes) &#123;</div><div class="line">                hex.append(Integer.toHexString(b &amp; 0xff));</div><div class="line">            &#125;</div><div class="line">            hex.append(&quot;.png&quot;);</div><div class="line">            return hex.toString();</div><div class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</div><div class="line">            throw new RuntimeException(&quot;NoSuchAlgorithmException&quot;, e);</div><div class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</div><div class="line">            throw new RuntimeException(&quot;UnsupportedEncodingException&quot;, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后修改 ImageLoader.java 源码进行测试，可使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line"></div><div class="line">    // 图片缓存</div><div class="line">    // private ImageCache mImageCache = new ImageCache();</div><div class="line">    private DiskCache mImageCache = new DiskCache();</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>接下来要实现的是：<strong>首先使用内存缓存，如果内存缓存没有图片再使用 SD 卡缓存，如果 SD 卡中也没有图片，最后才从网络上获取。</strong></p><p>于是新建一个双缓存类 DoubleCache.java，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class DoubleCache &#123;</div><div class="line"></div><div class="line">    private ImageCache mMemoryCache = new ImageCache();</div><div class="line">    private DiskCache mDiskCache = new DiskCache();</div><div class="line"></div><div class="line">    public Bitmap get(String url) &#123;</div><div class="line">        Bitmap bitmap = mMemoryCache.get(url);</div><div class="line">        if (bitmap == null) &#123;</div><div class="line">            bitmap = mDiskCache.get(url);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void put(String url, Bitmap bitmap) &#123;</div><div class="line">        mMemoryCache.put(url, bitmap);</div><div class="line">        mDiskCache.put(url, bitmap);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>虽然双缓存技术很优秀，但是我们最好提供 API，让使用者可以灵活选择缓存方式：只选内存缓存、只选 SD 卡缓存或者选择双缓存方式。而不合格的程序员则会提供如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line"></div><div class="line">    // 图片缓存</div><div class="line">    private ImageCache mImageCache = new ImageCache();</div><div class="line">    // SD 卡缓存</div><div class="line">    private DiskCache mDiskCache = new DiskCache();</div><div class="line">    // 双缓存</div><div class="line">    private DoubleCache mDoubleCache = new DoubleCache();</div><div class="line">    // true: 单独使用 SD 卡缓存; false: 单独使用内存缓存</div><div class="line">    private boolean isUseDiskCache = false;</div><div class="line">    // true: 使用双缓存</div><div class="line">    private boolean isUseDoubleCache = false;</div><div class="line"></div><div class="line">    public void displayImage(final String url, final ImageView imageView) &#123;</div><div class="line">        Bitmap bmp = null;</div><div class="line">        if (isUseDoubleCache) &#123;</div><div class="line">            bmp = mDoubleCache.get(url);</div><div class="line">        &#125; else if (isUseDiskCache) &#123;</div><div class="line">            bmp = mDiskCache.get(url);</div><div class="line">        &#125; else &#123;</div><div class="line">            bmp = mImageCache.get(url);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    public void useDiskCache(boolean useDiskCache) &#123;</div><div class="line">        isUseDiskCache = useDiskCache;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void useDoubleCache(boolean useDoubleCache) &#123;</div><div class="line">        isUseDoubleCache = useDoubleCache;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上述代码中，要加入新的缓存实现时都需要修改 ImageLoader 类，然后通过一个布尔变量让用户选择使用哪种缓存。因此，就使得在 ImageLoader 中存在各种 if-else 判断语句，通过这些判断来确定使用哪种缓存。随着这些逻辑的引入，代码越来越复杂、脆弱。如果不小心写错了某个 if 条件，那就需要更多的时间来排除，整个 ImageLoader 类也会变得越来越臃肿。最重要的是，用户不能自己实现缓存注入到 ImageLoader 中，可扩展性差。</p><p><strong>软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是对于修改是封闭的，这就是开放——关闭原则。</strong></p><p>也就是说，当软件需要变化时，我们应该尽量通过扩展的方式实现变化，而不是通过修改已有的代码来实现。根据这一个原则，我们可以画出如下所示的 UML 图。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-27a4841b8ee201ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>按照上图进行以下重构：</p><p><strong>提取抽象接口</strong>，用来抽象图片缓存的功能。其声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface ImageCache &#123;</div><div class="line">    Bitmap get(String url);</div><div class="line">    void put(String url, Bitmap bitmap);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ImageCache 接口简单定义了获取、缓存图片两个函数，缓存的 key 是图片的 url，值是图片本身。内存缓存、SD 卡缓存、双缓存都实现了该接口，我们看看这几个缓存实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">// 内存缓存 MemoryCache 类</div><div class="line">public class MemoryCache implements ImageCache &#123;</div><div class="line">    private LruCache&lt;String, Bitmap&gt; mImageCache;</div><div class="line"></div><div class="line">    public MemoryCache() &#123;</div><div class="line">        initImageCache();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initImageCache() &#123;</div><div class="line">        int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);</div><div class="line">        final int cacheSize = maxMemory / 4;</div><div class="line">        mImageCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class="line">            @Override</div><div class="line">            protected int sizeOf(@NonNull String key, @NonNull Bitmap value) &#123;</div><div class="line">                return ImageUtil.getBitmapSize(value) / 1024;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void put(@NonNull String url, @NonNull Bitmap bitmap) &#123;</div><div class="line">        mImageCache.put(url, bitmap);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Bitmap get(@NonNull String url) &#123;</div><div class="line">        return mImageCache.get(url);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// SD 卡缓存 DiskCache 类</div><div class="line">public class DiskCache implements ImageCache &#123;</div><div class="line">    private static String CACHE_DIR =</div><div class="line">            Environment.getExternalStorageDirectory() + &quot;/&quot;;</div><div class="line"></div><div class="line">    public Bitmap get(String url) &#123;</div><div class="line">        return BitmapFactory.decodeFile(CACHE_DIR </div><div class="line">                + ImageUtil.urlToMd5(url));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void put(String url, Bitmap bitmap) &#123;</div><div class="line">        FileOutputStream fileOutputStream = null;</div><div class="line">        try &#123;</div><div class="line">            fileOutputStream = new FileOutputStream(CACHE_DIR </div><div class="line">                    + ImageUtil.urlToMd5(url));</div><div class="line">            bitmap.compress(Bitmap.CompressFormat.PNG, 100, fileOutputStream);</div><div class="line">        &#125; catch (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (fileOutputStream != null) &#123;</div><div class="line">                try &#123;</div><div class="line">                    fileOutputStream.close();</div><div class="line">                &#125; catch (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 双缓存 DoubleCache 类</div><div class="line">public class DoubleCache implements ImageCache &#123;</div><div class="line">    private MemoryCache mMemoryCache = new MemoryCache();</div><div class="line">    private DiskCache mDiskCache = new DiskCache();</div><div class="line"></div><div class="line">    public Bitmap get(String url) &#123;</div><div class="line">        Bitmap bitmap = mMemoryCache.get(url);</div><div class="line">        if (bitmap == null) &#123;</div><div class="line">            bitmap = mDiskCache.get(url);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void put(String url, Bitmap bitmap) &#123;</div><div class="line">        mMemoryCache.put(url, bitmap);</div><div class="line">        mDiskCache.put(url, bitmap);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后重构 ImageLoader，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line"></div><div class="line">    // 图片缓存，默认内存缓存</div><div class="line">    private ImageCache mImageCache = new MemoryCache();</div><div class="line"></div><div class="line">    // 线程池，线程数量为 CPU 的数量</div><div class="line">    private ExecutorService mExecutorService = Executors.newFixedThreadPool(</div><div class="line">            Runtime.getRuntime().availableProcessors());</div><div class="line"></div><div class="line">    // UI Handler</div><div class="line">    private Handler mUiHandler = new Handler(Looper.getMainLooper());</div><div class="line">    </div><div class="line">    // 注入缓存实现</div><div class="line">    public void setImageCache(ImageCache cache) &#123;</div><div class="line">        mImageCache = cache;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void displayImage(final String url, final ImageView imageView) &#123;</div><div class="line">        Bitmap bitmap = mImageCache.get(url);</div><div class="line">        if (bitmap != null) &#123;</div><div class="line">            imageView.setImageBitmap(bitmap);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 内存中没有，去加载</div><div class="line">        submitLoadRequest(url, imageView);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void submitLoadRequest(final String url, </div><div class="line">                                   final ImageView imageView) &#123;</div><div class="line">        imageView.setTag(url);</div><div class="line">        mExecutorService.submit(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                Bitmap bitmap = ImageUtil.downloadImage(url);</div><div class="line">                if (bitmap == null) return;</div><div class="line">                if (url.equals(imageView.getTag())) &#123;</div><div class="line">                    updateImageView(imageView, bitmap);</div><div class="line">                &#125;</div><div class="line">                mImageCache.put(url, bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 通知界面更新显示图片</div><div class="line">    private void updateImageView(final ImageView imageView,</div><div class="line">                                 final Bitmap bitmap) &#123;</div><div class="line">        mUiHandler.post(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                imageView.setImageBitmap(bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>附工具类 ImageUtil.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">public class ImageUtil &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 下载图片</div><div class="line">     * @param imageUrl 图片链接</div><div class="line">     * @return Bitmap</div><div class="line">     */</div><div class="line">    public static Bitmap downloadImage(String imageUrl) &#123;</div><div class="line">        if (TextUtils.isEmpty(imageUrl)) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        Bitmap bitmap = null;</div><div class="line">        try &#123;</div><div class="line">            URL url = new URL(imageUrl);</div><div class="line">            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 计算图片大小</div><div class="line">     * @param bitmap 图片</div><div class="line">     * @return int</div><div class="line">     */</div><div class="line">    public static int getBitmapSize(Bitmap bitmap) &#123;</div><div class="line">        if (bitmap == null) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</div><div class="line">            return bitmap.getAllocationByteCount();</div><div class="line">        &#125;</div><div class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB_MR1) &#123;</div><div class="line">            return bitmap.getByteCount();</div><div class="line">        &#125;</div><div class="line">        return bitmap.getRowBytes() * bitmap.getHeight();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 将图片 url 转换成字符串，用作文件名称</div><div class="line">     * @param url</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public static String urlToMd5(String url) &#123;</div><div class="line">        if (TextUtils.isEmpty(url)) &#123;</div><div class="line">            return &quot;&quot;;</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">            MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);</div><div class="line">            byte[] bytes = md5.digest(url.getBytes(&quot;UTF-8&quot;));</div><div class="line">            StringBuilder builder = new StringBuilder();</div><div class="line">            for (byte b : bytes) &#123;</div><div class="line">                builder.append(Integer.toHexString(b &amp; 0xff));</div><div class="line">            &#125;</div><div class="line">            builder.append(&quot;.png&quot;);</div><div class="line">            return builder.toString();</div><div class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</div><div class="line">            throw new RuntimeException(&quot;NoSuchAlgorithmException&quot;, e);</div><div class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</div><div class="line">            throw new RuntimeException(&quot;UnsupportedEncodingException&quot;, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>经过此次重构，没有了那么多的 if-else 语句，没有了各种各样的缓存实现对象、布尔变量，代码确实清晰简洁。用户可以通过setImageCache(ImageCache cache) 函数设置缓存实现，也就是通常说的依赖注入。具体如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">ImageLoader imageLoader = new ImageLoader();</div><div class="line">// 使用内存缓存</div><div class="line">imageLoader.setImageCache(new MemoryCache());</div><div class="line">// 使用 SD 卡缓存</div><div class="line">imageLoader.setImageCache(new DiskCache());</div><div class="line">// 使用双缓存</div><div class="line">imageLoader.setImageCache(new DoubleCache());</div><div class="line">// 使用自定义的图片缓存实现</div><div class="line">imageLoader.setImageCache(new ImageCache() &#123;</div><div class="line">    @Override</div><div class="line">    public Bitmap get(String url) &#123;</div><div class="line">        return null; // 从缓存中获取图片</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void put(String url, Bitmap bitmap) &#123;</div><div class="line">        // 缓存图片</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>在上述代码中，通过 setImageCache(ImageCache cache) 方法注入不同的缓存实现，这样不仅能够使 ImageLoader 更简单、健壮，也使得 ImageLoader 的可扩展性、灵活性更高。MemoryCache、DiskCache、DoubleCache 缓存图片的具体实现完全不一样，但是，它们的一个特点是，都实现了 ImageCache 接口。当用户需要自定义实现缓存策略时，只需要新建一个实现 ImageCache 接口的类，然后构造该类的对象，并且通过 setImageCache 函数注入到 ImageLoader 中，这样 ImageLoader 就实现了千变万化的缓存策略，且扩展这些缓存策略并不会导致 ImageLoader 类的修改。</p><p>开闭原则指导我们，当软件需要变化时，应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。但是通过继承等方式添加新的实现，这会导致类型的膨胀以及历史遗留代码的冗余。在开发过程中需要自己结合具体情况进行考量。</p><hr><h3 id="开闭原则概述"><a href="#开闭原则概述" class="headerlink" title="开闭原则概述"></a>开闭原则概述</h3><hr><p><strong>软件实体应当对扩展开放，对修改关闭 (Software entities should be open for extension, but closed for modification)。</strong></p><p><strong>开闭原则</strong>是面向对象设计中“可复用设计”的基石，是设计模式最基本的法则。其他五大设计原则和 23 种设计模式都可以看做是开闭原则的实现方法和手段。</p><p>说的通俗一点就是，已经开发好的软件实体（如类、模块、函数），在升级迭代引入新功能时，不应该修改已有的代码，而是在已有代码的基础上，添加新代码来实现。</p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>00.1 ANDROID 面向对象的六大原则——单一职责原则</title>
      <link href="/1901/01/03/02%20DESIGN%20PATTERN/00.1%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"/>
      <url>/1901/01/03/02%20DESIGN%20PATTERN/00.1%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2c1e32dd007712db.gif?imageMogr2/auto-orient/strip" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a><br>|<br><a href="https://xianxiaotao.github.io/1901/01/03/02%20DESIGN%20PATTERN/00.1%20ANDROID%20面向对象的六大原则——单一职责原则/" target="_blank" rel="external">第一篇：单一职责原则</a><br><a href="https://xianxiaotao.github.io/1901/01/04/02%20DESIGN%20PATTERN/00.2%20ANDROID%20面向对象的六大原则——开闭原则/" target="_blank" rel="external">第二篇：开闭原则</a><br><a href="https://xianxiaotao.github.io/1901/01/05/02%20DESIGN%20PATTERN/00.3%20ANDROID%20面向对象的六大原则——里氏替换原则/" target="_blank" rel="external">第三篇：里氏替换原则</a><br><a href="https://xianxiaotao.github.io/1901/01/06/02%20DESIGN%20PATTERN/00.4%20ANDROID%20面向对象的六大原则——依赖倒置原则/" target="_blank" rel="external">第四篇：依赖倒置原则</a><br><a href="https://xianxiaotao.github.io/1901/01/07/02%20DESIGN%20PATTERN/00.5%20ANDROID%20面向对象的六大原则——接口隔离原则/" target="_blank" rel="external">第五篇：接口隔离原则</a><br><a href="https://xianxiaotao.github.io/1901/01/08/02%20DESIGN%20PATTERN/00.6%20ANDROID%20面向对象的六大原则——迪米特原则/" target="_blank" rel="external">第六篇：迪米特原则</a></p></blockquote><p><strong>请实现一个简易的图片加载器（ImageLoader）？</strong></p><p>以下是一个新手实现的图片加载器源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.graphics.Bitmap;</div><div class="line">import android.graphics.BitmapFactory;</div><div class="line">import android.os.Handler;</div><div class="line">import android.os.Looper;</div><div class="line">import android.text.TextUtils;</div><div class="line">import android.util.LruCache;</div><div class="line">import android.widget.ImageView;</div><div class="line"></div><div class="line">import java.net.HttpURLConnection;</div><div class="line">import java.net.URL;</div><div class="line">import java.util.concurrent.ExecutorService;</div><div class="line">import java.util.concurrent.Executors;</div><div class="line"></div><div class="line">public class ImageLoader &#123;</div><div class="line"></div><div class="line">    // 图片缓存</div><div class="line">    LruCache&lt;String, Bitmap&gt; mImageCache;</div><div class="line">    // 线程池，线程数量为 CPU 的数量</div><div class="line">    ExecutorService mExecutorService = Executors.newFixedThreadPool(</div><div class="line">            Runtime.getRuntime().availableProcessors());</div><div class="line">    // UI Handler</div><div class="line">    Handler mUiHandler = new Handler(Looper.getMainLooper());</div><div class="line"></div><div class="line">    public ImageLoader() &#123;</div><div class="line">        initImageCache();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 初始化内存缓存</div><div class="line">     */</div><div class="line">    private void initImageCache() &#123;</div><div class="line">        // 计算可用的最大内存</div><div class="line">        final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);</div><div class="line">        // 取四分之一的可用内存作为缓存</div><div class="line">        final int cacheSize = maxMemory / 4;</div><div class="line">        mImageCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class="line">            @Override</div><div class="line">            protected int sizeOf(String key, Bitmap bitmap) &#123;</div><div class="line">                return bitmap.getRowBytes() * bitmap.getHeight() / 1024;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 加载指定 url 的图片并显示</div><div class="line">     */</div><div class="line">    public void displayImage(final String url, final ImageView imageView) &#123;</div><div class="line">        // 先从内存中找</div><div class="line">        Bitmap bmp = mImageCache.get(url);</div><div class="line">        if (bmp != null) &#123;</div><div class="line">            imageView.setImageBitmap(bmp);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 内存中没有，去加载</div><div class="line">        imageView.setTag(url);</div><div class="line">        mExecutorService.submit(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                Bitmap bitmap = downloadImage(url);</div><div class="line">                if (bitmap == null) return;</div><div class="line">                if (url.equals(imageView.getTag())) &#123;</div><div class="line">                    updateImageView(imageView, bitmap);</div><div class="line">                &#125;</div><div class="line">                mImageCache.put(url, bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 通知界面更新显示图片</div><div class="line">     * @param imageView ImageView</div><div class="line">     * @param bitmap 位图</div><div class="line">     */</div><div class="line">    private void updateImageView(final ImageView imageView, </div><div class="line">                                 final Bitmap bitmap) &#123;</div><div class="line">        mUiHandler.post(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                imageView.setImageBitmap(bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 下载指定 url 的图片</div><div class="line">     * @param imageUrl 图片链接</div><div class="line">     * @return Bitmap</div><div class="line">     */</div><div class="line">    private Bitmap downloadImage(String imageUrl) &#123;</div><div class="line">        if (TextUtils.isEmpty(imageUrl)) return null;</div><div class="line"></div><div class="line">        Bitmap bitmap = null;</div><div class="line">        try &#123;</div><div class="line">            URL url = new URL(imageUrl);</div><div class="line">            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 动态申请权限</div><div class="line">requestRuntimePermission(new String[]&#123;&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&#125;, null);</div><div class="line">String url = &quot;https://upload-images.jianshu.io/upload_images/14186083-9bb468395ee3d048.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;;</div><div class="line">ImageView imageView = findViewById(R.id.image);</div><div class="line">new ImageLoader().displayImage(url, imageView);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-bc755e9afc10cbf3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片加载器"></p><blockquote><p>上述代码虽然满足功能需求，但是所有的功能代码都写在一个类中，这样随着功能的增多，ImageLoader 类会越来越大，代码也越来越负责，图片加载系统就越来越脆弱……</p></blockquote><p>我们可以参照<strong>单一职责原则</strong>，把 ImageLoader 拆分一下，让各个功能独立出来：</p><ul><li>ImageCache：用于处理图片缓存。</li><li>ImageUtil：图片工具类，如获取图片大小、下载图片等。</li></ul><p>改进后的源码：<br><strong>ImageLoader.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.graphics.Bitmap;</div><div class="line">import android.os.Handler;</div><div class="line">import android.os.Looper;</div><div class="line">import android.widget.ImageView;</div><div class="line"></div><div class="line">import java.util.concurrent.ExecutorService;</div><div class="line">import java.util.concurrent.Executors;</div><div class="line"></div><div class="line">public class ImageLoader &#123;</div><div class="line"></div><div class="line">    // 图片缓存</div><div class="line">    private ImageCache mImageCache = new ImageCache();</div><div class="line">    // 线程池，线程数量为 CPU 的数量</div><div class="line">    private ExecutorService mExecutorService = Executors.newFixedThreadPool(</div><div class="line">            Runtime.getRuntime().availableProcessors());</div><div class="line">    // UI Handler</div><div class="line">    private Handler mUiHandler = new Handler(Looper.getMainLooper());</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 加载指定 url 的图片并显示</div><div class="line">     */</div><div class="line">    public void displayImage(final String url, final ImageView imageView) &#123;</div><div class="line">        // 先从内存中找</div><div class="line">        Bitmap bmp = mImageCache.get(url);</div><div class="line">        if (bmp != null) &#123;</div><div class="line">            imageView.setImageBitmap(bmp);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 内存中没有，去加载</div><div class="line">        imageView.setTag(url);</div><div class="line">        mExecutorService.submit(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                Bitmap bitmap = ImageUtil.downloadImage(url);</div><div class="line">                if (bitmap == null) return;</div><div class="line">                if (url.equals(imageView.getTag())) &#123;</div><div class="line">                    updateImageView(imageView, bitmap);</div><div class="line">                &#125;</div><div class="line">                mImageCache.put(url, bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 通知界面更新显示图片</div><div class="line">     * @param imageView ImageView</div><div class="line">     * @param bitmap 位图</div><div class="line">     */</div><div class="line">    private void updateImageView(final ImageView imageView,</div><div class="line">                                 final Bitmap bitmap) &#123;</div><div class="line">        mUiHandler.post(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                imageView.setImageBitmap(bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>ImageCache.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.graphics.Bitmap;</div><div class="line"></div><div class="line">import androidx.annotation.NonNull;</div><div class="line">import androidx.collection.LruCache;</div><div class="line"></div><div class="line">public class ImageCache &#123;</div><div class="line"></div><div class="line">    // 图片缓存</div><div class="line">    private LruCache&lt;String, Bitmap&gt; mImageCache;</div><div class="line"></div><div class="line">    public ImageCache() &#123;</div><div class="line">        initImageCache();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initImageCache() &#123;</div><div class="line">        // 计算可使用的最大内存</div><div class="line">        int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);</div><div class="line">        // 取四分之一的可用内存作为缓存</div><div class="line">        final int cacheSize = maxMemory / 4;</div><div class="line">        mImageCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class="line">            @Override</div><div class="line">            protected int sizeOf(@NonNull String key, @NonNull Bitmap value) &#123;</div><div class="line">                return ImageUtil.getBitmapSize(value) / 1024;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void put(@NonNull String url, @NonNull Bitmap bitmap) &#123;</div><div class="line">        mImageCache.put(url, bitmap);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Bitmap get(@NonNull String url) &#123;</div><div class="line">        return mImageCache.get(url);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>ImageUtil.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.graphics.Bitmap;</div><div class="line">import android.graphics.BitmapFactory;</div><div class="line">import android.os.Build;</div><div class="line">import android.text.TextUtils;</div><div class="line"></div><div class="line">import java.net.HttpURLConnection;</div><div class="line">import java.net.URL;</div><div class="line"></div><div class="line">public class ImageUtil &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 下载图片</div><div class="line">     * @param imageUrl 图片链接</div><div class="line">     * @return Bitmap</div><div class="line">     */</div><div class="line">    public static Bitmap downloadImage(String imageUrl) &#123;</div><div class="line">        if (TextUtils.isEmpty(imageUrl)) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        Bitmap bitmap = null;</div><div class="line">        try &#123;</div><div class="line">            URL url = new URL(imageUrl);</div><div class="line">            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 计算图片大小</div><div class="line">     * @param bitmap 图片</div><div class="line">     * @return int</div><div class="line">     */</div><div class="line">    public static int getBitmapSize(Bitmap bitmap) &#123;</div><div class="line">        if (bitmap == null) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</div><div class="line">            return bitmap.getAllocationByteCount();</div><div class="line">        &#125;</div><div class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB_MR1) &#123;</div><div class="line">            return bitmap.getByteCount();</div><div class="line">        &#125;</div><div class="line">        return bitmap.getRowBytes() * bitmap.getHeight();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="单一职责原则概述"><a href="#单一职责原则概述" class="headerlink" title="单一职责原则概述"></a>单一职责原则概述</h3><hr><p><strong>应该有且仅有一个原因引起类的变更 (There should never be more than one reason for a class to change)。</strong></p><p>单一职责原则为我们提供了一个编写程序的准则，要求我们在编写类，抽象类，接口时，要使其功能职责单一纯碎，将导致其变更的因素缩减到最少。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起。一个职责的变化可能会影响或损坏其他职责的功能。而且职责越多，这个类变化的几率就会越大，类的稳定性就会越低。</p><p>在软件开发中，经常会遇到一个功能类 T 负责两个不同的职责：职责 P1，职责 P2。现因需求变更需要更改职责 P1 来满足新的业务需求，当我们实现完成后，发现因更改职责 P1 竟导致原本能够正常运行的职责 P2 发生故障。而修复职责 P2 又不得不更改职责 P1 的逻辑，这便是因为功能类 T 的职责不够单一，职责 P1 与职责 P2 耦合在一起导致的。</p><h3 id="附：动态权限申请代码"><a href="#附：动态权限申请代码" class="headerlink" title="附：动态权限申请代码"></a>附：动态权限申请代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.content.pm.PackageManager;</div><div class="line"></div><div class="line">import androidx.annotation.NonNull;</div><div class="line">import androidx.appcompat.app.AppCompatActivity;</div><div class="line">import androidx.core.app.ActivityCompat;</div><div class="line">import androidx.core.content.ContextCompat;</div><div class="line"></div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class BaseActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private PermissionListener mListener;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 权限申请</div><div class="line">     * @param permissions 待申请的权限集合</div><div class="line">     * @param listener  申请结果监听事件</div><div class="line">     */</div><div class="line">    protected void requestRuntimePermission(String[] permissions,</div><div class="line">                                            PermissionListener listener)&#123;</div><div class="line">        this.mListener = listener;</div><div class="line"></div><div class="line">        // 用于存放为授权的权限</div><div class="line">        List&lt;String&gt; permissionList = new ArrayList&lt;&gt;();</div><div class="line">        // 遍历传递过来的权限集合</div><div class="line">        for (String permission : permissions) &#123;</div><div class="line">            // 判断是否已经授权</div><div class="line">            if (ContextCompat.checkSelfPermission(this,permission)</div><div class="line">                    != PackageManager.PERMISSION_GRANTED)&#123;</div><div class="line">                // 未授权，则加入待授权的权限集合中</div><div class="line">                permissionList.add(permission);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 判断集合，如果集合不为空，则需要去授权</div><div class="line">        if (!permissionList.isEmpty()) &#123;</div><div class="line">            ActivityCompat.requestPermissions(this,</div><div class="line">                    permissionList.toArray(new String[permissionList.size()]),</div><div class="line">                    1);</div><div class="line">        &#125;</div><div class="line">        // 为空，则已经全部授权</div><div class="line">        else &#123;</div><div class="line">            if (listener != null) &#123;</div><div class="line">                listener.onGranted();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 权限申请结果</div><div class="line">     * @param requestCode  请求码</div><div class="line">     * @param permissions  所有的权限集合</div><div class="line">     * @param grantResults 授权结果集合</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void onRequestPermissionsResult(int requestCode,</div><div class="line">                                           @NonNull String[] permissions,</div><div class="line">                                           @NonNull int[] grantResults) &#123;</div><div class="line">        super.onRequestPermissionsResult(requestCode, permissions, </div><div class="line">                grantResults);</div><div class="line">        if (requestCode == 1 &amp;&amp; grantResults.length &gt; 0) &#123;</div><div class="line">            // 被用户拒绝的权限集合</div><div class="line">            List&lt;String&gt; deniedPermissions = new ArrayList&lt;&gt;();</div><div class="line">            // 用户通过的权限集合</div><div class="line">            List&lt;String&gt; grantedPermissions = new ArrayList&lt;&gt;();</div><div class="line">            for (int i = 0; i &lt; grantResults.length; i++) &#123;</div><div class="line">                // 获取授权结果，这是一个int类型的值</div><div class="line">                int grantResult = grantResults[i];</div><div class="line"></div><div class="line">                // 用户拒绝授权的权限</div><div class="line">                if (grantResult != PackageManager.PERMISSION_GRANTED)&#123;</div><div class="line">                    String permission = permissions[i];</div><div class="line">                    deniedPermissions.add(permission);</div><div class="line">                &#125;</div><div class="line">                // 用户同意的权限</div><div class="line">                else &#123;</div><div class="line">                    String permission = permissions[i];</div><div class="line">                    grantedPermissions.add(permission);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // 用户拒绝权限为空</div><div class="line">            if (deniedPermissions.isEmpty()) &#123;</div><div class="line">                if(mListener != null)&#123;</div><div class="line">                    mListener.onGranted();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            // 不为空</div><div class="line">            else &#123;</div><div class="line">                if(mListener != null)&#123;</div><div class="line">                    // 回调授权成功的接口</div><div class="line">                    mListener.onDenied(deniedPermissions);</div><div class="line">                    // 回调授权失败的接口</div><div class="line">                    mListener.onGranted(grantedPermissions);</div><div class="line">                    mListener.onDenied();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PermissionListener.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public interface PermissionListener &#123;</div><div class="line">    // 授权成功</div><div class="line">    void onGranted();</div><div class="line">    // 授权部分</div><div class="line">    void onGranted(List&lt;String&gt; grantedPermission);</div><div class="line">    // 拒绝授权</div><div class="line">    void onDenied(List&lt;String&gt; deniedPermission);</div><div class="line">    // 授权失败</div><div class="line">    void onDenied();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>00 设计模式概述</title>
      <link href="/1901/01/02/02%20DESIGN%20PATTERN/00%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"/>
      <url>/1901/01/02/02%20DESIGN%20PATTERN/00%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-567aaeb02a63c644.gif?imageMogr2/auto-orient/strip" alt=""></p><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">返回设计模式博客目录</a></p></blockquote><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><hr><p>“设计模式”这个术语最初并不是出现在软件设计中，而是被用于建筑领域的设计中。</p><p>直到 1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）一书，在本教程中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）匿名著称。</p><h4 id="1-1-软件设计模式的概念"><a href="#1-1-软件设计模式的概念" class="headerlink" title="1.1 软件设计模式的概念"></a>1.1 软件设计模式的概念</h4><p>软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。</p><h4 id="1-2-学习设计模式的意义"><a href="#1-2-学习设计模式的意义" class="headerlink" title="1.2 学习设计模式的意义"></a>1.2 学习设计模式的意义</h4><p><strong>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。</strong>正确使用设计模式具有以下优点。</p><ul><li>可以提高程序员的思维能力、编程能力和设计能力。</li><li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li></ul><h3 id="二、23-种设计模式"><a href="#二、23-种设计模式" class="headerlink" title="二、23 种设计模式"></a>二、23 种设计模式</h3><hr><h4 id="2-1-分类"><a href="#2-1-分类" class="headerlink" title="2.1 分类"></a>2.1 分类</h4><p>设计模式有两种分类方法，即根据模式的目的来分和根据模式的作用的范围来分。</p><ul><li>根据目的来分<br>根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。<ul><li>创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</li><li>结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</li><li>行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</li></ul></li><li>根据作用范围来分<br>根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。<ul><li>类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。</li><li>对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。</li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">范围\目的</th><th style="text-align:center">创建型模式</th><th style="text-align:center">结构型模式</th><th style="text-align:center">行为型模式</th></tr></thead><tbody><tr><td style="text-align:center">类模式</td><td style="text-align:center">工厂方法</td><td style="text-align:center">(类）适配器</td><td style="text-align:center">模板方法、解释器</td></tr><tr><td style="text-align:center">对象模式</td><td style="text-align:center">单例<br>原型<br>抽象工厂<br>建造者</td><td style="text-align:center">代理<br>（对象）适配器<br>桥接<br>装饰<br>外观<br>享元<br>组合</td><td style="text-align:center">策略<br>命令<br>职责链<br>状态<br>观察者<br>中介者<br>迭代器<br>访问者<br>备忘录</td></tr></tbody></table></div><h4 id="2-2-功能"><a href="#2-2-功能" class="headerlink" title="2.2 功能"></a>2.2 功能</h4><ol><li>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li><li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li><li>工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li><li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li><li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li><li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li><li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li><li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</li><li>装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。</li><li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li><li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li><li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li><li>模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li><li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li><li>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li><li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li><li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li><li>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li><li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li><li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li><li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li><li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li><li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li></ol><p>必须指出，这 23 种设计模式不是孤立存在的，很多模式之间存在一定的关联关系，在大的系统开发中常常同时使用多种设计模式，希望读者认真学好它们。</p><h3 id="三、六大原则"><a href="#三、六大原则" class="headerlink" title="三、六大原则"></a>三、六大原则</h3><hr><h4 id="3-1-单一职责原则"><a href="#3-1-单一职责原则" class="headerlink" title="3.1 单一职责原则"></a>3.1 单一职责原则</h4><p>单一职责原则 SRP（Single Responsibility Principle)：<strong>一个类只负责一个功能领域的相应职责，即就一个类而言，应该只有一个引起它变化的原因。</strong></p><p>单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。</p><h4 id="3-2-开闭原则"><a href="#3-2-开闭原则" class="headerlink" title="3.2 开闭原则"></a>3.2 开闭原则</h4><p>开闭原则 OCP（Open-Closed Principle）：<strong>一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</strong></p><p>在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。</p><p>任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。</p><p>为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。</p><h4 id="3-3-里氏替换原则"><a href="#3-3-里氏替换原则" class="headerlink" title="3.3 里氏替换原则"></a>3.3 里氏替换原则</h4><p>里氏替换原则 LSP（Liskov Substitution Principle）：<strong>所有引用父类的地方必须能透明地使用其子类的对象。</strong></p><p>里氏替换原则告诉我们：在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象，它不一定能够使用基类对象。</p><p>里氏替换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p><p>在使用里氏替换原则时需要注意如下几个问题：</p><ul><li>子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏替换原则，为了保证系统的扩展性，在程序中通常使用父类类进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。</li><li>运用里氏替换原则时，尽量把父类设计为抽象类或接口，让子类继承父类或实现父接口，并实现在父类中的声明的方法，运行时，子类实例替换父类实例，方便扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过一个新的子类来实现。</li><li>Java 语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏替换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。</li></ul><h4 id="3-4-依赖倒置原则"><a href="#3-4-依赖倒置原则" class="headerlink" title="3.4 依赖倒置原则"></a>3.4 依赖倒置原则</h4><p>依赖倒置原则 DIP（Dependency Inversion Principle）：<strong>抽象不应该依赖于细节，细节应当依赖于抽象，要针对接口编程，而不是针对实现编程。</strong></p><p>依赖倒置原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口或抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。</p><p>在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。</p><p>在实现依赖倒置原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入（当一个对象要与其他对象发生依赖关系时，通过抽闲来注入所依赖的对象。）的方式注入到其他对象中。</p><h4 id="3-5-接口隔离原则"><a href="#3-5-接口隔离原则" class="headerlink" title="3.5 接口隔离原则"></a>3.5 接口隔离原则</h4><p>接口隔离原则 ISP（Interface Segregation Principle）：<strong>使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</strong></p><p>根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。</p><p>这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。</p><p>对于这两种不同的含义，ISP的表达方式以及含义都有所不同：</p><ul><li>当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。</li><li>如果理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来并不方便，为了使接口的职责单一，需要将大借口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为”定制服务“，即为不同的客户端提供宽窄不同的接口。</li></ul><p>在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。</p><h4 id="3-6-迪米特法则"><a href="#3-6-迪米特法则" class="headerlink" title="3.6 迪米特法则"></a>3.6 迪米特法则</h4><p>迪米特法则 LoD（Law of Demeter）：<strong>一个软件实体应当尽可能少地与其他实体发生相互作用。</strong></p><p>如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。</p><p>迪米特法则还有几种定义形式，包括：不要和”陌生人“说话，只与你的直接朋友通信等，在迪米特法则中，对于一个对象，其朋友包括一下几类：</p><ul><li>当前对象本身</li><li>以参数形式传入到当前对象方法中的对象</li><li>当前对象的成员对象</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友</li><li>当前对象所创建的对象</li></ul><p>任何一个对象，如果满足上面的条件之一，就是当前对象的”朋友“，否则就是”陌生人“。在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与”陌生人“发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。</p><p>迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用，即通过引入一个合理的第三者来降低现有对象之间的耦合度。</p><p>在将迪米特法则运用到系统设计中时，要注意下面几点：</p><ul><li>在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及。</li><li>在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限。</li><li>在类的设计上，只要有可能，一个类型应当设计成不变类。</li><li>在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</li></ul><h3 id="四、UML中的类图"><a href="#四、UML中的类图" class="headerlink" title="四、UML中的类图"></a>四、UML中的类图</h3><hr><h4 id="4-1-类、接口和类图"><a href="#4-1-类、接口和类图" class="headerlink" title="4.1 类、接口和类图"></a>4.1 类、接口和类图</h4><h5 id="4-1-1-类"><a href="#4-1-1-类" class="headerlink" title="4.1.1 类"></a>4.1.1 类</h5><p>类（Class）是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。在 UML 中，类使用包含类名、属性和操作且带有分隔线的矩形来表示。</p><ul><li>类名（Name）是一个字符串，例如，Student。</li><li>属性（Attribute）是指类的特性，即类的成员变量。UML 按以下格式表示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[可见性]属性名:类型[=默认值]</div></pre></td></tr></table></figure></li></ul><p>例如：-name:String</p><blockquote><p>注意：“可见性”表示该属性对类外的元素是否可见，包括公有（Public）、私有（Private）、受保护（Protected）和朋友（Friendly）4 种，在类图中分别用符号+、-、#、~表示。</p></blockquote><ul><li>操作（Operations）是类的任意一个实例对象都可以使用的行为，是类的成员方法。UML 按以下格式表示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[可见性]名称(参数列表)[:返回类型]</div></pre></td></tr></table></figure></li></ul><p>例如：+display():void。</p><p>下图所示是学生类的 UML 表示。</p><p><img src="http://c.biancheng.net/uploads/allimg/181112/3-1Q1121K933555.gif" alt=""></p><h5 id="4-1-2-接口"><a href="#4-1-2-接口" class="headerlink" title="4.1.2 接口"></a>4.1.2 接口</h5><p>接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。在 UML 中，接口使用一个带有名称的小圆圈来进行表示。</p><p><img src="http://c.biancheng.net/uploads/allimg/181112/3-1Q1121K9493J.gif" alt=""></p><h5 id="4-1-3-类图"><a href="#4-1-3-类图" class="headerlink" title="4.1.3 类图"></a>4.1.3 类图</h5><p>类图（ClassDiagram）是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。它主要用于描述软件系统的结构化设计，帮助人们简化对软件系统的理解，它是系统分析与设计阶段的重要产物，也是系统编码与测试的重要模型依据。</p><p>类图中的类可以通过某种编程 语言直接实现。类图在软件系统开发的整个生命周期都是有效的，它是面向对象系统的建模中最常见的图。下图所示是“计算长方形和圆形的周长与面积”的类图，图形接口有计算面积和周长的抽象方法，长方形和圆形实现这两个方法供访问类调用。</p><p><img src="http://c.biancheng.net/uploads/allimg/181112/3-1Q1121P6195T.gif" alt=""></p><h4 id="4-2-类之间的关系"><a href="#4-2-类之间的关系" class="headerlink" title="4.2 类之间的关系"></a>4.2 类之间的关系</h4><p>在软件系统中，类不是孤立存在的，类与类之间存在各种关系。根据类与类之间的耦合度从弱到强排列，UML 中的类图有以下几种关系：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。</p><h5 id="4-2-1-依赖关系"><a href="#4-2-1-依赖关系" class="headerlink" title="4.2.1 依赖关系"></a>4.2.1 依赖关系</h5><p>依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p><p>在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是人与手机的关系图，人通过手机的语音传送方法打电话。</p><p><img src="http://c.biancheng.net/uploads/allimg/181112/3-1Q1121PA2Y5.gif" alt=""></p><h5 id="4-2-2-关联关系"><a href="#4-2-2-关联关系" class="headerlink" title="4.2.2 关联关系"></a>4.2.2 关联关系</h5><p>关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。</p><p>关联可以是双向的，也可以是单向的。在 UML 类图中，双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。也可以在关联线的两端标注角色名，代表两种不同的角色。</p><p>在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系。下图所示是老师和学生的关系图，每个老师可以教多个学生，每个学生也可向多个老师学，他们是双向关联。</p><p><img src="http://c.biancheng.net/uploads/allimg/181112/3-1Q1121Q5115Q.gif" alt=""></p><h5 id="4-2-3-聚合关系"><a href="#4-2-3-聚合关系" class="headerlink" title="4.2.3 聚合关系"></a>4.2.3 聚合关系</h5><p>聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。</p><p>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</p><p>在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图。</p><p><img src="http://c.biancheng.net/uploads/allimg/181112/3-1Q1121Q541410.gif" alt=""></p><h5 id="4-2-4-组合关系"><a href="#4-2-4-组合关系" class="headerlink" title="4.2.4 组合关系"></a>4.2.4 组合关系</h5><p>组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 cxmtains-a 关系。</p><p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p><p>在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图。</p><p><img src="http://c.biancheng.net/uploads/allimg/181112/3-1Q1121QFD27.gif" alt=""></p><h5 id="4-2-5-泛化（继承）关系"><a href="#4-2-5-泛化（继承）关系" class="headerlink" title="4.2.5 泛化（继承）关系"></a>4.2.5 泛化（继承）关系</h5><p>泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。</p><p>在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/181112/3-1Q1121Q62C57.gif" alt=""></p><h5 id="4-2-6-实现关系"><a href="#4-2-6-实现关系" class="headerlink" title="4.2.6 实现关系"></a>4.2.6 实现关系</h5><p>实现（Realization）关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p><p>在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如下图所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/181112/3-1Q1121QI4317.gif" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式博客目录</title>
      <link href="/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/"/>
      <url>/1901/01/01/02%20DESIGN%20PATTERN/0%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-12abd0a1bd503c70.gif?imageMogr2/auto-orient/strip" width="100%"></p><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/02/02%20DESIGN%20PATTERN/00%20设计模式概述/" target="_blank" rel="external">00 设计模式概述</a></p></blockquote><h3 id="原则："><a href="#原则：" class="headerlink" title="原则："></a>原则：</h3><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/03/02%20DESIGN%20PATTERN/00.1%20ANDROID%20面向对象的六大原则——单一职责原则/" target="_blank" rel="external">00.1 ANDROID 面向对象的六大原则——单一职责原则</a><br><a href="https://xianxiaotao.github.io/1901/01/04/02%20DESIGN%20PATTERN/00.2%20ANDROID%20面向对象的六大原则——开闭原则/" target="_blank" rel="external">00.2 ANDROID 面向对象的六大原则——开闭原则</a><br><a href="https://xianxiaotao.github.io/1901/01/05/02%20DESIGN%20PATTERN/00.3%20ANDROID%20面向对象的六大原则——里氏替换原则/" target="_blank" rel="external">00.3 ANDROID 面向对象的六大原则——里氏替换原则</a><br><a href="https://xianxiaotao.github.io/1901/01/06/02%20DESIGN%20PATTERN/00.4%20ANDROID%20面向对象的六大原则——依赖倒置原则/" target="_blank" rel="external">00.4 ANDROID 面向对象的六大原则——依赖倒置原则</a><br><a href="https://xianxiaotao.github.io/1901/01/07/02%20DESIGN%20PATTERN/00.5%20ANDROID%20面向对象的六大原则——接口隔离原则/" target="_blank" rel="external">00.5 ANDROID 面向对象的六大原则——接口隔离原则</a><br><a href="https://xianxiaotao.github.io/1901/01/08/02%20DESIGN%20PATTERN/00.6%20ANDROID%20面向对象的六大原则——迪米特原则/" target="_blank" rel="external">00.6 ANDROID 面向对象的六大原则——迪米特原则</a></p></blockquote><h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3><div class="table-container"><table><thead><tr><th style="text-align:center">范围\目的</th><th style="text-align:center">创建型模式</th><th style="text-align:center">结构型模式</th><th style="text-align:center">行为型模式</th></tr></thead><tbody><tr><td style="text-align:center">类模式</td><td style="text-align:center"><a href="https://xianxiaotao.github.io/1901/01/12/02%20DESIGN%20PATTERN/04%20设计模式——工厂方法模式/" target="_blank" rel="external">工厂方法</a></td><td style="text-align:center"><a href="https://xianxiaotao.github.io/1901/01/27/02%20DESIGN%20PATTERN/19%20设计模式——适配器模式/" target="_blank" rel="external">(类）适配器</a></td><td style="text-align:center"><a href="https://xianxiaotao.github.io/1901/01/22/02%20DESIGN%20PATTERN/14%20设计模式——模板方法模式/" target="_blank" rel="external">模板方法</a><br><a href="https://xianxiaotao.github.io/1901/01/17/02%20DESIGN%20PATTERN/09%20设计模式——解释器模式/" target="_blank" rel="external">解释器</a></td></tr><tr><td style="text-align:center">对象模式</td><td style="text-align:center"><a href="https://xianxiaotao.github.io/1901/01/09/02%20DESIGN%20PATTERN/01%20设计模式——单例模式/" target="_blank" rel="external">单例</a><br><a href="https://xianxiaotao.github.io/1901/01/11/02%20DESIGN%20PATTERN/03%20设计模式——原型模式" target="_blank" rel="external">原型</a><br><a href="https://xianxiaotao.github.io/1901/01/13/02%20DESIGN%20PATTERN/05%20设计模式——抽象工厂模式/" target="_blank" rel="external">抽象工厂</a><br><a href="https://xianxiaotao.github.io/1901/01/10/02%20DESIGN%20PATTERN/02%20设计模式——建造者模式/" target="_blank" rel="external">建造者</a></td><td style="text-align:center"><a href="https://xianxiaotao.github.io/1901/01/25/02%20DESIGN%20PATTERN/17%20设计模式——代理模式/" target="_blank" rel="external">代理</a><br><a href="https://xianxiaotao.github.io/1901/01/27/02%20DESIGN%20PATTERN/19%20设计模式——适配器模式/" target="_blank" rel="external">（对象）适配器</a><br><a href="https://xianxiaotao.github.io/1901/01/02/03/02%20DESIGN%20PATTERN/23%20设计模式——桥接模式/" target="_blank" rel="external">桥接</a><br><a href="https://xianxiaotao.github.io/1901/01/28/02%20DESIGN%20PATTERN/20%20设计模式——装饰模式/" target="_blank" rel="external">装饰</a><br><a href="https://xianxiaotao.github.io/1901/02/02/02%20DESIGN%20PATTERN/22%20设计模式——外观模式/" target="_blank" rel="external">外观</a><br><a href="https://xianxiaotao.github.io/1901/02/01/02%20DESIGN%20PATTERN/21%20设计模式——享元模式/" target="_blank" rel="external">享元</a><br><a href="https://xianxiaotao.github.io/1901/01/26/02%20DESIGN%20PATTERN/18%20设计模式——组合模式/" target="_blank" rel="external">组合</a></td><td style="text-align:center"><a href="https://xianxiaotao.github.io/1901/01/14/02%20DESIGN%20PATTERN/06%20设计模式——策略模式/" target="_blank" rel="external">策略</a><br><a href="https://xianxiaotao.github.io/1901/01/18/02%20DESIGN%20PATTERN/10%20设计模式——命令模式/" target="_blank" rel="external">命令</a><br><a href="https://xianxiaotao.github.io/1901/01/16/02%20DESIGN%20PATTERN/08%20设计模式——责任链模式/" target="_blank" rel="external">责任链</a><br><a href="https://xianxiaotao.github.io/1901/01/15/02%20DESIGN%20PATTERN/07%20设计模式——状态模式/" target="_blank" rel="external">状态</a><br><a href="https://xianxiaotao.github.io/1901/01/19/02%20DESIGN%20PATTERN/11%20设计模式——观察者模式/" target="_blank" rel="external">观察者</a><br><a href="https://xianxiaotao.github.io/1901/01/24/02%20DESIGN%20PATTERN/16%20设计模式——中介者模式/" target="_blank" rel="external">中介者</a><br><a href="https://xianxiaotao.github.io/1901/01/21/02%20DESIGN%20PATTERN/13%20设计模式——迭代器模式/" target="_blank" rel="external">迭代器</a><br><a href="https://xianxiaotao.github.io/1901/01/23/02%20DESIGN%20PATTERN/15%20设计模式——访问者模式/" target="_blank" rel="external">访问者</a><br><a href="https://xianxiaotao.github.io/1901/01/20/02%20DESIGN%20PATTERN/12%20设计模式——备忘录模式/" target="_blank" rel="external">备忘录</a></td></tr></tbody></table></div><h3 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h3><blockquote><p><a href="https://xianxiaotao.github.io/1901/01/09/02%20DESIGN%20PATTERN/01%20设计模式——单例模式/" target="_blank" rel="external">01 设计模式——单例模式</a><br><a href="https://xianxiaotao.github.io/1901/01/10/02%20DESIGN%20PATTERN/02%20设计模式——建造者模式/" target="_blank" rel="external">02 设计模式——建造者模式</a><br><a href="https://xianxiaotao.github.io/1901/01/11/02%20DESIGN%20PATTERN/03%20设计模式——原型模式" target="_blank" rel="external">03 设计模式——原型模式</a><br><a href="https://xianxiaotao.github.io/1901/01/12/02%20DESIGN%20PATTERN/04%20设计模式——工厂方法模式/" target="_blank" rel="external">04 设计模式——工厂方法模式</a><br><a href="https://xianxiaotao.github.io/1901/01/13/02%20DESIGN%20PATTERN/05%20设计模式——抽象工厂模式/" target="_blank" rel="external">05 设计模式——抽象工厂模式</a><br><a href="https://xianxiaotao.github.io/1901/01/14/02%20DESIGN%20PATTERN/06%20设计模式——策略模式/" target="_blank" rel="external">06 设计模式——策略模式</a><br><a href="https://xianxiaotao.github.io/1901/01/15/02%20DESIGN%20PATTERN/07%20设计模式——状态模式/" target="_blank" rel="external">07 设计模式——状态模式</a><br><a href="https://xianxiaotao.github.io/1901/01/16/02%20DESIGN%20PATTERN/08%20设计模式——责任链模式/" target="_blank" rel="external">08 设计模式——责任链模式</a><br><a href="https://xianxiaotao.github.io/1901/01/17/02%20DESIGN%20PATTERN/09%20设计模式——解释器模式/" target="_blank" rel="external">09 设计模式——解释器模式</a><br><a href="https://xianxiaotao.github.io/1901/01/18/02%20DESIGN%20PATTERN/10%20设计模式——命令模式/" target="_blank" rel="external">10 设计模式——命令模式</a><br><a href="https://xianxiaotao.github.io/1901/01/19/02%20DESIGN%20PATTERN/11%20设计模式——观察者模式/" target="_blank" rel="external">11 设计模式——观察者模式</a><br><a href="https://xianxiaotao.github.io/1901/01/20/02%20DESIGN%20PATTERN/12%20设计模式——备忘录模式/" target="_blank" rel="external">12 设计模式——备忘录模式</a><br><a href="https://xianxiaotao.github.io/1901/01/21/02%20DESIGN%20PATTERN/13%20设计模式——迭代器模式/" target="_blank" rel="external">13 设计模式——迭代器模式</a><br><a href="https://xianxiaotao.github.io/1901/01/22/02%20DESIGN%20PATTERN/14%20设计模式——模板方法模式/" target="_blank" rel="external">14 设计模式——模板方法模式</a><br><a href="https://xianxiaotao.github.io/1901/01/23/02%20DESIGN%20PATTERN/15%20设计模式——访问者模式/" target="_blank" rel="external">15 设计模式——访问者模式</a><br><a href="https://xianxiaotao.github.io/1901/01/24/02%20DESIGN%20PATTERN/16%20设计模式——中介者模式/" target="_blank" rel="external">16 设计模式——中介者模式</a><br><a href="https://xianxiaotao.github.io/1901/01/25/02%20DESIGN%20PATTERN/17%20设计模式——代理模式/" target="_blank" rel="external">17 设计模式——代理模式</a><br><a href="https://xianxiaotao.github.io/1901/01/26/02%20DESIGN%20PATTERN/18%20设计模式——组合模式/" target="_blank" rel="external">18 设计模式——组合模式</a><br><a href="https://xianxiaotao.github.io/1901/01/27/02%20DESIGN%20PATTERN/19%20设计模式——适配器模式/" target="_blank" rel="external">19 设计模式——适配器模式</a><br><a href="https://xianxiaotao.github.io/1901/01/28/02%20DESIGN%20PATTERN/20%20设计模式——装饰模式/" target="_blank" rel="external">20 设计模式——装饰模式</a><br><a href="https://xianxiaotao.github.io/1901/02/01/02%20DESIGN%20PATTERN/21%20设计模式——享元模式/" target="_blank" rel="external">21 设计模式——享元模式</a><br><a href="https://xianxiaotao.github.io/1901/02/02/02%20DESIGN%20PATTERN/22%20设计模式——外观模式/" target="_blank" rel="external">22 设计模式——外观模式</a><br><a href="https://xianxiaotao.github.io/1901/01/02/03/02%20DESIGN%20PATTERN/23%20设计模式——桥接模式/" target="_blank" rel="external">23 设计模式——桥接模式</a></p></blockquote><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><blockquote><p><a href="https://xianxiaotao.github.io/1901/03/01/02%20DESIGN%20PATTERN/31%20设计模式实际应用一/" target="_blank" rel="external">31 设计模式实际应用一</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DESIGN PATTERN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CATALOG </tag>
            
            <tag> DESIGN PATTERN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA | 多线程断点下载</title>
      <link href="/1900/03/03/01%20JAVA/JAVA%20%7C%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%AD%E7%82%B9%E4%B8%8B%E8%BD%BD/"/>
      <url>/1900/03/03/01%20JAVA/JAVA%20%7C%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%AD%E7%82%B9%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>基本原理：利用URLConnection获取要下载文件的长度、头部等相关信息，并设置响应的头部信息。并且通过URLConnection获取输入流，将文件分成指定的块，每一块单独开辟一个线程完成数据的读取、写入。通过输入流读取下载文件的信息，然后将读取的信息用RandomAccessFile随机写入到本地文件中。同时，每个线程写入的数据都文件指针也就是写入数据的长度，需要保存在一个临时文件中。这样当本次下载没有完成的时候，下次下载的时候就从这个文件中读取上一次下载的文件长度，然后继续接着上一次的位置开始下载。并且将本次下载的长度写入到这个文件中。</p><h3 id="最简单的下载代码："><a href="#最简单的下载代码：" class="headerlink" title="最简单的下载代码："></a>最简单的下载代码：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">package com.xian.blog;</div><div class="line"></div><div class="line">import java.io.BufferedInputStream;</div><div class="line">import java.io.BufferedOutputStream;</div><div class="line">import java.io.FileOutputStream;</div><div class="line">import java.net.HttpURLConnection;</div><div class="line">import java.net.URL;</div><div class="line"></div><div class="line">public class SimpleDownload &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        try &#123;</div><div class="line">            URL url = new URL(<span class="string">"http://ww1.sinaimg.cn/large/adc90466gy1fcptk0wnt2j20e90ifmz4"</span>);</div><div class="line">            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">            conn.setConnectTimeout(3000);</div><div class="line">            int code = conn.getResponseCode();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (200 == code) &#123;</div><div class="line">                BufferedInputStream <span class="keyword">in</span> = new BufferedInputStream(conn.getInputStream());</div><div class="line">                BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(<span class="string">"/Users/xianxiaotao/desktop/activitylife.png"</span>));</div><div class="line">                byte[] buf = new byte[1024];</div><div class="line">                int len = -1;</div><div class="line">                <span class="keyword">while</span> (-1 != (len = in.read(buf)))</div><div class="line">                    out.write(buf, 0, len);</div><div class="line">                in.close();</div><div class="line">                out.close();</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>上述代码简易，但不适合大型文件下载。</p></blockquote><h3 id="多线程断点下载代码："><a href="#多线程断点下载代码：" class="headerlink" title="多线程断点下载代码："></a>多线程断点下载代码：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line">package com.xian.blog;</div><div class="line"></div><div class="line">import java.io.BufferedInputStream;</div><div class="line">import java.io.File;</div><div class="line">import java.io.IOException;</div><div class="line">import java.io.RandomAccessFile;</div><div class="line">import java.net.HttpURLConnection;</div><div class="line">import java.net.URL;</div><div class="line"></div><div class="line">public class XDownloadTask extends Thread&#123;</div><div class="line">    private static final String DIR_PATH = <span class="string">"/Users/xianxiaotao/downloads"</span>;  // 下载目录</div><div class="line">    private static final int THREAD_AMOUNT = 3;    // 总线程数</div><div class="line"></div><div class="line">    private URL url;// 目标下载地址</div><div class="line">    private File dataFile;// 本地文件</div><div class="line">    private File tempFile;// 存储线程下载进度的临时文件</div><div class="line">    private long totalLength;// 服务端文件总长度</div><div class="line">    private long threadLenght;// 每个线程要下载的长度</div><div class="line">    private long totalFinish;// 记录：总共完成了多少</div><div class="line">    private long begin;// 用来记录下载开始时间</div><div class="line"></div><div class="line">    public XDownloadTask(String address) throws IOException &#123;</div><div class="line">url = new URL(address);// 记住下载地址</div><div class="line">dataFile = new File(DIR_PATH, address.substring(address.lastIndexOf(<span class="string">"/"</span>) + 1));// 截取地址中的文件名，创建本地文件</div><div class="line">tempFile = new File(dataFile.getAbsolutePath() + <span class="string">".temp"</span>);// 在本地文件所在文件夹中创建临时文件</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">try &#123;</div><div class="line">    HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">    conn.setConnectTimeout(10000);</div><div class="line"></div><div class="line">            totalLength = conn.getContentLength();// 获取服务端发送过来的文件长度</div><div class="line">    threadLenght = (totalLength + THREAD_AMOUNT - 1) / THREAD_AMOUNT;// 计算每个线程要下载的长度</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!tempFile.exists()) &#123;// 如果临时文件不存在</div><div class="line">RandomAccessFile raf = new RandomAccessFile(tempFile, <span class="string">"rw"</span>);// 创建临时文件，用来记录每个线程已下载多少</div><div class="line"><span class="keyword">for</span> (int i = 0; i &lt; THREAD_AMOUNT; i++)</div><div class="line">    raf.writeInt(0);</div><div class="line">        raf.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (int i = 0; i &lt; THREAD_AMOUNT; i++)// 按线程数循环</div><div class="line">new DownloadThread(i).start();// 开启线程，每个线程将会下载一部分数据到本地文件中</div><div class="line"></div><div class="line">    begin = System.currentTimeMillis();// 记录开始时间</div><div class="line">&#125; catch (IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class DownloadThread extends Thread &#123;</div><div class="line">private int id;// 用来标记当前线程是下载任务中的第几个线程</div><div class="line"></div><div class="line">public DownloadThread(int id) &#123;</div><div class="line">    this.id = id;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">    try &#123;</div><div class="line">RandomAccessFile tempRaf = new RandomAccessFile(tempFile, <span class="string">"rws"</span>);// 记录进度的临时文件</div><div class="line">tempRaf.seek(id * 4);// 将指针移动到当前线程的位置</div><div class="line">int threadFinish = tempRaf.readInt();// 读取当前线程已完成了多少</div><div class="line">synchronized(XDownloadTask.this) &#123;// 多个下载线程之间同步</div><div class="line">    totalFinish += threadFinish;// 统计所有线程总共完成了多少</div><div class="line">&#125;</div><div class="line"></div><div class="line">long start = id * threadLenght + threadFinish;// 计算当前线程起始位置</div><div class="line">long end = id * threadLenght + threadLenght - 1;// 计算当前线程结束位置</div><div class="line">System.out.println(<span class="string">"线程"</span> + id + <span class="string">": "</span> + start + <span class="string">"-"</span> + end);</div><div class="line"></div><div class="line">HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">conn.setConnectTimeout(10000);</div><div class="line">conn.setRequestProperty(<span class="string">"Range"</span>, <span class="string">"bytes="</span> + start + <span class="string">"-"</span> + end);// 设置当前线程下载的范围</div><div class="line"></div><div class="line">BufferedInputStream <span class="keyword">in</span> = new BufferedInputStream(conn.getInputStream());// 获取连接的输入流</div><div class="line">RandomAccessFile dataRaf = new RandomAccessFile(dataFile, <span class="string">"rws"</span>);// 保存数据的本地文件</div><div class="line">dataRaf.seek(start);// 设置当前线程保存数据的位置</div><div class="line"></div><div class="line">byte[] buf = new byte[1024];</div><div class="line">int len = -1;</div><div class="line"><span class="keyword">while</span> (-1 != (len = in.read(buf))) &#123;</div><div class="line">    dataRaf.write(buf, 0, len);</div><div class="line">    threadFinish += len;</div><div class="line">    tempRaf.seek(id * 4);</div><div class="line">    tempRaf.writeInt(threadFinish);// 将当前线程完成了多少写入到临时文件</div><div class="line">    synchronized (XDownloadTask.this) &#123;</div><div class="line">totalFinish += len;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dataRaf.close();</div><div class="line">tempRaf.close();</div><div class="line"></div><div class="line">System.out.println(<span class="string">"线程"</span> + id + <span class="string">"下载完毕"</span>);</div><div class="line"><span class="keyword">if</span> (totalFinish == totalLength) &#123;</div><div class="line">    System.out.println(<span class="string">"下载完成，耗时："</span> + (System.currentTimeMillis() - begin));</div><div class="line">    tempFile.delete();</div><div class="line">&#125;</div><div class="line">    &#125; catch (IOException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws IOException &#123;</div><div class="line">new XDownloadTask(<span class="string">"http://ww1.sinaimg.cn/large/adc90466gy1fcptk0wnt2j20e90ifmz4"</span>).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a2e7fc327814cb69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA | equals 的正确姿势</title>
      <link href="/1900/03/02/01%20JAVA/JAVA%20%7C%20equals%20%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"/>
      <url>/1900/03/02/01%20JAVA/JAVA%20%7C%20equals%20%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>职员（Employee）及其子类（Manager），当判断对象是否等同取决于所有属性时，建议使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (getClass() != otherObject.getClass()) <span class="built_in">return</span> <span class="literal">false</span>;</div></pre></td></tr></table></figure></p><p>而不是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!(otherObject instanceof Employee)) <span class="built_in">return</span> <span class="literal">false</span>;</div></pre></td></tr></table></figure></p><p>如果当父类能够明确判断对象是否相同的条件时，可以使用instanceof。比如，实际中职员都有一个唯一ID，只要id相同即是同一个职员。那么将父类Employee的equals方法设计为判断ID值是否相同即可，当然hashCode方法也要由id来决定。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public int <span class="function"><span class="title">hashCode</span></span>() &#123;</div><div class="line">    <span class="built_in">return</span> Objects.hash(this.id);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public boolean equals(Object otherObject) &#123;</div><div class="line">    <span class="keyword">if</span> (this == otherObject) <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">if</span> (otherObject == null) <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span> (!(otherObject instanceof Employee)) <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    Employee other = (Employee) otherObject;</div><div class="line">    <span class="built_in">return</span> this.id == other.id;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>全部代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">class Employee &#123;</div><div class="line">    private String name;</div><div class="line">    private double salary;</div><div class="line">    private LocalDate hireDay;</div><div class="line"></div><div class="line">    public Employee(String name, double salary, int year, int month, int day) &#123;</div><div class="line">        this.name = name;</div><div class="line">        this.salary = salary;</div><div class="line">        this.hireDay = LocalDate.of(year, month, day);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String <span class="function"><span class="title">getName</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> this.name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public double <span class="function"><span class="title">getSalary</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> this.salary;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public LocalDate <span class="function"><span class="title">getHireDay</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> this.hireDay;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void raiseSalary(double byPercent) &#123;</div><div class="line">        double raise = this.salary * byPercent / 100;</div><div class="line">        this.salary += raise;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int <span class="function"><span class="title">hashCode</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> Objects.hash(this.name, this.salary, this.hireDay);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">    public boolean equals(Object otherObject) &#123;</div><div class="line">        <span class="keyword">if</span> (this == otherObject) <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span> (otherObject == null) <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">if</span> (getClass() != otherObject.getClass()) <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">        Employee other = (Employee) otherObject;</div><div class="line">        <span class="built_in">return</span> Objects.equals(this.name, other.name) &amp;&amp; this.salary == other.salary </div><div class="line">            &amp;&amp; Objects.equals(this.hireDay, other.hireDay);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> getClass().getName() + <span class="string">" [name="</span> + name + <span class="string">", salary="</span> + salary </div><div class="line">            + <span class="string">", hireDay="</span> + hireDay + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Manager extends Employee &#123;</div><div class="line">    private double bonus;</div><div class="line"></div><div class="line">    public Manager(String name, double salary, int year, int month, int day) &#123;</div><div class="line">        super(name, salary, year, month, day);</div><div class="line">        bonus = 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void <span class="built_in">set</span>Bonus(double bonus) &#123;</div><div class="line">        this.bonus = bonus;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public double <span class="function"><span class="title">getSalary</span></span>() &#123;</div><div class="line">        double baseSalary = super.getSalary();</div><div class="line">        <span class="built_in">return</span> baseSalary + bonus;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int <span class="function"><span class="title">hashCode</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> super.hashCode() + 17 * Double.hashCode(bonus);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean equals(Object otherObject) &#123;</div><div class="line">        <span class="keyword">if</span> (!super.equals(otherObject)) <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">        Manager other = (Manager) otherObject;</div><div class="line">        <span class="built_in">return</span> bonus == other.bonus;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA | 使用克隆防止破坏封装性</title>
      <link href="/1900/03/01/01%20JAVA/JAVA%20%7C%20%E4%BD%BF%E7%94%A8%E5%85%8B%E9%9A%86%E9%98%B2%E6%AD%A2%E7%A0%B4%E5%9D%8F%E5%B0%81%E8%A3%85%E6%80%A7/"/>
      <url>/1900/03/01/01%20JAVA/JAVA%20%7C%20%E4%BD%BF%E7%94%A8%E5%85%8B%E9%9A%86%E9%98%B2%E6%AD%A2%E7%A0%B4%E5%9D%8F%E5%B0%81%E8%A3%85%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>请先看一个案例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 职员类</div><div class="line"> * </div><div class="line"> * @author xianxiaotao</div><div class="line"> */</div><div class="line">public class Employee &#123;</div><div class="line">    private Date hireDay;</div><div class="line">    </div><div class="line">    public Employee(Date hireDay) &#123;</div><div class="line">        this.hireDay = hireDay;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public Date <span class="function"><span class="title">getHireDay</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> this.hireDay;    // bad coding</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>职员，受雇日期是固定不变的，即使将属性设置为私有，依然可以使用这段代码直接将职员工龄增加10年：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Employee harry = new Employee(new Date());</div><div class="line">Date d = harry.getHireDay();</div><div class="line">double tenYearsInMilliSeconds = 10 * 365.25 * 24 * 60 * 60 * 1000;</div><div class="line">d.setTime(d.getTime() - (long) tenYearsInMilliSeconds);</div></pre></td></tr></table></figure></p><p>如果需要返回一个可变对象的引用，应该首先对它进行克隆（clone），代码修改如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Date <span class="function"><span class="title">getHireDay</span></span>() &#123;</div><div class="line">    <span class="built_in">return</span> (Date) hireDay.clone();// Ok</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>建议使用LocalDate代替Date</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA 8 Lambda</title>
      <link href="/1900/02/03/01%20JAVA/JAVA%208%20Lambda/"/>
      <url>/1900/02/03/01%20JAVA/JAVA%208%20Lambda/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h3><p>Java是一种面向对象语言，所以必须构造一个对象，这个对象的类需要有一个方法能包含所需的代码。如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class LengthComparator implements Comparator&lt;String&gt; &#123;</div><div class="line">    public int compare(String first, String second) &#123;</div><div class="line">        <span class="built_in">return</span> first.length - second.first;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// uses</div><div class="line">Arrays.sort(strings, new LengthComparator());</div></pre></td></tr></table></figure></p><p>如果使用Lambda表达式，则使用代码更改为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Arrays.sort(strings, (String first, String second) -&gt; &#123; <span class="built_in">return</span> first.length - second.first; &#125;));</div></pre></td></tr></table></figure></p><h4 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h4><p>在这里，编译器可以推导出first和second必然是字符串，参数类型可以省略不写；方法体里只有一行，亦可简化。如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Arrays.sort(strings, (first, second) -&gt; first.length() - second.length());</div></pre></td></tr></table></figure></p><h4 id="无参"><a href="#无参" class="headerlink" title="无参"></a>无参</h4><p>即使lambda表达式没有参数，仍然要提供括号，就像无参数方法一样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">() -&gt; &#123; <span class="keyword">for</span> (int i = 100; i &gt;= 0; i--) System.out.println(i); &#125;</div></pre></td></tr></table></figure></p><h4 id="一参"><a href="#一参" class="headerlink" title="一参"></a>一参</h4><p>如果方法只有一个参数，而且这个参数的类型可以推导得出，那么甚至还可以省略小括号：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ActionListener listener = event -&gt; System.out.println(<span class="string">"The time is "</span> + new Date());</div></pre></td></tr></table></figure></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>1）无需指定lambda表达式的返回类型，因为返回类型总是会由上下文推导得出。<br>2）如果一个lambda表达式只在某些分支返回一个值，而在另外一些分支不返回值，这是不合法的。例如，(int x) -&gt; { if (x &gt;= 0) return 1; }就不合法。</p><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">package com.xian.lambda;</div><div class="line"></div><div class="line">import java.util.Arrays;</div><div class="line">import java.util.Date;</div><div class="line"></div><div class="line">import javax.swing.JOptionPane;</div><div class="line">import javax.swing.Timer;</div><div class="line"></div><div class="line">public class LambdaTest &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        String[] masters = &#123;<span class="string">"liyao"</span>, <span class="string">"zhaoyu"</span>, <span class="string">"hufeng"</span>, <span class="string">"xianxiaotao"</span>, <span class="string">"cuihongquan"</span>&#125;;</div><div class="line">        System.out.println(Arrays.toString(masters));</div><div class="line">        System.out.println(<span class="string">"Sorted in dictionary order:"</span>);</div><div class="line">        Arrays.sort(masters);</div><div class="line">        System.out.println(Arrays.toString(masters));</div><div class="line">        System.out.println(<span class="string">"Sorted by length:"</span>);</div><div class="line">        Arrays.sort(masters, (first, second) -&gt; first.length() - second.length());</div><div class="line">        System.out.println(Arrays.toString(masters));</div><div class="line">        </div><div class="line">        Timer t = new Timer(10000, event -&gt; System.out.println(<span class="string">"The time is"</span> + new Date()));</div><div class="line">        t.start();</div><div class="line">        JOptionPane.showMessageDialog(null, <span class="string">"Quit program?"</span>);</div><div class="line">        System.exit(0);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="二、函数式接口"><a href="#二、函数式接口" class="headerlink" title="二、函数式接口"></a>二、函数式接口</h3><p>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这个接口称为函数式接口。如上例中的Comparator接口，或者java.util.function包中的接口Predicate：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface Predicate&lt;T&gt; &#123;</div><div class="line">    boolean <span class="built_in">test</span>(T t);</div><div class="line">    // Additional default and static methods</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ArrayList类有一个removeIf方法它的参数就是一个Predicate。这个接口专门用来传递lambda表达式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list.removeIf(e -&gt; e == null);</div></pre></td></tr></table></figure></p><h3 id="三、方法引用"><a href="#三、方法引用" class="headerlink" title="三、方法引用"></a>三、方法引用</h3><p>表达式System.out::println是一个方法引用，等价于lambda表达式x -&gt; System.out.println(x)。又如下列两行代码等同：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Timer t = new Timer(1000, event -&gt; System.out.println(event));</div><div class="line">Timer t = new Timer(1000, System.out::println);</div></pre></td></tr></table></figure></p><p>操作符 “::” 用来分割方法名与对象或类名。主要分为三种情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">objcet::instanceMethod    如：System.out::println             x -&gt; System.out.println(x)</div><div class="line">Class::staticMethod       如：Math::pow                       (x, y) -&gt; Math.pow(x, y)</div><div class="line">Class::instanceMethod     如：String::compareToIgnoreCase     (x, y) -&gt; x.compareToIgnoreCase(y)</div></pre></td></tr></table></figure></p><p>对于第三种情况，第一个参数会成为方法的目标。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Arrays.sort(masters, String::compareToIgnoreCase);</div><div class="line">Arrays.sort(masters, (first, second) -&gt; first.compareToIgnoreCase(second));</div></pre></td></tr></table></figure></p><blockquote><p>注意：对于重载方法，编译器会尝试从上下文中找出你指的那一个方法；方法引用不能独立存在，总是会转换为函数式接口的实例；方法引用中可以使用this和super参数，例如this::equals等同于x -&gt; this.equals(x)；使用super作为目标，会调用方法的超类版本，格式为super::instanceMethod；this是指创建lambda表达式的方法所属的对象，super同理。</p></blockquote><h3 id="四、构造器引用"><a href="#四、构造器引用" class="headerlink" title="四、构造器引用"></a>四、构造器引用</h3><p>构造器引用与方法引用类似，只不过方法名为new。例如，Person::new是Person构造器的一个引用。至于哪一个构造器，这取决于上下文。假如你有一个字符串列表，并把它转换为Person对象数组，其如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; names = ...;</div><div class="line">Stream&lt;Person&gt; stream = names.stream().map(Person::new);</div><div class="line">List&lt;Person&gt; people = stream.collect(Collectors.toList());</div></pre></td></tr></table></figure></p><p>根据上下文，编译器会选择一个String参数的构造器。可以用数组类型建立构造器引用。例如，int[]::new，这等价于lambda表达式x -&gt; new int[x]。</p><h3 id="五、变量"><a href="#五、变量" class="headerlink" title="五、变量"></a>五、变量</h3><p>lambda表达式中捕获的变量必须实际上是最终变量，即这个变量初始化之后就不会再为它赋新值。如下例中的text总是指示同一个String对象，所以此处合法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class LambdaTest &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        repeatMessage(<span class="string">"hello"</span>, 1000);</div><div class="line">        JOptionPane.showMessageDialog(null, <span class="string">"Quit program?"</span>);</div><div class="line">        System.exit(0);        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static void repeatMessage(String text, int delay) &#123;</div><div class="line">        ActionListener listener = event -&gt; System.out.println(text);</div><div class="line">        new Timer(delay, listener).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当lambda表达式捕获外围作用域中变量的，无论是外部改变还是内部改变都不合法的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 外部改变：</div><div class="line">public static void repeat(String text, int count) &#123;</div><div class="line">    <span class="keyword">for</span> (int i = 1; i &lt;= count; i++) &#123;</div><div class="line">        ActionListener listener = event -&gt; &#123;</div><div class="line">            System.out.println(i + <span class="string">": "</span> + text);    // Error: Cannot refer to changing i</div><div class="line">        &#125;;</div><div class="line">        new Timer(1000, listener).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 内部改变：</div><div class="line">public static void countDown(int start, int delay) &#123;</div><div class="line">    ActionListener listener = event -&gt; &#123;</div><div class="line">            start--;                                // Error: Cannot mutate captured variable</div><div class="line">            System.out.println(start); </div><div class="line">        &#125;;</div><div class="line">        new Timer(delay, listener).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA 8 LocalDate</title>
      <link href="/1900/02/02/01%20JAVA/JAVA%208%20LocalDate/"/>
      <url>/1900/02/02/01%20JAVA/JAVA%208%20LocalDate/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="java-time-LocalDate-8"><a href="#java-time-LocalDate-8" class="headerlink" title="java.time.LocalDate 8"></a>java.time.LocalDate 8</h3><ul><li>static LocalDate now()<br>构造一个表示当前日期的对象。</li><li>static LocalDate of(int year, int month, int day)<br>构造一个表示给定日期的对象。</li><li>int getYear()</li><li>int getMonthValue()</li><li>int getDayOfMonth()<br>得到当前日期的年、月和日。</li><li>DayOfWeek getDayOfWeek()<br>得到当前日期是星期几，作为DayOfWeek类的一个实例返回。调用getValue来得到1 ~ 7之间的一个数，表示这是星期几，1表示星期一，7表示星期日。</li><li>LocalDate plusDays(int n)</li><li>LocalDate minusDays(int n)<br>生成当前日期之后或之前n天的日期。</li></ul><h3 id="使用LocalDate输出日历"><a href="#使用LocalDate输出日历" class="headerlink" title="使用LocalDate输出日历"></a>使用LocalDate输出日历</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">package com.xian.date18;</div><div class="line"></div><div class="line">import java.time.DayOfWeek;</div><div class="line">import java.time.LocalDate;</div><div class="line"></div><div class="line">public class LocalDateDemo &#123;</div><div class="line">    public static void <span class="built_in">print</span>Calendar(LocalDate date) &#123;</div><div class="line">        int month = date.getMonthValue();</div><div class="line">        int today = date.getDayOfMonth();</div><div class="line"></div><div class="line">        date = date.minusDays(today - 1);        // <span class="built_in">set</span> to start of month</div><div class="line">        DayOfWeek weekday = date.getDayOfWeek();</div><div class="line">        int value = weekday.getValue();          // 1 = Monday, ... 7 = Sunday</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Mon Tue Wed Thu Fri Sat Sun"</span>);</div><div class="line">        <span class="keyword">for</span> (int i = 1; i &lt; value; i++)</div><div class="line">            System.out.print(<span class="string">"    "</span>);</div><div class="line">        <span class="keyword">while</span> (date.getMonthValue() == month) &#123;</div><div class="line">            System.out.printf(<span class="string">"%3d"</span>, date.getDayOfMonth());</div><div class="line">            <span class="keyword">if</span> (date.getDayOfMonth() == today)</div><div class="line">                System.out.print(<span class="string">"*"</span>);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                System.out.print(<span class="string">" "</span>);</div><div class="line">            date = date.plusDays(1);</div><div class="line">            <span class="keyword">if</span> (date.getDayOfWeek().getValue() == 1)</div><div class="line">                System.out.println();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        <span class="built_in">print</span>Calendar(LocalDate.now());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><pre>输出：Mon Tue Wed Thu Fri Sat Sun          1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19* 20  21  22  23  24  25  26  27  28  29  30  31 </pre>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA 8 Interface</title>
      <link href="/1900/02/01/01%20JAVA/JAVA%208%20Interface/"/>
      <url>/1900/02/01/01%20JAVA/JAVA%208%20Interface/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><hr><p>目前为止，通常的做法都是将静态方法放在伴随类中。在标准库中，你会看到成对出现的接口和使用工具类，如Collection/Collections或Path/Paths。在Java SE 8中，允许在接口中增加静态方法，节省一个伴随类，只是这有违于将接口作为抽象规范的初衷。示例如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">interface MyComparable&lt;T&gt; &#123;</div><div class="line">    public static &lt;T&gt; int compare(java.lang.Comparable&lt;T&gt; t1, T t2) &#123; </div><div class="line">        <span class="built_in">return</span> t1.compareTo(t2); </div><div class="line">    &#125;</div><div class="line">    int compareTo(T t);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><hr><p>可以为接口方法提供一个默认实现。必须用default修饰符标记这样一个方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface Collection &#123;</div><div class="line">    int size();// An abstract method</div><div class="line">    default boolean <span class="function"><span class="title">isEmpty</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> size() == 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="解决默认方法冲突"><a href="#解决默认方法冲突" class="headerlink" title="解决默认方法冲突"></a>解决默认方法冲突</h3><hr><p>如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，会发生什么情况？Java的相应规则如下：<br>1）超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。确保与Java SE 7兼容。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">interface Named &#123;</div><div class="line">    default String <span class="function"><span class="title">getName</span></span>() &#123; </div><div class="line">        <span class="built_in">return</span> getClass().getName() + <span class="string">"_"</span> + <span class="built_in">hash</span>Code(); </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Person &#123;</div><div class="line">    public String <span class="function"><span class="title">getName</span></span>() &#123; </div><div class="line">        <span class="built_in">return</span> getClass().getName(); </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Student extends Person implements Named &#123; // super.getName() &#125;</div></pre></td></tr></table></figure></p><p>2）接口冲突。如果两个接口都提供了同名同参的默认方法，实现类必须覆盖这个方法类解决冲突。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">interface Named &#123;</div><div class="line">    default String <span class="function"><span class="title">getName</span></span>() &#123; <span class="built_in">return</span> <span class="string">"Named:"</span> + getClass().getName() + <span class="string">"_"</span> + <span class="built_in">hash</span>Code(); &#125;</div><div class="line">&#125;</div><div class="line">interface Called &#123;</div><div class="line">    default String <span class="function"><span class="title">getName</span></span>() &#123; <span class="built_in">return</span> <span class="string">"Called:"</span> + getClass().getName() + <span class="string">"_"</span> + <span class="built_in">hash</span>Code(); &#125;</div><div class="line">&#125;</div><div class="line">class Student implements Named, Called &#123; </div><div class="line">    public String <span class="function"><span class="title">getName</span></span>() &#123; <span class="built_in">return</span> Named.super.getName(); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Socket 如何演化成 Tomcat</title>
      <link href="/1900/01/15/01%20JAVA/15%20Java%20Socket%20%E5%A6%82%E4%BD%95%E6%BC%94%E5%8C%96%E6%88%90%20Tomcat/"/>
      <url>/1900/01/15/01%20JAVA/15%20Java%20Socket%20%E5%A6%82%E4%BD%95%E6%BC%94%E5%8C%96%E6%88%90%20Tomcat/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>相关文章：<br><a href="https://xianxiaotao.github.io/1900/01/13/01%20JAVA/13%20Java%20Socket/" target="_blank" rel="external">Java Socket</a><br><a href="https://xianxiaotao.github.io/1900/01/14/01%20JAVA/14%20Java%20Socket%20%E8%81%8A%E5%A4%A9%E5%AE%A4%E5%8E%9F%E7%90%86/" target="_blank" rel="external">Java Socket 聊天室原理</a><br><a href="https://xianxiaotao.github.io/1900/01/15/01%20JAVA/15%20Java%20Socket%20%E5%A6%82%E4%BD%95%E6%BC%94%E5%8C%96%E6%88%90%20Tomcat/" target="_blank" rel="external">Java Socket 如何演化成 Tomcat</a></p></blockquote><ul><li>模拟请求表单；</li><li>简易服务器代码获取请求；</li><li>HTTP协议；</li><li>抽象封装Response和Request；</li><li>将与客户端的交互封装成Servlet；</li><li>使用分发器多线程处理各种业务；</li><li>分发器使用的上下文及全局变量；</li><li>利用反射优化代码；</li><li>在配置文件中设置路径与Servlet的对应关系；</li><li>完整源码下载链接</li></ul><h3 id="一、请求表单"><a href="#一、请求表单" class="headerlink" title="一、请求表单"></a>一、请求表单</h3><p>首先在前端模拟一个注册请求表单，代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;注册&lt;/title&gt;</div><div class="line">    &lt;meta http-equiv=<span class="string">"content-type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>/&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;form method=<span class="string">"post"</span> action=<span class="string">"http://localhost:8888/index.html"</span>&gt;</div><div class="line">        昵称：&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"username"</span> id=<span class="string">"username"</span>/&gt;</div><div class="line">        密码：&lt;input <span class="built_in">type</span>=<span class="string">"password"</span> name=<span class="string">"password"</span> id=<span class="string">"password"</span>/&gt;</div><div class="line">        兴趣：&lt;input <span class="built_in">type</span>=<span class="string">"checkbox"</span> name=<span class="string">"fav"</span> value=<span class="string">"0"</span>/&gt;篮球</div><div class="line">             &lt;input <span class="built_in">type</span>=<span class="string">"checkbox"</span> name=<span class="string">"fav"</span> value=<span class="string">"1"</span>/&gt;足球</div><div class="line">             &lt;input <span class="built_in">type</span>=<span class="string">"checkbox"</span> name=<span class="string">"fav"</span> value=<span class="string">"2"</span>/&gt;冰球</div><div class="line">             &lt;input <span class="built_in">type</span>=<span class="string">"submit"</span> value=<span class="string">"注册"</span>/&gt;</div><div class="line">    &lt;/form&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p><blockquote><p>method是请求方式，默认为get，其数据量小，安全性不高，而post量大，安全性相对高；<br>action为请求的服务器路径；id用于前端区分唯一性；<br>name用于服务器区分唯一性，如要提交数据给后台，必须声明name；<br>此处fav的值对应多个，用于测试服务器解析参数。</p></blockquote><h3 id="二、简易服务器"><a href="#二、简易服务器" class="headerlink" title="二、简易服务器"></a>二、简易服务器</h3><p>用一个简易的服务器代码输出来自浏览器的请求信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class Server &#123;</div><div class="line">    private ServerSocket server;</div><div class="line">    private boolean isRunning = <span class="literal">true</span>;</div><div class="line">    </div><div class="line">    // 开启服务</div><div class="line">    public void <span class="function"><span class="title">start</span></span>() &#123;</div><div class="line">        try &#123;</div><div class="line">            server = new ServerSocket(8888);</div><div class="line">            <span class="keyword">while</span> (isRunning) &#123;</div><div class="line">                receive();</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            stop();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 处理请求并响应</div><div class="line">    private void <span class="function"><span class="title">receive</span></span>() &#123;</div><div class="line">        try &#123;</div><div class="line">            Socket client = server.accept();</div><div class="line">            </div><div class="line">            // 以下代码临时用于接受客户端的请求信息</div><div class="line">            byte[] data = new byte[1024 * 10];</div><div class="line">            int len = client.getInputStream().read(data);</div><div class="line">            String requestInfo = new String(data, 0, len).trim();</div><div class="line">            requestInfo = URLDecoder.decode(requestInfo, <span class="string">"utf-8"</span>);</div><div class="line">            System.out.println(requestInfo);</div><div class="line">            </div><div class="line">            // 以下代码为返回信息，遵从HTTP协议</div><div class="line">            // TODO</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 关闭服务</div><div class="line">    public void <span class="function"><span class="title">stop</span></span>() &#123;</div><div class="line">        isRunning = <span class="literal">true</span>;</div><div class="line">        CloseUtil.closeServerSocket(server);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>开启上述服务器，以默认或GET方式发送表单，服务端接收到的信息是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GET /index.html?username=先小涛&amp;password=123456&amp;fav=0&amp;fav=2 HTTP/1.1</div><div class="line">Host: localhost:8888</div><div class="line">Accept: text/html,application/xhtml xml,application/xml;q=0.9,*/*;q=0.8</div><div class="line">Accept-Language: zh-cn</div><div class="line">Connection: keep-alive</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/600.8.9 (KHTML, like Gecko) Version/8.0.8 Safari/600.8.9</div></pre></td></tr></table></figure></p><p>以POST方式发送表单，服务端接收到的信息是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">POST /index.html HTTP/1.1</div><div class="line">Host: localhost:8888</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line">Origin: file://</div><div class="line">Connection: keep-alive</div><div class="line">Accept: text/html,application/xhtml xml,application/xml;q=0.9,*/*;q=0.8</div><div class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/600.8.9 (KHTML, like Gecko) Version/8.0.8 Safari/600.8.9</div><div class="line">Accept-Language: zh-cn</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">Content-Length: 102</div><div class="line"></div><div class="line">username=先小涛&amp;password=123456&amp;fav=0&amp;fav=2</div></pre></td></tr></table></figure></p><h3 id="三、HTTP协议"><a href="#三、HTTP协议" class="headerlink" title="三、HTTP协议"></a>三、HTTP协议</h3><p>上述两段请求信息由于请求方式不同导致略有差别，而这些固定格式的信息是由遵从HTTP协议的浏览器负责生成的。服务端响应的信息也要遵从HTTP协议，否则客户端无法解析返回的数据。HTTP响应格式与请求一样，由三个部分构成，分别是：<br>1、HTTP协议版本、状态代码、描述<br>2、响应头(Response Head)<br>3、响应正文(Response Content)<br>可以用代码方式拼接响应字符串：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 响应正文</div><div class="line">StringBuilder responseContext = new StringBuilder();</div><div class="line">responseContext.append(<span class="string">"&lt;html&gt;&lt;title&gt;HTTP响应示例&lt;/title&gt;&lt;body&gt;I defined a tomcat&lt;/body&gt;&lt;/html&gt;"</span>);</div><div class="line">// 响应全文</div><div class="line">StringBuilder response = new StringBuilder();</div><div class="line">response.append(<span class="string">"HTTP/1.1"</span>).append(<span class="string">" "</span>).append(<span class="string">"200"</span>).append(<span class="string">" "</span>).append(<span class="string">"OK"</span>);</div><div class="line">response.append(<span class="string">"Server:xianxiaotao Server/0.0.1"</span>).append(<span class="string">"\r\n"</span>);</div><div class="line">response.append(<span class="string">"Date:"</span>).append(new Date()).append(<span class="string">"\r\n"</span>);</div><div class="line">response.append(<span class="string">"Content-type:text/html;charset=utf-8"</span>).append(<span class="string">"\r\n"</span>);</div><div class="line">response.append(<span class="string">"Content-Length:"</span>).append(responseContext.toString().getBytes().length).append(<span class="string">"\r\n"</span>);</div><div class="line">response.append(<span class="string">"\r\n"</span>);</div><div class="line">response.append(responseContext);</div><div class="line">// 返回数据</div><div class="line">BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));</div><div class="line">bw.write(response.toString());</div><div class="line">bw.flush();</div><div class="line">bw.close();</div></pre></td></tr></table></figure></p><p>HTTP协议中常用的一些信息：<br>1、状态代码：<br>200 OK<br>400 Bad Request<br>404 Not Found<br>405 Method Not Allowed<br>500 Server Error</p><p>2、内容类型：<br>超文本：Content-type:text/html;charset=GBK<br>纯文本：Content-type:text/plain;charset=GBK<br>下载流：Content-type:application/octet-stream</p><blockquote><p>响应信息都是固定格式，不必每次都要拼字符串，可抽取共性封装成Response对象。Request如是。</p></blockquote><h3 id="四、Response"><a href="#四、Response" class="headerlink" title="四、Response"></a>四、Response</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">public class Response &#123;</div><div class="line">    public static final String CRLF = <span class="string">"\r\n"</span>;   // 回车符</div><div class="line">    public static final String BLANK = <span class="string">" "</span>;     // 空格符</div><div class="line">    </div><div class="line">    private StringBuilder headInfo;             // 头信息</div><div class="line">    private StringBuilder content;              // 正文</div><div class="line">    private int len;                            // 正文长度</div><div class="line">    private BufferedWriter bw;                  // 推送信息到客户端的流</div><div class="line">    </div><div class="line">    private <span class="function"><span class="title">Response</span></span>() &#123;</div><div class="line">        headInfo = new StringBuilder();</div><div class="line">        content = new StringBuilder();</div><div class="line">        len = 0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public Response(Socket socket) &#123;</div><div class="line">        this();</div><div class="line">        try &#123;</div><div class="line">            bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            headInfo = null;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 构建正文</div><div class="line">    public Response <span class="built_in">print</span>(String info) &#123;</div><div class="line">        content.append(info);</div><div class="line">        len += info.getBytes().length;</div><div class="line">        <span class="built_in">return</span> this;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 构建正文+回车</div><div class="line">    public Response println(String info) &#123;</div><div class="line">        content.append(info).append(CRLF);</div><div class="line">        len += (info + CRLF).getBytes().length;</div><div class="line">        <span class="built_in">return</span> this;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 生产响应头信息</div><div class="line">    private void createHeadInfo(int code) &#123;</div><div class="line">        headInfo.append(<span class="string">"HTTP/1.1"</span>).append(BLANK).append(code).append(BLANK);</div><div class="line">        switch (code) &#123;</div><div class="line">            <span class="keyword">case</span> 200:</div><div class="line">                headInfo.append(<span class="string">"OK"</span>);</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">            <span class="keyword">case</span> 404:</div><div class="line">                headInfo.append(<span class="string">"NOT FOUND"</span>);</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">            <span class="keyword">case</span> 500:</div><div class="line">                headInfo.append(<span class="string">"SERVER ERROR"</span>);</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">        &#125;</div><div class="line">        headInfo.append(<span class="string">"Server:xianxiaotao Server/0.0.1"</span>).append(CRLF);</div><div class="line">        headInfo.append(<span class="string">"Date:"</span>).append(new Date()).append(CRLF);</div><div class="line">        headInfo.append(<span class="string">"Content-type:text/html;charset=utf-8"</span>).append(CRLF);</div><div class="line">        headInfo.append(<span class="string">"Content-Length:"</span>).append(len).append(CRLF);</div><div class="line">        headInfo.append(CRLF);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 推送到客户端</div><div class="line">    public void pushToClient(int code) throws IOException &#123;</div><div class="line">        <span class="keyword">if</span> (null == headInfo) </div><div class="line">            code = 500;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            createHeadInfo(code);</div><div class="line">            bw.append(headInfo.toString());</div><div class="line">            bw.append(content.toString());</div><div class="line">            bw.flush();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void <span class="function"><span class="title">close</span></span>() &#123;</div><div class="line">        CloseUtil.closeIO(bw);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="五、Request"><a href="#五、Request" class="headerlink" title="五、Request"></a>五、Request</h3><p>主要解析请求信息中的请求方式和参数，并将结果封装成Request对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line">public class Request &#123;</div><div class="line">    public static final String CRLF = <span class="string">"\r\n"</span>;</div><div class="line">    </div><div class="line">    private String method;          // 请求方式</div><div class="line">    private String url;             // 请求资源</div><div class="line">    private Map&lt;String, List&lt;String&gt;&gt; parameterMapValues;   // 请求参数</div><div class="line">    private BufferedInputStream bis;// 流</div><div class="line">    private String requestInfo;     // 请求信息</div><div class="line">    </div><div class="line">    private <span class="function"><span class="title">Request</span></span>() &#123;</div><div class="line">        method = <span class="string">""</span>;</div><div class="line">        url = <span class="string">""</span>;</div><div class="line">        parameterMapValues = new HashMap&lt;&gt;();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public Request(Socket client) &#123;</div><div class="line">        this();</div><div class="line">        try &#123;</div><div class="line">            this.bis = new BufferedInputStream(client.getInputStream());</div><div class="line">            byte[] buf = new byte[10240];</div><div class="line">            int len = bis.read(buf);</div><div class="line">            requestInfo = new String(buf, 0, len);</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            <span class="built_in">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        parseRequestInfo();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 解析请求信息</div><div class="line">     */</div><div class="line">    private void <span class="function"><span class="title">parseRequestInfo</span></span>() &#123;</div><div class="line">        <span class="keyword">if</span> (null == requestInfo || requestInfo.trim().length() == 0) </div><div class="line">            <span class="built_in">return</span>;</div><div class="line">        </div><div class="line">        String paramString = <span class="string">""</span>;    // 请求参数</div><div class="line">        String firstLine = requestInfo.substring(0, requestInfo.indexOf(CRLF));</div><div class="line">        int idx = firstLine.indexOf(<span class="string">"/"</span>);</div><div class="line">        this.method = firstLine.substring(0, idx).trim();</div><div class="line">        String urlStr = firstLine.substring(idx, firstLine.indexOf(<span class="string">"HTTP/"</span>)).trim();</div><div class="line">        <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">"post"</span>)) &#123;</div><div class="line">            this.url = urlStr;</div><div class="line">            paramString = requestInfo.substring(requestInfo.lastIndexOf(CRLF)).trim();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">"get"</span>)) &#123;</div><div class="line">            <span class="keyword">if</span> (urlStr.contains(<span class="string">"?"</span>)) &#123; // 是否存在参数</div><div class="line">                String[] urlArray = urlStr.split(<span class="string">"\\?"</span>);</div><div class="line">                this.url = urlArray[0];</div><div class="line">                paramString = urlArray[1];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                this.url = urlStr;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (paramString.equals(<span class="string">""</span>)) </div><div class="line">            <span class="built_in">return</span>;</div><div class="line">        parseParams(paramString);   // 解析请求参数</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 解析请求信息中的参数</div><div class="line">     * @param paramString</div><div class="line">     */</div><div class="line">    private void parseParams(String paramString) &#123;</div><div class="line">        StringTokenizer token = new StringTokenizer(paramString, <span class="string">"&amp;"</span>);</div><div class="line">        <span class="keyword">while</span> (token.hasMoreTokens()) &#123;</div><div class="line">            String str = token.nextToken();</div><div class="line">            String[] keyAndVal = str.split(<span class="string">"="</span>);</div><div class="line">            <span class="keyword">if</span> (keyAndVal.length == 1) &#123;    // 只有参数没有值</div><div class="line">                keyAndVal = Arrays.copyOf(keyAndVal, 2);</div><div class="line">                keyAndVal[1] = null;</div><div class="line">            &#125;</div><div class="line">            String key = keyAndVal[0].trim();</div><div class="line">            String val = (null == keyAndVal[1] ? null : decode(keyAndVal[1].trim(), <span class="string">"utf-8"</span>));</div><div class="line">            <span class="keyword">if</span> (!parameterMapValues.containsKey(key)) &#123;</div><div class="line">                parameterMapValues.put(key, new ArrayList&lt;&gt;());</div><div class="line">            &#125;</div><div class="line">            List&lt;String&gt; values = parameterMapValues.get(key);</div><div class="line">            values.add(val);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 解决中文问题</div><div class="line">     * @param value 需要正确显示中文的字符</div><div class="line">     * @param code 字符集（gbk、utf-8等）</div><div class="line">     * @<span class="built_in">return</span> String 如异常则返回null</div><div class="line">     */</div><div class="line">    private String decode(String value, String code) &#123;</div><div class="line">        try &#123;</div><div class="line">            <span class="built_in">return</span> URLDecoder.decode(value, code);</div><div class="line">        &#125; catch (UnsupportedEncodingException e) &#123;&#125;</div><div class="line">        </div><div class="line">        <span class="built_in">return</span> null;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 获取网页对应name的多个值</div><div class="line">     * @param name</div><div class="line">     * @<span class="built_in">return</span> String[] 一个name有多个值</div><div class="line">     */</div><div class="line">    public String[] getParameterValues(String name) &#123;</div><div class="line">        List&lt;String&gt; values = parameterMapValues.get(name);</div><div class="line">        <span class="keyword">if</span> (null == values)</div><div class="line">            <span class="built_in">return</span> null;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="built_in">return</span> values.toArray(new String[0]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 获取网页对应name的值</div><div class="line">     * @param name</div><div class="line">     * @<span class="built_in">return</span> String name对应的值</div><div class="line">     */</div><div class="line">    public String getParameter(String name) &#123;</div><div class="line">        String[] values = getParameterValues(name);</div><div class="line">        <span class="built_in">return</span> (null == values) ? null : values[0];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String <span class="function"><span class="title">getUrl</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> url;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void <span class="built_in">set</span>Url(String url) &#123;</div><div class="line">        this.url = url;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>需要注意参数值为中文、一参多值的情况。</p></blockquote><h3 id="六、Servlet"><a href="#六、Servlet" class="headerlink" title="六、Servlet"></a>六、Servlet</h3><p>客户端与服务器端的交互形式不定，如登录、注册、查看信息等。可抽象出一个抽象类，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public abstract class Servlet &#123;</div><div class="line">    public void service(Request req, Response rep) throws Exception &#123;</div><div class="line">        <span class="keyword">do</span>Get(req, rep);</div><div class="line">        <span class="keyword">do</span>Post(req, rep);</div><div class="line">    &#125;</div><div class="line">    public abstract void <span class="keyword">do</span>Get(Request req, Response rep) throws Exception;</div><div class="line">    public abstract void <span class="keyword">do</span>Post(Request req, Response rep) throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>具体的交互业务类Servlet继承抽象类，利用JAVA的多态优化其他代码。示例如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class RegisterServlet extends Servlet &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void <span class="keyword">do</span>Get(Request req, Response rep) throws Exception &#123;</div><div class="line">        rep.println(<span class="string">"&lt;html&gt;&lt;title&gt;HTTP响应示例&lt;/title&gt;&lt;body&gt;欢迎用户"</span> + req.getParameter(<span class="string">"username"</span>) + <span class="string">"注册成功&lt;/body&gt;&lt;/html&gt;"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void <span class="keyword">do</span>Post(Request req, Response rep) throws Exception &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="七、分发器Dispatcher"><a href="#七、分发器Dispatcher" class="headerlink" title="七、分发器Dispatcher"></a>七、分发器Dispatcher</h3><p>既然交互方式不定，同一种交互方式的交互次数不定，需要借助分发器（多线程）进行优化处理。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 分发器，多线程（一个请求响应，创建一个此对象）</div><div class="line"> * @author xianxiaotao</div><div class="line"> */</div><div class="line">public class Dispatcher implements Runnable &#123;</div><div class="line">    private Socket client;</div><div class="line">    private Request req;</div><div class="line">    private Response rep;</div><div class="line">    private int code = 200;     // 默认200</div><div class="line">    </div><div class="line">    public Dispatcher(Socket client) &#123;</div><div class="line">        this.client = client;</div><div class="line">        try &#123;</div><div class="line">            req = new Request(client.getInputStream());</div><div class="line">            rep = new Response(client.getOutputStream());</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            code = 500;</div><div class="line">            <span class="built_in">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">        try &#123;</div><div class="line">            // 根据请求参数中的url找到对应的Servlet</div><div class="line">            Servlet servlet = WebApp.getServlet(req.getUrl());  </div><div class="line">            <span class="keyword">if</span> (null == servlet)    // 找不到处理</div><div class="line">                this.code = 404;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                servlet.service(req, rep);</div><div class="line">            rep.pushToClient(code);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            this.code = 500;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 再推送一次</div><div class="line">        try &#123;</div><div class="line">            rep.pushToClient(code);</div><div class="line">        &#125; catch (IOException e) &#123;&#125;</div><div class="line">        </div><div class="line">        CloseUtil.closeSocket(client);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="八、上下文ServletContext和全局变量WebApp"><a href="#八、上下文ServletContext和全局变量WebApp" class="headerlink" title="八、上下文ServletContext和全局变量WebApp"></a>八、上下文ServletContext和全局变量WebApp</h3><p>分发器需要根据请求参数中的url，从上下文中找出对应的Servlet来做相应的处理。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 上下文</div><div class="line"> * @author xianxiaotao</div><div class="line"> */</div><div class="line">public class ServletContext &#123;</div><div class="line">    private Map&lt;String, String&gt; mapping;    // url(/register) ——&gt; 别名(register)</div><div class="line">    private Map&lt;String, Servlet&gt; servlet;   // 别名(register) ——&gt; 对应的Servlet(RegisterServlet)，后期使用反射其全类名获取对象</div><div class="line">    </div><div class="line">    public <span class="function"><span class="title">ServletContext</span></span>() &#123;</div><div class="line">        mapping = new HashMap&lt;&gt;();</div><div class="line">        servlet = new HashMap&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Map&lt;String, String&gt; <span class="function"><span class="title">getMapping</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> mapping;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void <span class="built_in">set</span>Mapping(Map&lt;String, String&gt; mapping) &#123;</div><div class="line">        this.mapping = mapping;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Map&lt;String, Servlet&gt; <span class="function"><span class="title">getServlet</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> servlet;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void <span class="built_in">set</span>Servlet(Map&lt;String, Servlet&gt; servlet) &#123;</div><div class="line">        this.servlet = servlet;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>创建WebApp，保存全局变量（上下文），以及对应的操作（解析、获取）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class WebApp &#123;</div><div class="line">    private static ServletContext context;</div><div class="line">    </div><div class="line">    // 初始化请求资源路径与Servlet的对应关系，临时代码，后期解析配置文件获取对应关系</div><div class="line">    static &#123;</div><div class="line">        context = new ServletContext();</div><div class="line">        Map&lt;String, String&gt; mapping = context.getMapping();</div><div class="line">        mapping.put(<span class="string">"/reg"</span>, <span class="string">"register"</span>);</div><div class="line">        mapping.put(<span class="string">"/register"</span>, <span class="string">"register"</span>);</div><div class="line">        Map&lt;String, Servlet&gt; servlet = context.getServlet();</div><div class="line">        servlet.put(<span class="string">"register"</span>, new RegisterServlet());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 根据url获取对应的Servlet</div><div class="line">     * @param url 表单Action中的值</div><div class="line">     * @<span class="built_in">return</span> Servlet</div><div class="line">     */</div><div class="line">    public static Servlet getServlet(String url) &#123;</div><div class="line">        <span class="keyword">if</span> (null == url || url.trim().length() == 0)</div><div class="line">            <span class="built_in">return</span> null;</div><div class="line">        <span class="built_in">return</span> context.getServlet().get(context.getMapping().get(url));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>如果将上下文中存放的Servlet对象，改成存放对象全类名字符串。需要对象时，利用JAVA中的反射技术创建对象，这将极大优化内存。</p></blockquote><h3 id="九、反射"><a href="#九、反射" class="headerlink" title="九、反射"></a>九、反射</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, String &gt; servlet = context.getServlet();</div><div class="line">servlet.put(<span class="string">"register"</span>, <span class="string">"com.xian.blog.xtomcat.RegisterServlet"</span>);</div><div class="line"></div><div class="line">public static Servlet getServlet(String url) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123;</div><div class="line">    <span class="keyword">if</span> (null == url || url.trim().length() == 0)</div><div class="line">        <span class="built_in">return</span> null;</div><div class="line">    String servletName = context.getServlet().get(context.getMapping().get(url));</div><div class="line">    <span class="built_in">return</span> (Servlet)Class.forName(servletName).newInstance();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="十、Xml配置文件"><a href="#十、Xml配置文件" class="headerlink" title="十、Xml配置文件"></a>十、Xml配置文件</h3><p>将请求资源路径与Servlet的对应关系写死在程序中，不便于代码维护扩展。最好的方式将其配置的xml文件中，程序负责解析而不用经常修改代码。配置文件格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</div><div class="line">&lt;web-app&gt;</div><div class="line">    &lt;servlet&gt;</div><div class="line">        &lt;servlet-name&gt;register&lt;/servlet-name&gt;</div><div class="line">        &lt;servlet-class&gt;com.xian.blog.xtomcat.RegisterServlet&lt;/servlet-class&gt;</div><div class="line">    &lt;/servlet&gt;</div><div class="line">    &lt;servlet-mapping&gt;</div><div class="line">        &lt;servlet-name&gt;register&lt;/servlet-name&gt;</div><div class="line">        &lt;url-pattern&gt;/reg&lt;/url-pattern&gt;</div><div class="line">        &lt;url-pattern&gt;/register&lt;/url-pattern&gt;</div><div class="line">    &lt;/servlet-mapping&gt;</div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure></p><p>从文件中抽象出2个对象<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 存放配置信息：</div><div class="line"> * &lt;servlet&gt;</div><div class="line"> *      &lt;servlet-name&gt;register&lt;/servlet-name&gt;</div><div class="line"> *      &lt;servlet-class&gt;com.xian.blog.xtomcat.RegisterServlet&lt;/servlet-class&gt;</div><div class="line"> * &lt;/servlet&gt;</div><div class="line"> * @author xianxiaotao</div><div class="line"> */</div><div class="line">public class Entity &#123;</div><div class="line">    private String name;</div><div class="line">    private String clzz;</div><div class="line">    public String <span class="function"><span class="title">getName</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> name;</div><div class="line">    &#125;</div><div class="line">    public void <span class="built_in">set</span>Name(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    public String <span class="function"><span class="title">getClzz</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> clzz;</div><div class="line">    &#125;</div><div class="line">    public void <span class="built_in">set</span>Clzz(String clzz) &#123;</div><div class="line">        this.clzz = clzz;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * 存放配置信息：</div><div class="line"> * &lt;servlet-mapping&gt;</div><div class="line"> *      &lt;servlet-name&gt;register&lt;/servlet-name&gt;</div><div class="line"> *      &lt;url-pattern&gt;/reg&lt;/url-pattern&gt;</div><div class="line"> *      &lt;url-pattern&gt;/register&lt;/url-pattern&gt;</div><div class="line"> * &lt;/servlet-mapping&gt;</div><div class="line"> * @author xianxiaotao</div><div class="line"> */</div><div class="line">public class Mapping &#123;</div><div class="line">    private String name;</div><div class="line">    private List&lt;String&gt; urlPattern;</div><div class="line">    public <span class="function"><span class="title">Mapping</span></span>() &#123;</div><div class="line">        urlPattern = new ArrayList&lt;&gt;();</div><div class="line">    &#125;</div><div class="line">    public String <span class="function"><span class="title">getName</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> name;</div><div class="line">    &#125;</div><div class="line">    public void <span class="built_in">set</span>Name(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    public List&lt;String&gt; <span class="function"><span class="title">getUrlPattern</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> urlPattern;</div><div class="line">    &#125;</div><div class="line">    public void <span class="built_in">set</span>UrlPattern(List&lt;String&gt; urlPattern) &#123;</div><div class="line">        this.urlPattern = urlPattern;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>具体子类实现DefaultHandler中的方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">public class WebHandler extends DefaultHandler &#123;</div><div class="line">    private List&lt;Entity&gt; entityList;</div><div class="line">    private List&lt;Mapping&gt; mappingList;</div><div class="line">    private Entity entity;</div><div class="line">    private Mapping mapping;</div><div class="line">    private String beginTag;</div><div class="line">    private boolean isMapping;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void startDocument() throws SAXException &#123;</div><div class="line">        // 文档解析开始</div><div class="line">        entityList = new ArrayList&lt;&gt;();</div><div class="line">        mappingList = new ArrayList&lt;&gt;();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public void startElement(String uri, String <span class="built_in">local</span>Name, String qName, Attributes attributes) throws SAXException &#123;</div><div class="line">        // 开始元素</div><div class="line">        <span class="keyword">if</span> (null != qName) &#123;</div><div class="line">            beginTag = qName;</div><div class="line">            <span class="keyword">if</span> (qName.equals(<span class="string">"servlet"</span>)) &#123;</div><div class="line">                isMapping = <span class="literal">false</span>;</div><div class="line">                entity = new Entity();</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (qName.equals(<span class="string">"servlet-mapping"</span>)) &#123;</div><div class="line">                isMapping = <span class="literal">true</span>;</div><div class="line">                mapping = new Mapping();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public void characters(char[] ch, int start, int length) throws SAXException &#123;</div><div class="line">        // 处理元素</div><div class="line">        <span class="keyword">if</span> (null != beginTag) &#123;</div><div class="line">            String str = new String(ch, start, length);</div><div class="line">            <span class="keyword">if</span> (isMapping) &#123;</div><div class="line">                <span class="keyword">if</span> (beginTag.equals(<span class="string">"servlet-name"</span>)) &#123;</div><div class="line">                    mapping.setName(str);</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (beginTag.equals(<span class="string">"url-pattern"</span>)) &#123;</div><div class="line">                    mapping.getUrlPattern().add(str);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (beginTag.equals(<span class="string">"servlet-name"</span>)) &#123;</div><div class="line">                    entity.setName(str);</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (beginTag.equals(<span class="string">"servlet-class"</span>)) &#123;</div><div class="line">                    entity.setClzz(str);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public void endElement(String uri, String <span class="built_in">local</span>Name, String qName) throws SAXException &#123;</div><div class="line">        // 结束元素</div><div class="line">        <span class="keyword">if</span> (null != qName) &#123;</div><div class="line">            <span class="keyword">if</span> (qName.equals(<span class="string">"servlet"</span>)) &#123;</div><div class="line">                entityList.add(entity);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (qName.equals(<span class="string">"servlet-mapping"</span>)) &#123;</div><div class="line">                mappingList.add(mapping);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        beginTag = null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void endDocument() throws SAXException &#123;</div><div class="line">        // 文档解析结束</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public List&lt;Entity&gt; <span class="function"><span class="title">getEntityList</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> entityList;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void <span class="built_in">set</span>EntityList(List&lt;Entity&gt; entityList) &#123;</div><div class="line">        this.entityList = entityList;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public List&lt;Mapping&gt; <span class="function"><span class="title">getMappingList</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> mappingList;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void <span class="built_in">set</span>MappingList(List&lt;Mapping&gt; mappingList) &#123;</div><div class="line">        this.mappingList = mappingList;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>解析配置文件代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// 初始化请求资源路径与Servlet的对应关系，临时代码，后期解析配置文件获取对应关系</div><div class="line">static &#123;</div><div class="line">    try &#123;</div><div class="line">        SAXParserFactory factory = SAXParserFactory.newInstance();  // 获取解析工厂</div><div class="line">        SAXParser parser = factory.newSAXParser();</div><div class="line">        WebHandler handler = new WebHandler();</div><div class="line">        parser.parse(Thread.currentThread().getContextClassLoader().getResourceAsStream(<span class="string">"com/xian/blog/xtomcat/web.xml"</span>), handler);</div><div class="line">        </div><div class="line">        context = new ServletContext();</div><div class="line">        Map&lt;String, String &gt; servlet = context.getServlet();</div><div class="line">        <span class="keyword">for</span> (Entity entity : handler.getEntityList())</div><div class="line">            servlet.put(entity.getName(), entity.getClzz());</div><div class="line">        </div><div class="line">        Map&lt;String, String&gt; mapping = context.getMapping();</div><div class="line">        <span class="keyword">for</span> (Mapping mapp : handler.getMappingList()) &#123;</div><div class="line">            List&lt;String&gt; urlPatterns = mapp.getUrlPattern();</div><div class="line">            <span class="keyword">for</span> (String url : urlPatterns) &#123;</div><div class="line">                mapping.put(url, mapp.getName());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="十一、完整代码下载链接"><a href="#十一、完整代码下载链接" class="headerlink" title="十一、完整代码下载链接"></a>十一、完整代码下载链接</h3><p><a href="https://pan.baidu.com/s/1bo3Dd0r" target="_blank" rel="external">https://pan.baidu.com/s/1bo3Dd0r</a></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-28e9b830315d44c3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Socket 之聊天室原理</title>
      <link href="/1900/01/14/01%20JAVA/14%20Java%20Socket%20%E8%81%8A%E5%A4%A9%E5%AE%A4%E5%8E%9F%E7%90%86/"/>
      <url>/1900/01/14/01%20JAVA/14%20Java%20Socket%20%E8%81%8A%E5%A4%A9%E5%AE%A4%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>相关文章：<br><a href="https://xianxiaotao.github.io/1900/01/13/01%20JAVA/13%20Java%20Socket/" target="_blank" rel="external">Java Socket</a><br><a href="https://xianxiaotao.github.io/1900/01/14/01%20JAVA/14%20Java%20Socket%20%E8%81%8A%E5%A4%A9%E5%AE%A4%E5%8E%9F%E7%90%86/" target="_blank" rel="external">Java Socket 聊天室原理</a><br><a href="https://xianxiaotao.github.io/1900/01/15/01%20JAVA/15%20Java%20Socket%20%E5%A6%82%E4%BD%95%E6%BC%94%E5%8C%96%E6%88%90%20Tomcat/" target="_blank" rel="external">Java Socket 如何演化成 Tomcat</a></p></blockquote><p>JAVA为基于TCP协议开发提供了相关API，具体代码如下。<br>客户端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Socket client = new Socket(<span class="string">"localhost"</span>, 9876);// 创建客户端，并指定服务器端地址和端口</div><div class="line">DataOutputStream dos = new DataOutputStream(client.getOutputStream());</div><div class="line">dos.writeUTF(<span class="string">"客户端向服务器端发送数据"</span>);           // 客户端向服务器发送数据</div><div class="line"></div><div class="line">DataInputStream dis = new DataInputStream(client.getInputStream());</div><div class="line">String msg = dis.readUTF();                     // 客户端接受服务器端返回的数据</div><div class="line">System.out.println(msg);</div><div class="line">client.close();</div></pre></td></tr></table></figure></p><p>服务端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ServerSocket server = new ServerSocket(9876);   // 创建服务器并指定端口</div><div class="line">Socket socket = server.accept();                // 接受客户端连接（阻塞式）</div><div class="line"></div><div class="line">DataInputStream dis = new DataInputStream(socket.getInputStream());</div><div class="line">String msg = dis.readUTF();                     // 读取客户端请求数据</div><div class="line"></div><div class="line">DataOutputStream dos = new DataOutputStream(socket.getOutputStream());</div><div class="line">dos.writeUTF(<span class="string">"服务器接受的数据："</span> + msg);          // 服务器端返回客户端数据</div><div class="line">dos.flush();</div><div class="line">server.close();</div></pre></td></tr></table></figure></p><blockquote><p>上述代码中，只建立一次请求，为实现双方多次交互，则需要加入循环处理；而且客户端发送数据和接受数据都在一个线程中，意味着客户端不发送数据就接受不了服务端返回的数据，因此他们需要在不同的线程中处理各自的业务。服务器端同理。</p></blockquote><h3 id="客户端实现多线程"><a href="#客户端实现多线程" class="headerlink" title="客户端实现多线程"></a>客户端实现多线程</h3><p>发送数据线程：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public class Send implements Runnable &#123;</div><div class="line">    private BufferedReader console;     // 测试时使用控制台输入信息</div><div class="line">    private DataOutputStream dos;       // 输出流（发送数据）</div><div class="line">    private boolean isRunning = <span class="literal">true</span>;   // 控制线程运行</div><div class="line">    </div><div class="line">    public Send(Socket client) &#123;</div><div class="line">        console = new BufferedReader(new InputStreamReader(System.in));</div><div class="line">        try &#123;</div><div class="line">            dos = new DataOutputStream(client.getOutputStream());</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            end();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private String <span class="function"><span class="title">getMsgFromConsole</span></span>() &#123;</div><div class="line">        try &#123; <span class="built_in">return</span> console.readLine(); &#125; catch (IOException e) &#123;&#125;</div><div class="line">        <span class="built_in">return</span> <span class="string">""</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private void <span class="function"><span class="title">end</span></span>() &#123;    // 出现异常则结束线程</div><div class="line">        isRunning = <span class="literal">false</span>; </div><div class="line">        CloseUtil.closeIO(console, dos);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private void <span class="function"><span class="title">send</span></span>() &#123;   // 发送数据</div><div class="line">        String msg = getMsgFromConsole();</div><div class="line">        try &#123;</div><div class="line">            <span class="keyword">if</span> (null != msg &amp;&amp; msg.length() &gt; 0)</div><div class="line">                dos.writeUTF(msg);</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">        end();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void <span class="function"><span class="title">run</span></span>() &#123;     // 线程体</div><div class="line">        <span class="keyword">while</span> (isRunning)</div><div class="line">            send();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>接受数据线程：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class Receive implements Runnable &#123;</div><div class="line">    private DataInputStream dis;      // 输入流（接受数据）</div><div class="line">    private boolean isRunning = <span class="literal">true</span>; // 控制线程运行</div><div class="line"></div><div class="line">    public Receive (Socket client) &#123;</div><div class="line">        try &#123;</div><div class="line">            dis = new DataInputStream(client.getInputStream());</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            end();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void <span class="function"><span class="title">end</span></span>() &#123;              // 出现异常则结束线程</div><div class="line">        isRunning = <span class="literal">false</span>; </div><div class="line">        CloseUtil.closeIO(dis);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private String <span class="function"><span class="title">receive</span></span>() &#123;        // 接受数据</div><div class="line">        String msg = <span class="string">""</span>;</div><div class="line">        try &#123;</div><div class="line">            msg = dis.readUTF();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            end();</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> msg;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">        <span class="keyword">while</span> (isRunning) </div><div class="line">            System.out.println(receive());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>客户端只需开启Send、Receive两个线程：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Socket client = new Socket(<span class="string">"localhost"</span>, 9876); // 创建客户端，并指定服务器端地址和端口</div><div class="line">new Thread(new Send(client)).start();</div><div class="line">new Thread(new Receive(client)).start();</div></pre></td></tr></table></figure></p><h3 id="服务端实现群聊"><a href="#服务端实现群聊" class="headerlink" title="服务端实现群聊"></a>服务端实现群聊</h3><p>群聊，将服务端作为中转站，转发所有客户消息给其他客户（不需转给自己）。因此，服务端需要管理所有的连接通道，每个通道封装数据信息以及对应的操作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">public class Server &#123;</div><div class="line">    // 保存连接通道</div><div class="line">    private List&lt;ChatChannel&gt; channels = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    // 启动服务</div><div class="line">    public void start() throws IOException &#123;</div><div class="line">        @SuppressWarnings(<span class="string">"resource"</span>)</div><div class="line">        ServerSocket server = new ServerSocket(9876);</div><div class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">            Socket client = server.accept();</div><div class="line">            ChatChannel channel = new ChatChannel(client);</div><div class="line">            channels.add(channel);</div><div class="line">            new Thread(channel).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 连接通道类</div><div class="line">    private class ChatChannel implements Runnable &#123;</div><div class="line">        private DataInputStream dis;</div><div class="line">        private DataOutputStream dos;</div><div class="line">        private boolean isRunning = <span class="literal">true</span>;</div><div class="line"></div><div class="line">        public ChatChannel(Socket socket) &#123;</div><div class="line">            try &#123;</div><div class="line">                dis = new DataInputStream(socket.getInputStream());</div><div class="line">                dos = new DataOutputStream(socket.getOutputStream());</div><div class="line">            &#125; catch (IOException e) &#123;</div><div class="line">                end();</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">        private String <span class="function"><span class="title">receive</span></span>() &#123;</div><div class="line">            String msg = <span class="string">""</span>;</div><div class="line">            try &#123;</div><div class="line">                msg = dis.readUTF();</div><div class="line">            &#125; catch (IOException e) &#123;</div><div class="line">                end();</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">return</span> msg;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        private void send(String msg) &#123;</div><div class="line">            <span class="keyword">if</span> (null == msg || msg.length() == 0)</div><div class="line">                <span class="built_in">return</span>;</div><div class="line">            try &#123;</div><div class="line">                dos.writeUTF(msg);</div><div class="line">                dos.flush();</div><div class="line">            &#125; catch (IOException e) &#123;</div><div class="line">                end();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        private void <span class="function"><span class="title">end</span></span>() &#123;</div><div class="line">            CloseUtil.closeIO(dis, dos);</div><div class="line">            isRunning = <span class="literal">false</span>;</div><div class="line">            channels.remove(this);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">            <span class="keyword">while</span> (isRunning) &#123;</div><div class="line">                String msg = receive();</div><div class="line">                <span class="keyword">for</span> (ChatChannel other : channels) &#123;</div><div class="line">                    <span class="keyword">if</span> (other == this)</div><div class="line">                        <span class="built_in">continue</span>;</div><div class="line">                    other.send(msg);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>开启服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new Server().start();</div></pre></td></tr></table></figure></p><h3 id="私聊"><a href="#私聊" class="headerlink" title="私聊"></a>私聊</h3><p>要找到对应的用户进行私聊，需要对每个客户端进行唯一性标示，即创建客户端的时候指定用户名/ID并发送给服务端，服务端在创建对应的ChatChannel时，保存获取到的用户名/ID信息。而私聊的代码实现就是将信息转发到指定的ChatChannel连接通道中。</p><blockquote><p>按照面向对象编程的思想，用户信息、消息本体都要封装成一个个的对象。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Socket</title>
      <link href="/1900/01/13/01%20JAVA/13%20Java%20Socket/"/>
      <url>/1900/01/13/01%20JAVA/13%20Java%20Socket/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>相关文章：<br><a href="https://xianxiaotao.github.io/1900/01/13/01%20JAVA/13%20Java%20Socket/" target="_blank" rel="external">Java Socket</a><br><a href="https://xianxiaotao.github.io/1900/01/14/01%20JAVA/14%20Java%20Socket%20%E8%81%8A%E5%A4%A9%E5%AE%A4%E5%8E%9F%E7%90%86/" target="_blank" rel="external">Java Socket 聊天室原理</a><br><a href="https://xianxiaotao.github.io/1900/01/15/01%20JAVA/15%20Java%20Socket%20%E5%A6%82%E4%BD%95%E6%BC%94%E5%8C%96%E6%88%90%20Tomcat/" target="_blank" rel="external">Java Socket 如何演化成 Tomcat</a></p></blockquote><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><hr><p>Socket 是 Java 网络编程的基础，了解还是有好处的，这篇文章主要讲解 Socket 的基础编程。Socket 用在哪呢，主要用在进程间，网络间通信。</p><h4 id="1-1、网络编程中两个主要的问题"><a href="#1-1、网络编程中两个主要的问题" class="headerlink" title="1.1、网络编程中两个主要的问题"></a>1.1、网络编程中两个主要的问题</h4><p>一个是如何准确的定位网络上一台或多台主机，另一个就是找到主机后如何可靠高效的进行数据传输。</p><p>在 TCP/I P协议中 IP 层主要负责网络主机的定位，数据传输的路由，由 IP 地址可以唯一地确定 Internet 上的一台主机。</p><p>而 TCP 层则提供面向应用的可靠（TCP）的或非可靠（UDP）的数据传输机制，这是网络编程的主要对象，一般不需要关心 IP 层是如何处理数据的。</p><p>目前较为流行的网络编程模型是客户机/服务器（C/S）结构。 即通信双方一方作为服务器等待客户提出请求并予以响应。客户则在需要服务时向服务器提出申请。服务器一般作为守护进程始终运行，监听网络端口，一旦有客户请求，就会启动一个服务进程来响应该客户，同时自己继续监听服务端口，使后来的客户也能及时得到服务。</p><h4 id="1-2、两类传输协议：TCP-和-UDP"><a href="#1-2、两类传输协议：TCP-和-UDP" class="headerlink" title="1.2、两类传输协议：TCP 和 UDP"></a>1.2、两类传输协议：TCP 和 UDP</h4><p>TCP 是 Tranfer Control Protocol 的简称，是一种面向连接的保证可靠传输的协议。通过 TCP 协议传输，得到的是一个顺序的无差错的数据流。发送方和接收方的成对的两个 socket 之间必须建立连接，以便在 TCP 协议的基础上进行通信，当一个 socket（通常都是server socket）等待建立连接时，另一个 socket 可以要求进行连接，一旦这两个 socket 连接起来，它们就可以进行双向数据传输，双方都可以进行发送或接收操作。</p><p>UDP 是 User Datagram Protocol 的简称，是一种无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。</p><p>TCP 和 UDP 的区别：<br>UDP：<br>1）每个数据报中都给出了完整的地址信息，因此无需要建立发送方和接收方的连接。<br>2）UDP传输数据时是有大小限制的，每个被传输的数据报必须限定在 64KB 之内。<br>3）UDP 是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方。</p><p>TCP：<br>1）面向连接的协议，在 socket 之间进行数据传输之前必然要建立连接，所以在 TCP 中需要连接时间。<br>2）TCP 传输数据大小限制，一旦连接建立起来，双方的 socket 就可以按统一的格式传输大的数据。<br>3）TCP是一个可靠的协议，它确保接收方完全正确地获取发送方所发送的全部数据。</p><p>应用：<br>1，TCP 在网络通信上有极强的生命力，例如远程连接（Telnet）和文件传输（FTP）都需要不定长度的数据被可靠地传输。但是可靠的传输是要付出代价的，对数据内容正确性的检验必然占用计算机的处理时间和网络的带宽，因此 TCP 传输的效率不如 UDP 高。</p><p>2，UDP 操作简单，而且仅需要较少的监护，因此通常用于局域网高可靠性的分散系统中 client/server 应用程序。例如视频会议系统，并不要求音频视频数据绝对的正确，只要保证连贯性就可以了，这种情况下显然使用UDP会更合理一些。</p><h3 id="二、Java-Socket"><a href="#二、Java-Socket" class="headerlink" title="二、Java Socket"></a>二、Java Socket</h3><hr><h4 id="2-1、什么是-Socket"><a href="#2-1、什么是-Socket" class="headerlink" title="2.1、什么是 Socket"></a>2.1、什么是 Socket</h4><p>网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个 Socket。Socket 通常用来实现客户方和服务方的连接。Socket 是 TCP/IP 协议的一个十分流行的编程界面，一个 Socket 由一个 IP 地址和一个端口号唯一确定。</p><p>但是，Socket 所支持的协议种类也不光 TCP/IP 一种，因此两者之间是没有必然联系的。在 Java 环境下，Socket 编程主要是指基于 TCP/IP 协议的网络编程。</p><h4 id="2-2、Socket-通讯的过程"><a href="#2-2、Socket-通讯的过程" class="headerlink" title="2.2、Socket 通讯的过程"></a>2.2、Socket 通讯的过程</h4><p>Server 端 Listen（监听）某个端口是否有连接请求，Client 端向 Server 端发出 Connect（连接）请求，Server 端向 Client 端发回 Accept（接受）消息。一个连接就建立起来了。Server 端和 Client 端都可以通过 Send，Write 等方法与对方通信。</p><p>对于一个功能齐全的 Socket，都要包含以下基本结构，其工作过程包含以下四个基本的步骤：<br>1）创建 Socket；<br>2）打开连接到 Socket 的输入/出流；<br>3）按照一定的协议对 Socket 进行读/写操作；<br>4）关闭 Socket.（在实际应用中，并未使用到显示的 close，虽然很多文章都推荐如此，不过在我的程序中，可能因为程序本身比较简单，要求不高，所以并未造成什么影响。）</p><h4 id="2-3、创建-Socket"><a href="#2-3、创建-Socket" class="headerlink" title="2.3、创建 Socket"></a>2.3、创建 Socket</h4><p>Java 在包 java.net 中提供了两个类：Socket 和 ServerSocket，分别用来表示双向连接的客户端和服务端。这是两个封装得非常好的类，使用很方便。其构造方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Socket(InetAddress address, int port);</div><div class="line">Socket(InetAddress address, int port, boolean stream);</div><div class="line">Socket(String host, int prot);</div><div class="line">Socket(String host, int prot, boolean stream);</div><div class="line">Socket(SocketImpl impl)</div><div class="line">Socket(String host, int port, InetAddress localAddr, int localPort)</div><div class="line">Socket(InetAddress address, int port, InetAddress localAddr, int localPort)</div><div class="line">ServerSocket(int port);</div><div class="line">ServerSocket(int port, int backlog);</div><div class="line">ServerSocket(int port, int backlog, InetAddress bindAddr)</div></pre></td></tr></table></figure></p><p>其中 address、host 和 port 分别是双向连接中另一方的 IP 地址、主机名和端口号，stream 指明 socket 是流 socket 还是数据报 socket，localPort 表示本地主机的端口号，localAddr 和 bindAddr 是本地机器的地址（ServerSocket 的主机地址），impl 是 socket 的父类，既可以用来创建 serverSocket 又可以用来创建 Socket。count 则表示服务端所能支持的最大连接数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Socket client = new Socket(&quot;127.0.01.&quot;, 80);</div><div class="line">ServerSocket server = new ServerSocket(80);</div></pre></td></tr></table></figure></p><p>注意，在选择端口时，必须小心。每一个端口提供一种特定的 服务，只有给出正确的端口，才能获得相应的服务。0~1023 的端口号为系统所保留，例如 http 服务的端口号为 80，telnet 服务的端口号为 21，ftp 服务的端口号为 23，所以我们在选择端口号时，最好选择一个大于 1023 的数以防止发生冲突。</p><p>在创建 socket 时如果发生错误，将产生 IOException，在程序中必须对之作出处理。所以在创建 Socket 或 ServerSocket 是必须捕获或抛出例外。</p><h4 id="2-4-示例"><a href="#2-4-示例" class="headerlink" title="2.4 示例"></a>2.4 示例</h4><p>服务器端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import java.io.InputStream;</div><div class="line">import java.net.ServerSocket;</div><div class="line">import java.net.Socket;</div><div class="line"></div><div class="line">public class SocketServer &#123;</div><div class="line">  public static void main(String[] args) throws Exception &#123;</div><div class="line">    // 监听指定的端口</div><div class="line">    int port = 55533;</div><div class="line">    ServerSocket server = new ServerSocket(port);</div><div class="line">    </div><div class="line">    // server将一直等待连接的到来</div><div class="line">    System.out.println(&quot;server将一直等待连接的到来&quot;);</div><div class="line">    Socket socket = server.accept();</div><div class="line">    // 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取</div><div class="line">    InputStream inputStream = socket.getInputStream();</div><div class="line">    byte[] bytes = new byte[1024];</div><div class="line">    int len;</div><div class="line">    StringBuilder sb = new StringBuilder();</div><div class="line">    while ((len = inputStream.read(bytes)) != -1) &#123;</div><div class="line">      //注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</div><div class="line">      sb.append(new String(bytes, 0, len,&quot;UTF-8&quot;));</div><div class="line">    &#125;</div><div class="line">    System.out.println(&quot;get message from client: &quot; + sb);</div><div class="line">    inputStream.close();</div><div class="line">    socket.close();</div><div class="line">    server.close();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>客户端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import java.io.OutputStream;</div><div class="line">import java.net.Socket;</div><div class="line"></div><div class="line">public class SocketClient &#123;</div><div class="line">  public static void main(String args[]) throws Exception &#123;</div><div class="line">    // 要连接的服务端IP地址和端口</div><div class="line">    String host = &quot;127.0.0.1&quot;; </div><div class="line">    int port = 55533;</div><div class="line">    // 与服务端建立连接</div><div class="line">    Socket socket = new Socket(host, port);</div><div class="line">    // 建立连接后获得输出流</div><div class="line">    OutputStream outputStream = socket.getOutputStream();</div><div class="line">    String message=&quot;你好  xianxiaotao&quot;;</div><div class="line">    socket.getOutputStream().write(message.getBytes(&quot;UTF-8&quot;));</div><div class="line">    outputStream.close();</div><div class="line">    socket.close();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>客户端通过 IP 和端口，连接到指定的 server，然后通过 Socket 获得输出流，并向其输出内容，服务器会获得消息。最终服务端控制台打印如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">server将一直等待连接的到来</div><div class="line">get message from client: 你好  xianxiaotao</div></pre></td></tr></table></figure></p><p>通过这个例子应该掌握并了解：</p><ul><li>Socket 服务端和客户端的基本编程</li><li>传输编码统一指定，防止乱码</li></ul><p>这个例子做为学习的基本例子，实际开发中会有各种变形，比如客户端在发送完消息后，需要服务端进行处理并返回。</p><h3 id="三、消息通信优化"><a href="#三、消息通信优化" class="headerlink" title="三、消息通信优化"></a>三、消息通信优化</h3><hr><h4 id="3-1-双向通信，发送消息并接受消息"><a href="#3-1-双向通信，发送消息并接受消息" class="headerlink" title="3.1 双向通信，发送消息并接受消息"></a>3.1 双向通信，发送消息并接受消息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">import java.io.InputStream;</div><div class="line">import java.io.OutputStream;</div><div class="line">import java.net.ServerSocket;</div><div class="line">import java.net.Socket;</div><div class="line"></div><div class="line">public class SocketServer &#123;</div><div class="line">  public static void main(String[] args) throws Exception &#123;</div><div class="line">    // 监听指定的端口</div><div class="line">    int port = 55533;</div><div class="line">    ServerSocket server = new ServerSocket(port);</div><div class="line">    </div><div class="line">    // server将一直等待连接的到来</div><div class="line">    System.out.println(&quot;server将一直等待连接的到来&quot;);</div><div class="line">    Socket socket = server.accept();</div><div class="line">    // 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取</div><div class="line">    InputStream inputStream = socket.getInputStream();</div><div class="line">    byte[] bytes = new byte[1024];</div><div class="line">    int len;</div><div class="line">    StringBuilder sb = new StringBuilder();</div><div class="line">    //只有当客户端关闭它的输出流的时候，服务端才能取得结尾的-1</div><div class="line">    while ((len = inputStream.read(bytes)) != -1) &#123;</div><div class="line">      // 注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</div><div class="line">      sb.append(new String(bytes, 0, len, &quot;UTF-8&quot;));</div><div class="line">    &#125;</div><div class="line">    System.out.println(&quot;get message from client: &quot; + sb);</div><div class="line"></div><div class="line">    OutputStream outputStream = socket.getOutputStream();</div><div class="line">    outputStream.write(&quot;Hello Client,I get the message.&quot;.getBytes(&quot;UTF-8&quot;));</div><div class="line"></div><div class="line">    inputStream.close();</div><div class="line">    outputStream.close();</div><div class="line">    socket.close();</div><div class="line">    server.close();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>与之前 server 的不同在于，当读取完客户端的消息后，打开输出流，将指定消息发送回客户端，客户端程序为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">import java.io.InputStream;</div><div class="line">import java.io.OutputStream;</div><div class="line">import java.net.Socket;</div><div class="line"></div><div class="line">public class SocketClient &#123;</div><div class="line">  public static void main(String args[]) throws Exception &#123;</div><div class="line">    // 要连接的服务端IP地址和端口</div><div class="line">    String host = &quot;127.0.0.1&quot;;</div><div class="line">    int port = 55533;</div><div class="line">    // 与服务端建立连接</div><div class="line">    Socket socket = new Socket(host, port);</div><div class="line">    // 建立连接后获得输出流</div><div class="line">    OutputStream outputStream = socket.getOutputStream();</div><div class="line">    String message = &quot;你好  xianxiaotao&quot;;</div><div class="line">    socket.getOutputStream().write(message.getBytes(&quot;UTF-8&quot;));</div><div class="line">    //通过shutdownOutput高速服务器已经发送完数据，后续只能接受数据</div><div class="line">    socket.shutdownOutput();</div><div class="line">    </div><div class="line">    InputStream inputStream = socket.getInputStream();</div><div class="line">    byte[] bytes = new byte[1024];</div><div class="line">    int len;</div><div class="line">    StringBuilder sb = new StringBuilder();</div><div class="line">    while ((len = inputStream.read(bytes)) != -1) &#123;</div><div class="line">      //注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</div><div class="line">      sb.append(new String(bytes, 0, len,&quot;UTF-8&quot;));</div><div class="line">    &#125;</div><div class="line">    System.out.println(&quot;get message from server: &quot; + sb);</div><div class="line">    </div><div class="line">    inputStream.close();</div><div class="line">    outputStream.close();</div><div class="line">    socket.close();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>客户端也有相应的变化，在发送完消息时，调用关闭输出流方法，然后打开输出流，等候服务端的消息。</p><h4 id="3-2-关闭通信"><a href="#3-2-关闭通信" class="headerlink" title="3.2 关闭通信"></a>3.2 关闭通信</h4><p>正常来说，客户端打开一个输出流，如果不做约定，也不关闭它，那么服务端永远不知道客户端是否发送完消息，那么服务端会一直等待下去，直到读取超时。所以怎么告知服务端已经发送完消息就显得特别重要。</p><h5 id="3-2-1-关闭-Socket"><a href="#3-2-1-关闭-Socket" class="headerlink" title="3.2.1 关闭 Socket"></a>3.2.1 关闭 Socket</h5><p>当 Socket 关闭的时候，服务端就会收到响应的关闭信号，那么服务端也就知道流已经关闭了，这个时候读取操作完成，就可以继续后续工作。但是这种方式有一些缺点</p><ul><li>客户端 Socket 关闭后，将不能接受服务端发送的消息，也不能再次发送消息。</li><li>如果客户端想再次发送消息，需要重现创建 Socket 连接。</li></ul><h5 id="3-2-2-shutdownOutput"><a href="#3-2-2-shutdownOutput" class="headerlink" title="3.2.2 shutdownOutput"></a>3.2.2 shutdownOutput</h5><p>通过 Socket 关闭输出流的方式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socket.shutdownOutput();</div></pre></td></tr></table></figure></p><p>而不是（outputStream为发送消息到服务端打开的输出流）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">outputStream.close();</div></pre></td></tr></table></figure></p><p>如果关闭了输出流，那么相应的 Socket 也将关闭，和直接关闭 Socke t一个性质。</p><p>调用 Socket 的 shutdownOutput() 方法，底层会告知服务端我这边已经写完了，那么服务端收到消息后，就能知道已经读取完消息，如果服务端有要返回给客户的消息那么就可以通过服务端的输出流发送给客户端，如果没有，直接关闭 Socket。</p><p>这种方式通过关闭客户端的输出流，告知服务端已经写完了，虽然可以读到服务端发送的消息，但是还是有一点缺点：不能再次发送消息给服务端，如果再次发送，需要重新建立Socket连接。</p><p>这个缺点，在访问频率比较高的情况下将是一个需要优化的地方。</p><h5 id="3-2-3-通过约定符号"><a href="#3-2-3-通过约定符号" class="headerlink" title="3.2.3 通过约定符号"></a>3.2.3 通过约定符号</h5><p>这种方式的用法，就是双方约定一个字符或者一个短语，来当做消息发送完成的标识，通常这么做就需要改造读取方法。</p><p>假如约定单独的一行为 end，代表发送完成，例如下面的消息，end则代表消息发送完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hello 先小涛</div><div class="line">end</div></pre></td></tr></table></figure></p><p>那么服务端响应的读取操作需要进行如下改造：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Socket socket = server.accept();</div><div class="line">// 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取</div><div class="line">BufferedReader read=new BufferedReader(new InputStreamReader(socket.getInputStream(),&quot;UTF-8&quot;));</div><div class="line">String line;</div><div class="line">StringBuilder sb = new StringBuilder();</div><div class="line">while ((line = read.readLine()) != null &amp;&amp; !&quot;end&quot;.equals(line)) &#123;</div><div class="line">  //注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</div><div class="line">  sb.append(line);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看见，服务端不仅判断是否读到了流的末尾，还判断了是否读到了约定的末尾。这么做的优缺点如下：</p><ul><li>优点：不需要关闭流，当发送完一条命令（消息）后可以再次发送新的命令（消息）。</li><li>缺点：需要额外的约定结束标志，太简单的容易出现在要发送的消息中，误被结束，太复杂的不好处理，还占带宽。<br>经过了这么多的优化还是有缺点，难道就没有完美的解决方案吗，答案是有的，看接下来的内容。</li></ul><h5 id="3-2-4-通过指定长度"><a href="#3-2-4-通过指定长度" class="headerlink" title="3.2.4 通过指定长度"></a>3.2.4 通过指定长度</h5><p>如果你了解一点 class 文件的结构，那么你就会佩服这么设计方式，也就是说我们可以在此找灵感，就是我们可以<strong>先指定后续命令的长度</strong>，然后读取指定长度的内容做为客户端发送的消息。</p><p>现在首要的问题就是用几个字节指定长度呢，我们可以算一算：</p><blockquote><p>1个字节：最大256，表示256B<br>2个字节：最大65536，表示64K<br>3个字节：最大16777216，表示16M<br>4个字节：最大4294967296，表示4G<br>依次类推…</p></blockquote><p>这个时候是不是很纠结，最大的当然是最保险的，但是真的有必要选择最大的吗，其实如果你稍微了解一点UTF-8的编码方式，那么你就应该能想到为什么一定要固定表示长度字节的长度呢，我们可以使用变长方式来表示长度的表示，比如：</p><blockquote><p>第一个字节首位为0：即0XXXXXXX，表示长度就一个字节，最大128，表示128B<br>第一个字节首位为110，那么附带后面一个字节表示长度：即110XXXXX 10XXXXXX，最大2048，表示2K<br>第一个字节首位为1110，那么附带后面二个字节表示长度：即110XXXXX 10XXXXXX 10XXXXXX，最大131072，表示128K<br>依次类推</p></blockquote><p>上面提到的这种用法适合高富帅的程序员使用，一般呢，如果用作命名发送，两个字节就够了，如果还不放心4个字节基本就能满足你的所有要求，下面的例子我们将采用2个字节表示长度，目的只是给你一种思路，让你知道有这种方式来获取消息的结尾：</p><p>服务端程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">import java.io.InputStream;</div><div class="line">import java.net.ServerSocket;</div><div class="line">import java.net.Socket;</div><div class="line"></div><div class="line">public class SocketServer &#123;</div><div class="line">  public static void main(String[] args) throws Exception &#123;</div><div class="line">    // 监听指定的端口</div><div class="line">    int port = 55533;</div><div class="line">    ServerSocket server = new ServerSocket(port);</div><div class="line"></div><div class="line">    // server将一直等待连接的到来</div><div class="line">    System.out.println(&quot;server将一直等待连接的到来&quot;);</div><div class="line">    Socket socket = server.accept();</div><div class="line">    // 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取</div><div class="line">    InputStream inputStream = socket.getInputStream();</div><div class="line">    byte[] bytes;</div><div class="line">    // 因为可以复用Socket且能判断长度，所以可以一个Socket用到底</div><div class="line">    while (true) &#123;</div><div class="line">      // 首先读取两个字节表示的长度</div><div class="line">      int first = inputStream.read();</div><div class="line">      //如果读取的值为-1 说明到了流的末尾，Socket已经被关闭了，此时将不能再去读取</div><div class="line">      if(first==-1)&#123;</div><div class="line">        break;</div><div class="line">      &#125;</div><div class="line">      int second = inputStream.read();</div><div class="line">      int length = (first &lt;&lt; 8) + second;</div><div class="line">      // 然后构造一个指定长的byte数组</div><div class="line">      bytes = new byte[length];</div><div class="line">      // 然后读取指定长度的消息即可</div><div class="line">      inputStream.read(bytes);</div><div class="line">      System.out.println(&quot;get message from client: &quot; + new String(bytes, &quot;UTF-8&quot;));</div><div class="line">    &#125;</div><div class="line">    inputStream.close();</div><div class="line">    socket.close();</div><div class="line">    server.close();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>此处的读取步骤为，先读取两个字节的长度，然后读取消息，客户端为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">import java.io.OutputStream;</div><div class="line">import java.net.Socket;</div><div class="line"></div><div class="line">public class SocketClient &#123;</div><div class="line">  public static void main(String args[]) throws Exception &#123;</div><div class="line">    // 要连接的服务端IP地址和端口</div><div class="line">    String host = &quot;127.0.0.1&quot;;</div><div class="line">    int port = 55533;</div><div class="line">    // 与服务端建立连接</div><div class="line">    Socket socket = new Socket(host, port);</div><div class="line">    // 建立连接后获得输出流</div><div class="line">    OutputStream outputStream = socket.getOutputStream();</div><div class="line">    String message = &quot;你好  xianxiaotao&quot;;</div><div class="line">    //首先需要计算得知消息的长度</div><div class="line">    byte[] sendBytes = message.getBytes(&quot;UTF-8&quot;);</div><div class="line">    //然后将消息的长度优先发送出去</div><div class="line">    outputStream.write(sendBytes.length &gt;&gt;8);</div><div class="line">    outputStream.write(sendBytes.length);</div><div class="line">    //然后将消息再次发送出去</div><div class="line">    outputStream.write(sendBytes);</div><div class="line">    outputStream.flush();</div><div class="line">    //==========此处重复发送一次，实际项目中为多个命名，此处只为展示用法</div><div class="line">    message = &quot;第二条消息&quot;;</div><div class="line">    sendBytes = message.getBytes(&quot;UTF-8&quot;);</div><div class="line">    outputStream.write(sendBytes.length &gt;&gt;8);</div><div class="line">    outputStream.write(sendBytes.length);</div><div class="line">    outputStream.write(sendBytes);</div><div class="line">    outputStream.flush();</div><div class="line">    //==========此处重复发送一次，实际项目中为多个命名，此处只为展示用法</div><div class="line">    message = &quot;the third message!&quot;;</div><div class="line">    sendBytes = message.getBytes(&quot;UTF-8&quot;);</div><div class="line">    outputStream.write(sendBytes.length &gt;&gt;8);</div><div class="line">    outputStream.write(sendBytes.length);</div><div class="line">    outputStream.write(sendBytes);    </div><div class="line">    </div><div class="line">    outputStream.close();</div><div class="line">    socket.close();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>客户端要多做的是，在发送消息之前先把消息的长度发送过去。</p><p>当然如果是需要服务器返回结果，那么也依然使用这种方式，服务端也是先发送结果的长度，然后客户端进行读取。当然现在流行的就是，长度+类型+数据模式的传输方式。</p><h3 id="四、服务端优化"><a href="#四、服务端优化" class="headerlink" title="四、服务端优化"></a>四、服务端优化</h3><hr><h4 id="4-1-服务端并发处理能力"><a href="#4-1-服务端并发处理能力" class="headerlink" title="4.1 服务端并发处理能力"></a>4.1 服务端并发处理能力</h4><p>在上面的例子中，服务端仅仅只是接受了一个 Socket 请求，并处理了它，然后就结束了，但是在实际开发中，一个 Socket 服务往往需要服务大量的 Socket 请求，那么就不能再服务完一个 Socket 的时候就关闭了，这时候可以采用循环接受请求并处理的逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.net.ServerSocket;</div><div class="line">import java.net.Socket;</div><div class="line"></div><div class="line">public class SocketServer &#123;</div><div class="line">  public static void main(String args[]) throws IOException &#123;</div><div class="line">    // 监听指定的端口</div><div class="line">    int port = 55533;</div><div class="line">    ServerSocket server = new ServerSocket(port);</div><div class="line">    // server将一直等待连接的到来</div><div class="line">    System.out.println(&quot;server将一直等待连接的到来&quot;);</div><div class="line">    </div><div class="line">    while(true) &#123;</div><div class="line">      Socket socket = server.accept();</div><div class="line">      // 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取</div><div class="line">      InputStream inputStream = socket.getInputStream();</div><div class="line">      byte[] bytes = new byte[1024];</div><div class="line">      int len;</div><div class="line">      StringBuilder sb = new StringBuilder();</div><div class="line">      while ((len = inputStream.read(bytes)) != -1) &#123;</div><div class="line">        // 注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</div><div class="line">        sb.append(new String(bytes, 0, len, &quot;UTF-8&quot;));</div><div class="line">      &#125;</div><div class="line">      System.out.println(&quot;get message from client: &quot; + sb);</div><div class="line">      inputStream.close();</div><div class="line">      socket.close();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这种一般也是新手写法，但是能够循环处理多个 Socket 请求，不过当一个请求的处理比较耗时的时候，后面的请求将被阻塞，所以一般都是用多线程的方式来处理 Socket，即每有一个 Socket 请求的时候，就创建一个线程来处理它。</p><p>不过在实际生产中，创建的线程会交给线程池来处理，为了：</p><ul><li>线程复用，创建线程耗时，回收线程慢。</li><li>防止短时间内高并发，指定线程池大小，超过数量将等待，方式短时间创建大量线程导致资源耗尽，服务挂掉。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">import java.io.InputStream;</div><div class="line">import java.net.ServerSocket;</div><div class="line">import java.net.Socket;</div><div class="line">import java.util.concurrent.ExecutorService;</div><div class="line">import java.util.concurrent.Executors;</div><div class="line"></div><div class="line">public class SocketServer &#123;</div><div class="line">  public static void main(String args[]) throws Exception &#123;</div><div class="line">    // 监听指定的端口</div><div class="line">    int port = 55533;</div><div class="line">    ServerSocket server = new ServerSocket(port);</div><div class="line">    // server将一直等待连接的到来</div><div class="line">    System.out.println(&quot;server将一直等待连接的到来&quot;);</div><div class="line"></div><div class="line">    //如果使用多线程，那就需要线程池，防止并发过高时创建过多线程耗尽资源</div><div class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(100);</div><div class="line">    </div><div class="line">    while (true) &#123;</div><div class="line">      Socket socket = server.accept();</div><div class="line">      </div><div class="line">      Runnable runnable=()-&gt;&#123;</div><div class="line">        try &#123;</div><div class="line">          // 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取</div><div class="line">          InputStream inputStream = socket.getInputStream();</div><div class="line">          byte[] bytes = new byte[1024];</div><div class="line">          int len;</div><div class="line">          StringBuilder sb = new StringBuilder();</div><div class="line">          while ((len = inputStream.read(bytes)) != -1) &#123;</div><div class="line">            // 注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</div><div class="line">            sb.append(new String(bytes, 0, len, &quot;UTF-8&quot;));</div><div class="line">          &#125;</div><div class="line">          System.out.println(&quot;get message from client: &quot; + sb);</div><div class="line">          inputStream.close();</div><div class="line">          socket.close();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">          e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">      &#125;;</div><div class="line">      threadPool.submit(runnable);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用线程池的方式，算是一种成熟的方式。可以应用在生产中。</p><h4 id="4-2-服务端其他属性"><a href="#4-2-服务端其他属性" class="headerlink" title="4.2 服务端其他属性"></a>4.2 服务端其他属性</h4><p>ServerSocket 有以下 3 个属性：</p><ul><li>SO_TIMEOUT：表示等待客户连接的超时时间。一般不设置，会持续等待。</li><li>SO_REUSEADDR：表示是否允许重用服务器所绑定的地址。一般不设置，经我的测试没必要，下面会进行详解。</li><li>SO_RCVBUF：表示接收数据的缓冲区的大小。一般不设置，用系统默认就可以了。</li></ul><h4 id="4-3-性能再次提升"><a href="#4-3-性能再次提升" class="headerlink" title="4.3 性能再次提升"></a>4.3 性能再次提升</h4><p>当现在的性能还不能满足需求的时候，就需要考虑使用 NIO，这不是本篇的内容。</p><h3 id="五、Socket-的其它知识"><a href="#五、Socket-的其它知识" class="headerlink" title="五、Socket 的其它知识"></a>五、Socket 的其它知识</h3><p>其实如果经常看有关网络编程的源码的话，就会发现Socket还是有很多设置的，可以学着用，但是还是要有一些基本的了解比较好。下面就对Socket的Java API中涉及到的进行简单讲解。首先呢Socket有哪些可以设置的选项，其实在SocketOptions接口中已经都列出来了：</p><ul><li>int TCP_NODELAY = 0x0001：对此连接禁用 Nagle 算法。</li><li>int SO_BINDADDR = 0x000F：此选项为 TCP 或 UDP 套接字在 IP 地址头中设置服务类型或流量类字段。</li><li>int SO_REUSEADDR = 0x04：设置套接字的 SO_REUSEADDR。</li><li>int SO_BROADCAST = 0x0020：此选项启用和禁用发送广播消息的处理能力。</li><li>int IP_MULTICAST_IF = 0x10：设置用于发送多播包的传出接口。</li><li>int IP_MULTICAST_IF2 = 0x1f：设置用于发送多播包的传出接口。</li><li>int IP_MULTICAST_LOOP = 0x12：此选项启用或禁用多播数据报的本地回送。</li><li>int IP_TOS = 0x3：此选项为 TCP 或 UDP 套接字在 IP 地址头中设置服务类型或流量类字段。</li><li>int SO_LINGER = 0x0080：指定关闭时逗留的超时值。</li><li>int SO_TIMEOUT = 0x1006：设置阻塞 Socket 操作的超时值： ServerSocket.accept(); SocketInputStream.read(); DatagramSocket.receive(); 选项必须在进入阻塞操作前设置才能生效。</li><li>int SO_SNDBUF = 0x1001：设置传出网络 I/O 的平台所使用的基础缓冲区大小的提示。</li><li>int SO_RCVBUF = 0x1002：设置传入网络 I/O 的平台所使用基础缓冲区的大小的提示。</li><li>int SO_KEEPALIVE = 0x0008：为 TCP 套接字设置 keepalive 选项时</li><li>int SO_OOBINLINE = 0x1003：置 OOBINLINE 选项时，在套接字上接收的所有 TCP 紧急数据都将通过套接字输入流接收。</li></ul><h4 id="5-1-客户端绑定端口"><a href="#5-1-客户端绑定端口" class="headerlink" title="5.1 客户端绑定端口"></a>5.1 客户端绑定端口</h4><p>服务端绑定端口是可以理解的，因为要监听指定的端口，但是客户端可以绑定端口吗？如果非要指定一个端口，就不能用Socket的构造方法，要一步一步来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 要连接的服务端IP地址和端口</div><div class="line">String host = &quot;localhost&quot;; </div><div class="line">int port = 55533;</div><div class="line">// 与服务端建立连接</div><div class="line">Socket socket = new Socket();</div><div class="line">socket.bind(new InetSocketAddress(55534));</div><div class="line">socket.connect(new InetSocketAddress(host, port));</div></pre></td></tr></table></figure></p><p>这样做就可以了，但是当这个程序执行完成以后，再次执行就会报，端口占用异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java.net.BindException: Address already in use: connect</div></pre></td></tr></table></figure></p><p>明明上一个Socket已经关闭了，为什么再次使用还会说已经被占用了呢？如果你是用netstat 命令来查看端口的使用情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">netstat -n|findstr &quot;55533&quot;</div><div class="line">TCP 127.0.0.1:55534 127.0.0.1:55533 TIME_WAIT</div></pre></td></tr></table></figure></p><p>就会发现端口的使用状态为TIME_WAIT。简单来说，当连接主动关闭后，端口状态变为TIME_WAIT，其他程序依然不能使用这个端口，防止服务端因为超时重新发送的确认连接断开对新连接的程序造成影响。</p><p>TIME_WAIT的时间一般有底层决定，一般是2分钟，还有1分钟和30秒的。</p><h4 id="5-2-读超时-SO-TIMEOUT"><a href="#5-2-读超时-SO-TIMEOUT" class="headerlink" title="5.2 读超时 SO_TIMEOUT"></a>5.2 读超时 SO_TIMEOUT</h4><p>读超时这个属性还是比较重要的，当Socket优化到最后的时候，往往一个Socket连接会一直用下去，那么当一端因为异常导致连接没有关闭，另一方是不应该持续等下去的，所以应该设置一个读取的超时时间，当超过指定的时间后，还没有读到数据，就假定这个连接无用，然后抛异常，捕获异常后关闭连接就可以了，调用方法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public void setSoTimeout(int timeout)</div><div class="line">throws SocketException</div></pre></td></tr></table></figure></p><p>timeout - 指定的以毫秒为单位的超时值。设置0为持续等待下去。建议根据网络环境和实际生产环境选择。</p><p>这个选项设置的值将对以下操作有影响：<br>ServerSocket.accept()<br>SocketInputStream.read()<br>DatagramSocket.receive()</p><h4 id="5-3-设置连接超时"><a href="#5-3-设置连接超时" class="headerlink" title="5.3 设置连接超时"></a>5.3 设置连接超时</h4><p>这个连接超时和上面说的读超时不一样，读超时是在建立连接以后，读数据时使用的，而连接超时是在进行连接的时候，等待的时间。</p><h4 id="5-4-判断Socket是否可用"><a href="#5-4-判断Socket是否可用" class="headerlink" title="5.4 判断Socket是否可用"></a>5.4 判断Socket是否可用</h4><p>当需要判断一个Socket是否可用的时候，不能简简单单判断是否为null，是否关闭，下面给出一个比较全面的判断Socket是否可用的表达式，这是根据Socket自身的一些状态进行判断的，它的状态有：</p><ul><li>bound：是否绑定</li><li>closed：是否关闭</li><li>connected：是否连接</li><li>shutIn：是否关闭输入流</li><li>shutOut：是否关闭输出流</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socket != null &amp;&amp; socket.isBound() &amp;&amp; !socket.isClosed() &amp;&amp; socket.isConnected()&amp;&amp; !socket.isInputShutdown() &amp;&amp; !socket.isOutputShutdown()</div></pre></td></tr></table></figure><p>建议如此使用，但这只是第一步，保证Socket自身的状态是可用的，但是当连接正常创建后，上面的属性如果不调用本方相应的方法是不会改变的，也就是说如果网络断开、服务器主动断开，Java底层是不会检测到连接断开并改变Socket的状态，所以，真实的检测连接状态还是得通过额外的手段，有两种方式。</p><h5 id="5-4-1-自定义心跳包"><a href="#5-4-1-自定义心跳包" class="headerlink" title="5.4.1 自定义心跳包"></a>5.4.1 自定义心跳包</h5><p>双方需要约定，什么样的消息属于心跳包，什么样的消息属于正常消息，假设你看了上面的章节现在说就容易理解了，我们定义前两个字节为消息的长度，那么我们就可以定义第 3 个字节为消息的属性，可以指定一位为消息的类型，1 为心跳，0 为正常消息。那么要做的有如下：</p><ul><li>客户端发送心跳包</li><li>服务端获取消息判断是否是心跳包，若是丢弃</li><li>当客户端发送心跳包失败时，就可以断定连接不可用</li></ul><h5 id="5-4-2-通过发送紧急数据"><a href="#5-4-2-通过发送紧急数据" class="headerlink" title="5.4.2 通过发送紧急数据"></a>5.4.2 通过发送紧急数据</h5><p>Socket 自带一种模式，那就是发送紧急数据，这有一个前提，那就是服务端的 OOBINLINE 不能设置为true，它的默认值是 false。</p><p>OOBINLINE 的 true 和 false 影响了什么：</p><ul><li>对客户端没有影响</li><li>对服务端，如果设置为true，那么服务端将会捕获紧急数据，这会对接收数据造成混淆，需要额外判断</li></ul><p>发送紧急数据通过调用Socket的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socket.sendUrgentData(0);</div></pre></td></tr></table></figure></p><p>发送数据任意即可，因为 OOBINLINE 为 false 的时候，服务端会丢弃掉紧急数据。当发送紧急数据报错以后，我们就会知道连接不通了。</p><h5 id="5-4-3-真的需要判断连接断开吗"><a href="#5-4-3-真的需要判断连接断开吗" class="headerlink" title="5.4.3 真的需要判断连接断开吗"></a>5.4.3 真的需要判断连接断开吗</h5><p>通过上面的两种方式已经可以判断出连接是否可用，然后我们就可以进行后续操作，可是请大家认真考虑下面的问题：</p><ul><li>发送心跳成功时确认连接可用，当再次发送消息时能保证连接还可用吗？即便中间的间隔很短</li><li>如果连接不可用了，你会怎么做？重新建立连接再次发送数据？还是说单单只是记录日志？</li><li>如果你打算重新建立连接，那么发送心跳包的意义何在？为何不在发送异常时再新建连接？</li></ul><p>如果你认真考虑了上面的问题，那么你就会觉得发送心跳包完全是没有必要的操作，通过发送心跳包来判断连接是否可用是通过捕获异常来判断的。那么我们完全可以在发送消息报出IO异常的时候，在异常中重新发送一次即可，这两种方式的编码有什么不同呢，下面写一写伪代码。</p><p>提前检测连接是否可用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//有一个连接中的socket</div><div class="line">Socket socket=...</div><div class="line">//要发送的数据</div><div class="line">String data=&quot;&quot;;</div><div class="line">try&#123;</div><div class="line">    //发送心跳包或者紧急数据，来检测连接的可用性</div><div class="line">&#125;catch (Excetption e)&#123;</div><div class="line">    //打印日志，并重连Socket</div><div class="line">    socket=new Socket(host,port);</div><div class="line">&#125;</div><div class="line">socket.write(data);</div></pre></td></tr></table></figure></p><p>直接发送数据，出异常后重新连接再次发送：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//有一个连接中的socket</div><div class="line">Socket socket=...</div><div class="line">//要发送的数据</div><div class="line">String data=&quot;&quot;;</div><div class="line">try&#123;</div><div class="line">    socket.write(data);</div><div class="line">&#125;catch (Excetption e)&#123;</div><div class="line">    //打印日志，并重连Socket</div><div class="line">    socket=new Socket(host,port);</div><div class="line">    socket.write(data);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通过比较可以发现两种方式的特点，现在简单介绍下：</p><ul><li>两种方式均可实现连接断开重新连接并发送</li><li>提前检测，再每次发送消息的时候都要检测，影响效率，占用带宽</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/14186083-8af4c2b06d1c0568.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>参考文章：<br><a href="https://www.jianshu.com/p/cde27461c226" target="_blank" rel="external">https://www.jianshu.com/p/cde27461c226</a><br><a href="https://www.cnblogs.com/diaobiyong/p/9929319.html" target="_blank" rel="external">https://www.cnblogs.com/diaobiyong/p/9929319.html</a><br><a href="https://www.cnblogs.com/futao123/p/5068632.html" target="_blank" rel="external">https://www.cnblogs.com/futao123/p/5068632.html</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射三：类内部信息获取</title>
      <link href="/1900/01/12/01%20JAVA/12%20%E5%8F%8D%E5%B0%84%E4%B8%89%EF%BC%9A%E7%B1%BB%E5%86%85%E9%83%A8%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/"/>
      <url>/1900/01/12/01%20JAVA/12%20%E5%8F%8D%E5%B0%84%E4%B8%89%EF%BC%9A%E7%B1%BB%E5%86%85%E9%83%A8%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>相关文章：<br><a href="https://xianxiaotao.github.io/1900/01/08/01%20JAVA/08%20Java%20Relfect/" target="_blank" rel="external">Java Relfect</a><br><a href="https://xianxiaotao.github.io/1900/01/09/01%20JAVA/09%20Java%20RelfectUtils/" target="_blank" rel="external">Java RelfectUtils</a><br><a href="https://xianxiaotao.github.io/1900/01/10/01%20JAVA/10%20%E5%8F%8D%E5%B0%84%E4%B8%80%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%91%A8%E8%BE%B9%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/" target="_blank" rel="external">反射一：基本类周边信息获取</a><br><a href="https://xianxiaotao.github.io/1900/01/11/01%20JAVA/11%20%E5%8F%8D%E5%B0%84%E4%BA%8C%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%91%A8%E8%BE%B9%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/" target="_blank" rel="external">反射二：泛型相关周边信息获取</a><br><a href="https://xianxiaotao.github.io/1900/01/12/01%20JAVA/12%20%E5%8F%8D%E5%B0%84%E4%B8%89%EF%BC%9A%E7%B1%BB%E5%86%85%E9%83%A8%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/" target="_blank" rel="external">反射三：类内部信息获取</a></p></blockquote><p>上两篇文章中，给大家讲了，有关类周边信息的获取方法，这篇文章中我们将深入到类的内部，看看类的构造函数，内部变量，函数等信息的获取方法。相比而言，这篇更重要。</p><h3 id="一、构造函数相关获取"><a href="#一、构造函数相关获取" class="headerlink" title="一、构造函数相关获取"></a>一、构造函数相关获取</h3><hr><h4 id="1、获取构造函数"><a href="#1、获取构造函数" class="headerlink" title="1、获取构造函数"></a>1、获取构造函数</h4><p>要获取类的构造函数，有下面几种方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 获取 public 类型的构造函数</div><div class="line">Constructor&lt;?&gt;[] getConstructors();</div><div class="line">Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes);</div><div class="line"> </div><div class="line">// 获取所有类型的构造函数</div><div class="line">Constructor&lt;?&gt;[] getDeclaredConstructors();</div><div class="line">Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</div></pre></td></tr></table></figure></p><p>这四种方法中，getConstructors 与 getConstructor 获取的是声明为 public 的构造函数。无法得到声明为 protected、private 的构造函数。而加有 Declared（声明）的两个函数 getDeclaredConstructors、getDeclaredConstructor 能获取所有声明的构造函数，无论它是 public、protected 还是 private 类型，都能获取到。所以这两个函数较为常用。</p><p>下面我们举个例子来看下 getDeclaredConstructors 和 getDeclaredConstructor 的用法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Constructor&lt;?&gt;[] getDeclaredConstructors();</div></pre></td></tr></table></figure></p><p>首先，构造一个类 Person：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class Person &#123;</div><div class="line">    private int age;</div><div class="line">    private String name;</div><div class="line">    public Person() &#123;</div><div class="line">    &#125;</div><div class="line">    private Person(int age, String name) &#123;</div><div class="line">        this.age = age;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    private Person(Integer age, String name) &#123;</div><div class="line">        this.age = age;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    public int getAge() &#123;</div><div class="line">        return age;</div><div class="line">    &#125;</div><div class="line">    public void setAge(int age) &#123;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 Person 类中，目前我们只关心构造函数，所以我们声明了三个构造函数，有一个无参数的构造函数，和两个有参数的构造函数。我们把无参的构造函数声明为 public，另外两个都声明为 private。在上面我们说过，在四个获取构造函数的方法中，只有具有 Declared 的两个 getDeclaredXXX() 的函数才能获取类中所有的函数。而另外两个只能获取声明为 public 的函数。下面我们就利用一个例子来获取Person类的构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 1、枚举</div><div class="line">Class&lt;?&gt; clazz = Person.class;</div><div class="line">Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors();</div><div class="line">for (Constructor item:constructors)&#123;</div><div class="line">    Log.d(TAG,&quot;枚举到的构造函数：&quot;+item.toString());</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 2、根据类型，获取指定的构造的构造函数</div><div class="line">Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(Integer.class, String.class);</div><div class="line">Log.d(TAG, &quot;指定参数得到的构造函数：&quot;+constructor.toString());</div></pre></td></tr></table></figure></p><p>结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1f36c6e1ec4d2caf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>使用根据类型获取指定的构造的构造函数时，有两点要非常注意：</p><ul><li>parameterTypes 是数据类型的 Class 对象，如果是原始类型，那么应该对应的是 int.class、double.class（原始类型也是有 class 对象的）。</li><li>parameterTypes 一定要与要得到的构造函数中的参数声明顺序、类型及个数要完全匹配，如果多一个、少一个或类型不匹配也是找不到的。这一点是极其要注意的，getDeclaredConstructor 不是模糊匹配而是精确匹配。</li></ul><p>例如上述两个私有构造函数，第一个构造函数的 age 类型是原始类型 int，第二个构造函数的 age 参数类型是 Integer。那下列语句要匹配哪个构造函数呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clazz.getDeclaredConstructor(Integer.class, String.class);</div></pre></td></tr></table></figure></p><p>由于这里是严格匹配，所以这里必然匹配的是 private Person(Integer age, String name) 函数，如果我们要匹配 private Person(int age, String name) 要怎么办呢？那获取构造函数的方法就要这么写了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clazz.getDeclaredConstructor(int.class, String.class);</div></pre></td></tr></table></figure></p><p>这里要非常提醒大家的是，不光派生自 Object 的类具有 Class 对象，原始的数据类型也是具有 Class 对象的。</p><h4 id="2、Constructor-构造实例"><a href="#2、Constructor-构造实例" class="headerlink" title="2、Constructor 构造实例"></a>2、Constructor 构造实例</h4><p>利用 Constructor 的对象来构造实例时，主要是使用的是 newInstance 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public T newInstance(Object... args);</div></pre></td></tr></table></figure></p><p>可以看到 newInstance 有可以传入可变长参数，值得非常注意的是，传入的参数类型、顺序及个数都必须与当前的 Constructor 对象一一对应，不然就会报下面的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java.lang.IllegalArgumentException: Wrong number of arguments; expected 2, got 0</div></pre></td></tr></table></figure></p><p>继续使用上述 Person 类，下面来看看，如何使用 newInstance 来构造 Person 的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = Person.class;</div><div class="line">Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(Integer.class, String.class);</div><div class="line">constructor.setAccessible(true);</div><div class="line"></div><div class="line">// 构造实例一</div><div class="line">Person person1 = (Person) constructor.newInstance(new Integer(30), new String(&quot;xian&quot;));</div><div class="line">Log.d(TAG, &quot;构造的参数为：&quot; + person1.getName() + &quot;  &quot; + person1.getAge());</div><div class="line"></div><div class="line">// 构造实例二</div><div class="line">Person person2 = (Person) constructor.newInstance(50,&quot;xiao&quot;);</div><div class="line">Log.d(TAG,&quot;构造的参数为：&quot;+person2.getName() + &quot;  &quot;+ person2.getAge());</div><div class="line"></div><div class="line">// 构造实例三</div><div class="line">Person person3 = (Person) constructor.newInstance();</div><div class="line">person3.setAge(30);</div><div class="line">person3.setName(&quot;xian&quot;);</div><div class="line">Log.d(TAG,&quot;构造的参数为：&quot;+person3.getName() + &quot;  &quot;+ person3.getAge());</div></pre></td></tr></table></figure></p><p>结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c7d521dd461b4486.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这段代码总共分为四部分：<br><strong><em>第一部分：获取 Constructor 对象</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = Person.class;</div><div class="line">Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(Integer.class, String.class);</div><div class="line">constructor.setAccessible(true);</div></pre></td></tr></table></figure></p><p>首先，通过 getDeclaredConstructor(Integer.class, String.class) 获取指定的构造函数，要得到的这个构造函数，第一个参数是 Integer 类型，第二个参数是 String 类型。所以匹配的是下面这个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private Person(Integer age, String name) &#123;</div><div class="line">    this.age = age;</div><div class="line">    this.name = name;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>最后一句利用的是 Constructor 的函数 setAccessible，它完整的声明是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void setAccessible(boolean flag)</div></pre></td></tr></table></figure></p><p>它代表的含义是，是否将任何函数或字段设置为可访问的。如果设置为 true，就不管这个函数或者字段是声明为 private 还是 public，都是可以访问的，默认情况下是 false，即只有 public 类型是可访问的。如果没有设置 setAccessible(true) 的话，在使用 protected 或者 private 构造函数创建实例时，会提示访问拒绝，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">java.lang.IllegalAccessException: Class java.lang.Class&lt;com.xxt.xtest.TestActivity&gt; </div><div class="line">        cannot access private method void </div><div class="line">        com.xxt.xtest.Person.&lt;init&gt;(java.lang.Integer, java.lang.String) </div><div class="line">        of class java.lang.Class&lt;com.xxt.xtest.Person&gt;</div></pre></td></tr></table></figure></p><p>在反射中，总共有三种类型具有 setAccessible(boolean flag) 函数：Constructor、Field、Method；分别对应构造函数，成员变量和成员函数。我们知道在一个类中，也就只有构造函数，成员变量和成员函数这三部分，而且这三部分都可能会被设置为 private 和 protected，所以它们三个都会具有设置是否可访问的 setAccessible(boolean flag) 函数。</p><p><strong><em>第二部分：使用标准的 Integer, String 构造实例</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 构造实例一</div><div class="line">Person person1 = (Person) constructor.newInstance(new Integer(30), new String(&quot;xian&quot;));</div><div class="line">Log.d(TAG, &quot;构造的参数为：&quot; + person1.getName() + &quot;  &quot; + person1.getAge());</div></pre></td></tr></table></figure></p><p>在这个利用中，我们向 newInstance() 函数中传递的两个参数是严格遵守 constructor 所对应的构造函数的，即第一个参数是 Integer 类型，第二个参数是 String 类型。然后将 constructor.newInstance 的返回值强转成 Person 的实例。最后通过 person 的函数 person1.getName() 和 person1.getAge() 获取它的内容。</p><p><strong><em>第三部分：使非标准，但可转换的参数来构造实例</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 构造实例二</div><div class="line">Person person2 = (Person) constructor.newInstance(50,&quot;xiao&quot;);</div><div class="line">Log.d(TAG,&quot;构造的参数为：&quot;+person2.getName() + &quot;  &quot;+ person2.getAge());</div></pre></td></tr></table></figure></p><p>在这个构造方法中，我们传递的两个参数都不是标准的 Integer 和 String 类型。但第一个参数 50 是可以强转成 Integer 类型的，而第二个字符串，也是可以强转为 String 类型的。所以对于可以强转成为参数类型的数值，也是可以成功接受的。所以从结果也可以看出，我们可以成功得到 person2 中的值。</p><p><strong><em>第四部分：如果不按规则传递参数会怎样</em></strong><br>我们知道，我们得到的 constructor 对应的构造函数是：private Person(Integer age, String name)，所在我们在 newInstance 的时候，必须声明这个 Constructor 时的参数类型，顺序及个数一个个传进去参数的对应值，如果我们不传、少传或者多传，结果会怎样呢？我们来看看第三个构造实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 构造实例三</div><div class="line">Person person3 = (Person) constructor.newInstance();</div><div class="line">person3.setAge(30);</div><div class="line">person3.setName(&quot;xian&quot;);</div><div class="line">Log.d(TAG,&quot;构造的参数为：&quot;+person3.getName() + &quot;  &quot;+ person3.getAge());</div></pre></td></tr></table></figure></p><p>在这个实例中，我们没有按照 constructor 的参数顺序去填对应的值，而是压根没有填任何的值。如果我们 constructor 对应的构造函数是下面这个没有参数的构造函数的话，这么做是允许的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public Person() &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>而我们这里的 constructor 对应的构造函数却是：private Person(Integer age, String name)，即便我们后面利用 set 方法重新设置进了各种参数，但这是没用的，因为在程序执行到 constructor.newInstance(); 的时候就已经报错了。错误信息为：参数个数不对。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java.lang.IllegalArgumentException: Wrong number of arguments; expected 2, got 0</div></pre></td></tr></table></figure></p><h4 id="3、Constructor-获取参数类型"><a href="#3、Constructor-获取参数类型" class="headerlink" title="3、Constructor 获取参数类型"></a>3、Constructor 获取参数类型</h4><p>Constructor 中获取参数类型的主要有两个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 用于解析一般函数</div><div class="line">Class&lt;?&gt;[] getParameterTypes();</div><div class="line">// 用于解析泛型对象</div><div class="line">Type[] getGenericParameterTypes();</div></pre></td></tr></table></figure></p><p>此处举例说明 getParameterTypes() 。下面的程序将实现，分别打印出 Person.class 中所有构造函数的参数类型列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = Person.class;</div><div class="line">Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors();</div><div class="line">for (Constructor&lt;?&gt; c : constructors)&#123;</div><div class="line">    c.setAccessible(true);</div><div class="line">    Class&lt;?&gt;[] types = c.getParameterTypes();</div><div class="line"></div><div class="line">    StringBuilder builder = new StringBuilder(&quot;获取参数类型为：&quot;);</div><div class="line">    for(Class t : types)&#123;</div><div class="line">        builder.append(t.getName());</div><div class="line">        builder.append(&quot;   &quot;);</div><div class="line">    &#125;</div><div class="line">    Log.d(TAG,builder.toString());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e22432ff534e6eeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="4、Constructor-获取构造函数的访问修饰符"><a href="#4、Constructor-获取构造函数的访问修饰符" class="headerlink" title="4、Constructor 获取构造函数的访问修饰符"></a>4、Constructor 获取构造函数的访问修饰符</h4><p>示例函数：打印出每个构造函数的访问修饰符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = Person.class;</div><div class="line">Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors();</div><div class="line">for (Constructor&lt;?&gt; c:constructors) &#123;</div><div class="line">    c.setAccessible(true);</div><div class="line">    int modifier = c.getModifiers();</div><div class="line">    Log.d(TAG,&quot;一个访问修饰符为：&quot; + Modifier.toString(modifier));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-6d42232b6291fb6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="5、Constructor-getDeclaringClass"><a href="#5、Constructor-getDeclaringClass" class="headerlink" title="5、Constructor getDeclaringClass()"></a>5、Constructor getDeclaringClass()</h4><p>方法声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class&lt;T&gt; getDeclaringClass();</div></pre></td></tr></table></figure></p><p>该函数用于得到声明 Constructor 的类的 Class 对象。用个例子来说明下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = Person.class;</div><div class="line">Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor();</div><div class="line">Class&lt;?&gt; declareClassClazz = constructor.getDeclaringClass();</div><div class="line">Log.d(TAG,declareClassClazz.getName());</div></pre></td></tr></table></figure></p><p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2020-03-08 18:48:00.432 10977-10977/com.xxt.xtest D/xian: com.xxt.xtest.Person</div></pre></td></tr></table></figure></p><h3 id="二、成员变量的获取与设置"><a href="#二、成员变量的获取与设置" class="headerlink" title="二、成员变量的获取与设置"></a>二、成员变量的获取与设置</h3><hr><h4 id="1、获取-Field-对象"><a href="#1、获取-Field-对象" class="headerlink" title="1、获取 Field 对象"></a>1、获取 Field 对象</h4><p>类中的信息，无外乎有三种：构造函数、成员变量和成员函数。类中成员变量相关的信息都保存在 Filed 类型的对象里。Class 中对 Field 对象的获取有下面四个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 仅能获取声明类型为 public 的成员变量</div><div class="line">Field[] getFields();</div><div class="line">Field getField(String name);</div><div class="line">// 可以获取全部的成员变量</div><div class="line">Field[] getDeclaredFields();</div><div class="line">Field getDeclaredField(String name)</div></pre></td></tr></table></figure></p><h5 id="1-1、getDeclaredFields"><a href="#1-1、getDeclaredFields" class="headerlink" title="1.1、getDeclaredFields()"></a>1.1、getDeclaredFields()</h5><p>使用上面的 Person.class 进行测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Person &#123;</div><div class="line">    private int age;</div><div class="line">    private String name;</div><div class="line">    public Person() &#123;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 Person 类中，我们有两个成员变量，一个是 int age，另一个是 String name，非常注意的是这两个变量全部都被声明为 private。一方面，我们只有利用 getDeclaredXXX() 系列函数才能得到他们的Field；另一方面，如果要访问每个成员变量所对应 Field 对象的信息，就必须设置 field.setAccessible(true); 。</p><p>在 Constructor 中，我们已经提到在类中的三部分：构造函数、成员变量、成员函数，他们都可能会被设置为 private 或 protected 类型，所以为了能让用户访问 private 或 protected 类型的对象，在它们三个所对应的类型 Constructor、Field、Method 中都有实现 setAccessible(boolean flag) 函数。意义与都完全一样：表示是否将当前对象设置成为可访问的。默认是 false，即如果当前对象的声明类型为 private 或 protected 就无法访问。</p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = Person.class;</div><div class="line">Field[] fields = clazz.getDeclaredFields();</div><div class="line">for (Field field : fields) &#123;</div><div class="line">    field.setAccessible(true);</div><div class="line">    Class&lt;?&gt; type = field.getType();</div><div class="line">    Log.d(TAG,&quot;枚举到的 field: &quot; + type.getName() + &quot;  &quot; + field.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.../com.xxt.xtest D/xian: 枚举到的 field: int  age</div><div class="line">.../com.xxt.xtest D/xian: 枚举到的 field: java.lang.String  name</div><div class="line">.../com.xxt.xtest D/xian: 枚举到的 field: com.android.tools.ir.runtime.IncrementalChange $change</div><div class="line">.../com.xxt.xtest D/xian: 枚举到的 field: long  serialVersionUID</div></pre></td></tr></table></figure></p><h5 id="1-2、getDeclaredField-String-name"><a href="#1-2、getDeclaredField-String-name" class="headerlink" title="1.2、getDeclaredField(String name)"></a>1.2、getDeclaredField(String name)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = Person.class;</div><div class="line">Field field = clazz.getDeclaredField(&quot;age&quot;);</div><div class="line">field.setAccessible(true);</div><div class="line">Class&lt;?&gt; type = field.getType();</div><div class="line">Log.d(TAG,&quot;age field: &quot; + type.getName() + &quot;  &quot; + field.getName());</div></pre></td></tr></table></figure><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.../com.xxt.xtest D/xian: age field: int  age</div></pre></td></tr></table></figure></p><h4 id="2、Field：get-amp-set"><a href="#2、Field：get-amp-set" class="headerlink" title="2、Field：get &amp; set"></a>2、Field：get &amp; set</h4><h5 id="2-1、get-amp-set"><a href="#2-1、get-amp-set" class="headerlink" title="2.1、get() &amp; set()"></a>2.1、get() &amp; set()</h5><p>当获取或设置指定类对象中某变量的值时，可以使用 Field 中的 get、set 方法，声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void set(Object object, Object value)</div><div class="line">Object get(Object object)</div></pre></td></tr></table></figure></p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = Person.class;</div><div class="line">Constructor&lt;?&gt; constructor = clazz.getConstructor();</div><div class="line">Person person = (Person)constructor.newInstance();</div><div class="line"></div><div class="line">Field fName = clazz.getDeclaredField(&quot;name&quot;);</div><div class="line">fName.setAccessible(true);</div><div class="line">fName.set(person, &quot;xian&quot;);</div><div class="line">String val = (String)fName.get(person);</div><div class="line">Log.d(TAG, &quot;fieldName: &quot; + val + &quot;, personName: &quot; + person.getName());</div></pre></td></tr></table></figure></p><p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.../com.xxt.xtest D/xian: fieldName: xian, personName: xian</div></pre></td></tr></table></figure></p><p>大家注意，在 set 时，第一个参数是要设置的 Person 的实例，第二个参数是这个 Field 所对应的值。在 get 时，传递的参数是当前要获取的 Person 实例，得到的是当前实例中对应成员变量的值。</p><h5 id="2-2、get-系列函数与-set-系列函数"><a href="#2-2、get-系列函数与-set-系列函数" class="headerlink" title="2.2、get 系列函数与 set 系列函数"></a>2.2、get 系列函数与 set 系列函数</h5><p>再回过头来看上面的 get 与 set 函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void set(Object object, Object value)</div><div class="line">Object get(Object object)</div></pre></td></tr></table></figure></p><p>在 set 中，要传入所 Field 的值必须是派生自 Object 类型的，也就规定这个 Field 的所对应的成员变量类型就必须是派生自 Object 的的类型，比如 Integer、String 等。</p><p>那么问题就来了，那我们的成员变量的类型，并不一定是派生自 Object 的类型啊，也可能是原始的数据类型，比如 int、double、char、byte 等，那这些类型的成员变量的值要怎么设置与获取呢？<br>为了解决这个问题，Java 的开发者们额外开发了几对 get 与 set 函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// 设置与获取 int 类型的值</div><div class="line">void setInt(Object object, int value)</div><div class="line">int getInt(Object object)</div><div class="line">// 设置与获取 double 类型的值</div><div class="line">void setDouble(Object object, double value)</div><div class="line">double getDouble(Object object)</div><div class="line">// 设置与获取 float 类型的值</div><div class="line">void setFloat(Object object, float value)</div><div class="line">float getFloat(Object object)</div><div class="line">// 设置与获取 bool 类型的值</div><div class="line">void setBoolean(Object object, boolean value)</div><div class="line">boolean getBoolean(Object object)</div><div class="line">// 设置与获取 short 类型的值</div><div class="line">void setShort(Object object, short value)</div><div class="line">short getShort(Object object)</div><div class="line">// 设置与获取 long 类型的值</div><div class="line">void setLong(Object object, long value)</div><div class="line">long getLong(Object object)</div><div class="line">// 设置与获取 byte 类型的值</div><div class="line">void setByte(Object object, byte value)</div><div class="line">byte getByte(Object object)</div><div class="line">// 设置与获取 char 类型的值</div><div class="line">void setChar(Object object, char value)</div><div class="line">char getChar(Object object)</div></pre></td></tr></table></figure></p><p>示例代码：<br>···<br>Class&lt;?&gt; clazz = Person.class;<br>Constructor&lt;?&gt; constructor = clazz.getConstructor();<br>Person person = (Person)constructor.newInstance();</p><p>Field fAge = clazz.getDeclaredField(“age”);<br>fAge.setAccessible(true);<br>fAge.setInt(person, 20);<br>Log.d(TAG, “fieldAge: “ + fAge.getInt(person) + “, personAge:” + person.getAge());<br>···<br>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.../com.xxt.xtest D/xian: fieldAge: 20, personAge:20</div></pre></td></tr></table></figure></p><h4 id="3、Field-之-isEnumConstant"><a href="#3、Field-之-isEnumConstant" class="headerlink" title="3、Field 之 isEnumConstant()"></a>3、Field 之 isEnumConstant()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean isEnumConstant()</div></pre></td></tr></table></figure><p>这个函数用于判断当前 Field 是否为枚举常量。举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Person &#123;</div><div class="line">    public static enum COLOR&#123;WHITE,BLACK,YELLOW&#125;</div><div class="line">    private int age;</div><div class="line">    private String name;</div><div class="line">    private COLOR color;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz2 = Person.COLOR.class;</div><div class="line">Field field = clazz2.getDeclaredField(&quot;WHITE&quot;);</div><div class="line">Log.d(TAG,&quot;COLOR.WHITE 是否是枚举常量：&quot; + field.isEnumConstant());</div><div class="line"></div><div class="line">Class&lt;?&gt; clazz = Person.class;</div><div class="line">Field fColor = clazz.getDeclaredField(&quot;color&quot;);</div><div class="line">fColor.setAccessible(true);</div><div class="line">boolean isEnum = fColor.isEnumConstant();</div><div class="line">Log.d(TAG,&quot;color 是否是枚举常量：&quot; + isEnum);</div></pre></td></tr></table></figure></p><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2020-03-08 19:30:42.298 15040-15040/com.xxt.xtest D/xian: COLOR.WHITE 是否是枚举常量：true</div><div class="line">2020-03-08 19:30:42.298 15040-15040/com.xxt.xtest D/xian: color 是否是枚举常量：false</div></pre></td></tr></table></figure></p><p>我们从结果中可以看到，首先 COLOR 枚举类中的 WHITE 是一个枚举常量，而利用 COLOR 定义的 color 变量不是枚举常量。</p><h4 id="4、Field-Modifiers-getDeclaringClass"><a href="#4、Field-Modifiers-getDeclaringClass" class="headerlink" title="4、Field Modifiers getDeclaringClass()"></a>4、Field Modifiers getDeclaringClass()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 获取该成员变量所对应的访问修饰符组所对应的 Int 数字</div><div class="line">int getModifiers()</div><div class="line">// 获取声明该变量的类</div><div class="line">Class&lt;?&gt; getDeclaringClass()</div></pre></td></tr></table></figure><p>getModifiers()：获取该 Field 所对应的成员变量的访问修饰符。<br>getDeclaringClass()：获取声明该成员变量的类的 Class 对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = Person.class;</div><div class="line">Field fAge = clazz.getDeclaredField(&quot;age&quot;);</div><div class="line">Class&lt;?&gt; declareClazz = fAge.getDeclaringClass();</div><div class="line">Log.d(TAG, declareClazz.toString());</div></pre></td></tr></table></figure></p><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.../com.xxt.xtest D/xian: class com.xxt.xtest.Person</div></pre></td></tr></table></figure></p><h3 id="三、成员函数的获取与设置"><a href="#三、成员函数的获取与设置" class="headerlink" title="三、成员函数的获取与设置"></a>三、成员函数的获取与设置</h3><hr><h4 id="1、获取-Method-对象"><a href="#1、获取-Method-对象" class="headerlink" title="1、获取 Method 对象"></a>1、获取 Method 对象</h4><p>与成员变量对应的类型为 Field 类似，类中的方法对应的类型是 Method。获取指定类中的成员函数的方法有下面四种方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Method[] getMethods()</div><div class="line">Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</div><div class="line"></div><div class="line">Method[] getDeclaredMethods()</div><div class="line">Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</div></pre></td></tr></table></figure></p><p>与上面所有的有 Declared 系列的函数组一样，getMethods() 和 getMethod() 只能获取声明为 public 的函数。而 getDeclaredMethods()、getDeclaredMethod() 可以得到所有的函数，无论声明为 public、protected 还是 private。</p><h5 id="1-1、getDeclaredMethods"><a href="#1-1、getDeclaredMethods" class="headerlink" title="1.1、getDeclaredMethods()"></a>1.1、getDeclaredMethods()</h5><p>该函数能够获取类中所有声明的函数（不包括构造函数），举个例子来看他使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = Person.class;</div><div class="line">Method[] methods = clazz.getDeclaredMethods();</div><div class="line">for (Method m : methods) &#123;</div><div class="line">    Log.d(TAG, &quot;枚举到的方法：&quot; + m.toString());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>结果为：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-01b2ef049fd7b9d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h5 id="1-2、getDeclaredMethod-String-Class-lt-gt-…"><a href="#1-2、getDeclaredMethod-String-Class-lt-gt-…" class="headerlink" title="1.2、getDeclaredMethod(String, Class&lt;?&gt;…)"></a>1.2、getDeclaredMethod(String, Class&lt;?&gt;…)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</div></pre></td></tr></table></figure><ul><li>name：表示要获取 Method 对象的成员函数名。</li><li>parameterTypes：需要匹配的成员函数需要传入的参数的类型，这里需要非常注意，这里的 getDeclaredMethod 是精确匹配的，如果我们传入的函数名以及参数类型、顺序、个数与该函数声明不一致的话，就会报错。</li></ul><p>值得非常注意的是，当我们要找的方法所对应的参数类型是原始数据类型，比如 Int、double 等，它们所对应的 Class 对象为 int.class、double.class 即可；所以原始类型也是有 Class对象的。</p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = Person.class;</div><div class="line">Method method = clazz.getDeclaredMethod(&quot;setName&quot;, String.class);</div><div class="line">Log.d(TAG, &quot;方法：&quot; + method.toString());</div></pre></td></tr></table></figure></p><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.../com.xxt.xtest D/xian: 方法：public void com.xxt.xtest.Person.setName(java.lang.String)</div></pre></td></tr></table></figure></p><h4 id="2、Method-Invoke"><a href="#2、Method-Invoke" class="headerlink" title="2、Method Invoke"></a>2、Method Invoke</h4><p>Invoke 函数无疑是 Method 类中最重要的方法，它的功能是用于执行 Method 对象所对应的函数。完整的声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object invoke(Object receiver, Object... args)</div></pre></td></tr></table></figure></p><ul><li>Object receiver：指要执行该函数的类对象，比如我们的 Person 类的某一实例。</li><li>Object… args：可变长参数，用于传入该函数声明中的参数所对应的值的列表。</li><li>返回值：Object，将函数的结果返回，Object 对象就是执行此函数后返回的结果。</li></ul><p>我们在 Person 中单独再加一个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Person &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    public Boolean testInvoke(Integer age, String name) &#123;</div><div class="line">        Log.d(&quot;xian&quot;,&quot;得到参数 age: &quot; + age + &quot;, name: &quot;+name);</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = Person.class;</div><div class="line">Person person = new Person();</div><div class="line">Method method = clazz.getDeclaredMethod(&quot;testInvoke&quot;, Integer.class, String.class);</div><div class="line">method.setAccessible(true);</div><div class="line">Boolean result = (Boolean)method.invoke(person, 25, &quot;I m xian&quot;);</div><div class="line">Log.d(TAG,&quot;执行结果: &quot;+result);</div></pre></td></tr></table></figure></p><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2020-03-08 19:53:51.572 16600-16600/com.xxt.xtest D/xian: 得到参数 age: 25, name: I m xian</div><div class="line">2020-03-08 19:53:51.573 16600-16600/com.xxt.xtest D/xian: 执行结果: true</div></pre></td></tr></table></figure></p><p>这里总结一下，从 Field、Method 中都可以看出，Field、Method 的对象对应的不是哪个类实例中变量，而是类中变量的对象。也就是说，Field、Method 对象只有一个，是在编译时，保存在 Class 中的。而 Person 的实例却可以有很多个，如果要改变哪个 Person 实例中成员变量的值，就必须将该 Person 实例传入 Field 对象的参数中，让 Field 对象设置。</p><h4 id="3、Method-获取参数类型"><a href="#3、Method-获取参数类型" class="headerlink" title="3、Method 获取参数类型"></a>3、Method 获取参数类型</h4><p>与其它类的获取参数类型一样，这里同样针对普通变量和泛型有两种获取参数类型的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 用于获取普通的参数类型</div><div class="line">Class&lt;?&gt;[] getParameterTypes()</div><div class="line">// 用于获取带有泛型参数的类型</div><div class="line">Type[] getGenericParameterTypes()</div></pre></td></tr></table></figure></p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz  = Person.class;</div><div class="line">Method method = clazz.getDeclaredMethod(&quot;testInvoke&quot;, Integer.class, String.class);</div><div class="line">Class&lt;?&gt;[] params = method.getParameterTypes();</div><div class="line">for (Class c : params)&#123;</div><div class="line">    Log.d(TAG,&quot;枚举到参数类型：&quot;+c.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2020-03-08 19:58:29.982 16600-16600/com.xxt.xtest D/xian: 枚举到参数类型：java.lang.Integer</div><div class="line">2020-03-08 19:58:29.982 16600-16600/com.xxt.xtest D/xian: 枚举到参数类型：java.lang.String</div></pre></td></tr></table></figure></p><h4 id="4、Method-获取返回值类型"><a href="#4、Method-获取返回值类型" class="headerlink" title="4、Method 获取返回值类型"></a>4、Method 获取返回值类型</h4><p>获取指定成员函数返回值类型的方法，同样根据返回值是否是泛型，同样有两种方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; getReturnType()</div><div class="line">Type getGenericReturnType()</div></pre></td></tr></table></figure></p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = Person.class;</div><div class="line">Method method = clazz.getDeclaredMethod(&quot;testInvoke&quot;, Integer.class, String.class);</div><div class="line">Class type = method.getReturnType();</div><div class="line">Log.d(TAG, &quot;返回值类型为：&quot; + type.getName());</div></pre></td></tr></table></figure></p><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2020-03-08 20:01:26.430 16600-16600/com.xxt.xtest D/xian: 返回值类型为：java.lang.Boolean</div></pre></td></tr></table></figure></p><h3 id="四、实战实例讲解"><a href="#四、实战实例讲解" class="headerlink" title="四、实战实例讲解"></a>四、实战实例讲解</h3><hr><h4 id="1、Fragment-instantiate"><a href="#1、Fragment-instantiate" class="headerlink" title="1、Fragment.instantiate()"></a>1、Fragment.instantiate()</h4><p>在 V4 包中，Fragment 有一个函数，可以根据指定 Fragment 的路径名来得到对应 Fragment 的实例。它的完整声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static Fragment instantiate(Context context, String fname, Bundle args)</div></pre></td></tr></table></figure></p><ul><li>context：Context 类型对象;</li><li>fname：对应 Fragment 类的完整的路径名，可以利用 Class.getName() 得到。</li><li>args：是在构造 Fragment 实例时需要的 Bundle参数。</li></ul><p><strong>使用方法</strong><br>新建一个Fragment：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import androidx.fragment.app.Fragment;</div><div class="line"></div><div class="line">public class DemoFragment extends Fragment &#123;</div><div class="line">    public void printFragment(String name)&#123;</div><div class="line">        Log.d(&quot;xian&quot;, name + &quot;知道你是个逗逼&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后我利用 Fragment.instantiate 来获取它的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = DemoFragment.class;</div><div class="line">DemoFragment fragment = (DemoFragment) Fragment.instantiate(this, clazz.getName(), null);</div><div class="line">fragment.printFragment(&quot;先小涛&quot;);</div></pre></td></tr></table></figure></p><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2020-03-08 20:10:23.552 17684-17684/com.xxt.xtest D/xian: 先小涛知道你是个逗逼</div></pre></td></tr></table></figure></p><p><strong>原理</strong><br>这个函数内部是如何实现的吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public static Fragment instantiate(Context context, String fname, @Nullable Bundle args) &#123;</div><div class="line">    try &#123;</div><div class="line">        // 根据 fname 得到对应 Fragment 的 Class 对象</div><div class="line">        Class&lt;?&gt; clazz = sClassMap.get(fname);</div><div class="line">        // 首先通过一个 sClassMap 中查找一下。如果没有，则通过</div><div class="line">        // ClassLoader 将其加载到内存中，并将其保存到 sClassMap中。</div><div class="line">        if (clazz == null) &#123;</div><div class="line">            // Class not found in the cache, see if it&apos;s real, and try to add it</div><div class="line">            clazz = context.getClassLoader().loadClass(fname);</div><div class="line">            sClassMap.put(fname, clazz);</div><div class="line">        &#125;</div><div class="line">        // 得到对应 Fragment 的实例</div><div class="line">        Fragment f = (Fragment) clazz.getConstructor().newInstance();</div><div class="line">        if (args != null) &#123;</div><div class="line">            // 将传入的 Bundle 参数 args 加入到 Fragment 的 mArguments参数对象中</div><div class="line">            args.setClassLoader(f.getClass().getClassLoader());</div><div class="line">            f.setArguments(args);</div><div class="line">        &#125;</div><div class="line">        // 将 Fragment 的实例 f 返回</div><div class="line">        return f;</div><div class="line">    &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="2、PopupWindow-setTouchModal"><a href="#2、PopupWindow-setTouchModal" class="headerlink" title="2、PopupWindow.setTouchModal()"></a>2、PopupWindow.setTouchModal()</h4><p>如果我想要一个效果：点击 PopupWindow 外部区域，弹窗不消失，但是点击事件会向下面的 activity 传递，这时候就需要用到 PopupWindow 的 setTouchModal(boolean touchModal) 函数。该函数完整声明为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Set whether this window is touch modal or if outside touches will be sent to</div><div class="line"> * other windows behind it.</div><div class="line"> * @hide</div><div class="line"> */</div><div class="line">public void setTouchModal(boolean touchModal) &#123;</div><div class="line">    mNotTouchModal = !touchModal;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在注解中，利用 @hide 将此函数隐藏了，我们通过 PopupWindow对象是没有办法得到调用它的。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f2eae265fe738192.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>所以我们只有通过反射来做。下面我们来举个例子来调用这个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static void setPopupWindowTouchModal (PopupWindow popupWindow, </div><div class="line">                                             boolean touchModal) &#123;</div><div class="line">    if (null == popupWindow) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    try &#123;</div><div class="line">        Method method = PopupWindow.class.getDeclaredMethod(</div><div class="line">                &quot;setTouchModal&quot;, boolean.class);</div><div class="line">        method.setAccessible(true);</div><div class="line">        method.invoke(popupWindow, touchModal);</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        System.out.println(e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7cc697ce6f2ec479?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>原文链接：<br><a href="https://blog.csdn.net/harvic880925/article/details/50107951" target="_blank" rel="external">夯实JAVA基本之二 —— 反射（3）：类内部信息获取</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射二：泛型相关周边信息获取</title>
      <link href="/1900/01/11/01%20JAVA/11%20%E5%8F%8D%E5%B0%84%E4%BA%8C%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%91%A8%E8%BE%B9%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/"/>
      <url>/1900/01/11/01%20JAVA/11%20%E5%8F%8D%E5%B0%84%E4%BA%8C%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%91%A8%E8%BE%B9%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>相关文章：<br><a href="https://xianxiaotao.github.io/1900/01/08/01%20JAVA/08%20Java%20Relfect/" target="_blank" rel="external">Java Relfect</a><br><a href="https://xianxiaotao.github.io/1900/01/09/01%20JAVA/09%20Java%20RelfectUtils/" target="_blank" rel="external">Java RelfectUtils</a><br><a href="https://xianxiaotao.github.io/1900/01/10/01%20JAVA/10%20%E5%8F%8D%E5%B0%84%E4%B8%80%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%91%A8%E8%BE%B9%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/" target="_blank" rel="external">反射一：基本类周边信息获取</a><br><a href="https://xianxiaotao.github.io/1900/01/11/01%20JAVA/11%20%E5%8F%8D%E5%B0%84%E4%BA%8C%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%91%A8%E8%BE%B9%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/" target="_blank" rel="external">反射二：泛型相关周边信息获取</a><br><a href="https://xianxiaotao.github.io/1900/01/12/01%20JAVA/12%20%E5%8F%8D%E5%B0%84%E4%B8%89%EF%BC%9A%E7%B1%BB%E5%86%85%E9%83%A8%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/" target="_blank" rel="external">反射三：类内部信息获取</a></p></blockquote><p>在上篇中，讲解了如何利用反射来获取普通类型的类的使用，今天给大家讲解下，有关如何使用反射来获取泛型中的信息。</p><h3 id="一、获取泛型超类和接口的相关信息"><a href="#一、获取泛型超类和接口的相关信息" class="headerlink" title="一、获取泛型超类和接口的相关信息"></a>一、获取泛型超类和接口的相关信息</h3><hr><p>在这部分内容中，我们将讲述如何获取泛型的超类和接口，把上篇中遗留下来的两个函数先讲完。</p><h4 id="1、获取泛型超类相关信息"><a href="#1、获取泛型超类相关信息" class="headerlink" title="1、获取泛型超类相关信息"></a>1、获取泛型超类相关信息</h4><p>上篇中，我们讲了，要获取泛型类型的超类，要用到一个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 针对泛型父类而设计</div><div class="line">public Type getGenericSuperclass();</div></pre></td></tr></table></figure></p><p>下面我们就先看看这个函数怎么用，我们依然以上篇中的 Point 类以及它的派生类 PointImpl 为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// Point 泛型类的实现</div><div class="line">public class Point&lt;T&gt; &#123;</div><div class="line">    private T x,y;</div><div class="line">    public T getX() &#123;</div><div class="line">        return x;</div><div class="line">    &#125;</div><div class="line">    public void setX(T x) &#123;</div><div class="line">        this.x = x;</div><div class="line">    &#125;</div><div class="line">    public T getY() &#123;</div><div class="line">        return y;</div><div class="line">    &#125;</div><div class="line">    public void setY(T y) &#123;</div><div class="line">        this.y = y;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// PointImpl 类的实现</div><div class="line">public class PointImpl extends Point&lt;Integer&gt; &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从上面的代码中，我们可以看到，Point 类是一个泛型类，具有一个泛型变量 T；而 PointImpl 派生自 Point 并且在派生时，将 Point 进行填充为 Point&lt;Integer&gt;，即将 Point 中的泛型变量填充为 Integer 类型。</p><p>下面， 我们将通过反射获取 PointImpl 的父类的类型，以及 PointImpl 的填充类型。我们在没看代码之前，我们先看看结果，我们知道 PointImpl 的父类类型是 Point，而 PointImpl 的填充类型应该是 Integer。然后我们再看看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = PointImpl.class;</div><div class="line">Type type = clazz.getGenericSuperclass();</div><div class="line">if (type instanceof ParameterizedType) &#123;</div><div class="line">    ParameterizedType parameterizedType = (ParameterizedType) type;</div><div class="line">    // 返回表示此类型实际类型参数的 Type 对象的数组</div><div class="line">    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</div><div class="line">    for (Type parameterArgType : actualTypeArguments) &#123;</div><div class="line">        Class parameterArgClass = (Class) parameterArgType;</div><div class="line">        Log.d(TAG,&quot;填充类型为：&quot; + parameterArgClass.getName());</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    // 返回 Type 对象，表示声明此类型的类或接口。</div><div class="line">    Type type1 = parameterizedType.getRawType();</div><div class="line">    Class class22 = (Class) type1;</div><div class="line">    Log.d(TAG, &quot;PointImpl 的父类类型为：&quot; + class22.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b54440d383037646.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从结果中，我们可以看到，先获得到的是 PointImpl 在填充父类时的类型 Integer，然后获得的是 PointImpl 的父类类型。下面先看如何获取当前类在填充父类时的填充类型的。对应代码是这一块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = PointImpl.class;</div><div class="line">Type type = clazz.getGenericSuperclass();</div><div class="line">if (type instanceof ParameterizedType) &#123;</div><div class="line">    ParameterizedType parameterizedType = (ParameterizedType) type;</div><div class="line">    // 返回表示此类型实际类型参数的 Type 对象的数组</div><div class="line">    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</div><div class="line">    for (Type parameterArgType : actualTypeArguments) &#123;</div><div class="line">        Class parameterArgClass = (Class) parameterArgType;</div><div class="line">        Log.d(TAG, &quot;填充类型为：&quot; + parameterArgClass.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h5 id="1-1、获取泛型超类"><a href="#1-1、获取泛型超类" class="headerlink" title="1.1、获取泛型超类"></a>1.1、获取泛型超类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = PointImpl.class;</div><div class="line">Type type = clazz.getGenericSuperclass();</div></pre></td></tr></table></figure><p>在这段代码中，我们通过 clazz.getGenericSuperclass() 获取 PointImpl.class 的超类。由于我们知道 PointImpl.class 的父类是泛型，所以我们只能使用 clazz.getGenericSuperclass() 来获取。得到的 type 的值对应的是 Point，而 type 对应的是 ParameterizedType，所以我们用 type instanceof ParameterizedType 来识别，然后将 type 变量强转为 ParameterizedType变量；再然后利用 parameterizedType.getActualTypeArguments() 获取当前泛型变量的填充列表，我们知道 Point 中泛型变量 T 被填充为Integer，所以我们得到的数组 Type[] 里，只有一个值，它对应的就是 Integer.Class；<br>最后我们将得到的 Type 进行强转成 Class 类型，所以 parameterArgClass 对应的值就是 Integer.Class。所以parameterArgClass.getName() 的值为：java.lang.Integer。</p><p>上述所说的 Type 是什么呢？</p><h5 id="1-2、Type-类型"><a href="#1-2、Type-类型" class="headerlink" title="1.2、Type 类型"></a>1.2、Type 类型</h5><p>我们先看看 Type 的源码，看他自己是怎么说的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">package java.lang.reflect;</div><div class="line"> </div><div class="line">/**</div><div class="line"> * Common interface implemented by all Java types.</div><div class="line"> * @since 1.5</div><div class="line"> */</div><div class="line">public interface Type &#123;</div><div class="line">    // Empty</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Type 是一个接口，这里意思是它是 Java 所有类型都会继承这个接口。但通过源码会发现 String、Integer、Double 这些类都没有继承这个接口，就连 Object 也没继承。再仔细查代码会出现，Class 继承了这个接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public final class Class&lt;T&gt; implements Serializable, AnnotatedElement, GenericDeclaration, Type &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>所以说，这个 Type 类型是泛型所特有的。那它用是来做什么的呢？他就是用来标识，当前 Class 中所填充的类型的。意思是，当我们在填充一个泛型时，比如上面我们的 PointImpl extends Point<integer>，这个填充类型就会放在 Type 的保存起来，当需要用到的时候再取出来。那问题又来了，我们这里填充的是 Integer 类型，那如果我们填充的是数组泛型呢，比如 Point<arraylist>，再假如我们填充的是一个通配符呢？这Type要怎么识别呢？</arraylist></integer></p><p>为了解决这个问题，Java 的开发者，在 Type 的基础上派生了另外几个接口，分别来保存不同的类型，他们分别是：</p><ul><li>ParameterizedType<br>这就是上面我们代码中用到的，他代表的是一个泛型类型，比如 Point，它就是一个泛型类型。</li><li>TypeVariable<br>这个代表的就是泛型变量，例如 Point&lt;T&gt;，这里面的 T 就是泛型变量，而如果我们利用一种方法获得的对象是 T，那它对应的类型就是 TypeVariable。这个类型的应用后面会细讲。</li><li>WildcardType<br>上面的 TypeVariable 对应的是泛型变量，而如果我们得到不是泛型变量，而是通配符比如：? extends Integer，那它对应的类型就是WildcardType。</li><li>GenericArrayType<br>如果我们得到的是类似 String[] 这种数组形式的表达式，那它对应的类型就是 GenericArrayType，非常值得注意的是如果 type 对应的是表达式是 ArrayList 这种的，这个 type 类型应该是 ParameterizedType，而不是 GenericArrayType，只有类似 Integer[] 这种的才是 GenericArrayType 类型。</li></ul><p>虽然我们后面会对 TypeVariable、WildcardType 进行讲解，这里还是先对他们三个类型对应的意义先总结一下，比如我们这里的 clazz.getGenericSuperclass()，得到的 Type 对应的是完整的泛型表达式即：Point，那它对应的类型就是 ParameterizedType，如果我们得到的 Type 对应的表达式，仅仅是 Point 中用来填充泛型变量 T 的 Integer，那这个 Type 对应的类型就是 TypeVariable，如果我们得到的是依然是填充泛型变量 T 的填充类型，这而个填充类型却是通配符 ？，那这个 Type 对应的类型就是 WildcardType。这一段看不大明白也没关系，后面还会再讲。</p><h5 id="1-3、ParameterizedType"><a href="#1-3、ParameterizedType" class="headerlink" title="1.3、ParameterizedType"></a>1.3、ParameterizedType</h5><p>上面我们已经提到当获取的 Type 类型，对应的是一个完整泛型表达式的时候（比如，我们这里获取到的 PointImpl.class 的父类）type 对应的完整表达式就是 Point。</p><p>在 ParameterizedType 中有两个极有用的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Type[] getActualTypeArguments();</div><div class="line">Type getRawType();</div></pre></td></tr></table></figure></p><ul><li>getActualTypeArguments()<br>用来返回当前泛型表达式中，用来填充泛型变量的真正值的列表。像我们这里得到的 Point，用来填充泛型变量 T 的是 Integer 类型，所以这里返回的 Integer 类型所对应的 Class 对象。</li><li>getRawType()<br>上面示例这个它返回的值是 com.xxt.xtest.Point，它的意义是声明当前泛型表达式的类或者接口的 Class 对象。比如，我们这里的 type 对应的是 Point，而声明 Point 这个泛型的当然是 Point 类型，所以返回的是 Point.Class。</li></ul><p>下面我们再回过来看看 getActualTypeArguments()。</p><p>我们上面说到，这个函数将返回用来填充泛型变量真实参数列表。像我们这里的是 Point，将返回 Integer 对应的 Class 对象。而并不是所有的每次都会返回填充类型对应的 Class 对象。我们知道我们在填充一个泛型时，是存在各种可能的，比如 Point、Point&lt;? extends Number&gt;、Point<arraylist>、Point<arraylist<? extend="" number="">&gt; 等等。虽然我们没办法穷举可能填充为哪些类型，但我们知道 Type 类型是用来表示填充泛型变量的类型的，而继承 Type 接口只有五个：Class、ParameterizedType、TypeVariable、WildcardType、GenericArrayType。所以这也是 Type[] getActualTypeArguments(); 中 Type[] 数组的所有可能取值。</arraylist<?></arraylist></p><h5 id="1-4、getRawType"><a href="#1-4、getRawType" class="headerlink" title="1.4、getRawType()"></a>1.4、getRawType()</h5><p>来看看 getRawType的用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Type type1 = parameterizedType.getRawType();</div><div class="line">Class class22 = (Class) type1;</div><div class="line">Log.d(TAG, &quot;PointImpl的父类类型为：&quot; + class22.getName());</div></pre></td></tr></table></figure></p><p>我们知道，parameterizedType 对应的值是 Point，而 parameterizedType.getRawType() 得到的就是声明这个泛型的类的Class对象。所以这里的 type1 对应的值就是 Point.Class。将其转换成 Class 对象，通过 class22.getName() 得到的值是：com.xxt.xtest.Point。</p><h4 id="2、获取泛型接口相关信息"><a href="#2、获取泛型接口相关信息" class="headerlink" title="2、获取泛型接口相关信息"></a>2、获取泛型接口相关信息</h4><p>上泛我们也说到，获取普通类所继承的接口使用的是 Class.getInterfaces() 函数，如果要获取泛型接口的对象需要用到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public Type[] getGenericInterfaces();</div></pre></td></tr></table></figure></p><blockquote><p>注意：getGenericInterfaces() 数与 getInterfaces() 函数一样，都只能获取此类直接继承的接口列表。</p></blockquote><p>这里得到的一个 Type 数组，因为我们一个类可以继承多个接口，所以这里的每一个 type 对应的就是我们所继承的一个接口类型。</p><p>下面我们举个例子来看这个接口的用法。首先，生成一个泛型接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public interface PointInterface&lt;T,U&gt; &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看到，我们这个泛型接口里有两个泛型变量，这个接口里我们没有定义任何的方法，因为我们这里只会获取填充泛型接口的实际类型，不会用到它的方法，所以就没有必要生成了，写个空接口即可。</p><p>然后，我们直接使用前面的 PointImpl 来继承好了，就不再另写其它类了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public class PointImpl extends Point&lt;Integer&gt; implements PointInterface&lt;String,Double&gt; &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从这里可以看出，我们在生成 PointImpl 时将 PointInterface&lt;T, U&gt; 填充为 PointInterface&lt;String, Double&gt;。下面我们来看如何来获取 PointImpl 所继承的泛型接口的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = PointImpl.class;</div><div class="line">Type[] types = clazz.getGenericInterfaces();</div><div class="line">for (Type type : types) &#123;</div><div class="line">    if (type instanceof ParameterizedType) &#123;</div><div class="line">        ParameterizedType parameterizedType = (ParameterizedType) type;</div><div class="line">        // 返回表示此类型实际类型参数的 Type 对象的数组</div><div class="line">        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</div><div class="line">        for (Type parameterArgType : actualTypeArguments) &#123;</div><div class="line">            Class parameterArgClass = (Class) parameterArgType;</div><div class="line">            Log.d(TAG, &quot;此接口的填充类型为：&quot; + parameterArgClass.getName());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 返回 Type 对象，表示声明此类型的类或接口。</div><div class="line">        Type type1 = parameterizedType.getRawType();</div><div class="line">        Class class22 = (Class) type1;</div><div class="line">        Log.d(TAG,&quot;声明此接口的类型为：&quot;+class22.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序运行结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4a1d6aebd98e4910.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>代码分析。首先，是获得 PointImpl.class 所继承接口的数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = PointImpl.class;</div><div class="line">Type[] types = clazz.getGenericInterfaces();</div></pre></td></tr></table></figure></p><p>因为我们知道，我们的 PointImpl 只继承了一个接口：PointInterface&lt;String, Double&gt;，所以此时的 Type[] 中只有一个元素，即代表着 PointInterface&lt;String, Double&gt; 的 type。然后是利用 for…each 循环遍历 types 中的每一个元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">if (type instanceof ParameterizedType) &#123;</div><div class="line">    ParameterizedType parameterizedType = (ParameterizedType) type;</div><div class="line">    // 返回表示此类型实际类型参数的 Type 对象的数组</div><div class="line">    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</div><div class="line">    for (Type parameterArgType : actualTypeArguments) &#123;</div><div class="line">        Class parameterArgClass = (Class) parameterArgType;</div><div class="line">        Log.d(TAG, &quot;此接口的填充类型为：&quot; + parameterArgClass.getName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 返回 Type 对象，表示声明此类型的类或接口。</div><div class="line">    Type type1 = parameterizedType.getRawType();</div><div class="line">    Class class22 = (Class) type1;</div><div class="line">    Log.d(TAG, &quot;声明此接口的类型为：&quot;+class22.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>因为我们知道，我们这里的 type 代表的是 PointInterface&lt;String, Double&gt;，明显它是一个泛型，所以它对应的 type 类型应该是 ParameterizedType。下面的代码就与上面获取泛型超类的一样了，即通过 parameterizedType.getActualTypeArguments() 获取到它的参数数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ParameterizedType parameterizedType = (ParameterizedType) type;</div><div class="line">// 返回表示此类型实际类型参数的 Type 对象的数组</div><div class="line">Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</div><div class="line">for (Type parameterArgType : actualTypeArguments) &#123;</div><div class="line">    Class parameterArgClass = (Class) parameterArgType;</div><div class="line">    Log.d(TAG, &quot;此接口的填充类型为：&quot; + parameterArgClass.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>因为我们知道，PointInterface&lt;T, U&gt; 被 PointImpl 填充为 PointInterface&lt;String,Double&gt;，所以它的真实的参数类型应该是 String 和 Double。</p><p>我们前面说过 Type 只有五种类型：Class、ParameterizedType、TypeVariable、WildcardType、GenericArrayType。而 ParameterizedType 代表完整的泛型表达式，TypeVariable 代表泛型变量的符号即 T,U 等，WildcardType 代表通配符，GenericArrayType 代表数组类型，而 Class 则表示派生于 Object 的所有 Class 类，明显这里的 String 和 Double 是Class类型的。所以我们将它们强转为 Class 类型，然后通过 parameterArgClass.getName() 得到它们的完整路径名。最后通过 parameterizedType.getRawType() 获取声明 PointInterface&lt;String,Double&gt; 的接口类类型，虽然这里得到的是 Type，但我们声明接口的是 PointInterface.Class。所以，也是 Class 类型，直接将其强转为 Class 即可。最后通过 Class.getName() 获取其完整的路径名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 返回 Type 对象，表示声明此类型的类或接口。</div><div class="line">Type type1 = parameterizedType.getRawType();</div><div class="line">Class class22 = (Class) type1;</div><div class="line">Log.d(TAG, &quot;声明此接口的类型为：&quot;+class22.getName());</div></pre></td></tr></table></figure></p><p>好了，到这里，有关泛型超类和继承接口的信息获取到这就结束了，下面我们再来看看上面另外提到的另外三个 Type 类型：TypeVariable、WildcardType、GenericArrayType。</p><h3 id="二、Type-的五种类型"><a href="#二、Type-的五种类型" class="headerlink" title="二、Type 的五种类型"></a>二、Type 的五种类型</h3><hr><p>上面说们说过，Type 接口是用来保存当前泛型被填充的类型的，它总共有五种类型：Class、ParameterizedType、TypeVariable、WildcardType、GenericArrayType。</p><p>在这上面的例子中，我们用到了 Class、ParameterizedType。</p><ul><li>当 type 所代表的表达式是一个完整泛型时，比如 Point，那这个 Type 类型就是 ParameterizedType；</li><li>如果 type 所代表的是一个确定的类，比如 Integer、String、Double 等，那这个 type 所对应的类型就是 Class，强转之后，得到的就是他们所对应的 Class 对象，即 Integer.Class、String.Class、Double.Class 等；</li><li>如果 type 对应的是一个泛型变量，即类似于 T 或 U 这种还没有被填充的泛型变量，那它的类型就是 TypeVariable；</li><li>而如果 type 对应的是一个通配符表达式，比如 ？ extends Num，或者仅仅是一个通配符 ？，类似这种有通符符的类型就是 WildcardType；</li><li>而如果 type 对应的类型是类似于 String[] 的数组，那它的类型就是GenericArrayType。</li></ul><p>下面我们就来分别看看 TypeVariable、WildcardType 和 GenericArrayType 的用法。</p><h4 id="1、TypeVariable"><a href="#1、TypeVariable" class="headerlink" title="1、TypeVariable"></a>1、TypeVariable</h4><p>我们上面说了，当 type 代表的类型是一个泛型变量时，它的类型就是 TypeVariable。TypeVariable 有两个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String getName();</div><div class="line">Type[] getBounds();</div></pre></td></tr></table></figure></p><ul><li>getName：就是得到当前泛型变量的名称；</li><li>getBounds：返回表示此类型变量上边界的 Type 对象的数组。如果没有上边界，则默认返回 Object。</li></ul><p>有关这两个函数我们举个例子来详细说明，我们依然在 PointInterface 泛型接口上做文章：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface PointInterface&lt;T,U&gt; &#123;</div><div class="line">&#125;</div><div class="line">public class PointGenericityImpl&lt;T extends Number&amp; Serializable&gt; </div><div class="line">        implements PointInterface&lt;T,Integer&gt; &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里，我们在 PointInterface 的基础上，重写一个类 PointGenericityImpl，与上面直接在类中填充不同的是，它是一个泛型类。首先，将 PointInterface&lt;T, U&gt; 填充为 PointInterface&lt;T, Integer&gt;，即第一个参数依然是一个泛型，而第二个参数填充为 Integer；而我们也给 PointGenericityImpl 中的泛型变量 T 添加了限定：T extends Number&amp;Serializable，给它添加了extends 限定（上边界），指定 T 必须派生自 Number 类和 Serializable 类。</p><p>我们再看一下如何获取信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = PointGenericityImpl.class;</div><div class="line">Type[] types = clazz.getGenericInterfaces();</div><div class="line">for (Type type : types) &#123;</div><div class="line">    if (type instanceof ParameterizedType) &#123;</div><div class="line">        ParameterizedType parameterizedType = (ParameterizedType) type;</div><div class="line">        // 返回表示此类型实际类型参数的 Type 对象的数组</div><div class="line">        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</div><div class="line">        for (Type parameterArgType : actualTypeArguments) &#123;</div><div class="line">            if(parameterArgType instanceof TypeVariable)&#123;</div><div class="line">                TypeVariable typeVariable = (TypeVariable) parameterArgType;</div><div class="line">                Log.d(TAG, &quot;此接口的填充类型为：&quot; + typeVariable.getName());</div><div class="line"></div><div class="line">                // 返回表示此类型变量上边界的 Type 对象的数组。</div><div class="line">                Type[] typeBounds = typeVariable.getBounds();</div><div class="line">                for (Type bound : typeBounds)&#123;</div><div class="line">                    Class&lt;?&gt; boundClass = (Class)bound;</div><div class="line">                    // 如果不写，则默认输出 Object，如果写了，则输出对应的</div><div class="line">                    Log.d(TAG, &quot;bound为：&quot; + boundClass.getName());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (parameterArgType instanceof  Class)&#123;</div><div class="line">                Class parameterArgClass = (Class) parameterArgType;</div><div class="line">                Log.d(TAG, &quot;此接口的填充类型为：&quot; + parameterArgClass.getName());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>先看看结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-8cd98fb62aa61122.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>我们逐段来分析下；首先，获取 PointGenericityImpl 直接继承的的泛型接口数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = PointGenericityImpl.class;</div><div class="line">Type[] types = clazz.getGenericInterfaces();</div></pre></td></tr></table></figure></p><p>我们知道 PointGenericityImpl 只直接继承了一个接口：PointInterface&lt;T, Integer&gt;，其中 T 的限定为：&lt;T extends Number&amp;Serializable&gt;；所以 types 中只有一个元素，这个 type 元素代表的是 PointInterface&lt;T, Integer&gt;，明显它是一个泛型，所以这个 type 的类型是 ParameterizedType。所以，我们下面虽然用了 for …each 进行了列举了 types 中的所有元素，但我们知道它只有一个元素。然后我们将这个元素强转为 ParameterizedType，利用 parameterizedType.getActualTypeArguments() 得到 PointInterface&lt;T,U&gt; 中 T 和 U 被填充的真实类型对应的 Type 数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ParameterizedType parameterizedType = (ParameterizedType) type;</div><div class="line">// 返回表示此类型实际类型参数的 Type 对象的数组</div><div class="line">Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</div></pre></td></tr></table></figure></p><p>我们知道，PointInterface&lt;T,U&gt; 被真实填充为了 PointInterface&lt;T,Integer&gt;，其中 T 的限定为：&lt;T extends Number&amp;Serializable&gt;；所以这个 Type[] 数组包含两个变量，一个是 T，一个是 Integer。我们知道 T 是一个泛型变量，所以对应的类型应该是 TypeVariable。而 Integer 则是一个具体的类，它对应的类型应该是 Class。</p><ul><li>针对 T ：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">if(parameterArgType instanceof TypeVariable)&#123;</div><div class="line">    TypeVariable typeVariable = (TypeVariable) parameterArgType;</div><div class="line">    Log.d(TAG, &quot;此接口的填充类型为：&quot; + typeVariable.getName());</div><div class="line"></div><div class="line">    // 返回表示此类型变量上边界的 Type 对象的数组。</div><div class="line">    Type[] typeBounds = typeVariable.getBounds();</div><div class="line">    for (Type bound : typeBounds)&#123;</div><div class="line">        Class&lt;?&gt; boundClass = (Class)bound;</div><div class="line">        // 如果不写，则默认输出 Object，如果写了，则输出对应的</div><div class="line">        Log.d(TAG, &quot;bound为：&quot; + boundClass.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们知道 T 对应的 type 是 TypeVariable，所以将它强转为 TypeVariable 变量。然后用 typeVariable.getName() 获取这个填充的泛型变量的名字，得到的值为：T。</p><p>然后，利用 typeVariable.getBounds() 得到 T 的限定条件：上边界的数组。上边界的意思就是 extends 关键字后面的限定条件。“上”的意思就是能取到的最大父类。最大父类当然是用 extends 关键字来限定的。我们知道这里的 T 的限定条件是：&lt;T extends Number&amp;Serializable&gt;，所以 Type[] typeBounds = typeVariable.getBounds(); 所得到 typeBounds 有两个变量，一个是Number，一个是 Serializable。这两个都是具体的类型，所以我们可以直接将它们转换为 Class 类型，然后利用 Class.getName() 获取它们完整的路径名，结果如下：（有关上下边界的意义下面在讲WildcardType时会有图文讲解）</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-8db2587f9d11c68d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>针对 Integer：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = PointGenericityImpl.class;</div><div class="line">Type[] types = clazz.getGenericInterfaces();</div><div class="line">for (Type type : types) &#123;</div><div class="line">    if (type instanceof ParameterizedType) &#123;</div><div class="line">        ParameterizedType parameterizedType = (ParameterizedType) type;</div><div class="line">        // 返回表示此类型实际类型参数的 Type 对象的数组</div><div class="line">        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</div><div class="line">        for (Type parameterArgType : actualTypeArguments) &#123;</div><div class="line">            </div><div class="line">            ...</div><div class="line">            </div><div class="line">            if (parameterArgType instanceof Class) &#123;</div><div class="line">                Class parameterArgClass = (Class) parameterArgType;</div><div class="line">                Log.d(TAG, &quot;此接口的填充类型为：&quot; + parameterArgClass.getName());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第一个类型是 type 类型对应的是 T，第二个 type 类型则是 Integer 类型。明显 Integer 是一个 Class 类型，所以我们直接将它强转为 Class 即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (parameterArgType instanceof Class)&#123;</div><div class="line">    Class parameterArgClass = (Class) parameterArgType;</div><div class="line">    Log.d(TAG, &quot;此接口的填充类型为：&quot; + parameterArgClass.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="2、GenericArrayType"><a href="#2、GenericArrayType" class="headerlink" title="2、GenericArrayType"></a>2、GenericArrayType</h4><p>上面我们说过，当 type 对应的类型是类似于 String[]、Integer[] 等的数组时，那 type 的类型就是 GenericArrayType。这里要特别说明的如果 type 对应的是类似于 ArrayList、List 这样的类型，那 type 的类型应该是 ParameterizedType，而不是 GenericArrayType，因为 ArrayList 是一个泛型表达式。所以当且仅当 type 对应的类型是类似于 String[]、Integer[] 这样的数组时，type 的类型才是GenericArrayType。GenericArrayType 的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Type getGenericComponentType();</div></pre></td></tr></table></figure></p><p>这是 GenericArrayType 仅有一个函数，由于 getGenericComponentType 所代表的表达是 String[] 这种的数组，所以 getGenericComponentType 获取的就是这里的数组类型所对应的 Type，比如这里的 String[] 通过 getGenericComponentType 获取到的 Type 对应的就是 String。</p><p>好了，下面我们就举个例子来看看 GenericArrayType 的用法。我们重新生成一个泛型接口 PointSingleInterface：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public interface PointSingleInterface&lt;T&gt; &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这个泛型接口，只有一个泛型变量。然后生成一个类继承这个接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public class PointArrayImpl implements PointSingleInterface&lt;Integer[]&gt; &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 PointArrayImpl 中，我们填充 PointSingleInterface 中泛型变量 T 的是 Integer[]，一个 Integer 数组。下面我们来看看如何获取 PointArrayImpl 的接口信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = PointArrayImpl.class;</div><div class="line">Type[] interfaces = clazz.getGenericInterfaces();</div><div class="line">for (Type type : interfaces)&#123;</div><div class="line">    if (type instanceof ParameterizedType) &#123;</div><div class="line">        ParameterizedType pt = (ParameterizedType) type;</div><div class="line">        Type[] actualArgs = pt.getActualTypeArguments();</div><div class="line">        for (Type arg : actualArgs)&#123;</div><div class="line">            if (arg instanceof GenericArrayType)&#123;</div><div class="line">                GenericArrayType arrayType = (GenericArrayType)arg;</div><div class="line">                Type comType = arrayType.getGenericComponentType();</div><div class="line">                Class&lt;?&gt; typeClass = (Class)comType;</div><div class="line">                Log.d(TAG, &quot;数组类型为：&quot;+typeClass.getName());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-faac6c05306c3c09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>分析：首先，通过 clazz.getGenericInterfaces() 获取 PointArrayImpl.class 的接口对应的 type 列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = PointArrayImpl.class;</div><div class="line">Type[] interfaces = clazz.getGenericInterfaces();</div></pre></td></tr></table></figure></p><p>我们知道 PointArrayImpl.class 只直接继承一个接口：PointSingleInterface&lt;Integer[]&gt;，所以 interfaces 数组中只有一个元素，它代表的表达式就是 PointSingleInterface&lt;Integer[]&gt;；明显这个一个泛型表达式，所以这个 type 的类型就是 ParameterizedType。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">for (Type type : interfaces) &#123;</div><div class="line">    if (type instanceof ParameterizedType) &#123;</div><div class="line">        ParameterizedType pt = (ParameterizedType) type;</div><div class="line">        Type[] actualArgs = pt.getActualTypeArguments();</div><div class="line">        for (Type arg : actualArgs)&#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后利用 for…each 对 interfaces 数组进行逐个列表，但我们知道它只有一个元素，代表的表达式是 PointSingleInterface<integer[]>；然后用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Type[] actualArgs = pt.getActualTypeArguments();</div></pre></td></tr></table></figure></integer[]></p><p>得到表达式中 PointSingleInterface&lt;Integer[]&gt; 的参数列表，显然参数只有一个，即 Integer[]，所以 actualArgs 中只有一个元素，这个 type 元素对应的表达式是 Integer[]。我们知道当 type 对应的表达式是 Integer[] 时，这个 type 的类型就是 GenericArrayType。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (arg instanceof GenericArrayType)&#123;</div><div class="line">    GenericArrayType arrayType = (GenericArrayType)arg;</div><div class="line">    Type comType = arrayType.getGenericComponentType();</div><div class="line">    Class&lt;?&gt; typeClass = (Class)comType;</div><div class="line">    Log.d(TAG, &quot;数组类型为：&quot; + typeClass.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们将 arg 强转为 GenericArrayType 类型的变量 arrayType，然后利用 arrayType.getGenericComponentType() 得到数组的类型，因为我们这里的数组是 Integer[]，所以得到的类型是 Integer，明显这是一个确切的类，所以它的类型就是 Class，所以我们直接将 comType 进行强制转换为 Class&lt;?&gt; typeClass，最后利用 typeClass.getName() 得到 Integer 的具体类名。</p><p>好了，到这里，我们已经讲完了两种类型，下面开始讲解最后一个也是最难的一种类型 WildcardType。</p><h4 id="3、WildcardType"><a href="#3、WildcardType" class="headerlink" title="3、WildcardType"></a>3、WildcardType</h4><h5 id="3-1、概述"><a href="#3-1、概述" class="headerlink" title="3.1、概述"></a>3.1、概述</h5><p>我们前面说过，当 type 所代表的表达式是类型通配符相关的表达式时，比如 &lt;? extends Integer&gt;、&lt;? super String&gt; 或者 &lt;?&gt; 等，这个 type 的类型就是 WildcardType。</p><p>我们先来看看 WildcardType 的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 获取上边界对象列表</div><div class="line">Type[] getUpperBounds();</div><div class="line">// 获取下边界对象列表</div><div class="line">Type[] getLowerBounds();</div></pre></td></tr></table></figure></p><ul><li>getUpperBounds：获取上边界对象列表，上边界就是使用 extends 关键字所做的的限定，如果没有默认是 Object；</li><li>getLowerBounds：获取下边界对象列表，下边界是指使用 super 关键字所做的限定，如果没有则为 Null。</li></ul><p>我们举个例子：<br>&lt;? extends Integer&gt; 这个通配符的上边界就是 Integer.Class，下边界就是 null。<br>&lt;? super String&gt; 这个通配符的下边界是 String，上边界就是 Object。</p><p>有关上下边界，大家可能很不好记，我画个图来给大家解释下，上下边界的含义：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c1bff1bd48e656f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>看到这个类继承图，大家应该很容易就明白了，类继承图中，根结点始终是在祖先类，而且在继承图的上方，所以上方的就是上界，而子类是在下方，下方的就是下界。而表现在代码上，上界是继承的关系，所以是 &lt;? extends Object&gt;，而下界的则是 &lt;? super Double&gt;。</p><h5 id="3-2、有关通配符的使用范围"><a href="#3-2、有关通配符的使用范围" class="headerlink" title="3.2、有关通配符的使用范围"></a>3.2、有关通配符的使用范围</h5><p>通配符只是泛型变量的填充类型的一种，不能做为泛型变量使用。通配符 ? 只能出现在 Box&lt;?&gt; box; 中，其它位置都是不对的。即只能出现在生成泛型实例时使用，其它位置都是不可以的。尤其像下面这两个，直接用来填充类中的泛型变量：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-870d0c7ecf0d9fde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>但是第三个却是允许的。因为，这里的通配符 Comparable&lt;? extends Number&gt;，只有来生成 Comparable 对象的，所以是允许使用的。大家一定要注意，通配符只能用来填充泛型类来生成对象，其它用途一概是错误的。</p><h5 id="3-3、举例说明"><a href="#3-3、举例说明" class="headerlink" title="3.3、举例说明"></a>3.3、举例说明</h5><p>同样，我们使用上面的 PointSingleInterface 泛型接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public interface PointSingleInterface&lt;T&gt; &#123;&#125;</div></pre></td></tr></table></figure></p><p>然后我们生成一个类来继承这个接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public class PointWildcardImpl implements PointSingleInterface&lt;Comparable&lt;? extends Number&gt;&gt; &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>接下来就看看我们是怎么得到的 PointWildcardImpl 信息的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = PointWildcardImpl.class;</div><div class="line">// 此时的 type 对应 PointSingleInterface&lt;Comparable&lt;? extends Number&gt;&gt;</div><div class="line">Type[] types = clazz.getGenericInterfaces();</div><div class="line">for (Type type : types) &#123;</div><div class="line">    if (type instanceof ParameterizedType) &#123;</div><div class="line">        ParameterizedType parameterizedType = (ParameterizedType) type;</div><div class="line">        // 得到填充 PointSingleInterface 的具体参数，</div><div class="line">        // 即：Comparable&lt;? extends Number&gt;，仍然是一个 ParameterizedType</div><div class="line">        Type[] actualTypes = parameterizedType.getActualTypeArguments();</div><div class="line">        for (Type actualType : actualTypes) &#123;</div><div class="line">            if (actualType instanceof ParameterizedType) &#123;</div><div class="line">                ParameterizedType ComparableType = (ParameterizedType) actualType;</div><div class="line">                // 对 Comparable&lt;? extends Number&gt; 再取填充参数，</div><div class="line">                // 得到的 type 对应 &lt;? extends Number&gt;，这个就是 WildcardType 了</div><div class="line">                Type[] compareArgs = ComparableType.getActualTypeArguments();</div><div class="line">                for (Type Arg:compareArgs)&#123;</div><div class="line">                    if(Arg instanceof WildcardType) &#123;</div><div class="line">                        // 将得到的对应 WildcardType 的 type 强转为 WildcardType 的变量</div><div class="line">                        WildcardType wt = (WildcardType) Arg;</div><div class="line"></div><div class="line">                        // 利用 getLowerBounds 得到下界，即派生自 Super 的限定，</div><div class="line">                        // 如果没有派生自 super 则为 null</div><div class="line">                        Type[] lowerBounds = wt.getLowerBounds();</div><div class="line">                        for (Type bound:lowerBounds)&#123;</div><div class="line">                            Class&lt;?&gt; boundClass = (Class)bound;</div><div class="line">                            Log.d(TAG, &quot;lowerBound为：&quot; + boundClass.getName());</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        // 通过 getUpperBounds 得到上界，即派生 自extends 的限定，</div><div class="line">                        // 如果没有，默认是 Object</div><div class="line">                        Type[] upperBounds = wt.getUpperBounds();</div><div class="line">                        for (Type bound:upperBounds) &#123;</div><div class="line">                            Class&lt;?&gt; boundClass = (Class)bound;</div><div class="line">                            // 如果不写，则默认输出 Object，如果写了，则输出对应的</div><div class="line">                            Log.d(TAG, &quot;upperBound为：&quot; + boundClass.getName());</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果为：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b4e5b074a8d892af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>好了，到这里，所有有关 type 的类型就讲完了，但我们上面是逐个分析当前 type 应该强转为哪种类型的，如果我们稍微疏忽分析错了，或者，我们根本不知道它当前是哪种类型，这要怎么办，我们必须能写出来一个统一的转换函数出来。我们知道 type 所有的类型总共五种：Class、ParameterizedType、TypeVariable、WildcardType、GenericArrayType，所以我们利用递规的方法来写一个通用类型转换函数出来。</p><h5 id="3-4、通用类型转换函数"><a href="#3-4、通用类型转换函数" class="headerlink" title="3.4、通用类型转换函数"></a>3.4、通用类型转换函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">// 入口</div><div class="line">private void parseClass(Class&lt;?&gt; c) &#123;</div><div class="line">    parseTypeParameters(c.getGenericInterfaces());</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void parseTypeParameters(Type[] types) &#123;</div><div class="line">    for (Type type:types) &#123;</div><div class="line">        parseTypeParameter(type);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void parseTypeParameter(Type type) &#123;</div><div class="line">    if (type instanceof Class) &#123;</div><div class="line">        Class&lt;?&gt; c = (Class&lt;?&gt;) type;</div><div class="line">        Log.d(TAG, c.getSimpleName());</div><div class="line">    &#125; else if(type instanceof TypeVariable) &#123;</div><div class="line">        TypeVariable&lt;?&gt; tv = (TypeVariable&lt;?&gt;)type;</div><div class="line">        Log.d(TAG, tv.getName());</div><div class="line">        parseTypeParameters(tv.getBounds());</div><div class="line">    &#125; else if (type instanceof WildcardType) &#123;</div><div class="line">        WildcardType wt = (WildcardType)type;</div><div class="line">        Log.d(TAG, &quot;?&quot;);</div><div class="line">        parseTypeParameters(wt.getUpperBounds());</div><div class="line">        parseTypeParameters(wt.getLowerBounds());</div><div class="line">    &#125; else if (type instanceof ParameterizedType) &#123;</div><div class="line">        ParameterizedType pt = (ParameterizedType)type;</div><div class="line">        Type t = pt.getOwnerType();</div><div class="line">        if (t != null) &#123;</div><div class="line">            parseTypeParameter(t);</div><div class="line">        &#125;</div><div class="line">        parseTypeParameter(pt.getRawType());</div><div class="line">        parseTypeParameters(pt.getActualTypeArguments());</div><div class="line">    &#125; else if (type instanceof GenericArrayType) &#123;</div><div class="line">        GenericArrayType arrayType = (GenericArrayType)type;</div><div class="line">        Type t = arrayType.getGenericComponentType();</div><div class="line">        parseTypeParameter(t);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用上面的 PointWildcardImpl 类进行测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">parseClass(PointWildcardImpl.class);</div></pre></td></tr></table></figure></p><p>执行结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-862a349d26c00744.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><hr><p>本文涉及函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 获取泛型超类的 Type</div><div class="line">public Type getGenericSuperclass();</div><div class="line">// 获取泛型接口的方法</div><div class="line">public Type[] getGenericInterfaces();</div></pre></td></tr></table></figure></p><p>ParameterizedType 相关：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 获取填充泛型变量的真实参数列表</div><div class="line">Type[] getActualTypeArguments();</div><div class="line">// 返回声明此当前泛型表达式的类或接口的 Class 对象</div><div class="line">Type getRawType();</div></pre></td></tr></table></figure></p><p>TypeVariable 相关：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 就是得到当前泛型变量的名称</div><div class="line">String getName();</div><div class="line">// 返回表示此类型变量上边界的 Type 对象的数组。</div><div class="line">// 如果没有上边界，则默认返回Object</div><div class="line">Type[]  getBounds();</div></pre></td></tr></table></figure></p><p>GenericArrayType 相关：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 当前数组类型所对应的 Type</div><div class="line">Type getGenericComponentType();</div></pre></td></tr></table></figure></p><p>WildcardType 相关：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 获取通配符的上边界对象列表</div><div class="line">Type[] getUpperBounds();</div><div class="line">// 获取通配符的下边界对象列表</div><div class="line">Type[] getLowerBounds();</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-8a247d2376d8c786?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>原文链接：<br><a href="https://blog.csdn.net/harvic880925/article/details/50085595" target="_blank" rel="external">夯实JAVA基本之二 —— 反射（2）：泛型相关周边信息获取</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射一：基本类周边信息获取</title>
      <link href="/1900/01/10/01%20JAVA/10%20%E5%8F%8D%E5%B0%84%E4%B8%80%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%91%A8%E8%BE%B9%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/"/>
      <url>/1900/01/10/01%20JAVA/10%20%E5%8F%8D%E5%B0%84%E4%B8%80%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%91%A8%E8%BE%B9%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>相关文章：<br><a href="https://xianxiaotao.github.io/1900/01/08/01%20JAVA/08%20Java%20Relfect/" target="_blank" rel="external">Java Relfect</a><br><a href="https://xianxiaotao.github.io/1900/01/09/01%20JAVA/09%20Java%20RelfectUtils/" target="_blank" rel="external">Java RelfectUtils</a><br><a href="https://xianxiaotao.github.io/1900/01/10/01%20JAVA/10%20%E5%8F%8D%E5%B0%84%E4%B8%80%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%91%A8%E8%BE%B9%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/" target="_blank" rel="external">反射一：基本类周边信息获取</a><br><a href="https://xianxiaotao.github.io/1900/01/11/01%20JAVA/11%20%E5%8F%8D%E5%B0%84%E4%BA%8C%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%91%A8%E8%BE%B9%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/" target="_blank" rel="external">反射二：泛型相关周边信息获取</a><br><a href="https://xianxiaotao.github.io/1900/01/12/01%20JAVA/12%20%E5%8F%8D%E5%B0%84%E4%B8%89%EF%BC%9A%E7%B1%BB%E5%86%85%E9%83%A8%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/" target="_blank" rel="external">反射三：类内部信息获取</a></p></blockquote><p>JAVA 反射机制是在运行状态中，对于任何一个类，都能够知道这个类的所有属性和方法；对于任何一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 JAVA 语言的反射机制。</p><h3 id="一、引入"><a href="#一、引入" class="headerlink" title="一、引入"></a>一、引入</h3><hr><p>在开始反射之前，我们先看看 JVM 是如何将我们写的类对应的 java 文件加载到内存中的。</p><h4 id="1、类的生命周期"><a href="#1、类的生命周期" class="headerlink" title="1、类的生命周期"></a>1、类的生命周期</h4><p>这部分我们先讲讲 JVM 的加载机制。写一个最简单的 Main 函数，来看看这个函数的是如何被执行的，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Animal animal = new Animal();</div><div class="line">        animal.setName(&quot;cat&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 内部静态类</div><div class="line">    public static class Animal &#123;</div><div class="line">        private String name;</div><div class="line">        public String getName() &#123;</div><div class="line">            return name;</div><div class="line">        &#125;</div><div class="line">        public void setName(String name) &#123;</div><div class="line">            this.name = name;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这段代码很简单，我们定义了一个 Animal 的类，在 main() 函数中，我们首先定义了一个 Animal 实例，然后调用了该实例的 setName() 方法。</p><p>大家都知道，在拿到一个 java 源文件后，如果要经过源码编译，要经过两个阶段：编译（javac.exe）、运行（java.exe）。</p><ul><li>编译</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javac Test.java</div></pre></td></tr></table></figure><p>在执行后在同一目录下生成 Test.class 和 Animal 类对应的文件Test$Animal.class（由于我们的 Animal 类是 Main 中的内部类，所以用 $ 表示）。</p><ul><li>运行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java Main</div></pre></td></tr></table></figure><p>在这一阶段，又分为三个小阶段：装载，链接，初始化。</p><ul><li>装载<br>类的装载是通过类加载器完成的，加载器将 .class 文件的二进制文件装入 JVM 的方法区，并且在堆区创建描述这个类的 java.lang.Class 对象，用来封装数据。 但是同一个类只会被类装载器装载一次！</li><li>链接<br>链接就是把二进制数据组装为可以运行的状态。链接分为校验、准备、解析这三个阶段。校验一般用来确认此二进制文件是否适合当前的 JVM（版本），准备就是为静态成员分配内存空间，并设置默认值。解析指的是转换常量池中的代码作为直接引用的过程，直到所有的符号引用都可以被运行程序使用（建立完整的对应关系）。</li><li>初始化<br>初始化就是对类中的变量进行初始化值。完成之后，类型也就完成了初始化，初始化之后类的对象就可以正常使用了，直到一个对象不再使用之后，将被垃圾回收，释放空间。</li></ul><p>当没有任何引用指向 Class 对象时就会被卸载，结束类的生命周期。如果再次用到就再重新开始装载、链接和初始化的过程。</p><h4 id="2、获取类类型"><a href="#2、获取类类型" class="headerlink" title="2、获取类类型"></a>2、获取类类型</h4><h5 id="2-1、泛型隐藏填充类型"><a href="#2-1、泛型隐藏填充类型" class="headerlink" title="2.1、泛型隐藏填充类型"></a>2.1、泛型隐藏填充类型</h5><p>泛型隐藏填充类型默认填充为无界通配符？在上面，我们讲了，类只会被装载一次，利用装载的类可以实例化出各种不同的对象。而反射就是通过获取装载的类来做出各种操作的。装载的类，我们称为类类型，利用装载的类产生的实例，我们称为类实例。下面我们就看看，如何利用代码获取类类型的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 使用方法一</div><div class="line">Class class1 = Animal.class;</div><div class="line">Log.i(TAG, class1.getName());</div><div class="line">// 使用方法二</div><div class="line">Class&lt;?&gt; class2 = Animal.class;</div><div class="line">Log.i(TAG, class2.getName());</div></pre></td></tr></table></figure></p><p>运行结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-5b73896f01a266e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从结果中可以看出 class1 和 class2 是完全一样的，那构造他们时的方法一和方法二有什么区别呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 使用方法一</div><div class="line">Class class1 = Animal.class;</div><div class="line">// 使用方法二</div><div class="line">Class&lt;?&gt; class2 = Animal.class;</div></pre></td></tr></table></figure></p><p>可以看到这两个方法，右边全部都是 Animal.class，而左边却有些不同。方法一中，是直接生成了一个 Class 的实例。而在方法二中，则生成的是一个 Class 的泛型，并且使用的是无界通配符来填充的。我们都知道，Class 类是一个泛型，而泛型的正规写法就应该是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class&lt;Animal&gt; class2 = Animal.class;</div></pre></td></tr></table></figure></p><p>而方法一，只是把泛型的填充给省略了.在泛型中，如果把泛型的填充给省略掉，那就会默认填充为无界通配符”？”。所以方法一的真实写法是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; class1 = Animal.class;</div></pre></td></tr></table></figure></p><p>所以这两种写法是意义是完全相同的。如果我们不用通配符，也就只能这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class&lt;Animal&gt; class2 = Animal.class;</div></pre></td></tr></table></figure></p><h5 id="2-2、获取类类型的方法"><a href="#2-2、获取类类型的方法" class="headerlink" title="2.2、获取类类型的方法"></a>2.2、获取类类型的方法</h5><p>上面我们通过 Class&lt;?&gt; class1 = Animal.class; 即直接使用类名的 Class 对象来获取类类型，这只是其中一个方法，下面这四种方法都可以获得对应的类类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 方法一：</div><div class="line">Person person = new Person();  </div><div class="line">Class a = person.getClass() </div><div class="line">// 方法二：</div><div class="line">Class b = Persion.class;</div><div class="line">// 方法三：</div><div class="line">Class c = Class.forName(String className); </div><div class="line">// 方法四：（不建议使用）</div><div class="line">Class d = context.getClassLoader().loadClass(String className);</div></pre></td></tr></table></figure></p><p>方法一：通过类实例的 getClass() 方法得到类类型；方法二：直接通过类的 class 对象得到；方法三和方法四中是通过类名得到，这两点要非常注意，这里的 className 一定要从包名具体到类名，唯一定位到一个类才行，不然就会报 ClassNotFound 错误。</p><p>在上面我们提到过，类只会被加载一次，所以 a、b、c、d 都是相等的，因为他们都是指向同一个对象，如果用等号操作符来判断的话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean result = (clazz1 == clazz2 &amp;&amp; clazz3 == clazz4 &amp;&amp; clazz1 == clazz3);</div></pre></td></tr></table></figure></p><p>result 的值为 true。</p><p>下面我们针对方法三和方法四举个粟子来看下：有一个单独的 Animal 类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Animal &#123;</div><div class="line">    private String name;</div><div class="line"> </div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class TestActivity extends BaseActivity &#123;</div><div class="line"></div><div class="line">    private static final String TAG = &quot;xian&quot;;</div><div class="line">    private Button btnCancel;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_test);</div><div class="line"></div><div class="line">        btnCancel = findViewById(R.id.login_cancel_btn);</div><div class="line">        btnCancel.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                try &#123;</div><div class="line">                    test();</div><div class="line">                &#125; catch (Exception e) &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void test() throws Exception &#123;</div><div class="line">        Class&lt;?&gt; class1 = Class.forName(&quot;com.xxt.xtest.Animal&quot;);</div><div class="line">        Log.d(TAG,&quot;通过 Class.forName 获得的类名：&quot; + class1.getName());</div><div class="line"></div><div class="line">        class1 = getClassLoader().loadClass(&quot;com.xxt.xtest.Animal&quot;);</div><div class="line">        Log.d(TAG,&quot;通过 ClassLoader 获得的类名：&quot;+class1.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-628c16d96517e204.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从上面的用法中，可以看出，我们要使用 Class.forName() 或者 getClassLoader().loadClass()，其中的类名必须是从包名到类名的完整路径。</p><p>从这里看来 Class.forName() 和 getClassLoader().loadClass() 是相同的，其实他们是有区别的。平时，我们不建议使用 getClassLoader().loadClass() 的方法来加载类类型。有关Class.forName() 和 getClassLoader().loadClass() 的具体区别，会在本篇末尾讲述。</p><h3 id="二、基本类类型周边信息获取"><a href="#二、基本类类型周边信息获取" class="headerlink" title="二、基本类类型周边信息获取"></a>二、基本类类型周边信息获取</h3><p>我们知道类分为基本类和泛型类，这篇我们只讲基本类类型的周边信息获取，有关泛型类的周边信息获取，我们会放到下一篇中。<br>这部分主要讲述类类型周边信息获取方法，包括类名，包名，超类和继承接口。</p><h4 id="1、类名、包名获取"><a href="#1、类名、包名获取" class="headerlink" title="1、类名、包名获取"></a>1、类名、包名获取</h4><p>相关的有三个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 获取完整的类名（包含包名）</div><div class="line">public String getName();</div><div class="line">// 仅获取类名</div><div class="line">public String getSimpleName();</div><div class="line">// 获取类类型所对应的 package 对象，几乎不用</div><div class="line">public Package getPackage()</div></pre></td></tr></table></figure></p><p>函数使用如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; class1 = Animal.class;</div><div class="line">Package package1 = class1.getPackage();</div><div class="line"> </div><div class="line">Log.d(TAG,&quot;完整的类名：&quot; + class1.getName());</div><div class="line">Log.d(TAG,&quot;仅获取类名：&quot; + class1.getSimpleName());</div><div class="line">Log.d(TAG,&quot;包名：&quot; + package1.getName());</div></pre></td></tr></table></figure></p><p>结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b2be100acdc32679.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从结果中很清晰的看到，class.getName() 获取的是类名包含完整路径。调用 Class.forName() 就是用的这个值。class.getSimpleName() 得到的是仅仅是一个类名。而 class.getPackage() 得到的是该类对应的 Package 对象。通过 package.getName() 能获得该类所对应的包名。</p><h4 id="2、获取超类-Class-对象"><a href="#2、获取超类-Class-对象" class="headerlink" title="2、获取超类 Class 对象"></a>2、获取超类 Class 对象</h4><p>获取 superClass 的类对象，涉及到两个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 获取普通函数的父类 Class 对象</div><div class="line">public Class&lt;?&gt; getSuperclass();</div><div class="line">// 针对泛型父类而设计</div><div class="line">public Type getGenericSuperclass();</div></pre></td></tr></table></figure></p><p>getSuperclass() 用来获取普通函数，而 getGenericSuperclass() 是用来获取泛型类型的父类而设计的，有关 getGenericSuperclass() 的知识我们后面会讲，这里先看看 getSuperclass() 的用法。</p><p>我们仍然利用前面讲到的 Animal 类，然后在其上派生一个 AnimalImpl 子类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Animal &#123;</div><div class="line">    private String name;</div><div class="line"> </div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public class AnimalImpl extends Animal &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; class2 = Class.forName(&quot;com.xxt.xtest.AnimalImpl&quot;);</div><div class="line">Class&lt;?&gt; parentClass = class2.getSuperclass();</div><div class="line">Log.d(TAG, &quot;父类：&quot; + parentClass.getName());</div></pre></td></tr></table></figure></p><p>结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-503c26e48ae994ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在这里，我们使用了 Class.forName(“com.xxt.xtest.AnimalImpl”); 找到 AnimalImpl 的类类型对象，然后调用 class2.getSuperclass() 找到它的父类 Class 对象。很明显，它的父类是 Animal 类。由于我们这里得到了父类的 Class 对象 parentClass，所以可以对它使用 Class 的一切函数。所以调用 parentClass.getName() 就可以获得父类的名称了。</p><h4 id="3、直接继承的接口的-Class-对象"><a href="#3、直接继承的接口的-Class-对象" class="headerlink" title="3、直接继承的接口的 Class 对象"></a>3、直接继承的接口的 Class 对象</h4><p>这里要先声明一个观点：Class 类，不同于定义类的 class 标识，Class 类是一个泛型。类对象是由 Class 对象来表示，而接口对象同样也是用 Class 对象来表示。所以同样是 Class 对象，它可能表示的类对象，也可能表示的是接口对象。获取接口对象的函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 获取普通接口的方法</div><div class="line">public Class&lt;?&gt;[] getInterfaces();</div><div class="line">// 获取泛型接口的方法</div><div class="line">public Type[] getGenericInterfaces();</div></pre></td></tr></table></figure></p><p>与获取 superClass 对象一样，这里同样有两个函数来获取接口对象，有关 getGenericInterfaces() 获取泛型接口的方法，我们下篇再讲，这里先讲讲获取普通接口的方法 getInterfaces()。</p><p>getInterfaces() 将获取指定类直接继承的接口列表，注意是直接继承。如果不是直接继承，那将是获取不到的。举个例子，以上面的 Animal 为例：</p><p>我们先声明一个接口，让 Animal 类来继承：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface IAnimal &#123;</div><div class="line">    void setName(String name);</div><div class="line">    String getName();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后是 Animal 类继承接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Animal implements IAnimal &#123;</div><div class="line">    private String name;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>为了测试不是直接继承的接口是无法获取的问题，我们再从 Animal 派生一个子类 AnimalImpl:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public class AnimalImpl extends Animal &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们再整理一下思路，Animal 类直接继承了 IAnimal，而 AnimalImpl 仅仅派生自 Animal，它的 IAnimal 接口不是直接继承的，而是从它的父类 Aniaml 那带过来的。</p><p>然后我们分别看看 Animal 类和 AnimalImpl 类的的获取接口的结果，完整的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 获取 Animal 类的接口列表</div><div class="line">Class&lt;?&gt; class3 = Animal.class;</div><div class="line">Class&lt;?&gt;[] interfaces = class3.getInterfaces();</div><div class="line">for (Class interItem:interfaces)&#123;</div><div class="line">    Log.d(TAG, &quot;Animal 继承的接口：&quot; + interItem.getName());</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 获取 AnimalImpl 的接口列表</div><div class="line">class3 = AnimalImpl.class;</div><div class="line">interfaces = class3.getInterfaces();</div><div class="line">if (interfaces.length &gt;0) &#123;</div><div class="line">    for (Class interItem : interfaces) &#123;</div><div class="line">        Log.d(TAG, &quot;AnimalImpl 继承的接口：&quot; + interItem.getName());</div><div class="line">    &#125;</div><div class="line">&#125; else &#123;</div><div class="line">    Log.d(TAG, &quot;AnimalImpl 无继承的接口&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-9c807913aab4fc48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从结果可以看出，这里找到了 Animal 类所继承的接口值；但 AnimalImpl 获取到的接口列表为空。所以这也证明了 getInterfaces() 只能获取类直接继承的接口列表。</p><h4 id="4、获取某个类类型的所有接口"><a href="#4、获取某个类类型的所有接口" class="headerlink" title="4、获取某个类类型的所有接口"></a>4、获取某个类类型的所有接口</h4><p>如果我想传进去一下类类型，然后要得到它所有继承的接口列表要怎么办？不管它是不是直接继承来的都要列出来。</p><p>那只有靠递规了，我们需要递规它的父类直接继承的接口、父类的父类直接继承的接口以此类推，最终到 Object 类的时候就找到所有继承的接口了。</p><p>在开始递规获取所有接口之前，我们先构造下代码。由于我们要获取所有接口，为了效果更好些，我们在 Animal 和 AnimalImpl 基础上，多加几个继承的接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 给 Animal 添加 IAnimal、Serializable 两个接口</div><div class="line">public class Animal implements IAnimal, Serializable &#123;</div><div class="line">    private String name;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 给 AnimalImpl 添加 Serializable 接口</div><div class="line">public class AnimalImpl extends Animal implements Serializable &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>所以如果我们获取 AnimalImpl 类的接口列表，得到的应该是三个：自已直接继承的 Serializable、从父类 Animal 那继承的 IAnimal 和 Serializable。获取类类型所有接口列表的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 获取所传类类型的所有继承的接口列表</div><div class="line"> * @param clazz</div><div class="line"> * @return</div><div class="line"> */</div><div class="line">public Class&lt;?&gt;[] getAllInterface(Class&lt;?&gt; clazz)&#123;</div><div class="line">    // 获取自身的所有接口</div><div class="line">    Class&lt;?&gt;[] interSelf = clazz.getInterfaces();</div><div class="line">    // 递规调用getAllInterface获取超类的所有接口</div><div class="line">    Class&lt;?&gt; superClazz = clazz.getSuperclass();</div><div class="line">    Class&lt;?&gt;[] interParent = null;</div><div class="line">    if (null != superClazz) &#123;</div><div class="line">        interParent = getAllInterface(superClazz);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 返回值</div><div class="line">    if (interParent == null &amp;&amp; interSelf != null) &#123;</div><div class="line">        return interSelf;</div><div class="line">    &#125; else if (interParent == null &amp;&amp; interSelf == null)&#123;</div><div class="line">        return null;</div><div class="line">    &#125; else if (interParent != null &amp;&amp; interSelf == null)&#123;</div><div class="line">        return interParent;</div><div class="line">    &#125; else &#123;</div><div class="line">        final int length = interParent.length + interSelf.length;</div><div class="line">        Class&lt;?&gt;[] result = new Class[length];</div><div class="line">        System.arraycopy(interSelf,0,result,0,interSelf.length);</div><div class="line">        System.arraycopy(interParent,0,result,interSelf.length,interParent.length);</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt;[] clazzes = getAllInterface(AnimalImpl.class);</div><div class="line">SpannableStringBuilder builder = new SpannableStringBuilder();</div><div class="line">for (Class clazz : clazzes) &#123;</div><div class="line">    builder.append(clazz.getName());</div><div class="line">    builder.append(&quot;   &quot;);</div><div class="line">&#125;</div><div class="line">Log.d(TAG, &quot;AnimalImpl 继承的所有接口: &quot; + builder.toString());</div></pre></td></tr></table></figure></p><p>先看看执行结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-83d45c3fc9948663.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这段代码最关键的地方在于 getAllInterface(Class&lt;?&gt; clazz)；代码分为两部分，第一部分是获得自己的接口列表和父类的列表：通过 Class&lt;?&gt;[] interSelf = clazz.getInterfaces(); 获得自已直接继承的接口列表。然后，通过 Class&lt;?&gt; superClazz = clazz.getSuperclass(); 获取父类的 Class 类型，然后调用 getAllInterface(superClazz) 获得父类的所有接口列表。那么，把它们两个合并，就是所有的接口列表了。</p><p>合并逻辑：对 interParent 和 interSelf 判空，如果两个列表都是空，那直接返回空；如果有一个是空，另一个不是空，则返回那个不是空的列表；如果两个都不是空，则将他们合并，然后返回合并后的列表。</p><h4 id="5、获取类的访问修饰符"><a href="#5、获取类的访问修饰符" class="headerlink" title="5、获取类的访问修饰符"></a>5、获取类的访问修饰符</h4><p>由于我们在定义类时，比如下面的内部类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static final class InnerClass &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在类名，前面的那一坨 public static final，就是类的访问修饰符，是定义这个类在的访问区域和访问限定的。这部分就讲讲如何获取类的这部分访问修饰符，以上面的内部类 InnerClass 为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz = getClassLoader().loadClass(InnerClass.class.getName());</div><div class="line">int modifiers = clazz.getModifiers();</div><div class="line">String retval = Modifier.toString(modifiers);</div><div class="line">boolean isFinal = Modifier.isFinal(modifiers);</div><div class="line">Log.d(TAG, &quot;InnerClass 的定义修饰符: &quot; + retval);</div><div class="line">Log.d(TAG, &quot;is Final: &quot; + isFinal);</div></pre></td></tr></table></figure></p><p>结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-5c279d59ebf4f79c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>首先，在这部分代码中，我们又换了一种类加载方式，使用的是 ClassLoader。然后我们单独来看看这句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int modifiers = clazz.getModifiers();</div></pre></td></tr></table></figure></p><p>通过 clazz.getModifiers() 得到一个整型变量，由于访问修饰符有很多，所以这些修饰符被打包成一个 int，对应的二进制中，每个修饰符是一个标志位，可以被置位或清零。另外 Java 开发人员单独提供了一个类来提取这个整型变量中各标识位的函数，这个类就是 Modifier。Modifier 中主要有以下几个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 根据整型变量来生成对应的修饰符字符串</div><div class="line">String Modifier.toString(int modifiers) </div><div class="line">// 以下这些方法来检查特定的修饰符是否存在</div><div class="line">boolean Modifier.isAbstract(int modifiers)</div><div class="line">boolean Modifier.isFinal(int modifiers)</div><div class="line">boolean Modifier.isInterface(int modifiers)</div><div class="line">boolean Modifier.isNative(int modifiers)</div><div class="line">boolean Modifier.isPrivate(int modifiers)</div><div class="line">boolean Modifier.isProtected(int modifiers)</div><div class="line">boolean Modifier.isPublic(int modifiers)</div><div class="line">boolean Modifier.isStatic(int modifiers)</div><div class="line">boolean Modifier.isStrict(int modifiers)</div><div class="line">boolean Modifier.isSynchronized(int modifiers)</div><div class="line">boolean Modifier.isTransient(int modifiers)</div><div class="line">boolean Modifier.isVolatile(int modifiers)</div></pre></td></tr></table></figure></p><p>首先是 toString 函数：这个函数的作用就是根据传进来的整型，获取其中的标识位来判断具有哪个修饰符，然后将所有修饰符拼接起来输出。比如我们的例子中输出的就是：public static final。</p><p>其它的就是一些 isXXXX(int moifiers) 的判断指定标识位的函数了。在例子中，我们使用了 Modifier.isFinal(int modifiers) 来判断是不是具有 final 修饰符，返回结果为 true。</p><h4 id="6、获取接口的访问修饰符"><a href="#6、获取接口的访问修饰符" class="headerlink" title="6、获取接口的访问修饰符"></a>6、获取接口的访问修饰符</h4><p>从上面获取类的访问修饰符时，接口、类、函数都是通过 Modifier 类判断访问修饰符的，又因为类和接口类型全部都是用 Class 对象来标识，所以接口和类的获取访问修饰符的方式完全相同，下面就举一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 定义一个类部接口</div><div class="line">public static interface  InnerInteface &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; clazz2 = InnerInteface.class;</div><div class="line">int modifiers = clazz2.getModifiers();</div><div class="line">String str = Modifier.toString(modifiers);</div><div class="line">boolean isInterface = Modifier.isInterface(modifiers);</div><div class="line">Log.d(TAG, &quot;InnerClass 的定义修饰符: &quot; + str);</div><div class="line">Log.d(TAG, &quot;isInterface: &quot; + isInterface);</div></pre></td></tr></table></figure></p><p>如果我们要直接获取一个接口的对象，同样，也是通过开头所讲的那四种获取Class对象的方式。因为我们现在知道 Class 对象，不光代表类也可以代表接口。有关 Modifier 的使用与第五部分获取类的修饰符是一样的。</p><h4 id="7、Class-forName-与-ClassLoader-loadClass-的区别"><a href="#7、Class-forName-与-ClassLoader-loadClass-的区别" class="headerlink" title="7、Class.forName 与 ClassLoader.loadClass 的区别"></a>7、Class.forName 与 ClassLoader.loadClass 的区别</h4><p>我们通过源码来看看他们的区别。先看 Class.forName：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public static Class&lt;?&gt; forName(String className) throws ClassNotFoundException &#123;</div><div class="line">    return forName(className, true, VMStack.getCallingClassLoader());</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public static Class&lt;?&gt; forName(String className, boolean initializeBoolean,</div><div class="line">        ClassLoader classLoader) throws ClassNotFoundException &#123;</div><div class="line">    Class&lt;?&gt; result;</div><div class="line">    try &#123;</div><div class="line">        result = classForName(className, initializeBoolean, classLoader);</div><div class="line">    &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">        Throwable cause = e.getCause();</div><div class="line">        if (cause instanceof ExceptionInInitializerError) &#123;</div><div class="line">            throw (ExceptionInInitializerError) cause;</div><div class="line">        &#125;</div><div class="line">        throw e;</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从源中可以看到 Class.forName(String className) 最终调用的是 forName(String className, boolean initializeBoolean, ClassLoader classLoader) 函数。<br>其中：</p><ul><li>className：类名。</li><li>initializeBoolean：表示是否需要初始化；如果设为 true，表示在加载以后，还会进入链接阶段。</li><li>classLoader：ClassLoader 加载器。</li></ul><p>我们知道源文件在编译后，在运行时，分为三个阶段：加载、链接和初始化。这里的 initializeBoolean 就是定义是否进行链接和初始化。而 Class.forName 默认是设置的为 true。所以利用 Class.forName() 得到的类类型，除了加载进来以外，还进行了链接和初始化操作。</p><p>下面再来看看 ClassLoader.loadClass()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public Class&lt;?&gt; loadClass(String className) throws ClassNotFoundException &#123;</div><div class="line">    return loadClass(className, false);</div><div class="line">&#125;</div><div class="line">protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123;</div><div class="line">    Class&lt;?&gt; clazz = findLoadedClass(className);</div><div class="line"> </div><div class="line">    if (clazz == null) &#123;</div><div class="line">        try &#123;</div><div class="line">            clazz = parent.loadClass(className, false);</div><div class="line">        &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">            // Don&apos;t want to see this.</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        if (clazz == null) &#123;</div><div class="line">            clazz = findClass(className);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    return clazz;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>loadClass(String className) 最终是调用递规函数 loadClass(String className, boolean resolve) 来将类加载出来。通过代码也可以看出来 ClassLoader 的 loadClass(String className) 只是将类加载出来，并没有链接与初始化的步骤。</p><p>最后，我们总结一下，Class.forName(String className) 不仅会将类加载进来，而且会对其进行初始化，而 ClassLoader.loadClass(String ClassName) 则只是将类加载进来，而没有对类进行初始化。一般来讲，他们两个是通用的，但如果你加载类依赖初始化值的话，那 ClassLoader.loadClass(String ClassName) 将不再适用。</p><p>举例来说：在 JDBC 编程中，常看到这样的用法。Class.forName(“com.mysql.jdbc.Driver”); 如果换成了 getClass().getClassLoader().loadClass(“com.mysql.jdbc.Driver”); 就不行。</p><p>为什么呢？打开 com.mysql.jdbc.Driver 的源代码看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// Register ourselves with the DriverManager</div><div class="line">static &#123;</div><div class="line">    try &#123;</div><div class="line">        java.sql.DriverManager.registerDriver(new Driver());</div><div class="line">    &#125; catch (SQLException E) &#123;</div><div class="line">        throw new RuntimeException(&quot;Can&apos;t register driver!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>原来，Driver 在 static 块中会注册自己到 java.sql.DriverManager。而 static 块就是在 Class 的初始化中被执行。所以这个地方就只能用Class.forName(className)。</p><p>这篇文章所涉及到的几个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// 获取类类型对象的几种方式：</div><div class="line">Person person = new Person();  </div><div class="line">Class a = person.getClass() // 方法一</div><div class="line">Class b = Persion.class; // 方法二</div><div class="line">Class c = Class.forName(String ClassName); // 方法三</div><div class="line">Class d = context.getClassLoader().loadClass(String ClassName); // 方法四（不建议使用）</div><div class="line"> </div><div class="line">// 获取包名类名</div><div class="line">public String getName(); // 获取完整的类名（包含包名）</div><div class="line">public String getSimpleName(); // 仅获取类名</div><div class="line">public Package getPackage(); // 获取类类型所对应的 package 对象</div><div class="line"> </div><div class="line">// 获取超类 Class 对象</div><div class="line">public Class&lt;?&gt; getSuperclass(); // 获取普通函数的父类 Class 对象</div><div class="line">public Type getGenericSuperclass(); // 针对泛型父类而设计（下篇讲解）</div><div class="line"> </div><div class="line">// 获取接口 Class 对象</div><div class="line">public Class&lt;?&gt;[] getInterfaces(); // 获取普通接口的方法</div><div class="line">public Type[] getGenericInterfaces(); // 获取泛型接口的方法</div><div class="line"> </div><div class="line">// 类访问修饰符</div><div class="line">int modifiers = clazz.getModifiers(); // 获取类访问修饰符对应的 int 变量</div><div class="line">String Modifier.toString(int modifiers); // 根据整型变量来生成对应的修饰符字符串</div><div class="line">boolean Modifier.isAbstract(int modifiers); // isXXX() 系列函数用以检查特定的修饰符是否存在</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0e02e34db86b305e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>原文链接：<br><a href="https://blog.csdn.net/harvic880925/article/details/50072739" target="_blank" rel="external">夯实JAVA基本之二 —— 反射（1）：基本类周边信息获取</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA ReflectUtils</title>
      <link href="/1900/01/09/01%20JAVA/09%20Java%20RelfectUtils/"/>
      <url>/1900/01/09/01%20JAVA/09%20Java%20RelfectUtils/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>相关文章：<br><a href="https://xianxiaotao.github.io/1900/01/08/01%20JAVA/08%20Java%20Relfect/" target="_blank" rel="external">Java Relfect</a><br><a href="https://xianxiaotao.github.io/1900/01/09/01%20JAVA/09%20Java%20RelfectUtils/" target="_blank" rel="external">Java RelfectUtils</a><br><a href="https://xianxiaotao.github.io/1900/01/10/01%20JAVA/10%20%E5%8F%8D%E5%B0%84%E4%B8%80%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%91%A8%E8%BE%B9%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/" target="_blank" rel="external">反射一：基本类周边信息获取</a><br><a href="https://xianxiaotao.github.io/1900/01/11/01%20JAVA/11%20%E5%8F%8D%E5%B0%84%E4%BA%8C%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%91%A8%E8%BE%B9%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/" target="_blank" rel="external">反射二：泛型相关周边信息获取</a><br><a href="https://xianxiaotao.github.io/1900/01/12/01%20JAVA/12%20%E5%8F%8D%E5%B0%84%E4%B8%89%EF%BC%9A%E7%B1%BB%E5%86%85%E9%83%A8%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/" target="_blank" rel="external">反射三：类内部信息获取</a></p></blockquote><h4 id="Invoking-Arbitrary-Methods："><a href="#Invoking-Arbitrary-Methods：" class="headerlink" title="Invoking Arbitrary Methods："></a>Invoking Arbitrary Methods：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Method sqrt = Math.class.getMethod(<span class="string">"sqrt"</span>, double.class);</div><div class="line">double x = (Double) sqrt.invoke(null, 100); // 此方法为静态方法，隐式参数为null</div></pre></td></tr></table></figure><h4 id="ReflectionUtils："><a href="#ReflectionUtils：" class="headerlink" title="ReflectionUtils："></a>ReflectionUtils：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div></pre></td><td class="code"><pre><div class="line">package com.xian.reflection;</div><div class="line"></div><div class="line">import java.lang.annotation.Annotation;</div><div class="line">import java.lang.reflect.AccessibleObject;</div><div class="line">import java.lang.reflect.Array;</div><div class="line">import java.lang.reflect.Constructor;</div><div class="line">import java.lang.reflect.Field;</div><div class="line">import java.lang.reflect.Method;</div><div class="line">import java.lang.reflect.Modifier;</div><div class="line">import java.util.ArrayList;</div><div class="line"></div><div class="line">/**</div><div class="line"> * ReflectionUtils : </div><div class="line"> * 1 Get all features of a class</div><div class="line"> * 2 A generic toString method that works <span class="keyword">for</span> any class</div><div class="line"> * 3 Copy array</div><div class="line"> * </div><div class="line"> * @author xianxiaotao</div><div class="line"> */</div><div class="line">public class ReflectionUtils &#123;</div><div class="line">    /**</div><div class="line">     * flag to contain annotation and exception string</div><div class="line">     */</div><div class="line">    private static int flag = 0b00000000_00000000_00000000_00000000;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * flag : contain annotation string</div><div class="line">     */</div><div class="line">    public static final int CONTAIN_ANNOTATION = 0b00000000_00000000_00000000_00000001;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * flag : contain exception string</div><div class="line">     */</div><div class="line">    public static final int CONTAIN_EXCEPTION  = 0b00000000_00000000_00000000_00000010;</div><div class="line">    </div><div class="line">    // Cycles of references could cause an infinite recursion. Therefore, </div><div class="line">    // the ObjectAnalyzer keeps track of objects that were already visited</div><div class="line">    private static ArrayList&lt;Object&gt; visited = new ArrayList&lt;&gt;();</div><div class="line">    </div><div class="line">    // Suppresses default constructor, ensuring non-instantiability.</div><div class="line">    private <span class="function"><span class="title">ReflectionUtils</span></span>() &#123;&#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * Get all features of a class</div><div class="line">     * @param className</div><div class="line">     * @<span class="built_in">return</span></div><div class="line">     * @throws ClassNotFoundException</div><div class="line">     */</div><div class="line">    public static String getClass(String className) throws ClassNotFoundException &#123;</div><div class="line">        StringBuilder sb = new StringBuilder();</div><div class="line">        Class&lt;?&gt; clazz = Class.forName(className);</div><div class="line">        Class&lt;?&gt; superClazz = clazz.getSuperclass();</div><div class="line">        sb.append(clazz.getPackage().getName()).append(<span class="string">"\n\n"</span>);</div><div class="line">        sb.append(getAnnotations(clazz.getDeclaredAnnotations()));</div><div class="line">        sb.append(getModifiers(clazz.getModifiers()));</div><div class="line">        sb.append(<span class="string">"class "</span>).append(className);</div><div class="line">        <span class="keyword">if</span> (superClazz != null &amp;&amp; superClazz != Object.class)</div><div class="line">            sb.append(<span class="string">" extends "</span>).append(superClazz.getName());</div><div class="line">        </div><div class="line">        Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</div><div class="line">        <span class="keyword">if</span> (interfaces.length &gt; 0)</div><div class="line">            sb.append(<span class="string">" implements "</span>);</div><div class="line">        <span class="keyword">for</span> (int i = 0; i &lt; interfaces.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (i &gt; 0) sb.append(<span class="string">", "</span>);</div><div class="line">            sb.append(interfaces[i].getName());</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        sb.append(<span class="string">" &#123;\n"</span>);</div><div class="line">        sb.append(getConstructors(clazz)).append(<span class="string">"\n"</span>);</div><div class="line">        sb.append(getMethods(clazz)).append(<span class="string">"\n"</span>);</div><div class="line">        sb.append(getFields(clazz)).append(<span class="string">"\n"</span>);</div><div class="line">        sb.append(<span class="string">"&#125;\n"</span>);</div><div class="line">        <span class="built_in">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * Get all constructors</div><div class="line">     * @param clazz</div><div class="line">     * @<span class="built_in">return</span> String</div><div class="line">     */</div><div class="line">    public static String getConstructors(Class&lt;?&gt; clazz) &#123;</div><div class="line">        StringBuilder sb = new StringBuilder();</div><div class="line">        Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors();</div><div class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; c : constructors) &#123;</div><div class="line">            sb.append(getAnnotations(c.getDeclaredAnnotations()));</div><div class="line">            String name = c.getName();</div><div class="line">            sb.append(<span class="string">"    "</span>);</div><div class="line">            String modifiers = Modifier.toString(c.getModifiers());</div><div class="line">            <span class="keyword">if</span> (modifiers.length() &gt; 0)</div><div class="line">                sb.append(modifiers).append(<span class="string">" "</span>);</div><div class="line">            sb.append(name).append(<span class="string">"("</span>);</div><div class="line">            String paramStr = getParamTypes(c.getParameterTypes());</div><div class="line">            sb.append(paramStr).append(<span class="string">")"</span>);</div><div class="line">            sb.append(getExceptions(c.getExceptionTypes()));</div><div class="line">            sb.append(<span class="string">";\n"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private static String getExceptions(Class&lt;?&gt;[] es) &#123;</div><div class="line">        StringBuilder sb = new StringBuilder();</div><div class="line">        <span class="keyword">if</span> (isContainException() &amp;&amp; es != null &amp;&amp; es.length &gt; 0) &#123;</div><div class="line">            sb.append(<span class="string">" throws "</span>);</div><div class="line">            <span class="keyword">for</span> (int i = 0; i &lt; es.length; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (i &gt; 0) sb.append(<span class="string">", "</span>);</div><div class="line">                sb.append(es[i].getName());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * get annotation of a class, method or field</div><div class="line">     * @param as</div><div class="line">     * @<span class="built_in">return</span></div><div class="line">     */</div><div class="line">    private static String getAnnotations(Annotation[] as) &#123;</div><div class="line">        StringBuilder sb = new StringBuilder();</div><div class="line">        <span class="keyword">if</span> (isContainAnnotation() &amp;&amp; as != null &amp;&amp; as.length &gt; 0) &#123;</div><div class="line">            sb.append(<span class="string">"    @"</span>);</div><div class="line">            <span class="keyword">for</span> (int i = 0; i &lt; as.length; i++) &#123;</div><div class="line">                sb.append(as[i].annotationType().getName()).append(<span class="string">"\n"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * get parameter types</div><div class="line">     * @param paramTypes</div><div class="line">     * @<span class="built_in">return</span></div><div class="line">     */</div><div class="line">    private static String getParamTypes(Class&lt;?&gt;[] paramTypes) &#123;</div><div class="line">        StringBuilder sb = new StringBuilder();</div><div class="line">        <span class="keyword">for</span> (int i = 0; i &lt; paramTypes.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (i &gt; 0) sb.append(<span class="string">", "</span>);</div><div class="line">            sb.append(paramTypes[i].getName());</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private static String getModifiers(int modifier) &#123;</div><div class="line">        String modifiers = Modifier.toString(modifier);</div><div class="line">        <span class="keyword">if</span> (modifiers.length() &gt; 0)</div><div class="line">            <span class="built_in">return</span> modifiers + <span class="string">" "</span>;</div><div class="line">        <span class="built_in">return</span> <span class="string">""</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * Get all methods of a class</div><div class="line">     * @param clazz</div><div class="line">     * @<span class="built_in">return</span></div><div class="line">     */</div><div class="line">    public static String getMethods(Class&lt;?&gt; clazz) &#123;</div><div class="line">        <span class="built_in">return</span> getMethods(clazz, null);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * Gets the method <span class="keyword">for</span> the specified method name</div><div class="line">     * @param clazz</div><div class="line">     * @<span class="built_in">return</span></div><div class="line">     */</div><div class="line">    public static String getMethods(Class&lt;?&gt; clazz, String methodName) &#123;</div><div class="line">        StringBuilder sb = new StringBuilder();</div><div class="line">        Method[] methods = clazz.getDeclaredMethods();</div><div class="line">        <span class="keyword">for</span> (Method m : methods) &#123;</div><div class="line">            sb.append(getAnnotations(m.getDeclaredAnnotations()));</div><div class="line">            Class&lt;?&gt; <span class="built_in">return</span>Type = m.getReturnType();</div><div class="line">            String name = m.getName();</div><div class="line">            <span class="keyword">if</span> (methodName != null &amp;&amp; !methodName.equals(name))</div><div class="line">                <span class="built_in">continue</span>;</div><div class="line">            sb.append(<span class="string">"    "</span>).append(getModifiers(m.getModifiers())).append(<span class="built_in">return</span>Type.getName()).append(<span class="string">" "</span> + name + <span class="string">"("</span>);</div><div class="line">            String paramStr = getParamTypes(m.getParameterTypes());</div><div class="line">            sb.append(paramStr).append(<span class="string">")"</span>);</div><div class="line">            sb.append(getExceptions(m.getExceptionTypes()));</div><div class="line">            sb.append(<span class="string">";\n"</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * Get all fields of a class</div><div class="line">     * @param clazz</div><div class="line">     * @<span class="built_in">return</span></div><div class="line">     */</div><div class="line">    public static String getFields(Class&lt;?&gt; clazz) &#123;</div><div class="line">        StringBuilder sb = new StringBuilder();</div><div class="line">        Field[] fields = clazz.getDeclaredFields();</div><div class="line">        <span class="keyword">for</span> (Field f : fields) &#123;</div><div class="line">            Class&lt;?&gt; <span class="built_in">type</span> = f.getType();</div><div class="line">            sb.append(<span class="string">"    "</span>).append(getModifiers(f.getModifiers())).append(type.getName()).append(<span class="string">" "</span>).append(f.getName()).append(<span class="string">";\n"</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * ReflectionUtils.setFlag(ReflectionUtils.CONTAIN_EXCEPTION | ReflectionUtils.CONTAIN_ANNOTATION);</div><div class="line">     * @param state</div><div class="line">     */</div><div class="line">    public static void <span class="built_in">set</span>Flag(int state) &#123;</div><div class="line">        flag = state;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private static boolean <span class="function"><span class="title">isContainException</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> (flag &amp; CONTAIN_EXCEPTION) == CONTAIN_EXCEPTION ? <span class="literal">true</span> : <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private static boolean <span class="function"><span class="title">isContainAnnotation</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> (flag &amp; CONTAIN_ANNOTATION) == CONTAIN_ANNOTATION ? <span class="literal">true</span> : <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * Converts an object to a string representation that lists all fields.</div><div class="line">     * @param obj</div><div class="line">     * @<span class="built_in">return</span> a string with the object<span class="string">'s class name and all field names and values</span></div><div class="line">     */</div><div class="line">    public static String toString(Object obj) &#123;</div><div class="line">        if (obj == null) return "null";</div><div class="line">        if (visited.contains(obj)) return "...";</div><div class="line">        visited.add(obj);</div><div class="line">        </div><div class="line">        Class&lt;?&gt; clazz = obj.getClass();</div><div class="line">        if (clazz == String.class) return (String) obj;</div><div class="line">        if (clazz.isArray()) &#123;</div><div class="line">            String r = clazz.getComponentType() + "[]&#123;";</div><div class="line">            for (int i = 0; i &lt; Array.getLength(obj); i++) &#123;</div><div class="line">                if (i &gt; 0) r += ",";</div><div class="line">                Object val = Array.get(obj, i);</div><div class="line">                if (clazz.getComponentType().isPrimitive()) r += val;</div><div class="line">                else r += toString(val);    // recursion</div><div class="line">            &#125;</div><div class="line">            return r + "&#125;";</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // others : inspect the fields of this class and all superclasses</div><div class="line">        String r = clazz.getName();</div><div class="line">        do &#123;</div><div class="line">            r += " [";</div><div class="line">            Field[] fields = clazz.getDeclaredFields();</div><div class="line">            AccessibleObject.setAccessible(fields, true);   // uses the setAccessible convenience method to make all fields accessible</div><div class="line">            for (Field f : fields) &#123;                        // get the names and values of all fields</div><div class="line">                if (!Modifier.isStatic(f.getModifiers())) &#123;</div><div class="line">                    if (!r.endsWith("[")) r += ",";</div><div class="line">                    r += f.getName() + "=";</div><div class="line">                    try &#123;</div><div class="line">                        Class&lt;?&gt; t = f.getType();</div><div class="line">                        Object val = f.get(obj);</div><div class="line">                        if (t.isPrimitive()) r += val;</div><div class="line">                        else r += toString(val);</div><div class="line">                    &#125; catch (Exception e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            r += "]";</div><div class="line">            </div><div class="line">            clazz = clazz.getSuperclass();</div><div class="line">            if (clazz.getSuperclass() != Object.class) </div><div class="line">                clazz = null;</div><div class="line">        &#125; while (clazz != null);</div><div class="line">        </div><div class="line">        return r;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">    * This method grows an array by allocating a new array of the same type and copying all elements.</div><div class="line">    * @param a the array to grow. This can be an object array or a primitive type array</div><div class="line">    * @return a larger array that contains all elements of a.</div><div class="line">    */</div><div class="line">    public static Object copyOf(Object arr, int newLength) &#123;</div><div class="line">        Class&lt;?&gt; clazz = arr.getClass();</div><div class="line">        if (!clazz.isArray()) return null;</div><div class="line">        </div><div class="line">        Class&lt;?&gt; componentType = clazz.getComponentType();</div><div class="line">        int length = Array.getLength(arr);</div><div class="line">        Object newArray = Array.newInstance(componentType, newLength);</div><div class="line">        System.arraycopy(arr, 0, newArray, 0, Math.min(length, newLength));</div><div class="line">        return newArray;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // clear static ArrayList var(visited)</div><div class="line">    public static void clean() &#123;</div><div class="line">        visited.clear();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // unit test</div><div class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</div><div class="line">        // setFlag(CONTAIN_EXCEPTION | CONTAIN_ANNOTATION);</div><div class="line">        // System.out.println(getClass("java.lang.String"));</div><div class="line">        </div><div class="line">        /*</div><div class="line">        // 使用方式如下或者在自定义类中toString方法里添加 ReflectionUtils.clear(); return ReflectionUtils.toString(this);</div><div class="line">        ArrayList&lt;Integer&gt; squares = new ArrayList&lt;&gt;(); </div><div class="line">        for (int i = 1; i &lt;= 5; i++)</div><div class="line">            squares.add(i * i);</div><div class="line">        System.out.println(ReflectionUtils.toString(squares));</div><div class="line">        ReflectionUtils.clear();</div><div class="line">        */</div><div class="line">        </div><div class="line">        System.out.println(new Manager("xian xiaotao", 300000, 2020, 1, 1));</div><div class="line">        // com.xian.reflection.Manager [name=xian xiaotao, salary=300000.0, hireDay=2020-01-01]</div><div class="line">        // com.xian.reflection.Manager [bonus=0.0] [id=0,name=xian xiaotao,salary=300000.0,hireDay=java.time.LocalDate [year=2020,month=1,day=1]]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">java.lang</div><div class="line"></div><div class="line">public final class java.lang.String implements java.io.Serializable, java.lang.Comparable, java.lang.CharSequence &#123;</div><div class="line">    public java.lang.String([B, int, int);</div><div class="line">    public java.lang.String([B, java.nio.charset.Charset);</div><div class="line">    public java.lang.String([B, java.lang.String) throws java.io.UnsupportedEncodingException;</div><div class="line">    public java.lang.String([B, int, int, java.nio.charset.Charset);</div><div class="line">    public java.lang.String([B, int, int, java.lang.String) throws java.io.UnsupportedEncodingException;</div><div class="line">    java.lang.String([C, boolean);</div><div class="line">    public java.lang.String(java.lang.StringBuilder);</div><div class="line">    public java.lang.String(java.lang.StringBuffer);</div><div class="line">    public java.lang.String([B);</div><div class="line">    public java.lang.String([I, int, int);</div><div class="line">    public java.lang.String();</div><div class="line">    public java.lang.String([C);</div><div class="line">    public java.lang.String(java.lang.String);</div><div class="line">    public java.lang.String([C, int, int);</div><div class="line">    @java.lang.Deprecated</div><div class="line">    public java.lang.String([B, int);</div><div class="line">    @java.lang.Deprecated</div><div class="line">    public java.lang.String([B, int, int, int);</div><div class="line"></div><div class="line">    public boolean equals(java.lang.Object);</div><div class="line">    public java.lang.String toString();</div><div class="line">    public int <span class="built_in">hash</span>Code();</div><div class="line">    public volatile int compareTo(java.lang.Object);</div><div class="line">    public int compareTo(java.lang.String);</div><div class="line">    public int indexOf(java.lang.String, int);</div><div class="line">    static int indexOf([C, int, int, java.lang.String, int);</div><div class="line">    static int indexOf([C, int, int, [C, int, int, int);</div><div class="line">    public int indexOf(int);</div><div class="line">    public int indexOf(java.lang.String);</div><div class="line">    public int indexOf(int, int);</div><div class="line">    public static java.lang.String valueOf(char);</div><div class="line">    public static java.lang.String valueOf(java.lang.Object);</div><div class="line">    public static java.lang.String valueOf(boolean);</div><div class="line">    public static java.lang.String valueOf([C, int, int);</div><div class="line">    public static java.lang.String valueOf([C);</div><div class="line">    public static java.lang.String valueOf(double);</div><div class="line">    public static java.lang.String valueOf(<span class="built_in">float</span>);</div><div class="line">    public static java.lang.String valueOf(long);</div><div class="line">    public static java.lang.String valueOf(int);</div><div class="line">    private static void checkBounds([B, int, int);</div><div class="line">    public int length();</div><div class="line">    public boolean isEmpty();</div><div class="line">    public char charAt(int);</div><div class="line">    public int codePointAt(int);</div><div class="line">    public int codePointBefore(int);</div><div class="line">    public int codePointCount(int, int);</div><div class="line">    public int offsetByCodePoints(int, int);</div><div class="line">    public void getChars(int, int, [C, int);</div><div class="line">    void getChars([C, int);</div><div class="line">    public [B getBytes();</div><div class="line">    public [B getBytes(java.lang.String) throws java.io.UnsupportedEncodingException;</div><div class="line">    @java.lang.Deprecated</div><div class="line">    public void getBytes(int, int, [B, int);</div><div class="line">    public [B getBytes(java.nio.charset.Charset);</div><div class="line">    public boolean contentEquals(java.lang.StringBuffer);</div><div class="line">    public boolean contentEquals(java.lang.CharSequence);</div><div class="line">    private boolean nonSyncContentEquals(java.lang.AbstractStringBuilder);</div><div class="line">    public boolean equalsIgnoreCase(java.lang.String);</div><div class="line">    public int compareToIgnoreCase(java.lang.String);</div><div class="line">    public boolean regionMatches(int, java.lang.String, int, int);</div><div class="line">    public boolean regionMatches(boolean, int, java.lang.String, int, int);</div><div class="line">    public boolean startsWith(java.lang.String);</div><div class="line">    public boolean startsWith(java.lang.String, int);</div><div class="line">    public boolean endsWith(java.lang.String);</div><div class="line">    private int indexOfSupplementary(int, int);</div><div class="line">    public int lastIndexOf(int, int);</div><div class="line">    static int lastIndexOf([C, int, int, [C, int, int, int);</div><div class="line">    static int lastIndexOf([C, int, int, java.lang.String, int);</div><div class="line">    public int lastIndexOf(java.lang.String, int);</div><div class="line">    public int lastIndexOf(int);</div><div class="line">    public int lastIndexOf(java.lang.String);</div><div class="line">    private int lastIndexOfSupplementary(int, int);</div><div class="line">    public java.lang.String substring(int);</div><div class="line">    public java.lang.String substring(int, int);</div><div class="line">    public java.lang.CharSequence subSequence(int, int);</div><div class="line">    public java.lang.String concat(java.lang.String);</div><div class="line">    public java.lang.String replace(char, char);</div><div class="line">    public java.lang.String replace(java.lang.CharSequence, java.lang.CharSequence);</div><div class="line">    public boolean matches(java.lang.String);</div><div class="line">    public boolean contains(java.lang.CharSequence);</div><div class="line">    public java.lang.String replaceFirst(java.lang.String, java.lang.String);</div><div class="line">    public java.lang.String replaceAll(java.lang.String, java.lang.String);</div><div class="line">    public [Ljava.lang.String; split(java.lang.String, int);</div><div class="line">    public [Ljava.lang.String; split(java.lang.String);</div><div class="line">    public static transient java.lang.String join(java.lang.CharSequence, [Ljava.lang.CharSequence;);</div><div class="line">    public static java.lang.String join(java.lang.CharSequence, java.lang.Iterable);</div><div class="line">    public java.lang.String toLowerCase(java.util.Locale);</div><div class="line">    public java.lang.String toLowerCase();</div><div class="line">    public java.lang.String toUpperCase();</div><div class="line">    public java.lang.String toUpperCase(java.util.Locale);</div><div class="line">    public java.lang.String trim();</div><div class="line">    public [C toCharArray();</div><div class="line">    public static transient java.lang.String format(java.util.Locale, java.lang.String, [Ljava.lang.Object;);</div><div class="line">    public static transient java.lang.String format(java.lang.String, [Ljava.lang.Object;);</div><div class="line">    public static java.lang.String copyValueOf([C, int, int);</div><div class="line">    public static java.lang.String copyValueOf([C);</div><div class="line">    public native java.lang.String intern();</div><div class="line"></div><div class="line">    private final [C value;</div><div class="line">    private int <span class="built_in">hash</span>;</div><div class="line">    private static final long serialVersionUID;</div><div class="line">    private static final [Ljava.io.ObjectStreamField; serialPersistentFields;</div><div class="line">    public static final java.util.Comparator CASE_INSENSITIVE_ORDER;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Relfect</title>
      <link href="/1900/01/08/01%20JAVA/08%20Java%20Relfect/"/>
      <url>/1900/01/08/01%20JAVA/08%20Java%20Relfect/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>相关文章：<br><a href="https://xianxiaotao.github.io/1900/01/08/01%20JAVA/08%20Java%20Relfect/" target="_blank" rel="external">Java Relfect</a><br><a href="https://xianxiaotao.github.io/1900/01/09/01%20JAVA/09%20Java%20RelfectUtils/" target="_blank" rel="external">Java RelfectUtils</a><br><a href="https://xianxiaotao.github.io/1900/01/10/01%20JAVA/10%20%E5%8F%8D%E5%B0%84%E4%B8%80%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%91%A8%E8%BE%B9%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/" target="_blank" rel="external">反射一：基本类周边信息获取</a><br><a href="https://xianxiaotao.github.io/1900/01/11/01%20JAVA/11%20%E5%8F%8D%E5%B0%84%E4%BA%8C%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%91%A8%E8%BE%B9%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/" target="_blank" rel="external">反射二：泛型相关周边信息获取</a><br><a href="https://xianxiaotao.github.io/1900/01/12/01%20JAVA/12%20%E5%8F%8D%E5%B0%84%E4%B8%89%EF%BC%9A%E7%B1%BB%E5%86%85%E9%83%A8%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/" target="_blank" rel="external">反射三：类内部信息获取</a></p></blockquote><h3 id="一、使用反射机制步骤如下"><a href="#一、使用反射机制步骤如下" class="headerlink" title="一、使用反射机制步骤如下"></a>一、使用反射机制步骤如下</h3><hr><p>使用反射机制步骤如下</p><ol><li>导入 java.lang.relfect 包</li><li>获得你想操作的类的 java.lang.Class 对象</li><li>调用诸如 getDeclaredMethods 的方法</li><li>使用反射API 来操作这些信息</li></ol><p>获取class对象的3种方法</p><ol><li><p>已经得到一个类的实例，可以使用如下方式来得到Class对象：<br>Class c = 对象名.getClass();</p></li><li><p>如果在编译期知道类的名字，可以使用如下方法：<br>Class c = java.lang.String.class;<br>Class c = Integer.TYPE;</p></li><li><p>如果类名在编译期不知道, 但是在运行期可以获得, 可以使用下面的方法：<br>Class c = Class.forName(str);  // 注意:str是类的全路径</p></li></ol><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class TestClass &#123;</div><div class="line">    static &#123;</div><div class="line">        System.out.println(&quot;static&quot;);</div><div class="line">    &#125;</div><div class="line">    private String name = &quot;先小涛&quot;;</div><div class="line">    private String address = &quot;南京&quot;;</div><div class="line">    public void print() &#123;</div><div class="line">        System.out.println(&quot;name:&quot; + name + &quot; ,address:&quot; + address);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试代码</div><div class="line">private void test() throws Exception &#123;</div><div class="line">    TestClass testObj = new TestClass();</div><div class="line">    // 同过反射机制得到类的对象</div><div class="line">    Class &lt;? extends TestClass&gt; clazzClass = testObj.getClass();</div><div class="line">    System.out.println(&quot;clazzClass:&quot; + clazzClass);</div><div class="line">    // 调用无参构造方法，创建一个对象</div><div class="line">    TestClass testObj2 = (TestClass) clazzClass.newInstance();</div><div class="line">    System.out.println(&quot;gctObj==gctOb2 :&quot; + (testObj == testObj2));</div><div class="line">    System.out.println(&quot;gctObj.getClass() == gctOb2.getClass() :&quot; +</div><div class="line">            (testObj.getClass() == testObj2.getClass()));</div><div class="line">    testObj2.print();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样获得 Class 类对象的方法，其实是利用反射 API 把指定字符串的类加载到内存中，所以也叫类加载器加载方法。这样的话，它会把该类的静态方法和静态属性，以及静态代码全部加载到内存中。但这时候，对象还没有产生。所以为什么静态方法不能访问非静态属性和方法。因为静态方法和属性产生的时机在非静态属性和方法之前。</p><p>在进行 testObj.getClass() 的时候，实际上是对指定类进行类加载，这时候，会把静态属性、方法以及静态代码块都加载到内存中。所以这时候会打印出”静态代码块运行”。但这时候，对象却还没有产生。所以”构造方法运行”这几个字不会打印。当执行 clazzClass.newInstance() 的时候，就是利用反射机制将 Class 对象生成一个该类的一个实例。这时候对象就产生了。所以打印”构造方法运行”。当执行到 TestClass testObj = new TestClass(); 语句时，又生成了一个对象。但这时候类已经加载完毕，静态的东西已经加载到内存中，而静态代码块只执行一次，所以不用再去加载类，所以只会打印”构造方法运行”，而”静态代码块运行”不会打印。</p><p>反射机制不但可以例出该类对象所拥有的方法和属性，还可以获得该类的构造方法及通过构造方法获得实例。也可以动态的调用这个实例的成员方法。</p><h3 id="二、获得其他类中的全部构造函数"><a href="#二、获得其他类中的全部构造函数" class="headerlink" title="二、获得其他类中的全部构造函数"></a>二、获得其他类中的全部构造函数</h3><hr><p>Java 通过反射机制获取获得其他类中的全部构造函数，步骤所用方法如下：</p><ol><li>forName()：返回给定串名相应的Class对象。</li><li>getConstructors()：返回当前Class对象表示的类的所有公有构造子对象数组。</li></ol><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; testClazz = null;</div><div class="line">try &#123;</div><div class="line">    testClazz = Class.forName(&quot;java.lang.String&quot;);</div><div class="line">&#125; catch (Exception e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div><div class="line">Constructor&lt;?&gt; cons[] = testClazz.getConstructors();</div><div class="line">for (int i = 0; i &lt; cons.length; i++) &#123;</div><div class="line">    int mo = cons[i].getModifiers();</div><div class="line">    StringBuilder sb = new StringBuilder();</div><div class="line">    // 构造函数修饰符</div><div class="line">    sb.append(Modifier.toString(mo)).append(&quot; &quot;);</div><div class="line">    // 构造函数名</div><div class="line">    sb.append(cons[i].getName()).append(&quot;(&quot;);</div><div class="line">    // 构造函数参数</div><div class="line">    Class&lt;?&gt; p[] = cons[i].getParameterTypes();</div><div class="line">    for (int j = 0; j &lt; p.length; ++j) &#123;</div><div class="line">        sb.append(p[j].getName()).append(&quot; arg&quot;).append(j);</div><div class="line">        if (j &lt; p.length - 1) &#123;</div><div class="line">            sb.append(&quot;,&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    sb.append(&quot;)&#123;&#125;&quot;);</div><div class="line">    print(sb.toString());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-36361cbcd9b55427.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="三、实例化一个类的对象"><a href="#三、实例化一个类的对象" class="headerlink" title="三、实例化一个类的对象"></a>三、实例化一个类的对象</h3><hr><p>Java 通过反射机制实例化一个类的对象，步骤所用方法如下：</p><ol><li>forName() 返回给定串名相应的Class对象。</li><li>newInstance() 创建类的新实例。</li><li>getConstructors() 返回当前Class对象表示的类的所有公有构造子对象数组。</li><li>getName()   返回Class对象表示的类型(类、接口、数组或基类型)的完整路径名字符串。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">class User &#123;</div><div class="line">    private int age;</div><div class="line">    private String name;</div><div class="line">    public User() &#123;</div><div class="line">        super();</div><div class="line">    &#125;</div><div class="line">    public User(String name) &#123;</div><div class="line">        super();</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    public User(int age, String name) &#123;</div><div class="line">        super();</div><div class="line">        this.age = age;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    public int getAge() &#123;</div><div class="line">        return age;</div><div class="line">    &#125;</div><div class="line">    public void setAge(int age) &#123;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;User [age=&quot; + age + &quot;, name=&quot; + name + &quot;]&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试代码</div><div class="line">private void test() throws Exception &#123;</div><div class="line">    Class&lt;?&gt; class1 = Class.forName(&quot;com.xxt.xtest.User&quot;);</div><div class="line">    // 第一种方法，实例化默认构造方法，调用set赋值</div><div class="line">    User user = (User) class1.newInstance();</div><div class="line">    user.setAge(20);</div><div class="line">    user.setName(&quot;先小涛&quot;);</div><div class="line">    print(user);</div><div class="line">    // 结果 User [age=20, name=先小涛]</div><div class="line"></div><div class="line">    // 第二种方法 取得全部的构造函数 使用构造函数赋值</div><div class="line">    Constructor&lt;?&gt; cons[] = class1.getConstructors();</div><div class="line">    // 查看每个构造方法需要的参数</div><div class="line">    for (int i = 0; i &lt; cons.length; i++) &#123;</div><div class="line">        Class&lt;?&gt; clazzs[] = cons[i].getParameterTypes();</div><div class="line">        print(&quot;cons[&quot; + i + &quot;] (&quot;);</div><div class="line">        for (int j = 0; j &lt; clazzs.length; j++) &#123;</div><div class="line">            if (j == clazzs.length - 1)</div><div class="line">                print(clazzs[j].getName());</div><div class="line">            else</div><div class="line">                print(clazzs[j].getName() + &quot;,&quot;);</div><div class="line">        &#125;</div><div class="line">        print(&quot;)&quot;);</div><div class="line">    &#125;</div><div class="line">    // 结果</div><div class="line">    // cons[0] ()</div><div class="line">    // cons[1] (int,java.lang.String)</div><div class="line">    // cons[2] (java.lang.String)</div><div class="line"></div><div class="line">    user = (User) cons[2].newInstance(&quot;先小涛&quot;);</div><div class="line">    print(user);</div><div class="line">    // 结果 User [age=0, name=先小涛]</div><div class="line">    user = (User) cons[1].newInstance(20, &quot;先小涛&quot;);</div><div class="line">    print(user);</div><div class="line">    // 结果 User [age=20, name=先小涛]</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="四、获取某个类的全部属性"><a href="#四、获取某个类的全部属性" class="headerlink" title="四、获取某个类的全部属性"></a>四、获取某个类的全部属性</h3><hr><p>Java反射获取某个类的全部属性,步骤所用方法如下：</p><ol><li>forName()：返回给定串名相应的 Class 对象。</li><li>getDeclaredFields()：返回当前 Class 对象表示的类或接口的所有已说明的域对象数组。</li><li>getFields()：返回当前 Class 对象表示的类或接口的所有可访问的公有域对象数组。</li><li>getModifiers()：返回该类或接口的 Java 语言修改器代码。</li><li>getName()：返回 Class 对象表示的类型(类、接口、数组或基类型)的完整路径名字符串。</li></ol><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">private void test() throws Exception &#123;</div><div class="line">    Class&lt;?&gt; clazz = Class.forName(&quot;com.xxt.xtest.User&quot;);</div><div class="line">    System.out.println(&quot;===============本类属性===============&quot;);</div><div class="line">    // 取得本类的全部属性</div><div class="line">    Field[] field = clazz.getDeclaredFields();</div><div class="line">    for (int i = 0; i &lt; field.length; i++) &#123;</div><div class="line">        // 权限修饰符</div><div class="line">        int mo = field[i].getModifiers();</div><div class="line">        String prev = Modifier.toString(mo);</div><div class="line">        // 属性类型</div><div class="line">        Class&lt;?&gt; type = field[i].getType();</div><div class="line">        System.out.println(prev + &quot; &quot; + type.getName() + &quot; &quot; + field[i].getName() + &quot;;&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    System.out.println(&quot;==========实现的接口或者父类的属性==========&quot;);</div><div class="line">    // 取得实现的接口或者父类的属性</div><div class="line">    Field[] filed1 = clazz.getFields();</div><div class="line">    for (int j = 0; j &lt; filed1.length; j++) &#123;</div><div class="line">        // 权限修饰符</div><div class="line">        int mo = filed1[j].getModifiers();</div><div class="line">        String prev = Modifier.toString(mo);</div><div class="line">        // 属性类型</div><div class="line">        Class&lt;?&gt; type = filed1[j].getType();</div><div class="line">        System.out.println(prev + &quot; &quot; + type.getName() + &quot; &quot; + filed1[j].getName() + &quot;;&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>输出结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a9bee7318772e28a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="五、操作某个类的属性"><a href="#五、操作某个类的属性" class="headerlink" title="五、操作某个类的属性"></a>五、操作某个类的属性</h3><hr><p>Java 通过反射机制操作某个类的属性，步骤所用方法如下：</p><ol><li>forName()：返回给定串名相应的Class对象。</li><li>getDeclaredField()：返回当前 Class 对象表示的类或接口的指定已说明的一个域对象。</li></ol><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private void test() throws Exception &#123;</div><div class="line">    Class&lt;?&gt; clazz = Class.forName(&quot;com.xxt.xtest.User&quot;);</div><div class="line">    Object obj = clazz.newInstance();</div><div class="line">    // 可以直接对 private 的属性赋值</div><div class="line">    Field field = clazz.getDeclaredField(&quot;name&quot;);</div><div class="line">    field.setAccessible(true);</div><div class="line">    field.set(obj, &quot;Java 反射机制&quot;);</div><div class="line">    print(field.get(obj));</div><div class="line">    // 输出结果：Java 反射机制</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="六、获取某个类的全部方法"><a href="#六、获取某个类的全部方法" class="headerlink" title="六、获取某个类的全部方法"></a>六、获取某个类的全部方法</h3><hr><p>Java 通过反射机制获取某个类的全部方法，步骤所用方法如下：</p><ol><li>forName()：返回给定串名相应的Class对象。</li><li>getMethods()：返回当前Class对象表示的类或接口的所有公有成员方法对象数组，包括已声明的和从父类继承的方法。</li><li>getModifiers()：返回该类或接口的Java语言修改器代码。</li><li>getName()：返回Class对象表示的类型(类、接口、数组或基类型)的完整路径名字符串。</li></ol><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">private void test() throws Exception &#123;</div><div class="line">    Class&lt;?&gt; clazz = Class.forName(&quot;com.xxt.xtest.User&quot;);</div><div class="line">    Method methods[] = clazz.getMethods();</div><div class="line">    StringBuilder sb = new StringBuilder();</div><div class="line">    for (Method method : methods) &#123;</div><div class="line">        Class&lt;?&gt; returnType = method.getReturnType();</div><div class="line">        Class&lt;?&gt; paras[] = method.getParameterTypes();</div><div class="line">        int temp = method.getModifiers();</div><div class="line">        sb.append(Modifier.toString(temp)).append(&quot; &quot;);</div><div class="line">        sb.append(returnType.getName()).append(&quot; &quot;);</div><div class="line">        sb.append(method.getName()).append(&quot; &quot;).append(&quot;(&quot;);</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; paras.length; ++i) &#123;</div><div class="line">            sb.append(paras[i].getName()).append(&quot; arg&quot;).append(i);</div><div class="line">            if (i &lt; paras.length - 1) sb.append(&quot;, &quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Class&lt;?&gt; exceptions[] = method.getExceptionTypes();</div><div class="line">        if (exceptions.length &gt; 0) &#123;</div><div class="line">            sb.append(&quot;) throws &quot;);</div><div class="line">            for (int j = 0; j &lt; exceptions.length; ++j) &#123;</div><div class="line">                sb.append(exceptions[j].getName()).append(&quot; &quot;);</div><div class="line">                if (j &lt; exceptions.length - 1) &#123;</div><div class="line">                    sb.append(&quot;, &quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            sb.append(&quot;)&quot;);</div><div class="line">        &#125;</div><div class="line">        sb.append(&quot;\n&quot;);</div><div class="line">    &#125;</div><div class="line">    print(sb);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4baef1cfcb810581.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="七、调用某个类的方法"><a href="#七、调用某个类的方法" class="headerlink" title="七、调用某个类的方法"></a>七、调用某个类的方法</h3><hr><p>Java通过反射机制调用某个类的方法，步骤所用方法如下：</p><ol><li>forName()：返回给定串名相应的 Class 对象。</li><li>getMethod()：返回当前 Class 对象表示的类或接口的指定的公有成员方法对象。</li><li>newInstance()：创建类的新实例。</li></ol><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class TestReflect &#123;</div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        Class&lt;?&gt; clazz = Class.forName(&quot;com.xxt.xtest.TestReflect&quot;);</div><div class="line">        // 调用 TestReflect 类中的 reflect1 方法</div><div class="line">        Method method = clazz.getMethod(&quot;reflect1&quot;);</div><div class="line">        method.invoke(clazz.newInstance());</div><div class="line">        // Java 反射机制 - 调用某个类的方法1.</div><div class="line">        // 调用 TestReflect 的 reflect2 方法</div><div class="line">        method = clazz.getMethod(&quot;reflect2&quot;, int.class, String.class);</div><div class="line">        method.invoke(clazz.newInstance(), 20, &quot;张三&quot;);</div><div class="line">        // Java 反射机制 - 调用某个类的方法2.</div><div class="line">        // age -&gt; 20. name -&gt; 张三</div><div class="line">    &#125;</div><div class="line">    public void reflect1() &#123;</div><div class="line">        System.out.println(&quot;Java 反射机制 - 调用某个类的方法1.&quot;);</div><div class="line">    &#125;</div><div class="line">    public void reflect2(int age, String name) &#123;</div><div class="line">        System.out.println(&quot;Java 反射机制 - 调用某个类的方法2.&quot;);</div><div class="line">        System.out.println(&quot;age -&gt; &quot; + age + &quot;. name -&gt; &quot; + name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="八、取得并修改数组的大小等信息"><a href="#八、取得并修改数组的大小等信息" class="headerlink" title="八、取得并修改数组的大小等信息"></a>八、取得并修改数组的大小等信息</h3><hr><p>Java 通过反射机制取得并修改数组的大小等信息，步骤所用方法如下：</p><ol><li>getClass()：取得该类已经被实例化了的对象的该类的引用。</li><li>getComponentType()：如果当前类表示一个数组，则返回表示该数组组件的Class对象，否则返回null。</li><li>newInstance()：创建类的新实例。</li></ol><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class TestReflect &#123;</div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        int[] temp = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;;</div><div class="line">        int[] newTemp = (int[]) arrayInc(temp, 15);</div><div class="line">        print(newTemp);</div><div class="line">        String[] atr = &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;;</div><div class="line">        String[] str1 = (String[]) arrayInc(atr, 8);</div><div class="line">        print(str1);</div><div class="line">    &#125;</div><div class="line">    // 修改数组大小</div><div class="line">    public static Object arrayInc(Object obj, int len) &#123;</div><div class="line">        Class&lt;?&gt; arr = obj.getClass().getComponentType();</div><div class="line">        Object newArr = Array.newInstance(arr, len);</div><div class="line">        int co = Array.getLength(obj);</div><div class="line">        System.arraycopy(obj, 0, newArr, 0, co);</div><div class="line">        return newArr;</div><div class="line">    &#125;</div><div class="line">    // 打印</div><div class="line">    public static void print(Object obj) &#123;</div><div class="line">        Class&lt;?&gt; c = obj.getClass();</div><div class="line">        if (!c.isArray()) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;数组长度为： &quot; + Array.getLength(obj));</div><div class="line">        for (int i = 0; i &lt; Array.getLength(obj); i++) &#123;</div><div class="line">            System.out.print(Array.get(obj, i) + &quot; &quot;);</div><div class="line">        &#125;</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-12ca2a229b879b08.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>参考链接：<a href="http://www.51gjie.com/java/803.html" target="_blank" rel="external">反射技术</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Annotation</title>
      <link href="/1900/01/07/01%20JAVA/07%20Java%20Annotation/"/>
      <url>/1900/01/07/01%20JAVA/07%20Java%20Annotation/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="一、什么是注解"><a href="#一、什么是注解" class="headerlink" title="一、什么是注解"></a>一、什么是注解</h3><hr><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。</p><p>Java 注解用于为 Java 程序提供元数据。作为元数据，注解不直接影响代码的执行，但也有一些注解实际上可以用于这一目的。</p><p>什么是元数据，即一种描述数据的数据。所以可以说注解是描述源代码的数据。简单理解注解可以看出一个个标签，用来标记你的代码，是一种应用于类，方法，参数，变量，构造器及包的一种特殊修饰符。</p><p>注解和 class、interface 一样也是一种类型，通过 @interface 定义。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Documented</div><div class="line">@Target(ElementType.TYPE)</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">public @interface TestAnnotation &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@TestAnnotation</div><div class="line">public class Test &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="二、元注解"><a href="#二、元注解" class="headerlink" title="二、元注解"></a>二、元注解</h3><hr><p>元注解就是注解到注解上的注解，或者说元注解是一种基本注解，它能用来注解其他注解。我们可以将元注解看成一种特殊的修饰符，用来解释说明注解，它是注解的元数据。例如上例中的 @Retention 等。</p><p>元注解一共用 5 种：@Retention、@Documented、@Target、@Inherited、@Repeatable。</p><h4 id="1、-Retention"><a href="#1、-Retention" class="headerlink" title="1、@Retention"></a>1、@Retention</h4><p>Retention 意为保留期，@Retention 用来解释说明一个注解的存活周期。@Retention 取值：</p><ul><li>RetentionPolicy.SOURCE<br>注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。</li><li>RetentionPolicy.CLASS<br>注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。</li><li>RetentionPolicy.RUNTIME<br>注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。</li></ul><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Retention(RetentionPolicy.CLASS)</div><div class="line">public @interface TestAnnotation &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="2、-Documented"><a href="#2、-Documented" class="headerlink" title="2、@Documented"></a>2、@Documented</h4><p>用于描述其它类型的 annotation 应该被作为被标注的程序成员的公共 API，因此可以被例如 javadoc 此类的工具文档化。Documented 是一个标记注解，没有成员。ANDROID 提供了的 NonNull 注解的源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Documented</div><div class="line">@Retention(CLASS)</div><div class="line">@Target(&#123;METHOD, PARAMETER, FIELD, LOCAL_VARIABLE, ANNOTATION_TYPE, PACKAGE&#125;)</div><div class="line">public @interface NonNull &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="3、-Target"><a href="#3、-Target" class="headerlink" title="3、@Target"></a>3、@Target</h4><p>指定注解应用的地方，用来限定注解的应用场景（类，方法，参数等等）。不使用 @Target 注解则默认不限制。其取值如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">取值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">ElementType.ANNOTATION_TYPE</td><td style="text-align:left">可以给一个注解进行注解</td></tr><tr><td style="text-align:left">ElementType.CONSTRUCTOR</td><td style="text-align:left">可以给构造方法进行注解</td></tr><tr><td style="text-align:left">ElementType.FIELD</td><td style="text-align:left">可以给属性进行注解</td></tr><tr><td style="text-align:left">ElementType.LOCAL_VARIABLE</td><td style="text-align:left">可以给局部变量进行注解</td></tr><tr><td style="text-align:left">ElementType.METHOD</td><td style="text-align:left">可以给方法进行注解</td></tr><tr><td style="text-align:left">ElementType.PACKAGE</td><td style="text-align:left">可以给一个包进行注解</td></tr><tr><td style="text-align:left">ElementType.PARAMETER</td><td style="text-align:left">可以给一个方法内的参数进行注解</td></tr><tr><td style="text-align:left">ElementType.TYPE</td><td style="text-align:left">可以给一个类型进行注解，比如类、接口、枚举</td></tr></tbody></table></div><p>示例：ANDROID 中的 @LayoutRes 注解，限定为布局资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public void setContentView(@LayoutRes int layoutResID) &#123;</div><div class="line">    getDelegate().setContentView(layoutResID);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Documented</div><div class="line">@Retention(CLASS)</div><div class="line">@Target(&#123;METHOD, PARAMETER, FIELD, LOCAL_VARIABLE&#125;)</div><div class="line">public @interface LayoutRes &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="4、-Inherited"><a href="#4、-Inherited" class="headerlink" title="4、@Inherited"></a>4、@Inherited</h4><p>标记这个注解是继承于哪个注解类。只能被用来标注 “Annotation 类型”，它所标注的 Annotation 具有继承性。当一个超类被 @Inherited 注解的注解（A 注解）进行过注解的话，如果它的子类没有被如何其他注解进行注解，那么这个子类就继承了超类的注解（A 注解）。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@Retention(RetentionPolicy.CLASS)</div><div class="line">@Inherited</div><div class="line">public @interface TestAnnotation &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@TestAnnotation</div><div class="line">public class TestA &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class TestB extends TestA&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>TestAnnotation 被 @Retention 注解，类 TestA 被 @TestAnnotation 注解，类 TestB 继承类 TestA，那么类 TestB 也拥有 TestAnnotation注解。</p><blockquote><p>@Inherited annotation 类型是被标注过的 class 的子类所继承。类并不从它所实现的接口继承 annotation，方法并不从它所重载的方法继承 annotation。</p></blockquote><h4 id="5、-Repeatable"><a href="#5、-Repeatable" class="headerlink" title="5、@Repeatable"></a>5、@Repeatable</h4><p>@Repeatable 是自然可重复的意思，这是 Java 8 加进来的新特性。<br>在需要对同一种注解多次使用时，往往需要借助 @Repeatable。示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@Target(ElementType.TYPE)</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">public @interface Roles &#123;</div><div class="line">    Role[] value();</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Repeatable(Roles.class)</div><div class="line">public @interface Role &#123;</div><div class="line">    String role() default &quot;&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Role(role=&quot;husband&quot;)</div><div class="line">@Role(role=&quot;father&quot;)</div><div class="line">@Role(role=&quot;son&quot;)</div><div class="line">public class Person &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面的代码 @Repeatable 注解了 Role ，@Repeatable 后面括号中的类相当于一个容器注解。</p><p>什么是容器注解？本身也是注解，用来存放其他注解。按照规定，它里面必须要有一个 value 的属性，属性类型是一个被 @Repeatable 注解过的注解数组。</p><p>@Role(role=”husband”)，role=”husband” 表示给 Role 这个注解的 role 属性赋值，关于注解的属性下面会说明。Person 类需要多次使用 @Role 注解，所以这里使用 @Repeatable 注解 @Role。</p><p>测试一下注解效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Annotation[] annotations = Person.class.getAnnotations();</div><div class="line">System.out.println(annotations.length);</div><div class="line">Roles p1 = (Roles) annotations[0];</div><div class="line">for (Role t : p1.value()) &#123;</div><div class="line">    System.out.println(t.role());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>打印如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">husband</div><div class="line">father</div><div class="line">son</div></pre></td></tr></table></figure></p><h3 id="三、注解的属性"><a href="#三、注解的属性" class="headerlink" title="三、注解的属性"></a>三、注解的属性</h3><hr><p>注解的属性也叫成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无参的方法”的形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。</p><p>注解的<strong><em>属性类型</em></strong>必须以下几种：8 种基本类型（byte、boolean、char、short、int、long、float、double）和 String、Enum、Class、annotation 类型，以及这些类型的数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public @interface TestAnnotation &#123;</div><div class="line">    int id();</div><div class="line">    String msg();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面代码定义 TestAnnotation 这个注解有 id 和 msg 两个属性。在使用的时候我们需要给它们赋值。</p><p><strong><em>赋值方式</em></strong>：括号内以 value=“” 的形式赋值，多个属性以逗号隔开。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@TestAnnotation(id = 1, msg = &quot;注解测试&quot;)</div><div class="line">public class Test &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注解中可以设置默认值，默认值用 default 关键字指定。使用注解时对于指定了默认值的属性，如果不需要修改，可以不赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public @interface TestAnnotation &#123;</div><div class="line">    int id() default 0;</div><div class="line">    String msg() default &quot;msg&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 使用默认值</div><div class="line">@TestAnnotation()</div><div class="line">public class Test &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当一个注解只有一个属性且属性名为 value 时，使用此注解可以省略括号内的属性名直接赋值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public @interface TestAnnotation &#123;</div><div class="line">    String value();</div><div class="line">&#125;</div><div class="line"></div><div class="line">@TestAnnotation(&quot;1&quot;)</div><div class="line">public class Test &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果注解没有属性，括号也可以省略：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public @interface TestAnnotation &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@TestAnnotation</div><div class="line">public class Test &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="四、JDK-内置注解"><a href="#四、JDK-内置注解" class="headerlink" title="四、JDK 内置注解"></a>四、JDK 内置注解</h3><hr><p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中，外加 JDK 7 以后新增 3个，共 10 个。分别是：@Override、@Deprecated、@SuppressWarnings；@Retention、@Documented、@Target、@Inherited；@SafeVarargs、@FunctionalInterface、@Repeatable。</p><div class="table-container"><table><thead><tr><th>取值</th><th>描述</th></tr></thead><tbody><tr><td></td><td><strong><em>作用在代码的注解：</em></strong></td></tr><tr><td>@Override</td><td>检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</td></tr><tr><td>@Deprecated</td><td>标记过时元素的注解，用来标识类，方法或者变量已过时，不建议使用。调用过时方法时编译器会提醒。</td></tr><tr><td>@SuppressWarnings</td><td>指示编译器去忽略注解中声明的警告。</td></tr><tr><td></td><td><strong><em>作用在其他注解的注解：</em></strong></td></tr><tr><td>@Retention</td><td>标识这个注解怎么保存，是只在代码中，还是编入 class 文件中，或者是在运行时可以通过反射访问。</td></tr><tr><td>@Documented</td><td>标记这些注解是否包含在用户文档中。</td></tr><tr><td>@Target</td><td>标记这个注解应该是哪种 Java 成员。</td></tr><tr><td>@Inherited</td><td>标记这个注解是继承于哪个注解类(默认注解没有继承于任何子类)</td></tr><tr><td></td><td><strong><em>从 JAVA 7 开始新增：</em></strong></td></tr><tr><td>@SafeVarargs</td><td>JAVA 7，参数安全类型注解。它的目的是提醒开发者不要用参数做一些不安全的操作，它的存在会阻止编译器产生 unchecked 这样的警告。</td></tr><tr><td>@FunctionalInterface</td><td>JAVA 8，标识一个匿名函数或函数式接口。</td></tr><tr><td>@Repeatable</td><td>JAVA 8，标识某注解可以在同一个声明上使用多次。</td></tr></tbody></table></div><h3 id="五、注解的提取与应用"><a href="#五、注解的提取与应用" class="headerlink" title="五、注解的提取与应用"></a>五、注解的提取与应用</h3><hr><p>注解通过反射获取，通过 Class 对象的方法获取注解。常用的三个方法：<br><strong>isAnnotationPresent</strong><br>方法判断是否应用了某个注解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) &#123;...&#125;</div></pre></td></tr></table></figure></p><p><strong>getAnnotation</strong><br>方法获取指定类型的注解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) &#123;...&#125;</div></pre></td></tr></table></figure></p><p><strong>getAnnotations</strong><br>方法获取注解到当前元素上的所有注解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public Annotation[] getAnnotations() &#123;...&#125;</div></pre></td></tr></table></figure></p><p>以运行时注解为例：获取下面 TestAnnotation 注解的 name 属性内容，可以如下获取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">@Target(&#123;ElementType.TYPE, ElementType.FIELD&#125;)</div><div class="line">@interface TestAnnotation &#123;</div><div class="line">    String name();</div><div class="line">&#125;</div><div class="line"></div><div class="line">@TestAnnotation(name = &quot;先小涛&quot;)</div><div class="line">public class Person &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试</div><div class="line">private void test() &#123;</div><div class="line">    boolean hasAnnotation = Person.class.isAnnotationPresent(TestAnnotation.class);</div><div class="line">    if (hasAnnotation)&#123;</div><div class="line">        TestAnnotation annotation = Person.class.getAnnotation(TestAnnotation.class);</div><div class="line">        Log.d(TAG, annotation.name());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>打印结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2020-03-09 02:42:35.379 26182-26182/com.xxt.xtest D/xian: 先小涛</div></pre></td></tr></table></figure></p><p>方法和属性也可以借助返回来获取注解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">@interface TestAnnotation &#123;</div><div class="line">    String msg();</div><div class="line">&#125;</div><div class="line"></div><div class="line">@TestAnnotation(msg=&quot;注解类&quot;)</div><div class="line">public class Person &#123;</div><div class="line">    @TestAnnotation(msg=&quot;注解成员变量&quot;)</div><div class="line">    private String name;</div><div class="line"></div><div class="line">    @TestAnnotation(msg=&quot;注解方法&quot;)</div><div class="line">    private void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试</div><div class="line">private void test() &#123;</div><div class="line">    boolean hasAnnotation = Person.class.isAnnotationPresent(TestAnnotation.class);</div><div class="line">    if (hasAnnotation) &#123;</div><div class="line">        TestAnnotation annotation = Person.class.getAnnotation(TestAnnotation.class);</div><div class="line">        if (annotation != null) &#123;</div><div class="line">            Log.d(TAG, annotation.msg());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        // 属性获取注解</div><div class="line">        Field nameField = Person.class.getDeclaredField(&quot;name&quot;);</div><div class="line">        nameField.setAccessible(true);</div><div class="line">        TestAnnotation annotation1 = nameField.getAnnotation(TestAnnotation.class);</div><div class="line">        if (annotation1 != null) &#123;</div><div class="line">            Log.d(TAG, annotation1.msg());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 方法获取注解</div><div class="line">        Method setNameMethod = Person.class.getDeclaredMethod(&quot;setName&quot;, String.class);</div><div class="line">        TestAnnotation annotation2 = setNameMethod.getAnnotation(TestAnnotation.class);</div><div class="line">        if (annotation2 != null) &#123;</div><div class="line">            Log.d(TAG, annotation2.msg());</div><div class="line">        &#125;</div><div class="line">    &#125; catch (NoSuchFieldException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; catch (NoSuchMethodException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>打印结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2020-03-09 02:53:23.584 27085-27085/com.xxt.xtest D/xian: 注解类</div><div class="line">2020-03-09 02:53:23.584 27085-27085/com.xxt.xtest D/xian: 注解成员变量</div><div class="line">2020-03-09 02:53:23.584 27085-27085/com.xxt.xtest D/xian: 注解方法</div></pre></td></tr></table></figure></p><blockquote><p>注意：如果一个注解要想在运行时被提取，那么@Retention(RetentionPolicy.RUNTIME) 是必须的。</p></blockquote><p>注解的应用：</p><ul><li>提供信息给编译器：编译器可以通过注解来探测错误和警告信息。</li><li>编译阶段处理：软件工具可以利用注解信息来自动生成代码，HTML文档或者做其他相应处理。</li><li>运行时的处理： 某些注解可以在程序运行时接收代码的提取。</li></ul><p>当开发者使用注解修饰了类，方法，变量等成员后，注解不会自己生效，必须由开发者提供对应的代码来提取处理注解信息。</p><p>这些用来提取和处理注解信息的代码统称为APT（Annotation Processing Tool），注解处理器，它用来在编译时扫描和处理注解。</p><p><strong>总结来说，注解（Annotation）相对于一种标记，注解的应用就是编译器，开发工具或者程序通过反射来提取你的类和各种元素有无这种标记，有某种标记就去做相应的处理。</strong></p><p><img src="https://tva1.sinaimg.cn/large/56682a80gw1evevriupwoj20u6149gqr.jpg" alt=""></p><p>参考文章：<br><a href="https://www.jianshu.com/p/7a401215123d" target="_blank" rel="external">Java 注解 annotation</a><br><a href="https://www.runoob.com/w3cnote/java-annotation.html" target="_blank" rel="external">Java 注解（Annotation）</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Generic</title>
      <link href="/1900/01/06/01%20JAVA/06%20Java%20Generic/"/>
      <url>/1900/01/06/01%20JAVA/06%20Java%20Generic/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><hr><p>什么是泛型，看表面的意思，泛型就是指广泛的、普通的类型。在 Java 中是<strong>指把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型</strong>。</p><p>ArrayList 就是使用泛型的典型案例，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; strList = new ArrayList&lt;String&gt;();</div><div class="line">List&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;();</div><div class="line">List&lt;Double&gt; doubleList = new ArrayList&lt;Double&gt;();</div></pre></td></tr></table></figure></p><p>可以看到，通过菱形语法（’&lt;&gt;’）可以将 List 内元素的类型限定为 String、Integer 和 Double 类型。需要注意的是 &lt;&gt; 内的类型只能是<strong>引用类型</strong>，当然对于基本类型，可以使用对应的<strong>包装类型</strong>。</p><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><hr><p>没有泛型会怎样？举个例子：实现两个能够设置点坐标的类，分别设置 Integer 类型的点坐标和 Float 类型的点坐标，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">// 设置 Integer 类型的点坐标</div><div class="line">class IntegerPoint &#123;</div><div class="line">    private Integer x;       // 表示 X 坐标</div><div class="line">    private Integer y;       // 表示 Y 坐标</div><div class="line">    public void setX(Integer x)&#123;</div><div class="line">        this.x = x;</div><div class="line">    &#125;</div><div class="line">    public void setY(Integer y)&#123;</div><div class="line">        this.y = y;</div><div class="line">    &#125;</div><div class="line">    public Integer getX()&#123;</div><div class="line">        return this.x;</div><div class="line">    &#125;</div><div class="line">    public Integer getY()&#123;</div><div class="line">        return this.y;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 设置 Float 类型的点坐标</div><div class="line">class FloatPoint &#123;</div><div class="line">    private Float x;       // 表示 X 坐标</div><div class="line">    private Float y;       // 表示 Y 坐标</div><div class="line">    public void setX(Float x) &#123;</div><div class="line">        this.x = x;</div><div class="line">    &#125;</div><div class="line">    public void setY(Float y) &#123;</div><div class="line">        this.y = y;</div><div class="line">    &#125;</div><div class="line">    public Float getX() &#123;</div><div class="line">        return this.x;</div><div class="line">    &#125;</div><div class="line">    public Float getY() &#123;</div><div class="line">        return this.y;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>大家可以发现一个问题：它们除了变量类型不一样（一个是 Integer 一个是 Float）以外，其它并没有什么区别。那我们能不能合并成一个呢？</p><p>答案是可以的，因为 Integer 和 Float 都是派生自 Object 的，我们用下面这段代码代替：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class ObjectPoint &#123;</div><div class="line">    private Object x;</div><div class="line">    private Object y;</div><div class="line">    public void setX(Object x) &#123;</div><div class="line">        this.x = x;</div><div class="line">    &#125;</div><div class="line">    public void setY(Object y) &#123;</div><div class="line">        this.y = y;</div><div class="line">    &#125;</div><div class="line">    public Object getX() &#123;</div><div class="line">        return this.x;</div><div class="line">    &#125;</div><div class="line">    public Object getY() &#123;</div><div class="line">        return this.y;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>即全部都用 Object 来代替所有的子类。在使用的时候是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ObjectPoint integerPoint = new ObjectPoint();</div><div class="line">integerPoint.setX(new Integer(100));</div><div class="line">Integer integerX = (Integer) integerPoint.getX();</div></pre></td></tr></table></figure></p><p>在设置的时候，使用 new Integer(100) 来新建一个 Integer 对象，然后在取值的时候，进行强制转换。由于设置的类型和强转的类型是一致的，所以不会出错。</p><p>同理，FloatPoint 的设置和取值也是类似的，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ObjectPoint floatPoint = new ObjectPoint();</div><div class="line">floatPoint.setX(new Float(100.12f));</div><div class="line">Float floatX = (Float) floatPoint.getX();</div></pre></td></tr></table></figure></p><p>但是上面的代码很容易发生运行时异常，且编译是不会报错。比如我们改成下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ObjectPoint floatPoint = new ObjectPoint();</div><div class="line">floatPoint.setX(new Float(100.12f));</div><div class="line">String floatX = (String) floatPoint.getX();</div></pre></td></tr></table></figure></p><p>因为编译器也不知道你传进去的是什么，而 floatPoint.getX() 返回的类型是 Object，所以编译时，将 Object 强转成 String 是成立的。必然不会报错。而在运行时，floatPoint 实例中明明传进去的是 Float 类型的变量，非要把它强转成 String 类型，肯定会报类型转换错误的！</p><p>那有没有一种办法在编译阶段，即能合并成同一个，又能在编译时检查出来传进去类型不对呢？当然，这就是泛型。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Point&lt;T&gt; &#123;</div><div class="line">    private T x;</div><div class="line">    private T y;</div><div class="line"></div><div class="line">    public T getX() &#123;</div><div class="line">        return x;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setX(T x) &#123;</div><div class="line">        this.x = x;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public T getY() &#123;</div><div class="line">        return y;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setY(T y) &#123;</div><div class="line">        this.y = y;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果使用不当，编译器会提示错误信息。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d4522b37fbb98029.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这样代码就不需要强制转换，而且只要在编译时期没有出现警告，那么运行时期就不会出现 ClassCastException 异常。</p><h3 id="Type-amp-How"><a href="#Type-amp-How" class="headerlink" title="Type &amp; How"></a>Type &amp; How</h3><hr><h4 id="1-泛型类"><a href="#1-泛型类" class="headerlink" title="1. 泛型类"></a>1. 泛型类</h4><p>泛型类也就是把泛型定义在类上，这样用户在使用类的时候才把类型给确定下来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Point&lt;T&gt; &#123;</div><div class="line">    private T x;</div><div class="line"></div><div class="line">    public T getX() &#123;</div><div class="line">        return x;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setX(T x) &#123;</div><div class="line">        this.x = x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看到上面这个程序，在使用时如果定义了类型，那么在使用时就可以不用进行强制类型转换，直接就可以得到一个 T 类型的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// IntegerPoint 使用</div><div class="line">Point&lt;Integer&gt; p = new Point&lt;Integer&gt;() ; </div><div class="line">p.setX(new Integer(100)) ; </div><div class="line">System.out.println(p.getX());  </div><div class="line"> </div><div class="line">// FloatPoint 使用</div><div class="line">Point&lt;Float&gt; p = new Point&lt;Float&gt;() ; </div><div class="line">p.setX(new Float(100.12f)) ; </div><div class="line">System.out.println(p.getX());</div></pre></td></tr></table></figure></p><p>下面来看看泛型是怎么定义及使用的吧。</p><ul><li>Point&lt;T&gt;<br>即在类名后面加一个尖括号，括号里是一个大写字母。这里写的是 T，其实这个字母可以是任何大写字母，意义是相同的。</li><li>T<br>这个 T 表示派生自 Object 类的任何类，比如 String、Integer、Double 等等。这里要注意的是，T 一定是派生于 Object 类的。为方便起见，大家可以在这里把 T 当成 String，即 String 在类中怎么用，那 T 在类中就可以怎么用！所以它可以定义变量，作为返回值，作为参数传入。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 定义变量</div><div class="line">private T x ; </div><div class="line">// 作为返回值</div><div class="line">public T getX()&#123; </div><div class="line">    return x ;  </div><div class="line">&#125;  </div><div class="line">// 作为参数</div><div class="line">public void setX(T x)&#123;  </div><div class="line">    this.x = x ;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用方式参考上面，不再表述。</p><h4 id="2-泛型变量"><a href="#2-泛型变量" class="headerlink" title="2. 泛型变量"></a>2. 泛型变量</h4><p>上在我们只定义了一个泛型变量T，那如果我们需要传进去多个泛型要怎么办呢？只需要类似下面这样就可以了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class MorePoint&lt;T, U&gt; &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>也就是在原来的 T 后面用逗号隔开，写上其它的任意大写字母即可。想加几个就加几个，比如我们想加五个泛型变量，那应该是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class MorePoint&lt;T, U, A, B, C&gt; &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>举个例子，我们在 Point 上再另加一个字段 name，也用泛型来表示，那要怎么做？代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class MorePoint&lt;T,U&gt; &#123;</div><div class="line">    private T x;</div><div class="line">    private T y;       </div><div class="line"></div><div class="line">    private U name;</div><div class="line"> </div><div class="line">    public void setX(T x) &#123;</div><div class="line">        this.x = x;</div><div class="line">    &#125;</div><div class="line">    public T getX() &#123;</div><div class="line">        return this.x;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 代码省略...</div><div class="line"></div><div class="line">    public void setName(U name)&#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public U getName() &#123;</div><div class="line">        return this.name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 使用</div><div class="line">MorePoint&lt;Integer, String&gt; morePoint = new MorePoint&lt;Integer, String&gt;();</div><div class="line">morePoint.setName(&quot;xian&quot;);</div><div class="line">Log.d(TAG, &quot;morPont.getName:&quot; + morePoint.getName());</div></pre></td></tr></table></figure></p><p>从上面的代码中，可以明显看出，就是在新添加的泛型变量 U 用法与 T 是一样的。上面提到任意一个大写字母都可以，他们的意义是完全相同的，但为了提高可读性，大家还是用有意义的字母比较好，一般来讲，在不同的情境下使用的字母意义如下：</p><ul><li>E — Element，常用在 java Collection 里，如：List<e>、Iterator<e>、Set<e>；</e></e></e></li><li>K, V — Key, Value，如：代表 Map 的键值对；</li><li>N — Number，数字；</li><li>T — Type，类型，如 String，Integer 等等。</li></ul><p>使用约定俗成的大写字母，可以提高可读性。</p><h4 id="3-泛型接口"><a href="#3-泛型接口" class="headerlink" title="3. 泛型接口"></a>3. 泛型接口</h4><p>在接口上定义泛型与在类中定义泛型是一样的，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">interface Info&lt;T&gt; &#123;</div><div class="line">    // 定义抽象方法，抽象方法的返回值就是泛型类</div><div class="line">    public T getVar(); 型  </div><div class="line">    public void setVar(T x);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h5 id="使用方式一：非泛型子类"><a href="#使用方式一：非泛型子类" class="headerlink" title="使用方式一：非泛型子类"></a>使用方式一：非泛型子类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class InfoImpl implements Info&lt;String&gt; &#123;</div><div class="line">    private String var ;</div><div class="line">    public InfoImpl(String var) &#123;</div><div class="line">        this.setVar(var) ;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void setVar(String var) &#123;</div><div class="line">        this.var = var ;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public String getVar() &#123;</div><div class="line">        return this.var ;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public class Test &#123;</div><div class="line">    public void main(String arsg[]) &#123;</div><div class="line">        InfoImpl i = new InfoImpl(&quot;xian&quot;);</div><div class="line">        System.out.println(i.getVar()) ;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>InfoImpl 不是一个泛型类，因为他类名后没有 <t>。然后在这里我们将 Info<string> 中的泛型变量 T 定义填充为了 String 类型。所以在重写时 setVar() 和 getVar() 时，IDE 会也我们直接生成 String 类型的重写函数。在使用时，传进去 String 类型的字符串来构造 InfoImpl 实例，然后调用它的函数即可。</string></t></p><h5 id="使用方法二：泛型子类"><a href="#使用方法二：泛型子类" class="headerlink" title="使用方法二：泛型子类"></a>使用方法二：泛型子类</h5><p>在方法一中，我们在类中直接把 Info<t> 接口给填充好了，但我们的类，是可以构造成泛型类的，那我们利用泛型类来构造填充泛型接口会是怎样呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">interface Info&lt;T&gt; &#123;</div><div class="line">    public T getVar();</div><div class="line">    public void setVar(T var);</div><div class="line">&#125;</div><div class="line">class InfoImpl&lt;T&gt; implements Info&lt;T&gt; &#123;</div><div class="line">    private T var ;</div><div class="line">    public InfoImpl(T var) &#123;</div><div class="line">        this.setVar(var) ;</div><div class="line">    &#125;</div><div class="line">    public void setVar(T var) &#123;</div><div class="line">        this.var = var ;</div><div class="line">    &#125;</div><div class="line">    public T getVar() &#123;</div><div class="line">        return this.var ;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class Test &#123;</div><div class="line">    public static void main(String arsg[]) &#123;</div><div class="line">        InfoImpl&lt;String&gt; i = new InfoImpl&lt;String&gt;(&quot;xian&quot;);</div><div class="line">        System.out.println(i.getVar()) ;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></t></p><p>在这个类中，我们构造了一个泛型类 InfoImpl<t>，然后把泛型变量 T 传给了 Info<t>，这说明接口和泛型类使用的都是同一个泛型变量。然后在使用时，就是构造一个泛型类的实例的过程，使用过程也不变。</t></t></p><p>使用泛型类来继承泛型接口的作用就是让用户来定义接口所使用的变量类型，而不是像方法一那样，在类中写死。</p><p>那我们稍微加深点难度，构造一个多个泛型变量的类，并继承自 Info 接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class InfoImpl&lt;T,K,U&gt; implements Info&lt;U&gt; &#123;</div><div class="line">    private U var ;</div><div class="line">    private T x;</div><div class="line">    private K y;</div><div class="line">    public InfoImpl(U var) &#123;</div><div class="line">        this.setVar(var) ;</div><div class="line">    &#125;</div><div class="line">    public void setVar(U var) &#123;</div><div class="line">        this.var = var ;</div><div class="line">    &#125;</div><div class="line">    public U getVar() &#123;</div><div class="line">        return this.var ;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这个例子中，我们在泛型类中定义三个泛型变量 T、K、U，并且把第三个泛型变量 U 用来填充接口 Info。所以在这个例子中 Info 所使用的类型就是由 U 来决定的。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">InfoImpl&lt;Integer, Double, String&gt; i = new InfoImpl&lt;&gt;(&quot;xian&quot;);</div><div class="line">System.out.println(i.getVar()) ;</div></pre></td></tr></table></figure></p><h4 id="4-泛型函数"><a href="#4-泛型函数" class="headerlink" title="4. 泛型函数"></a>4. 泛型函数</h4><p>上面我们讲解了类和接口的泛型使用，下面我们再说说，怎么单独在一个函数里使用泛型。新建一个普通的类 StaticFans，然后在其中定义了两个泛型函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class StaticFans &#123;</div><div class="line">    // 静态函数</div><div class="line">    public static &lt;T&gt; void staticMethod(T a) &#123;</div><div class="line">        Log.d(&quot;xian&quot;, &quot;staticMethod: &quot; + a.toString());</div><div class="line">    &#125;</div><div class="line">    // 普通函数</div><div class="line">    public &lt;T&gt; void otherMethod(T a) &#123;</div><div class="line">        Log.d(&quot;xian&quot;, &quot;otherMethod: &quot; + a.toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面分别是静态泛型函数和常规泛型函数的定义方法，与以往方法的唯一不同点就是在返回值前加上 <t> 来表示泛型变量。其它没什么区别。使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 静态方法</div><div class="line">StaticFans.staticMethod(&quot;Xian&quot;);</div><div class="line"></div><div class="line">// 常规方法</div><div class="line">StaticFans staticFans = new StaticFans();</div><div class="line">staticFans.otherMethod(123);</div></pre></td></tr></table></figure></t></p><h4 id="5-泛型返回值"><a href="#5-泛型返回值" class="headerlink" title="5. 泛型返回值"></a>5. 泛型返回值</h4><p>有时，我们需要将泛型变量返回，比如下面这个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static &lt;T&gt; List&lt;T&gt; parseArray(String response, Class&lt;T&gt; object) &#123;</div><div class="line">    List&lt;T&gt; modelList = JSON.parseArray(response, object);</div><div class="line">    return modelList;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="6-泛型数组"><a href="#6-泛型数组" class="headerlink" title="6. 泛型数组"></a>6. 泛型数组</h4><p>在写程序时，大家可能会遇到类似 String[] list = new String[8]; 的需求，这里可以定义 String 数组，当然我们也可以定义泛型数组，泛型数组的定义方法为 T[]，与 String[] 是一致的，下面看看用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static &lt;T&gt; T[] fun1(T... arg) &#123;</div><div class="line">    return arg ;  // 返回泛型数组  </div><div class="line">&#125;  </div><div class="line">// 使用</div><div class="line">public static void main(String args[]) &#123;  </div><div class="line">    Integer[] i = fun1(1,2,3,4,5,6) ;</div><div class="line">    Integer[] result = fun1(i) ;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><hr><h4 id="1-无界"><a href="#1-无界" class="headerlink" title="1. 无界"></a>1. 无界</h4><p>“?”可以接收任何类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void processElements(List&lt;?&gt; elements)&#123;</div><div class="line">   for(Object o : elements)&#123;</div><div class="line">      System.out.println(o);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="2-上界"><a href="#2-上界" class="headerlink" title="2. 上界"></a>2. 上界</h4><p>这种情况下能够接收 A 类或者 A 类的子类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void processElements(List&lt;? extends A&gt; elements)&#123;</div><div class="line">   for(A a : elements)&#123;</div><div class="line">      System.out.println(a.getValue());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>A 类也可以换成接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public interface Comparable&lt;T&gt; &#123;</div><div class="line">    public boolean compareTo(T i);</div><div class="line">&#125;</div><div class="line">// 添加上 extends Comparable 之后，就可以 Comparable 里的函数了</div><div class="line">public static &lt;T extends Comparable&gt; T min(T... a) &#123;</div><div class="line">    T smallest = a[0];</div><div class="line">    for (T item : a) &#123;</div><div class="line">        if (smallest.compareTo(item)) &#123;</div><div class="line">            smallest = item;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return smallest;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通配多个类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static &lt;T extends Fruit &amp; Serializable&gt; String getFruitName(T t) &#123;</div><div class="line">    return t.getName();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static &lt;T extends Comparable &amp; Serializable, U extends Runnable&gt; T foo(T t, U u) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="3-下界"><a href="#3-下界" class="headerlink" title="3. 下界"></a>3. 下界</h4><p>接收 A 类或者 A 类的父类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void insertElements(List&lt;? super A&gt; list)&#123;</div><div class="line">    list.add(new A());</div><div class="line">    list.add(new B());</div><div class="line">    list.add(new C());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>泛型通配符 &lt; ? extends T &gt; 来接收返回的数据，此写法的泛型集合不能使用 add 方 法， 而 &lt; ? super T &gt; 不能使用 get 方法，做为接口调用赋值时易出错。</p><p>当我们使用 extends 时，我们可以读元素，因为元素都是 T 类或子类，可以放心的用 T 类拿出。当使用 super 时，可以添加元素，因为都是 T 类或父类，那么就可以安全的插入 T 类。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-317cba49d48c6f46?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>参考链接：<a href="https://segmentfault.com/a/1190000019606768" target="_blank" rel="external">JAVA 泛型</a>、<a href="https://blog.csdn.net/harvic880925/article/details/49872903" target="_blank" rel="external">夯实 JAVA 基础 —— 泛型详解</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Thread</title>
      <link href="/1900/01/05/01%20JAVA/05%20Java%20Thread/"/>
      <url>/1900/01/05/01%20JAVA/05%20Java%20Thread/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><strong>线程对象</strong>是可以产生线程的对象。比如在 JAVA 平台中 Thread 对象、Runnable 对象。<strong>线程</strong>，是指正在执行的一个指点令序列。在 JAVA 平台上是指从一个线程对象的 start() 开始，运行 run() 方法体中的那一段相对独立的过程。</p><p>相比于多进程，多线程的优势有：<br>1）进程之间不能共享数据，线程可以；<br>2）系统创建进程需要为该进程重新分配系统资源，而同一类线程共享代码和数据空间，故创建线程代价比较小；<br>3）JAVA 语言内置了多线程功能支持，简化了 JAVA 多线程编程。</p><h3 id="一、创建线程和启动"><a href="#一、创建线程和启动" class="headerlink" title="一、创建线程和启动"></a>一、创建线程和启动</h3><hr><h4 id="1、继承-Thread-类"><a href="#1、继承-Thread-类" class="headerlink" title="1、继承 Thread 类"></a>1、继承 Thread 类</h4><p>通过继承 Thread 类创建线程类的具体步骤和具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 1. 定义一个继承 Thread 类的子类，并重写该类的 run() 方法；</div><div class="line">class TestThread extends Thread   &#123;</div><div class="line">    public void run()   &#123;</div><div class="line">        // do something here</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public void test() &#123;</div><div class="line">    // 2. 创建 Thread 子类的实例，即创建了线程对象</div><div class="line">    TestThread thread = new TestThread();</div><div class="line">    // 3. 调用该线程对象的 start()方法启动线程。</div><div class="line">    thread.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="2、实现-Runnable-接口"><a href="#2、实现-Runnable-接口" class="headerlink" title="2、实现 Runnable 接口"></a>2、实现 Runnable 接口</h4><p>通过实现 Runnable 接口创建线程类的具体步骤和具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 1. 定义 Runnable 接口的实现类，并重写该接口的 run() 方法</div><div class="line">class TestRunnable implements Runnable &#123; </div><div class="line">    public void run() &#123; </div><div class="line">        // do something here  </div><div class="line">    &#125;  </div><div class="line">&#125;</div><div class="line"></div><div class="line">public void test() &#123;</div><div class="line">    // 2. 创建 Runnable 实现类的实例</div><div class="line">    Runnable runnable = new TestRunnable();   </div><div class="line">    // 3. 将 Runnable 实例作为 Thread 的 target 对象</div><div class="line">    // 即该Thread对象才是真正的线程对象。</div><div class="line">    Thread thread = new Thread(runnable);   </div><div class="line">    thread.start(); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="3、通过-Callable-和-Future-创建线程"><a href="#3、通过-Callable-和-Future-创建线程" class="headerlink" title="3、通过 Callable 和 Future 创建线程"></a>3、通过 Callable 和 Future 创建线程</h4><p>通过 Callable 和 Future 创建线程的具体步骤和具体代码如下：</p><ul><li>创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</li><li>创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</li><li>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li><li>调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值其中。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">// 步骤一</div><div class="line">class TestCallable implements Callable&lt;Integer&gt; &#123;</div><div class="line">    @Override</div><div class="line">    public Integer call() throws Exception &#123;</div><div class="line">        int i = 0;</div><div class="line">        while (i &lt; 10) &#123;</div><div class="line">            print(Thread.currentThread().getName() + &quot; &quot; + i);</div><div class="line">            i ++;</div><div class="line">        &#125;</div><div class="line">        return i;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void test() &#123;</div><div class="line">    // 步骤二</div><div class="line">    TestCallable testCallable = new TestCallable();</div><div class="line">    FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(testCallable);</div><div class="line"></div><div class="line">    // 开启 ft 线程</div><div class="line">    for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">        print(Thread.currentThread().getName() + &quot; 的循环变量 i 的值 &quot; + i);</div><div class="line">        // i 为 20 的时候创建 ft线程</div><div class="line">        if (i == 6) &#123;</div><div class="line">            // 步骤三</div><div class="line">            new Thread(ft,&quot;有返回值的线程 FutureTask&quot;).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // ft 线程结束时，获取返回值</div><div class="line">    try &#123;</div><div class="line">        // 步骤四</div><div class="line">        // get() 方法会阻塞，直到子线程执行结束才返回</div><div class="line">        print(&quot;子线程的返回值：&quot; + ft.get());</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; catch (ExecutionException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void print(String msg) &#123;</div><div class="line">    Log.d(TAG, msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>打印结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ddda1463dd803bb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>Callable 概述：</p><ul><li>Callable 类似于 Runnable，但是它有返回值，Runnable 没有。</li><li>new Thread(futureTask) 的方式来创建 FutureTask 任务，FutureTask 是一个实现了 Runnable 和 Future 接口的类。</li><li>call 方法可以抛出异常，run 方法不可以。</li><li>Callable 规定重写的方法是 call()，Runnable 规定重写的方法是 run()。</li><li>运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li></ul><h3 id="二、线程的生命周期"><a href="#二、线程的生命周期" class="headerlink" title="二、线程的生命周期"></a>二、线程的生命周期</h3><hr><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1a449b72ea5d696a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="1、新建状态"><a href="#1、新建状态" class="headerlink" title="1、新建状态"></a>1、新建状态</h4><p>用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用 start 方法进入就绪状态（runnable）。</p><blockquote><p>不能对已经启动的线程再次调用 start() 方法，否则会出现 java.lang.IllegalThreadStateException 异常。</p></blockquote><h4 id="2、就绪状态"><a href="#2、就绪状态" class="headerlink" title="2、就绪状态"></a>2、就绪状态</h4><p>处于就绪状态的线程已经具备了运行条件，但还没有分配到 CPU，处于线程就绪队列（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为 CPU 的调度不一定是按照先进先出的顺序来调度的），等待系统为其分配 CPU。等待状态并不是执行状态，当系统选定一个等待执行的 Thread 对象后，它就会从等待执行状态进入执行状态，系统挑选的动作称之为“CPU 调度”。一旦获得 CPU，线程就进入运行状态并自动调用自己的 run 方法。</p><blockquote><p>如果希望子线程调用 start() 方法后立即执行，可以使用 Thread.sleep() 方式使主线程睡眠一伙儿，转去执行子线程。</p></blockquote><h4 id="3、运行状态"><a href="#3、运行状态" class="headerlink" title="3、运行状态"></a>3、运行状态</h4><p>处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p><p>处于就绪状态的线程，如果获得了 CPU 的调度，就会从就绪状态变为运行状态，执行 run() 方法中的任务。如果该线程失去了 CPU 资源，就会又从运行状态变为就绪状态，重新等待系统分配资源。也可以对在运行状态的线程调用 yield() 方法，它就会让出 CPU 资源，再次变为就绪状态。</p><p>当发生如下情况是，线程会从运行状态变为阻塞状态：</p><ul><li>线程调用 sleep 方法主动放弃所占用的系统资源。</li><li>线程调用一个阻塞式 IO 方法，在该方法返回之前，该线程被阻塞。</li><li>线程试图获得一个同步监视器，但更改同步监视器正被其他线程所持有。</li><li>线程在等待某个通知（notify）。</li><li>程序调用了线程的 suspend 方法将线程挂起。不过该方法容易导致死锁，所以程序应该尽量避免使用该方法。</li></ul><p>当线程的 run() 方法执行完，或者被强制性地终止，例如出现异常，或者调用了 stop()、destroy() 方法等等，就会从运行状态转变为死亡状态。</p><h4 id="4、阻塞状态"><a href="#4、阻塞状态" class="headerlink" title="4、阻塞状态"></a>4、阻塞状态</h4><p>处于运行状态的线程在某些情况下，如执行了 sleep 方法，或等待 I/O 设备等资源，将让出 CPU 并暂时停止自己的运行，进入阻塞状态。 </p><p>在阻塞状态的线程不能进入就绪队列。只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的 I/O 设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行。</p><h4 id="5、死亡状态"><a href="#5、死亡状态" class="headerlink" title="5、死亡状态"></a>5、死亡状态</h4><p>当线程的 run() 方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用 start() 方法，会抛出 java.lang.IllegalThreadStateException 异常。</p><h3 id="三、线程管理"><a href="#三、线程管理" class="headerlink" title="三、线程管理"></a>三、线程管理</h3><hr><p>JAVA 提供了一些便捷的方法用于会线程状态的控制：线程睡眠、让步、合并，设置优先级，后台（守护）线程，结束线程。</p><h4 id="1、线程睡眠（sleep）"><a href="#1、线程睡眠（sleep）" class="headerlink" title="1、线程睡眠（sleep）"></a>1、线程睡眠（sleep）</h4><p>如果我们需要让当前正在执行的线程暂停一段时间，并进入阻塞状态，则可以通过调用 Thread 的 sleep 方法。</p><p>sleep 是静态方法，最好不要用 Thread 的实例对象调用它，因为它睡眠的始终是当前正在运行的线程，而不是调用它的线程对象，它只对正在运行状态的线程对象有效。如下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public void test() &#123;</div><div class="line">    print(Thread.currentThread().getName());</div><div class="line">    MyThread myThread = new MyThread();</div><div class="line">    myThread.start();</div><div class="line">    try &#123;</div><div class="line">        // 这里 sleep 的就是 main 线程，而非 myThread 线程</div><div class="line">        myThread.sleep(1000);</div><div class="line">        Thread.sleep(10);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; 100; i++)&#123;</div><div class="line">        print(&quot;main: &quot; + i);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyThread extends Thread &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        for (int i = 0; i &lt; 100; i++)&#123;</div><div class="line">            print(&quot;MyThread: &quot; + i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>JAVA 线程调度是 JAVA 多线程的核心，只有良好的调度，才能充分发挥系统的性能，提高程序的执行效率。但是不管程序员怎么编写调度，只能最大限度的影响线程执行的次序，而不能做到精准控制。因为使用 sleep 方法之后，线程是进入阻塞状态的，只有当睡眠的时间结束，才会重新进入到就绪状态，而就绪状态进入到运行状态，是由系统控制的，我们不可能精准的去干涉它，所以如果调用 Thread.sleep(1000) 使得线程睡眠1秒，可能结果会大于1秒。</p><h4 id="2、线程让步（yield）"><a href="#2、线程让步（yield）" class="headerlink" title="2、线程让步（yield）"></a>2、线程让步（yield）</h4><p>yield() 方法和 sleep() 方法有点相似，它也是 Thread 类提供的一个静态的方法，它也可以让当前正在执行的线程暂停，让出 CPU 资源给其他的线程。但是和 sleep() 方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。yield() 方法只是让当前线程暂停一下，重新进入就绪的线程池中，让系统的线程调度器重新调度器重新调度一次，完全可能出现这样的情况：当某个线程调用 yield() 方法之后，线程调度器又将其调度出来重新进入到运行状态执行。</p><p>实际上，当某个线程调用了 yield() 方法暂停之后，优先级与当前线程相同，或者优先级比当前线程更高的就绪状态的线程更有可能获得执行的机会，当然，只是有可能，因为我们不可能精确的干涉 CPU 调度线程。用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public void test() &#123;</div><div class="line">    new MyThread(&quot;低级&quot;, 1).start();</div><div class="line">    new MyThread(&quot;中级&quot;, 5).start();</div><div class="line">    new MyThread(&quot;高级&quot;, 10).start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyThread extends Thread &#123;</div><div class="line">    public MyThread(String name, int pro) &#123;</div><div class="line">        super(name);            // 设置线程的名称</div><div class="line">        this.setPriority(pro);  // 设置优先级</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        for (int i = 0; i &lt; 30; i++) &#123;</div><div class="line">            print(this.getName() + &quot;线程第 &quot; + i + &quot; 次执行！&quot;);</div><div class="line">            if (i % 5 == 0) &#123;</div><div class="line">                Thread.yield();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>关于 sleep() 方法和 yield() 方的区别如下：</p><ul><li>sleep 方法暂停当前线程后，会进入阻塞状态，只有当睡眠时间到了，才会转入就绪状态。而 yield 方法调用后 ，是直接进入就绪状态，所以有可能刚进入就绪状态，又被调度到运行状态。</li><li>sleep 方法声明抛出了 InterruptedException，所以调用 sleep 方法的时候要捕获该异常，或者显示声明抛出该异常。而 yield 方法则没有声明抛出任务异常。</li><li>sleep 方法比 yield 方法有更好的可移植性，通常不要依靠 yield 方法来控制并发线程的执行。</li></ul><h4 id="3、线程合并（join）"><a href="#3、线程合并（join）" class="headerlink" title="3、线程合并（join）"></a>3、线程合并（join）</h4><p>线程的合并的含义就是将几个并行线程的线程合并为一个单线程执行，应用场景是当一个线程必须等待另一个线程执行完毕才能执行时，Thread 类提供了 join 方法来完成这个功能。注意，它不是静态方法。</p><p>从下面的方法的列表可以看到，它有3个重载的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 当前线程等该加入该线程后面，等待该线程终止。    </div><div class="line">void join()      </div><div class="line"></div><div class="line">// 当前线程等待该线程终止的时间最长为 millis 毫秒。</div><div class="line">// 如果在 millis 时间内，该线程没有执行完，</div><div class="line">// 那么当前线程进入就绪状态，重新等待 CPU 调度  </div><div class="line">void join(long millis)  </div><div class="line"></div><div class="line">// 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。</div><div class="line">// 如果在 millis + nanos 时间内，该线程没有执行完，</div><div class="line">// 那么当前线程进入就绪状态，重新等待 CPU 调度</div><div class="line">void join(long millis, int nanos)</div></pre></td></tr></table></figure></p><h4 id="4、设置线程的优先级"><a href="#4、设置线程的优先级" class="headerlink" title="4、设置线程的优先级"></a>4、设置线程的优先级</h4><p>每个线程执行时都有一个优先级的属性，优先级高的线程可以获得较多的执行机会，而优先级低的线程则获得较少的执行机会。与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取 CPU 资源的概率较大，优先级低的也并非没机会执行。</p><p>每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main 线程具有普通优先级。</p><p>注：Thread 类提供了 setPriority(int newPriority) 和 getPriority() 方法来设置和返回一个指定线程的优先级，其中 setPriority 方法的参数是一个整数，范围是 1~10 之间，也可以使用 Thread 类提供的三个静态常量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MAX_PRIORITY   =  10</div><div class="line">MIN_PRIORITY   =  1</div><div class="line">NORM_PRIORITY  =  5</div></pre></td></tr></table></figure></p><p>使用示例代码见上（节：线程让步）。</p><p>虽然 Java 提供了 10 个优先级别，但这些优先级别需要操作系统的支持。不同的操作系统的优先级并不相同，而且也不能很好的和 Java 的 10 个优先级别对应。所以我们应该使用 MAX_PRIORITY、MIN_PRIORITY 和 NORM_PRIORITY 三个静态常量来设定优先级，这样才能保证程序最好的可移植性。</p><h4 id="5、后台（守护）线程"><a href="#5、后台（守护）线程" class="headerlink" title="5、后台（守护）线程"></a>5、后台（守护）线程</h4><p>守护线程使用的情况较少，但并非无用，举例来说，JVM 的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。调用线程对象的方法 setDaemon(true)，则可以将其设置为守护线程。守护线程的用途为：</p><ul><li>守护线程通常用于执行一些后台作业，例如在你的应用程序运行时播放背景音乐，在文字编辑器里做自动语法检查、自动保存等功能。</li><li>Java 的垃圾回收也是一个守护线程。守护线的好处就是你不需要关心它的结束问题。例如你在你的应用程序运行的时候希望播放背景音乐，如果将这个播放背景音乐的线程设定为非守护线程，那么在用户请求退出的时候，不仅要退出主线程，还要通知播放背景音乐的线程退出；如果设定为守护线程则不需要了。</li></ul><p>setDaemon 方法的详细说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public final void setDaemon(boolean on)</div></pre></td></tr></table></figure></p><p>将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。 该方法必须在启动线程前调用。 该方法首先调用该线程的 checkAccess 方法，且不带任何参数。这可能抛出 SecurityException（在当前线程中）。  </p><ul><li>参数：<br>   on - 如果为 true，则将该线程标记为守护线程。    </li><li>抛出：<br>  IllegalThreadStateException - 如果该线程处于活动状态。<br>  SecurityException - 如果当前线程无法修改该线程。</li></ul><p>注：JRE 判断程序是否执行结束的标准是所有的前台执线程行完毕了，而不管后台线程的状态，因此，在使用后台线程时候一定要注意这个问题。</p><h4 id="6、正确结束线程"><a href="#6、正确结束线程" class="headerlink" title="6、正确结束线程"></a>6、正确结束线程</h4><p>Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit 这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的。想要安全有效的结束一个线程，可以使用下面的方法：</p><ul><li>正常执行完run方法，然后结束掉；</li><li>控制循环条件和判断条件的标识符来结束掉线程。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class MyThread extends Thread &#123;  </div><div class="line">    int i = 0;  </div><div class="line">    boolean next = true;  </div><div class="line">    @Override  </div><div class="line">    public void run() &#123;  </div><div class="line">        while (next) &#123;  </div><div class="line">            if (i == 10)  &#123;</div><div class="line">                next = false;  </div><div class="line">            &#125;  </div><div class="line">            i++;  </div><div class="line">            System.out.println(i);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="四、线程同步"><a href="#四、线程同步" class="headerlink" title="四、线程同步"></a>四、线程同步</h3><hr><p>JAVA 允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。</p><h4 id="1、同步方法"><a href="#1、同步方法" class="headerlink" title="1、同步方法"></a>1、同步方法</h4><p>即有 synchronized 关键字修饰的方法。由于 Java 的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public synchronized void save() &#123;&#125;</div></pre></td></tr></table></figure></p><blockquote><p>synchronized 关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类。</p></blockquote><h4 id="2、同步代码块"><a href="#2、同步代码块" class="headerlink" title="2、同步代码块"></a>2、同步代码块</h4><p>即有 synchronized 关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class Bank &#123;</div><div class="line">    private int count =0;  // 账户余额  </div><div class="line">    // 存钱  </div><div class="line">    public void addMoney(int money) &#123;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            count += money;</div><div class="line">        &#125;</div><div class="line">        System.out.println(System.currentTimeMillis()+&quot;存进：&quot;+money);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 取钱  </div><div class="line">    public void subMoney(int money) &#123;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            if (count-money &lt; 0) &#123;</div><div class="line">                System.out.println(&quot;余额不足&quot;);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            count -= money;</div><div class="line">        &#125;</div><div class="line">        System.out.println(+System.currentTimeMillis()+&quot;取出：&quot;+money);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 查询  </div><div class="line">    public void lookMoney() &#123;</div><div class="line">        System.out.println(&quot;账户余额：&quot;+count);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用 synchronized 代码块同步关键代码即可。</p></blockquote><h4 id="3、使用特殊域变量（volatile）实现线程同步"><a href="#3、使用特殊域变量（volatile）实现线程同步" class="headerlink" title="3、使用特殊域变量（volatile）实现线程同步"></a>3、使用特殊域变量（volatile）实现线程同步</h4><p>• volatile 关键字为域变量的访问提供了一种免锁机制；<br>• 使用 volatile 修饰域相当于告诉虚拟机该域可能会被其他线程更新；<br>• 因此每次使用该域就要重新计算，而不是使用寄存器中的值；<br>• volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">public class SynchronizedThread &#123;</div><div class="line">    class Bank &#123;</div><div class="line">        private volatile int account = 100;</div><div class="line"></div><div class="line">        public int getAccount() &#123;</div><div class="line">            return account;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 用同步方法实现</div><div class="line">         * @param money</div><div class="line">         */</div><div class="line">        public synchronized void save(int money) &#123;</div><div class="line">            account += money;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 用同步代码块实现</div><div class="line">         * @param money</div><div class="line">         */</div><div class="line">        public void save1(int money) &#123;</div><div class="line">            synchronized (this) &#123;</div><div class="line">                account += money;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class NewThread implements Runnable &#123;</div><div class="line">        private Bank bank;</div><div class="line"></div><div class="line">        public NewThread(Bank bank) &#123;</div><div class="line">            this.bank = bank;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">                // bank.save1(10);</div><div class="line">                bank.save(10);</div><div class="line">                System.out.println(i + &quot;账户余额为：&quot; + bank.getAccount());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 建立线程，调用内部类</div><div class="line">     */</div><div class="line">    public void useThread() &#123;</div><div class="line">        Bank bank = new Bank();</div><div class="line">        NewThread new_thread = new NewThread(bank);</div><div class="line">        System.out.println(&quot;线程1&quot;);</div><div class="line">        Thread thread1 = new Thread(new_thread);</div><div class="line">        thread1.start();</div><div class="line">        System.out.println(&quot;线程2&quot;);</div><div class="line">        Thread thread2 = new Thread(new_thread);</div><div class="line">        thread2.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        SynchronizedThread st = new SynchronizedThread();</div><div class="line">        st.useThread();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。用 final 域，有锁保护的域和 volatile 域可以避免非同步的问题。</p></blockquote><h4 id="4、使用重入锁（Lock）实现线程同步"><a href="#4、使用重入锁（Lock）实现线程同步" class="headerlink" title="4、使用重入锁（Lock）实现线程同步"></a>4、使用重入锁（Lock）实现线程同步</h4><p>在 Java SE5.0 中新增了一个 java.util.concurrent 包来支持同步。ReentrantLock 类是可重入、互斥、实现了 Lock 接口的锁，它与使用 synchronized 方法和快具有相同的基本行为和语义，并且扩展了其能力。ReentrantLock 类的常用方法有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ReentrantLock() : 创建一个 ReentrantLock 实例         </div><div class="line">lock() : 获得锁        </div><div class="line">unlock() : 释放锁</div></pre></td></tr></table></figure></p><p>ReentrantLock() 还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 只给出要修改的代码，其余代码与上同</div><div class="line">class Bank &#123;</div><div class="line">    private int account = 100;</div><div class="line">    // 需要声明这个锁</div><div class="line">    private Lock lock = new ReentrantLock();</div><div class="line"></div><div class="line">    public int getAccount() &#123;</div><div class="line">        return account;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 这里不再需要synchronized </div><div class="line">    public void save(int money) &#123;</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            account += money;</div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-11fbb63f7f30fdc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="五、线程通信"><a href="#五、线程通信" class="headerlink" title="五、线程通信"></a>五、线程通信</h3><hr><h4 id="1、借助于-wait、notify-和-notifyAll-实现通信"><a href="#1、借助于-wait、notify-和-notifyAll-实现通信" class="headerlink" title="1、借助于 wait、notify 和 notifyAll 实现通信"></a>1、借助于 wait、notify 和 notifyAll 实现通信</h4><p>程执行 wait() 后，就放弃了运行资格，处于冻结状态；线程运行时，内存中会建立一个线程池，冻结状态的线程都存在于线程池中，notify() 执行时唤醒的也是线程池中的线程，线程池中有多个线程时唤醒第一个被冻结的线程；notifyall()，唤醒线程池中所有线程。</p><blockquote><p>• wait()、notify()、notifyall() 都用在同步里面，因为这三个函数是对持有锁的线程进行操作，而只有同步才有锁，所以要使用在同步中；<br>• wait()、notify()、notifyall(),  在使用时必须标识它们所操作的线程持有的锁，因为等待和唤醒必须是同一锁下的线程；而锁可以是任意对象，所以这三个方法都是 Object 类中的方法。</p></blockquote><p>单个消费者生产者例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">// 生产者和消费者都要操作的资源</div><div class="line">class Resource &#123;</div><div class="line">    private String name;</div><div class="line">    private int count = 1;</div><div class="line">    private boolean flag = false;</div><div class="line"></div><div class="line">    public synchronized void set(String name) &#123;</div><div class="line">        if (flag) &#123;</div><div class="line">            try &#123; wait(); &#125; catch (Exception e) &#123;&#125;</div><div class="line">        &#125;</div><div class="line">        this.name = name + &quot;---&quot; + count++;</div><div class="line">        print(Thread.currentThread().getName() + &quot;...生产者...&quot; + this.name);</div><div class="line">        flag = true;</div><div class="line">        this.notify();</div><div class="line">    &#125;</div><div class="line">    public synchronized void out() &#123;</div><div class="line">        if (!flag) &#123;</div><div class="line">            try &#123; wait(); &#125; catch (Exception e) &#123;&#125;</div><div class="line">        &#125;</div><div class="line">        print(Thread.currentThread().getName() + &quot;...消费者...&quot; + name);</div><div class="line">        flag = false;</div><div class="line">        this.notify();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Producer implements Runnable &#123;</div><div class="line">    private Resource res;</div><div class="line">    Producer(Resource res) &#123;</div><div class="line">        this.res = res;</div><div class="line">    &#125;</div><div class="line">    public void run() &#123;</div><div class="line">        while(true) &#123;</div><div class="line">            res.set(&quot;商品&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Consumer implements Runnable &#123;</div><div class="line">    private Resource res;</div><div class="line">    Consumer(Resource res) &#123;</div><div class="line">        this.res = res;</div><div class="line">    &#125;</div><div class="line">    public void run() &#123;</div><div class="line">        while(true) &#123;</div><div class="line">            res.out();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 运行结果正常，生产者生产一个商品，紧接着消费者消费一个商品。</div><div class="line">public void test() &#123;</div><div class="line">    Resource r = new Resource();</div><div class="line">    Producer pro = new Producer(r);</div><div class="line">    Consumer con = new Consumer(r);</div><div class="line">    Thread t1 = new Thread(pro);</div><div class="line">    Thread t2 = new Thread(con);</div><div class="line">    t1.start();</div><div class="line">    t2.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-bd3281e4882f72e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如果有多个生产者和多个消费者，上面的代码是有问题，比如 2 个生产者，2 个消费者，运行结果就可能出现生产的 1 个商品生产了一次而被消费了 2 次，或者连续生产 2 个商品而只有1个被消费，这是因为此时共有 4 个线程在操作 Resource 对象 r,  而 notify() 唤醒的是线程池中第 1 个 wait() 的线程，所以生产者执行 notify() 时，唤醒的线程有可能是另 1 个生产者线程，这个生产者线程从 wait() 中醒来后不会再判断 flag，而是直接向下运行打印出一个新的商品，这样就出现了连续生产 2 个商品。</p><p>为了避免这种情况，修改代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">class Resource &#123;</div><div class="line">    private String name;</div><div class="line">    private int count = 1;</div><div class="line">    private boolean flag = false;</div><div class="line"></div><div class="line">    public synchronized void set(String name) &#123;</div><div class="line">        /* 原先是if,现在改成while，这样生产者线程从冻结状态醒来时，还会再判断flag. */</div><div class="line">        while(flag)</div><div class="line">            try &#123; wait();&#125; catch(Exception e) &#123;&#125;</div><div class="line">        this.name = name + &quot;---&quot; + count++;</div><div class="line">        print(Thread.currentThread().getName() + &quot;...生产者...&quot;+ this.name);</div><div class="line">        flag = true;</div><div class="line">        /* 原先是 notify(), 现在改成 notifyAll()，这样生产者线程生产完一个商品后</div><div class="line">        可以将等待中的消费者线程唤醒，否则只将上面改成 while 后，可能出现所有生产者</div><div class="line">        和消费者都在 wait() 的情况。*/</div><div class="line">        this.notifyAll();</div><div class="line">    &#125;</div><div class="line">    public synchronized void out() &#123;</div><div class="line">        /* 原先是if,现在改成while，这样消费者线程从冻结状态醒来时，还会再判断flag. */</div><div class="line">        while(!flag)</div><div class="line">            try&#123; wait();&#125; catch(Exception e) &#123;&#125;</div><div class="line">        print(Thread.currentThread().getName() + &quot;...消费者...&quot; + this.name);</div><div class="line">        flag = false;</div><div class="line">        /* 原先是 notify(), 现在改成 notifyAll()，这样消费者线程消费完一个商品后</div><div class="line">        可以将等待中的生产者线程唤醒，否则只将上面改成 while 后，可能出现所有生产者</div><div class="line">        和消费者都在 wait() 的情况。*/</div><div class="line">        this.notifyAll(); </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void test() &#123;</div><div class="line">    Resource r = new Resource();</div><div class="line">    Producer pro = new Producer(r);</div><div class="line">    Consumer con = new Consumer(r);</div><div class="line">    Thread t1 = new Thread(pro);</div><div class="line">    Thread t2 = new Thread(con);</div><div class="line">    Thread t3 = new Thread(pro);</div><div class="line">    Thread t4 = new Thread(con);</div><div class="line">    t1.start();</div><div class="line">    t2.start();</div><div class="line">    t3.start();</div><div class="line">    t4.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果部分截图：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2d0b4c1e1d5d3137.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="2、使用-Condition-控制线程通信"><a href="#2、使用-Condition-控制线程通信" class="headerlink" title="2、使用 Condition 控制线程通信"></a>2、使用 Condition 控制线程通信</h4><p>JDK 1.5 中，提供了多线程的升级解决方案为：</p><ul><li>将同步 synchronized 替换为显式的 Lock 操作；</li><li>将 Object 类中的 wait()、notify()、notifyAll() 替换成了 Condition 对象，该对象可以通过 Lock 锁对象获取;</li><li>一个 Lock 对象上可以绑定多个 Condition 对象，这样实现了本方线程只唤醒对方线程，而 JDK 1.5 之前，一个同步只能有一个锁，不同的同步只能用锁来区分，且锁嵌套时容易死锁。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">class Resource &#123;</div><div class="line">    private String name;</div><div class="line">    private int count = 1;</div><div class="line">    private boolean flag = false;</div><div class="line">    /* Lock 是一个接口，ReentrantLock 是该接口的一个直接子类。*/</div><div class="line">    private Lock lock = new ReentrantLock();</div><div class="line">    /* 创建代表生产者方面的 Condition 对象*/</div><div class="line">    private Condition conditionPro = lock.newCondition();</div><div class="line">    /* 使用同一个锁，创建代表消费者方面的 Condition 对象*/</div><div class="line">    private Condition conditionCon = lock.newCondition();</div><div class="line"></div><div class="line">    public void set(String name) &#123;</div><div class="line">        // 锁住此语句与 lock.unlock() 之间的代码</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            while(flag) &#123;</div><div class="line">                // 生产者线程在 conditionPro 对象上等待</div><div class="line">                conditionPro.await();</div><div class="line">            &#125;</div><div class="line">            this.name = name + &quot;---&quot; + count++;</div><div class="line">            print(Thread.currentThread().getName() + &quot;...生产者...&quot; + this.name);</div><div class="line">            flag = true;</div><div class="line">            conditionCon.signalAll();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            // unlock() 要放在 finally 块中。</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void out() &#123;</div><div class="line">        // 锁住此语句与 lock.unlock() 之间的代码</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            while(!flag) &#123;</div><div class="line">                // 消费者线程在 conditionCon 对象上等待</div><div class="line">                conditionCon.await();</div><div class="line">            &#125;</div><div class="line">            print(Thread.currentThread().getName() + &quot;...消费者...&quot; + this.name);</div><div class="line">            flag = false;</div><div class="line">            /* 唤醒所有在 conditionCon 对象下等待的线程，也就是唤醒所有生产者线程*/</div><div class="line">            conditionPro.signalAll();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally&#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3、使用阻塞队列（BlockingQueue）控制线程通信"><a href="#3、使用阻塞队列（BlockingQueue）控制线程通信" class="headerlink" title="3、使用阻塞队列（BlockingQueue）控制线程通信"></a>3、使用阻塞队列（BlockingQueue）控制线程通信</h4><p>BlockingQueue 是一个接口，也是 Queue 的子接口。BlockingQueue 具有一个特征：当生产者线程试图向 BlockingQueue 中放入元素时，如果该队列已满，则线程被阻塞；但消费者线程试图从 BlockingQueue 中取出元素时，如果队列已空，则该线程阻塞。程序的两个线程通过交替向 BlockingQueue 中放入元素、取出元素，即可很好地控制线程的通信。</p><p>BlockingQueue 提供如下两个支持阻塞的方法：</p><ul><li>put(E e)：尝试把 E e 元素放如 BlockingQueue 中，如果该队列的元素已满，则阻塞该线程。</li><li>take()：尝试从 BlockingQueue 的头部取出元素，如果该队列的元素已空，则阻塞该线程。</li></ul><p>BlockingQueue 继承了 Queue 接口，当然也可以使用 Queue 接口中的方法，这些方法归纳起来可以分为如下三组：</p><ul><li>在队列尾部插入元素，包括 add(E e)、offer(E e)、put(E e) 方法，当该队列已满时，这三个方法分别会抛出异常、返回 false、阻塞队列。</li><li>在队列头部删除并返回删除的元素。包括 remove()、poll()、take() 方法，当该队列已空时，这三个方法分别会抛出异常、返回 false、阻塞队列。</li><li>在队列头部取出但不删除元素。包括 element() 和 peek() 方法，当队列已空时，这两个方法分别抛出异常、返回 false。</li></ul><p>BlockingQueue 接口包含如下 5 个实现类：</p><ul><li>ArrayBlockingQueue：基于数组实现的 BlockingQueue 队列。</li><li>LinkedBlockingQueue：基于链表实现的 BlockingQueue 队列。</li><li>PriorityBlockingQueue：它并不是保准的阻塞队列，该队列调用remove()、poll()、take() 等方法提取出元素时，并不是取出队列中存在时间最长的元素，而是队列中最小的元素。它判断元素的大小即可根据元素（实现Comparable接口）的本身大小来自然排序，也可使用 Comparator 进行定制排序。</li><li>SynchronousQueue：同步队列。对该队列的存、取操作必须交替进行。</li><li>DelayQueue：它是一个特殊的 BlockingQueue，底层基于 PriorityBlockingQueue 实现，不过，DelayQueue 要求集合元素都实现 Delay 接口（该接口里只有一个 long getDelay() 方法），DelayQueue 根据集合元素的 getDelay() 方法的返回值进行排序。</li></ul><p>Copy 的一个示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">import java.util.concurrent.ArrayBlockingQueue;</div><div class="line">import java.util.concurrent.BlockingQueue;</div><div class="line">public class BlockingQueueTest &#123;</div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        //创建一个容量为1的BlockingQueue</div><div class="line">        BlockingQueue&lt;String&gt; b=new ArrayBlockingQueue&lt;&gt;(1);</div><div class="line">        //启动3个生产者线程</div><div class="line">        new Producer(b).start();</div><div class="line">        new Producer(b).start();</div><div class="line">        new Producer(b).start();</div><div class="line">        //启动一个消费者线程</div><div class="line">        new Consumer(b).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Producer extends Thread&#123;</div><div class="line">    private BlockingQueue&lt;String&gt; b;</div><div class="line">    public Producer(BlockingQueue&lt;String&gt; b)&#123;</div><div class="line">        this.b=b;</div><div class="line">    &#125;</div><div class="line">    public synchronized void run()&#123;</div><div class="line">        String [] str=new String[]&#123;</div><div class="line">            &quot;java&quot;,</div><div class="line">            &quot;struts&quot;,</div><div class="line">            &quot;Spring&quot;</div><div class="line">        &#125;;</div><div class="line">        for(int i=0;i&lt;9999999;i++)&#123;</div><div class="line">            System.out.println(getName()+&quot;生产者准备生产集合元素！&quot;);</div><div class="line">            try&#123;</div><div class="line">                b.put(str[i%3]);</div><div class="line">                sleep(1000);</div><div class="line">                //尝试放入元素，如果队列已满，则线程被阻塞</div><div class="line">            &#125;catch(Exception e)&#123;System.out.println(e);&#125;</div><div class="line">            System.out.println(getName()+&quot;生产完成：&quot;+b);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Consumer extends Thread&#123;</div><div class="line">    private BlockingQueue&lt;String&gt; b;</div><div class="line">    public Consumer(BlockingQueue&lt;String&gt; b)&#123;</div><div class="line">        this.b=b;</div><div class="line">    &#125;</div><div class="line">    public  synchronized  void run()&#123;</div><div class="line">        while(true)&#123;</div><div class="line">            System.out.println(getName()+&quot;消费者准备消费集合元素！&quot;);</div><div class="line">            try&#123;</div><div class="line">                sleep(1000);</div><div class="line">                //尝试取出元素，如果队列已空，则线程被阻塞</div><div class="line">                b.take();</div><div class="line">            &#125;catch(Exception e)&#123;System.out.println(e);&#125;</div><div class="line">            System.out.println(getName()+&quot;消费完：&quot;+b);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="六、线程池"><a href="#六、线程池" class="headerlink" title="六、线程池"></a>六、线程池</h3><hr><p>合理利用线程池能够带来三个好处。</p><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h4 id="1、使用-Executors-工厂类产生线程池"><a href="#1、使用-Executors-工厂类产生线程池" class="headerlink" title="1、使用 Executors 工厂类产生线程池"></a>1、使用 Executors 工厂类产生线程池</h4><p>Executor 线程池框架的最大优点是把任务的提交和执行解耦。客户端将要执行的任务封装成 Task，然后提交即可。而 Task 如何执行客户端则是透明的。具体点讲，提交一个 Callable 对象给 ExecutorService（如最常用的线程池 ThreadPoolExecutor），将得到一个 Future 对象，调用 Future 对象的 get 方法等待执行结果。线程池实现原理类结构图如下：</p><p><img src="http://www.uml-diagrams.org/examples/java-7-concurrent-executors-uml-class-diagram-example.png" alt=""></p><p>上图中涉及到的线程池内部实现原理的所有类，不利于我们理解线程池如何使用。我们先从客户端的角度出发，看看客户端使用线程池所涉及到的类结构图。</p><p><strong>由上图可知，ExecutorService</strong>是 Java 中对线程池定义的一个接口，它 <code>java.util.concurrent</code> 包中。Java API 对 ExecutorService 接口的实现有两个，所以这两个即是 Java 线程池具体实现类如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ThreadPoolExecutor</div><div class="line"> ScheduledThreadPoolExecutor</div></pre></td></tr></table></figure></p><p>除此之外，ExecutorService 还继承了 Executor接口（注意区分 Executor 接口和 Executors 工厂类），这个接口只有一个 execute() 方法。</p><p>使用 Executors 执行多线程任务的步骤如下：</p><ul><li>调用 Executors 类的静态工厂方法创建一个 ExecutorService 对象，该对象代表一个线程池；</li><li>创建 Runnable 实现类或 Callable 实现类的实例，作为线程执行任务；</li><li>调用 ExecutorService 对象的 submit() 方法来提交 Runnable 实例或 Callable 实例；</li><li>当不想提交任务时，调用 ExecutorService 对象的 shutdown() 方法来关闭线程池。</li></ul><h5 id="1-1、Executors-创建线程池的方法"><a href="#1-1、Executors-创建线程池的方法" class="headerlink" title="1.1、Executors 创建线程池的方法"></a>1.1、Executors 创建线程池的方法</h5><ol><li>newFixedThreadPool() ：<br>作用：该方法返回一个固定线程数量的线程池，该线程池中的线程数量始终不变，即不会再创建新的线程，也不会销毁已经创建好的线程，自始自终都是那几个固定的线程在工作，所以该线程池可以控制线程的最大并发数。<br>栗子：假如有一个新任务提交时，线程池中如果有空闲的线程则立即使用空闲线程来处理任务，如果没有，则会把这个新任务存在一个任务队列中，一旦有线程空闲了，则按 FIFO 方式处理任务队列中的任务。</li><li>newCachedThreadPool() ：<br>作用：该方法返回一个可以根据实际情况调整线程池中线程的数量的线程池。即该线程池中的线程数量不确定，是根据实际情况动态调整的。<br>栗子：假如该线程池中的所有线程都正在工作，而此时有新任务提交，那么将会创建新的线程去处理该任务，而此时假如之前有一些线程完成了任务，现在又有新任务提交，那么将不会创建新线程去处理，而是复用空闲的线程去处理新任务。那么此时有人有疑问了，那这样来说该线程池的线程岂不是会越集越多？其实并不会，因为线程池中的线程都有一个“保持活动时间”的参数，通过配置它，如果线程池中的空闲线程的空闲时间超过该“保存活动时间”则立刻停止该线程，而该线程池默认的“保持活动时间”为60s。</li><li>newSingleThreadExecutor() ：<br>作用：该方法返回一个只有一个线程的线程池，即每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待这一个线程空闲，当这个线程空闲了再按FIFO方式顺序执行任务队列中的任务。</li><li>newScheduledThreadPool() ：<br>作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。</li><li>newSingleThreadScheduledExecutor() ：<br>作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。只不过和上面的区别是该线程池大小为1，而上面的可以指定线程池的大小。</li></ol><blockquote><p>Executors 只是一个工厂类，它所有的方法返回的都是 ThreadPoolExecutor、ScheduledThreadPoolExecutor 这两个类的实例。</p></blockquote><h5 id="1-2、ExecutorService-方法"><a href="#1-2、ExecutorService-方法" class="headerlink" title="1.2、ExecutorService 方法"></a>1.2、ExecutorService 方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- execute(Runnable)</div><div class="line">- submit(Runnable)</div><div class="line">- submit(Callable)</div><div class="line">- invokeAny(...)</div><div class="line">- invokeAll(...)</div></pre></td></tr></table></figure><ul><li><strong>execute(Runnable)</strong></li></ul><p>这个方法接收一个 Runnable 实例，并且异步的执行，请看下面的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</div><div class="line">executorService.execute(new Runnable() &#123;</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(&quot;Asynchronous task&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">executorService.shutdown();</div></pre></td></tr></table></figure></p><ul><li><strong>submit(Runnable)</strong></li></ul><p>submit(Runnable) 和 execute(Runnable) 区别是前者可以返回一个 Future 对象，通过返回的 Future 对象，我们可以检查提交的任务是否执行完毕，请看下面执行的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Future future = executorService.submit(new Runnable() &#123;</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(&quot;Asynchronous task&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">// returns null if the task has finished correctly.</div><div class="line">future.get();</div></pre></td></tr></table></figure></p><p>如果任务执行完成，future.get() 方法会返回一个 null。</p><blockquote><p>注意，future.get() 方法会产生阻塞。</p></blockquote><ul><li><strong>submit(Callable)</strong></li></ul><p>submit(Callable) 和 submit(Runnable) 类似，也会返回一个 Future 对象，但是除此之外，submit(Callable) 接收的是一个 Callable 的实现，Callable 接口中的 call() 方法有一个返回值，可以返回任务的执行结果，而 Runnable 接口中的 run() 方法是 void 的，没有返回值。请看下面实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Future future = executorService.submit(new Callable()&#123;</div><div class="line">    public Object call() throws Exception &#123;</div><div class="line">        System.out.println(&quot;Asynchronous Callable&quot;);</div><div class="line">        return &quot;Callable Result&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">System.out.println(&quot;future.get() = &quot; + future.get());</div></pre></td></tr></table></figure></p><p>如果任务执行完成，future.get() 方法会返回 Callable 任务的执行结果。另外，future.get() 方法会产生阻塞。</p><ul><li><strong>invokeAny(…)</strong></li></ul><p>invokeAny(…) 方法接收的是一个 Callable 的集合，执行这个方法不会返回 Future，但是会返回所有 Callable 任务中其中一个任务的执行结果。这个方法也无法保证返回的是哪个任务的执行结果，反正是其中的某一个。请看下面实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</div><div class="line">Set&lt;Callable&lt;String&gt;&gt; callables = new HashSet&lt;Callable&lt;String&gt;&gt;();</div><div class="line"></div><div class="line">callables.add(new Callable&lt;String&gt;() &#123;</div><div class="line">    public String call() throws Exception &#123;</div><div class="line">        return &quot;Task 1&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">callables.add(new Callable&lt;String&gt;() &#123;</div><div class="line">    public String call() throws Exception &#123;</div><div class="line">        return &quot;Task 2&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">callables.add(new Callable&lt;String&gt;() &#123;</div><div class="line">    public String call() throws Exception &#123;</div><div class="line">        return &quot;Task 3&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">String result = executorService.invokeAny(callables);</div><div class="line">System.out.println(&quot;result = &quot; + result);</div><div class="line">executorService.shutdown();</div></pre></td></tr></table></figure></p><p>大家可以尝试执行上面代码，每次执行都会返回一个结果，并且返回的结果是变化的，可能会返回“Task2”也可是“Task1”或者其它。</p><ul><li><strong>invokeAll(…)</strong></li></ul><p>invokeAll(…) 与 invokeAny(…) 类似也是接收一个 Callable 集合，但是前者执行之后会返回一个 Future 的 List，其中对应着每个 Callable任务执行后的 Future 对象。情况下面这个实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</div><div class="line">Set&lt;Callable&lt;String&gt;&gt; callables = new HashSet&lt;Callable&lt;String&gt;&gt;();</div><div class="line"></div><div class="line">callables.add(new Callable&lt;String&gt;() &#123;</div><div class="line">    public String call() throws Exception &#123;</div><div class="line">        return &quot;Task 1&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">callables.add(new Callable&lt;String&gt;() &#123;</div><div class="line">    public String call() throws Exception &#123;</div><div class="line">        return &quot;Task 2&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">callables.add(new Callable&lt;String&gt;() &#123;</div><div class="line">    public String call() throws Exception &#123;</div><div class="line">        return &quot;Task 3&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">List&lt;Future&lt;String&gt;&gt; futures = executorService.invokeAll(callables);</div><div class="line">for(Future&lt;String&gt; future : futures)&#123;</div><div class="line">    System.out.println(&quot;future.get = &quot; + future.get());</div><div class="line">&#125;</div><div class="line">executorService.shutdown();</div></pre></td></tr></table></figure><h5 id="1-3、ExecutorService-关闭方法"><a href="#1-3、ExecutorService-关闭方法" class="headerlink" title="1.3、ExecutorService 关闭方法"></a>1.3、ExecutorService 关闭方法</h5><p>当我们使用完成 ExecutorService 之后应该关闭它，否则它里面的线程会一直处于运行状态。举个例子，如果的应用程序是通过 main() 方法启动的，在这个 main() 退出之后，如果应用程序中的 ExecutorService 没有关闭，这个应用将一直运行。之所以会出现这种情况，是因为 ExecutorService 中运行的线程会阻止 JVM 关闭。</p><p>要关闭 ExecutorService 中执行的线程，我们可以调用 ExecutorService.shutdown() 方法。在调用 shutdown() 方法之后，ExecutorService 不会立即关闭，但是它不再接收新的任务，直到当前所有线程执行完成才会关闭，所有在 shutdown() 执行之前提交的任务都会被执行。</p><p>如果想立即关闭 ExecutorService，我们可以调用 ExecutorService.shutdownNow() 方法。这个动作将跳过所有正在执行的任务和被提交还没有执行的任务。但是它并不对正在执行的任务做任何保证，有可能它们都会停止，也有可能执行完成。</p><h4 id="2、ForkJoinPool-线程池"><a href="#2、ForkJoinPool-线程池" class="headerlink" title="2、ForkJoinPool 线程池"></a>2、ForkJoinPool 线程池</h4><p>在 Java 8 中，引入了自动并行化的概念。它能够让一部分 Java 代码自动地以并行的方式执行，前提是使用了 ForkJoinPool。</p><p>ForkJoinPool 同 ThreadPoolExecutor 一样，也实现了 Executor 和 ExecutorService 接口。它使用了一个无限队列来保存需要执行的任务，而线程的数量则是通过构造函数传入，如果没有向构造函数中传入希望的线程数量，那么当前计算机可用的CPU数量会被设置为线程数量作为默认值。</p><p>ForkJoinPool 主要用来使用分治法（Divide-and-Conquer Algorithm）来解决问题。典型的应用比如快速排序算法。这里的要点在于，ForkJoinPool 需要使用相对少的线程来处理大量的任务。比如要对 1000 万个数据进行排序，那么会将这个任务分割成两个 500 万的排序任务和一个针对这两组 500 万数据的合并任务。以此类推，对于 500 万的数据也会做出同样的分割处理，到最后会设置一个阈值来规定当数据规模到多少时，停止这样的分割处理。比如，当元素的数量小于 10 时，会停止分割，转而使用插入排序对它们进行排序。那么到最后，所有的任务加起来会有大概 2000000+ 个。问题的关键在于，对于一个任务而言，只有当它所有的子任务完成之后，它才能够被执行。所以当使用 ThreadPoolExecutor 时，使用分治法会存在问题，因为 ThreadPoolExecutor中 的线程无法像任务队列中再添加一个任务并且在等待该任务完成之后再继续执行。而使用 ForkJoinPool 时，就能够让其中的线程创建新的任务，并挂起当前的任务，此时线程就能够从队列中选择子任务执行。比如，我们需要统计一个 double 数组中小于 0.5 的元素的个数，那么可以使用 ForkJoinPool 进行实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class ForkJoinTest &#123;</div><div class="line">    private double[] d;</div><div class="line">    private class ForkJoinTask extends RecursiveTask &#123;</div><div class="line">        private int first;</div><div class="line">        private int last;</div><div class="line">        public ForkJoinTask(int first, int last) &#123;</div><div class="line">            this.first = first;</div><div class="line">            this.last = last;</div><div class="line">        &#125;</div><div class="line">        protected Integer compute() &#123;</div><div class="line">            int subCount;</div><div class="line">            if (last - first &lt; 10) &#123;</div><div class="line">                subCount = 0;</div><div class="line">                for (int i = first; i &lt;= last; i++) &#123;</div><div class="line">                    if (d[i] &lt; 0.5)&#123;</div><div class="line">                        subCount++;</div><div class="line">                     &#125;</div><div class="line">                &#125;</div><div class="line">             &#125; else &#123;</div><div class="line">                int mid = (first + last) /2;</div><div class="line">                ForkJoinTask left = new ForkJoinTask(first, mid);</div><div class="line">                left.fork();</div><div class="line">                ForkJoinTask right = new ForkJoinTask(mid + 1, last);</div><div class="line">                right.fork();</div><div class="line">                subCount = left.join();</div><div class="line">                subCount += right.join();</div><div class="line">            &#125;</div><div class="line">            return subCount;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ForkJoinPool pool=new ForkJoinPool();</div><div class="line">        pool.submit(new ForkJoinTask(0, 9999999));</div><div class="line">        pool.awaitTermination(2,TimeUnit.SECONDS);</div><div class="line">        System.out.println(&quot;Found &quot; + n + &quot; values&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>以上的关键是 fork() 和 join() 方法。在 ForkJoinPool 使用的线程中，会使用一个内部队列来对需要执行的任务以及子任务进行操作来保证它们的执行顺序。</p><p>使用 ThreadPoolExecutor 和 ForkJoinPool 的性能差异：</p><ul><li>使用 ForkJoinPool 能够使用数量有限的线程来完成非常多的具有父子关系的任务，比如使用 4 个线程来完成超过 200 万个任务。但是，使用 ThreadPoolExecutor 时，是不可能完成的，因为 ThreadPoolExecutor 中的 Thread 无法选择优先执行子任务，需要完成 200 万个具有父子关系的任务时，也需要 200 万个线程，显然这是不可行的。</li><li>ForkJoinPool 能够实现工作窃取（Work Stealing），在该线程池的每个线程中会维护一个队列来存放需要被执行的任务。当线程自身队列中的任务都执行完毕后，它会从别的线程中拿到未被执行的任务并帮助它执行。因此，提高了线程的利用率，从而提高了整体性能。</li><li>对于 ForkJoinPool，还有一个因素会影响它的性能，就是停止进行任务分割的那个阈值。比如在之前的快速排序中，当剩下的元素数量小于 10 的时候，就会停止子任务的创建。</li></ul><p>结论：</p><ul><li>当需要处理递归分治算法时，考虑使用ForkJoinPool；</li><li>仔细设置不再进行任务划分的阈值，这个阈值对性能有影响；</li><li>Java 8 中的一些特性会使用到 ForkJoinPool 中的通用线程池。在某些场合下，需要调整该线程池的默认的线程数量。</li></ul><h3 id="七、死锁"><a href="#七、死锁" class="headerlink" title="七、死锁"></a>七、死锁</h3><hr><p>产生死锁的四个必要条件如下。当下边的四个条件都满足时即产生死锁，即任意一个条件不满足既不会产生死锁。</p><p><strong>死锁的四个必要条件</strong></p><ul><li>互斥条件：资源不能被共享，只能被同一个进程使用</li><li>请求与保持条件：已经得到资源的进程可以申请新的资源</li><li>非剥夺条件：已经分配的资源不能从相应的进程中被强制剥夺</li><li>循环等待条件：系统中若干进程组成环路，该环路中每个进程都在+ 等待相邻进程占用的资源</li></ul><p>举个常见的死锁例子：进程 A 中包含资源 A，进程 B 中包含资源 B，A 的下一步需要资源 B，B 的下一步需要资源 A，所以它们就互相等待对方占有的资源释放，所以也就产生了一个循环等待死锁。</p><p><strong>处理死锁的方法</strong></p><ul><li>检测死锁并恢复；</li><li>资源进行动态分配；</li><li>破除上面的四种死锁条件之一；</li><li>忽略该问题，也即鸵鸟算法。当发生了什么问题时，不管他，直接跳过，无视它。</li></ul><h3 id="八、线程相关类-ThreadLocal"><a href="#八、线程相关类-ThreadLocal" class="headerlink" title="八、线程相关类 ThreadLocal"></a>八、线程相关类 ThreadLocal</h3><hr><p>ThreadLocal 它并不是一个线程，而是一个可以在每个线程中存储数据的数据存储类，通过它可以在指定的线程中存储数据，数据存储之后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到该线程的数据。 即多个线程通过同一个 ThreadLocal 获取到的东西是不一样的，就算有的时候出现的结果是一样的（偶然性，两个线程里分别存了两份相同的东西），但他们获取的本质是不同的。使用这个工具类可以简化多线程编程时的并发访问，很简洁的隔离多线程程序的竞争资源。</p><p>对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而 ThreadLocal 采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。ThreadLocal 类提供了如下的三个public方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 创建一个线程本地变量。</div><div class="line">ThreadLocal()</div><div class="line"></div><div class="line">// 返回此线程局部变量的当前线程副本中的值，</div><div class="line">// 如果这是线程第一次调用该方法，则创建并初始化此副本。</div><div class="line">T get()</div><div class="line"></div><div class="line">// 返回此线程局部变量的当前线程的初始值。 </div><div class="line">protected  T initialValue()</div></pre></td></tr></table></figure></p><p>注：ThreadLocal 和其他所有的同步机制一样，都是为了解决多线程中对于同一变量的访问冲突。值普通的同步机制中，通过对象加锁来实现多线程对同一变量的安全访问，且该变量是多线程共享的，所有需要使用这种同步机制来明确分开是在什么时候对变量进行读写，在什么时候需要锁定该对象。此种情况下，系统并没有将这个资源复制多份，而是采取安全机制来控制访问而已。ThreadLocal 只是从另一个角度解决多线程的并发访问，即将需要并发访问的资源复制多份，每个线程拥有一份资源，每个线程都有自己的资源副本。</p><p><strong><em>总结：若多个线程之间需要共享资源，以达到线程间的通信时，就使用同步机制；若仅仅需要隔离多线程之间的关系资源，则可以使用 ThreadLocal。</em></strong></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e4856ee7090c53ce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>参考文章：<a href="https://www.cnblogs.com/snow-flower/p/6114765.html" target="_blank" rel="external">Java 多线程详解</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IOUtils</title>
      <link href="/1900/01/04/01%20JAVA/04%20Java%20IOUtils/"/>
      <url>/1900/01/04/01%20JAVA/04%20Java%20IOUtils/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><hr><ul><li>copy：拷贝流。</li><li>copyLarge：拷贝较大的数据流。</li><li>read：从一个流中读取内容。</li><li>readFully：读取指定长度的流。</li><li>readLines：</li><li>contentEquals：比较两个流是否相等。</li><li>contentEqualsIgnoreEOL：比较两个流，忽略换行符。</li><li>skip：跳过指定长度的流。</li><li>skipFully：类似skip，如果忽略的长度大于现有的长度，抛出异常。</li><li>write：把数据写入到输出流中。</li><li>writeLines：</li><li>toBufferedInputStream: 把流的全部内容放在另一个流中。</li><li>toBufferedReader: 返回输入流，。</li><li>toByteArray: 返回字节数组。</li><li>toCharArray: 返回字符数组。</li><li>toInputStream: 返回输入流。</li><li>toString: 返回字符串。</li><li>ineIterator：读取流，返回迭代器。</li><li>close：关闭流。</li></ul><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div><div class="line">522</div><div class="line">523</div><div class="line">524</div><div class="line">525</div><div class="line">526</div><div class="line">527</div><div class="line">528</div><div class="line">529</div><div class="line">530</div><div class="line">531</div><div class="line">532</div><div class="line">533</div><div class="line">534</div><div class="line">535</div><div class="line">536</div><div class="line">537</div><div class="line">538</div><div class="line">539</div><div class="line">540</div><div class="line">541</div><div class="line">542</div><div class="line">543</div><div class="line">544</div><div class="line">545</div><div class="line">546</div><div class="line">547</div><div class="line">548</div><div class="line">549</div><div class="line">550</div><div class="line">551</div><div class="line">552</div><div class="line">553</div><div class="line">554</div><div class="line">555</div><div class="line">556</div><div class="line">557</div><div class="line">558</div><div class="line">559</div><div class="line">560</div><div class="line">561</div><div class="line">562</div><div class="line">563</div><div class="line">564</div><div class="line">565</div><div class="line">566</div><div class="line">567</div><div class="line">568</div><div class="line">569</div><div class="line">570</div><div class="line">571</div><div class="line">572</div><div class="line">573</div><div class="line">574</div><div class="line">575</div><div class="line">576</div><div class="line">577</div><div class="line">578</div><div class="line">579</div><div class="line">580</div><div class="line">581</div><div class="line">582</div><div class="line">583</div><div class="line">584</div><div class="line">585</div><div class="line">586</div><div class="line">587</div><div class="line">588</div><div class="line">589</div><div class="line">590</div><div class="line">591</div><div class="line">592</div><div class="line">593</div><div class="line">594</div><div class="line">595</div><div class="line">596</div><div class="line">597</div><div class="line">598</div><div class="line">599</div><div class="line">600</div><div class="line">601</div><div class="line">602</div><div class="line">603</div><div class="line">604</div><div class="line">605</div><div class="line">606</div><div class="line">607</div><div class="line">608</div><div class="line">609</div><div class="line">610</div><div class="line">611</div><div class="line">612</div><div class="line">613</div><div class="line">614</div><div class="line">615</div><div class="line">616</div><div class="line">617</div><div class="line">618</div><div class="line">619</div><div class="line">620</div><div class="line">621</div><div class="line">622</div><div class="line">623</div><div class="line">624</div><div class="line">625</div><div class="line">626</div><div class="line">627</div><div class="line">628</div><div class="line">629</div><div class="line">630</div><div class="line">631</div><div class="line">632</div><div class="line">633</div><div class="line">634</div><div class="line">635</div><div class="line">636</div><div class="line">637</div><div class="line">638</div><div class="line">639</div><div class="line">640</div><div class="line">641</div><div class="line">642</div><div class="line">643</div><div class="line">644</div><div class="line">645</div><div class="line">646</div><div class="line">647</div><div class="line">648</div><div class="line">649</div><div class="line">650</div><div class="line">651</div><div class="line">652</div><div class="line">653</div><div class="line">654</div><div class="line">655</div><div class="line">656</div><div class="line">657</div><div class="line">658</div><div class="line">659</div><div class="line">660</div><div class="line">661</div><div class="line">662</div><div class="line">663</div><div class="line">664</div><div class="line">665</div><div class="line">666</div><div class="line">667</div><div class="line">668</div><div class="line">669</div><div class="line">670</div><div class="line">671</div><div class="line">672</div><div class="line">673</div><div class="line">674</div><div class="line">675</div><div class="line">676</div><div class="line">677</div><div class="line">678</div><div class="line">679</div><div class="line">680</div><div class="line">681</div><div class="line">682</div><div class="line">683</div><div class="line">684</div><div class="line">685</div><div class="line">686</div><div class="line">687</div><div class="line">688</div><div class="line">689</div><div class="line">690</div><div class="line">691</div><div class="line">692</div><div class="line">693</div><div class="line">694</div><div class="line">695</div><div class="line">696</div><div class="line">697</div><div class="line">698</div><div class="line">699</div><div class="line">700</div><div class="line">701</div><div class="line">702</div><div class="line">703</div><div class="line">704</div><div class="line">705</div><div class="line">706</div><div class="line">707</div><div class="line">708</div><div class="line">709</div><div class="line">710</div><div class="line">711</div><div class="line">712</div><div class="line">713</div><div class="line">714</div><div class="line">715</div><div class="line">716</div><div class="line">717</div><div class="line">718</div><div class="line">719</div><div class="line">720</div><div class="line">721</div><div class="line">722</div><div class="line">723</div><div class="line">724</div><div class="line">725</div><div class="line">726</div><div class="line">727</div><div class="line">728</div><div class="line">729</div><div class="line">730</div><div class="line">731</div><div class="line">732</div><div class="line">733</div><div class="line">734</div><div class="line">735</div><div class="line">736</div><div class="line">737</div><div class="line">738</div><div class="line">739</div><div class="line">740</div><div class="line">741</div><div class="line">742</div><div class="line">743</div><div class="line">744</div><div class="line">745</div><div class="line">746</div><div class="line">747</div><div class="line">748</div><div class="line">749</div><div class="line">750</div><div class="line">751</div><div class="line">752</div><div class="line">753</div><div class="line">754</div><div class="line">755</div><div class="line">756</div><div class="line">757</div><div class="line">758</div><div class="line">759</div><div class="line">760</div><div class="line">761</div><div class="line">762</div><div class="line">763</div><div class="line">764</div><div class="line">765</div><div class="line">766</div><div class="line">767</div><div class="line">768</div><div class="line">769</div><div class="line">770</div><div class="line">771</div><div class="line">772</div><div class="line">773</div><div class="line">774</div><div class="line">775</div><div class="line">776</div><div class="line">777</div><div class="line">778</div><div class="line">779</div><div class="line">780</div><div class="line">781</div><div class="line">782</div><div class="line">783</div><div class="line">784</div><div class="line">785</div><div class="line">786</div><div class="line">787</div><div class="line">788</div><div class="line">789</div><div class="line">790</div><div class="line">791</div><div class="line">792</div><div class="line">793</div><div class="line">794</div><div class="line">795</div><div class="line">796</div><div class="line">797</div><div class="line">798</div><div class="line">799</div><div class="line">800</div><div class="line">801</div><div class="line">802</div><div class="line">803</div><div class="line">804</div><div class="line">805</div><div class="line">806</div><div class="line">807</div><div class="line">808</div><div class="line">809</div><div class="line">810</div><div class="line">811</div><div class="line">812</div><div class="line">813</div><div class="line">814</div><div class="line">815</div><div class="line">816</div><div class="line">817</div><div class="line">818</div><div class="line">819</div><div class="line">820</div><div class="line">821</div><div class="line">822</div><div class="line">823</div><div class="line">824</div><div class="line">825</div><div class="line">826</div><div class="line">827</div><div class="line">828</div><div class="line">829</div><div class="line">830</div><div class="line">831</div><div class="line">832</div><div class="line">833</div><div class="line">834</div><div class="line">835</div><div class="line">836</div><div class="line">837</div><div class="line">838</div><div class="line">839</div><div class="line">840</div><div class="line">841</div><div class="line">842</div><div class="line">843</div><div class="line">844</div><div class="line">845</div><div class="line">846</div><div class="line">847</div><div class="line">848</div><div class="line">849</div><div class="line">850</div><div class="line">851</div><div class="line">852</div><div class="line">853</div><div class="line">854</div><div class="line">855</div><div class="line">856</div><div class="line">857</div><div class="line">858</div><div class="line">859</div><div class="line">860</div><div class="line">861</div><div class="line">862</div><div class="line">863</div><div class="line">864</div><div class="line">865</div><div class="line">866</div><div class="line">867</div><div class="line">868</div><div class="line">869</div><div class="line">870</div><div class="line">871</div><div class="line">872</div><div class="line">873</div><div class="line">874</div><div class="line">875</div><div class="line">876</div><div class="line">877</div><div class="line">878</div><div class="line">879</div><div class="line">880</div><div class="line">881</div><div class="line">882</div><div class="line">883</div><div class="line">884</div><div class="line">885</div><div class="line">886</div><div class="line">887</div><div class="line">888</div><div class="line">889</div><div class="line">890</div><div class="line">891</div><div class="line">892</div><div class="line">893</div><div class="line">894</div><div class="line">895</div><div class="line">896</div><div class="line">897</div><div class="line">898</div><div class="line">899</div><div class="line">900</div><div class="line">901</div><div class="line">902</div><div class="line">903</div><div class="line">904</div><div class="line">905</div><div class="line">906</div><div class="line">907</div><div class="line">908</div><div class="line">909</div><div class="line">910</div><div class="line">911</div><div class="line">912</div><div class="line">913</div><div class="line">914</div><div class="line">915</div><div class="line">916</div><div class="line">917</div><div class="line">918</div><div class="line">919</div><div class="line">920</div><div class="line">921</div><div class="line">922</div><div class="line">923</div><div class="line">924</div><div class="line">925</div><div class="line">926</div><div class="line">927</div><div class="line">928</div><div class="line">929</div><div class="line">930</div><div class="line">931</div><div class="line">932</div><div class="line">933</div><div class="line">934</div><div class="line">935</div><div class="line">936</div><div class="line">937</div><div class="line">938</div><div class="line">939</div><div class="line">940</div><div class="line">941</div><div class="line">942</div><div class="line">943</div><div class="line">944</div><div class="line">945</div><div class="line">946</div><div class="line">947</div><div class="line">948</div><div class="line">949</div><div class="line">950</div><div class="line">951</div><div class="line">952</div><div class="line">953</div><div class="line">954</div><div class="line">955</div><div class="line">956</div><div class="line">957</div><div class="line">958</div><div class="line">959</div><div class="line">960</div><div class="line">961</div><div class="line">962</div><div class="line">963</div><div class="line">964</div><div class="line">965</div><div class="line">966</div><div class="line">967</div><div class="line">968</div><div class="line">969</div><div class="line">970</div><div class="line">971</div><div class="line">972</div><div class="line">973</div><div class="line">974</div><div class="line">975</div><div class="line">976</div><div class="line">977</div><div class="line">978</div><div class="line">979</div><div class="line">980</div><div class="line">981</div><div class="line">982</div><div class="line">983</div><div class="line">984</div><div class="line">985</div><div class="line">986</div><div class="line">987</div><div class="line">988</div><div class="line">989</div><div class="line">990</div><div class="line">991</div><div class="line">992</div><div class="line">993</div><div class="line">994</div><div class="line">995</div><div class="line">996</div><div class="line">997</div><div class="line">998</div><div class="line">999</div><div class="line">1000</div><div class="line">1001</div><div class="line">1002</div><div class="line">1003</div><div class="line">1004</div><div class="line">1005</div><div class="line">1006</div><div class="line">1007</div><div class="line">1008</div><div class="line">1009</div><div class="line">1010</div><div class="line">1011</div><div class="line">1012</div><div class="line">1013</div><div class="line">1014</div><div class="line">1015</div><div class="line">1016</div><div class="line">1017</div><div class="line">1018</div><div class="line">1019</div><div class="line">1020</div><div class="line">1021</div><div class="line">1022</div><div class="line">1023</div><div class="line">1024</div><div class="line">1025</div><div class="line">1026</div><div class="line">1027</div><div class="line">1028</div><div class="line">1029</div><div class="line">1030</div><div class="line">1031</div><div class="line">1032</div><div class="line">1033</div><div class="line">1034</div><div class="line">1035</div><div class="line">1036</div><div class="line">1037</div><div class="line">1038</div><div class="line">1039</div><div class="line">1040</div><div class="line">1041</div><div class="line">1042</div><div class="line">1043</div><div class="line">1044</div><div class="line">1045</div><div class="line">1046</div><div class="line">1047</div><div class="line">1048</div><div class="line">1049</div><div class="line">1050</div><div class="line">1051</div><div class="line">1052</div><div class="line">1053</div><div class="line">1054</div><div class="line">1055</div><div class="line">1056</div><div class="line">1057</div><div class="line">1058</div><div class="line">1059</div><div class="line">1060</div><div class="line">1061</div><div class="line">1062</div><div class="line">1063</div><div class="line">1064</div><div class="line">1065</div><div class="line">1066</div><div class="line">1067</div><div class="line">1068</div><div class="line">1069</div><div class="line">1070</div><div class="line">1071</div><div class="line">1072</div><div class="line">1073</div><div class="line">1074</div><div class="line">1075</div><div class="line">1076</div><div class="line">1077</div><div class="line">1078</div><div class="line">1079</div><div class="line">1080</div><div class="line">1081</div><div class="line">1082</div><div class="line">1083</div><div class="line">1084</div><div class="line">1085</div><div class="line">1086</div><div class="line">1087</div><div class="line">1088</div><div class="line">1089</div><div class="line">1090</div><div class="line">1091</div><div class="line">1092</div><div class="line">1093</div><div class="line">1094</div><div class="line">1095</div><div class="line">1096</div><div class="line">1097</div><div class="line">1098</div><div class="line">1099</div><div class="line">1100</div><div class="line">1101</div><div class="line">1102</div><div class="line">1103</div><div class="line">1104</div><div class="line">1105</div><div class="line">1106</div><div class="line">1107</div><div class="line">1108</div><div class="line">1109</div><div class="line">1110</div><div class="line">1111</div><div class="line">1112</div><div class="line">1113</div><div class="line">1114</div><div class="line">1115</div><div class="line">1116</div><div class="line">1117</div><div class="line">1118</div><div class="line">1119</div><div class="line">1120</div><div class="line">1121</div><div class="line">1122</div><div class="line">1123</div><div class="line">1124</div><div class="line">1125</div><div class="line">1126</div><div class="line">1127</div><div class="line">1128</div><div class="line">1129</div><div class="line">1130</div><div class="line">1131</div><div class="line">1132</div><div class="line">1133</div><div class="line">1134</div><div class="line">1135</div><div class="line">1136</div><div class="line">1137</div><div class="line">1138</div><div class="line">1139</div><div class="line">1140</div><div class="line">1141</div><div class="line">1142</div><div class="line">1143</div><div class="line">1144</div><div class="line">1145</div><div class="line">1146</div><div class="line">1147</div><div class="line">1148</div><div class="line">1149</div><div class="line">1150</div><div class="line">1151</div><div class="line">1152</div><div class="line">1153</div><div class="line">1154</div><div class="line">1155</div><div class="line">1156</div><div class="line">1157</div><div class="line">1158</div><div class="line">1159</div><div class="line">1160</div><div class="line">1161</div><div class="line">1162</div><div class="line">1163</div><div class="line">1164</div><div class="line">1165</div><div class="line">1166</div><div class="line">1167</div><div class="line">1168</div><div class="line">1169</div><div class="line">1170</div><div class="line">1171</div><div class="line">1172</div><div class="line">1173</div><div class="line">1174</div><div class="line">1175</div><div class="line">1176</div><div class="line">1177</div><div class="line">1178</div><div class="line">1179</div><div class="line">1180</div><div class="line">1181</div><div class="line">1182</div><div class="line">1183</div><div class="line">1184</div><div class="line">1185</div><div class="line">1186</div><div class="line">1187</div><div class="line">1188</div><div class="line">1189</div><div class="line">1190</div><div class="line">1191</div><div class="line">1192</div><div class="line">1193</div><div class="line">1194</div><div class="line">1195</div><div class="line">1196</div><div class="line">1197</div><div class="line">1198</div><div class="line">1199</div><div class="line">1200</div><div class="line">1201</div><div class="line">1202</div><div class="line">1203</div><div class="line">1204</div><div class="line">1205</div><div class="line">1206</div><div class="line">1207</div><div class="line">1208</div><div class="line">1209</div><div class="line">1210</div><div class="line">1211</div><div class="line">1212</div><div class="line">1213</div><div class="line">1214</div><div class="line">1215</div><div class="line">1216</div><div class="line">1217</div><div class="line">1218</div><div class="line">1219</div><div class="line">1220</div><div class="line">1221</div><div class="line">1222</div><div class="line">1223</div><div class="line">1224</div><div class="line">1225</div><div class="line">1226</div><div class="line">1227</div><div class="line">1228</div><div class="line">1229</div><div class="line">1230</div><div class="line">1231</div><div class="line">1232</div><div class="line">1233</div><div class="line">1234</div><div class="line">1235</div><div class="line">1236</div><div class="line">1237</div><div class="line">1238</div><div class="line">1239</div><div class="line">1240</div><div class="line">1241</div><div class="line">1242</div><div class="line">1243</div><div class="line">1244</div><div class="line">1245</div><div class="line">1246</div><div class="line">1247</div><div class="line">1248</div><div class="line">1249</div><div class="line">1250</div><div class="line">1251</div><div class="line">1252</div><div class="line">1253</div><div class="line">1254</div><div class="line">1255</div><div class="line">1256</div><div class="line">1257</div><div class="line">1258</div><div class="line">1259</div><div class="line">1260</div><div class="line">1261</div><div class="line">1262</div><div class="line">1263</div><div class="line">1264</div><div class="line">1265</div><div class="line">1266</div><div class="line">1267</div><div class="line">1268</div><div class="line">1269</div><div class="line">1270</div><div class="line">1271</div><div class="line">1272</div><div class="line">1273</div><div class="line">1274</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Licensed to the Apache Software Foundation (ASF) under one or more</div><div class="line"> * contributor license agreements.  See the NOTICE file distributed with</div><div class="line"> * this work for additional information regarding copyright ownership.</div><div class="line"> * The ASF licenses this file to You under the Apache License, Version 2.0</div><div class="line"> * (the &quot;License&quot;); you may not use this file except in compliance with</div><div class="line"> * the License.  You may obtain a copy of the License at</div><div class="line"> *</div><div class="line"> *      http://www.apache.org/licenses/LICENSE-2.0</div><div class="line"> *</div><div class="line"> * Unless required by applicable law or agreed to in writing, software</div><div class="line"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</div><div class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</div><div class="line"> * See the License for the specific language governing permissions and</div><div class="line"> * limitations under the License.</div><div class="line"> */</div><div class="line">package org.apache.commons.io;</div><div class="line"></div><div class="line">import java.io.BufferedInputStream;</div><div class="line">import java.io.BufferedReader;</div><div class="line">import java.io.ByteArrayInputStream;</div><div class="line">import java.io.CharArrayWriter;</div><div class="line">import java.io.File;</div><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.io.InputStreamReader;</div><div class="line">import java.io.OutputStream;</div><div class="line">import java.io.OutputStreamWriter;</div><div class="line">import java.io.PrintWriter;</div><div class="line">import java.io.Reader;</div><div class="line">import java.io.StringWriter;</div><div class="line">import java.io.Writer;</div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.Collection;</div><div class="line">import java.util.Iterator;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">import org.apache.commons.io.output.ByteArrayOutputStream;</div><div class="line"></div><div class="line">/**</div><div class="line"> * General IO stream manipulation utilities.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * This class provides static utility methods for input/output operations.</div><div class="line"> * &lt;ul&gt;</div><div class="line"> * &lt;li&gt;closeQuietly - these methods close a stream ignoring nulls and exceptions</div><div class="line"> * &lt;li&gt;toXxx/read - these methods read data from a stream</div><div class="line"> * &lt;li&gt;write - these methods write data to a stream</div><div class="line"> * &lt;li&gt;copy - these methods copy all the data from one stream to another</div><div class="line"> * &lt;li&gt;contentEquals - these methods compare the content of two streams</div><div class="line"> * &lt;/ul&gt;</div><div class="line"> * &lt;p&gt;</div><div class="line"> * The byte-to-char methods and char-to-byte methods involve a conversion step.</div><div class="line"> * Two methods are provided in each case, one that uses the platform default</div><div class="line"> * encoding and the other which allows you to specify an encoding. You are</div><div class="line"> * encouraged to always specify an encoding because relying on the platform</div><div class="line"> * default can lead to unexpected results, for example when moving from</div><div class="line"> * development to production.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * All the methods in this class that read a stream are buffered internally.</div><div class="line"> * This means that there is no cause to use a &lt;code&gt;BufferedInputStream&lt;/code&gt;</div><div class="line"> * or &lt;code&gt;BufferedReader&lt;/code&gt;. The default buffer size of 4K has been shown</div><div class="line"> * to be efficient in tests.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * Wherever possible, the methods in this class do &lt;em&gt;not&lt;/em&gt; flush or close</div><div class="line"> * the stream. This is to avoid making non-portable assumptions about the</div><div class="line"> * streams&apos; origin and further use. Thus the caller is still responsible for</div><div class="line"> * closing streams after use.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * Origin of code: Excalibur.</div><div class="line"> *</div><div class="line"> * @author Peter Donald</div><div class="line"> * @author Jeff Turner</div><div class="line"> * @author Matthew Hawthorne</div><div class="line"> * @author Stephen Colebourne</div><div class="line"> * @author Gareth Davis</div><div class="line"> * @author Ian Springer</div><div class="line"> * @author Niall Pemberton</div><div class="line"> * @author Sandy McArthur</div><div class="line"> * @version $Id: IOUtils.java 481854 2006-12-03 18:30:07Z scolebourne $</div><div class="line"> */</div><div class="line">public class IOUtils &#123;</div><div class="line">    // NOTE: This class is focussed on InputStream, OutputStream, Reader and</div><div class="line">    // Writer. Each method should take at least one of these as a parameter,</div><div class="line">    // or return one of them.</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The Unix directory separator character.</div><div class="line">     */</div><div class="line">    public static final char DIR_SEPARATOR_UNIX = &apos;/&apos;;</div><div class="line">    /**</div><div class="line">     * The Windows directory separator character.</div><div class="line">     */</div><div class="line">    public static final char DIR_SEPARATOR_WINDOWS = &apos;\\&apos;;</div><div class="line">    /**</div><div class="line">     * The system directory separator character.</div><div class="line">     */</div><div class="line">    public static final char DIR_SEPARATOR = File.separatorChar;</div><div class="line">    /**</div><div class="line">     * The Unix line separator string.</div><div class="line">     */</div><div class="line">    public static final String LINE_SEPARATOR_UNIX = &quot;\n&quot;;</div><div class="line">    /**</div><div class="line">     * The Windows line separator string.</div><div class="line">     */</div><div class="line">    public static final String LINE_SEPARATOR_WINDOWS = &quot;\r\n&quot;;</div><div class="line">    /**</div><div class="line">     * The system line separator string.</div><div class="line">     */</div><div class="line">    public static final String LINE_SEPARATOR;</div><div class="line">    static &#123;</div><div class="line">        // avoid security issues</div><div class="line">        StringWriter buf = new StringWriter(4);</div><div class="line">        PrintWriter out = new PrintWriter(buf);</div><div class="line">        out.println();</div><div class="line">        LINE_SEPARATOR = buf.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The default buffer size to use.</div><div class="line">     */</div><div class="line">    private static final int DEFAULT_BUFFER_SIZE = 1024 * 4;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Instances should NOT be constructed in standard programming.</div><div class="line">     */</div><div class="line">    public IOUtils() &#123;</div><div class="line">        super();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //-----------------------------------------------------------------------</div><div class="line">    /**</div><div class="line">     * Unconditionally close an &lt;code&gt;Reader&lt;/code&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Equivalent to &#123;@link Reader#close()&#125;, except any exceptions will be ignored.</div><div class="line">     * This is typically used in finally blocks.</div><div class="line">     *</div><div class="line">     * @param input  the Reader to close, may be null or already closed</div><div class="line">     */</div><div class="line">    public static void closeQuietly(Reader input) &#123;</div><div class="line">        try &#123;</div><div class="line">            if (input != null) &#123;</div><div class="line">                input.close();</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException ioe) &#123;</div><div class="line">            // ignore</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Unconditionally close a &lt;code&gt;Writer&lt;/code&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Equivalent to &#123;@link Writer#close()&#125;, except any exceptions will be ignored.</div><div class="line">     * This is typically used in finally blocks.</div><div class="line">     *</div><div class="line">     * @param output  the Writer to close, may be null or already closed</div><div class="line">     */</div><div class="line">    public static void closeQuietly(Writer output) &#123;</div><div class="line">        try &#123;</div><div class="line">            if (output != null) &#123;</div><div class="line">                output.close();</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException ioe) &#123;</div><div class="line">            // ignore</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Unconditionally close an &lt;code&gt;InputStream&lt;/code&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Equivalent to &#123;@link InputStream#close()&#125;, except any exceptions will be ignored.</div><div class="line">     * This is typically used in finally blocks.</div><div class="line">     *</div><div class="line">     * @param input  the InputStream to close, may be null or already closed</div><div class="line">     */</div><div class="line">    public static void closeQuietly(InputStream input) &#123;</div><div class="line">        try &#123;</div><div class="line">            if (input != null) &#123;</div><div class="line">                input.close();</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException ioe) &#123;</div><div class="line">            // ignore</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Unconditionally close an &lt;code&gt;OutputStream&lt;/code&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Equivalent to &#123;@link OutputStream#close()&#125;, except any exceptions will be ignored.</div><div class="line">     * This is typically used in finally blocks.</div><div class="line">     *</div><div class="line">     * @param output  the OutputStream to close, may be null or already closed</div><div class="line">     */</div><div class="line">    public static void closeQuietly(OutputStream output) &#123;</div><div class="line">        try &#123;</div><div class="line">            if (output != null) &#123;</div><div class="line">                output.close();</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException ioe) &#123;</div><div class="line">            // ignore</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // read toByteArray</div><div class="line">    //-----------------------------------------------------------------------</div><div class="line">    /**</div><div class="line">     * Get the contents of an &lt;code&gt;InputStream&lt;/code&gt; as a &lt;code&gt;byte[]&lt;/code&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method buffers the input internally, so there is no need to use a</div><div class="line">     * &lt;code&gt;BufferedInputStream&lt;/code&gt;.</div><div class="line">     *</div><div class="line">     * @param input  the &lt;code&gt;InputStream&lt;/code&gt; to read from</div><div class="line">     * @return the requested byte array</div><div class="line">     * @throws NullPointerException if the input is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     */</div><div class="line">    public static byte[] toByteArray(InputStream input) throws IOException &#123;</div><div class="line">        ByteArrayOutputStream output = new ByteArrayOutputStream();</div><div class="line">        copy(input, output);</div><div class="line">        return output.toByteArray();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Get the contents of a &lt;code&gt;Reader&lt;/code&gt; as a &lt;code&gt;byte[]&lt;/code&gt;</div><div class="line">     * using the default character encoding of the platform.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method buffers the input internally, so there is no need to use a</div><div class="line">     * &lt;code&gt;BufferedReader&lt;/code&gt;.</div><div class="line">     *</div><div class="line">     * @param input  the &lt;code&gt;Reader&lt;/code&gt; to read from</div><div class="line">     * @return the requested byte array</div><div class="line">     * @throws NullPointerException if the input is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     */</div><div class="line">    public static byte[] toByteArray(Reader input) throws IOException &#123;</div><div class="line">        ByteArrayOutputStream output = new ByteArrayOutputStream();</div><div class="line">        copy(input, output);</div><div class="line">        return output.toByteArray();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Get the contents of a &lt;code&gt;Reader&lt;/code&gt; as a &lt;code&gt;byte[]&lt;/code&gt;</div><div class="line">     * using the specified character encoding.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Character encoding names can be found at</div><div class="line">     * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method buffers the input internally, so there is no need to use a</div><div class="line">     * &lt;code&gt;BufferedReader&lt;/code&gt;.</div><div class="line">     *</div><div class="line">     * @param input  the &lt;code&gt;Reader&lt;/code&gt; to read from</div><div class="line">     * @param encoding  the encoding to use, null means platform default</div><div class="line">     * @return the requested byte array</div><div class="line">     * @throws NullPointerException if the input is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static byte[] toByteArray(Reader input, String encoding)</div><div class="line">            throws IOException &#123;</div><div class="line">        ByteArrayOutputStream output = new ByteArrayOutputStream();</div><div class="line">        copy(input, output, encoding);</div><div class="line">        return output.toByteArray();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Get the contents of a &lt;code&gt;String&lt;/code&gt; as a &lt;code&gt;byte[]&lt;/code&gt;</div><div class="line">     * using the default character encoding of the platform.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This is the same as &#123;@link String#getBytes()&#125;.</div><div class="line">     *</div><div class="line">     * @param input  the &lt;code&gt;String&lt;/code&gt; to convert</div><div class="line">     * @return the requested byte array</div><div class="line">     * @throws NullPointerException if the input is null</div><div class="line">     * @throws IOException if an I/O error occurs (never occurs)</div><div class="line">     * @deprecated Use &#123;@link String#getBytes()&#125;</div><div class="line">     */</div><div class="line">    public static byte[] toByteArray(String input) throws IOException &#123;</div><div class="line">        return input.getBytes();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // read char[]</div><div class="line">    //-----------------------------------------------------------------------</div><div class="line">    /**</div><div class="line">     * Get the contents of an &lt;code&gt;InputStream&lt;/code&gt; as a character array</div><div class="line">     * using the default character encoding of the platform.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method buffers the input internally, so there is no need to use a</div><div class="line">     * &lt;code&gt;BufferedInputStream&lt;/code&gt;.</div><div class="line">     *</div><div class="line">     * @param is  the &lt;code&gt;InputStream&lt;/code&gt; to read from</div><div class="line">     * @return the requested character array</div><div class="line">     * @throws NullPointerException if the input is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static char[] toCharArray(InputStream is) throws IOException &#123;</div><div class="line">        CharArrayWriter output = new CharArrayWriter();</div><div class="line">        copy(is, output);</div><div class="line">        return output.toCharArray();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Get the contents of an &lt;code&gt;InputStream&lt;/code&gt; as a character array</div><div class="line">     * using the specified character encoding.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Character encoding names can be found at</div><div class="line">     * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method buffers the input internally, so there is no need to use a</div><div class="line">     * &lt;code&gt;BufferedInputStream&lt;/code&gt;.</div><div class="line">     *</div><div class="line">     * @param is  the &lt;code&gt;InputStream&lt;/code&gt; to read from</div><div class="line">     * @param encoding  the encoding to use, null means platform default</div><div class="line">     * @return the requested character array</div><div class="line">     * @throws NullPointerException if the input is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static char[] toCharArray(InputStream is, String encoding)</div><div class="line">            throws IOException &#123;</div><div class="line">        CharArrayWriter output = new CharArrayWriter();</div><div class="line">        copy(is, output, encoding);</div><div class="line">        return output.toCharArray();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Get the contents of a &lt;code&gt;Reader&lt;/code&gt; as a character array.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method buffers the input internally, so there is no need to use a</div><div class="line">     * &lt;code&gt;BufferedReader&lt;/code&gt;.</div><div class="line">     *</div><div class="line">     * @param input  the &lt;code&gt;Reader&lt;/code&gt; to read from</div><div class="line">     * @return the requested character array</div><div class="line">     * @throws NullPointerException if the input is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static char[] toCharArray(Reader input) throws IOException &#123;</div><div class="line">        CharArrayWriter sw = new CharArrayWriter();</div><div class="line">        copy(input, sw);</div><div class="line">        return sw.toCharArray();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // read toString</div><div class="line">    //-----------------------------------------------------------------------</div><div class="line">    /**</div><div class="line">     * Get the contents of an &lt;code&gt;InputStream&lt;/code&gt; as a String</div><div class="line">     * using the default character encoding of the platform.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method buffers the input internally, so there is no need to use a</div><div class="line">     * &lt;code&gt;BufferedInputStream&lt;/code&gt;.</div><div class="line">     *</div><div class="line">     * @param input  the &lt;code&gt;InputStream&lt;/code&gt; to read from</div><div class="line">     * @return the requested String</div><div class="line">     * @throws NullPointerException if the input is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     */</div><div class="line">    public static String toString(InputStream input) throws IOException &#123;</div><div class="line">        StringWriter sw = new StringWriter();</div><div class="line">        copy(input, sw);</div><div class="line">        return sw.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Get the contents of an &lt;code&gt;InputStream&lt;/code&gt; as a String</div><div class="line">     * using the specified character encoding.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Character encoding names can be found at</div><div class="line">     * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method buffers the input internally, so there is no need to use a</div><div class="line">     * &lt;code&gt;BufferedInputStream&lt;/code&gt;.</div><div class="line">     *</div><div class="line">     * @param input  the &lt;code&gt;InputStream&lt;/code&gt; to read from</div><div class="line">     * @param encoding  the encoding to use, null means platform default</div><div class="line">     * @return the requested String</div><div class="line">     * @throws NullPointerException if the input is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     */</div><div class="line">    public static String toString(InputStream input, String encoding)</div><div class="line">            throws IOException &#123;</div><div class="line">        StringWriter sw = new StringWriter();</div><div class="line">        copy(input, sw, encoding);</div><div class="line">        return sw.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Get the contents of a &lt;code&gt;Reader&lt;/code&gt; as a String.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method buffers the input internally, so there is no need to use a</div><div class="line">     * &lt;code&gt;BufferedReader&lt;/code&gt;.</div><div class="line">     *</div><div class="line">     * @param input  the &lt;code&gt;Reader&lt;/code&gt; to read from</div><div class="line">     * @return the requested String</div><div class="line">     * @throws NullPointerException if the input is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     */</div><div class="line">    public static String toString(Reader input) throws IOException &#123;</div><div class="line">        StringWriter sw = new StringWriter();</div><div class="line">        copy(input, sw);</div><div class="line">        return sw.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Get the contents of a &lt;code&gt;byte[]&lt;/code&gt; as a String</div><div class="line">     * using the default character encoding of the platform.</div><div class="line">     *</div><div class="line">     * @param input the byte array to read from</div><div class="line">     * @return the requested String</div><div class="line">     * @throws NullPointerException if the input is null</div><div class="line">     * @throws IOException if an I/O error occurs (never occurs)</div><div class="line">     * @deprecated Use &#123;@link String#String(byte[])&#125;</div><div class="line">     */</div><div class="line">    public static String toString(byte[] input) throws IOException &#123;</div><div class="line">        return new String(input);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Get the contents of a &lt;code&gt;byte[]&lt;/code&gt; as a String</div><div class="line">     * using the specified character encoding.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Character encoding names can be found at</div><div class="line">     * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;.</div><div class="line">     *</div><div class="line">     * @param input the byte array to read from</div><div class="line">     * @param encoding  the encoding to use, null means platform default</div><div class="line">     * @return the requested String</div><div class="line">     * @throws NullPointerException if the input is null</div><div class="line">     * @throws IOException if an I/O error occurs (never occurs)</div><div class="line">     * @deprecated Use &#123;@link String#String(byte[],String)&#125;</div><div class="line">     */</div><div class="line">    public static String toString(byte[] input, String encoding)</div><div class="line">            throws IOException &#123;</div><div class="line">        if (encoding == null) &#123;</div><div class="line">            return new String(input);</div><div class="line">        &#125; else &#123;</div><div class="line">            return new String(input, encoding);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // readLines</div><div class="line">    //-----------------------------------------------------------------------</div><div class="line">    /**</div><div class="line">     * Get the contents of an &lt;code&gt;InputStream&lt;/code&gt; as a list of Strings,</div><div class="line">     * one entry per line, using the default character encoding of the platform.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method buffers the input internally, so there is no need to use a</div><div class="line">     * &lt;code&gt;BufferedInputStream&lt;/code&gt;.</div><div class="line">     *</div><div class="line">     * @param input  the &lt;code&gt;InputStream&lt;/code&gt; to read from, not null</div><div class="line">     * @return the list of Strings, never null</div><div class="line">     * @throws NullPointerException if the input is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static List readLines(InputStream input) throws IOException &#123;</div><div class="line">        InputStreamReader reader = new InputStreamReader(input);</div><div class="line">        return readLines(reader);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Get the contents of an &lt;code&gt;InputStream&lt;/code&gt; as a list of Strings,</div><div class="line">     * one entry per line, using the specified character encoding.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Character encoding names can be found at</div><div class="line">     * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method buffers the input internally, so there is no need to use a</div><div class="line">     * &lt;code&gt;BufferedInputStream&lt;/code&gt;.</div><div class="line">     *</div><div class="line">     * @param input  the &lt;code&gt;InputStream&lt;/code&gt; to read from, not null</div><div class="line">     * @param encoding  the encoding to use, null means platform default</div><div class="line">     * @return the list of Strings, never null</div><div class="line">     * @throws NullPointerException if the input is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static List readLines(InputStream input, String encoding) throws IOException &#123;</div><div class="line">        if (encoding == null) &#123;</div><div class="line">            return readLines(input);</div><div class="line">        &#125; else &#123;</div><div class="line">            InputStreamReader reader = new InputStreamReader(input, encoding);</div><div class="line">            return readLines(reader);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Get the contents of a &lt;code&gt;Reader&lt;/code&gt; as a list of Strings,</div><div class="line">     * one entry per line.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method buffers the input internally, so there is no need to use a</div><div class="line">     * &lt;code&gt;BufferedReader&lt;/code&gt;.</div><div class="line">     *</div><div class="line">     * @param input  the &lt;code&gt;Reader&lt;/code&gt; to read from, not null</div><div class="line">     * @return the list of Strings, never null</div><div class="line">     * @throws NullPointerException if the input is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static List readLines(Reader input) throws IOException &#123;</div><div class="line">        BufferedReader reader = new BufferedReader(input);</div><div class="line">        List list = new ArrayList();</div><div class="line">        String line = reader.readLine();</div><div class="line">        while (line != null) &#123;</div><div class="line">            list.add(line);</div><div class="line">            line = reader.readLine();</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // lineIterator</div><div class="line">    //-----------------------------------------------------------------------</div><div class="line">    /**</div><div class="line">     * Return an Iterator for the lines in a &lt;code&gt;Reader&lt;/code&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * &lt;code&gt;LineIterator&lt;/code&gt; holds a reference to the open</div><div class="line">     * &lt;code&gt;Reader&lt;/code&gt; specified here. When you have finished with the</div><div class="line">     * iterator you should close the reader to free internal resources.</div><div class="line">     * This can be done by closing the reader directly, or by calling</div><div class="line">     * &#123;@link LineIterator#close()&#125; or &#123;@link LineIterator#closeQuietly(LineIterator)&#125;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * The recommended usage pattern is:</div><div class="line">     * &lt;pre&gt;</div><div class="line">     * try &#123;</div><div class="line">     *   LineIterator it = IOUtils.lineIterator(reader);</div><div class="line">     *   while (it.hasNext()) &#123;</div><div class="line">     *     String line = it.nextLine();</div><div class="line">     *     /// do something with line</div><div class="line">     *   &#125;</div><div class="line">     * &#125; finally &#123;</div><div class="line">     *   IOUtils.closeQuietly(reader);</div><div class="line">     * &#125;</div><div class="line">     * &lt;/pre&gt;</div><div class="line">     *</div><div class="line">     * @param reader  the &lt;code&gt;Reader&lt;/code&gt; to read from, not null</div><div class="line">     * @return an Iterator of the lines in the reader, never null</div><div class="line">     * @throws IllegalArgumentException if the reader is null</div><div class="line">     * @since Commons IO 1.2</div><div class="line">     */</div><div class="line">    public static LineIterator lineIterator(Reader reader) &#123;</div><div class="line">        return new LineIterator(reader);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Return an Iterator for the lines in an &lt;code&gt;InputStream&lt;/code&gt;, using</div><div class="line">     * the character encoding specified (or default encoding if null).</div><div class="line">     * &lt;p&gt;</div><div class="line">     * &lt;code&gt;LineIterator&lt;/code&gt; holds a reference to the open</div><div class="line">     * &lt;code&gt;InputStream&lt;/code&gt; specified here. When you have finished with</div><div class="line">     * the iterator you should close the stream to free internal resources.</div><div class="line">     * This can be done by closing the stream directly, or by calling</div><div class="line">     * &#123;@link LineIterator#close()&#125; or &#123;@link LineIterator#closeQuietly(LineIterator)&#125;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * The recommended usage pattern is:</div><div class="line">     * &lt;pre&gt;</div><div class="line">     * try &#123;</div><div class="line">     *   LineIterator it = IOUtils.lineIterator(stream, &quot;UTF-8&quot;);</div><div class="line">     *   while (it.hasNext()) &#123;</div><div class="line">     *     String line = it.nextLine();</div><div class="line">     *     /// do something with line</div><div class="line">     *   &#125;</div><div class="line">     * &#125; finally &#123;</div><div class="line">     *   IOUtils.closeQuietly(stream);</div><div class="line">     * &#125;</div><div class="line">     * &lt;/pre&gt;</div><div class="line">     *</div><div class="line">     * @param input  the &lt;code&gt;InputStream&lt;/code&gt; to read from, not null</div><div class="line">     * @param encoding  the encoding to use, null means platform default</div><div class="line">     * @return an Iterator of the lines in the reader, never null</div><div class="line">     * @throws IllegalArgumentException if the input is null</div><div class="line">     * @throws IOException if an I/O error occurs, such as if the encoding is invalid</div><div class="line">     * @since Commons IO 1.2</div><div class="line">     */</div><div class="line">    public static LineIterator lineIterator(InputStream input, String encoding)</div><div class="line">            throws IOException &#123;</div><div class="line">        Reader reader = null;</div><div class="line">        if (encoding == null) &#123;</div><div class="line">            reader = new InputStreamReader(input);</div><div class="line">        &#125; else &#123;</div><div class="line">            reader = new InputStreamReader(input, encoding);</div><div class="line">        &#125;</div><div class="line">        return new LineIterator(reader);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //-----------------------------------------------------------------------</div><div class="line">    /**</div><div class="line">     * Convert the specified string to an input stream, encoded as bytes</div><div class="line">     * using the default character encoding of the platform.</div><div class="line">     *</div><div class="line">     * @param input the string to convert</div><div class="line">     * @return an input stream</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static InputStream toInputStream(String input) &#123;</div><div class="line">        byte[] bytes = input.getBytes();</div><div class="line">        return new ByteArrayInputStream(bytes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Convert the specified string to an input stream, encoded as bytes</div><div class="line">     * using the specified character encoding.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Character encoding names can be found at</div><div class="line">     * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;.</div><div class="line">     *</div><div class="line">     * @param input the string to convert</div><div class="line">     * @param encoding the encoding to use, null means platform default</div><div class="line">     * @throws IOException if the encoding is invalid</div><div class="line">     * @return an input stream</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static InputStream toInputStream(String input, String encoding) throws IOException &#123;</div><div class="line">        byte[] bytes = encoding != null ? input.getBytes(encoding) : input.getBytes();</div><div class="line">        return new ByteArrayInputStream(bytes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // write byte[]</div><div class="line">    //-----------------------------------------------------------------------</div><div class="line">    /**</div><div class="line">     * Writes bytes from a &lt;code&gt;byte[]&lt;/code&gt; to an &lt;code&gt;OutputStream&lt;/code&gt;.</div><div class="line">     *</div><div class="line">     * @param data  the byte array to write, do not modify during output,</div><div class="line">     * null ignored</div><div class="line">     * @param output  the &lt;code&gt;OutputStream&lt;/code&gt; to write to</div><div class="line">     * @throws NullPointerException if output is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static void write(byte[] data, OutputStream output)</div><div class="line">            throws IOException &#123;</div><div class="line">        if (data != null) &#123;</div><div class="line">            output.write(data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Writes bytes from a &lt;code&gt;byte[]&lt;/code&gt; to chars on a &lt;code&gt;Writer&lt;/code&gt;</div><div class="line">     * using the default character encoding of the platform.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method uses &#123;@link String#String(byte[])&#125;.</div><div class="line">     *</div><div class="line">     * @param data  the byte array to write, do not modify during output,</div><div class="line">     * null ignored</div><div class="line">     * @param output  the &lt;code&gt;Writer&lt;/code&gt; to write to</div><div class="line">     * @throws NullPointerException if output is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static void write(byte[] data, Writer output) throws IOException &#123;</div><div class="line">        if (data != null) &#123;</div><div class="line">            output.write(new String(data));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Writes bytes from a &lt;code&gt;byte[]&lt;/code&gt; to chars on a &lt;code&gt;Writer&lt;/code&gt;</div><div class="line">     * using the specified character encoding.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Character encoding names can be found at</div><div class="line">     * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method uses &#123;@link String#String(byte[], String)&#125;.</div><div class="line">     *</div><div class="line">     * @param data  the byte array to write, do not modify during output,</div><div class="line">     * null ignored</div><div class="line">     * @param output  the &lt;code&gt;Writer&lt;/code&gt; to write to</div><div class="line">     * @param encoding  the encoding to use, null means platform default</div><div class="line">     * @throws NullPointerException if output is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static void write(byte[] data, Writer output, String encoding)</div><div class="line">            throws IOException &#123;</div><div class="line">        if (data != null) &#123;</div><div class="line">            if (encoding == null) &#123;</div><div class="line">                write(data, output);</div><div class="line">            &#125; else &#123;</div><div class="line">                output.write(new String(data, encoding));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // write char[]</div><div class="line">    //-----------------------------------------------------------------------</div><div class="line">    /**</div><div class="line">     * Writes chars from a &lt;code&gt;char[]&lt;/code&gt; to a &lt;code&gt;Writer&lt;/code&gt;</div><div class="line">     * using the default character encoding of the platform.</div><div class="line">     *</div><div class="line">     * @param data  the char array to write, do not modify during output,</div><div class="line">     * null ignored</div><div class="line">     * @param output  the &lt;code&gt;Writer&lt;/code&gt; to write to</div><div class="line">     * @throws NullPointerException if output is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static void write(char[] data, Writer output) throws IOException &#123;</div><div class="line">        if (data != null) &#123;</div><div class="line">            output.write(data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Writes chars from a &lt;code&gt;char[]&lt;/code&gt; to bytes on an</div><div class="line">     * &lt;code&gt;OutputStream&lt;/code&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method uses &#123;@link String#String(char[])&#125; and</div><div class="line">     * &#123;@link String#getBytes()&#125;.</div><div class="line">     *</div><div class="line">     * @param data  the char array to write, do not modify during output,</div><div class="line">     * null ignored</div><div class="line">     * @param output  the &lt;code&gt;OutputStream&lt;/code&gt; to write to</div><div class="line">     * @throws NullPointerException if output is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static void write(char[] data, OutputStream output)</div><div class="line">            throws IOException &#123;</div><div class="line">        if (data != null) &#123;</div><div class="line">            output.write(new String(data).getBytes());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Writes chars from a &lt;code&gt;char[]&lt;/code&gt; to bytes on an</div><div class="line">     * &lt;code&gt;OutputStream&lt;/code&gt; using the specified character encoding.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Character encoding names can be found at</div><div class="line">     * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method uses &#123;@link String#String(char[])&#125; and</div><div class="line">     * &#123;@link String#getBytes(String)&#125;.</div><div class="line">     *</div><div class="line">     * @param data  the char array to write, do not modify during output,</div><div class="line">     * null ignored</div><div class="line">     * @param output  the &lt;code&gt;OutputStream&lt;/code&gt; to write to</div><div class="line">     * @param encoding  the encoding to use, null means platform default</div><div class="line">     * @throws NullPointerException if output is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static void write(char[] data, OutputStream output, String encoding)</div><div class="line">            throws IOException &#123;</div><div class="line">        if (data != null) &#123;</div><div class="line">            if (encoding == null) &#123;</div><div class="line">                write(data, output);</div><div class="line">            &#125; else &#123;</div><div class="line">                output.write(new String(data).getBytes(encoding));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // write String</div><div class="line">    //-----------------------------------------------------------------------</div><div class="line">    /**</div><div class="line">     * Writes chars from a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;Writer&lt;/code&gt;.</div><div class="line">     *</div><div class="line">     * @param data  the &lt;code&gt;String&lt;/code&gt; to write, null ignored</div><div class="line">     * @param output  the &lt;code&gt;Writer&lt;/code&gt; to write to</div><div class="line">     * @throws NullPointerException if output is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static void write(String data, Writer output) throws IOException &#123;</div><div class="line">        if (data != null) &#123;</div><div class="line">            output.write(data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Writes chars from a &lt;code&gt;String&lt;/code&gt; to bytes on an</div><div class="line">     * &lt;code&gt;OutputStream&lt;/code&gt; using the default character encoding of the</div><div class="line">     * platform.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method uses &#123;@link String#getBytes()&#125;.</div><div class="line">     *</div><div class="line">     * @param data  the &lt;code&gt;String&lt;/code&gt; to write, null ignored</div><div class="line">     * @param output  the &lt;code&gt;OutputStream&lt;/code&gt; to write to</div><div class="line">     * @throws NullPointerException if output is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static void write(String data, OutputStream output)</div><div class="line">            throws IOException &#123;</div><div class="line">        if (data != null) &#123;</div><div class="line">            output.write(data.getBytes());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Writes chars from a &lt;code&gt;String&lt;/code&gt; to bytes on an</div><div class="line">     * &lt;code&gt;OutputStream&lt;/code&gt; using the specified character encoding.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Character encoding names can be found at</div><div class="line">     * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method uses &#123;@link String#getBytes(String)&#125;.</div><div class="line">     *</div><div class="line">     * @param data  the &lt;code&gt;String&lt;/code&gt; to write, null ignored</div><div class="line">     * @param output  the &lt;code&gt;OutputStream&lt;/code&gt; to write to</div><div class="line">     * @param encoding  the encoding to use, null means platform default</div><div class="line">     * @throws NullPointerException if output is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static void write(String data, OutputStream output, String encoding)</div><div class="line">            throws IOException &#123;</div><div class="line">        if (data != null) &#123;</div><div class="line">            if (encoding == null) &#123;</div><div class="line">                write(data, output);</div><div class="line">            &#125; else &#123;</div><div class="line">                output.write(data.getBytes(encoding));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // write StringBuffer</div><div class="line">    //-----------------------------------------------------------------------</div><div class="line">    /**</div><div class="line">     * Writes chars from a &lt;code&gt;StringBuffer&lt;/code&gt; to a &lt;code&gt;Writer&lt;/code&gt;.</div><div class="line">     *</div><div class="line">     * @param data  the &lt;code&gt;StringBuffer&lt;/code&gt; to write, null ignored</div><div class="line">     * @param output  the &lt;code&gt;Writer&lt;/code&gt; to write to</div><div class="line">     * @throws NullPointerException if output is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static void write(StringBuffer data, Writer output)</div><div class="line">            throws IOException &#123;</div><div class="line">        if (data != null) &#123;</div><div class="line">            output.write(data.toString());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Writes chars from a &lt;code&gt;StringBuffer&lt;/code&gt; to bytes on an</div><div class="line">     * &lt;code&gt;OutputStream&lt;/code&gt; using the default character encoding of the</div><div class="line">     * platform.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method uses &#123;@link String#getBytes()&#125;.</div><div class="line">     *</div><div class="line">     * @param data  the &lt;code&gt;StringBuffer&lt;/code&gt; to write, null ignored</div><div class="line">     * @param output  the &lt;code&gt;OutputStream&lt;/code&gt; to write to</div><div class="line">     * @throws NullPointerException if output is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static void write(StringBuffer data, OutputStream output)</div><div class="line">            throws IOException &#123;</div><div class="line">        if (data != null) &#123;</div><div class="line">            output.write(data.toString().getBytes());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Writes chars from a &lt;code&gt;StringBuffer&lt;/code&gt; to bytes on an</div><div class="line">     * &lt;code&gt;OutputStream&lt;/code&gt; using the specified character encoding.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Character encoding names can be found at</div><div class="line">     * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method uses &#123;@link String#getBytes(String)&#125;.</div><div class="line">     *</div><div class="line">     * @param data  the &lt;code&gt;StringBuffer&lt;/code&gt; to write, null ignored</div><div class="line">     * @param output  the &lt;code&gt;OutputStream&lt;/code&gt; to write to</div><div class="line">     * @param encoding  the encoding to use, null means platform default</div><div class="line">     * @throws NullPointerException if output is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static void write(StringBuffer data, OutputStream output,</div><div class="line">                             String encoding) throws IOException &#123;</div><div class="line">        if (data != null) &#123;</div><div class="line">            if (encoding == null) &#123;</div><div class="line">                write(data, output);</div><div class="line">            &#125; else &#123;</div><div class="line">                output.write(data.toString().getBytes(encoding));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // writeLines</div><div class="line">    //-----------------------------------------------------------------------</div><div class="line">    /**</div><div class="line">     * Writes the &lt;code&gt;toString()&lt;/code&gt; value of each item in a collection to</div><div class="line">     * an &lt;code&gt;OutputStream&lt;/code&gt; line by line, using the default character</div><div class="line">     * encoding of the platform and the specified line ending.</div><div class="line">     *</div><div class="line">     * @param lines  the lines to write, null entries produce blank lines</div><div class="line">     * @param lineEnding  the line separator to use, null is system default</div><div class="line">     * @param output  the &lt;code&gt;OutputStream&lt;/code&gt; to write to, not null, not closed</div><div class="line">     * @throws NullPointerException if the output is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static void writeLines(Collection lines, String lineEnding,</div><div class="line">                                  OutputStream output) throws IOException &#123;</div><div class="line">        if (lines == null) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (lineEnding == null) &#123;</div><div class="line">            lineEnding = LINE_SEPARATOR;</div><div class="line">        &#125;</div><div class="line">        for (Iterator it = lines.iterator(); it.hasNext(); ) &#123;</div><div class="line">            Object line = it.next();</div><div class="line">            if (line != null) &#123;</div><div class="line">                output.write(line.toString().getBytes());</div><div class="line">            &#125;</div><div class="line">            output.write(lineEnding.getBytes());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Writes the &lt;code&gt;toString()&lt;/code&gt; value of each item in a collection to</div><div class="line">     * an &lt;code&gt;OutputStream&lt;/code&gt; line by line, using the specified character</div><div class="line">     * encoding and the specified line ending.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Character encoding names can be found at</div><div class="line">     * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;.</div><div class="line">     *</div><div class="line">     * @param lines  the lines to write, null entries produce blank lines</div><div class="line">     * @param lineEnding  the line separator to use, null is system default</div><div class="line">     * @param output  the &lt;code&gt;OutputStream&lt;/code&gt; to write to, not null, not closed</div><div class="line">     * @param encoding  the encoding to use, null means platform default</div><div class="line">     * @throws NullPointerException if the output is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static void writeLines(Collection lines, String lineEnding,</div><div class="line">                                  OutputStream output, String encoding) throws IOException &#123;</div><div class="line">        if (encoding == null) &#123;</div><div class="line">            writeLines(lines, lineEnding, output);</div><div class="line">        &#125; else &#123;</div><div class="line">            if (lines == null) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            if (lineEnding == null) &#123;</div><div class="line">                lineEnding = LINE_SEPARATOR;</div><div class="line">            &#125;</div><div class="line">            for (Iterator it = lines.iterator(); it.hasNext(); ) &#123;</div><div class="line">                Object line = it.next();</div><div class="line">                if (line != null) &#123;</div><div class="line">                    output.write(line.toString().getBytes(encoding));</div><div class="line">                &#125;</div><div class="line">                output.write(lineEnding.getBytes(encoding));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Writes the &lt;code&gt;toString()&lt;/code&gt; value of each item in a collection to</div><div class="line">     * a &lt;code&gt;Writer&lt;/code&gt; line by line, using the specified line ending.</div><div class="line">     *</div><div class="line">     * @param lines  the lines to write, null entries produce blank lines</div><div class="line">     * @param lineEnding  the line separator to use, null is system default</div><div class="line">     * @param writer  the &lt;code&gt;Writer&lt;/code&gt; to write to, not null, not closed</div><div class="line">     * @throws NullPointerException if the input is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static void writeLines(Collection lines, String lineEnding,</div><div class="line">                                  Writer writer) throws IOException &#123;</div><div class="line">        if (lines == null) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (lineEnding == null) &#123;</div><div class="line">            lineEnding = LINE_SEPARATOR;</div><div class="line">        &#125;</div><div class="line">        for (Iterator it = lines.iterator(); it.hasNext(); ) &#123;</div><div class="line">            Object line = it.next();</div><div class="line">            if (line != null) &#123;</div><div class="line">                writer.write(line.toString());</div><div class="line">            &#125;</div><div class="line">            writer.write(lineEnding);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // copy from InputStream</div><div class="line">    //-----------------------------------------------------------------------</div><div class="line">    /**</div><div class="line">     * Copy bytes from an &lt;code&gt;InputStream&lt;/code&gt; to an</div><div class="line">     * &lt;code&gt;OutputStream&lt;/code&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method buffers the input internally, so there is no need to use a</div><div class="line">     * &lt;code&gt;BufferedInputStream&lt;/code&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Large streams (over 2GB) will return a bytes copied value of</div><div class="line">     * &lt;code&gt;-1&lt;/code&gt; after the copy has completed since the correct</div><div class="line">     * number of bytes cannot be returned as an int. For large streams</div><div class="line">     * use the &lt;code&gt;copyLarge(InputStream, OutputStream)&lt;/code&gt; method.</div><div class="line">     *</div><div class="line">     * @param input  the &lt;code&gt;InputStream&lt;/code&gt; to read from</div><div class="line">     * @param output  the &lt;code&gt;OutputStream&lt;/code&gt; to write to</div><div class="line">     * @return the number of bytes copied</div><div class="line">     * @throws NullPointerException if the input or output is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @throws ArithmeticException if the byte count is too large</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static int copy(InputStream input, OutputStream output) throws IOException &#123;</div><div class="line">        long count = copyLarge(input, output);</div><div class="line">        if (count &gt; Integer.MAX_VALUE) &#123;</div><div class="line">            return -1;</div><div class="line">        &#125;</div><div class="line">        return (int) count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Copy bytes from a large (over 2GB) &lt;code&gt;InputStream&lt;/code&gt; to an</div><div class="line">     * &lt;code&gt;OutputStream&lt;/code&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method buffers the input internally, so there is no need to use a</div><div class="line">     * &lt;code&gt;BufferedInputStream&lt;/code&gt;.</div><div class="line">     *</div><div class="line">     * @param input  the &lt;code&gt;InputStream&lt;/code&gt; to read from</div><div class="line">     * @param output  the &lt;code&gt;OutputStream&lt;/code&gt; to write to</div><div class="line">     * @return the number of bytes copied</div><div class="line">     * @throws NullPointerException if the input or output is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.3</div><div class="line">     */</div><div class="line">    public static long copyLarge(InputStream input, OutputStream output)</div><div class="line">            throws IOException &#123;</div><div class="line">        byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];</div><div class="line">        long count = 0;</div><div class="line">        int n = 0;</div><div class="line">        while (-1 != (n = input.read(buffer))) &#123;</div><div class="line">            output.write(buffer, 0, n);</div><div class="line">            count += n;</div><div class="line">        &#125;</div><div class="line">        return count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Copy bytes from an &lt;code&gt;InputStream&lt;/code&gt; to chars on a</div><div class="line">     * &lt;code&gt;Writer&lt;/code&gt; using the default character encoding of the platform.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method buffers the input internally, so there is no need to use a</div><div class="line">     * &lt;code&gt;BufferedInputStream&lt;/code&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method uses &#123;@link InputStreamReader&#125;.</div><div class="line">     *</div><div class="line">     * @param input  the &lt;code&gt;InputStream&lt;/code&gt; to read from</div><div class="line">     * @param output  the &lt;code&gt;Writer&lt;/code&gt; to write to</div><div class="line">     * @throws NullPointerException if the input or output is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static void copy(InputStream input, Writer output)</div><div class="line">            throws IOException &#123;</div><div class="line">        InputStreamReader in = new InputStreamReader(input);</div><div class="line">        copy(in, output);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Copy bytes from an &lt;code&gt;InputStream&lt;/code&gt; to chars on a</div><div class="line">     * &lt;code&gt;Writer&lt;/code&gt; using the specified character encoding.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method buffers the input internally, so there is no need to use a</div><div class="line">     * &lt;code&gt;BufferedInputStream&lt;/code&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Character encoding names can be found at</div><div class="line">     * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method uses &#123;@link InputStreamReader&#125;.</div><div class="line">     *</div><div class="line">     * @param input  the &lt;code&gt;InputStream&lt;/code&gt; to read from</div><div class="line">     * @param output  the &lt;code&gt;Writer&lt;/code&gt; to write to</div><div class="line">     * @param encoding  the encoding to use, null means platform default</div><div class="line">     * @throws NullPointerException if the input or output is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static void copy(InputStream input, Writer output, String encoding)</div><div class="line">            throws IOException &#123;</div><div class="line">        if (encoding == null) &#123;</div><div class="line">            copy(input, output);</div><div class="line">        &#125; else &#123;</div><div class="line">            InputStreamReader in = new InputStreamReader(input, encoding);</div><div class="line">            copy(in, output);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // copy from Reader</div><div class="line">    //-----------------------------------------------------------------------</div><div class="line">    /**</div><div class="line">     * Copy chars from a &lt;code&gt;Reader&lt;/code&gt; to a &lt;code&gt;Writer&lt;/code&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method buffers the input internally, so there is no need to use a</div><div class="line">     * &lt;code&gt;BufferedReader&lt;/code&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Large streams (over 2GB) will return a chars copied value of</div><div class="line">     * &lt;code&gt;-1&lt;/code&gt; after the copy has completed since the correct</div><div class="line">     * number of chars cannot be returned as an int. For large streams</div><div class="line">     * use the &lt;code&gt;copyLarge(Reader, Writer)&lt;/code&gt; method.</div><div class="line">     *</div><div class="line">     * @param input  the &lt;code&gt;Reader&lt;/code&gt; to read from</div><div class="line">     * @param output  the &lt;code&gt;Writer&lt;/code&gt; to write to</div><div class="line">     * @return the number of characters copied</div><div class="line">     * @throws NullPointerException if the input or output is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @throws ArithmeticException if the character count is too large</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static int copy(Reader input, Writer output) throws IOException &#123;</div><div class="line">        long count = copyLarge(input, output);</div><div class="line">        if (count &gt; Integer.MAX_VALUE) &#123;</div><div class="line">            return -1;</div><div class="line">        &#125;</div><div class="line">        return (int) count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Copy chars from a large (over 2GB) &lt;code&gt;Reader&lt;/code&gt; to a &lt;code&gt;Writer&lt;/code&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method buffers the input internally, so there is no need to use a</div><div class="line">     * &lt;code&gt;BufferedReader&lt;/code&gt;.</div><div class="line">     *</div><div class="line">     * @param input  the &lt;code&gt;Reader&lt;/code&gt; to read from</div><div class="line">     * @param output  the &lt;code&gt;Writer&lt;/code&gt; to write to</div><div class="line">     * @return the number of characters copied</div><div class="line">     * @throws NullPointerException if the input or output is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.3</div><div class="line">     */</div><div class="line">    public static long copyLarge(Reader input, Writer output) throws IOException &#123;</div><div class="line">        char[] buffer = new char[DEFAULT_BUFFER_SIZE];</div><div class="line">        long count = 0;</div><div class="line">        int n = 0;</div><div class="line">        while (-1 != (n = input.read(buffer))) &#123;</div><div class="line">            output.write(buffer, 0, n);</div><div class="line">            count += n;</div><div class="line">        &#125;</div><div class="line">        return count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Copy chars from a &lt;code&gt;Reader&lt;/code&gt; to bytes on an</div><div class="line">     * &lt;code&gt;OutputStream&lt;/code&gt; using the default character encoding of the</div><div class="line">     * platform, and calling flush.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method buffers the input internally, so there is no need to use a</div><div class="line">     * &lt;code&gt;BufferedReader&lt;/code&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Due to the implementation of OutputStreamWriter, this method performs a</div><div class="line">     * flush.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method uses &#123;@link OutputStreamWriter&#125;.</div><div class="line">     *</div><div class="line">     * @param input  the &lt;code&gt;Reader&lt;/code&gt; to read from</div><div class="line">     * @param output  the &lt;code&gt;OutputStream&lt;/code&gt; to write to</div><div class="line">     * @throws NullPointerException if the input or output is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static void copy(Reader input, OutputStream output)</div><div class="line">            throws IOException &#123;</div><div class="line">        OutputStreamWriter out = new OutputStreamWriter(output);</div><div class="line">        copy(input, out);</div><div class="line">        // XXX Unless anyone is planning on rewriting OutputStreamWriter, we</div><div class="line">        // have to flush here.</div><div class="line">        out.flush();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Copy chars from a &lt;code&gt;Reader&lt;/code&gt; to bytes on an</div><div class="line">     * &lt;code&gt;OutputStream&lt;/code&gt; using the specified character encoding, and</div><div class="line">     * calling flush.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method buffers the input internally, so there is no need to use a</div><div class="line">     * &lt;code&gt;BufferedReader&lt;/code&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Character encoding names can be found at</div><div class="line">     * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA&lt;/a&gt;.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Due to the implementation of OutputStreamWriter, this method performs a</div><div class="line">     * flush.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method uses &#123;@link OutputStreamWriter&#125;.</div><div class="line">     *</div><div class="line">     * @param input  the &lt;code&gt;Reader&lt;/code&gt; to read from</div><div class="line">     * @param output  the &lt;code&gt;OutputStream&lt;/code&gt; to write to</div><div class="line">     * @param encoding  the encoding to use, null means platform default</div><div class="line">     * @throws NullPointerException if the input or output is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static void copy(Reader input, OutputStream output, String encoding)</div><div class="line">            throws IOException &#123;</div><div class="line">        if (encoding == null) &#123;</div><div class="line">            copy(input, output);</div><div class="line">        &#125; else &#123;</div><div class="line">            OutputStreamWriter out = new OutputStreamWriter(output, encoding);</div><div class="line">            copy(input, out);</div><div class="line">            // XXX Unless anyone is planning on rewriting OutputStreamWriter,</div><div class="line">            // we have to flush here.</div><div class="line">            out.flush();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // content equals</div><div class="line">    //-----------------------------------------------------------------------</div><div class="line">    /**</div><div class="line">     * Compare the contents of two Streams to determine if they are equal or</div><div class="line">     * not.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method buffers the input internally using</div><div class="line">     * &lt;code&gt;BufferedInputStream&lt;/code&gt; if they are not already buffered.</div><div class="line">     *</div><div class="line">     * @param input1  the first stream</div><div class="line">     * @param input2  the second stream</div><div class="line">     * @return true if the content of the streams are equal or they both don&apos;t</div><div class="line">     * exist, false otherwise</div><div class="line">     * @throws NullPointerException if either input is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     */</div><div class="line">    public static boolean contentEquals(InputStream input1, InputStream input2)</div><div class="line">            throws IOException &#123;</div><div class="line">        if (!(input1 instanceof BufferedInputStream)) &#123;</div><div class="line">            input1 = new BufferedInputStream(input1);</div><div class="line">        &#125;</div><div class="line">        if (!(input2 instanceof BufferedInputStream)) &#123;</div><div class="line">            input2 = new BufferedInputStream(input2);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int ch = input1.read();</div><div class="line">        while (-1 != ch) &#123;</div><div class="line">            int ch2 = input2.read();</div><div class="line">            if (ch != ch2) &#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">            ch = input1.read();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int ch2 = input2.read();</div><div class="line">        return (ch2 == -1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Compare the contents of two Readers to determine if they are equal or</div><div class="line">     * not.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * This method buffers the input internally using</div><div class="line">     * &lt;code&gt;BufferedReader&lt;/code&gt; if they are not already buffered.</div><div class="line">     *</div><div class="line">     * @param input1  the first reader</div><div class="line">     * @param input2  the second reader</div><div class="line">     * @return true if the content of the readers are equal or they both don&apos;t</div><div class="line">     * exist, false otherwise</div><div class="line">     * @throws NullPointerException if either input is null</div><div class="line">     * @throws IOException if an I/O error occurs</div><div class="line">     * @since Commons IO 1.1</div><div class="line">     */</div><div class="line">    public static boolean contentEquals(Reader input1, Reader input2)</div><div class="line">            throws IOException &#123;</div><div class="line">        if (!(input1 instanceof BufferedReader)) &#123;</div><div class="line">            input1 = new BufferedReader(input1);</div><div class="line">        &#125;</div><div class="line">        if (!(input2 instanceof BufferedReader)) &#123;</div><div class="line">            input2 = new BufferedReader(input2);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int ch = input1.read();</div><div class="line">        while (-1 != ch) &#123;</div><div class="line">            int ch2 = input2.read();</div><div class="line">            if (ch != ch2) &#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">            ch = input1.read();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int ch2 = input2.read();</div><div class="line">        return (ch2 == -1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>参考链接：<br><a href="http://commons.apache.org/proper/commons-io/apidocs/org/apache/commons/io/IOUtils.html" target="_blank" rel="external">Apache API：IOUtils</a><br><a href="http://www.docjar.com/html/api/org/apache/commons/io/IOUtils.java.html" target="_blank" rel="external">Source Code：IOUtils.java</a><br><a href="https://blog.csdn.net/qq_40794973/article/details/88824545" target="_blank" rel="external">相关博客</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO Stream</title>
      <link href="/1900/01/03/01%20JAVA/03%20Java%20IO%20Stream/"/>
      <url>/1900/01/03/01%20JAVA/03%20Java%20IO%20Stream/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="一、IO-流概述"><a href="#一、IO-流概述" class="headerlink" title="一、IO 流概述"></a>一、IO 流概述</h3><hr><p>流（Stream）的概念源于 UNIX 中管道（pipe）的概念。在 UNIX中，管道是一条不间断的字节流，用来实现程序或进程间的通信，或读写外围设备、外部文件等。一个流，必有源端和目的端，它们可以是计算机内存的某些区域，也可以是磁盘文件，甚至可以是Internet上的某个URL。实际上，流的源端和目的端可简单地看成是字节的生产者和消费者，对输入流，可不必关心它的源端是什么，只要简单地从流中读数据，而对输出流，也可不知道它的目的端，只是简单地往流中写数据。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。</strong>即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 </p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li><p>根据数据流向不同分为：输入流和输出流。<br>注意输入流和输出流是相对于程序而言的。把程序（内存）中的内容输出到磁盘、光盘等存储设备中是为输出；读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。</p></li><li><p>根据处理数据类型分为：字符流和字节流。<br>数据流中最小的数据单元是字节的流为字节流；数据流中最小的数据单元是字符的流为字符流。Java 中的字符是 Unicode 编码，一个字符占用两个字节（无论中文还是英文都是两个字节）。</p></li><li><p>根据功能不同分为：节点流和包装流。<br>1）节点流：可以从或向一个特定的地方(节点)读写数据，直接连接数据源。如最常见的是文件的 FileReader，还可以是数组、管道、字符串，关键字分别为 ByteArray/CharArray，Piped，String。<br>2）处理流（包装流）：并不直接连接数据源，是对一个已存在的流的连接和封装，是一种典型的装饰器设计模式，使用处理流主要是为了更方便的执行输入输出工作，如PrintStream，输出功能很强大，又如BufferedReader提供缓存机制，推荐输出时都使用处理流包装。</p></li></ul><blockquote><p>注意：一个 IO 流可以即是输入流又是字节流又或是以其他方式分类的流类型，是不冲突的。比如 FileInputStream，它既是输入流又是字节流还是文件节点流。</p></blockquote><ul><li>一些特别的的流类型<br>1）转换流：转换流只有字节流转换为字符流，因为字符流使用起来更方便，我们只会向更方便使用的方向转化。如：InputStreamReader 与 OutputStreamWriter。<br>2）缓冲流：有关键字 Buffered，也是一种处理流，为其包装的流增加了缓存功能，提高了输入输出的效率，增加缓冲功能后需要使用 flush() 才能将缓冲区中内容写入到实际的物理节点。但是，在现在版本的 Java 中，只需记得关闭输出流（调用 close() 方法），就会自动执行输出流的 flush() 方法，可以保证将缓冲区中内容写入。<br>3）对象流：有关键字Object，主要用于将目标对象保存到磁盘中或允许在网络中直接传输对象时使用（对象序列化）。</li></ul><h4 id="操作-IO-流的模板"><a href="#操作-IO-流的模板" class="headerlink" title="操作 IO 流的模板"></a>操作 IO 流的模板</h4><p><strong>第一步：创建源或目标对象</strong><br>输入：把文件中的数据流向到程序中，此时文件是源，程序是目标；<br>输出：把程序中的数据流向到文件中，此时文件是目标，程序是源。</p><p><strong>第二步：创建 IO 流对象</strong><br>输入：创建输入流对象；<br>输出：创建输出流对象；</p><p><strong>第三步：具体的 IO 操作</strong></p><p><strong>第四步：关闭资源</strong><br>输入：输入流的 close() 方法；<br>输出：输出流的 close() 方法。</p><p>复制文件示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public static void copy(File srcFile, File dstFile) &#123;</div><div class="line">    FileInputStream in = null;</div><div class="line">    FileOutputStream out = null;</div><div class="line">    try &#123;</div><div class="line">        // 第一、二步</div><div class="line">        in = new FileInputStream(srcFile);</div><div class="line">        out = new FileOutputStream(dstFile);</div><div class="line">        // 第三步</div><div class="line">        int b;</div><div class="line">        while ((b = in.read()) != -1) &#123;</div><div class="line">            out.write(b);</div><div class="line">        &#125;</div><div class="line">    &#125; catch(IOException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; finally &#123;</div><div class="line">        // 第四步</div><div class="line">        CloseUtils.closeIO(in, out);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>注意：程序中打开的文件 IO 资源不属于内存里的资源，垃圾回收机制无法回收该资源。如果不关闭该资源，那么磁盘的文件将一直被程序引用着，不能删除也不能更改，所以应该手动调用 close() 方法关闭流资源。</p></blockquote><h3 id="二、整体架构"><a href="#二、整体架构" class="headerlink" title="二、整体架构"></a>二、整体架构</h3><hr><h4 id="JAVA-流操作相关的类和接口"><a href="#JAVA-流操作相关的类和接口" class="headerlink" title="JAVA 流操作相关的类和接口"></a>JAVA 流操作相关的类和接口</h4><div class="table-container"><table><thead><tr><th>类</th><th>说明</th></tr></thead><tbody><tr><td>File</td><td>文件类</td></tr><tr><td>RandomAccessFile</td><td>随机存取文件类</td></tr><tr><td>InputStream</td><td>字节输入流</td></tr><tr><td>OutStream</td><td>字节输出流</td></tr><tr><td>Reader</td><td>字符输入流</td></tr><tr><td>Writer</td><td>字符输出流</td></tr></tbody></table></div><h4 id="Java-IO-流的整体架构"><a href="#Java-IO-流的整体架构" class="headerlink" title="Java IO 流的整体架构"></a>Java IO 流的整体架构</h4><p><img src="http://www.51gjie.com/Images/image1/lkqixikw.lqs.jpg" alt=""></p><p>从图中可以看出四大基类流，如下表所示。这四大基流都是抽象类，其他流都是继承于这四大基流的。</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">字节流</th><th style="text-align:center">字符流</th></tr></thead><tbody><tr><td style="text-align:center">输入流</td><td style="text-align:center">InputStream</td><td style="text-align:center">Reader</td></tr><tr><td style="text-align:center">输出流</td><td style="text-align:center">OutStream</td><td style="text-align:center">Writer</td></tr></tbody></table></div><h4 id="用法分析"><a href="#用法分析" class="headerlink" title="用法分析"></a>用法分析</h4><ul><li>按数据来源（去向）使用<br>是文件： FileInputStream, FileOutputStream, FileReader, FileWriter<br>是 byte[]：ByteArrayInputStream, ByteArrayOutputStream<br>是 char[]：CharArrayReader, CharArrayWriter<br>是 String：StringBufferInputStream, StringReader, StringWriter<br>网络数据流：InputStream, OutputStream, Reader, Writer </li><li>按是否格式化输出使用<br>要格式化输出：PrintStream, PrintWriter</li><li>按是否要缓冲使用<br>要缓冲：BufferedInputStream, BufferedOutputStream, BufferedReader, BufferedWriter。</li><li>按数据格式使用<br>二进制格式（只要不能确定是纯文本的）: InputStream, OutputStream 及其所有带 Stream 结尾的子类；<br>纯文本格式（含纯英文与汉字或其他编码方式）；Reader, Writer 及其所有带 eader, Writer 的子类 。</li><li>按输入输出使用<br>输入：Reader, InputStream 类型的子类；输出：Writer, OutputStream 类型的子类。</li><li>特殊需要<br>从 Stream 到 Reader、Writer 的转换类：InputStreamReader, OutputStreamWriter；<br>对象输入输出：ObjectInputStream, ObjectOutputStream；<br>进程间通信：PipeInputStream, PipeOutputStream, PipeReader, PipeWriter ；<br>合并输入：SequenceInputStream；<br>更特殊的需要：PushbackInputStream, PushbackReader, LineNumberInputStream, LineNumberReader。</li></ul><p>虽然四大基类流的实现类很多，功能繁杂，但是他们的命名非常有规律，可以“顾名思义”。如字节流的输入与输出的对应：</p><p><img src="https://upload-images.jianshu.io/upload_images/13909254-f1cc04b0aacb0e65.png?imageMogr2/auto-orient/strip|imageView2/2/w/440/format/webp" alt=""></p><p>图中蓝色的为主要的对应部分，红色的部分就是不对应部分。紫色的虚线部分代表这些流一般要搭配使用。</p><h3 id="三、IO-流文件操作"><a href="#三、IO-流文件操作" class="headerlink" title="三、IO 流文件操作"></a>三、IO 流文件操作</h3><hr><p>读取文件内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void test() throws IOException &#123;</div><div class="line">    String fileName = &quot;D:&quot;+File.separator+&quot;hello.txt&quot;;</div><div class="line">    File f = new File(fileName);</div><div class="line">    InputStream in = new FileInputStream(f);</div><div class="line">    byte[] b = new byte[1024];</div><div class="line">    int count = 0;</div><div class="line">    int temp;</div><div class="line">    while((temp = in.read()) != -1)&#123;</div><div class="line">        b[count++] = (byte)temp;</div><div class="line">    &#125;</div><div class="line">    in.close();</div><div class="line">    System.out.println(new String(b));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>向文件中写入字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public void test() throws IOException &#123;</div><div class="line">    String fileName = &quot;D:&quot; + File.separator + &quot;hello.txt&quot;;</div><div class="line">    File file = new File(fileName);</div><div class="line">    OutputStream out =new FileOutputStream(file);</div><div class="line">    String str = &quot;你好&quot;;</div><div class="line">    byte[] bytes = str.getBytes();</div><div class="line">    out.write(bytes);</div><div class="line">    out.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>向文件中追加新内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void test() throws IOException &#123;</div><div class="line">    String fileName = &quot;D:&quot; + File.separator + &quot;hello.txt&quot;;</div><div class="line">    File f = new File(fileName);</div><div class="line">    OutputStream out = new FileOutputStream(f,true);</div><div class="line">    String str = &quot;Xian&quot;;</div><div class="line">    // String str = &quot;\r\nXian&quot;;  // 可以换行</div><div class="line">    byte[] b = str.getBytes();</div><div class="line">    for (int i = 0; i &lt; b.length; i++) &#123;</div><div class="line">        out.write(b[i]);</div><div class="line">    &#125;</div><div class="line">    out.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用 RandomAccessFile 写入文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void test() throws IOException &#123;</div><div class="line">    String fileName = &quot;D:&quot;+File.separator+&quot;hello.txt&quot;;</div><div class="line">    File f = new File(fileName);</div><div class="line">    RandomAccessFile raf = new RandomAccessFile(f,&quot;rw&quot;);</div><div class="line">    raf.writeBytes(&quot;xian&quot;);</div><div class="line">    raf.writeInt(12);</div><div class="line">    raf.writeBoolean(true);</div><div class="line">    raf.writeChar(&apos;A&apos;);</div><div class="line">    raf.writeFloat(1.21f);</div><div class="line">    raf.writeDouble(12.123);</div><div class="line">    raf.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="四、字节流"><a href="#四、字节流" class="headerlink" title="四、字节流"></a>四、字节流</h3><hr><h4 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h4><p>InputStream 是所有字节输入流的父类，是一个抽象类。</p><p><strong>子类：</strong></p><p>ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从 Byte 数组、StringBuffer 和本地文件中读取数据。PipedInputStream 是从与其它线程共用的管道中读取数据。ObjectInputStream 和所有 FilterInputStream 的子类都是装饰流（装饰器模式的主角）。</p><p><strong>方法：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 返回此输入流下一个方法调用可以不受阻塞地从此输入流读取（或跳过）的估计字节数。</div><div class="line">int available()  </div><div class="line">// 关闭此输入流并释放与该流关联的所有系统资源。</div><div class="line">void close() </div><div class="line">// 在此输入流中标记当前的位置。</div><div class="line">void mark(int readLimit) </div><div class="line">// 测试此输入流是否支持 mark 和 reset 方法。</div><div class="line">boolean markSupported() </div><div class="line">// 从输入流中读取数据的下一个字节。</div><div class="line">abstract int read() </div><div class="line">// 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。</div><div class="line">int read(byte[] b) </div><div class="line">// 将输入流中最多 len 个数据字节读入 byte 数组。</div><div class="line">int read(byte[] b, int off, int len) </div><div class="line">// 将此流重新定位到最后一次对此输入流调用 mark 方法时的位置。</div><div class="line">void reset() </div><div class="line">// 跳过和丢弃此输入流中数据的 n 个字节。</div><div class="line">long skip(long n)</div></pre></td></tr></table></figure></p><p><strong>示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void test() throws Exception &#123;   // 异常抛出，不处理</div><div class="line">    // 第1步、使用File类找到一个文件</div><div class="line">    File f = new File(&quot;d:&quot; + File.separator + &quot;test.txt&quot;) ;</div><div class="line">    // 第2步、通过子类实例化父类对象</div><div class="line">    InputStream input = null ;          // 准备好一个输入的对象</div><div class="line">    input = new FileInputStream(f);     // 通过对象多态性，进行实例化</div><div class="line">    // 第3步、进行读操作</div><div class="line">    byte b[] = new byte[1024] ;         // 所有的内容都读到此数组之中</div><div class="line">    input.read(b) ;                     // 读取内容 网络编程中 read 方法会阻塞</div><div class="line">    // 第4步、关闭输出流</div><div class="line">    input.close() ;                     // 关闭输出流</div><div class="line">    System.out.println(new String(b));  // 把 byte 数组变为字符串输出</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h4><p>OutputStream 是所有的输出字节流的父类，它是一个抽象类。</p><p><strong>子类：</strong><br>（1）OutputStream是以字节为单位的输出流的超类，提供了write()函数从输出流中读取字节数据。<br>（2）ByteArrayOutputStream是字节数组输出流，写入ByteArrayOutputStream的数据被写入到一个byte数组，缓冲区会随着数据的不断写入而自动增长，可使用toByteArray()和toString()获取数据。<br>（3）PipedOutputStream是管道输出流，和PipedInputStream一起使用，能实现多线程间的管道通信。<br>（4）FilterOutputStream是过滤输出流，是DataOutputStream，BufferedOutputStream和PrintStream的超类<br>（5）DataOutputStream是数据输出流，用来装饰其他的输出流，允许应用程序以与机器无关方式向底层写入基本Java数据类型。<br>（6）BufferedOutputStream是缓冲输出流，它的作用是为另一个输出流添加缓冲功能。<br>（7）PrintStream是打印输出流，用来装饰其他输出流，为其他输出流添加功能，方便的打印各种数据值<br>（8）FileOutputStream是文件输出流，通常用于向文件进行写入操作。<br>（9）ObjectOutputStream是对象输出流，它和ObjectInputStream一起对基本数据或者对象的持久存储。</p><p><strong>方法：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// Writes the specified byte to this output stream.</div><div class="line">public abstract void write(int b) throws IOException</div><div class="line">// Writes b.length bytes from the specified byte array to this output stream.</div><div class="line">public void write(byte[] data) throws IOException</div><div class="line">// Writes length bytes from the specified byte array starting at offset </div><div class="line">// off to this output stream.</div><div class="line">public void write(byte[] data, int offset, int length) throws IOException</div><div class="line">// Flushes this output stream and forces any buffered output bytes</div><div class="line">// to be written out.</div><div class="line">public void flush() throws IOException</div><div class="line">// Closes this output stream and releases any system resources </div><div class="line">// associated with this stream.</div><div class="line">public void close() throws IOException</div></pre></td></tr></table></figure></p><p><strong>示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public void test() throws Exception &#123;   // 异常抛出，不处理</div><div class="line">    // 第1步、使用File类找到一个文件</div><div class="line">    File f = new File(&quot;d:&quot; + File.separator + &quot;test.txt&quot;);</div><div class="line">    // 第2步、通过子类实例化父类对象</div><div class="line">    OutputStream out = null ;           // 准备好一个输出的对象</div><div class="line">    out = new FileOutputStream(f);      // 通过对象多态性，进行实例化</div><div class="line">    // 第3步、进行写操作</div><div class="line">    String str = &quot;Hello World!!!&quot;;      // 准备一个字符串</div><div class="line">    byte b[] = str.getBytes() ;         // 只能输出byte数组，将字符串变为byte数组</div><div class="line">    out.write(b) ;                      // 将内容输出，保存文件</div><div class="line">    // 第4步、关闭输出流</div><div class="line">    out.close() ;                       // 关闭输出流</div><div class="line">    // 文件不存在会自动创建</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="示例：复制文件内容"><a href="#示例：复制文件内容" class="headerlink" title="示例：复制文件内容"></a>示例：复制文件内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 将 a.txt 文件 复制到 b.txt 中</div><div class="line"> */</div><div class="line">public void copy() throws IOException &#123;</div><div class="line">    // 1、创建源和目标</div><div class="line">    File srcFile = new File(&quot;io&quot;+File.separator+&quot;a.txt&quot;);</div><div class="line">    File descFile = new File(&quot;io&quot;+File.separator+&quot;b.txt&quot;);</div><div class="line">    // 2、创建输入输出流对象</div><div class="line">    InputStream in = new FileInputStream(srcFile);</div><div class="line">    OutputStream out = new FileOutputStream(descFile);</div><div class="line">    // 3、读取和写入操作</div><div class="line">    byte[] buffer = new byte[1024];</div><div class="line">    // 表示已经读取了多少个字节，-1 表示已经读取到文件的末尾</div><div class="line">    int len = -1;</div><div class="line">    while((len = in.read(buffer))!= -1) &#123;</div><div class="line">        // 打印读取的数据</div><div class="line">        System.out.println(new String(buffer,0,len));</div><div class="line">        // 将 buffer 数组中从 0 开始，长度为 len 的数据读取到 b.txt 文件中</div><div class="line">        out.write(buffer, 0, len);</div><div class="line">    &#125;</div><div class="line">    // 4、关闭流资源</div><div class="line">    out.close();</div><div class="line">    in.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="五、字符流"><a href="#五、字符流" class="headerlink" title="五、字符流"></a>五、字符流</h3><hr><p>使用字节流操作汉字或特殊符号语言的时候容易乱码，因为汉字不止一个字节，为了解决这个问题，建议使用字符流。一般可以用记事本打开的文件，我们可以看到内容不乱码的。就是文本文件，可以使用字符流。而操作二进制文件（比如图片、音频、视频）必须使用字节流。</p><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p>Reader 是所有的输入字符流的父类，它是一个抽象类。</p><p><strong>子类：</strong><br>CharReader、StringReader 是两种基本的介质流，它们分别将Char 数组、String中读取数据。PipedReader 是从与其它线程共用的管道中读取数据。<br>BufferedReader 很明显就是一个装饰器，它和其子类负责装饰其它Reader 对象。<br>FilterReader 是所有自定义具体装饰流的父类，其子类PushbackReader 对Reader 对象进行装饰，会增加一个行号。<br>InputStreamReader 是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。<br>FileReader 可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将 FileInputStream 转变为 Reader 的方法。我们可以从这个类中得到一定的技巧。</p><blockquote><p>Reader 中各个类的用途和使用方法基本和 InputStream 中的类使用一致。</p></blockquote><p><strong>方法：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 关闭该流并释放与之关联的所有资源。</div><div class="line">abstract void close() </div><div class="line">// 标记流中的当前位置。</div><div class="line">void mark(int readAheadLimit) </div><div class="line">// 判断此流是否支持 mark() 操作。</div><div class="line">boolean markSupported() </div><div class="line">// 读取单个字符。</div><div class="line">int read()</div><div class="line">// 将字符读入数组。</div><div class="line">int read(char[] cbuf)</div><div class="line">// 将字符读入数组的某一部分。</div><div class="line">abstract int read(char[] cbuf, int off, int len) </div><div class="line">// 试图将字符读入指定的字符缓冲区。</div><div class="line">int read(CharBuffer target) </div><div class="line">// 判断是否准备读取此流。</div><div class="line">boolean ready() </div><div class="line">// 重置该流。</div><div class="line">void reset() </div><div class="line">// 跳过字符。</div><div class="line">long skip(long n)</div></pre></td></tr></table></figure></p><p><strong>示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void test() throws IOException &#123;</div><div class="line">    //创建一个文件读取流对象，和指定名称的文件相关联起来。</div><div class="line">    //要保证该文件是已经存在的。如果不存在，会发生异常，即FileNotFoundException</div><div class="line">    FileReader reader = new FileReader(&quot;F:\\myFile\\test.txt&quot;);</div><div class="line">    //调用读取流对象的read方法。</div><div class="line">    //read方法：一次读取一次字符，而且会自动往后面读取字符。</div><div class="line">    int ch = 0;</div><div class="line">    while((ch = reader.read()) != -1) &#123;</div><div class="line">        System.out.print((char)ch);</div><div class="line">    &#125;</div><div class="line">    fr.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><p>Writer 是所有的输出字符流的父类，它是一个抽象类。</p><p><strong>子类：</strong><br>CharArrayWriter、StringWriter 是两种基本的介质流，它们分别向Char 数组、String 中写入数据。PipedWriter 是向与其它线程共用的管道中写入数据，<br>BufferedWriter 是一个装饰器为 Writer 提供缓冲功能。<br>PrintWriter 和 PrintStream 极其类似，功能和使用也非常相似。<br>OutputStreamWriter 是 OutputStream 到 Writer 转换的桥梁，它的子类 FileWriter，功能和使用和 OutputStream 极其类似。</p><p><strong>方法：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 将指定字符添加到此 writer。</div><div class="line">Writer append(char c) </div><div class="line">// 将指定字符序列添加到此 writer。</div><div class="line">Writer append(CharSequence csq) </div><div class="line">// 将指定字符序列的子序列添加到此 writer.Appendable。</div><div class="line">Writer append(CharSequence csq, int start, int end) </div><div class="line">// 关闭此流，但要先刷新它。</div><div class="line">abstract void close() </div><div class="line">// 刷新该流的缓冲。</div><div class="line">abstract void flush() </div><div class="line">// 写入字符数组。</div><div class="line">void write(char[] cbuf) </div><div class="line">// 写入字符数组的某一部分。</div><div class="line">abstract void write(char[] cbuf, int off, int len) </div><div class="line">// 写入单个字符。</div><div class="line">void write(int c) </div><div class="line">// 写入字符串。</div><div class="line">void write(String str) </div><div class="line">// 写入字符串的某一部分。</div><div class="line">void write(String str, int off, int len)</div></pre></td></tr></table></figure></p><p><strong>示例代码：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void test() throws IOException &#123;</div><div class="line">    // 第1步、使用File类找到一个文件</div><div class="line">    File f = new File(&quot;d:&quot; + File.separator + &quot;test.txt&quot;);</div><div class="line">    // 第2步、通过子类实例化父类对象</div><div class="line">    Writer out = null;              // 准备好一个输出的对象</div><div class="line">    out = new FileWriter(f);        // 通过对象多态性，进行实例化</div><div class="line">    // 第3步、进行写操作</div><div class="line">    String str = &quot;Hello World!!!&quot;;  // 准备一个字符串</div><div class="line">    out.write(str) ;                // 将内容输出，保存文件</div><div class="line">    // 第4步、关闭输出流</div><div class="line">    out.close() ;                   // 关闭输出流</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>用字符流完成文件的复制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 将 a.txt 文件 复制到 b.txt 中</div><div class="line"> */</div><div class="line">public void copy() throws IOException &#123;</div><div class="line">    // 1、创建源和目标</div><div class="line">    File srcFile = new File(&quot;io&quot;+File.separator+&quot;a.txt&quot;);</div><div class="line">    File descFile = new File(&quot;io&quot;+File.separator+&quot;b.txt&quot;);</div><div class="line">    // 2、创建字符输入输出流对象</div><div class="line">    Reader in = new FileReader(srcFile);</div><div class="line">    Writer out = new FileWriter(descFile);</div><div class="line">    // 3、读取和写入操作</div><div class="line">    char[] buffer = new char[1024];</div><div class="line">    // 表示已经读取了多少个字节，-1 表示已经读取到文件的末尾</div><div class="line">    int len;   </div><div class="line">    while((len=in.read(buffer))!=-1)&#123;</div><div class="line">        out.write(buffer, 0, len);</div><div class="line">    &#125;</div><div class="line">    // 4、关闭流资源</div><div class="line">    out.close();</div><div class="line">    in.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="六、包装流"><a href="#六、包装流" class="headerlink" title="六、包装流"></a>六、包装流</h3><hr><p>包含缓冲流，转换流对象流等等。<br>①、包装流隐藏了底层节点流的差异，并对外提供了更方便的输入\输出功能，让我们只关心这个高级流的操作。<br>②、使用包装流包装了节点流，程序直接操作包装流，而底层还是节点流和IO设备操作。<br>③、关闭包装流的时候，只需要关闭包装流即可。</p><h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><p>缓冲流：是一个包装流，目的是缓存作用，加快读取和写入数据的速度。<br>字节缓冲流：BufferedInputStream、BufferedOutputStream<br>字符缓冲流：BufferedReader、BufferedWriter</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public void test() throws Exception &#123;</div><div class="line">    //字节缓冲输入流</div><div class="line">    BufferedInputStream bis = new BufferedInputStream(</div><div class="line">            new FileInputStream(&quot;io&quot;+File.separator+&quot;a.txt&quot;));</div><div class="line">    //定义一个字节数组，用来存储数据</div><div class="line">    byte[] buffer = new byte[1024];</div><div class="line">    //定义一个整数，表示读取的字节数</div><div class="line">    int len = -1;</div><div class="line">    while((len=bis.read(buffer))!=-1)&#123;</div><div class="line">        System.out.println(new String(buffer,0,len));</div><div class="line">    &#125;</div><div class="line">    //关闭流资源</div><div class="line">    bis.close();</div><div class="line"></div><div class="line">    //字节缓冲输出流</div><div class="line">    BufferedOutputStream bos = new BufferedOutputStream(</div><div class="line">            new FileOutputStream(&quot;io&quot;+File.separator+&quot;a.txt&quot;));</div><div class="line">    bos.write(&quot;Hello，先小涛&quot;.getBytes());</div><div class="line">    bos.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>字符缓冲流使用与字节缓冲流非常像，直接替换上例中对应的类即可。</p><h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><p>把字节流转换为字符流。<br>InputStreamReader：把字节输入流转换为字符输入流<br>OutputStreamWriter：把字节输出流转换为字符输出流</p><p>示例：用转换流进行文件的复制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public void copy() throws IOException &#123;</div><div class="line">    //1、创建源和目标</div><div class="line">    File srcFile = new File(&quot;io&quot;+File.separator+&quot;a.txt&quot;);</div><div class="line">    File descFile = new File(&quot;io&quot;+File.separator+&quot;b.txt&quot;);</div><div class="line">    //2、创建字节输入输出流对象</div><div class="line">    InputStream in = new FileInputStream(srcFile);</div><div class="line">    OutputStream out = new FileOutputStream(descFile);</div><div class="line">    //3、创建转换输入输出对象</div><div class="line">    Reader rd = new InputStreamReader(in);</div><div class="line">    Writer wt = new OutputStreamWriter(out);</div><div class="line">    //3、读取和写入操作</div><div class="line">    char[] buffer = new char[1024];</div><div class="line">    int len = -1;</div><div class="line">    while((len=rd.read(buffer))!=-1)&#123;</div><div class="line">        wt.write(buffer, 0, len);</div><div class="line">    &#125;</div><div class="line">    //4、关闭流资源</div><div class="line">    rd.close();</div><div class="line">    wt.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>OutputStreamWriter 和 InputStreamReader 是字符和字节的桥梁：也可以称之为字符转换流。字符转换流原理：字节流+编码表。</p><p>FileWriter 和 FileReader：作为子类，仅作为操作字符文件的便捷类存在。当操作的字符文件，使用的是默认编码表时可以不用父类，而直接用子类就完成操作了，简化了代码。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//默认字符集。</div><div class="line">InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;a.txt&quot;));</div><div class="line">//指定GBK字符集。</div><div class="line">InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;a.txt&quot;),&quot;GBK&quot;);</div><div class="line"></div><div class="line">FileReader fr = new FileReader(&quot;a.txt&quot;);</div></pre></td></tr></table></figure></p><p>这三句代码的功能是一样的，其中第三句最为便捷。</p><blockquote><p>注意：一旦要指定其他编码时，绝对不能用子类，必须使用字符转换流。</p></blockquote><h4 id="内存流"><a href="#内存流" class="headerlink" title="内存流"></a>内存流</h4><p>把数据先临时存在数组中，也就是内存中。所以关闭内存流是无效的，关闭后还是可以调用这个类的方法。底层源码的 close() 是一个空方法。</p><p>字节内存流：ByteArrayOutputStream 、ByteArrayInputStream<br>字符内存流：CharArrayReader、CharArrayWriter<br>字符串流：StringReader,StringWriter（把数据临时存储到字符串中）</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public void test() throws Exception &#123;</div><div class="line">    // 字节数组输出流：程序---》内存</div><div class="line">    ByteArrayOutputStream bos = new ByteArrayOutputStream();</div><div class="line">    // 将数据写入到内存中</div><div class="line">    bos.write(&quot;hello&quot;.getBytes());</div><div class="line">    // 创建一个新分配的字节数组。 其大小是此输出流的当前大小，</div><div class="line">    // 缓冲区的有效内容已被复制到其中。</div><div class="line">    byte[] temp = bos.toByteArray();</div><div class="line">    System.out.println(new String(temp,0,temp.length));</div><div class="line"></div><div class="line">    </div><div class="line">    byte[] buffer = new byte[10];</div><div class="line">    // 字节数组输入流：内存---》程序</div><div class="line">    ByteArrayInputStream bis = new ByteArrayInputStream(temp);</div><div class="line">    int len = -1;</div><div class="line">    while((len=bis.read(buffer))!=-1)&#123;</div><div class="line">        System.out.println(new String(buffer,0,len));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 这里不写也没事，因为源码中的 close()是一个空的方法体</div><div class="line">    bos.close();</div><div class="line">    bis.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="合并流"><a href="#合并流" class="headerlink" title="合并流"></a>合并流</h4><p>把多个输入流合并为一个流，也叫顺序流，因为在读取的时候是先读第一个，读完了在读下面一个流。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void test() throws Exception &#123;</div><div class="line">    //定义字节输入合并流</div><div class="line">    SequenceInputStream seinput = new SequenceInputStream(</div><div class="line">            new FileInputStream(&quot;io/a.txt&quot;), </div><div class="line">            new FileInputStream(&quot;io/b.txt&quot;));</div><div class="line">    byte[] buffer = new byte[10];</div><div class="line">    int len = -1;</div><div class="line">    while((len=seinput.read(buffer)) != -1)&#123;</div><div class="line">        System.out.println(new String(buffer,0,len));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    seinput.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="七、序列化与反序列化（对象流）"><a href="#七、序列化与反序列化（对象流）" class="headerlink" title="七、序列化与反序列化（对象流）"></a>七、序列化与反序列化（对象流）</h3><h4 id="what"><a href="#what" class="headerlink" title="what"></a>what</h4><p><strong>序列化：</strong>指把堆内存中的 Java 对象数据，通过某种方式把对象存储到磁盘文件中或者传递给其他网络节点（在网络上传输）。这个过程称为序列化。通俗来说就是将数据结构或对象转换成二进制串的过程。<br><strong>反序列化：</strong>把磁盘文件中的对象数据或者把网络节点上的对象数据，恢复成Java对象模型的过程。也就是将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。</p><h4 id="why"><a href="#why" class="headerlink" title="why"></a>why</h4><p>①、在分布式系统中，此时需要把对象在网络上传输，就得把对象数据转换为二进制形式，需要共享的数据的 JavaBean 对象，都得做序列化。<br>②、服务器钝化：如果服务器发现某些对象好久没活动了，那么服务器就会把这些内存中的对象持久化在本地磁盘文件中（Java对象转换为二进制文件）；如果服务器发现某些对象需要活动时，先去内存中寻找，找不到再去磁盘文件中反序列化我们的对象数据，恢复成 Java 对象。这样能节省服务器内存。</p><h4 id="how"><a href="#how" class="headerlink" title="how"></a>how</h4><p>①、需要做序列化的对象的类，必须实现序列化接口：Java.lang.Serializable 接口（这是一个标志接口，没有任何抽象方法），Java 中大多数类都实现了该接口，比如：String，Integer。<br>②、底层会判断，如果当前对象是 Serializable 的实例，才允许做序列化，Java对象 instanceof Serializable 来判断。<br>③、在 Java 中使用对象流来完成序列化和反序列化。<br>ObjectOutputStream：通过 writeObject()方法做序列化操作<br>ObjectInputStream：通过 readObject() 方法做反序列化操作</p><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><p>第一步：创建一个 JavaBean 对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Person implements Serializable &#123;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    public int getAge() &#123;</div><div class="line">        return age;</div><div class="line">    &#125;</div><div class="line">    public void setAge(int age) &#123;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;</div><div class="line">    &#125;</div><div class="line">    public Person(String name, int age) &#123;</div><div class="line">        super();</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>第二步：使用 ObjectOutputStream 对象实现序列化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 在根目录下新建一个 io 的文件夹</div><div class="line">OutputStream op = new FileOutputStream(&quot;io&quot;+File.separator+&quot;a.txt&quot;);</div><div class="line">ObjectOutputStream ops = new ObjectOutputStream(op);</div><div class="line">ops.writeObject(new Person(&quot;vae&quot;,1));</div><div class="line">ops.close();</div></pre></td></tr></table></figure></p><p>第三步：使用ObjectInputStream 对象实现反序列化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">InputStream in = new FileInputStream(&quot;io&quot;+File.separator+&quot;a.txt&quot;);</div><div class="line">ObjectInputStream os = new ObjectInputStream(in);</div><div class="line">byte[] buffer = new byte[10];</div><div class="line">int len = -1;</div><div class="line">Person p = (Person) os.readObject();</div><div class="line">System.out.println(p);  //Person [name=vae, age=1]</div><div class="line">os.close();</div></pre></td></tr></table></figure></p><h4 id="question"><a href="#question" class="headerlink" title="question"></a>question</h4><p>问题1：如果某些数据不需要做序列化，比如密码，比如上面的年龄？<br>解决办法：在字段面前加上 transient。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">private String name;//需要序列化</div><div class="line">transient private int age;//不需要序列化</div></pre></td></tr></table></figure></p><p>那么我们在反序列化的时候，打印出来的就是Person [name=vae, age=0]，整型数据默认值为 0。</p><p>问题2：序列化版本问题，在完成序列化操作后，由于项目的升级或修改，可能我们会对序列化对象进行修改，比如增加某个字段，那么我们在进行反序列化就会报错，怎么办？<br>解决办法：在 JavaBean 对象中增加一个 serialVersionUID 字段，用来固定这个版本，无论我们怎么修改，版本都是一致的，就能进行反序列化了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private static final long serialVersionUID = 8656128222714547171L;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-3289e870dfe8c06b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>参考链接：<br><a href="http://www.51gjie.com/java/686.html" target="_blank" rel="external">Java IO流详解</a><br><a href="https://www.jianshu.com/p/e591ca6642e9" target="_blank" rel="external">最完整的javaIO流总结</a><br><a href="https://www.cnblogs.com/furaywww/p/8849850.html" target="_blank" rel="external">Java IO流详解</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java FileUtils</title>
      <link href="/1900/01/02/01%20JAVA/02%20Java%20FileUtils/"/>
      <url>/1900/01/02/01%20JAVA/02%20Java%20FileUtils/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>文件/文件夹工具类，是对文件操作处理的方法进行了封装，提供了公共的方法。其中 closeIO()、writeFileFromIS() 两个方法是从其他工具类中移植过来的，这样保证代码可以编译通过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div><div class="line">522</div><div class="line">523</div><div class="line">524</div><div class="line">525</div><div class="line">526</div><div class="line">527</div><div class="line">528</div><div class="line">529</div><div class="line">530</div><div class="line">531</div><div class="line">532</div><div class="line">533</div><div class="line">534</div><div class="line">535</div><div class="line">536</div><div class="line">537</div><div class="line">538</div><div class="line">539</div><div class="line">540</div><div class="line">541</div><div class="line">542</div><div class="line">543</div><div class="line">544</div><div class="line">545</div><div class="line">546</div><div class="line">547</div><div class="line">548</div><div class="line">549</div><div class="line">550</div><div class="line">551</div><div class="line">552</div><div class="line">553</div><div class="line">554</div><div class="line">555</div><div class="line">556</div><div class="line">557</div><div class="line">558</div><div class="line">559</div><div class="line">560</div><div class="line">561</div><div class="line">562</div><div class="line">563</div><div class="line">564</div><div class="line">565</div><div class="line">566</div><div class="line">567</div><div class="line">568</div><div class="line">569</div><div class="line">570</div><div class="line">571</div><div class="line">572</div><div class="line">573</div><div class="line">574</div><div class="line">575</div><div class="line">576</div><div class="line">577</div><div class="line">578</div><div class="line">579</div><div class="line">580</div><div class="line">581</div><div class="line">582</div><div class="line">583</div><div class="line">584</div><div class="line">585</div><div class="line">586</div><div class="line">587</div><div class="line">588</div><div class="line">589</div><div class="line">590</div><div class="line">591</div><div class="line">592</div><div class="line">593</div><div class="line">594</div><div class="line">595</div><div class="line">596</div><div class="line">597</div><div class="line">598</div><div class="line">599</div><div class="line">600</div><div class="line">601</div><div class="line">602</div><div class="line">603</div><div class="line">604</div><div class="line">605</div><div class="line">606</div><div class="line">607</div><div class="line">608</div><div class="line">609</div><div class="line">610</div><div class="line">611</div><div class="line">612</div><div class="line">613</div><div class="line">614</div><div class="line">615</div><div class="line">616</div><div class="line">617</div><div class="line">618</div><div class="line">619</div><div class="line">620</div><div class="line">621</div><div class="line">622</div><div class="line">623</div><div class="line">624</div><div class="line">625</div><div class="line">626</div><div class="line">627</div><div class="line">628</div><div class="line">629</div><div class="line">630</div><div class="line">631</div><div class="line">632</div><div class="line">633</div><div class="line">634</div><div class="line">635</div><div class="line">636</div><div class="line">637</div><div class="line">638</div><div class="line">639</div><div class="line">640</div><div class="line">641</div><div class="line">642</div><div class="line">643</div><div class="line">644</div><div class="line">645</div><div class="line">646</div><div class="line">647</div><div class="line">648</div><div class="line">649</div><div class="line">650</div><div class="line">651</div><div class="line">652</div><div class="line">653</div><div class="line">654</div><div class="line">655</div><div class="line">656</div><div class="line">657</div><div class="line">658</div><div class="line">659</div><div class="line">660</div><div class="line">661</div><div class="line">662</div><div class="line">663</div><div class="line">664</div><div class="line">665</div><div class="line">666</div><div class="line">667</div><div class="line">668</div><div class="line">669</div><div class="line">670</div><div class="line">671</div><div class="line">672</div><div class="line">673</div><div class="line">674</div><div class="line">675</div><div class="line">676</div><div class="line">677</div><div class="line">678</div><div class="line">679</div><div class="line">680</div><div class="line">681</div><div class="line">682</div><div class="line">683</div><div class="line">684</div><div class="line">685</div><div class="line">686</div><div class="line">687</div><div class="line">688</div><div class="line">689</div><div class="line">690</div><div class="line">691</div><div class="line">692</div><div class="line">693</div><div class="line">694</div><div class="line">695</div><div class="line">696</div><div class="line">697</div><div class="line">698</div><div class="line">699</div><div class="line">700</div><div class="line">701</div><div class="line">702</div><div class="line">703</div><div class="line">704</div><div class="line">705</div><div class="line">706</div><div class="line">707</div><div class="line">708</div><div class="line">709</div><div class="line">710</div><div class="line">711</div><div class="line">712</div><div class="line">713</div><div class="line">714</div><div class="line">715</div><div class="line">716</div><div class="line">717</div><div class="line">718</div><div class="line">719</div><div class="line">720</div><div class="line">721</div><div class="line">722</div><div class="line">723</div><div class="line">724</div><div class="line">725</div><div class="line">726</div><div class="line">727</div><div class="line">728</div><div class="line">729</div><div class="line">730</div><div class="line">731</div><div class="line">732</div><div class="line">733</div><div class="line">734</div><div class="line">735</div><div class="line">736</div><div class="line">737</div><div class="line">738</div><div class="line">739</div><div class="line">740</div><div class="line">741</div><div class="line">742</div><div class="line">743</div><div class="line">744</div><div class="line">745</div><div class="line">746</div><div class="line">747</div><div class="line">748</div><div class="line">749</div><div class="line">750</div><div class="line">751</div><div class="line">752</div><div class="line">753</div><div class="line">754</div><div class="line">755</div><div class="line">756</div><div class="line">757</div><div class="line">758</div><div class="line">759</div><div class="line">760</div><div class="line">761</div><div class="line">762</div><div class="line">763</div><div class="line">764</div><div class="line">765</div><div class="line">766</div><div class="line">767</div><div class="line">768</div><div class="line">769</div><div class="line">770</div><div class="line">771</div><div class="line">772</div><div class="line">773</div><div class="line">774</div><div class="line">775</div><div class="line">776</div><div class="line">777</div><div class="line">778</div><div class="line">779</div><div class="line">780</div><div class="line">781</div><div class="line">782</div><div class="line">783</div><div class="line">784</div><div class="line">785</div><div class="line">786</div><div class="line">787</div><div class="line">788</div><div class="line">789</div><div class="line">790</div><div class="line">791</div><div class="line">792</div><div class="line">793</div><div class="line">794</div><div class="line">795</div><div class="line">796</div><div class="line">797</div><div class="line">798</div><div class="line">799</div><div class="line">800</div><div class="line">801</div><div class="line">802</div><div class="line">803</div><div class="line">804</div><div class="line">805</div><div class="line">806</div><div class="line">807</div><div class="line">808</div><div class="line">809</div><div class="line">810</div><div class="line">811</div><div class="line">812</div><div class="line">813</div><div class="line">814</div><div class="line">815</div><div class="line">816</div><div class="line">817</div><div class="line">818</div><div class="line">819</div><div class="line">820</div><div class="line">821</div><div class="line">822</div><div class="line">823</div><div class="line">824</div><div class="line">825</div><div class="line">826</div><div class="line">827</div><div class="line">828</div><div class="line">829</div><div class="line">830</div><div class="line">831</div><div class="line">832</div><div class="line">833</div><div class="line">834</div><div class="line">835</div><div class="line">836</div><div class="line">837</div><div class="line">838</div><div class="line">839</div><div class="line">840</div><div class="line">841</div><div class="line">842</div><div class="line">843</div><div class="line">844</div><div class="line">845</div><div class="line">846</div><div class="line">847</div><div class="line">848</div><div class="line">849</div><div class="line">850</div><div class="line">851</div><div class="line">852</div><div class="line">853</div><div class="line">854</div><div class="line">855</div><div class="line">856</div><div class="line">857</div><div class="line">858</div><div class="line">859</div><div class="line">860</div><div class="line">861</div><div class="line">862</div><div class="line">863</div><div class="line">864</div><div class="line">865</div><div class="line">866</div><div class="line">867</div><div class="line">868</div><div class="line">869</div><div class="line">870</div><div class="line">871</div><div class="line">872</div><div class="line">873</div><div class="line">874</div><div class="line">875</div><div class="line">876</div><div class="line">877</div><div class="line">878</div><div class="line">879</div><div class="line">880</div><div class="line">881</div><div class="line">882</div><div class="line">883</div><div class="line">884</div><div class="line">885</div><div class="line">886</div><div class="line">887</div><div class="line">888</div><div class="line">889</div><div class="line">890</div><div class="line">891</div><div class="line">892</div><div class="line">893</div><div class="line">894</div><div class="line">895</div><div class="line">896</div><div class="line">897</div><div class="line">898</div><div class="line">899</div><div class="line">900</div><div class="line">901</div><div class="line">902</div><div class="line">903</div><div class="line">904</div><div class="line">905</div><div class="line">906</div><div class="line">907</div><div class="line">908</div><div class="line">909</div><div class="line">910</div><div class="line">911</div><div class="line">912</div><div class="line">913</div><div class="line">914</div><div class="line">915</div><div class="line">916</div><div class="line">917</div><div class="line">918</div><div class="line">919</div><div class="line">920</div><div class="line">921</div><div class="line">922</div><div class="line">923</div><div class="line">924</div><div class="line">925</div><div class="line">926</div><div class="line">927</div><div class="line">928</div><div class="line">929</div><div class="line">930</div><div class="line">931</div><div class="line">932</div><div class="line">933</div><div class="line">934</div><div class="line">935</div><div class="line">936</div><div class="line">937</div><div class="line">938</div><div class="line">939</div><div class="line">940</div><div class="line">941</div><div class="line">942</div><div class="line">943</div><div class="line">944</div><div class="line">945</div><div class="line">946</div><div class="line">947</div><div class="line">948</div><div class="line">949</div><div class="line">950</div><div class="line">951</div><div class="line">952</div><div class="line">953</div><div class="line">954</div><div class="line">955</div><div class="line">956</div><div class="line">957</div><div class="line">958</div><div class="line">959</div><div class="line">960</div><div class="line">961</div><div class="line">962</div><div class="line">963</div><div class="line">964</div><div class="line">965</div><div class="line">966</div><div class="line">967</div><div class="line">968</div><div class="line">969</div><div class="line">970</div><div class="line">971</div><div class="line">972</div><div class="line">973</div><div class="line">974</div><div class="line">975</div><div class="line">976</div><div class="line">977</div><div class="line">978</div><div class="line">979</div><div class="line">980</div><div class="line">981</div><div class="line">982</div><div class="line">983</div><div class="line">984</div><div class="line">985</div><div class="line">986</div><div class="line">987</div><div class="line">988</div><div class="line">989</div><div class="line">990</div><div class="line">991</div><div class="line">992</div><div class="line">993</div><div class="line">994</div><div class="line">995</div><div class="line">996</div><div class="line">997</div><div class="line">998</div><div class="line">999</div><div class="line">1000</div><div class="line">1001</div><div class="line">1002</div><div class="line">1003</div><div class="line">1004</div><div class="line">1005</div><div class="line">1006</div><div class="line">1007</div><div class="line">1008</div><div class="line">1009</div><div class="line">1010</div><div class="line">1011</div><div class="line">1012</div><div class="line">1013</div><div class="line">1014</div><div class="line">1015</div><div class="line">1016</div><div class="line">1017</div><div class="line">1018</div><div class="line">1019</div><div class="line">1020</div><div class="line">1021</div><div class="line">1022</div><div class="line">1023</div><div class="line">1024</div><div class="line">1025</div><div class="line">1026</div><div class="line">1027</div><div class="line">1028</div><div class="line">1029</div><div class="line">1030</div><div class="line">1031</div><div class="line">1032</div><div class="line">1033</div><div class="line">1034</div><div class="line">1035</div><div class="line">1036</div><div class="line">1037</div><div class="line">1038</div><div class="line">1039</div><div class="line">1040</div><div class="line">1041</div><div class="line">1042</div><div class="line">1043</div><div class="line">1044</div><div class="line">1045</div><div class="line">1046</div><div class="line">1047</div><div class="line">1048</div><div class="line">1049</div><div class="line">1050</div><div class="line">1051</div><div class="line">1052</div><div class="line">1053</div><div class="line">1054</div><div class="line">1055</div><div class="line">1056</div><div class="line">1057</div><div class="line">1058</div><div class="line">1059</div><div class="line">1060</div><div class="line">1061</div><div class="line">1062</div><div class="line">1063</div><div class="line">1064</div><div class="line">1065</div><div class="line">1066</div><div class="line">1067</div><div class="line">1068</div><div class="line">1069</div><div class="line">1070</div><div class="line">1071</div><div class="line">1072</div><div class="line">1073</div><div class="line">1074</div><div class="line">1075</div><div class="line">1076</div><div class="line">1077</div><div class="line">1078</div><div class="line">1079</div><div class="line">1080</div><div class="line">1081</div><div class="line">1082</div><div class="line">1083</div><div class="line">1084</div><div class="line">1085</div><div class="line">1086</div><div class="line">1087</div><div class="line">1088</div><div class="line">1089</div><div class="line">1090</div><div class="line">1091</div><div class="line">1092</div><div class="line">1093</div><div class="line">1094</div><div class="line">1095</div><div class="line">1096</div><div class="line">1097</div><div class="line">1098</div><div class="line">1099</div><div class="line">1100</div><div class="line">1101</div><div class="line">1102</div><div class="line">1103</div><div class="line">1104</div><div class="line">1105</div><div class="line">1106</div><div class="line">1107</div><div class="line">1108</div><div class="line">1109</div><div class="line">1110</div><div class="line">1111</div><div class="line">1112</div><div class="line">1113</div><div class="line">1114</div><div class="line">1115</div><div class="line">1116</div><div class="line">1117</div><div class="line">1118</div><div class="line">1119</div><div class="line">1120</div><div class="line">1121</div><div class="line">1122</div><div class="line">1123</div><div class="line">1124</div><div class="line">1125</div><div class="line">1126</div><div class="line">1127</div><div class="line">1128</div><div class="line">1129</div><div class="line">1130</div><div class="line">1131</div><div class="line">1132</div><div class="line">1133</div><div class="line">1134</div><div class="line">1135</div><div class="line">1136</div><div class="line">1137</div><div class="line">1138</div><div class="line">1139</div><div class="line">1140</div><div class="line">1141</div><div class="line">1142</div><div class="line">1143</div><div class="line">1144</div><div class="line">1145</div><div class="line">1146</div><div class="line">1147</div><div class="line">1148</div><div class="line">1149</div><div class="line">1150</div><div class="line">1151</div><div class="line">1152</div><div class="line">1153</div><div class="line">1154</div><div class="line">1155</div><div class="line">1156</div><div class="line">1157</div><div class="line">1158</div><div class="line">1159</div><div class="line">1160</div><div class="line">1161</div><div class="line">1162</div><div class="line">1163</div><div class="line">1164</div><div class="line">1165</div><div class="line">1166</div><div class="line">1167</div><div class="line">1168</div><div class="line">1169</div><div class="line">1170</div><div class="line">1171</div><div class="line">1172</div><div class="line">1173</div><div class="line">1174</div><div class="line">1175</div><div class="line">1176</div><div class="line">1177</div><div class="line">1178</div><div class="line">1179</div><div class="line">1180</div><div class="line">1181</div><div class="line">1182</div><div class="line">1183</div><div class="line">1184</div><div class="line">1185</div><div class="line">1186</div><div class="line">1187</div><div class="line">1188</div><div class="line">1189</div><div class="line">1190</div><div class="line">1191</div><div class="line">1192</div><div class="line">1193</div><div class="line">1194</div><div class="line">1195</div><div class="line">1196</div><div class="line">1197</div><div class="line">1198</div><div class="line">1199</div><div class="line">1200</div><div class="line">1201</div><div class="line">1202</div><div class="line">1203</div><div class="line">1204</div><div class="line">1205</div><div class="line">1206</div><div class="line">1207</div><div class="line">1208</div><div class="line">1209</div><div class="line">1210</div><div class="line">1211</div><div class="line">1212</div><div class="line">1213</div><div class="line">1214</div><div class="line">1215</div><div class="line">1216</div><div class="line">1217</div><div class="line">1218</div><div class="line">1219</div><div class="line">1220</div><div class="line">1221</div><div class="line">1222</div><div class="line">1223</div><div class="line">1224</div><div class="line">1225</div><div class="line">1226</div><div class="line">1227</div><div class="line">1228</div><div class="line">1229</div><div class="line">1230</div><div class="line">1231</div><div class="line">1232</div><div class="line">1233</div><div class="line">1234</div><div class="line">1235</div><div class="line">1236</div><div class="line">1237</div><div class="line">1238</div><div class="line">1239</div><div class="line">1240</div><div class="line">1241</div><div class="line">1242</div><div class="line">1243</div><div class="line">1244</div><div class="line">1245</div><div class="line">1246</div><div class="line">1247</div><div class="line">1248</div><div class="line">1249</div><div class="line">1250</div><div class="line">1251</div><div class="line">1252</div><div class="line">1253</div><div class="line">1254</div><div class="line">1255</div><div class="line">1256</div><div class="line">1257</div><div class="line">1258</div><div class="line">1259</div><div class="line">1260</div><div class="line">1261</div><div class="line">1262</div><div class="line">1263</div><div class="line">1264</div><div class="line">1265</div><div class="line">1266</div><div class="line">1267</div><div class="line">1268</div><div class="line">1269</div><div class="line">1270</div><div class="line">1271</div><div class="line">1272</div><div class="line">1273</div><div class="line">1274</div><div class="line">1275</div><div class="line">1276</div><div class="line">1277</div><div class="line">1278</div><div class="line">1279</div><div class="line">1280</div><div class="line">1281</div><div class="line">1282</div><div class="line">1283</div><div class="line">1284</div><div class="line">1285</div><div class="line">1286</div><div class="line">1287</div><div class="line">1288</div><div class="line">1289</div><div class="line">1290</div><div class="line">1291</div><div class="line">1292</div><div class="line">1293</div><div class="line">1294</div><div class="line">1295</div><div class="line">1296</div><div class="line">1297</div><div class="line">1298</div><div class="line">1299</div><div class="line">1300</div><div class="line">1301</div><div class="line">1302</div><div class="line">1303</div><div class="line">1304</div><div class="line">1305</div><div class="line">1306</div><div class="line">1307</div><div class="line">1308</div><div class="line">1309</div><div class="line">1310</div><div class="line">1311</div><div class="line">1312</div><div class="line">1313</div><div class="line">1314</div><div class="line">1315</div><div class="line">1316</div><div class="line">1317</div><div class="line">1318</div><div class="line">1319</div><div class="line">1320</div><div class="line">1321</div><div class="line">1322</div><div class="line">1323</div><div class="line">1324</div><div class="line">1325</div><div class="line">1326</div><div class="line">1327</div><div class="line">1328</div><div class="line">1329</div><div class="line">1330</div><div class="line">1331</div><div class="line">1332</div><div class="line">1333</div><div class="line">1334</div><div class="line">1335</div><div class="line">1336</div><div class="line">1337</div><div class="line">1338</div><div class="line">1339</div><div class="line">1340</div><div class="line">1341</div><div class="line">1342</div><div class="line">1343</div><div class="line">1344</div><div class="line">1345</div><div class="line">1346</div><div class="line">1347</div><div class="line">1348</div><div class="line">1349</div><div class="line">1350</div><div class="line">1351</div><div class="line">1352</div><div class="line">1353</div><div class="line">1354</div><div class="line">1355</div><div class="line">1356</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import java.io.BufferedInputStream;</div><div class="line">import java.io.BufferedOutputStream;</div><div class="line">import java.io.Closeable;</div><div class="line">import java.io.File;</div><div class="line">import java.io.FileInputStream;</div><div class="line">import java.io.FileNotFoundException;</div><div class="line">import java.io.FileOutputStream;</div><div class="line">import java.io.FilenameFilter;</div><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.io.OutputStream;</div><div class="line">import java.security.DigestInputStream;</div><div class="line">import java.security.MessageDigest;</div><div class="line">import java.security.NoSuchAlgorithmException;</div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.Arrays;</div><div class="line">import java.util.Collections;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @Author XianXiaoTao</div><div class="line"> * @Describe：文件相关工具类</div><div class="line"> */</div><div class="line">public final class FileUtils &#123;</div><div class="line"></div><div class="line">    private FileUtils() &#123;</div><div class="line">        throw new UnsupportedOperationException(&quot;u can&apos;t instantiate me...&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static final String LINE_SEP = System.getProperty(&quot;line.separator&quot;);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 根据文件路径获取文件</div><div class="line">     *</div><div class="line">     * @param filePath 文件路径</div><div class="line">     * @return 文件</div><div class="line">     */</div><div class="line">    public static File getFileByPath(final String filePath) &#123;</div><div class="line">        return isSpace(filePath) ? null : new File(filePath);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 根据文件目录路径获取子目录名称（不获取二级子目录）</div><div class="line">     * @param dirPath 文件路径</div><div class="line">     * @return 文件目录名称</div><div class="line">     */</div><div class="line">    public static List&lt;String&gt; getFiledirList(String dirPath)&#123;</div><div class="line">        if (dirPath == null || !isDir(dirPath)) return null;</div><div class="line">        List&lt;String&gt; stringList = new ArrayList&lt;&gt;();</div><div class="line">        File f = new File(dirPath);</div><div class="line">        File[] files = f.listFiles();</div><div class="line">        if(files != null&amp;&amp; files.length != 0)&#123;</div><div class="line">            for (File file : files) &#123;</div><div class="line">                if (file.isDirectory()) &#123;</div><div class="line">                    stringList.add(file.getName());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return stringList;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 判断文件是否存在</div><div class="line">     *</div><div class="line">     * @param filePath 文件路径</div><div class="line">     * @return &#123;@code true&#125;: 存在&lt;br&gt;&#123;@code false&#125;: 不存在</div><div class="line">     */</div><div class="line">    public static boolean isFileExists(final String filePath) &#123;</div><div class="line">        return isFileExists(getFileByPath(filePath));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 判断文件是否存在</div><div class="line">     *</div><div class="line">     * @param file 文件</div><div class="line">     * @return &#123;@code true&#125;: 存在&lt;br&gt;&#123;@code false&#125;: 不存在</div><div class="line">     */</div><div class="line">    public static boolean isFileExists(final File file) &#123;</div><div class="line">        return file != null &amp;&amp; file.exists();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 重命名文件</div><div class="line">     *</div><div class="line">     * @param filePath 文件路径</div><div class="line">     * @param newName  新名称</div><div class="line">     * @return &#123;@code true&#125;: 重命名成功&lt;br&gt;&#123;@code false&#125;: 重命名失败</div><div class="line">     */</div><div class="line">    public static boolean rename(final String filePath, final String newName) &#123;</div><div class="line">        return rename(getFileByPath(filePath), newName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 重命名文件</div><div class="line">     *</div><div class="line">     * @param file    文件</div><div class="line">     * @param newName 新名称</div><div class="line">     * @return &#123;@code true&#125;: 重命名成功&lt;br&gt;&#123;@code false&#125;: 重命名失败</div><div class="line">     */</div><div class="line">    public static boolean rename(final File file, final String newName) &#123;</div><div class="line">        // 文件为空返回false</div><div class="line">        if (file == null) return false;</div><div class="line">        // 文件不存在返回false</div><div class="line">        if (!file.exists()) return false;</div><div class="line">        // 新的文件名为空返回false</div><div class="line">        if (isSpace(newName)) return false;</div><div class="line">        // 如果文件名没有改变返回true</div><div class="line">        if (newName.equals(file.getName())) return true;</div><div class="line">        File newFile = new File(file.getParent() + File.separator + newName);</div><div class="line">        // 如果重命名的文件已存在返回false</div><div class="line">        return !newFile.exists()</div><div class="line">                &amp;&amp; file.renameTo(newFile);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 判断是否是目录</div><div class="line">     *</div><div class="line">     * @param dirPath 目录路径</div><div class="line">     * @return &#123;@code true&#125;: 是&lt;br&gt;&#123;@code false&#125;: 否</div><div class="line">     */</div><div class="line">    public static boolean isDir(final String dirPath) &#123;</div><div class="line">        return isDir(getFileByPath(dirPath));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 判断是否是目录</div><div class="line">     *</div><div class="line">     * @param file 文件</div><div class="line">     * @return &#123;@code true&#125;: 是&lt;br&gt;&#123;@code false&#125;: 否</div><div class="line">     */</div><div class="line">    public static boolean isDir(final File file) &#123;</div><div class="line">        return isFileExists(file) &amp;&amp; file.isDirectory();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 判断是否是文件</div><div class="line">     *</div><div class="line">     * @param filePath 文件路径</div><div class="line">     * @return &#123;@code true&#125;: 是&lt;br&gt;&#123;@code false&#125;: 否</div><div class="line">     */</div><div class="line">    public static boolean isFile(final String filePath) &#123;</div><div class="line">        return isFile(getFileByPath(filePath));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 判断是否是文件</div><div class="line">     *</div><div class="line">     * @param file 文件</div><div class="line">     * @return &#123;@code true&#125;: 是&lt;br&gt;&#123;@code false&#125;: 否</div><div class="line">     */</div><div class="line">    public static boolean isFile(final File file) &#123;</div><div class="line">        return isFileExists(file) &amp;&amp; file.isFile();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 判断目录是否存在，不存在则判断是否创建成功</div><div class="line">     *</div><div class="line">     * @param dirPath 目录路径</div><div class="line">     * @return &#123;@code true&#125;: 存在或创建成功&lt;br&gt;&#123;@code false&#125;: 不存在或创建失败</div><div class="line">     */</div><div class="line">    public static boolean createOrExistsDir(final String dirPath) &#123;</div><div class="line">        return createOrExistsDir(getFileByPath(dirPath));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 判断目录是否存在，不存在则判断是否创建成功</div><div class="line">     *</div><div class="line">     * @param file 文件</div><div class="line">     * @return &#123;@code true&#125;: 存在或创建成功&lt;br&gt;&#123;@code false&#125;: 不存在或创建失败</div><div class="line">     */</div><div class="line">    public static boolean createOrExistsDir(final File file) &#123;</div><div class="line">        // 如果存在，是目录则返回true，是文件则返回false，不存在则返回是否创建成功</div><div class="line">        return file != null &amp;&amp; (file.exists() ? file.isDirectory() : file.mkdirs());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 判断文件是否存在，不存在则判断是否创建成功</div><div class="line">     *</div><div class="line">     * @param filePath 文件路径</div><div class="line">     * @return &#123;@code true&#125;: 存在或创建成功&lt;br&gt;&#123;@code false&#125;: 不存在或创建失败</div><div class="line">     */</div><div class="line">    public static boolean createOrExistsFile(final String filePath) &#123;</div><div class="line">        return createOrExistsFile(getFileByPath(filePath));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 判断文件是否存在，不存在则判断是否创建成功</div><div class="line">     *</div><div class="line">     * @param file 文件</div><div class="line">     * @return &#123;@code true&#125;: 存在或创建成功&lt;br&gt;&#123;@code false&#125;: 不存在或创建失败</div><div class="line">     */</div><div class="line">    public static boolean createOrExistsFile(final File file) &#123;</div><div class="line">        if (file == null) return false;</div><div class="line">        // 如果存在，是文件则返回true，是目录则返回false</div><div class="line">        if (file.exists()) return file.isFile();</div><div class="line">        if (!createOrExistsDir(file.getParentFile())) return false;</div><div class="line">        try &#123;</div><div class="line">            return file.createNewFile();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 判断文件是否存在，存在则在创建之前删除</div><div class="line">     *</div><div class="line">     * @param file 文件</div><div class="line">     * @return &#123;@code true&#125;: 创建成功&lt;br&gt;&#123;@code false&#125;: 创建失败</div><div class="line">     */</div><div class="line">    public static boolean createFileByDeleteOldFile(final File file) &#123;</div><div class="line">        if (file == null) return false;</div><div class="line">        // 文件存在并且删除失败返回false</div><div class="line">        if (file.exists() &amp;&amp; !file.delete()) return false;</div><div class="line">        // 创建目录失败返回false</div><div class="line">        if (!createOrExistsDir(file.getParentFile())) return false;</div><div class="line">        try &#123;</div><div class="line">            return file.createNewFile();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 复制或移动目录</div><div class="line">     *</div><div class="line">     * @param srcDirPath  源目录路径</div><div class="line">     * @param destDirPath 目标目录路径</div><div class="line">     * @param isMove      是否移动</div><div class="line">     * @return &#123;@code true&#125;: 复制或移动成功&lt;br&gt;&#123;@code false&#125;: 复制或移动失败</div><div class="line">     */</div><div class="line">    private static boolean copyOrMoveDir(final String srcDirPath, final String destDirPath, final boolean isMove) &#123;</div><div class="line">        return copyOrMoveDir(getFileByPath(srcDirPath), getFileByPath(destDirPath), isMove);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 复制或移动目录</div><div class="line">     *</div><div class="line">     * @param srcDir  源目录</div><div class="line">     * @param destDir 目标目录</div><div class="line">     * @param isMove  是否移动</div><div class="line">     * @return &#123;@code true&#125;: 复制或移动成功&lt;br&gt;&#123;@code false&#125;: 复制或移动失败</div><div class="line">     */</div><div class="line">    private static boolean copyOrMoveDir(final File srcDir, final File destDir, final boolean isMove) &#123;</div><div class="line">        if (srcDir == null || destDir == null) return false;</div><div class="line">        // 如果目标目录在源目录中则返回false，看不懂的话好好想想递归怎么结束</div><div class="line">        // srcPath : F:\\MyGithub\\AndroidUtilCode\\utilcode\\src\\test\\res</div><div class="line">        // destPath: F:\\MyGithub\\AndroidUtilCode\\utilcode\\src\\test\\res1</div><div class="line">        // 为防止以上这种情况出现出现误判，须分别在后面加个路径分隔符</div><div class="line">        String srcPath = srcDir.getPath() + File.separator;</div><div class="line">        String destPath = destDir.getPath() + File.separator;</div><div class="line">        if (destPath.contains(srcPath)) return false;</div><div class="line">        // 源文件不存在或者不是目录则返回false</div><div class="line">        if (!srcDir.exists() || !srcDir.isDirectory()) return false;</div><div class="line">        // 目标目录不存在返回false</div><div class="line">        if (!createOrExistsDir(destDir)) return false;</div><div class="line">        File[] files = srcDir.listFiles();</div><div class="line">        for (File file : files) &#123;</div><div class="line">            File oneDestFile = new File(destPath + file.getName());</div><div class="line">            if (file.isFile()) &#123;</div><div class="line">                // 如果操作失败返回false</div><div class="line">                if (!copyOrMoveFile(file, oneDestFile, isMove)) return false;</div><div class="line">            &#125; else if (file.isDirectory()) &#123;</div><div class="line">                // 如果操作失败返回false</div><div class="line">                if (!copyOrMoveDir(file, oneDestFile, isMove)) return false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return !isMove || deleteDir(srcDir);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 复制或移动文件</div><div class="line">     *</div><div class="line">     * @param srcFilePath  源文件路径</div><div class="line">     * @param destFilePath 目标文件路径</div><div class="line">     * @param isMove       是否移动</div><div class="line">     * @return &#123;@code true&#125;: 复制或移动成功&lt;br&gt;&#123;@code false&#125;: 复制或移动失败</div><div class="line">     */</div><div class="line">    private static boolean copyOrMoveFile(final String srcFilePath, final String destFilePath, final boolean isMove) &#123;</div><div class="line">        return copyOrMoveFile(getFileByPath(srcFilePath), getFileByPath(destFilePath), isMove);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 复制或移动文件</div><div class="line">     *</div><div class="line">     * @param srcFile  源文件</div><div class="line">     * @param destFile 目标文件</div><div class="line">     * @param isMove   是否移动</div><div class="line">     * @return &#123;@code true&#125;: 复制或移动成功&lt;br&gt;&#123;@code false&#125;: 复制或移动失败</div><div class="line">     */</div><div class="line">    private static boolean copyOrMoveFile(final File srcFile, final File destFile, final boolean isMove) &#123;</div><div class="line">        if (srcFile == null || destFile == null) return false;</div><div class="line">        // 源文件不存在或者不是文件则返回false</div><div class="line">        if (!srcFile.exists() || !srcFile.isFile()) return false;</div><div class="line">        // 目标文件存在且是文件则返回false</div><div class="line">        if (destFile.exists() &amp;&amp; destFile.isFile()) return false;</div><div class="line">        // 目标目录不存在返回false</div><div class="line">        if (!createOrExistsDir(destFile.getParentFile())) return false;</div><div class="line">        try &#123;</div><div class="line">            return writeFileFromIS(destFile, new FileInputStream(srcFile))</div><div class="line">                    &amp;&amp; !(isMove &amp;&amp; !deleteFile(srcFile));</div><div class="line">        &#125; catch (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 复制目录</div><div class="line">     *</div><div class="line">     * @param srcDirPath  源目录路径</div><div class="line">     * @param destDirPath 目标目录路径</div><div class="line">     * @return &#123;@code true&#125;: 复制成功&lt;br&gt;&#123;@code false&#125;: 复制失败</div><div class="line">     */</div><div class="line">    public static boolean copyDir(final String srcDirPath, final String destDirPath) &#123;</div><div class="line">        return copyDir(getFileByPath(srcDirPath), getFileByPath(destDirPath));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 复制目录</div><div class="line">     *</div><div class="line">     * @param srcDir  源目录</div><div class="line">     * @param destDir 目标目录</div><div class="line">     * @return &#123;@code true&#125;: 复制成功&lt;br&gt;&#123;@code false&#125;: 复制失败</div><div class="line">     */</div><div class="line">    public static boolean copyDir(final File srcDir, final File destDir) &#123;</div><div class="line">        return copyOrMoveDir(srcDir, destDir, false);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 复制文件</div><div class="line">     *</div><div class="line">     * @param srcFilePath  源文件路径</div><div class="line">     * @param destFilePath 目标文件路径</div><div class="line">     * @return &#123;@code true&#125;: 复制成功&lt;br&gt;&#123;@code false&#125;: 复制失败</div><div class="line">     */</div><div class="line">    public static boolean copyFile(final String srcFilePath, final String destFilePath) &#123;</div><div class="line">        return copyFile(getFileByPath(srcFilePath), getFileByPath(destFilePath));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 复制文件</div><div class="line">     *</div><div class="line">     * @param srcFile  源文件</div><div class="line">     * @param destFile 目标文件</div><div class="line">     * @return &#123;@code true&#125;: 复制成功&lt;br&gt;&#123;@code false&#125;: 复制失败</div><div class="line">     */</div><div class="line">    public static boolean copyFile(final File srcFile, final File destFile) &#123;</div><div class="line">        return copyOrMoveFile(srcFile, destFile, false);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 移动目录</div><div class="line">     *</div><div class="line">     * @param srcDirPath  源目录路径</div><div class="line">     * @param destDirPath 目标目录路径</div><div class="line">     * @return &#123;@code true&#125;: 移动成功&lt;br&gt;&#123;@code false&#125;: 移动失败</div><div class="line">     */</div><div class="line">    public static boolean moveDir(final String srcDirPath, final String destDirPath) &#123;</div><div class="line">        return moveDir(getFileByPath(srcDirPath), getFileByPath(destDirPath));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 移动目录</div><div class="line">     *</div><div class="line">     * @param srcDir  源目录</div><div class="line">     * @param destDir 目标目录</div><div class="line">     * @return &#123;@code true&#125;: 移动成功&lt;br&gt;&#123;@code false&#125;: 移动失败</div><div class="line">     */</div><div class="line">    public static boolean moveDir(final File srcDir, final File destDir) &#123;</div><div class="line">        return copyOrMoveDir(srcDir, destDir, true);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 移动文件</div><div class="line">     *</div><div class="line">     * @param srcFilePath  源文件路径</div><div class="line">     * @param destFilePath 目标文件路径</div><div class="line">     * @return &#123;@code true&#125;: 移动成功&lt;br&gt;&#123;@code false&#125;: 移动失败</div><div class="line">     */</div><div class="line">    public static boolean moveFile(final String srcFilePath, final String destFilePath) &#123;</div><div class="line">        return moveFile(getFileByPath(srcFilePath), getFileByPath(destFilePath));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 移动文件</div><div class="line">     *</div><div class="line">     * @param srcFile  源文件</div><div class="line">     * @param destFile 目标文件</div><div class="line">     * @return &#123;@code true&#125;: 移动成功&lt;br&gt;&#123;@code false&#125;: 移动失败</div><div class="line">     */</div><div class="line">    public static boolean moveFile(final File srcFile, final File destFile) &#123;</div><div class="line">        return copyOrMoveFile(srcFile, destFile, true);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 删除目录</div><div class="line">     *</div><div class="line">     * @param dirPath 目录路径</div><div class="line">     * @return &#123;@code true&#125;: 删除成功&lt;br&gt;&#123;@code false&#125;: 删除失败</div><div class="line">     */</div><div class="line">    public static boolean deleteDir(final String dirPath) &#123;</div><div class="line">        return deleteDir(getFileByPath(dirPath));</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 删除文件或目录</div><div class="line">     * @param file</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public static boolean deleteDirOrFile(File file)&#123;</div><div class="line">        if (file == null) return false;</div><div class="line">        if (!file.exists()) return false;</div><div class="line">        if(file.isFile())&#123;</div><div class="line">            return deleteFile(file);</div><div class="line">        &#125;else&#123;</div><div class="line">            return deleteDir(file);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 删除文件或目录</div><div class="line">     * @param path</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public static boolean deleteDirOrFile(String path)&#123;</div><div class="line">        return deleteDirOrFile(getFileByPath(path));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 删除目录</div><div class="line">     *</div><div class="line">     * @param dir 目录</div><div class="line">     * @return &#123;@code true&#125;: 删除成功&lt;br&gt;&#123;@code false&#125;: 删除失败</div><div class="line">     */</div><div class="line">    public static boolean deleteDir(final File dir) &#123;</div><div class="line">        if (dir == null) return false;</div><div class="line">        // 目录不存在返回true</div><div class="line">        if (!dir.exists()) return true;</div><div class="line">        // 不是目录返回false</div><div class="line">        if (!dir.isDirectory()) return false;</div><div class="line">        // 现在文件存在且是文件夹</div><div class="line">        File[] files = dir.listFiles();</div><div class="line">        if (files != null &amp;&amp; files.length != 0) &#123;</div><div class="line">            for (File file : files) &#123;</div><div class="line">                if (file.isFile()) &#123;</div><div class="line">                    if (!file.delete()) return false;</div><div class="line">                &#125; else if (file.isDirectory()) &#123;</div><div class="line">                    if (!deleteDir(file)) return false;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return dir.delete();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 删除Luban文件集合 以“|” 分割</div><div class="line">     * @param srcFilePaths</div><div class="line">     */</div><div class="line">    public static void deleteFiles(String srcFilePaths)&#123;</div><div class="line">        if (srcFilePaths == null || srcFilePaths.length() == 0)</div><div class="line">            return;</div><div class="line">        List&lt;String&gt; list = Arrays.asList(srcFilePaths.split(&quot;\\|&quot;));</div><div class="line">        for(String path : list)&#123;</div><div class="line">            if(path.contains(&quot;luban&quot;))&#123;</div><div class="line">                deleteFile(path);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 删除文件</div><div class="line">     *</div><div class="line">     * @param srcFilePath 文件路径</div><div class="line">     * @return &#123;@code true&#125;: 删除成功&lt;br&gt;&#123;@code false&#125;: 删除失败</div><div class="line">     */</div><div class="line">    public static boolean deleteFile(final String srcFilePath) &#123;</div><div class="line">        return deleteFile(getFileByPath(srcFilePath));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 删除文件</div><div class="line">     *</div><div class="line">     * @param file 文件</div><div class="line">     * @return &#123;@code true&#125;: 删除成功&lt;br&gt;&#123;@code false&#125;: 删除失败</div><div class="line">     */</div><div class="line">    public static boolean deleteFile(final File file) &#123;</div><div class="line">        return file != null &amp;&amp; (!file.exists() || file.isFile() &amp;&amp; file.delete());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 删除目录下的所有文件</div><div class="line">     *</div><div class="line">     * @param dirPath 目录路径</div><div class="line">     * @return &#123;@code true&#125;: 删除成功&lt;br&gt;&#123;@code false&#125;: 删除失败</div><div class="line">     */</div><div class="line">    public static boolean deleteFilesInDir(final String dirPath) &#123;</div><div class="line">        return deleteFilesInDir(getFileByPath(dirPath));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 删除目录下的所有文件</div><div class="line">     *</div><div class="line">     * @param dir 目录</div><div class="line">     * @return &#123;@code true&#125;: 删除成功&lt;br&gt;&#123;@code false&#125;: 删除失败</div><div class="line">     */</div><div class="line">    public static boolean deleteFilesInDir(final File dir) &#123;</div><div class="line">        if (dir == null) return false;</div><div class="line">        // 目录不存在返回true</div><div class="line">        if (!dir.exists()) return true;</div><div class="line">        // 不是目录返回false</div><div class="line">        if (!dir.isDirectory()) return false;</div><div class="line">        // 现在文件存在且是文件夹</div><div class="line">        File[] files = dir.listFiles();</div><div class="line">        if (files != null &amp;&amp; files.length != 0) &#123;</div><div class="line">            for (File file : files) &#123;</div><div class="line">                if (file.isFile()) &#123;</div><div class="line">                    if (!file.delete()) return false;</div><div class="line">                &#125; else if (file.isDirectory()) &#123;</div><div class="line">                    if (!deleteDir(file)) return false;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取目录下所有文件</div><div class="line">     *</div><div class="line">     * @param dirPath     目录路径</div><div class="line">     * @param isRecursive 是否递归进子目录</div><div class="line">     * @return 文件链表</div><div class="line">     */</div><div class="line">    public static List&lt;File&gt; listFilesInDir(final String dirPath, final boolean isRecursive) &#123;</div><div class="line">        return listFilesInDir(getFileByPath(dirPath), isRecursive);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取目录下所有文件</div><div class="line">     *</div><div class="line">     * @param dir         目录</div><div class="line">     * @param isRecursive 是否递归进子目录</div><div class="line">     * @return 文件链表</div><div class="line">     */</div><div class="line">    public static List&lt;File&gt; listFilesInDir(final File dir, final boolean isRecursive) &#123;</div><div class="line">        if (!isDir(dir)) return null;</div><div class="line">        if (isRecursive) return listFilesInDir(dir);</div><div class="line">        List&lt;File&gt; list = new ArrayList&lt;&gt;();</div><div class="line">        File[] files = dir.listFiles();</div><div class="line">        if (files != null &amp;&amp; files.length != 0) &#123;</div><div class="line">            Collections.addAll(list, files);</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取目录下所有文件包括子目录</div><div class="line">     *</div><div class="line">     * @param dirPath 目录路径</div><div class="line">     * @return 文件链表</div><div class="line">     */</div><div class="line">    public static List&lt;File&gt; listFilesInDir(final String dirPath) &#123;</div><div class="line">        return listFilesInDir(getFileByPath(dirPath));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取目录下所有文件包括子目录</div><div class="line">     *</div><div class="line">     * @param dir 目录</div><div class="line">     * @return 文件链表</div><div class="line">     */</div><div class="line">    public static List&lt;File&gt; listFilesInDir(final File dir) &#123;</div><div class="line">        if (!isDir(dir)) return null;</div><div class="line">        List&lt;File&gt; list = new ArrayList&lt;&gt;();</div><div class="line">        File[] files = dir.listFiles();</div><div class="line">        if (files != null &amp;&amp; files.length != 0) &#123;</div><div class="line">            for (File file : files) &#123;</div><div class="line">                list.add(file);</div><div class="line">                if (file.isDirectory()) &#123;</div><div class="line">                    List&lt;File&gt; fileList = listFilesInDir(file);</div><div class="line">                    if (fileList != null) &#123;</div><div class="line">                        list.addAll(fileList);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取目录下所有后缀名为suffix的文件</div><div class="line">     * &lt;p&gt;大小写忽略&lt;/p&gt;</div><div class="line">     *</div><div class="line">     * @param dirPath     目录路径</div><div class="line">     * @param suffix      后缀名</div><div class="line">     * @param isRecursive 是否递归进子目录</div><div class="line">     * @return 文件链表</div><div class="line">     */</div><div class="line">    public static List&lt;File&gt; listFilesInDirWithFilter(final String dirPath, final String suffix, final boolean isRecursive) &#123;</div><div class="line">        return listFilesInDirWithFilter(getFileByPath(dirPath), suffix, isRecursive);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取目录下所有后缀名为suffix的文件</div><div class="line">     * &lt;p&gt;大小写忽略&lt;/p&gt;</div><div class="line">     *</div><div class="line">     * @param dir         目录</div><div class="line">     * @param suffix      后缀名</div><div class="line">     * @param isRecursive 是否递归进子目录</div><div class="line">     * @return 文件链表</div><div class="line">     */</div><div class="line">    public static List&lt;File&gt; listFilesInDirWithFilter(final File dir, final String suffix, final boolean isRecursive) &#123;</div><div class="line">        if (isRecursive) return listFilesInDirWithFilter(dir, suffix);</div><div class="line">        if (dir == null || !isDir(dir)) return null;</div><div class="line">        List&lt;File&gt; list = new ArrayList&lt;&gt;();</div><div class="line">        File[] files = dir.listFiles();</div><div class="line">        if (files != null &amp;&amp; files.length != 0) &#123;</div><div class="line">            for (File file : files) &#123;</div><div class="line">                if(file.length()&gt;10)&#123;</div><div class="line">                    if (file.getName().toUpperCase().endsWith(suffix.toUpperCase())) &#123;</div><div class="line">                        list.add(file);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取目录下所有后缀名为suffix的文件包括子目录</div><div class="line">     * &lt;p&gt;大小写忽略&lt;/p&gt;</div><div class="line">     *</div><div class="line">     * @param dirPath 目录路径</div><div class="line">     * @param suffix  后缀名</div><div class="line">     * @return 文件链表</div><div class="line">     */</div><div class="line">    public static List&lt;File&gt; listFilesInDirWithFilter(final String dirPath, final String suffix) &#123;</div><div class="line">        return listFilesInDirWithFilter(getFileByPath(dirPath), suffix);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取目录下所有后缀名为suffix的文件包括子目录</div><div class="line">     * &lt;p&gt;大小写忽略&lt;/p&gt;</div><div class="line">     *</div><div class="line">     * @param dir    目录</div><div class="line">     * @param suffix 后缀名</div><div class="line">     * @return 文件链表</div><div class="line">     */</div><div class="line">    public static List&lt;File&gt; listFilesInDirWithFilter(final File dir, final String suffix) &#123;</div><div class="line">        if (dir == null || !isDir(dir)) return null;</div><div class="line">        List&lt;File&gt; list = new ArrayList&lt;&gt;();</div><div class="line">        File[] files = dir.listFiles();</div><div class="line">        if (files != null &amp;&amp; files.length != 0) &#123;</div><div class="line">            for (File file : files) &#123;</div><div class="line">                if (file.getName().toUpperCase().endsWith(suffix.toUpperCase())) &#123;</div><div class="line">                    list.add(file);</div><div class="line">                &#125;</div><div class="line">                if (file.isDirectory()) &#123;</div><div class="line">                    list.addAll(listFilesInDirWithFilter(file, suffix));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取目录下所有符合filter的文件</div><div class="line">     *</div><div class="line">     * @param dirPath     目录路径</div><div class="line">     * @param filter      过滤器</div><div class="line">     * @param isRecursive 是否递归进子目录</div><div class="line">     * @return 文件链表</div><div class="line">     */</div><div class="line">    public static List&lt;File&gt; listFilesInDirWithFilter(final String dirPath, final FilenameFilter filter, final boolean isRecursive) &#123;</div><div class="line">        return listFilesInDirWithFilter(getFileByPath(dirPath), filter, isRecursive);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取目录下所有符合filter的文件</div><div class="line">     *</div><div class="line">     * @param dir         目录</div><div class="line">     * @param filter      过滤器</div><div class="line">     * @param isRecursive 是否递归进子目录</div><div class="line">     * @return 文件链表</div><div class="line">     */</div><div class="line">    public static List&lt;File&gt; listFilesInDirWithFilter(final File dir, final FilenameFilter filter, final boolean isRecursive) &#123;</div><div class="line">        if (isRecursive) return listFilesInDirWithFilter(dir, filter);</div><div class="line">        if (dir == null || !isDir(dir)) return null;</div><div class="line">        List&lt;File&gt; list = new ArrayList&lt;&gt;();</div><div class="line">        File[] files = dir.listFiles();</div><div class="line">        if (files != null &amp;&amp; files.length != 0) &#123;</div><div class="line">            for (File file : files) &#123;</div><div class="line">                if (filter.accept(file.getParentFile(), file.getName())) &#123;</div><div class="line">                    list.add(file);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取目录下所有符合filter的文件包括子目录</div><div class="line">     *</div><div class="line">     * @param dirPath 目录路径</div><div class="line">     * @param filter  过滤器</div><div class="line">     * @return 文件链表</div><div class="line">     */</div><div class="line">    public static List&lt;File&gt; listFilesInDirWithFilter(final String dirPath, final FilenameFilter filter) &#123;</div><div class="line">        return listFilesInDirWithFilter(getFileByPath(dirPath), filter);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取目录下所有符合filter的文件包括子目录</div><div class="line">     *</div><div class="line">     * @param dir    目录</div><div class="line">     * @param filter 过滤器</div><div class="line">     * @return 文件链表</div><div class="line">     */</div><div class="line">    public static List&lt;File&gt; listFilesInDirWithFilter(final File dir, final FilenameFilter filter) &#123;</div><div class="line">        if (dir == null || !isDir(dir)) return null;</div><div class="line">        List&lt;File&gt; list = new ArrayList&lt;&gt;();</div><div class="line">        File[] files = dir.listFiles();</div><div class="line">        if (files != null &amp;&amp; files.length != 0) &#123;</div><div class="line">            for (File file : files) &#123;</div><div class="line">                if (filter.accept(file.getParentFile(), file.getName())) &#123;</div><div class="line">                    list.add(file);</div><div class="line">                &#125;</div><div class="line">                if (file.isDirectory()) &#123;</div><div class="line">                    list.addAll(listFilesInDirWithFilter(file, filter));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取目录下指定文件名的文件包括子目录</div><div class="line">     * &lt;p&gt;大小写忽略&lt;/p&gt;</div><div class="line">     *</div><div class="line">     * @param dirPath  目录路径</div><div class="line">     * @param fileName 文件名</div><div class="line">     * @return 文件链表</div><div class="line">     */</div><div class="line">    public static List&lt;File&gt; searchFileInDir(final String dirPath, final String fileName) &#123;</div><div class="line">        return searchFileInDir(getFileByPath(dirPath), fileName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取目录下指定文件名的文件包括子目录</div><div class="line">     * &lt;p&gt;大小写忽略&lt;/p&gt;</div><div class="line">     *</div><div class="line">     * @param dir      目录</div><div class="line">     * @param fileName 文件名</div><div class="line">     * @return 文件链表</div><div class="line">     */</div><div class="line">    public static List&lt;File&gt; searchFileInDir(final File dir, final String fileName) &#123;</div><div class="line">        if (dir == null || !isDir(dir)) return null;</div><div class="line">        List&lt;File&gt; list = new ArrayList&lt;&gt;();</div><div class="line">        File[] files = dir.listFiles();</div><div class="line">        if (files != null &amp;&amp; files.length != 0) &#123;</div><div class="line">            for (File file : files) &#123;</div><div class="line">                if (file.getName().toUpperCase().equals(fileName.toUpperCase())) &#123;</div><div class="line">                    list.add(file);</div><div class="line">                &#125;</div><div class="line">                if (file.isDirectory()) &#123;</div><div class="line">                    list.addAll(searchFileInDir(file, fileName));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取文件最后修改的毫秒时间戳</div><div class="line">     *</div><div class="line">     * @param filePath 文件路径</div><div class="line">     * @return 文件最后修改的毫秒时间戳</div><div class="line">     */</div><div class="line">    public static long getFileLastModified(final String filePath) &#123;</div><div class="line">        return getFileLastModified(getFileByPath(filePath));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取文件最后修改的毫秒时间戳</div><div class="line">     *</div><div class="line">     * @param file 文件</div><div class="line">     * @return 文件最后修改的毫秒时间戳</div><div class="line">     */</div><div class="line">    public static long getFileLastModified(final File file) &#123;</div><div class="line">        if (file == null) return -1;</div><div class="line">        return file.lastModified();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 简单获取文件编码格式</div><div class="line">     *</div><div class="line">     * @param filePath 文件路径</div><div class="line">     * @return 文件编码</div><div class="line">     */</div><div class="line">    public static String getFileCharsetSimple(final String filePath) &#123;</div><div class="line">        return getFileCharsetSimple(getFileByPath(filePath));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 简单获取文件编码格式</div><div class="line">     *</div><div class="line">     * @param file 文件</div><div class="line">     * @return 文件编码</div><div class="line">     */</div><div class="line">    public static String getFileCharsetSimple(final File file) &#123;</div><div class="line">        int p = 0;</div><div class="line">        InputStream is = null;</div><div class="line">        try &#123;</div><div class="line">            is = new BufferedInputStream(new FileInputStream(file));</div><div class="line">            p = (is.read() &lt;&lt; 8) + is.read();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            closeIO(is);</div><div class="line">        &#125;</div><div class="line">        switch (p) &#123;</div><div class="line">            case 0xefbb:</div><div class="line">                return &quot;UTF-8&quot;;</div><div class="line">            case 0xfffe:</div><div class="line">                return &quot;Unicode&quot;;</div><div class="line">            case 0xfeff:</div><div class="line">                return &quot;UTF-16BE&quot;;</div><div class="line">            default:</div><div class="line">                return &quot;GBK&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取文件行数</div><div class="line">     *</div><div class="line">     * @param filePath 文件路径</div><div class="line">     * @return 文件行数</div><div class="line">     */</div><div class="line">    public static int getFileLines(final String filePath) &#123;</div><div class="line">        return getFileLines(getFileByPath(filePath));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取文件行数</div><div class="line">     * &lt;p&gt;比readLine要快很多&lt;/p&gt;</div><div class="line">     *</div><div class="line">     * @param file 文件</div><div class="line">     * @return 文件行数</div><div class="line">     */</div><div class="line">    public static int getFileLines(final File file) &#123;</div><div class="line">        int count = 1;</div><div class="line">        InputStream is = null;</div><div class="line">        try &#123;</div><div class="line">            is = new BufferedInputStream(new FileInputStream(file));</div><div class="line">            byte[] buffer = new byte[1024];</div><div class="line">            int readChars;</div><div class="line">            if (LINE_SEP.endsWith(&quot;\n&quot;)) &#123;</div><div class="line">                while ((readChars = is.read(buffer, 0, 1024)) != -1) &#123;</div><div class="line">                    for (int i = 0; i &lt; readChars; ++i) &#123;</div><div class="line">                        if (buffer[i] == &apos;\n&apos;) ++count;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                while ((readChars = is.read(buffer, 0, 1024)) != -1) &#123;</div><div class="line">                    for (int i = 0; i &lt; readChars; ++i) &#123;</div><div class="line">                        if (buffer[i] == &apos;\r&apos;) ++count;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            closeIO(is);</div><div class="line">        &#125;</div><div class="line">        return count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取目录大小</div><div class="line">     *</div><div class="line">     * @param dirPath 目录路径</div><div class="line">     * @return 文件大小</div><div class="line">     */</div><div class="line">    public static String getDirSize(final String dirPath) &#123;</div><div class="line">        return getDirSize(getFileByPath(dirPath));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取目录大小</div><div class="line">     *</div><div class="line">     * @param dir 目录</div><div class="line">     * @return 文件大小</div><div class="line">     */</div><div class="line">    public static String getDirSize(final File dir) &#123;</div><div class="line">        long len = getDirLength(dir);</div><div class="line">        return len == -1 ? &quot;&quot; : byte2FitMemorySize(len);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取文件大小</div><div class="line">     *</div><div class="line">     * @param filePath 文件路径</div><div class="line">     * @return 文件大小</div><div class="line">     */</div><div class="line">    public static String getFileSize(final String filePath) &#123;</div><div class="line">        return getFileSize(getFileByPath(filePath));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取文件大小</div><div class="line">     *</div><div class="line">     * @param file 文件</div><div class="line">     * @return 文件大小</div><div class="line">     */</div><div class="line">    public static String getFileSize(final File file) &#123;</div><div class="line">        long len = getFileLength(file);</div><div class="line">        return len == -1 ? &quot;&quot; : byte2FitMemorySize(len);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取目录长度</div><div class="line">     *</div><div class="line">     * @param dirPath 目录路径</div><div class="line">     * @return 目录长度</div><div class="line">     */</div><div class="line">    public static long getDirLength(final String dirPath) &#123;</div><div class="line">        return getDirLength(getFileByPath(dirPath));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取目录长度</div><div class="line">     *</div><div class="line">     * @param dir 目录</div><div class="line">     * @return 目录长度</div><div class="line">     */</div><div class="line">    public static long getDirLength(final File dir) &#123;</div><div class="line">        if (!isDir(dir)) return -1;</div><div class="line">        long len = 0;</div><div class="line">        File[] files = dir.listFiles();</div><div class="line">        if (files != null &amp;&amp; files.length != 0) &#123;</div><div class="line">            for (File file : files) &#123;</div><div class="line">                if (file.isDirectory()) &#123;</div><div class="line">                    len += getDirLength(file);</div><div class="line">                &#125; else &#123;</div><div class="line">                    len += file.length();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return len;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取文件长度</div><div class="line">     *</div><div class="line">     * @param filePath 文件路径</div><div class="line">     * @return 文件长度</div><div class="line">     */</div><div class="line">    public static long getFileLength(final String filePath) &#123;</div><div class="line">        return getFileLength(getFileByPath(filePath));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取文件长度</div><div class="line">     *</div><div class="line">     * @param file 文件</div><div class="line">     * @return 文件长度</div><div class="line">     */</div><div class="line">    public static long getFileLength(final File file) &#123;</div><div class="line">        if (!isFile(file)) return -1;</div><div class="line">        return file.length();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取文件的MD5校验码</div><div class="line">     *</div><div class="line">     * @param filePath 文件路径</div><div class="line">     * @return 文件的MD5校验码</div><div class="line">     */</div><div class="line">    public static String getFileMD5ToString(final String filePath) &#123;</div><div class="line">        File file = isSpace(filePath) ? null : new File(filePath);</div><div class="line">        return getFileMD5ToString(file);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取文件的MD5校验码</div><div class="line">     *</div><div class="line">     * @param filePath 文件路径</div><div class="line">     * @return 文件的MD5校验码</div><div class="line">     */</div><div class="line">    public static byte[] getFileMD5(final String filePath) &#123;</div><div class="line">        File file = isSpace(filePath) ? null : new File(filePath);</div><div class="line">        return getFileMD5(file);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取文件的MD5校验码</div><div class="line">     *</div><div class="line">     * @param file 文件</div><div class="line">     * @return 文件的MD5校验码</div><div class="line">     */</div><div class="line">    public static String getFileMD5ToString(final File file) &#123;</div><div class="line">        return bytes2HexString(getFileMD5(file));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取文件的MD5校验码</div><div class="line">     *</div><div class="line">     * @param file 文件</div><div class="line">     * @return 文件的MD5校验码</div><div class="line">     */</div><div class="line">    public static byte[] getFileMD5(final File file) &#123;</div><div class="line">        if (file == null) return null;</div><div class="line">        DigestInputStream dis = null;</div><div class="line">        try &#123;</div><div class="line">            FileInputStream fis = new FileInputStream(file);</div><div class="line">            MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);</div><div class="line">            dis = new DigestInputStream(fis, md);</div><div class="line">            byte[] buffer = new byte[1024 * 256];</div><div class="line">            while (true) &#123;</div><div class="line">                if (!(dis.read(buffer) &gt; 0)) break;</div><div class="line">            &#125;</div><div class="line">            md = dis.getMessageDigest();</div><div class="line">            return md.digest();</div><div class="line">        &#125; catch (NoSuchAlgorithmException | IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            closeIO(dis);</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取全路径中的最长目录</div><div class="line">     *</div><div class="line">     * @param file 文件</div><div class="line">     * @return filePath最长目录</div><div class="line">     */</div><div class="line">    public static String getDirName(final File file) &#123;</div><div class="line">        if (file == null) return null;</div><div class="line">        return getDirName(file.getPath());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取全路径中的最长目录</div><div class="line">     *</div><div class="line">     * @param filePath 文件路径</div><div class="line">     * @return filePath最长目录</div><div class="line">     */</div><div class="line">    public static String getDirName(final String filePath) &#123;</div><div class="line">        if (isSpace(filePath)) return filePath;</div><div class="line">        int lastSep = filePath.lastIndexOf(File.separator);</div><div class="line">        return lastSep == -1 ? &quot;&quot; : filePath.substring(0, lastSep + 1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取全路径中的文件名</div><div class="line">     *</div><div class="line">     * @param file 文件</div><div class="line">     * @return 文件名</div><div class="line">     */</div><div class="line">    public static String getFileName(final File file) &#123;</div><div class="line">        if (file == null) return null;</div><div class="line">        return getFileName(file.getPath());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取全路径中的文件名</div><div class="line">     *</div><div class="line">     * @param filePath 文件路径</div><div class="line">     * @return 文件名</div><div class="line">     */</div><div class="line">    public static String getFileName(final String filePath) &#123;</div><div class="line">        if (isSpace(filePath)) return filePath;</div><div class="line">        int lastSep = filePath.lastIndexOf(File.separator);</div><div class="line">        return lastSep == -1 ? filePath : filePath.substring(lastSep + 1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取全路径中的不带拓展名的文件名</div><div class="line">     *</div><div class="line">     * @param file 文件</div><div class="line">     * @return 不带拓展名的文件名</div><div class="line">     */</div><div class="line">    public static String getFileNameNoExtension(final File file) &#123;</div><div class="line">        if (file == null) return null;</div><div class="line">        return getFileNameNoExtension(file.getPath());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取全路径中的不带拓展名的文件名</div><div class="line">     *</div><div class="line">     * @param filePath 文件路径</div><div class="line">     * @return 不带拓展名的文件名</div><div class="line">     */</div><div class="line">    public static String getFileNameNoExtension(final String filePath) &#123;</div><div class="line">        if (isSpace(filePath)) return filePath;</div><div class="line">        int lastPoi = filePath.lastIndexOf(&apos;.&apos;);</div><div class="line">        int lastSep = filePath.lastIndexOf(File.separator);</div><div class="line">        if (lastSep == -1) &#123;</div><div class="line">            return (lastPoi == -1 ? filePath : filePath.substring(0, lastPoi));</div><div class="line">        &#125;</div><div class="line">        if (lastPoi == -1 || lastSep &gt; lastPoi) &#123;</div><div class="line">            return filePath.substring(lastSep + 1);</div><div class="line">        &#125;</div><div class="line">        return filePath.substring(lastSep + 1, lastPoi);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取全路径中的文件拓展名</div><div class="line">     *</div><div class="line">     * @param file 文件</div><div class="line">     * @return 文件拓展名</div><div class="line">     */</div><div class="line">    public static String getFileExtension(final File file) &#123;</div><div class="line">        if (file == null) return null;</div><div class="line">        return getFileExtension(file.getPath());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取全路径中的文件拓展名</div><div class="line">     *</div><div class="line">     * @param filePath 文件路径</div><div class="line">     * @return 文件拓展名</div><div class="line">     */</div><div class="line">    public static String getFileExtension(final String filePath) &#123;</div><div class="line">        if (isSpace(filePath)) return filePath;</div><div class="line">        int lastPoi = filePath.lastIndexOf(&apos;.&apos;);</div><div class="line">        int lastSep = filePath.lastIndexOf(File.separator);</div><div class="line">        if (lastPoi == -1 || lastSep &gt;= lastPoi) return &quot;&quot;;</div><div class="line">        return filePath.substring(lastPoi + 1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ///////////////////////////////////////////////////////////////////////////</div><div class="line">    // copy from ConvertUtils</div><div class="line">    ///////////////////////////////////////////////////////////////////////////</div><div class="line"></div><div class="line">    private static final char hexDigits[] = &#123;&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;&#125;;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * byteArr转hexString</div><div class="line">     * &lt;p&gt;例如：&lt;/p&gt;</div><div class="line">     * bytes2HexString(new byte[] &#123; 0, (byte) 0xa8 &#125;) returns 00A8</div><div class="line">     *</div><div class="line">     * @param bytes 字节数组</div><div class="line">     * @return 16进制大写字符串</div><div class="line">     */</div><div class="line">    private static String bytes2HexString(final byte[] bytes) &#123;</div><div class="line">        if (bytes == null) return null;</div><div class="line">        int len = bytes.length;</div><div class="line">        if (len &lt;= 0) return null;</div><div class="line">        char[] ret = new char[len &lt;&lt; 1];</div><div class="line">        for (int i = 0, j = 0; i &lt; len; i++) &#123;</div><div class="line">            ret[j++] = hexDigits[bytes[i] &gt;&gt;&gt; 4 &amp; 0x0f];</div><div class="line">            ret[j++] = hexDigits[bytes[i] &amp; 0x0f];</div><div class="line">        &#125;</div><div class="line">        return new String(ret);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 字节数转合适内存大小</div><div class="line">     * &lt;p&gt;保留3位小数&lt;/p&gt;</div><div class="line">     *</div><div class="line">     * @param byteNum 字节数</div><div class="line">     * @return 合适内存大小</div><div class="line">     */</div><div class="line">    private static String byte2FitMemorySize(final long byteNum) &#123;</div><div class="line">        if (byteNum &lt; 0) &#123;</div><div class="line">            return &quot;shouldn&apos;t be less than zero!&quot;;</div><div class="line">        &#125; else if (byteNum &lt; 1024) &#123;</div><div class="line">            return String.format(&quot;%.3fB&quot;, (double) byteNum + 0.0005);</div><div class="line">        &#125; else if (byteNum &lt; 1048576) &#123;</div><div class="line">            return String.format(&quot;%.3fKB&quot;, (double) byteNum / 1024 + 0.0005);</div><div class="line">        &#125; else if (byteNum &lt; 1073741824) &#123;</div><div class="line">            return String.format(&quot;%.3fMB&quot;, (double) byteNum / 1048576 + 0.0005);</div><div class="line">        &#125; else &#123;</div><div class="line">            return String.format(&quot;%.3fGB&quot;, (double) byteNum / 1073741824 + 0.0005);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static boolean isSpace(final String s) &#123;</div><div class="line">        if (s == null) return true;</div><div class="line">        for (int i = 0, len = s.length(); i &lt; len; ++i) &#123;</div><div class="line">            if (!Character.isWhitespace(s.charAt(i))) &#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // ---------------</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 在指定的位置创建指定的文件</div><div class="line">     * @param filePath 完整的文件路径</div><div class="line">     * @param mkdir 是否创建相关的文件夹</div><div class="line">     * @throws IOException</div><div class="line">     */</div><div class="line">    public static void mkFile(String filePath, boolean mkdir) throws IOException&#123;</div><div class="line">        File file = new File(filePath);</div><div class="line">        /**</div><div class="line">         * mkdirs()创建多层目录，mkdir()创建单层目录</div><div class="line">         * writeObject时才创建磁盘文件。</div><div class="line">         * 若不创建文件，readObject出错。</div><div class="line">         */</div><div class="line">        file.getParentFile().mkdirs();</div><div class="line">        file.createNewFile();</div><div class="line">        file = null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 在指定的位置创建文件夹</div><div class="line">     * @param dirPath 文件夹路径</div><div class="line">     * @return 若创建成功，则返回True；反之，则返回False</div><div class="line">     */</div><div class="line">    public static boolean mkDir(String dirPath) &#123;</div><div class="line">        return new File(dirPath).mkdirs();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 删除指定的文件</div><div class="line">     * @param filePath 文件路径</div><div class="line">     * @return 若删除成功，则返回True；反之，则返回False</div><div class="line">     */</div><div class="line">    public static boolean delFile(String filePath) &#123;</div><div class="line">        return new File(filePath).delete();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 删除指定的文件夹</div><div class="line">     * @param dirPath 文件夹路径</div><div class="line">     * @param delFile 文件夹中是否包含文件</div><div class="line">     * @return 若删除成功，则返回True；反之，则返回False</div><div class="line">     */</div><div class="line">    public static boolean delDir(String dirPath, boolean delFile) &#123;</div><div class="line">        if (delFile) &#123;</div><div class="line">            File file = new File(dirPath);</div><div class="line">            if (file.isFile()) &#123;</div><div class="line">                return file.delete();</div><div class="line">            &#125; else if (file.isDirectory()) &#123;</div><div class="line">                if (file.listFiles().length == 0) &#123;</div><div class="line">                    return file.delete();</div><div class="line">                &#125; else &#123;</div><div class="line">                    int zFiles = file.listFiles().length;</div><div class="line">                    File[] delfile = file.listFiles();</div><div class="line">                    for (int i = 0; i &lt; zFiles; i++) &#123;</div><div class="line">                        if (delfile[i].isDirectory()) &#123;</div><div class="line">                            delDir(delfile[i].getAbsolutePath(), true);</div><div class="line">                        &#125;</div><div class="line">                        delfile[i].delete();</div><div class="line">                    &#125;</div><div class="line">                    return file.delete();</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            return new File(dirPath).delete();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 复制文件/文件夹 若要进行文件夹复制，请勿将目标文件夹置于源文件夹中</div><div class="line">     * @param source 源文件（夹）</div><div class="line">     * @param target 目标文件（夹）</div><div class="line">     * @param isFolder 若进行文件夹复制，则为True；反之为False</div><div class="line">     * @throws IOException</div><div class="line">     */</div><div class="line">    public static void copy(String source, String target, boolean isFolder) throws IOException&#123;</div><div class="line">        if (isFolder) &#123;</div><div class="line">            new File(target).mkdirs();</div><div class="line">            File a = new File(source);</div><div class="line">            String[] file = a.list();</div><div class="line">            File temp = null;</div><div class="line">            for (int i = 0; i &lt; file.length; i++) &#123;</div><div class="line">                if (source.endsWith(File.separator)) &#123;</div><div class="line">                    temp = new File(source + file[i]);</div><div class="line">                &#125; else &#123;</div><div class="line">                    temp = new File(source + File.separator + file[i]);</div><div class="line">                &#125;</div><div class="line">                if (temp.isFile()) &#123;</div><div class="line">                    FileInputStream input = new FileInputStream(temp);</div><div class="line">                    FileOutputStream output = new FileOutputStream(target + File.separator + temp.getName().toString());</div><div class="line">                    byte[] b = new byte[1024];</div><div class="line">                    int len;</div><div class="line">                    while ((len = input.read(b)) != -1) &#123;</div><div class="line">                        output.write(b, 0, len);</div><div class="line">                    &#125;</div><div class="line">                    output.flush();</div><div class="line">                    output.close();</div><div class="line">                    input.close();</div><div class="line">                &#125; if (temp.isDirectory()) &#123;</div><div class="line">                    copy(source + File.separator + file[i], target + File.separator + file[i], true);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            int byteread = 0;</div><div class="line">            File oldFile = new File(source);</div><div class="line">            if (oldFile.exists()) &#123;</div><div class="line">                InputStream inputStream = new FileInputStream(source);</div><div class="line">                File file = new File(target);</div><div class="line">                file.getParentFile().mkdirs();</div><div class="line">                file.createNewFile();</div><div class="line">                FileOutputStream outputStream = new FileOutputStream(file);</div><div class="line">                byte[] buffer = new byte[1024];</div><div class="line">                while ((byteread = inputStream.read(buffer)) != -1)&#123;</div><div class="line">                    outputStream.write(buffer, 0, byteread);</div><div class="line">                &#125;</div><div class="line">                inputStream.close();</div><div class="line">                outputStream.close();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 关闭IO，从 CloseUtils 中移植过来的</div><div class="line">     * @param closeables closeables</div><div class="line">     */</div><div class="line">    private static void closeIO(Closeable... closeables) &#123;</div><div class="line">        if (closeables == null) return;</div><div class="line">        for (Closeable closeable : closeables) &#123;</div><div class="line">            if (closeable != null) &#123;</div><div class="line">                try &#123; closeable.close(); &#125; catch (IOException e) &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 将输入流写入文件，从 FileIOUtils 中移植过来的</div><div class="line">     *</div><div class="line">     * @param file   文件</div><div class="line">     * @param is     输入流</div><div class="line">     * @return &#123;@code true&#125;: 写入成功&lt;br&gt;&#123;@code false&#125;: 写入失败</div><div class="line">     */</div><div class="line">    private static boolean writeFileFromIS(final File file, final InputStream is) &#123;</div><div class="line">        if (!createOrExistsFile(file) || is == null) return false;</div><div class="line">        OutputStream os = null;</div><div class="line">        try &#123;</div><div class="line">            os = new BufferedOutputStream(new FileOutputStream(file));</div><div class="line">            byte data[] = new byte[8192];</div><div class="line">            int len;</div><div class="line">            while ((len = is.read(data, 0, 8192)) != -1) &#123;</div><div class="line">                os.write(data, 0, len);</div><div class="line">            &#125;</div><div class="line">            return true;</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            return false;</div><div class="line">        &#125; finally &#123;</div><div class="line">            CloseUtils.closeIO(is, os);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>参考链接：<a href="https://www.cnblogs.com/android-deli/p/10322150.html" target="_blank" rel="external">ANDROID-FILEUTILS工具类</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java File</title>
      <link href="/1900/01/01/01%20JAVA/01%20Java%20File/"/>
      <url>/1900/01/01/01%20JAVA/01%20Java%20File/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="一、File-类"><a href="#一、File-类" class="headerlink" title="一、File 类"></a>一、File 类</h3><hr><p>File 是“文件”和“目录路径名”的抽象表示形式，它直接继承于 Object，实现了 Serializable 接口和 Comparable 接口。实现 Serializable 接口，意味着 File 对象支持序列化操作。而实现 Comparable 接口，意味着 File 对象之间可以比较大小；File 能直接被存储在有序集合(如 TreeSet、TreeMap 中)。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public class File extends Object implements Serializable, Comparable&lt;File&gt;</div></pre></td></tr></table></figure><p>File 类的实例是不可变的；也就是说，一旦创建，File 对象表示的抽象路径名将永不改变。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">// 通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例。</div><div class="line">// 如果给定字符串是空字符串，那么结果是空抽象路径名。</div><div class="line">File(String pathname)</div><div class="line"></div><div class="line">// 根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。</div><div class="line">// 如果 parent 为 null，则创建一个新的 File 实例，</div><div class="line">// 这与调用给定 child 路径名字符串的单参数 File 构造方法的效果一样。</div><div class="line">// 否则，parent 抽象路径名用于表示目录，child 路径名字符串用于表示目录或文件。</div><div class="line">// 如果 child 路径名字符串是绝对路径名，则用与系统有关的方式将它转换为一个相对路径名。</div><div class="line">// 如果 parent 是空抽象路径名，则通过将 child 转换为抽象路径名，</div><div class="line">// 并根据与系统有关的默认目录解析结果来创建新的 File 实例。</div><div class="line">// 否则，将每个路径名字符串转换为一个抽象路径名，并根据父抽象路径名解析子抽象路径名。</div><div class="line">File(File parent, String child)</div><div class="line"></div><div class="line">// 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。</div><div class="line">// 如果 parent 为 null，则创建一个新的 File 实例，</div><div class="line">// 这与调用以给定 child 路径名字符串作为参数的单参数 File 构造方法效果一样。</div><div class="line">// 否则，parent 路径名字符串用于表示目录，child 路径名字符串用于表示目录或文件。</div><div class="line">// 如果 child 路径名字符串是绝对路径名，则用与系统有关的方式将它转换为一个相对路径名。</div><div class="line">// 如果 parent 是空字符串，则通过将 child 转换为抽象路径名，</div><div class="line">// 并根据与系统有关的默认目录解析结果来创建新的 File 实例。</div><div class="line">// 否则，将每个路径名字符串转换为一个抽象路径名，并根据父抽象路径名解析子抽象路径名。</div><div class="line">File(String parent, String child)</div><div class="line"></div><div class="line">// 通过将给定的 file: URI转换为一个抽象路径名来创建一个新的 File 实例。</div><div class="line">// file: URI 的具体形式与系统有关，因此，由此构造方法执行的转换也与系统有关。</div><div class="line">// 对于某个给定抽象路径名 f，可以保证：new File( f.toURI()).equals(f.getAbsoluteFile()) </div><div class="line">// 只要原始抽象路径名、URI 和新抽象路径名都是在同一 Java 虚拟机（或者它的不同调用）中创建的。</div><div class="line">// 但是，当在某一操作系统上的虚拟机中创建的 file: URI </div><div class="line">// 在不同操作系统上的虚拟机中被转换为抽象路径名时，这种关系通常是不成立的。</div><div class="line">File(URI uri)</div></pre></td></tr></table></figure><p>利用构造方法，指定路径名、文件名等来构造 File 类的对象，之后调用该对象的 createNewFile() 方法就可以创建出相应的文件。</p><p>parent 指定路径（父目录），可以是 File 类对象也可以是字符串， child 中也可以加入路径层级，但要注意，所用的路径必须存在，不存在的路径不会新建。</p><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 路径分割符&quot;:&quot;,此字段被初始化为包含系统属性 file.separator 值的第一个字符。</div><div class="line">// 在 UNIX 系统上，此字段的值为 &apos;/&apos;；在 Microsoft Windows 系统上，它为 &apos;\\&apos;。</div><div class="line">public static final String pathSeparator</div><div class="line">// 路径分割符&apos;:&apos;,此字段被初始为包含系统属性 path.separator 值的第一个字符。</div><div class="line">// 此字符用于分隔以路径列表 形式给定的文件序列中的文件名。</div><div class="line">// 在 UNIX 系统上，此字段为 &apos;:&apos;；在Microsoft Windows 系统上，它为 &apos;;&apos;。</div><div class="line">public static final char pathSeparatorChar</div><div class="line">// 分隔符&quot;/&quot;</div><div class="line">public static final String separator     </div><div class="line">// 分隔符&apos;/&apos;       </div><div class="line">public static final char separatorChar</div></pre></td></tr></table></figure><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">// 按字母顺序比较两个抽象路径名。</div><div class="line">int compareTo(File pathname)</div><div class="line">// 计算此抽象路径名的哈希码。</div><div class="line">int hashCode()</div><div class="line"></div><div class="line">// 构造一个表示此抽象路径名的 file: URI。</div><div class="line">URI toURI()</div><div class="line">// 已过时。 此方法不会自动转义 URL 中的非法字符。</div><div class="line">// 建议新的代码使用以下方式将抽象路径名转换为 URL：</div><div class="line">// 首先通过 toURI 方法将其转换为 URI，然后通过 URI.toURL 方法将 URI 装换为 URL。</div><div class="line">URL toURL() </div><div class="line"></div><div class="line">// 返回此抽象路径名表示的文件最后一次被修改的时间。</div><div class="line">long lastModified()</div><div class="line">// 返回由此抽象路径名表示的文件的长度。</div><div class="line">long length()</div><div class="line">// 返回此抽象路径名指定的分区中未分配的字节数。</div><div class="line">long getFreeSpace()</div><div class="line">// 返回此抽象路径名指定的分区大小。</div><div class="line">long getTotalSpace() </div><div class="line">// 返回此抽象路径名指定的分区上可用于此虚拟机的字节数。</div><div class="line">long getUsableSpace()</div><div class="line"></div><div class="line">// 在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。</div><div class="line">void deleteOnExit()</div><div class="line">// 返回此抽象路径名的绝对路径名形式。</div><div class="line">File getAbsoluteFile() </div><div class="line">// 返回此抽象路径名的规范形式。</div><div class="line">File getCanonicalFile() </div><div class="line">// 返回此抽象路径名父目录的抽象路径名；如果此路径名没有指定父目录，则返回 null。</div><div class="line">File getParentFile() </div><div class="line"></div><div class="line">// 返回此抽象路径名的路径名字符串。</div><div class="line">String toString()</div><div class="line">// 返回此抽象路径名的绝对路径名字符串。</div><div class="line">String getAbsolutePath()</div><div class="line">// 返回此抽象路径名的规范路径名字符串。</div><div class="line">String getCanonicalPath() </div><div class="line">// 返回由此抽象路径名表示的文件或目录的名称。</div><div class="line">String getName()</div><div class="line">// 返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 null。</div><div class="line">String getParent()</div><div class="line">// 将此抽象路径名转换为一个路径名字符串。</div><div class="line">String getPath() </div><div class="line"></div><div class="line">// 测试应用程序是否可以执行此抽象路径名表示的文件。</div><div class="line">boolean canExecute()</div><div class="line">// 测试应用程序是否可以读取此抽象路径名表示的文件。</div><div class="line">boolean canRead()</div><div class="line">// 测试应用程序是否可以修改此抽象路径名表示的文件。</div><div class="line">boolean canWrite()</div><div class="line">// 当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。</div><div class="line">boolean createNewFile() </div><div class="line">// 删除此抽象路径名表示的文件或目录。</div><div class="line">boolean delete()</div><div class="line">// 测试此抽象路径名与给定对象是否相等。</div><div class="line">boolean equals(Object obj) </div><div class="line">// 测试此抽象路径名表示的文件或目录是否存在。</div><div class="line">boolean exists() </div><div class="line">// 测试此抽象路径名是否为绝对路径名。</div><div class="line">boolean isAbsolute()</div><div class="line">// 测试此抽象路径名表示的文件是否是一个目录。</div><div class="line">boolean isDirectory()</div><div class="line">// 测试此抽象路径名表示的文件是否是一个标准文件。</div><div class="line">boolean isFile()</div><div class="line">// 测试此抽象路径名指定的文件是否是一个隐藏文件。</div><div class="line">boolean isHidden()</div><div class="line">// 创建此抽象路径名指定的目录。</div><div class="line">boolean mkdir()</div><div class="line">// 创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。</div><div class="line">boolean mkdirs()</div><div class="line">// 重新命名此抽象路径名表示的文件。</div><div class="line">boolean renameTo(File dest)</div><div class="line">// 设置此抽象路径名所有者执行权限的一个便捷方法。</div><div class="line">boolean setExecutable(boolean executable)</div><div class="line">// 设置此抽象路径名的所有者或所有用户的执行权限。</div><div class="line">boolean setExecutable(boolean executable, boolean ownerOnly)</div><div class="line">// 设置此抽象路径名指定的文件或目录的最后一次修改时间。</div><div class="line">boolean setLastModified(long time)</div><div class="line">// 设置此抽象路径名所有者读权限的一个便捷方法。</div><div class="line">boolean setReadable(boolean readable)</div><div class="line">// 设置此抽象路径名的所有者或所有用户的读权限。</div><div class="line">boolean setReadable(boolean readable, boolean ownerOnly)</div><div class="line">// 标记此抽象路径名指定的文件或目录，从而只能对其进行读操作。</div><div class="line">boolean setReadOnly()</div><div class="line">// 设置此抽象路径名所有者写权限的一个便捷方法。</div><div class="line">boolean setWritable(boolean writable)</div><div class="line">// 设置此抽象路径名的所有者或所有用户的写权限。</div><div class="line">boolean setWritable(boolean writable, boolean ownerOnly)</div><div class="line"></div><div class="line">// 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。</div><div class="line">String[] list()</div><div class="line">// 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录。</div><div class="line">String[] list(FilenameFilter filter)</div><div class="line"></div><div class="line">// 返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。</div><div class="line">File[] listFiles()</div><div class="line">// 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。</div><div class="line">File[] listFiles(FileFilter filter)</div><div class="line">// 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。</div><div class="line">File[] listFiles(FilenameFilter filter)</div><div class="line"></div><div class="line">// 列出可用的文件系统根。</div><div class="line">static File[] listRoots()</div><div class="line">// 在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。</div><div class="line">static File createTempFile(String prefix, String suffix)</div><div class="line">// 在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。</div><div class="line">static File createTempFile(String prefix, String suffix, File directory)</div></pre></td></tr></table></figure><h3 id="二、创建文件"><a href="#二、创建文件" class="headerlink" title="二、创建文件"></a>二、创建文件</h3><hr><p>File 创建文件使用 file.createNewFile() 函数，因为有四种构造函数，所以有 4 种创建文件的情形。举例：在“dir”目录(相对路径)下新建文件“file1.txt”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">// 第一种</div><div class="line">try &#123;</div><div class="line">    File dir = new File(&quot;dir&quot;);    // 获取目录“dir”对应的File对象</div><div class="line">    File file1 = new File(dir, &quot;file1.txt&quot;);</div><div class="line">    file1.createNewFile();</div><div class="line">&#125; catch (IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第二种</div><div class="line">try &#123;</div><div class="line">    File file2 = new File(&quot;dir&quot;, &quot;file2.txt&quot;);</div><div class="line">    file2.createNewFile();</div><div class="line">&#125; catch (IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第三种</div><div class="line">try &#123;</div><div class="line">    File file3 = new File(&quot;/home/sky/dir/file3.txt&quot;);   //linux创建文件</div><div class="line">    //File file3 = new File(&quot;D:/dir/file4.txt&quot;);   // windows创建文件</div><div class="line">    file3.createNewFile();</div><div class="line">&#125; catch (IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第四种</div><div class="line">try &#123;</div><div class="line">    URI uri = new URI(&quot;file:/home/skywang/dir/file4.txt&quot;); </div><div class="line">    File file4 = new File(uri);</div><div class="line">    file4.createNewFile();</div><div class="line">&#125; catch (IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="三、创建目录"><a href="#三、创建目录" class="headerlink" title="三、创建目录"></a>三、创建目录</h3><hr><p><strong>根据相对路径创建目录</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">File dir = new File(&quot;dir&quot;);</div><div class="line">dir.mkdir();</div></pre></td></tr></table></figure></p><p>在当前路径下新建目录“dir”。</p><p><strong>根据绝对路径新建目录</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">File dir = new File(&quot;/home/sky/dir&quot;);  linux创建</div><div class="line">//File dir = new File(&quot;D:/dir&quot;);   windows创建</div><div class="line">dir.mkdirs();</div></pre></td></tr></table></figure></p><p>新建目录“/home/sky/dir”。</p><p><strong>创建目录第三种方式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">URI uri = new URI(&quot;file:/home/sky/dir&quot;); </div><div class="line">File dir = new File(uri);</div><div class="line">sub.mkdir();</div></pre></td></tr></table></figure></p><h3 id="四、创建子目录"><a href="#四、创建子目录" class="headerlink" title="四、创建子目录"></a>四、创建子目录</h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// 方法一</div><div class="line">// 在dir目录下新建sub1目录，并且在当前目录下 &quot;dir/sub1&quot;。</div><div class="line">// 它能正常运行的前提是“sub1”的父目录“dir”已经存在！</div><div class="line">File sub1 = new File(&quot;dir&quot;, &quot;sub1&quot;);</div><div class="line">sub1.mkdir();</div><div class="line"></div><div class="line">// 方法二</div><div class="line">// 在dir目录下新建sub2目录，并且在当前目录下 &quot;dir/sub2&quot;。</div><div class="line">// 它能正常运行的前提是“sub2”的父目录“dir”已经存在！</div><div class="line">File sub2 = new File(dir, &quot;sub2&quot;);</div><div class="line">sub2.mkdir();</div><div class="line"></div><div class="line">// 方法三</div><div class="line">// 在dir目录下新建sub3目录，并且在当前目录下 &quot;dir/sub3&quot;。</div><div class="line">// 它不需要dir已经存在，也能正常运行；若“sub3”的父母路不存在，</div><div class="line">// mkdirs()方法会自动创建父目录。</div><div class="line">File sub3 = new File(&quot;dir/sub3&quot;);</div><div class="line">sub3.mkdirs();</div><div class="line"></div><div class="line">// 方法四</div><div class="line">// 新建目录&quot;/home/skywang/dir/sub3&quot;。它不需要dir已经存在，</div><div class="line">// 也能正常运行；若“sub4”的父母路不存在，</div><div class="line">// mkdirs()方法会自动创建父目录。</div><div class="line">File sub4 = new File(&quot;/home/skywang/dir/sub4&quot;);</div><div class="line">sub4.mkdirs();</div><div class="line"></div><div class="line">// 方法五</div><div class="line">URI uri = new URI(&quot;file:/home/skywang/dir/sub5&quot;); </div><div class="line">File sub5 = new File(uri);</div><div class="line">sub5.mkdirs();</div></pre></td></tr></table></figure><h3 id="五、目录操作示例"><a href="#五、目录操作示例" class="headerlink" title="五、目录操作示例"></a>五、目录操作示例</h3><ol><li><p>返回文件名数组<br>String[] list()<br>String[] list(FilenameFilter filter)</p></li><li><p>返回 File 数组<br>File[] listFiles()<br>File[] listFiles(FileFilter filter)<br>File[] listFiles(FilenameFilter filter)</p></li></ol><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * File 类有一个 listFiles(FileNameFilter filter).</div><div class="line"> * 只需要实现一个简单的 filter 就可以找到满足 filter 条件的所有文件。</div><div class="line"> * 例如我要在 E:\data\file_selector_test 目录下面查找以 .txt 结尾的文件</div><div class="line"> *</div><div class="line"> * @author 先小涛</div><div class="line"> */</div><div class="line">class FileNameSelector implements FilenameFilter &#123;</div><div class="line">    private String extension = &quot;.&quot;;</div><div class="line"></div><div class="line">    public FileNameSelector(String fileExtensionNoDot) &#123;</div><div class="line">        extension += fileExtensionNoDot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean accept(File dir, String name) &#123;</div><div class="line">        return name.endsWith(extension);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 删除文件夹下的所有文件以及该文件夹</div><div class="line">    public static void deleteDirectory(File file) &#123;</div><div class="line">        File[] fileArray = file.listFiles();</div><div class="line">        if (fileArray.length &gt; 0) &#123;</div><div class="line">            for (File f : fileArray) &#123;</div><div class="line">                if (f.isFile()) &#123;</div><div class="line">                    if (f.delete()) &#123;</div><div class="line">                        System.out.println(f + &quot;文件删除成功&quot;);</div><div class="line">                    &#125; else &#123;</div><div class="line">                        System.out.println(f + &quot;文件删除失败&quot;);</div><div class="line">                    &#125;</div><div class="line">                &#125; else &#123;</div><div class="line">                    deleteDirectory(f);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 删除文件夹</div><div class="line">        if (file.delete()) &#123;</div><div class="line">            System.out.println(file + &quot;文件夹删除成功&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            System.out.println(file + &quot;文件夹删除失败&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 扫描指定文件夹下的所有文件，并输出</div><div class="line">    public static void findAllFiles(File f) &#123;</div><div class="line">        // 判断给定的路径是否是目录</div><div class="line">        if (f.isDirectory()) &#123;</div><div class="line">            File[] files = f.listFiles();</div><div class="line">            // 再依次循环进行判断</div><div class="line">            for (File file : files) &#123;</div><div class="line">                // 继续把内容传入到 findAllFiles 方法之中进行验证</div><div class="line">                findAllFiles(file);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            System.out.println(f);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        File directory = new File(&quot;E:\\test\\file_selector_test&quot;);</div><div class="line">        // listFiles() 列出所有文件</div><div class="line">        File[] files = directory.listFiles();</div><div class="line">        System.out.println(&quot;\n目录&quot; + directory.getName() + &quot;下的所有文件&quot;);</div><div class="line">        for (File file : files) &#123;</div><div class="line">            System.out.print(&quot;  &quot; + file.getName());</div><div class="line">        &#125;</div><div class="line">        // listFiles(FileNameFilter filter) 列出所有.txt文件</div><div class="line">        File[] txtFiles = directory.listFiles(new FileNameSelector(&quot;txt&quot;));</div><div class="line">        System.out.println(&quot;\n目录&quot; + directory.getName() + &quot;下的.txt文件&quot;);</div><div class="line">        for (File file : txtFiles) &#123;</div><div class="line">            System.out.print(&quot;  &quot; + file.getName());</div><div class="line">        &#125;</div><div class="line">        // isDirectory() 判断是否为文件目录</div><div class="line">        if(directory.isDirectory()) &#123;</div><div class="line">            System.out.println(directory.getPath() + &quot; is Directory&quot;);</div><div class="line">        &#125;</div><div class="line">        // isFile() 判断是否为文件</div><div class="line">        if(directory.isFile()) &#123;</div><div class="line">            System.out.println(directory.getPath() + &quot; is File&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // File.separator输出不同的系统中斜杠的方向</div><div class="line">        // 在windows中斜杠的方向是向右斜的\\</div><div class="line">        // 在Linux  中斜杠的方向是向左斜的//</div><div class="line">        System.out.println(&quot;File.separator:&quot; + File.separator);</div><div class="line">        String pathName = &quot;e:&quot; + File.separator + &quot;test&quot; + File.separator</div><div class="line">                + &quot;file_selector_test&quot; + File.separator + &quot;io.txt&quot;;</div><div class="line">        File f = new File(pathName);</div><div class="line">        try &#123;</div><div class="line">            // createNewFile() 方法：创建指定文件夹下的文件，如果文件夹不存在</div><div class="line">            // 会报&quot;找不到指定路径&quot;错误，应该首先手动创建该文件夹。返回值为 boolean</div><div class="line">            // 若没有该文件，创建成功返回 true；若又该文件则创建失败返回 false</div><div class="line">            System.out.println(f.createNewFile());</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            // TODO Auto-generated catch block</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // delete() 方法：删除一个文件或者整个文件夹，返回值为布尔类型</div><div class="line">        // 如果删除的是文件夹，必须保证是一个空文件夹，否则删除失败</div><div class="line">        File f0 = new File(&quot;E:\\test\\file_selector_test\\io.txt&quot;);</div><div class="line">        boolean boo = f0.delete();</div><div class="line">        if (boo) &#123;</div><div class="line">            System.out.println(&quot;成功删除文件&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            System.out.println(&quot;删除失败&quot;);</div><div class="line">        &#125;</div><div class="line">        // 调用创建的方法进行删除文件夹以及该文件夹下的所有文件</div><div class="line">        deleteDirectory(new File(&quot;E:\\test\\file_selector_test2&quot;));</div><div class="line"></div><div class="line">        File f1 = new File(&quot;e:&quot; + File.separator + &quot;test&quot;+File.separator+&quot;io.txt&quot;);</div><div class="line">        // getPath() 方法：将此抽象路径名转换为一个路径名字符串</div><div class="line">        System.out.println(f1.getPath());</div><div class="line">        // getParent() 方法：返回此抽象路径名父目录的路径名字符串；</div><div class="line">        // 如果此路径名没有指定父目录，则返回 nul</div><div class="line">        System.out.println(f1.getParent());</div><div class="line">        if (f1.exists()) &#123;</div><div class="line">            f1.delete();</div><div class="line">        &#125; else &#123;</div><div class="line">            try &#123;</div><div class="line">                System.out.println(f1.createNewFile());</div><div class="line">            &#125; catch(Exception e)&#123;&#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // list()方法：返回一个字符串数组，这些字符串指定此抽象路径名</div><div class="line">        // 表示的目录中的文件和目录，列出的仅是名称。</div><div class="line">        File f2 = new File(&quot;E:\\test\\file_selector_test&quot;);</div><div class="line">        String[] str = f2.list();</div><div class="line">        for(int i=0; i&lt;str.length; i++)&#123;</div><div class="line">            System.out.println(str[i]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 扫描某个路径下的所有文件</div><div class="line">        findAllFiles(new File(&quot;E:\\&quot;));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-db0d22bd21db20fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>参考链接：<a href="http://www.51gjie.com/java/688.html" target="_blank" rel="external">Java File 类</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
