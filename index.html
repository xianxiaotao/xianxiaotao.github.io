<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="King">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="King">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="King">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>King</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">King</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">xianxiaotao</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2200/01/01/Custom View/00 Android 自定义控件 目录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="King">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2200/01/01/Custom View/00 Android 自定义控件 目录/" itemprop="url">精通 Android 自定义 View 目录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2200-01-01T00:00:00+08:00">
                2200-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Custom-View/" itemprop="url" rel="index">
                    <span itemprop="name">Custom View</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇从自定义控件的动画、绘图、视图三方面入手，分别讲解与自定义控件相关的各种知识，给大家系统的梳理相关知识。不仅适合 Android 初、中级水平从业者，也适合高水平从业者查漏补缺使用。</p>
<p>内容摘自启舰所著的书籍《Android 自定义控件开发入门与实践》。</p>
<h2 id="第1章-绘图基础"><a href="#第1章-绘图基础" class="headerlink" title="第1章  绘图基础"></a>第1章  绘图基础</h2><h3 id="1-1-基本图形绘制"><a href="#1-1-基本图形绘制" class="headerlink" title="1.1 基本图形绘制"></a>1.1 基本图形绘制</h3><p>|— 1.1.1 概述<br>|— 1.1.2 画笔的基本设置<br>|— 1.1.3 Canvas使用基础<br>|— 1.1.4 Rect与RectF<br>|— 1.1.5 Color</p>
<h3 id="1-2-路径"><a href="#1-2-路径" class="headerlink" title="1.2 路径"></a>1.2 路径</h3><p>|— 1.2.1 概述<br>|— 1.2.2 直线路径<br>|— 1.2.3 弧线路径<br>|— 1.2.4 addXXX系列函数<br>|— 1.2.5 填充模式<br>|— 1.2.6 重置路径<br>|— 1.2.7 示例:蜘蛛网状图</p>
<h3 id="1-3-文字"><a href="#1-3-文字" class="headerlink" title="1.3 文字"></a>1.3 文字</h3><p>|— 1.3.1 Paint设置<br>|— 1.3.2 Canvas绘制文本<br>|— 1.3.3 设置字体样式</p>
<h3 id="1-4-Region"><a href="#1-4-Region" class="headerlink" title="1.4 Region"></a>1.4 Region</h3><p>|— 1.4.1 构造Region<br>|— 1.4.2 枚举区域——RegionIterator类<br>|— 1.4.3 区域相交<br>|— 1.4.4 其他函数</p>
<h3 id="1-5-Canvas-画布"><a href="#1-5-Canvas-画布" class="headerlink" title="1.5 Canvas(画布)"></a>1.5 Canvas(画布)</h3><p>|— 1.5.1 Canvas变换<br>|— 1.5.2 画布的保存与恢复<br>|— 1.5.3 示例一:圆形头像<br>|— 1.5.4 示例二:裁剪动画</p>
<h3 id="1-6-控件的使用方法"><a href="#1-6-控件的使用方法" class="headerlink" title="1.6 控件的使用方法"></a>1.6 控件的使用方法</h3><p>|— 1.6.1 控件概述<br>|— 1.6.2 通过XML引入控件<br>|— 1.6.3 动态添加控件</p>
<h2 id="第2章-视图动画"><a href="#第2章-视图动画" class="headerlink" title="第2章 视图动画"></a>第2章 视图动画</h2><h3 id="2-1-视图动画标签"><a href="#2-1-视图动画标签" class="headerlink" title="2.1 视图动画标签"></a>2.1 视图动画标签</h3><p>|— 2.1.1 概述<br>|— 2.1.2 scale 标签<br>|— 2.1.3 alpha 标签<br>|— 2.1.4 rotate 标签<br>|— 2.1.5 translate 标签<br>|— 2.1.6 set 标签</p>
<h3 id="2-2-视图动画的代码实现"><a href="#2-2-视图动画的代码实现" class="headerlink" title="2.2 视图动画的代码实现"></a>2.2 视图动画的代码实现</h3><p>|— 2.2.1 概述<br>|— 2.2.2 ScaleAnimation<br>|— 2.2.3 AlphaAnimation<br>|— 2.2.4 RotateAnimation<br>|— 2.2.5 TranslateAnimation<br>|— 2.2.6 AnimationSet<br>|— 2.2.7 Animation</p>
<h3 id="2-3-插值器初探"><a href="#2-3-插值器初探" class="headerlink" title="2.3 插值器初探"></a>2.3 插值器初探</h3><p>|— 2.3.1 AccelerateDecelerateInterpolator<br>|— 2.3.2 AccelerateInterpolator<br>|— 2.3.3 DecelerateInterpolator<br>|— 2.3.4 LinearInterpolator<br>|— 2.3.5 BounceInterpolator<br>|— 2.3.6 AnticipateInterpolator<br>|— 2.3.7 OvershootInterpolator<br>|— 2.3.8 AnticipateOvershootInterpolator<br>|— 2.3.9 CycleInterpolator</p>
<h3 id="2-4-动画示例"><a href="#2-4-动画示例" class="headerlink" title="2.4 动画示例"></a>2.4 动画示例</h3><p>|— 2.4.1 镜头由远及近效果<br>|— 2.4.2 加载框效果<br>|— 2.4.3 扫描动画</p>
<h3 id="2-5-逐帧动画"><a href="#2-5-逐帧动画" class="headerlink" title="2.5 逐帧动画"></a>2.5 逐帧动画</h3><p>|— 2.5.1 XML 实现<br>|— 2.5.2 代码实现</p>
<h2 id="第3章-属性动画"><a href="#第3章-属性动画" class="headerlink" title="第3章 属性动画"></a>第3章 属性动画</h2><h3 id="3-1-ValueAnimator-的基本使用"><a href="#3-1-ValueAnimator-的基本使用" class="headerlink" title="3.1 ValueAnimator 的基本使用"></a>3.1 ValueAnimator 的基本使用</h3><p>|— 3.1.1 概述<br>|— 3.1.2 ValueAnimator 的简单使用<br>|— 3.1.3 常用函数<br>|— 3.1.4 示例：弹跳加载中效果</p>
<h3 id="3-2-自定义插值器与-Evaluator"><a href="#3-2-自定义插值器与-Evaluator" class="headerlink" title="3.2 自定义插值器与 Evaluator"></a>3.2 自定义插值器与 Evaluator</h3><p>|— 3.2.1 自定义插值器<br>|— 3.2.2 Evaluator</p>
<h3 id="3-3-ValueAnimator-进阶——ofObject"><a href="#3-3-ValueAnimator-进阶——ofObject" class="headerlink" title="3.3 ValueAnimator 进阶——ofObject"></a>3.3 ValueAnimator 进阶——ofObject</h3><p>|— 3.3.1 概述<br>|— 3.3.2 示例：抛物动画</p>
<h3 id="3-4-ObjectAnimator"><a href="#3-4-ObjectAnimator" class="headerlink" title="3.4 ObjectAnimator"></a>3.4 ObjectAnimator</h3><p>|— 3.4.1 概述<br>|— 3.4.2 ObjectAnimator 动画原理<br>|— 3.4.3 自定义 ObjectAnimator 属性<br>|— 3.4.4 何时需要实现对应的 get 函数<br>|— 3.4.5 常用函数</p>
<h3 id="3-5-组合动画——AnimatorSet"><a href="#3-5-组合动画——AnimatorSet" class="headerlink" title="3.5 组合动画——AnimatorSet"></a>3.5 组合动画——AnimatorSet</h3><p>|— 3.5.1 playSequentially() 与 playTogether() 函数<br>|— 3.5.2 AnimatorSet.Builder<br>|— 3.5.3 AnimatorSet 监听器<br>|— 3.5.4 常用函数<br>|— 3.5.5 示例：路径动画</p>
<h3 id="3-6-Animator-动画的-XML-实现"><a href="#3-6-Animator-动画的-XML-实现" class="headerlink" title="3.6 Animator 动画的 XML 实现"></a>3.6 Animator 动画的 XML 实现</h3><p>|— 3.6.1 animator 标签<br>|— 3.6.2 objectAnimator 标签<br>|— 3.6.3 set 标签</p>
<h2 id="第4章-属性动画进阶"><a href="#第4章-属性动画进阶" class="headerlink" title="第4章 属性动画进阶"></a>第4章 属性动画进阶</h2><h3 id="4-1-PropertyValuesHolder-与-Keyframe"><a href="#4-1-PropertyValuesHolder-与-Keyframe" class="headerlink" title="4.1 PropertyValuesHolder 与 Keyframe"></a>4.1 PropertyValuesHolder 与 Keyframe</h3><p>|— 4.1.1 PropertyValuesHolder<br>|— 4.1.2 Keyframe<br>|— 4.1.3 PropertyValuesHolder 其他函数<br>|— 4.1.4 示例：电话响铃效果</p>
<h3 id="4-2-ViewPropertyAnimator"><a href="#4-2-ViewPropertyAnimator" class="headerlink" title="4.2 ViewPropertyAnimator"></a>4.2 ViewPropertyAnimator</h3><p>|— 4.2.1 概述<br>|— 4.2.2 常用函数</p>
<h3 id="4-3-为-ViewGroup-内的组件添加动画"><a href="#4-3-为-ViewGroup-内的组件添加动画" class="headerlink" title="4.3 为 ViewGroup 内的组件添加动画"></a>4.3 为 ViewGroup 内的组件添加动画</h3><p>|— 4.3.1 animateLayoutChanges 属性<br>|— 4.3.2 LayoutTransition<br>|— 4.3.3 其他函数</p>
<h3 id="4-4-开源动画库-NineOldAndroids"><a href="#4-4-开源动画库-NineOldAndroids" class="headerlink" title="4.4 开源动画库 NineOldAndroids"></a>4.4 开源动画库 NineOldAndroids</h3><p>|— 4.4.1 NineOldAndroids 中的 ViewPropertyAnimator<br>|— 4.4.2 NineOldAndroids 中的 ViewHelper</p>
<h2 id="第5章-动画进阶"><a href="#第5章-动画进阶" class="headerlink" title="第5章 动画进阶"></a>第5章 动画进阶</h2><h3 id="5-1-利用-PathMeasure-实现路径动画"><a href="#5-1-利用-PathMeasure-实现路径动画" class="headerlink" title="5.1 利用 PathMeasure 实现路径动画"></a>5.1 利用 PathMeasure 实现路径动画</h3><p>|— 5.1.1 初始化<br>|— 5.1.2 简单函数使用<br>|— 5.1.3 getSegment() 函数<br>|— 5.1.4 getPosTan() 函数<br>|— 5.1.5 getMatrix() 函数<br>|— 5.1.6 示例：支付宝支付成功动画</p>
<h3 id="5-2-SVG-动画"><a href="#5-2-SVG-动画" class="headerlink" title="5.2 SVG 动画"></a>5.2 SVG 动画</h3><p>|— 5.2.1 概述<br>|— 5.2.2 vector 标签与图像显示<br>|— 5.2.3 动态 Vector<br>|— 5.2.4 示例：输入搜索动画</p>
<h2 id="第6章-Paint-基本使用"><a href="#第6章-Paint-基本使用" class="headerlink" title="第6章 Paint 基本使用"></a>第6章 Paint 基本使用</h2><h3 id="6-1-硬件加速"><a href="#6-1-硬件加速" class="headerlink" title="6.1 硬件加速"></a>6.1 硬件加速</h3><p>|— 6.1.1 概述<br>|— 6.1.2 软件绘制与硬件加速的区别<br>|— 6.1.3 禁用 GPU 硬件加速的方法</p>
<h3 id="6-2-文字"><a href="#6-2-文字" class="headerlink" title="6.2 文字"></a>6.2 文字</h3><p>|— 6.2.1 概述<br>|— 6.2.2 绘图四格线与 FontMetrics<br>|— 6.2.3 常用函数<br>|— 6.2.4 示例：定点写字</p>
<h3 id="6-3-Paint-常用函数"><a href="#6-3-Paint-常用函数" class="headerlink" title="6.3 Paint 常用函数"></a>6.3 Paint 常用函数</h3><p>|— 6.3.1 基本设置函数<br>|— 6.3.2 字体相关函数</p>
<h2 id="第7章-绘图进阶"><a href="#第7章-绘图进阶" class="headerlink" title="第7章 绘图进阶"></a>第7章 绘图进阶</h2><h3 id="7-1-贝济埃曲线"><a href="#7-1-贝济埃曲线" class="headerlink" title="7.1 贝济埃曲线"></a>7.1 贝济埃曲线</h3><p>|— 7.1.1 概述<br>|— 7.1.2 贝济埃曲线之 quadTo<br>|— 7.1.3 贝济埃曲线之 rQuadTo<br>|— 7.1.4 示例：波浪效果</p>
<h3 id="7-2-setShadowLayer-与阴影效果"><a href="#7-2-setShadowLayer-与阴影效果" class="headerlink" title="7.2 setShadowLayer 与阴影效果"></a>7.2 setShadowLayer 与阴影效果</h3><p>|— 7.2.1 构造函数<br>|— 7.2.2 清除阴影<br>|— 7.2.3 示例：给文字添加阴影</p>
<h3 id="7-3-BlurMaskFilter-发光效果和图片阴影"><a href="#7-3-BlurMaskFilter-发光效果和图片阴影" class="headerlink" title="7.3 BlurMaskFilter 发光效果和图片阴影"></a>7.3 BlurMaskFilter 发光效果和图片阴影</h3><p>|— 7.3.1 概述<br>|— 7.3.2 给图片添加纯色阴影</p>
<h3 id="7-4-Shader-与-BitmapShader"><a href="#7-4-Shader-与-BitmapShader" class="headerlink" title="7.4 Shader 与 BitmapShader"></a>7.4 Shader 与 BitmapShader</h3><p>|— 7.4.1 Shader 概述<br>|— 7.4.2 BitmapShader 的基本用法<br>|— 7.4.3 示例一：望远镜效果<br>|— 7.4.4 示例二：生成不规则头像</p>
<h3 id="7-5-Shader-之-LinearGradient"><a href="#7-5-Shader-之-LinearGradient" class="headerlink" title="7.5 Shader 之 LinearGradient"></a>7.5 Shader 之 LinearGradient</h3><p>|— 7.5.1 概述<br>|— 7.5.2 示例：闪光文字效果</p>
<h3 id="7-6-Shader-之-RadialGradient"><a href="#7-6-Shader-之-RadialGradient" class="headerlink" title="7.6 Shader 之 RadialGradient"></a>7.6 Shader 之 RadialGradient</h3><p>|— 7.6.1 双色渐变<br>|— 7.6.2 多色渐变<br>|— 7.6.3 TileMode 填充模式</p>
<h2 id="第8章-混合模式"><a href="#第8章-混合模式" class="headerlink" title="第8章 混合模式"></a>第8章 混合模式</h2><h3 id="8-1-混合模式之-AvoidXfermode"><a href="#8-1-混合模式之-AvoidXfermode" class="headerlink" title="8.1 混合模式之 AvoidXfermode"></a>8.1 混合模式之 AvoidXfermode</h3><p>|— 8.1.1 混合模式概述<br>|— 8.1.2 AvoidXfermode<br>|— 8.1.3 AvoidXfermode 绘制原理<br>|— 8.1.4 AvoidXfermode 之 Mode.AVOID</p>
<h3 id="8-2-混合模式之-PorterDuffXfermode"><a href="#8-2-混合模式之-PorterDuffXfermode" class="headerlink" title="8.2 混合模式之 PorterDuffXfermode"></a>8.2 混合模式之 PorterDuffXfermode</h3><p>|— 8.2.1 PorterDuffXfermode 概述<br>|— 8.2.2 颜色叠加相关模式</p>
<h3 id="8-3-PorterDuffXfermode-之源图像模式"><a href="#8-3-PorterDuffXfermode-之源图像模式" class="headerlink" title="8.3 PorterDuffXfermode 之源图像模式"></a>8.3 PorterDuffXfermode 之源图像模式</h3><p>|— 8.3.1 Mode.SRC<br>|— 8.3.2 Mode.SRC_IN<br>|— 8.3.3 Mode.SRC_OUT<br>|— 8.3.4 Mode.SRC_OVER<br>|— 8.3.5 Mode.SRC_ATOP</p>
<h3 id="8-4-目标图像模式与其他模式"><a href="#8-4-目标图像模式与其他模式" class="headerlink" title="8.4 目标图像模式与其他模式"></a>8.4 目标图像模式与其他模式</h3><p>|— 8.4.1 目标图像模式<br>|— 8.4.2 其他模式——Mode.CLEAR<br>|— 8.4.3 模式总结</p>
<h2 id="第9章-Canvas-与图层"><a href="#第9章-Canvas-与图层" class="headerlink" title="第9章 Canvas 与图层"></a>第9章 Canvas 与图层</h2><h3 id="9-1-获取-Canvas-对象的方法"><a href="#9-1-获取-Canvas-对象的方法" class="headerlink" title="9.1 获取 Canvas 对象的方法"></a>9.1 获取 Canvas 对象的方法</h3><p>|— 9.1.1 方法一：重写 onDraw()、dispatchDraw() 函数<br>|— 9.1.2 方法二：使用 Bitmap 创建<br>|— 9.1.3 方法三：调用 SurfaceHolder.lockCanvas() 函数</p>
<h3 id="9-2-图层与画布"><a href="#9-2-图层与画布" class="headerlink" title="9.2 图层与画布"></a>9.2 图层与画布</h3><p>|— 9.2.1 saveLayer() 函数<br>|— 9.2.2 画布与图层<br>|— 9.2.3 saveLayer() &amp; saveLayerAlpha()</p>
<h3 id="9-3-Flag-的具体含义"><a href="#9-3-Flag-的具体含义" class="headerlink" title="9.3 Flag 的具体含义"></a>9.3 Flag 的具体含义</h3><p>|— 9.3.1 MATRIX_SAVE_FLAG<br>|— 9.3.2 CLIP_SAVE_FLAG<br>|— 9.3.3 FULL_COLOR_LAYER_SAVE_FLAG &amp; HAS_ALPHA_LAYER_SAVE_FLAG<br>|— 9.3.4 CLIP_TO_LAYER_SAVE_FLAG<br>|— 9.3.5 ALL_SAVE_FLAG</p>
<h3 id="9-4-恢复画布"><a href="#9-4-恢复画布" class="headerlink" title="9.4 恢复画布"></a>9.4 恢复画布</h3><p>|— 9.4.1 restoreToCount(int count)<br>|— 9.4.2 restore() &amp; restoreToCount(int count) 的关系</p>
<h2 id="第10章-Android-画布"><a href="#第10章-Android-画布" class="headerlink" title="第10章 Android 画布"></a>第10章 Android 画布</h2><h3 id="10-1-ShapeDrawable"><a href="#10-1-ShapeDrawable" class="headerlink" title="10.1 ShapeDrawable"></a>10.1 ShapeDrawable</h3><p>|— 10.1.1 shape 标签与 GradientDrawable<br>|— 10.1.2 ShapDrawable 的构造函数<br>|— 10.1.3 常用函数<br>|— 10.1.4 自定义 Drawable<br>|— 10.1.5 Drawable 与 Bitmap 对比</p>
<h3 id="10-2-Bitmap"><a href="#10-2-Bitmap" class="headerlink" title="10.2 Bitmap"></a>10.2 Bitmap</h3><p>|— 10.2.1 概述<br>|— 10.2.2 创建 Bitmap 方法一：BitmapFactory<br>|— 10.2.3 BitmapFactory.Options<br>|— 10.2.4 创建 Bitmap 方法二：Bitmap 静态方法<br>|— 10.2.5 常用函数<br>|— 10.2.6 常见问题</p>
<h3 id="10-3-SurfaceView"><a href="#10-3-SurfaceView" class="headerlink" title="10.3 SurfaceView"></a>10.3 SurfaceView</h3><p>|— 10.3.1 概述<br>|— 10.3.2 基本用法<br>|— 10.3.3 双缓冲技术</p>
<h2 id="第11章-Matrix-与坐标变换"><a href="#第11章-Matrix-与坐标变换" class="headerlink" title="第11章 Matrix 与坐标变换"></a>第11章 Matrix 与坐标变换</h2><h3 id="11-1-矩阵运算"><a href="#11-1-矩阵运算" class="headerlink" title="11.1 矩阵运算"></a>11.1 矩阵运算</h3><p>|— 11.1.1 􏰂􏰃􏰄􏰅􏰆􏰇􏰈􏰆􏰂􏰃􏰄􏰅􏰆􏰇􏰈􏰆􏰂􏰃􏰄􏰅􏰆􏰇􏰈􏰆􏰂􏰃􏰄􏰅􏰆􏰇􏰈􏰆矩阵的加法与减法<br>|— 11.1.2 矩阵与数的乘法<br>|— 11.1.3 矩阵与矩阵的乘法<br>|— 11.1.4 </p>
<h3 id="11-2-ColorMatrix-色彩变换"><a href="#11-2-ColorMatrix-色彩变换" class="headerlink" title="11.2 ColorMatrix 色彩变换"></a>11.2 ColorMatrix 色彩变换</h3><p>|— 11.2.1 􏰠􏰡􏰢􏰣􏰂􏰃色彩变换矩阵<br>|— 11.2.2 色彩的几种运算方式<br>|— 11.2.3 ColorMatrix 函数<br>|— 11.2.4 ColorMatrix 相乘</p>
<h2 id="第12章-封装控件"><a href="#第12章-封装控件" class="headerlink" title="第12章 封装控件"></a>第12章 封装控件</h2><h3 id="12-1-自定义属性与自定义-Style"><a href="#12-1-自定义属性与自定义-Style" class="headerlink" title="12.1 自定义属性与自定义 Style"></a>12.1 自定义属性与自定义 Style</h3><p>|— 12.1.1 概述<br>|— 12.1.2 declare-styleable 标签的使用方法<br>|— 12.1.3 在 XML 中使用自定义的属性<br>|— 12.1.4 在代码中获取自定义属性的值<br>|— 12.1.5 declare-styleable 标签其他属性的用法</p>
<h3 id="12-2-测量与布局"><a href="#12-2-测量与布局" class="headerlink" title="12.2 测量与布局"></a>12.2 测量与布局</h3><p>|— 12.2.1 ViewGroup 绘制流程<br>|— 12.2.2 onMeasure() 函数与 MeasureSpec<br>|— 12.2.3 onLayout() 函数<br>|— 12.2.4 获取子控件 margin 值的方法</p>
<h3 id="12-3-实现-FlowLayout-容器"><a href="#12-3-实现-FlowLayout-容器" class="headerlink" title="12.3 实现 FlowLayout 容器"></a>12.3 实现 FlowLayout 容器</h3><p>|— 12.3.1 XML 布局<br>|— 12.3.2 提取 margin 值与重写 onMeasure() 函数</p>
<h2 id="第13章-控件高级属性"><a href="#第13章-控件高级属性" class="headerlink" title="第13章 控件高级属性"></a>第13章 控件高级属性</h2><h3 id="13-1-GestureDetector-手势检测"><a href="#13-1-GestureDetector-手势检测" class="headerlink" title="13.1 GestureDetector 手势检测"></a>13.1 GestureDetector 手势检测</h3><p>|— 13.1.1 概述<br>|— 13.1.2 GestureDetector.OnGestureListener<br>|— 13.1.3 GestureDetector.OnDoubleTapListener<br>|— 13.1.4 GestureDetector.SimpleOnGestureListener<br>|— 13.1.5 onFling() 函数的应用</p>
<h3 id="13-2-Window-与-WindowManager"><a href="#13-2-Window-与-WindowManager" class="headerlink" title="13.2 Window 与 WindowManager"></a>13.2 Window 与 WindowManager</h3><p>|— 13.2.1 Window 与 WindowManager 的关系<br>|— 13.2.2 示例：腾讯手机管家悬浮窗的小火箭效果</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/07/Custom View/07.5 精通自定义 View 之 绘图进阶（五）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="King">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/07/Custom View/07.5 精通自定义 View 之 绘图进阶（五）/" itemprop="url">07.5 精通自定义 View 之 绘图进阶（五）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-07T05:00:00+08:00">
                2019-07-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Custom-View/" itemprop="url" rel="index">
                    <span itemprop="name">Custom View</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <meta name="referrer" content="no-referrer">

<h2 id="7-5-Shader-之-LinearGradient"><a href="#7-5-Shader-之-LinearGradient" class="headerlink" title="7.5 Shader 之 LinearGradient"></a>7.5 Shader 之 LinearGradient</h2><p>通过 LinearGradient 可以实现线性渐变效果。</p>
<h4 id="7-5-1-概述"><a href="#7-5-1-概述" class="headerlink" title="7.5.1 概述"></a>7.5.1 概述</h4><h6 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1. 构造函数"></a>1. 构造函数</h6><p>第一个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public LinearGradient(float x0, float y0, float x1, float y1,</div><div class="line">        int color0, int color1, TileMode tile)</div></pre></td></tr></table></figure></p>
<ul>
<li>(x0,y0) ：起始渐变点坐标；(x1,y1) ：结束渐变点坐标。</li>
<li>color0：起始颜色；color1：终止颜色。颜色值必须使用 0xAARRGGBB 形式的 16 进制表示，表示透明度的 AA 一定不能少。</li>
<li>TileMode tile：与 BitmapShader 一样，用于指定控件区域大于指定的渐变区域时，空白区域的颜色填充方法。</li>
</ul>
<p>第二个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public LinearGradient(float x0, float y0, float x1, float y1,</div><div class="line">        int colors[], float positions[], TileMode tile)</div></pre></td></tr></table></figure></p>
<ul>
<li>colors[]：用于指定渐变的颜色值数组。同样，颜色值必须使用 0xAARRGGBB 形式的 16 进制表示，表示透明度的 AA 一定不能少。</li>
<li>positions[]：与渐变的颜色相对应，取值是 0-1 的 float 类型，表示在每一个颜色在整条渐变线中的百分比位置</li>
</ul>
<h6 id="2-双色渐变使用示例"><a href="#2-双色渐变使用示例" class="headerlink" title="2. 双色渐变使用示例"></a>2. 双色渐变使用示例</h6><p>自定义一个从左到右的双色渐变控件，代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private int mWidth, mHeight;</div><div class="line">    private LinearGradient mLinearGradient;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</div><div class="line">        super.onSizeChanged(w, h, oldw, oldh);</div><div class="line">        mWidth = getMeasuredWidth();</div><div class="line">        mHeight = getMeasuredHeight();</div><div class="line">        mLinearGradient = new LinearGradient(0, mHeight / 2f, mWidth, mHeight / 2f,</div><div class="line">                0xFFFF0000, 0xFF00FF00, Shader.TileMode.CLAMP);</div><div class="line">        mPaint.setShader(mLinearGradient);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawRect(0, 0, mWidth, mHeight, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-bd6dbc498b7ed192.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h6 id="3-多色渐变使用示例"><a href="#3-多色渐变使用示例" class="headerlink" title="3. 多色渐变使用示例"></a>3. 多色渐变使用示例</h6><p>在上面示例的基础上，使用多色渐变来构造 LinearGradient 实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private int mWidth, mHeight;</div><div class="line">    private LinearGradient mLinearGradient;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</div><div class="line">        super.onSizeChanged(w, h, oldw, oldh);</div><div class="line">        mWidth = getMeasuredWidth();</div><div class="line">        mHeight = getMeasuredHeight();</div><div class="line">        int[] colors = &#123;0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFFFFFF00, 0xFF00FFFF&#125;;</div><div class="line">        float[] pos = &#123;0f, 0.2f, 0.4f, 0.6f, 1.0f&#125;;</div><div class="line">        mLinearGradient = new LinearGradient(0, mHeight / 2f, mWidth, mHeight / 2f,</div><div class="line">                colors, pos, Shader.TileMode.CLAMP);</div><div class="line">        mPaint.setShader(mLinearGradient);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawRect(0, 0, mWidth, mHeight, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>效果如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-2d1eccd29d3cf068.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>从这里可以看出，渐变的开始点同样是控件左边中点，渐变的结束点也同样是控件右边中点；这里我们指定了五种渐变颜色，而且指定了每个颜色的位置，前四种颜色是按 20% 均匀分布的，最后两种颜色相距 40%；最后通过 canvas.drawRect() 函数把整个控件区域画出来。</p>
<p>注意：colors 和 pos 的个数一定要相等，也就是说必须指定每一个颜色值的位置。如果元素个数不相等，则会直接报错，如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-b3a9b6144803c90f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h6 id="4-TileMode-填充模式"><a href="#4-TileMode-填充模式" class="headerlink" title="4. TileMode 填充模式"></a>4. TileMode 填充模式</h6><p>从构造函数中可以看出，LiearGradient 只有一个 TileMode 参数，这说明 X 轴与 Y 轴共用这一个 TileMode 填充参数，而不能像 BitmapShader 那样分别指定 X 轴与 Y 轴的填充参数。</p>
<p>示例：分别指定不同的填充模式</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-d78f1af0694fccb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="从上到下依次为：CLAMP、MIRROR、REPEAT"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private int mWidth, mHeight;</div><div class="line">    private LinearGradient mGradientCLAMP, mGradientMIRROR, mGradientREPEAT;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</div><div class="line">        super.onSizeChanged(w, h, oldw, oldh);</div><div class="line">        mWidth = getMeasuredWidth();</div><div class="line">        mHeight = 200;</div><div class="line">        int[] colors = &#123;0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFFFFFF00, 0xFF00FFFF&#125;;</div><div class="line">        float[] pos = &#123;0f, 0.2f, 0.4f, 0.6f, 1.0f&#125;;</div><div class="line">        mGradientCLAMP = new LinearGradient(0, 0, mWidth / 2f, mHeight / 2f,</div><div class="line">                colors, pos, Shader.TileMode.CLAMP);</div><div class="line">        mGradientMIRROR = new LinearGradient(0, mHeight, mWidth / 2f, mHeight * 3f / 2,</div><div class="line">                colors, pos, Shader.TileMode.MIRROR);</div><div class="line">        mGradientREPEAT = new LinearGradient(0, mHeight * 2f, mWidth / 2f, mHeight*5 / 2f,</div><div class="line">                colors, pos, Shader.TileMode.REPEAT);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        mPaint.setShader(mGradientCLAMP);</div><div class="line">        canvas.drawRect(0, 0, mWidth, mHeight, mPaint);</div><div class="line">        mPaint.setShader(mGradientMIRROR);</div><div class="line">        canvas.drawRect(0, mHeight, mWidth, mHeight * 2, mPaint);</div><div class="line">        mPaint.setShader(mGradientREPEAT);</div><div class="line">        canvas.drawRect(0, mHeight * 2, mWidth, mHeight * 3, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="5-Shader-填充与显示区域"><a href="#5-Shader-填充与显示区域" class="headerlink" title="5. Shader 填充与显示区域"></a>5. Shader 填充与显示区域</h6><p>所有 Shader 都是一样的：Shader 的布局和显示是分离的；Shader 总是从控件的左上角开始布局的；如果单张图片无法覆盖整个控件，则会使用 TileMode 重复模式来填充空白区域；而 canvas.draw 系列函数则只表示哪部分区域被显示出来。</p>
<p>下面利用 drawText() 函数实现一个渐变文字效果。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-d3c178884edce57a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private String mText;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setTextSize(80);</div><div class="line">        mText = &quot;欢迎关注先先生的Blog&quot;;</div><div class="line"></div><div class="line">        float width = mPaint.measureText(mText);</div><div class="line">        int[] colors = &#123;0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFFFFFF00, 0xFF00FFFF&#125;;</div><div class="line">        float[] pos = &#123;0f, 0.2f, 0.4f, 0.6f, 1.0f&#125;;</div><div class="line">        LinearGradient gradient = new LinearGradient(0, 0, width / 2f, 0,</div><div class="line">                colors, pos, Shader.TileMode.MIRROR);</div><div class="line">        mPaint.setShader(gradient);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawText(mText, 0, 100, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="7-5-2-示例：闪光文字效果"><a href="#7-5-2-示例：闪光文字效果" class="headerlink" title="7.5.2 示例：闪光文字效果"></a>7.5.2 示例：闪光文字效果</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1df20933fc32f800.gif?imageMogr2/auto-orient/strip" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public class TestView extends AppCompatTextView &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private LinearGradient mLinearGradient;</div><div class="line">    private int mDx;</div><div class="line">    private Matrix mMatrix;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = getPaint();</div><div class="line">        mMatrix = new Matrix();</div><div class="line">        int length = (int) mPaint.measureText(getText().toString());</div><div class="line">        createAnim(length);</div><div class="line">        createLinearGradient(length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void createAnim(int length) &#123;</div><div class="line">        ValueAnimator animator = ValueAnimator.ofInt(0, 2 * length);</div><div class="line">        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">                mDx = (Integer) animation.getAnimatedValue();</div><div class="line">                postInvalidate();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        animator.setRepeatMode(ValueAnimator.RESTART);</div><div class="line">        animator.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">        animator.setDuration(2000);</div><div class="line">        animator.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void createLinearGradient(int length) &#123;</div><div class="line">        mLinearGradient = new LinearGradient(-length, 0, 0, 0,</div><div class="line">                new int[]&#123;getCurrentTextColor(), 0xFF00FF00, getCurrentTextColor()&#125;,</div><div class="line">                new float[]&#123;0, 0.5f, 1&#125;,</div><div class="line">                Shader.TileMode.CLAMP);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        mMatrix.reset();</div><div class="line">        mMatrix.setTranslate(mDx, 0);</div><div class="line">        mLinearGradient.setLocalMatrix(mMatrix);</div><div class="line">        mPaint.setShader(mLinearGradient);</div><div class="line"></div><div class="line">        super.onDraw(canvas);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 res/layout/act_main.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line">    &lt;com.xxt.xtest.TestView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_margin=&quot;20dp&quot;</div><div class="line">        android:textSize=&quot;24sp&quot;</div><div class="line">        android:text=&quot;欢迎关注先先生的Blog&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>
<p>控件派生自 TextView 的子类，所以可以使用 TextView 的自带方法 getCurrentTextColor() 来获取文字颜色、画笔、文字长度等；利用 Shader.setLocalMatrix(Matrix localM) 设置逐渐平移的矩阵，最后用 ValueAnimator 来控制矩阵平移的位移 mDx，移动距离是从 0 到两倍的 text 距离。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/07/Custom View/07.4 精通自定义 View 之 绘图进阶（四）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="King">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/07/Custom View/07.4 精通自定义 View 之 绘图进阶（四）/" itemprop="url">07.4 精通自定义 View 之 绘图进阶（四）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-07T04:00:00+08:00">
                2019-07-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Custom-View/" itemprop="url" rel="index">
                    <span itemprop="name">Custom View</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <meta name="referrer" content="no-referrer">

<h2 id="7-4-Shader-与-BitmapShader"><a href="#7-4-Shader-与-BitmapShader" class="headerlink" title="7.4 Shader 与 BitmapShader"></a>7.4 Shader 与 BitmapShader</h2><h4 id="7-4-1-Shader-概述"><a href="#7-4-1-Shader-概述" class="headerlink" title="7.4.1 Shader 概述"></a>7.4.1 Shader 概述</h4><p>Shader 在三维软件中称之为着色器，是用来给空白图形上色用的。在 PhotoShop 中有一个印章工具，能够指定印章的样式来填充图形。印章的样式可以是图像、颜色、渐变色等。这里的 Shader 实现的效果与印章类似。我们也是通过给 Shader 指定对应的图像、渐变色等来填充图形的。Paint 中有一个函数专门用于设置 Shader，其声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public Shader setShader(Shader shader)</div></pre></td></tr></table></figure></p>
<p>Shader 类只是一个基类，其中只有两个函数 setLocalMatrix(Matrix localM) 和 getLocalMatrix(Matrix localM)，用来设置坐标变换矩阵的。</p>
<p>Shader 类其实是一个空类，它的功能主要是靠它的派生类来实现的。继承关系如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-f0612d7804eb21c1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="7-4-2-BitmapShader-的基本用法"><a href="#7-4-2-BitmapShader-的基本用法" class="headerlink" title="7.4.2 BitmapShader 的基本用法"></a>7.4.2 BitmapShader 的基本用法</h4><p>它的构造函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public BitmapShader(Bitmap bitmap, TileMode tileX, TileMode tileY)</div></pre></td></tr></table></figure></p>
<p>这就相当于 PhotoShop 中的印章工具，bitmap 用来指定图案，tileX 用来指定当 X 轴超出单个图片大小时时所使用的重复策略，同样 tileY 用于指定当 Y 轴超出单个图片大小时时所使用的重复策略。</p>
<p>其中TileMode的取值有：</p>
<ul>
<li>TileMode.CLAMP：用边缘色彩填充多余空间。</li>
<li>TileMode.REPEAT：重复原图像来填充多余空间。</li>
<li>TileMode.MIRROR：重复使用镜像模式的图像来填充多余空间。</li>
</ul>
<h6 id="1-示例"><a href="#1-示例" class="headerlink" title="1. 示例"></a>1. 示例</h6><p>这里使用的印章图像如下图所示 (dog.png)。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-06b392e88addc2f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>中间是一幅小狗头像，四周被四种不同的颜色给包围。设置 Shader 的完整代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        Bitmap mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.dog_edge);</div><div class="line">        mPaint.setShader(new BitmapShader(mBitmap, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawRect(0, 0, getWidth(), getHeight(), mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>效果图如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-3148e2d732cb7ba9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>给自定义的控件添加上宽高限制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;!--&lt;com.xxt.xtest.TestView</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot; /&gt;--&gt;</div><div class="line">&lt;com.xxt.xtest.TestView</div><div class="line">    android:layout_width=&quot;300dp&quot;</div><div class="line">    android:layout_height=&quot;450dp&quot;</div><div class="line">    android:layout_gravity=&quot;center_horizontal&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>效果图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-6d202b7ca6dc61aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>从效果图中可以看出：</p>
<ul>
<li>在 X 轴和 Y 轴都使用 REPEAT 模式下，在超出单个图像的区域后，就会重复绘制这个图像。</li>
<li>绘制是从控件的左上角开始的，而不是从屏幕原点开始的。这点很好理解，因为我们只会在自定义控件上绘图，不会在全屏幕上绘图。</li>
</ul>
<h6 id="2-TileMode-模式解析"><a href="#2-TileMode-模式解析" class="headerlink" title="2. TileMode 模式解析"></a>2. TileMode 模式解析</h6><p>上面初步看到了 REPEAT 模式的用法，现在我们分别来看在各个模式下的不同表现。<br><strong>1）TileMode.REPEAT 模式：重复原图像来填充多余空间</strong><br>在更改模式时，只需要更新setShader里的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mPaint.setShader(new BitmapShader(mBmp, TileMode.REPEAT, TileMode.REPEAT));</div></pre></td></tr></table></figure></p>
<p>在这里，X 轴、Y 轴全部设置成 REPEAT 模式，所以当控件的显示范围超出了单个图的显示范围时，在 X 轴上将使用 REPEAT 模式；同样，在 Y 轴上也将使用 REPEAT 模式。</p>
<p><strong>2）TileMode.MIRROR 模式：重复使用镜像模式的图像来填充多余空间</strong><br>同样，将 X 轴、Y 轴全部改为 MIRROR 模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mPaint.setShader(new BitmapShader(mBmp, TileMode.MIRROR, TileMode.MIRROR));</div></pre></td></tr></table></figure></p>
<p>效果如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-1acfebf405a0e336.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在 X 轴上每两张图片的显示都像镜子一样翻转一下。同样，在 Y 轴上每两张图片的显示也都像镜子一样翻转一下。所以这就是镜相效果的作用，镜相效果其实就是在显示下一图片的时候，就相当于两张图片中间放了一个镜子一样。</p>
<p><strong>3）TileMode.CLAMP：用边缘色彩填充多余空间</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mPaint.setShader(new BitmapShader(mBmp, TileMode.CLAMP, TileMode.CLAMP));</div></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-a3d0c5b36c613db1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>CLAMP 模式的意思就是当控件区域超过当前单个图片的大小时，空白位置的颜色填充就用图片的边缘颜色来填充。</p>
<p><strong>4）TileMode.CLAMP 与填充顺序</strong><br>当 X 轴、Y 轴全部都是 CLAMP 模式时，X 轴的空白区域会用图像的右侧边缘颜色来填充；Y 轴的空白区域会用图像的底部的边缘颜色来填充，那效果应该是这样的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-8a5b91ff64280b8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>明显右下角的空白位置根本与图像是不沾边的，那它要用什么颜色来填充呢？是填充上方的蓝色还是填充左侧的绿色呢？</p>
<p>从最终的效果图来看，这部分填充的颜色是绿色的，可为什么呢？其实这是跟填充顺序有关的，并且是先填充竖向再填充横向。如果是先填充横向再填充竖向，那么右下角颜色应该是蓝色。</p>
<p><strong>4）使用混合填充模式</strong><br>比如在 X 轴填充空白区域时使用 MIRROR 样式、在填充 Y 轴空白区域时使用REPEAT样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mPaint.setShader(new BitmapShader(mBmp, TileMode.MIRROR, TileMode.REPEAT));</div></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-9dbadb9051f8c178.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>从效果图中可以看出来，首先使用 REPEAT 模式填充 Y 轴，然后使用 MIRROR 模式填充 X 轴。</p>
<blockquote>
<p>总之：无论哪两种模式混合或者相同模式，都是先填充 Y 轴，然后填充 X 轴。</p>
</blockquote>
<h6 id="3-绘图位置与图像显示"><a href="#3-绘图位置与图像显示" class="headerlink" title="3. 绘图位置与图像显示"></a>3. 绘图位置与图像显示</h6><p>在上面的例子中，我们利用 drawRect 把整个控件大小都给覆盖了，那假如我们只画一个小矩形而不完全覆盖整个控件，那我们 setShader() 函数中所设置的图片是从哪里开始画的呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        Bitmap mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.dog_edge);</div><div class="line">        mPaint.setShader(new BitmapShader(mBitmap, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        float left = getWidth() / 3f;</div><div class="line">        float top = getHeight() / 3f;</div><div class="line">        float right = getWidth() * 2f / 3;</div><div class="line">        float bottom = getHeight() * 2f / 3;</div><div class="line">        canvas.drawRect(left,top,right,bottom, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>即在绘图时，并不是完全覆盖控件大小的，而是取控件中间位置的 1/3 区域显示的。效果如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-bebdbf0c243f7d16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="7-4-3-示例一：望远镜效果"><a href="#7-4-3-示例一：望远镜效果" class="headerlink" title="7.4.3 示例一：望远镜效果"></a>7.4.3 示例一：望远镜效果</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d4a84ed28fe1ee93.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>这里要实现的效果是：根据手指所在的位置，把对应的图像绘制出来。这样看起来就是望远镜效果了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Rect mRect;</div><div class="line">    private int mDx = -1;</div><div class="line">    private int mDy = -1;</div><div class="line">    private Bitmap mBitmap, mBitmapBg;</div><div class="line">    private int mRadius = 300;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.meinv);</div><div class="line">        mRect = new Rect();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        switch (event.getAction()) &#123;</div><div class="line">            case MotionEvent.ACTION_DOWN:</div><div class="line">                mDx = (int) event.getX();</div><div class="line">                mDy = (int) event.getY();</div><div class="line">                invalidate();</div><div class="line">                return true;</div><div class="line">            case MotionEvent.ACTION_MOVE:</div><div class="line">                mDx = (int) event.getX();</div><div class="line">                mDy = (int) event.getY();</div><div class="line">                break;</div><div class="line">            case MotionEvent.ACTION_UP:</div><div class="line">            case MotionEvent.ACTION_CANCEL:</div><div class="line">                mDx = -1;</div><div class="line">                mDy = -1;</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        invalidate();</div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        if (mBitmapBg == null) &#123;</div><div class="line">            mBitmapBg = Bitmap.createBitmap(getWidth(), getHeight(), Bitmap.Config.ARGB_8888);</div><div class="line">            Canvas canvasBg = new Canvas(mBitmapBg);</div><div class="line">            mRect.set(0, 0, getWidth(), getHeight());</div><div class="line">            canvasBg.drawBitmap(mBitmap, null, mRect, mPaint);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mDx != -1 &amp;&amp; mDy != -1) &#123;</div><div class="line">            mPaint.setShader(new BitmapShader(mBitmapBg, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT));</div><div class="line">            canvas.drawCircle(mDx, mDy, mRadius, mPaint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们主要来看下 OnDraw() 函数：<br>在 onDraw() 函数中，第一部分，就是新建一个空白的 bitmap，这个 bitmap 的大小与控件一样，然后把我们的背景图进行拉伸，画到这个空白的 bitmap 上。由于这里的 canvasBg 是用 mBitmapBg 创建的，所以所画的任何图像都会直接显示在 mBitmapBg 上，而我们创建的 mBitmapBg 是与控件一样大的，所以当把 mBitmapBg 做为 Shader 来设置给 mPaint 时，mBitmapBg 会正好覆盖整个控件，而不会有多余的空白像素。</p>
<p>这里需要注意的就是我们在将原图像画到 mBitmapBg 时，进行了拉伸压缩，把它拉伸到和当前控件一样大小。然后利用 OnMotionEvent 来捕捉用户的手指位置，当用户手指下按时，在手指位置画一个半径为 mRadius 的圆形，把对应的位置的图像显示出来就可以了。</p>
<h4 id="7-4-4-示例二：生成不规则头像"><a href="#7-4-4-示例二：生成不规则头像" class="headerlink" title="7.4.4 示例二：生成不规则头像"></a>7.4.4 示例二：生成不规则头像</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-817a7e05511f03bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>res/values/attrs.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">    &lt;declare-styleable name=&quot;TestView&quot;&gt;</div><div class="line">        &lt;attr name=&quot;src&quot; format=&quot;reference&quot; /&gt;</div><div class="line">        &lt;attr name=&quot;format&quot; format=&quot;enum&quot;&gt;</div><div class="line">            &lt;enum name=&quot;circle&quot; value=&quot;0&quot;/&gt;</div><div class="line">            &lt;enum name=&quot;rectTangle&quot; value=&quot;1&quot;/&gt;</div><div class="line">        &lt;/attr&gt;</div><div class="line">        &lt;attr name=&quot;radius&quot; format=&quot;integer&quot; /&gt;</div><div class="line">    &lt;/declare-styleable&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure></p>
<p>自定义控件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap mBitmap;</div><div class="line">    private BitmapShader mBitmapShader;</div><div class="line">    private int mEnumFormat = 0;</div><div class="line">    private int mRadius = 5;</div><div class="line">    private RectF mRectF;</div><div class="line">    private Matrix mMatrix;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) throws Exception&#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init(context,attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs, int defStyle) throws Exception&#123;</div><div class="line">        super(context, attrs, defStyle);</div><div class="line">        init(context,attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init(Context context,AttributeSet attrs) throws Exception&#123;</div><div class="line">        // 提取属性定义</div><div class="line">        TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.TestView);</div><div class="line">        int BitmapID = typedArray.getResourceId(R.styleable.TestView_src,-1);</div><div class="line">        if (BitmapID == -1)&#123;</div><div class="line">            throw new Exception(&quot;TestView 需要定义 Src 属性，而且必须是图像&quot;);</div><div class="line">        &#125;</div><div class="line">        mBitmap = BitmapFactory.decodeResource(getResources(),BitmapID);</div><div class="line">        mEnumFormat = typedArray.getInt(R.styleable.TestView_format,0);</div><div class="line">        if (mEnumFormat == 1)&#123;</div><div class="line">            mRadius = typedArray.getInt(R.styleable.TestView_radius,5);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        typedArray.recycle();</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mBitmapShader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);</div><div class="line">        mRectF = new RectF();</div><div class="line">        mMatrix = new Matrix();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">        int measureWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        int measureHeight = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">        int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">        int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"></div><div class="line">        int width = mBitmap.getWidth();</div><div class="line">        int height = mBitmap.getHeight();</div><div class="line">        width = (measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth: width;</div><div class="line">        height = (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight: height;</div><div class="line">        setMeasuredDimension(width, height);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        float scale = (float) getWidth()/mBitmap.getWidth();</div><div class="line">        mMatrix.reset();</div><div class="line">        mMatrix.setScale(scale, scale);</div><div class="line">        mBitmapShader.setLocalMatrix(mMatrix);</div><div class="line">        mPaint.setShader(mBitmapShader);</div><div class="line"></div><div class="line">        float half = getWidth() / 2f;</div><div class="line"></div><div class="line">        if (mEnumFormat == 0)&#123;</div><div class="line">            canvas.drawCircle(half, half, getWidth() / 2f, mPaint);</div><div class="line">        &#125; else if(mEnumFormat == 1)&#123;</div><div class="line">            mRectF.set(0, 0, getWidth(), getHeight());</div><div class="line">            canvas.drawRoundRect(mRectF, mRadius, mRadius, mPaint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 XML 中使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:padding=&quot;20dp&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line">    &lt;com.xxt.xtest.TestView</div><div class="line">        android:layout_width=&quot;50dp&quot;</div><div class="line">        android:layout_height=&quot;50dp&quot;</div><div class="line">        app:src=&quot;@drawable/meinv&quot;</div><div class="line">        app:format=&quot;circle&quot;/&gt;</div><div class="line">    &lt;com.xxt.xtest.TestView</div><div class="line">        android:layout_width=&quot;100dp&quot;</div><div class="line">        android:layout_height=&quot;100dp&quot;</div><div class="line">        app:src=&quot;@drawable/head&quot;</div><div class="line">        app:format=&quot;circle&quot;/&gt;</div><div class="line">    &lt;com.xxt.xtest.TestView</div><div class="line">        android:layout_width=&quot;100dp&quot;</div><div class="line">        android:layout_height=&quot;100dp&quot;</div><div class="line">        android:layout_marginTop=&quot;10dp&quot;</div><div class="line">        app:src=&quot;@drawable/meinv&quot;</div><div class="line">        app:format=&quot;rectTangle&quot;</div><div class="line">        app:radius=&quot;10&quot;/&gt;</div><div class="line">    &lt;com.xxt.xtest.TestView</div><div class="line">        android:layout_width=&quot;130dp&quot;</div><div class="line">        android:layout_height=&quot;130dp&quot;</div><div class="line">        android:layout_marginTop=&quot;10dp&quot;</div><div class="line">        app:src=&quot;@drawable/head&quot;</div><div class="line">        app:format=&quot;rectTangle&quot;</div><div class="line">        app:radius=&quot;30&quot;/&gt;</div><div class="line">    &lt;com.xxt.xtest.TestView</div><div class="line">        android:layout_width=&quot;150dp&quot;</div><div class="line">        android:layout_height=&quot;150dp&quot;</div><div class="line">        android:layout_marginTop=&quot;10dp&quot;</div><div class="line">        app:src=&quot;@drawable/meinv&quot;</div><div class="line">        app:format=&quot;rectTangle&quot;</div><div class="line">        app:radius=&quot;70&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/07/Custom View/07.3 精通自定义 View 之 绘图进阶（三）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="King">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/07/Custom View/07.3 精通自定义 View 之 绘图进阶（三）/" itemprop="url">07.3 精通自定义 View 之 绘图进阶（三）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-07T03:00:00+08:00">
                2019-07-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Custom-View/" itemprop="url" rel="index">
                    <span itemprop="name">Custom View</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <meta name="referrer" content="no-referrer">

<h2 id="7-3-BlurMaskFilter-发光效果与图片阴影"><a href="#7-3-BlurMaskFilter-发光效果与图片阴影" class="headerlink" title="7.3 BlurMaskFilter 发光效果与图片阴影"></a>7.3 BlurMaskFilter 发光效果与图片阴影</h2><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2c82cb72b3789dbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在这张效果图中涉及三个发光效果：文字、图形和位图。</p>
<p>从最后一张美女位图所形成的发光效果中可以看到，与 setShadowLayer() 函数一样，发光效果也只会影响边缘部分图像，内部图像是不受影响的。</p>
<p>从第三幅图像（红绿各一半的位图）中可以看到：发光效果是无法指定发光颜色的，采用边缘部分的颜色取样来进行模糊发光。所以边缘是什么颜色，发出的光也就是什么颜色的。</p>
<p>所以初步我们对发光效果有如下结论：</p>
<ul>
<li>与 setShadowLayer() 函数一样，发光效果使用的也是高斯模糊算法，并且只会影响边缘部分图像，内部图像是不受影响的。</li>
<li>发光效果是无法指定发光颜色的，采用边缘部分的颜色取样来进行模糊发光。所以边缘是什么颜色，发出的光也就是什么颜色的。</li>
</ul>
<h4 id="7-3-1-概述"><a href="#7-3-1-概述" class="headerlink" title="7.3.1 概述"></a>7.3.1 概述</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public MaskFilter setMaskFilter(MaskFilter maskfilter)</div></pre></td></tr></table></figure>
<p>setMaskFilter() 函数中的 MaskFilter 也是没有具体实现的，是通过派生子类来实现具体的不同功能的。MaskFilter 有两个派生类：BlurMaskFilter 和 EmbossMaskFilter。其中，BlurMaskFilter 就能够实现发光效果；而 EmbossMaskFilter 则可以用于实现浮雕效果，用处很少，这里就不再讲解了。另一点需要注意的是，setMaskFilter() 函数是不支持硬件加速的，必须关闭硬件加速才可以。</p>
<p>BlurMaskFilter 的构造函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public BlurMaskFilter(float radius, Blur style)</div></pre></td></tr></table></figure></p>
<ul>
<li>float radius：用来定义模糊半径，同样是高斯模糊算法。</li>
<li>Blur style：发光样式，有内 Blur.INNER(内发光)、Blur.SOLID(外发光)、Blur.NORMAL(内外发光)、Blur.OUTER(仅发光部分可见)。</li>
</ul>
<p>上面效果图的示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint = new Paint();</div><div class="line">    private Bitmap mHeadBmp;</div><div class="line">    private Rect mRect;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init()&#123;</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setTextSize(50);</div><div class="line">        mHeadBmp = BitmapFactory.decodeResource(getResources(), R.drawable.head);</div><div class="line">        mRect = new Rect();</div><div class="line">        mPaint.setMaskFilter(new BlurMaskFilter(40, BlurMaskFilter.Blur.SOLID));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        canvas.drawText(&quot;xian小涛&quot;,100,100, mPaint);</div><div class="line">        canvas.drawCircle(300,300,50, mPaint);</div><div class="line">        mRect.set(300,500,300 + mHeadBmp.getWidth(),500 + mHeadBmp.getHeight());</div><div class="line">        canvas.drawBitmap(mHeadBmp,null, mRect, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>BlurStyle 发光效果图</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-a54f96eedd8b3cf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="依次为：Blur.INNER(内发光)、Blur.SOLID(外发光)、Blur.NORMAL(内外发光)、Blur.OUTER(仅发光部分可见)"></p>
<p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private BlurMaskFilter inner, solid, normal, outer;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line"></div><div class="line">        inner = new BlurMaskFilter(40, BlurMaskFilter.Blur.INNER);</div><div class="line">        solid = new BlurMaskFilter(40, BlurMaskFilter.Blur.SOLID);</div><div class="line">        normal = new BlurMaskFilter(40, BlurMaskFilter.Blur.NORMAL);</div><div class="line">        outer = new BlurMaskFilter(40, BlurMaskFilter.Blur.OUTER);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        mPaint.setMaskFilter(inner);</div><div class="line">        canvas.drawCircle(200,200,100, mPaint);</div><div class="line"></div><div class="line">        canvas.translate(300, 0);</div><div class="line">        mPaint.setMaskFilter(solid);</div><div class="line">        canvas.drawCircle(200,200,100, mPaint);</div><div class="line"></div><div class="line">        canvas.translate(300, 0);</div><div class="line">        mPaint.setMaskFilter(normal);</div><div class="line">        canvas.drawCircle(200,200,100, mPaint);</div><div class="line"></div><div class="line">        canvas.translate(300, 0);</div><div class="line">        mPaint.setMaskFilter(outer);</div><div class="line">        canvas.drawCircle(200,200,100, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>其中，Blur.OUTER 比较特殊，在这种模式下仅显示发光效果，会把原图像中除发光部分外的其他部分全部变为透明。</p>
</blockquote>
<h4 id="7-3-2-给图片添加纯色阴影"><a href="#7-3-2-给图片添加纯色阴影" class="headerlink" title="7.3.2 给图片添加纯色阴影"></a>7.3.2 给图片添加纯色阴影</h4><p>大家是否可以看出来发光效果与 setShadowLayer() 函数所生成的阴影之间有什么联系？</p>
<p>先来分析一下 setShadowLayer() 函数的阴影形成过程（假定阴影画笔是灰色）。对于文字和图形，它首先产生一个跟原型一样的灰色副本。然后对这个灰色副本应用 BlurMaskFilter，使其内外发光；这样就形成了所谓的阴影，当然最后再偏移一段距离。</p>
<p>所以，我们要给图片添加灰色阴影效果，就可以仿照这个过程：先绘制一幅跟图片一样大小的灰色图像，然后给这个灰色图形应用 BlurMaskFilter 使其内外发光，最后偏移原图形一段距离绘制阴影。</p>
<p>这里涉及到三个点：</p>
<ul>
<li>绘制一幅跟图片一样大小的灰色图像。</li>
<li>对灰色图像应用 BlurMaskFilter 使其内外发光。</li>
<li>偏移原图形一段距离绘制阴影。</li>
</ul>
<h6 id="1-抽取灰色图像"><a href="#1-抽取灰色图像" class="headerlink" title="1. 抽取灰色图像"></a>1. 抽取灰色图像</h6><p>首先来看怎么能绘出一个指定位图所对应的灰色图像。我们知道 canvas.drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint) 中的画笔颜色对画出来的位图是没有任何影响的，所以，如果我们需要画一张对应的灰色图像，就需要新建一张一样大小的空白图，而且新图片的透明度要与原图片保持一致。这样一来，如何从原图片中抽出 Alpha 值成为关键。即我们只需要创建一个与原图片一样大小且Alpha相同的图片即可。</p>
<p>其实，Bitmap 中已经存在抽取出只具有 Alpha 值图片的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public Bitmap extractAlpha();</div></pre></td></tr></table></figure></p>
<p>这个函数的功能是：新建一张空白图片，该图片具有与原图片一样的 Alpha 值，把这个新建的 Bitmap 作为结果返回。这个空白图片中每个像素都具有与原图片一样的 Alpha 值，而且具体的颜色是在使用canvas.drawBitmap() 函数绘制时由传入的画笔颜色指定的。</p>
<p><strong>总结：extractAlpha() 会新建一幅仅具有 Alpha 值的空白图像，而且这张图像的颜色是在使用 canvas.drawBitmap() 函数绘制时传入的画笔颜色指定的。</strong></p>
<p>下面拿一张图片来做实验，这张 PNG 图片中，只有一只小狗，其余地方都是透明色。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-0fa63d9969df5489.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>下面分别利用 extractAlpha() 函数画出该图片所对应的灰色和黑色阴影，效果图如下所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-ca07885ef1838c7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原图、灰色阴影、黑色阴影"></p>
<p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap mBitmap, mAlphaBmp;</div><div class="line">    private Rect mRect;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mRect = new Rect();</div><div class="line">        mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.dog);</div><div class="line">        mAlphaBmp = mBitmap.extractAlpha();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        int width = 200;</div><div class="line">        int height = width * mAlphaBmp.getHeight() / mAlphaBmp.getWidth();</div><div class="line">        // 绘制原图</div><div class="line">        mRect.set(50, 50, 50 + width, 50 + height);</div><div class="line">        canvas.drawBitmap(mBitmap, null, mRect, mPaint);</div><div class="line">        // 绘制灰色阴影</div><div class="line">        canvas.translate(width + 100, 0);</div><div class="line">        mPaint.setColor(Color.GRAY);</div><div class="line">        canvas.drawBitmap(mAlphaBmp, null, mRect, mPaint);</div><div class="line">        // 绘制黑色阴影</div><div class="line">        canvas.translate(width + 100, 0);</div><div class="line">        mPaint.setColor(Color.BLACK);</div><div class="line">        canvas.drawBitmap(mAlphaBmp, null, mRect, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h6 id="2-绘制阴影"><a href="#2-绘制阴影" class="headerlink" title="2. 绘制阴影"></a>2. 绘制阴影</h6><p>在上面灰色纯色图像的基础上，将此灰色图像使用 BlurMaskFilter 使其内外发光。然后再在灰色模糊阴影的基础上画上原图像，就形成了模糊阴影。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap mBitmap, mAlphaBmp;</div><div class="line">    private Rect mRect;</div><div class="line">    private BlurMaskFilter mFilter;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mRect = new Rect();</div><div class="line">        mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.dog);</div><div class="line">        mAlphaBmp = mBitmap.extractAlpha();</div><div class="line">        mFilter = new BlurMaskFilter(30, BlurMaskFilter.Blur.NORMAL);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        int width = 200;</div><div class="line">        int height = width * mAlphaBmp.getHeight() / mAlphaBmp.getWidth();</div><div class="line">        mRect.set(50, 50, 50 + width, 50 + height);</div><div class="line"></div><div class="line">        // 绘制灰色阴影</div><div class="line">        mPaint.setColor(Color.GRAY);</div><div class="line">        mPaint.setMaskFilter(mFilter);</div><div class="line">        canvas.drawBitmap(mAlphaBmp, null, mRect, mPaint);</div><div class="line"></div><div class="line">        // 绘制原图</div><div class="line">        mPaint.setMaskFilter(null);</div><div class="line">        canvas.translate(-10, -10);</div><div class="line">        canvas.drawBitmap(mBitmap, null, mRect, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>效果如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-64d6af67e125a769.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="7-3-3-封装控件"><a href="#7-3-3-封装控件" class="headerlink" title="7.3.3 封装控件"></a>7.3.3 封装控件</h4><p>将它封装成一个控件，具有如下功能：</p>
<ul>
<li>让用户定义图片内容。</li>
<li>让用户定义偏移距离。</li>
<li>让用户定义阴影颜色和阴影模糊程度。</li>
<li>可以使用wrap_content属性自适应大小。</li>
</ul>
<blockquote>
<p>下面程序经过多次测试，效果并不完美，待完善。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-7a5cfd013c874038.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>res/values/xshadow.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">    &lt;declare-styleable name=&quot;XShadowImageView&quot;&gt;</div><div class="line">        &lt;attr name=&quot;src&quot; format=&quot;reference&quot;/&gt;</div><div class="line">        &lt;attr name=&quot;shadowDx&quot; format=&quot;integer&quot; /&gt;</div><div class="line">        &lt;attr name=&quot;shadowDy&quot; format=&quot;integer&quot; /&gt;</div><div class="line">        &lt;attr name=&quot;shadowColor&quot; format=&quot;color&quot;/&gt;</div><div class="line">        &lt;attr name=&quot;shadowRadius&quot; format=&quot;float&quot;/&gt;</div><div class="line">    &lt;/declare-styleable&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure></p>
<p>src/…/XShadowImageView.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">public class XShadowImageView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap mBitmap, mShadowBitmap;</div><div class="line">    private int mDx, mDy;</div><div class="line">    private float mRadius;</div><div class="line">    private int mShadowColor;</div><div class="line">    private BlurMaskFilter mBlurMaskFilter;</div><div class="line">    private Rect mRect;</div><div class="line"></div><div class="line">    public XShadowImageView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public XShadowImageView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">        init(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        // 禁用硬件加速</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line"></div><div class="line">        // 提取属性</div><div class="line">        TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.XShadowImageView);</div><div class="line">        mDx = ta.getInt(R.styleable.XShadowImageView_shadowDx, 0);</div><div class="line">        mDy = ta.getInt(R.styleable.XShadowImageView_shadowDy, 0);</div><div class="line">        mRadius = ta.getFloat(R.styleable.XShadowImageView_shadowRadius, 0);</div><div class="line">        mShadowColor = ta.getInt(R.styleable.XShadowImageView_shadowColor, Color.BLACK);</div><div class="line">        int bitmapId = ta.getResourceId(R.styleable.XShadowImageView_src, -1);</div><div class="line">        if (bitmapId != -1) &#123;</div><div class="line">            mBitmap = BitmapFactory.decodeResource(getResources(), bitmapId);</div><div class="line">        &#125;</div><div class="line">        ta.recycle();</div><div class="line"></div><div class="line">        // 其他初始化</div><div class="line">        mRect = new Rect();</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(mShadowColor);</div><div class="line">        mBlurMaskFilter = new BlurMaskFilter(mRadius, BlurMaskFilter.Blur.NORMAL);</div><div class="line">        if (mBitmap != null) &#123;</div><div class="line">            mShadowBitmap = mBitmap.extractAlpha();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">        int measureWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        int measureHeight = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">        int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">        int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"></div><div class="line">        int width = mBitmap.getWidth();</div><div class="line">        int height = mBitmap.getHeight();</div><div class="line">        width = (measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth: width;</div><div class="line">        height = (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight: height;</div><div class="line">        setMeasuredDimension(width, height);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        if (mBitmap != null) &#123;</div><div class="line">            int width = getWidth() - mDx;</div><div class="line">            int height = getHeight() - mDy;</div><div class="line"></div><div class="line">            // 绘制阴影</div><div class="line">            mPaint.setMaskFilter(mBlurMaskFilter);</div><div class="line">            mRect.set(mDx, mDy, width, height);</div><div class="line">            canvas.drawBitmap(mShadowBitmap, null, mRect, mPaint);</div><div class="line"></div><div class="line">            // 绘制原图像</div><div class="line">            mPaint.setMaskFilter(null);</div><div class="line">            mRect.set(0, 0, width, height);</div><div class="line">            canvas.drawBitmap(mBitmap, null, mRect, mPaint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.xxt.xtest.XShadowImageView</div><div class="line">        android:layout_width=&quot;100dp&quot;</div><div class="line">        android:layout_height=&quot;100dp&quot;</div><div class="line">        android:layout_gravity=&quot;center_horizontal&quot;</div><div class="line">        app:src=&quot;@drawable/head&quot;</div><div class="line">        app:shadowDx=&quot;30&quot;</div><div class="line">        app:shadowDy=&quot;30&quot;</div><div class="line">        app:shadowRadius=&quot;30.0&quot;</div><div class="line">        app:shadowColor=&quot;@android:color/black&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;com.xxt.xtest.XShadowImageView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_gravity=&quot;center_horizontal&quot;</div><div class="line">        app:src=&quot;@drawable/head&quot;</div><div class="line">        app:shadowDx=&quot;30&quot;</div><div class="line">        app:shadowDy=&quot;30&quot;</div><div class="line">        app:shadowRadius=&quot;30.0&quot;</div><div class="line">        app:shadowColor=&quot;@android:color/holo_red_dark&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;com.xxt.xtest.XShadowImageView</div><div class="line">        android:layout_width=&quot;260dp&quot;</div><div class="line">        android:layout_height=&quot;360dp&quot;</div><div class="line">        android:layout_gravity=&quot;center_horizontal&quot;</div><div class="line">        app:src=&quot;@drawable/meinv&quot;</div><div class="line">        app:shadowDx=&quot;40&quot;</div><div class="line">        app:shadowDy=&quot;40&quot;</div><div class="line">        app:shadowRadius=&quot;40.0&quot;</div><div class="line">        app:shadowColor=&quot;@android:color/holo_red_dark&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/07/Custom View/07.2 精通自定义 View 之 绘图进阶（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="King">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/07/Custom View/07.2 精通自定义 View 之 绘图进阶（二）/" itemprop="url">07.2 精通自定义 View 之 绘图进阶（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-07T02:00:00+08:00">
                2019-07-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Custom-View/" itemprop="url" rel="index">
                    <span itemprop="name">Custom View</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <meta name="referrer" content="no-referrer">

<h2 id="7-2-setShadowLayer-与阴影效果"><a href="#7-2-setShadowLayer-与阴影效果" class="headerlink" title="7.2 setShadowLayer 与阴影效果"></a>7.2 setShadowLayer 与阴影效果</h2><p>利用 layer-list 只能实现按钮的阴影效果，对于文字和图片都无法实现阴影效果，除了 layer-list，我们只能用自定义控件来实现阴影效果了，Paint 中有一个专门用来实现阴影效果的函数 setShadowLayer，我们先来看看这个函数实现的阴影效果图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-fea6ceb64d2ef245.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>从效果图中可以看出 setShadowLayer 函数能够实现：</p>
<ul>
<li>定制阴影模糊程度</li>
<li>定制阴影偏移距离</li>
<li>清除阴影和显示阴影</li>
</ul>
<h4 id="7-2-1-setShadowLayer-构造函数"><a href="#7-2-1-setShadowLayer-构造函数" class="headerlink" title="7.2.1 setShadowLayer() 构造函数"></a>7.2.1 setShadowLayer() 构造函数</h4><h6 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void setShadowLayer(float radius, float dx, float dy, int color)</div></pre></td></tr></table></figure>
<ul>
<li>float radius：意思是模糊半径，radius 越大越模糊，越小越清晰，但是如果 radius 设置为0，则阴影消失不见。</li>
<li>float dx：阴影的横向偏移距离，正值向右偏移，负值向左偏移。</li>
<li>float dy：阴影的纵向偏移距离，正值向下偏移，负值向上偏移。</li>
<li>int color：绘制阴影的画笔颜色，即阴影的颜色（对图片阴影无效）。</li>
</ul>
<p>setShadowLayer 使用的是高斯模糊算法，高斯模糊的具体算法是：对于正在处理的每一个像素，取周围若干个像素的 RGB 值并且平均，然后这个平均值就是模糊处理过的像素。如果对图片中的所有像素都这么处理的话，处理完成的图片就会变得模糊。其中，所取周围像素的半径就是模糊半径。所以，模糊半径越大，所得平均像素与原始像素相差就越大，也就越模糊。</p>
<p>绘制阴影的画笔颜色为什么对图片无效？</p>
<p>从上面的效果图中可以看出，使用 setShadowLayer 所产生的阴影，对于文字和绘制的图形的阴影都是使用自定义的阴影画笔颜色来画的；而图片的阴影则是直接产生一张相同的图片，仅对阴影图片的边缘进行模糊。之所以生成一张相同的背景图片，是因为如果统一使用某一种颜色来做阴影可能会与图片的颜色相差很大，而且不协调，比如某张图片的色彩非常丰富，而阴影如果使用灰色来做，可能就会显得很突兀，所以为了解决这个问题，针对图片的阴影就不再是统一颜色了，而是复制出这张图片，把复制出的图片的边缘进行模糊，做为阴影。但这样又会引起一个问题，就是如果我们想把图片的阴影做成灰色怎么办？使用 setShadowLayer 自动生成阴影是没办法了，在下篇我们会具体来讲，如何给图片添加指定颜色的阴影。</p>
<blockquote>
<p>注意：setShadowLayer 只有文字绘制阴影支持硬件加速，其它都不支持硬件加速，为了方便起见，需要在自定义控件中禁用硬件加速。</p>
</blockquote>
<h6 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h6><p><img src="https://upload-images.jianshu.io/upload_images/14186083-fc3493677e1727cb.gif?imageMogr2/auto-orient/strip" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint = new Paint();</div><div class="line">    private Bitmap mHeadBmp;</div><div class="line">    private Rect mRect;</div><div class="line">    private int mRadius = 1;</div><div class="line">    private int mDx = 10;</div><div class="line">    private int mDy = 10;</div><div class="line">    private boolean mSetShadow = true;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init()&#123;</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setTextSize(50);</div><div class="line">        mHeadBmp = BitmapFactory.decodeResource(getResources(), R.drawable.head);</div><div class="line">        mRect = new Rect();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        if (mSetShadow) &#123;</div><div class="line">            mPaint.setShadowLayer(mRadius, mDx, mDy, Color.GRAY);</div><div class="line">        &#125; else &#123;</div><div class="line">            mPaint.clearShadowLayer();</div><div class="line">        &#125;</div><div class="line">        canvas.drawText(&quot;xian小涛&quot;,100,100, mPaint);</div><div class="line">        canvas.drawCircle(200,200,50, mPaint);</div><div class="line">        mRect.set(200,300,200 + mHeadBmp.getWidth(),300 + mHeadBmp.getHeight());</div><div class="line">        canvas.drawBitmap(mHeadBmp,null, mRect, mPaint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void changeRadius() &#123;</div><div class="line">        mRadius++;</div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void changeDx() &#123;</div><div class="line">        mDx+=5;</div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void changeDy() &#123;</div><div class="line">        mDy+=5;</div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void clearShadow()&#123;</div><div class="line">        mSetShadow = false;</div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void showShadow()&#123;</div><div class="line">        mSetShadow = true;</div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123;</div><div class="line"></div><div class="line">    private TestView mView;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        mView = findViewById(R.id.view);</div><div class="line">        findViewById(R.id.radius_btn).setOnClickListener(this);</div><div class="line">        findViewById(R.id.dx_btn).setOnClickListener(this);</div><div class="line">        findViewById(R.id.dy_btn).setOnClickListener(this);</div><div class="line">        findViewById(R.id.clear_btn).setOnClickListener(this);</div><div class="line">        findViewById(R.id.show_btn).setOnClickListener(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onClick(View v) &#123;</div><div class="line">        switch (v.getId())&#123;</div><div class="line">            case R.id.radius_btn:</div><div class="line">                mView.changeRadius();</div><div class="line">                break;</div><div class="line">            case R.id.dx_btn:</div><div class="line">                mView.changeDx();</div><div class="line">                break;</div><div class="line">            case R.id.dy_btn:</div><div class="line">                mView.changeDy();</div><div class="line">                break;</div><div class="line">            case R.id.clear_btn:</div><div class="line">                mView.clearShadow();</div><div class="line">                break;</div><div class="line">            case R.id.show_btn:</div><div class="line">                mView.showShadow();</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="7-2-2-清除阴影"><a href="#7-2-2-清除阴影" class="headerlink" title="7.2.2 清除阴影"></a>7.2.2 清除阴影</h4><p>清除阴影其实有两个方法，可以将setShadowLayer的radius的值设为0，也可以使用专门的清除阴影的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void clearShadowLayer()</div></pre></td></tr></table></figure></p>
<p>具体效果见上面例子。</p>
<h4 id="7-2-3-示例：给文字添加阴影"><a href="#7-2-3-示例：给文字添加阴影" class="headerlink" title="7.2.3 示例：给文字添加阴影"></a>7.2.3 示例：给文字添加阴影</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-37733c90da49b0ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>从图中可以看到，TextView、Button、EditText 中的文字自定添加了阴影。而且对于 EditText 而言，新输入的文字依然有阴影效果。</p>
<p>setShadowLayer 是 API 1 就已经引入的函数，而且添加了 TextView 类 和 TextView 的派生类来支持阴影设置。TextView 的派生类如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-b2bc9117410494fb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h6 id="1-通过-XML-属性添加阴影"><a href="#1-通过-XML-属性添加阴影" class="headerlink" title="1. 通过 XML 属性添加阴影"></a>1. 通过 XML 属性添加阴影</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;TextView</div><div class="line">    ......</div><div class="line">    android:shadowRadius=&quot;3&quot;</div><div class="line">    android:shadowDx=&quot;5&quot;</div><div class="line">    android:shadowDy=&quot;5&quot;</div><div class="line">    android:shadowColor=&quot;@android:color/darker_gray&quot;/&gt;</div></pre></td></tr></table></figure>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line"></div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;使用XML添加阴影效果&quot;</div><div class="line">        android:shadowRadius=&quot;3&quot;</div><div class="line">        android:shadowDx=&quot;5&quot;</div><div class="line">        android:shadowDy=&quot;5&quot;</div><div class="line">        android:shadowColor=&quot;@android:color/darker_gray&quot;/&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/radius_btn&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;使用XML添加阴影效果&quot;</div><div class="line">        android:shadowRadius=&quot;3&quot;</div><div class="line">        android:shadowDx=&quot;5&quot;</div><div class="line">        android:shadowDy=&quot;5&quot;</div><div class="line">        android:shadowColor=&quot;@android:color/darker_gray&quot;/&gt;</div><div class="line">    &lt;EditText</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;使用XML添加阴影效果&quot;</div><div class="line">        android:shadowRadius=&quot;3&quot;</div><div class="line">        android:shadowDx=&quot;5&quot;</div><div class="line">        android:shadowDy=&quot;5&quot;</div><div class="line">        android:shadowColor=&quot;@android:color/darker_gray&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>
<h6 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h6><p>TextView 及其派生类都有一个 Paint.setShadowLayer 的同名方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void setShadowLayer(float radius, float dx, float dy, int color)</div></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TextView tv = findViewById(R.id.tv);</div><div class="line">tv.setShadowLayer(3, 5, 5, Color.GRAY);</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/07/Custom View/07.1 精通自定义 View 之 绘图进阶（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="King">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/07/Custom View/07.1 精通自定义 View 之 绘图进阶（一）/" itemprop="url">07.1 精通自定义 View 之 绘图进阶（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-07T01:00:00+08:00">
                2019-07-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Custom-View/" itemprop="url" rel="index">
                    <span itemprop="name">Custom View</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <meta name="referrer" content="no-referrer">

<h2 id="7-1-贝济埃曲线"><a href="#7-1-贝济埃曲线" class="headerlink" title="7.1 贝济埃曲线"></a>7.1 贝济埃曲线</h2><h4 id="7-1-1-概述"><a href="#7-1-1-概述" class="headerlink" title="7.1.1 概述"></a>7.1.1 概述</h4><p>在 Path 的系列函数中，除了一些基本的设置和绘图用法外，还有一个强大的工具——贝济埃曲线。它能将利用 moveTo、lineTo 连接的生硬路径变得平滑，也能够实现很多炫酷的效果，比如水波纹等。</p>
<h6 id="1-贝赛尔曲线来源"><a href="#1-贝赛尔曲线来源" class="headerlink" title="1. 贝赛尔曲线来源"></a>1. 贝赛尔曲线来源</h6><p>贝塞尔曲线于 1962 年，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由 Paul de Casteljau 于 1959 年运用 de Casteljau 算法开发，以稳定数值的方法求出贝塞尔曲线。</p>
<p>在数学的数值分析领域中，贝赛尔曲线（Bézier 曲线）是电脑图形学中相当重要的参数曲线。更高维度的广泛化贝塞尔曲线就称作贝塞尔曲面，其中贝塞尔三角是一种特殊的实例。</p>
<h6 id="2-贝济埃曲线公式"><a href="#2-贝济埃曲线公式" class="headerlink" title="2. 贝济埃曲线公式"></a>2. 贝济埃曲线公式</h6><p><strong>1）一阶贝济埃曲线</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-d7535084366336a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-88a1d9f33c56d0d5?imageMogr2/auto-orient/strip" alt=""></p>
<p>P0 为起点、P1 为终点，t 表示当前时间，B(t) 表示公式的结果值。<br>注意，曲线的意义就是公式结果 B(t) 随时间的变化，其取值所形成的轨迹。在动画中，黑色点表示在当前时间 t 下公式 B(t) 的取值。而红色的那条线就不在各个时间点下不同取值的 B(t) 所形成的轨迹。</p>
<p>总而言之：对于一阶贝济埃曲线，大家可以理解为在起始点和终点形成的这条直线上，匀速移动的点。</p>
<p><strong>2）二阶贝济埃曲线</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-d0fab250e052d246?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-723ce7c1ee1e0016?imageMogr2/auto-orient/strip" alt=""></p>
<p>在这里 P0 是起始点，P2 是终点，P1 是控制点。<br>假设将时间定在 t=0.25 的时刻，此时的状态如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-b43003ea2bdfb507?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>首先，P0 点和 P1 点形成了一条贝济埃曲线，还记得我们上面对一阶贝济埃曲线的总结么：就是一个点在这条直线上做匀速运动；所以 P0-P1 这条直线上的移动的点就是 Q0。</p>
<p>同样，P1、P2 形成了一条一阶贝济埃曲线，在这条一阶贝济埃曲线上，它们的随时间移动的点是 Q1。</p>
<p>最后，动态点 Q0 和 Q1 又形成了一条一阶贝济埃曲线，在它们这条一阶贝济埃曲线动态移动的点是 B。而 B 的移动轨迹就是这个二阶贝济埃曲线的最终形态。从上面的讲解大家也可以知道，之所以叫它二阶贝济埃曲线是因为，B 的移动轨迹是建立在两个一阶贝济埃曲线的中间点 Q0、Q1 的基础上的。</p>
<p>在理解了二阶贝赛尔曲线的形成原理以后，我们就不难理解三阶贝赛尔曲线了。</p>
<p><strong>3）三阶贝济埃曲线</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-044ad9428fcbbc29?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-2c38ba6a9c8950a3?imageMogr2/auto-orient/strip" alt=""></p>
<p>同样，我们取其中一点来讲解轨迹的形成原理，当 t=0.25 时,此时状态如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-f67fcc49e576bc40?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>同样，P0 是起始点，P3 是终点；P1 是第一个控制点，P2 是第二个控制点。</p>
<p>首先，这里有三条一阶贝济埃曲线，分别是 P0-P1、P1-P2、P2-P3，他们随时间变化的点分别为 Q0、Q1、Q2。然后是由 Q0、Q1、Q2 这三个点，再次连接，形成了两条一阶贝济埃曲线，分别是Q0-Q1、Q1-Q2，他们随时间变化的点为 R0、R1。</p>
<p>同样，R0 和 R1 同样可以连接形成一条一阶贝济埃曲线，在 R0-R1 这条贝赛尔曲线上随时间移动的点是 B，而 B 的移动轨迹就是这个三阶贝济埃曲线的最终形状。</p>
<p>从上面的解析大家可以看出，所谓几阶贝济埃曲线，全部是由一条条一阶贝济埃曲线搭起来的。在上图中，形成一阶贝济埃曲线的直线是灰色的，形成二阶贝济埃曲线线是绿色的，形成三阶贝济埃曲线的线是蓝色的。</p>
<p>在理解了上面的二阶和三阶贝济埃曲线以后，我们再来看几个贝济埃曲线的动态图。</p>
<p><strong>4）四阶贝济埃曲线</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-91e7647f793fd876?imageMogr2/auto-orient/strip" alt=""></p>
<p><strong>5）五阶贝济埃曲线</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-e28ef335e39c174f?imageMogr2/auto-orient/strip" alt=""></p>
<p>######3. 贝济埃曲线与 PhotoShop 钢笔工具<br>在专业绘图工具 Photoshop 中，有一个钢笔工具，它使用的路径弯曲效果就是二阶贝济埃曲线，下面利用 Photoshop 的钢笔工具来得出二阶贝济埃曲线的相关控制点。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-003dae5d4ff785c8?imageMogr2/auto-orient/strip" alt=""></p>
<p>我们拿最终成形的图形来看一下为什么钢笔工具是二阶贝济埃曲线：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-cb15295694db8eff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>右图演示的假设某一点 t=0.25 时，动态点 B 的位置图。<br>同样，这里 P0 是起始点，P2 是终点，P1 是控制点。<br>P0-P1、P1-P2 形成了第一层的一阶贝济埃曲线。它们随时间的动态点分别是 Q0、Q1；动态点 Q0、Q1 又形成了第二层的一阶贝济埃曲线，它们的动态点是 B。而 B 的轨迹跟钢笔工具的形状是完全一样的，所以说钢笔工具的拉伸效果使用的是二阶贝济埃曲线。</p>
<p>这里需要注意的是，我们在使用钢笔工具时，拖动的是 P5 点。其实二阶贝济埃曲线的控制点是其对面的 P1 点，钢笔工具这样设计是当然是因为操作起来比较方便。</p>
<h4 id="7-1-2-贝济埃曲线之-quadTo"><a href="#7-1-2-贝济埃曲线之-quadTo" class="headerlink" title="7.1.2 贝济埃曲线之 quadTo"></a>7.1.2 贝济埃曲线之 quadTo</h4><p>在 Path 类中有四个方法与贝济埃曲线相关，分别是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 二阶济埃尔</div><div class="line">public void quadTo(float x1, float y1, float x2, float y2)</div><div class="line">public void rQuadTo(float dx1, float dy1, float dx2, float dy2)</div><div class="line">// 三阶济埃尔</div><div class="line">public void cubicTo(float x1, float y1, float x2, float y2,float x3, float y3)</div><div class="line">public void rCubicTo(float x1, float y1, float x2, float y2,float x3, float y3)</div></pre></td></tr></table></figure></p>
<p>在这四个函数中 quadTo、rQuadTo 是二阶贝济埃曲线，cubicTo、rCubicTo 是三阶贝济埃曲线；我们这篇文章以二阶贝济埃曲线的 quadTo、rQuadTo 为主，三阶贝济埃曲线 cubicTo、rCubicTo 用的使用方法与二阶贝济埃曲线类似，用处也比较少，这篇就不再细讲了。</p>
<h6 id="1-quadTo-使用原理"><a href="#1-quadTo-使用原理" class="headerlink" title="1. quadTo 使用原理"></a>1. quadTo 使用原理</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void quadTo(float x1, float y1, float x2, float y2)</div></pre></td></tr></table></figure>
<p>参数中 (x1,y1) 是控制点坐标，(x2,y2) 是终点坐标。<br>大家可能会有一个疑问：有控制点和终点坐标，那起始点是多少呢？<br>整条线的起始点是通过 Path.moveTo(x,y) 来指定的，而如果我们连续调用 quadTo()，前一个 quadTo() 的终点，就是下一个 quadTo() 函数的起点；如果初始没有调用 Path.moveTo(x,y) 来指定起始点，则默认以控件左上角(0,0)为起始点。大家可能还是有点迷糊，下面我们就举个例子来看看，我们利用 quadTo() 来画下面的这条波浪线：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-8c334c61c48848cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>下面分析一下，在这条路径轨迹中，控制点分别在哪个位置，如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-e37060659bbc933e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>我们先看 P0-P2 这条轨迹，P0 是起点，假设位置坐标是 (100,300)，P2 是终点，假充位置坐标是 (300,300)；在以 P0 为起始点，P2 为终点这条二阶贝济埃曲线上，P1 是控制点，很明显 P1 大概在 P0、P2 中间的位置，所以它的 X 坐标应该是 200，关于 Y 坐标，我们无法确定，但很明显的是 P1 在 P0、P2 点的上方，也就是它的 Y 值比它们的小，所以根据钢笔工具上面的位置，我们让 P1 的比 P0、P2 的小 100，所以 P1的坐标是 (200，200)。</p>
<p>同理，不难求出在 P2-P4 这条二阶贝济埃曲线上，它们的控制点 P3 的坐标位置应该是 (400,400)。</p>
<p>所以我们就可以自定义一个控件，并重写它的 onDraw() 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setStrokeWidth(4);</div><div class="line">        mPaint.setColor(Color.GRAY);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setAntiAlias(true);</div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        mPath.moveTo(100, 300);</div><div class="line">        mPath.quadTo(200, 200, 300, 300);</div><div class="line">        mPath.quadTo(400, 400, 500, 300);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过这个例子希望大家知道两点：</p>
<ul>
<li>整条线的起始点是通过 Path.moveTo(x,y) 来指定的，如果初始没有调用 Path.moveTo(x,y) 来指定起始点，则默认以控件左上角 (0,0) 为起始点。</li>
<li>如果我们连续调用 quadTo()，前一个 quadTo() 的终点，就是下一个 quadTo() 函数的起点。</li>
</ul>
<h6 id="2-示例：手指轨迹"><a href="#2-示例：手指轨迹" class="headerlink" title="2. 示例：手指轨迹"></a>2. 示例：手指轨迹</h6><p>要实现手指轨迹其实是非常简单的，我们只需要在自定义中拦截 OnTouchEvent，然后根据手指的移动轨迹来绘制 Path 即可。最简单的方法就是直接使用 Path.lineTo() 就能实现把各个点连接起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(4);</div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        switch (event.getAction())&#123;</div><div class="line">            case MotionEvent.ACTION_DOWN:</div><div class="line">                mPath.moveTo(event.getX(), event.getY());</div><div class="line">                return true;</div><div class="line">            case MotionEvent.ACTION_MOVE:</div><div class="line">                mPath.lineTo(event.getX(), event.getY());</div><div class="line">                invalidate();</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然实现了画出手指的移动轨迹，但我们仔细来看看画出来的图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-d6cd12f5a2fbbdd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>我们把轨迹放大，明显看出，在两个点连接处有明显的转折，而且在轨迹顶部位置横纵坐标变化比较快的位置，看起来跟图片这大后的马赛克一样；利用 Path 绘图，是不可能出现马赛克的，因为除了 Bitmap 以外的任何 canvas 绘图全部都是矢量图，也就是利用数学公式来作出来的图，无论放在多大屏幕上，都不可能会出现马赛克。这里利用 Path 绘图，在轨迹顶部之所以看起来像是马赛克是因为这个轨迹是由各个不同点之间连线写出来的，而之间并没有平滑过渡，所以当坐标变化比较剧烈时，线与线之间的转折就显得特别明显了。</p>
<p>所以要想优化这种效果，就得实现线与线之间的平滑过渡，很显然，二阶贝济埃曲线就是干这个事的。下面我们就利用我们新学的 Path.quadTo 函数来重新实现下移动轨迹效果。</p>
<h6 id="3-优化：使用-Path-quadTo-函数实现手势过渡"><a href="#3-优化：使用-Path-quadTo-函数实现手势过渡" class="headerlink" title="3. 优化：使用 Path.quadTo() 函数实现手势过渡"></a>3. 优化：使用 Path.quadTo() 函数实现手势过渡</h6><p>使用 Path.lineTo() 的最大问题就是线段转折处不够平滑。Path.quadTo() 可以实现平滑过渡，但使用 Path.quadTo() 的最大问题是，如何找到起始点和结束点。</p>
<p>下图中，有用绿点表示的三个点，连成的两条直线，很明显他们转折处是有明显折痕的</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-88af940cfd85bb19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>下面我们在 PhotoShop 中利用钢笔工具，看如何才能实现这两条线之间的转折。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-65b3cc5c9634eb46?imageMogr2/auto-orient/strip" alt=""></p>
<p>最终的贝济埃曲线连接如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-b26dea192018dcc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>从这两个线段中可以看出，我们使用 Path.lineTo() 的时候，是直接把手指触点 A、B、C 给连起来。而钢笔工具要实现这三个点间的流畅过渡，就只能将这两个线段的中间点做为起始点和结束点，而将手指的倒数第二个触点 B 做为控制点。</p>
<p>大家可能会觉得，那这样，在结束的时候，A 到 P0 和 P1 到 C1 的这段距离岂不是没画进去？是的，如果 Path 最终没有 close 的话，这两段距离是被抛弃掉的。因为手指间滑动时，每两个点间的距离很小，所以 P1 到 C 之间的距离可以忽略不计。</p>
<p>下面我们就利用这种方法在photoshop中求证，在连接多个线段时，是否能行？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-c8dbebc11cee4204.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在这个图形中，有很多点连成了弯弯曲曲的线段，我们利用上面我们讲的，将两个线段的中间做为二阶贝济埃曲线的起始点和终点，把上一个手指的位置做为控制点，来看看是否真的能组成平滑的连线<br>整个连接过程如动画所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-c2167deb01b0a691?imageMogr2/auto-orient/strip" alt=""></p>
<p>在最终的路径中看来，各个点间的连线是非常平滑的。从这里也可以看出，在为了实现平滑效果，我们只能把开头的线段一半和结束的线段的一半抛弃掉。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-a218b1d8f0dce88d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line">    private float mPreX, mPreY;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(4);</div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        switch (event.getAction())&#123;</div><div class="line">            case MotionEvent.ACTION_DOWN:</div><div class="line">                mPath.moveTo(event.getX(), event.getY());</div><div class="line">                mPreX = event.getX();</div><div class="line">                mPreY = event.getY();</div><div class="line">                return true;</div><div class="line">            case MotionEvent.ACTION_MOVE:</div><div class="line">                float endX = (mPreX + event.getX()) / 2;</div><div class="line">                float endY = (mPreY + event.getY()) / 2;</div><div class="line">                mPath.quadTo(mPreX, mPreY, endX, endY);</div><div class="line">                mPreX = event.getX();</div><div class="line">                mPreY = event.getY();</div><div class="line">                invalidate();</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="7-1-3-贝济埃曲线之-rQuadTo"><a href="#7-1-3-贝济埃曲线之-rQuadTo" class="headerlink" title="7.1.3 贝济埃曲线之 rQuadTo"></a>7.1.3 贝济埃曲线之 rQuadTo</h4><h6 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void rQuadTo(float dx1, float dy1, float dx2, float dy2)</div></pre></td></tr></table></figure>
<ul>
<li>dx1：控制点 X 坐标，表示相对上一个终点 X 坐标的位移坐标，可为负值，正值表示相加，负值表示相减。</li>
<li>dy1：控制点 Y 坐标，表示相对上一个终点 Y 坐标的位移坐标。同样可为负值，正值表示相加，负值表示相减。</li>
<li>dx2：终点 X 坐标，同样是一个相对坐标，相对上一个终点 X 坐标的位移值，可为负值，正值表示相加，负值表示相减。</li>
<li>dy2：终点 Y 坐标，同样是一个相对，相对上一个终点 Y 坐标的位移值。可为负值，正值表示相加，负值表示相减。</li>
</ul>
<p>这四个参数都是传递的都是相对值，相对上一个终点的位移值。</p>
<p>比如，我们上一个终点坐标是 (300,400) 那么利用，rQuadTo(100,-100,200,100) 得到的控制点坐标是 (300+100, 400-100) 即 (500,300)；同样，得到的终点坐标是 (300+200, 400+100)，即 (500,500)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 利用 quadTo 定义一个绝对坐标：</div><div class="line">path.moveTo(300,400);</div><div class="line">path.quadTo(500,300,500,500);</div><div class="line"></div><div class="line">// 与利用 rQuadTo 定义相对坐标是等价的：</div><div class="line">path.moveTo(300,400);</div><div class="line">path.rQuadTo(100,-100,200,100)</div></pre></td></tr></table></figure></p>
<h6 id="2-使用-rQuadTo-函数实现波浪线"><a href="#2-使用-rQuadTo-函数实现波浪线" class="headerlink" title="2. 使用 rQuadTo() 函数实现波浪线"></a>2. 使用 rQuadTo() 函数实现波浪线</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mPath.moveTo(100, 300);</div><div class="line">/*</div><div class="line">mPath.quadTo(200, 200, 300, 300);</div><div class="line">mPath.quadTo(400, 400, 500, 300);</div><div class="line">*/</div><div class="line">// 替换成</div><div class="line">mPath.rQuadTo(100, -100, 200, 0);</div><div class="line">mPath.rQuadTo(100, 100, 200, 0);</div><div class="line">canvas.drawPath(mPath, mPaint);</div></pre></td></tr></table></figure>
<p>第一句：path.rQuadTo(100,-100,200,0); 是建立在 (100,300) 这个点基础上来计算相对坐标的，所以：<br>控制点X坐标 = 上一个终点X坐标+控制点X位移 = 100+100=200；<br>控制点Y坐标 = 上一个终点Y坐标+控制点Y位移 = 300-100=200；<br>终点X坐标 = 上一个终点X坐标+终点X位移 = 100+200=300；<br>终点Y坐标 = 上一个终点Y坐标+终点Y位移 = 300+0=300;<br>所以这句与 path.quadTo(200,200,300,300); 对等的。</p>
<p>第二句：path.rQuadTo(100,100,200,0); 是建立在它的前一个终点即 (300,300) 的基础上来计算相对坐标的，所以：<br>控制点X坐标 = 上一个终点X坐标+控制点X位移 = 300+100=200；<br>控制点Y坐标 = 上一个终点Y坐标+控制点Y位移 = 300+100=200；<br>终点X坐标 = 上一个终点X坐标+终点X位移 = 300+200=500；<br>终点Y坐标 = 上一个终点Y坐标+终点Y位移 = 300+0=300;<br>所以这句与 path.quadTo(400,400,500,300); 对等的。</p>
<p>最终效果也是一样的。</p>
<p>通过这个例子，只想让大家明白一点：rQuadTo(float dx1, float dy1, float dx2, float dy2) 中的位移坐标，都是以上一个终点位置为基准来做偏移的。</p>
<h4 id="7-1-4-示例：波浪效果"><a href="#7-1-4-示例：波浪效果" class="headerlink" title="7.1.4 示例：波浪效果"></a>7.1.4 示例：波浪效果</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-500be19b0bdb1bd8.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>我们将 mPath 的起始位置向左移一个波长，然后利用 for 循环画出当前屏幕中可能容得下的所有波。然后画一个波的左右两个半波：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 画的是一个波长中的前半个波</div><div class="line">mPath.rQuadTo(halfWaveLen/2, -100, halfWaveLen, 0); </div><div class="line">// 画的是一个波长中的后半个波</div><div class="line">mPath.rQuadTo(halfWaveLen/2, 100, halfWaveLen, 0);</div></pre></td></tr></table></figure></p>
<p>大家在这里可以看到，屏幕左右都多画了一个波长的图形。这是为了波形移动做准备的。</p>
<p>让波纹动起来其实挺简单，利用调用在 path.moveTo 的时候，将起始点向右移动即可实现移动，而且只要我们移动一个波长的长度，波纹就会重合，就可以实现无限循环了。</p>
<p>完整的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line">    private int mItemWaveLength = 1000;</div><div class="line">    private int dx;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPath = new Path();</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setStyle(Paint.Style.FILL_AND_STROKE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        mPath.reset();</div><div class="line">        int originY = 300;</div><div class="line">        int halfWaveLen = mItemWaveLength/2;</div><div class="line">        mPath.moveTo(-mItemWaveLength+dx,originY);</div><div class="line">        for (int i = -mItemWaveLength; i&lt;=getWidth()+mItemWaveLength; i+=mItemWaveLength)&#123;</div><div class="line">            mPath.rQuadTo(halfWaveLen/2f,-100,halfWaveLen,0);</div><div class="line">            mPath.rQuadTo(halfWaveLen/2f,100,halfWaveLen,0);</div><div class="line">        &#125;</div><div class="line">        mPath.lineTo(getWidth(),getHeight());</div><div class="line">        mPath.lineTo(0,getHeight());</div><div class="line">        mPath.close();</div><div class="line"></div><div class="line">        canvas.drawPath(mPath,mPaint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void startAnim()&#123;</div><div class="line">        ValueAnimator animator = ValueAnimator.ofInt(0,mItemWaveLength);</div><div class="line">        animator.setDuration(2000);</div><div class="line">        animator.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">        animator.setInterpolator(new LinearInterpolator());</div><div class="line">        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">                dx = (int)animation.getAnimatedValue();</div><div class="line">                postInvalidate();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        animator.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用 TestView<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        TestView view = findViewById(R.id.view);</div><div class="line">        view.startAnim();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/06/Custom View/06.3 精通自定义 View 之 Paint 基本使用（三）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="King">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/06/Custom View/06.3 精通自定义 View 之 Paint 基本使用（三）/" itemprop="url">06.3 精通自定义 View 之 Paint 基本使用（三）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-06T03:00:00+08:00">
                2019-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Custom-View/" itemprop="url" rel="index">
                    <span itemprop="name">Custom View</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <meta name="referrer" content="no-referrer">

<h2 id="6-3-Paint-常用函数"><a href="#6-3-Paint-常用函数" class="headerlink" title="6.3 Paint 常用函数"></a>6.3 Paint 常用函数</h2><h4 id="6-1-1-基本函数设置"><a href="#6-1-1-基本函数设置" class="headerlink" title="6.1.1 基本函数设置"></a>6.1.1 基本函数设置</h4><p>我们先来看一下paint中基本设置的函数都有哪些。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 重置画笔</div><div class="line">reset()</div><div class="line">// 给画笔设置颜色值</div><div class="line">setColor(int color)</div><div class="line">// 设置颜色，利用 ARGB 分开设置</div><div class="line">setARGB(int a, int r, int g, int b)</div><div class="line">// 设置画笔透明度</div><div class="line">setAlpha(int a)</div><div class="line">// 设置画笔样式，取值有：Paint.Style.FILL、STROKE、FILL_AND_STROKE</div><div class="line">setStyle(Paint.Style style)</div><div class="line">// 设置画笔宽度</div><div class="line">setStrokeWidth(float width)</div><div class="line">// 设置画笔是否抗锯齿</div><div class="line">setAntiAlias(boolean aa)</div><div class="line"></div><div class="line">// 设置线冒样式，取值有Cap.ROUND(圆形线冒)、</div><div class="line">// Cap.SQUARE(方形线冒)、Paint.Cap.BUTT(无线冒)</div><div class="line">setStrokeCap(Paint.Cap cap)</div><div class="line">// 设置线段连接处样式，取值有：Join.MITER（结合处为锐角）、</div><div class="line">// Join.Round(结合处为圆弧)、Join.BEVEL(结合处为直线)</div><div class="line">setStrokeJoin(Paint.Join join)</div><div class="line">// 设置笔画的倾斜度，区别不明显</div><div class="line">setStrokeMiter(float miter)</div><div class="line">// 设置路径样式。取值类型是所有派生自 PathEffect 的子类：</div><div class="line">// ComposePathEffect、CornerPathEffect、DashPathEffect、</div><div class="line">// DiscretePathEffect、PathDashPathEffect、SumPathEffect</div><div class="line">setPathEffect(PathEffect effect)</div></pre></td></tr></table></figure></p>
<h6 id="1-setStrokeCap-Paint-Cap-cap"><a href="#1-setStrokeCap-Paint-Cap-cap" class="headerlink" title="1. setStrokeCap(Paint.Cap cap)"></a>1. setStrokeCap(Paint.Cap cap)</h6><p>设置线帽样式，取值有 Cap.ROUND (圆形线帽)、Cap.SQUARE (方形线帽)、Paint.Cap.BUTT (无线帽)</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-8d1fcbc504d407cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>红线左侧多出来的区域就是线帽。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setStrokeWidth(80);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setAntiAlias(true);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        // 无线帽</div><div class="line">        mPaint.setStrokeCap(Paint.Cap.BUTT);</div><div class="line">        canvas.drawLine(100, 200, 400, 200, mPaint);</div><div class="line">        // 方形线帽</div><div class="line">        mPaint.setStrokeCap(Paint.Cap.SQUARE);</div><div class="line">        canvas.drawLine(100, 400, 400, 400, mPaint);</div><div class="line">        // 圆形线帽</div><div class="line">        mPaint.setStrokeCap(Paint.Cap.ROUND);</div><div class="line">        canvas.drawLine(100, 600, 400, 600, mPaint);</div><div class="line"></div><div class="line">        // 画辅助线</div><div class="line">        mPaint.reset();</div><div class="line">        mPaint.setStrokeWidth(2);</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        canvas.drawLine(100, 50, 100, 750, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="2-setStrokeJoin-Paint-Join-join"><a href="#2-setStrokeJoin-Paint-Join-join" class="headerlink" title="2. setStrokeJoin(Paint.Join join)"></a>2. setStrokeJoin(Paint.Join join)</h6><p>参数取值有：Join.MITER (结合处为锐角)、Join.Round (结合处为圆弧)、Join.BEVEL(结合处为直线)</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-4e349899a7f42832?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-10d2f61db3868fbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setStrokeWidth(40);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setAntiAlias(true);</div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        // 结合处为锐角 MITER</div><div class="line">        mPath.moveTo(100, 100);</div><div class="line">        mPath.lineTo(250, 100);</div><div class="line">        mPath.lineTo(100, 250);</div><div class="line">        mPaint.setStrokeJoin(Paint.Join.MITER);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        // 结合处为圆弧 ROUND</div><div class="line">        mPath.moveTo(300, 100);</div><div class="line">        mPath.lineTo(450, 100);</div><div class="line">        mPath.lineTo(300, 250);</div><div class="line">        mPaint.setStrokeJoin(Paint.Join.ROUND);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        // 结合处为直线 BEVEL</div><div class="line">        mPath.moveTo(500, 100);</div><div class="line">        mPath.lineTo(650, 100);</div><div class="line">        mPath.lineTo(500, 250);</div><div class="line">        mPaint.setStrokeJoin(Paint.Join.BEVEL);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="3-setPathEffect-PathEffect-effect"><a href="#3-setPathEffect-PathEffect-effect" class="headerlink" title="3. setPathEffect(PathEffect effect)"></a>3. setPathEffect(PathEffect effect)</h6><p>设置路径样式。取值类型是所有派生自 PathEffect 的子类：ComposePathEffect、CornerPathEffect、DashPathEffect、DiscretePathEffect、PathDashPathEffect、SumPathEffect。</p>
<p>1）CornerPathEffect<br>它的作用就是将原来 Path 生硬的直线拐角，变成圆形拐角。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public CornerPathEffect(float radius)</div></pre></td></tr></table></figure></p>
<p>参数 radius：即当前连接两条直线所使用的圆的半径。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-fc5362e0bd2e16ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-c6098ec540f11b5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line">    private CornerPathEffect effect100, effect200;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setStrokeWidth(4);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setAntiAlias(true);</div><div class="line">        mPath = new Path();</div><div class="line">        effect100 = new CornerPathEffect(100);</div><div class="line">        effect200 = new CornerPathEffect(200);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        mPath.moveTo(100,600);</div><div class="line">        mPath.lineTo(400,100);</div><div class="line">        mPath.lineTo(700,900);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line"></div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPaint.setPathEffect(effect100);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line"></div><div class="line">        mPaint.setColor(Color.BLUE);</div><div class="line">        mPaint.setPathEffect(effect200);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2）DashPathEffect 虚线效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public DashPathEffect(float intervals[], float phase)</div></pre></td></tr></table></figure></p>
<p>phase：开始绘制的偏移值。<br>intervals[]：表示组成虚线的各个线段的长度；整条虚线就是由intervals[] 中这些基本线段循环组成的。比如，我们定义new float[] {20,10}；那这个虚线段就是由两段线段组成的，第一个可见的线段长为20，每二个线段不可见，长度为10。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-b59d246d7eca5520?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>对于 intervals[] 数组的有两个限定：</p>
<ul>
<li>长度必须大于等于 2；因为必须有一个实线段和一个空线段来组成虚线。</li>
<li>个数必须为偶数，如果是基数，最后一个数字将被忽略；这个很好理解，因为一组虚线的组成必然是一个实线和一个空线成对组成的。</li>
</ul>
<p>示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-aed9539fe190586b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line">    private DashPathEffect effect1, effect2;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setStrokeWidth(4);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setAntiAlias(true);</div><div class="line">        mPath = new Path();</div><div class="line">        effect1 = new DashPathEffect(new float[]&#123;20,10,100,100&#125;,0);</div><div class="line">        effect2 = new DashPathEffect(new float[]&#123;20,10,50,100&#125;,15);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        mPath.moveTo(100,600);</div><div class="line">        mPath.lineTo(400,100);</div><div class="line">        mPath.lineTo(700,900);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line"></div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPaint.setPathEffect(effect1);</div><div class="line">        canvas.translate(0, 100);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line"></div><div class="line">        mPaint.setColor(Color.BLUE);</div><div class="line">        mPaint.setPathEffect(effect2);</div><div class="line">        canvas.translate(0, 100);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3）DiscretePathEffect 离散路径效果<br>DiscretePathEffect 就是将原来路径分隔成定长的线段，然后将每条线段随机偏移一段位置，我们可以用它来模拟一种类似生锈铁丝的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public DiscretePathEffect(float segmentLength, float deviation)</div></pre></td></tr></table></figure></p>
<ul>
<li>参数 segmentLength：表示将原来的路径切成多长的线段。如果值为2，那么这个路径就会被切成一段段由长度为 2 的小线段。所以这个值越小，所切成的小线段越多；这个值越大，所切成的小线段越少。</li>
<li>参数 deviation：表示被切成的每个小线段的可偏移距离。值越大，就表示每个线段的可偏移距离就越大，就显得越凌乱，值越小，每个线段的可偏移原位置的距离就越小。</li>
</ul>
<p>示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-9d31b725f3a65625.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = getPaint();</div><div class="line">        mPath = getPath();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        // 第一条原生 Path</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        // 第二条 Path</div><div class="line">        canvas.translate(0,200);</div><div class="line">        mPaint.setPathEffect(new DiscretePathEffect(2,5));</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        // 第三条 Path</div><div class="line">        canvas.translate(0,200);</div><div class="line">        mPaint.setPathEffect(new DiscretePathEffect(6,5));</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        // 第四条 Path</div><div class="line">        canvas.translate(0,200);</div><div class="line">        mPaint.setPathEffect(new DiscretePathEffect(6,15));</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Path getPath()&#123;</div><div class="line">        Path path = new Path();</div><div class="line">        // 定义路径的起点</div><div class="line">        path.moveTo(0, 0);</div><div class="line"></div><div class="line">        // 定义路径的各个点</div><div class="line">        for (int i = 0; i &lt;= 40; i++) &#123;</div><div class="line">            path.lineTo(i*35, (float) (Math.random() * 150));</div><div class="line">        &#125;</div><div class="line">        return path;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Paint getPaint()&#123;</div><div class="line">        Paint paint = new Paint();</div><div class="line">        paint.setStrokeWidth(4);</div><div class="line">        paint.setColor(Color.GREEN);</div><div class="line">        paint.setStyle(Paint.Style.STROKE);</div><div class="line">        paint.setAntiAlias(true);</div><div class="line">        return paint;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4）PathDashPathEffect 印章路径效果<br>它的作用就是用另一个路径图案做为印章，沿着指定路径一个个盖上去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public PathDashPathEffect(Path shape, float advance, float phase,Style style)</div></pre></td></tr></table></figure></p>
<ul>
<li>Path shape：表示印章路径，比如我们下面示例中的三角形加右上角一个点。</li>
<li>float advance：表示两个印章路径间的距离，印章间距离越大，间距就越大。</li>
<li>float phase：路径绘制偏移距离，与上面 DashPathEffect 中的 float phase 参数意义相同。</li>
<li>Style style：表示在遇到转角时，如何操作印章以使转角平滑过渡，取值有：Style.ROTATE，Style.MORPH，Style.TRANSLATE；Style.ROTATE 表示通过旋转印章来过渡转角；Style.MORPH 表示通过变形印章来过渡转角；Style.TRANSLATE 表示通过位移来过渡转角。</li>
</ul>
<p>示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-4dfb51710a4d6aa1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line">    private PathDashPathEffect mEffectMORPH, mEffectROTATE, mEffectTRANSLATE;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint = getPaint();</div><div class="line">        mPath = getPath();</div><div class="line">        // 构建印章路径</div><div class="line">        Path stampPath = getStampPath();</div><div class="line">        stampPath.addCircle(0,0,3, Path.Direction.CCW);</div><div class="line">        mEffectMORPH = new PathDashPathEffect(stampPath,35,0, PathDashPathEffect.Style.MORPH);</div><div class="line">        mEffectROTATE = new PathDashPathEffect(stampPath,35,0, PathDashPathEffect.Style.ROTATE);</div><div class="line">        mEffectTRANSLATE = new PathDashPathEffect(stampPath,35,0, PathDashPathEffect.Style.TRANSLATE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        // 原始线</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        // 使用印章路径效果 MORPH</div><div class="line">        canvas.translate(0,200);</div><div class="line">        mPaint.setPathEffect(mEffectMORPH);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        // 使用印章路径效果 ROTATE</div><div class="line">        canvas.translate(0,200);</div><div class="line">        mPaint.setPathEffect(mEffectROTATE);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        // 使用印章路径效果 TRANSLATE</div><div class="line">        canvas.translate(0,200);</div><div class="line">        mPaint.setPathEffect(mEffectTRANSLATE);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Path getPath()&#123;</div><div class="line">        Path path = new Path();</div><div class="line">        // 定义路径的起点</div><div class="line">        path.moveTo(0, 0);</div><div class="line"></div><div class="line">        // 定义路径的各个点</div><div class="line">        for (int i = 0; i &lt;= 40; i++) &#123;</div><div class="line">            path.lineTo(i*35, (float) (Math.random() * 150));</div><div class="line">        &#125;</div><div class="line">        return path;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Path getStampPath()&#123;</div><div class="line">        Path path  = new Path();</div><div class="line">        path.moveTo(0,20);</div><div class="line">        path.lineTo(10,0);</div><div class="line">        path.lineTo(20,20);</div><div class="line">        path.close();</div><div class="line"></div><div class="line">        path.addCircle(0,0,3, Path.Direction.CCW);</div><div class="line">        return path;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Paint getPaint()&#123;</div><div class="line">        Paint paint = new Paint();</div><div class="line">        paint.setStrokeWidth(4);</div><div class="line">        paint.setColor(Color.GREEN);</div><div class="line">        paint.setStyle(Paint.Style.STROKE);</div><div class="line">        paint.setAntiAlias(true);</div><div class="line">        return paint;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>5）ComposePathEffect &amp; SumPathEffect<br>这两个都是用来合并两个特效的。但它们之间是有区别的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public ComposePathEffect(PathEffect outerpe, PathEffect innerpe)</div><div class="line">public SumPathEffect(PathEffect first, PathEffect second)</div></pre></td></tr></table></figure></p>
<p>ComposePathEffect 合并两个特效是有先后顺序的，它会先将第二个参数的 PathEffect innerpe 的特效作用于路径上，然后再在此加了特效的路径上作用第一个特效。</p>
<p>而 SumPathEffect 是分别对原始路径分别作用第一个特效和第二个特效。然后再将这两条路径合并，做为最终结果。</p>
<p>示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-5444bb1a116fd454?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 画原始路径</div><div class="line">Paint paint = getPaint();</div><div class="line">Path path = getPath();</div><div class="line">canvas.drawPath(path,paint);</div><div class="line"> </div><div class="line">// 仅应用圆角特效的路径</div><div class="line">canvas.translate(0,200);</div><div class="line">CornerPathEffect cornerPathEffect = new CornerPathEffect(100);</div><div class="line">paint.setPathEffect(cornerPathEffect);</div><div class="line">canvas.drawPath(path,paint);</div><div class="line"> </div><div class="line">// 仅应用虚线特效的路径</div><div class="line">canvas.translate(0,200);</div><div class="line">DashPathEffect dashPathEffect = new DashPathEffect(new float[]&#123;2,5,10,10&#125;,0);</div><div class="line">paint.setPathEffect(dashPathEffect);</div><div class="line">canvas.drawPath(path,paint);</div><div class="line"> </div><div class="line">// 利用 ComposePathEffect 先应用圆角特效，再应用虚线特效</div><div class="line">canvas.translate(0,200);</div><div class="line">ComposePathEffect composePathEffect = new ComposePathEffect(dashPathEffect,cornerPathEffect);</div><div class="line">paint.setPathEffect(composePathEffect);</div><div class="line">canvas.drawPath(path,paint);</div><div class="line"> </div><div class="line">// 利用 SumPathEffect，分别将圆角特效应用于原始路径，然后将生成的两条特效路径合并</div><div class="line">canvas.translate(0,200);</div><div class="line">paint.setStyle(Paint.Style.STROKE);</div><div class="line">SumPathEffect sumPathEffect = new SumPathEffect(cornerPathEffect,dashPathEffect);</div><div class="line">paint.setPathEffect(sumPathEffect);</div><div class="line">canvas.drawPath(path,paint);</div></pre></td></tr></table></figure>
<h4 id="6-1-2-字体相关函数"><a href="#6-1-2-字体相关函数" class="headerlink" title="6.1.2 字体相关函数"></a>6.1.2 字体相关函数</h4><p><strong>setTextSize(float textSize)</strong><br>设置文字大小</p>
<p><strong>setFakeBoldText(boolean fakeBoldText)</strong><br>设置是否为粗体文字</p>
<p><strong>setStrikeThruText(boolean strikeThruText)</strong><br>设置带有删除线效果</p>
<p><strong>setUnderlineText(boolean underlineText)</strong><br>设置下划线</p>
<p><strong>setTextAlign(Paint.Align align)</strong><br>设置开始绘图点位置</p>
<p><strong>setTextScaleX(float scaleX)</strong><br>水平拉伸设置</p>
<p><strong>setTextSkewX(float skewX)</strong><br>设置字体水平倾斜度，普通斜体字是-0.25，可见往右斜</p>
<p><strong>setTypeface(Typeface typeface)</strong><br>字体样式</p>
<p><strong>setLinearText(boolean linearText)</strong><br>设置是否打开线性文本标识；由于文本想要快速绘制出来，必然是需要提前缓存在显存中的，一般而言每个文字需要一个字节的大小来存储它（当然具体需要多少字节与编码方式有关），那如果是长篇文章，可见所需的大小可想而知。我们可以通过 setLinearText (true) 告诉 Android 我们不需要这样的文本缓存。但如果我们不用文本缓存，虽然能够省去一些内存空间，但这是以显示速度为代价的。</p>
<p>由于这个是 API 1 的函数，由于当时的 android 手机的内存大小还是很小的，所以尽量减少内存使用是每个应用的头等大事，在当时的的环境下这个函数还是很有用的。</p>
<p>但在今天，内存动不动就是 4G 以上了，文本缓存的所占的那点内存就微不足道了，没有哪个 APP 会牺牲性能来减少这点这内存占用了，所以这个函数基本没用了。</p>
<p><strong>setSubpixelText(boolean subpixelText)</strong><br>表示是否打开亚像素设置来绘制文本。亚像素的概念比较难理解，首先，我们都知道像素，比如一个 android 手机的分辨率是 1280<em>720，那就是指它的屏幕在垂直方向有 1280 个像素点，水平方向上有 720 个像素点。我们知道每个像素点都是一个独立显示一个颜色的个体。所以如果一副图片，在一个屏幕上用了 300</em>100 个相素点，而在另一个屏幕上却用了 450*150 个像素来显示。那么，请问在哪个屏幕上这张图片显示的更清晰？当然是第二个屏幕，因为它使用的像素点更多，所显示的细节更精细。</p>
<p>那么问题来了，android 设置在出厂时，设定的像素显示都是固定的几个范围：320<em>480，480</em>800，720<em>1280，1080</em>1920 等等；那么如何在同样的分辨率的显示器中增强显示清晰度呢？</p>
<p>亚像素的概念就油然而生了，亚像素就是把两个相邻的两个像素之间的距离再细分，再插入一些像素，这些通过程序加入的像素就是亚像素。在两个像素间插入的像素个数是通过程序计算出来的，一般是插入两个、三个或四个。</p>
<p>所以打开亚像素显示，是可以在增强文本显示清晰度的，但由于插入亚像素是通过程序计算而来的，所以会耗费一定的计算机性能。注意：亚像素是通过程序计算出来模拟插入的，在没有改变硬件构造的情况下，来改善屏幕分辨率大小。</p>
<p>亚像素显示，是仅在液晶显示器上使用的一种增强字体清晰度的技术。但这种技术有时会出现问题，用投影仪投射到白色墙壁上，会出出字体显示不正常的情况，而且对于老式的CRT显示器是根本不支持的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/06/Custom View/06.2 精通自定义 View 之 Paint 基本使用（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="King">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/06/Custom View/06.2 精通自定义 View 之 Paint 基本使用（二）/" itemprop="url">06.2 精通自定义 View 之 Paint 基本使用（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-06T02:00:00+08:00">
                2019-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Custom-View/" itemprop="url" rel="index">
                    <span itemprop="name">Custom View</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <meta name="referrer" content="no-referrer">

<h2 id="6-2-文字"><a href="#6-2-文字" class="headerlink" title="6.2 文字"></a>6.2 文字</h2><h4 id="6-2-1-概述"><a href="#6-2-1-概述" class="headerlink" title="6.2.1 概述"></a>6.2.1 概述</h4><h6 id="1-四线格与基线"><a href="#1-四线格与基线" class="headerlink" title="1. 四线格与基线"></a>1. 四线格与基线</h6><p>小时候，我们在刚开始学习写字母时，用的本子是四线格的，我们必须把字母按照规则写在四线格内。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-b796318147ad1ee8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在 canvas 在利用 drawText 绘制文字时，也是有规则的，这个规则就是基线！我们先来看一下什么是基线：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-ab25407ebd89fbb0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可见基线就是四线格中的第三条线。也就是说，只要基线的位置定了，那文字的位置必然是定了的！</p>
<h6 id="2-canvas-drawText"><a href="#2-canvas-drawText" class="headerlink" title="2. canvas.drawText()"></a>2. canvas.drawText()</h6><p>1）canvas.drawText() 与基线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * text:要绘制的文字</div><div class="line"> * x：绘制原点x坐标</div><div class="line"> * y：绘制原点y坐标</div><div class="line"> * paint:用来做画的画笔</div><div class="line"> */</div><div class="line">public void drawText(String text, float x, float y, Paint paint)</div></pre></td></tr></table></figure></p>
<p>上面这个构造函数是最常用的 drawText 方法，传进去一个 String 对象就能画出对应的文字。但这里有两个参数需要非常注意，表示原点坐标的 x 和 y。很多同学可能会认为，这里传进去的原点参数 (x,y) 是所在绘制文字所在矩形的左上角的点。但实际上并不是！比如，我们上面如果要画 “harvic’s blog” 这几个字，这个原点坐标应当是下图中绿色小点的位置。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-6799d753bccdd71f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>一般而言，(x,y) 所代表的位置是所画图形对应的矩形的左上角点。但在 drawText 中是非常例外的，y 所代表的是基线的位置。</p>
<p>2）示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line"> </div><div class="line">    int baseLineX = 0;</div><div class="line">    int baseLineY = 200;</div><div class="line">    </div><div class="line">    // 画基线</div><div class="line">    Paint paint = new Paint();</div><div class="line">    paint.setColor(Color.RED);</div><div class="line">    canvas.drawLine(baseLineX, baseLineY, 3000, baseLineY, paint);</div><div class="line"> </div><div class="line">    // 写文字</div><div class="line">    paint.setColor(Color.GREEN);</div><div class="line">    paint.setTextSize(120); // 以px为单位</div><div class="line">    canvas.drawText(&quot;harvic\&apos;s blog&quot;, baseLineX, baseLineY, paint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先，我们把 (0,200) 所在的这条横线画出来，所以我先画了一条线从点坐标为 (0,200) 到点坐标为 (3000,200) 的一条直线，然后利用 canvas.drawText 以 (0,200) 为原点画出文字，最终效果图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-ba0826eb929753ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>结论：</p>
<ul>
<li>drawText() 函数中的参数 y 是基线的位置。</li>
<li>一定要清楚的是，只要 x 坐标、基线位置、文字大小确定，文字的位置就是确定了。</li>
</ul>
<h6 id="3-paint-setTextAlign-函数"><a href="#3-paint-setTextAlign-函数" class="headerlink" title="3. paint.setTextAlign() 函数"></a>3. paint.setTextAlign() 函数</h6><p>在上面我们讲了，drawText() 函数中的 y 参数表示所要绘制文字的基线所在位置。从上面的例子中可以看到，绘制是从 x 坐标的右边开始的，但这并不是必然的结果。我们来看一张图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-308a568c5c7ea992.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在 drawText(text, x, y, paint) 中传进去的原点坐标 (x,y)。其中，y 表示的基线的位置。那 x 代表什么呢？从上面的例子运行结果来看，应当是文字开始绘制的地方。</p>
<p>并不是！x 代表所要绘制文字所在矩形的相对位置。相对位置就是指指定点 (x,y) 在在所要绘制矩形的位置。我们知道所绘制矩形的纵坐标是由 y 值来确定的，而相对 x 坐标的位置，只有左、中、右三个位置了。也就是所绘制矩形可能是在 x 坐标的左侧绘制，也有可能在 x 坐标的中间，也有可能在 x 坐标的右侧。而定义在 x 坐标在所绘制矩形相对位置的函数是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 其中 Align 的取值为：Panit.Align.LEFT,Paint.Align.CENTER,Paint.Align.RIGHT</div><div class="line"> */</div><div class="line">Paint::setTextAlign(Align align);</div></pre></td></tr></table></figure></p>
<p>仍然使用上面的例子，当设置不同的 Align 取值时，效果如下图所示。<br><strong>Paint.Align.LEFT：</strong><br><img src="https://upload-images.jianshu.io/upload_images/14186083-7cbb15dc7967a198.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>Paint.Align.CENTER：</strong><br><img src="https://upload-images.jianshu.io/upload_images/14186083-dcdac7faa0f2601e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>Paint.Align.RIGHT：</strong><br><img src="https://upload-images.jianshu.io/upload_images/14186083-fe138d527ea49694.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h6 id="4-注意"><a href="#4-注意" class="headerlink" title="4. 注意"></a>4. 注意</h6><p>这里需要再次强调的是：相对位置是根据所要绘制文字所在矩形来计算的。比如，只写一个大写字母 A，将其相对位置设置为 Paint.Align.CENTER。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mPaint.setTextAlign(Paint.Align.CENTER);</div><div class="line">canvas.drawText(&quot;A&quot;, baseLineX, baseLineY, mPaint);</div></pre></td></tr></table></figure></p>
<p>效果如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-e0e6bdfd3959f399.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="6-2-2-绘图四线格与-FontMetrics"><a href="#6-2-2-绘图四线格与-FontMetrics" class="headerlink" title="6.2.2 绘图四线格与 FontMetrics"></a>6.2.2 绘图四线格与 FontMetrics</h4><h6 id="1-文字的绘图四线格"><a href="#1-文字的绘图四线格" class="headerlink" title="1. 文字的绘图四线格"></a>1. 文字的绘图四线格</h6><p>除了基线以外，系统在绘制文字时还有 4 条线，分别是 ascent、descent、top、bottom，如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-f4f98522d06491b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li>ascent：系统建议的，绘制单个字符时，字符应当的最高高度所在线。</li>
<li>descent：系统建议的，绘制单个字符时，字符应当的最低高度所在线。</li>
<li>top：可绘制的最高高度所在线。</li>
<li>bottom：可绘制的最低高度所在线。</li>
</ul>
<p>我们在绘制文字时，ascent 是推荐的绘制文字的最高高度，就表示在绘制文字时，尽力要在这个最高高度以下绘制文字。descent 是推荐的绘制文字的最底高度线，同样表示是在绘制文字时尽量在这个 descent 线以上来绘制文字。而 top 线则指该文字可以绘制的最高高度线，bottom 则是表示该文字可以绘制的最低高度线。ascent、descent 是系统建议上的绘制高度，而 top、bottom 则是物理上屏幕最高、最低可以画的高度值。</p>
<h6 id="2-FontMetrics"><a href="#2-FontMetrics" class="headerlink" title="2. FontMetrics"></a>2. FontMetrics</h6><p>1）FontMetrics 概述<br>我们知道基线的位置是我们在构造 drawText() 函数时由参数 y 来决定的，那 ascent、descent、top、bottom 这些线的位置要怎么计算出来呢？</p>
<p>Android 给我们提供了一个类：FontMetrics，它里面有四个成员变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FontMetrics::ascent;</div><div class="line">FontMetrics::descent;</div><div class="line">FontMetrics::top;</div><div class="line">FontMetrics::bottom;</div></pre></td></tr></table></figure></p>
<p>他们的意义与值的计算方法分别如下：</p>
<ul>
<li>ascent = ascent 线的 y 坐标 - baseline 线的 y 坐标。</li>
<li>descent = descent 线的 y 坐标 - baseline 线的 y 坐标。</li>
<li>top = top 线的 y 坐标 - baseline 线的 y 坐标。</li>
<li>bottom = bottom 线的 y 坐标 - baseline 线的 y 坐标。</li>
</ul>
<p>我们再来看个图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-0cfad062b77303f8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>从这个图中，我们先说明两点，然后再回过头来看上面的公式：<br>1、X 轴，Y 轴的正方向走向是 X 轴向右是正方向，Y 轴向下是正方向，所以越往下 Y 坐标越大！<br>2、大家千万不要将 FontMetrics 中的 ascent、descent、top、bottom 与现实中的 ascent、descent、top、bottom 所在线混淆！这几条线是真实存在的，而 FontMetrics 中的 ascent、descent、top、bottom 这个变量的值就是用来计算这几条线的位置的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ascent = ascent线的y坐标 - baseline线的y坐标</div></pre></td></tr></table></figure></p>
<p>FontMetrics 的这几个变量的值都是以 baseline 为基准的，对于 ascent 来说，baseline 线在 ascent 线之下，所以必然 baseline 的 y 值要大于 ascent 线的 y 值，所以 ascent 变量的值是负的。</p>
<p>同理，对于 descent 而言：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">descent = descent线的y坐标 - baseline线的y坐标</div></pre></td></tr></table></figure></p>
<p>descent 线在 baseline 线之下，所以必然 descent 线的 y 坐标要大于 baseline 线的 y 坐标，所以 descent 变量的值必然是正数。</p>
<p>2）得到 Text 四线格的各线位置<br>先列出一个公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ascent 线 Y 坐标 = baseline 线 Y 坐标 + fontMetric.ascent</div></pre></td></tr></table></figure></p>
<p>推算过程如下：</p>
<p>因为 ascent 线的 Y 坐标等于 baseline 线的 Y 坐标减去从 baseline 线到 ascent 线的这段距离。也就是：(|fontMetric.ascent|表示取绝对值)。<br>ascent 线 Y 坐标 = baseline 线 Y 坐标 - |fontMetric.ascent|;<br>又因为 fontMetric.ascent 是负值，所以：<br>ascent 线 Y 坐标 = baseline 线 Y 坐标 - |fontMetric.ascent|;<br>ascent 线 Y 坐标 = baseline 线 Y 坐标 - (-fontMetric.ascent);<br>ascent 线 Y 坐标 = baseline 线 Y 坐标 + fontMetric.ascent;</p>
<p>这就是整个推算过程，没什么难度，同理可以得到：</p>
<ul>
<li>ascent 线 Y 坐标 = baseline 线的 y 坐标 + fontMetric.ascent；</li>
<li>descent 线 Y 坐标 = baseline 线的 y 坐标 + fontMetric.descent；</li>
<li>top 线 Y 坐标 = baseline 线的 y 坐标 + fontMetric.top；</li>
<li>bottom 线 Y 坐标 = baseline 线的 y 坐标 + fontMetric.bottom；</li>
</ul>
<p>3）获取 FontMetrics 对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Paint paint = new Paint();</div><div class="line">Paint.FontMetrics fm = paint.getFontMetrics();</div><div class="line">Paint.FontMetricsInt fmInt = paint.getFontMetricsInt();</div></pre></td></tr></table></figure></p>
<p>从这里可以看到，通过 paint.getFontMetrics() 得到对应的 FontMetrics 对象。这里还有另外一个 FontMetrics 同样的类叫做 FontMetricsInt，它的意义与 FontMetrics 完全相同，只是得到的值的类型不一样而已，FontMetricsInt 中的四个成员变量的值都是 Int 类型，而 FontMetrics 得到的四个成员变量的值则都是 float 类型的。</p>
<p>4）示例：计算 Text 四线格位置</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-dbe98aa14347e5e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Paint.FontMetrics mFm;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setTextSize(120);</div><div class="line">        mPaint.setTextAlign(Paint.Align.LEFT);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        int baseLineX = 0;</div><div class="line">        int baseLineY = 200;</div><div class="line"></div><div class="line">        // 写文字</div><div class="line">        canvas.drawText(&quot;harvic\&apos;s blog&quot;, baseLineX, baseLineY, mPaint);</div><div class="line">        // 计算各线在位置</div><div class="line">        mFm = mPaint.getFontMetrics();</div><div class="line">        float ascent = baseLineY + mFm.ascent;</div><div class="line">        float descent = baseLineY + mFm.descent;</div><div class="line">        float top = baseLineY + mFm.top;</div><div class="line">        float bottom = baseLineY + mFm.bottom;</div><div class="line">        // 画基线</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        canvas.drawLine(baseLineX, baseLineY, 3000, baseLineY, mPaint);</div><div class="line">        // 画 top</div><div class="line">        mPaint.setColor(Color.BLUE);</div><div class="line">        canvas.drawLine(baseLineX, top, 3000, top, mPaint);</div><div class="line">        // 画 ascent</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        canvas.drawLine(baseLineX, ascent, 3000, ascent, mPaint);</div><div class="line">        // 画 descent</div><div class="line">        mPaint.setColor(Color.YELLOW);</div><div class="line">        canvas.drawLine(baseLineX, descent, 3000, descent, mPaint);</div><div class="line">        // 画 bottom</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        canvas.drawLine(baseLineX, bottom, 3000, bottom, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6-2-3-常用函数"><a href="#6-2-3-常用函数" class="headerlink" title="6.2.3 常用函数"></a>6.2.3 常用函数</h4><h6 id="1-字符串所占高度和宽度"><a href="#1-字符串所占高度和宽度" class="headerlink" title="1. 字符串所占高度和宽度"></a>1. 字符串所占高度和宽度</h6><p>1）高度<br>字符串所占高度很容易得到，直接用 bottom 线所在位置的 Y 坐标减去 top 线所在位置的 Y 坐标就是字符串所占的高度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mFm = mPaint.getFontMetricsInt();</div><div class="line">int top = baseLineY + fm.top;</div><div class="line">int bottom = baseLineY + fm.bottom;</div><div class="line">// 所占高度</div><div class="line">int height = bottom - top;</div></pre></td></tr></table></figure></p>
<p>2）、宽度<br>宽度是非常容易得到的，直接利用下面的函数就可以得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int width = mPaint.measureText(&quot;harvic&apos;s blog&quot;);</div></pre></td></tr></table></figure></p>
<h6 id="2-最小矩形"><a href="#2-最小矩形" class="headerlink" title="2. 最小矩形"></a>2. 最小矩形</h6><p>1）概述<br>要获取最小矩形，也是通过系统函数来获取的，函数及意义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 获取指定字符串所对应的最小矩形，以（0，0）点所在位置为基线</div><div class="line"> * @param text  要测量最小矩形的字符串</div><div class="line"> * @param start 要测量起始字符在字符串中的索引</div><div class="line"> * @param end   所要测量的字符的长度</div><div class="line"> * @param bounds 接收测量结果</div><div class="line"> */</div><div class="line">public void getTextBounds(String text, int start, int end, Rect bounds);</div></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">String text = &quot;harvic\&apos;s blog&quot;;</div><div class="line">Paint paint = new Paint();</div><div class="line">// 设置paint</div><div class="line">paint.setTextSize(120); </div><div class="line"> </div><div class="line">Rect minRect = new Rect();</div><div class="line">paint.getTextBounds(text,0,text.length(),minRect);</div><div class="line">Log.e(&quot;xian&quot;,minRect.toShortString());</div></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-65a904e02b3acde3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以看到这个矩形的左上角位置为（8,-90），右下角的位置为（654,25）；大家可能会有疑问，为什么左上角的 Y 坐标是个负数？从代码中，我们也可以看到，我们并没有给 getTextBounds() 传递基线位置。那它就是以（0,0）为基线来得到这个最小矩形的！所以这个最小矩形的位置就是以（0,0）为基线的结果！</p>
<p>2）得到最小矩形的实际位置<br>我们先来看一个原理图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-436e2f53ad881b18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在上面这个图中，我们将黑色矩形平行下移距离Y（黄色线依照的是基线的位置），那么平移后的左上角点的 y 坐标就是 y2 = y1 + Y。</p>
<p>同样的道理，由于 paint.getTextBounds() 得到最小矩形的基线是 y = 0；那我们直接将这个矩形移动 baseline 的距离就可以得到这个矩形实际应当在的位置了。</p>
<p>所以矩形应当所在实际位置的坐标是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Rect minRect = new Rect();</div><div class="line">paint.getTextBounds(text,0,text.length(),minRect);</div><div class="line">// 最小矩形，实际 top 位置</div><div class="line">int minTop = bounds.top + baselineY;</div><div class="line">// 最小矩形，实际 bottom 位置</div><div class="line">int minBottom = bounds.bottom + baselineY;</div></pre></td></tr></table></figure></p>
<p>3）完整的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line"></div><div class="line">    String text = &quot;harvic\&apos;s blog&quot;;</div><div class="line">    int baseLineY = 200;</div><div class="line">    int baseLineX = 0 ;</div><div class="line"></div><div class="line">    // 设置paint</div><div class="line">    Paint paint = new Paint();</div><div class="line">    paint.setTextSize(120); //以px为单位</div><div class="line">    paint.setTextAlign(Paint.Align.LEFT);</div><div class="line"></div><div class="line">    // 画text所占的区域</div><div class="line">    Paint.FontMetricsInt fm = paint.getFontMetricsInt();</div><div class="line">    int top = baseLineY + fm.top;</div><div class="line">    int bottom = baseLineY + fm.bottom;</div><div class="line">    int width = (int)paint.measureText(text);</div><div class="line">    Rect rect = new Rect(baseLineX,top,baseLineX+width,bottom);</div><div class="line"></div><div class="line">    paint.setColor(Color.GREEN);</div><div class="line">    canvas.drawRect(rect,paint);</div><div class="line"></div><div class="line">    // 画最小矩形</div><div class="line">    Rect minRect = new Rect();</div><div class="line">    paint.getTextBounds(text,0,text.length(),minRect);</div><div class="line">    minRect.top = baseLineY + minRect.top;</div><div class="line">    minRect.bottom = baseLineY + minRect.bottom;</div><div class="line">    paint.setColor(Color.RED);</div><div class="line">    canvas.drawRect(minRect,paint);</div><div class="line"></div><div class="line">    // 写文字</div><div class="line">    paint.setColor(Color.BLACK);</div><div class="line">    canvas.drawText(text, baseLineX, baseLineY, paint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-ebb6cef9d9cbf11e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="6-2-4-示例：定点写字"><a href="#6-2-4-示例：定点写字" class="headerlink" title="6.2.4 示例：定点写字"></a>6.2.4 示例：定点写字</h4><h6 id="1-给定左上顶点绘图"><a href="#1-给定左上顶点绘图" class="headerlink" title="1. 给定左上顶点绘图"></a>1. 给定左上顶点绘图</h6><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ea033f084880c022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在这个图中，我们给定左上角的位置，即 (left,top)；我们知道要画文字，drawText() 中传进去的 Y 坐标是基线的位置，所以我们就必须根据 top 的位置计算出 baseline 的位置。</p>
<p>我们来看一个公式：<br>FontMetrics.top = top - baseline;</p>
<p>所以：<br>baseline = top - FontMetrics.top;</p>
<p>因为 FontMetrics.top 是可以得到的，又因为我们的 top 坐标是给定的，所以通过这个公式就能得到 baseline 的位置了。</p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Paint.FontMetrics mFm;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setTextSize(120);</div><div class="line">        mPaint.setTextAlign(Paint.Align.LEFT);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        mFm = mPaint.getFontMetrics();</div><div class="line">        float top = 0;</div><div class="line">        int baseLineX = 0;</div><div class="line">        float baseLineY = top - mFm.top;</div><div class="line"></div><div class="line">        // 写文字</div><div class="line">        canvas.drawText(&quot;harvic\&apos;s blog&quot;, 0, baseLineY, mPaint);</div><div class="line"></div><div class="line">        // 画基线</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        canvas.drawLine(baseLineX, baseLineY, 3000, baseLineY, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h6 id="2-给定中间线位置绘图"><a href="#2-给定中间线位置绘图" class="headerlink" title="2. 给定中间线位置绘图"></a>2. 给定中间线位置绘图</h6><p>先来看一张图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-1072d0900b738e32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在这个图中，总共有四条线：top 线、bottom 线、baseline 和 center线。其中 center 线正是在 top 线和 bottom 线的正中间。</p>
<p>为了方便推导公式，另外标了三个距离 A、B、C。显然，距离 A 和距离 C 是相等的，都等于文字所在矩形高度以的一半，即 A = C = (bottom - top)/2。</p>
<p>又因为：<br>bottom = baseline + FontMetrics.bottom<br>top = baseline + FontMetrics.top<br>将这两个公式代入上面的公式，就可得到：<br>A = C = (FontMetrics.bottom - FontMetrics.top)/2</p>
<p>而距离 B 则表示 center 线到 baseline 的距离。很显然距离<br>B = C - (bottom - baseline)</p>
<p>又因为：<br>FontMetrics.bottom = bottom - baseline<br>C = A<br>所以：<br>B = A - FontMetrics.bottom</p>
<p>从而有：<br>baseline = center + B = center + A - FontMetrics.bottom = center + (FontMetrics.bottom - FontMetrics.top)/2 - FontMetrics.bottom</p>
<p>根据上面的推导过程，我们最终可知，当给定中间线 center 位置以后，baseline 的位置为：<br>baseline = center + (FontMetrics.bottom - FontMetrics.top)/2 - FontMetrics.bottom</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/06/Custom View/06.1 精通自定义 View 之 Paint 基本使用（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="King">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/06/Custom View/06.1 精通自定义 View 之 Paint 基本使用（一）/" itemprop="url">06.1 精通自定义 View 之 Paint 基本使用（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-06T01:00:00+08:00">
                2019-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Custom-View/" itemprop="url" rel="index">
                    <span itemprop="name">Custom View</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <meta name="referrer" content="no-referrer">

<p><a href="https://www.jianshu.com/p/7a832e074b69" target="_blank" rel="external">参考文档：硬件加速</a></p>
<h2 id="6-1-硬件加速"><a href="#6-1-硬件加速" class="headerlink" title="6.1 硬件加速"></a>6.1 硬件加速</h2><h4 id="6-1-1-本质和原理"><a href="#6-1-1-本质和原理" class="headerlink" title="6.1.1 本质和原理"></a>6.1.1 本质和原理</h4><h6 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h6><p>所谓硬件加速，指的是把某些计算工作交给专门的硬件来做，而不是和普通的计算工作一样交给 CPU 来处理。这样不仅减轻了 CPU 的压力，而且由于有了「专人」的处理，这份计算工作的速度也被加快了。这就是「硬件加速」。</p>
<p>而对于 Android 来说，硬件加速有它专属的意思：在 Android 里，硬件加速专指把 View 中绘制的计算工作交给 GPU 来处理。进一步地再明确一下，这个「绘制的计算工作」指的就是把绘制方法中的那些 Canvas.drawXXX() 变成实际的像素这件事。</p>
<h6 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h6><p>在硬件加速关闭的时候，Canvas 绘制的工作方式是：把要绘制的内容写进一个 Bitmap，然后在之后的渲染过程中，这个 Bitmap 的像素内容被直接用于渲染到屏幕。这种绘制方式的主要计算工作在于把绘制操作转换为像素的过程（例如由一句 Canvas.drawCircle() 来获得一个具体的圆的像素信息），这个过程的计算是由 CPU 来完成的。大致就像这样：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2789715-2e12c05c18113d57.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/839/format/webp" alt=""></p>
<p>而开启硬件加速后，Canvas 的工作方式改变了：它把绘制的内容转为 GPU 的操作保存下来，然后交给 GPU 来完成显示工作。大致过程：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2789715-38ff7dae4e1cdd37.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/839/format/webp" alt=""></p>
<p>从上图可以看出，开启硬件加速后，绘制的计算工作有 CPU 交给 GPU，不过这怎么就能起到加速作用，让绘制变快了呢？</p>
<ul>
<li>本来CPU的工作，分摊一部分给GPU，自然可以提高效率；</li>
<li>相对于CPU来说，GPU自身的设计本来就对于很多常见类型内容的计算(例如简单的圆形、方形)具有优势；</li>
<li>由于绘制流程的不同；硬件加速在界面内容发生重绘的时候绘制流程可以得到优化，避免一些重复操作，从而大幅提升绘制效率。</li>
</ul>
<p>关于第三点，它的原理大致说一下：</p>
<p>关闭硬件加速时，绘制内容会被 CPU 转为实际的像素，然后直接渲染到屏幕，具体来说，这个 [实际的像素]，是由 bitmap 承载的，在界面的某个 View 由于内容发生改变而调用 invalidat() 方法时，如果没有开启硬件加速，为了正确计算 bitmap 的像素，这个 View 的父 View、父 View 的父 View 乃至一直向上知道最顶级的 View，以及所有和它相交的 View，都需要被调用 invalidate() 来重绘，一个View的改变使得大半个界面甚至整个界面重绘一遍，这个工作量是非常大的。</p>
<p>而在开启硬件加速时，绘制的内容会被转换成 GPU 的操作保存下来(承载的形式成为 displaylist，对应的类也叫作 DisplayList)，再转交给 GPU。由于所有绘制的内容都没有变成最终的像素，所以它们之间是相互独立的，那么在界面内容发生改变时，只需把发生了改变的 View 调用 invalidate() 方法以更新它所对应的 GPU 就好，至于它的父 View 和兄弟 View，只需要保持原样，那么这个工作量就很小了。</p>
<p>正是由于上面的原因，硬件加速不仅是由于 GPU 的引入提高效率，而且因为绘制机制的改变，而极大的提高了界面内容改变时的刷新效率。</p>
<p>总结：<strong>用了 GPU，绘制更快；绘制机制的改变，导致界面内容改变时的刷新效率极大提高。</strong></p>
<h4 id="6-1-2-在-Android-中的限制"><a href="#6-1-2-在-Android-中的限制" class="headerlink" title="6.1.2 在 Android 中的限制"></a>6.1.2 在 Android 中的限制</h4><p>可事实就是，硬件加速不止有好处，也有限制：收到 GPU 绘制方式的限制，Canvas 的有些方法在硬件加速开启时会失效或者无法正常工作，比如：开启硬件加速，clipPath() 在 API 18 及以上系统中才有效，具体的 API 限制和 API 版本的关系如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2789715-ea809b43011e9e11.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/783/format/webp" alt=""></p>
<p>所以，如果你对自定义控件有自定义绘制的内容，最好参照一下表格，确保你的绘制操作可以正确地在所有用户手机中正常显示，而不是只在你最新 Android 系统的 Nexus 或 Pixel 里测试一遍没问题就发布。那就小心被祭天了。</p>
<h4 id="6-1-3-禁用-GPU-硬件加速的方法"><a href="#6-1-3-禁用-GPU-硬件加速的方法" class="headerlink" title="6.1.3 禁用 GPU 硬件加速的方法"></a>6.1.3 禁用 GPU 硬件加速的方法</h4><p>1）在 AndroidManifest.xml 文件中为 application 标签添加如下属性，即可为整个应用程序开启/关闭硬件加速。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;application android:hardwareAccelerated=&quot;true&quot; ...&gt;</div></pre></td></tr></table></figure></p>
<p>2）在 AndroidManifest.xml 文件中为 activity 标签下使用 hardwareAccelerated 属性开启/关闭硬件加速。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;activity android:hardwareAccelerated=&quot;false&quot; ...&gt;</div></pre></td></tr></table></figure></p>
<p>3）在 Window 层级上使用如下代码开启硬件加速（Window 层级不支持关闭硬件加速）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getWindow().setFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);</div></pre></td></tr></table></figure></p>
<p>4）在 View 层级上使用如下代码关闭硬件加速(在 View 层级上不支持开启硬件加速)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setLayerType(LAYER_TYPE_SOFTWARE,null);</div></pre></td></tr></table></figure></p>
<p>或者在layout xml中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:layerType=&quot;software&quot; &gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>
<p>事实上，view.setLayerType(LAYER_TYPE_SOFTWARE, null) 这个方法的作用并不是关闭硬件加速，只是当它的参数为 LAYER_TYPE_SOFTWARE 的时候，可以顺便把硬件加速关掉而已；并且除了这个方法外，Android 并没有提供专门的 View 级别的硬件加速开关，所以它就顺便成了一个开关硬件加速的方法。</p>
<ul>
<li>参数为 LAYER_TYPE_SOFTWARE 时，使用软件来绘制 View Layer，绘制到一个 Bitmap，并顺便关闭硬件加速；</li>
<li>参数为 LAYER_TYPE_HARDWARE 时，使用 GPU 来绘制 View Layer，绘制到一个 OpenGL texture (如果硬件加速关闭，那么行为和 LAYER_TYPE_SOFTWARE 一致)；</li>
<li>参数为 LAYER_TYPE_NONE 时，关闭 View Layer。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/05/Custom View/05.2 精通自定义 View 之动画进阶（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="King">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/05/Custom View/05.2 精通自定义 View 之动画进阶（二）/" itemprop="url">05.2 精通自定义 View 之动画进阶（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-05T02:00:00+08:00">
                2019-07-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Custom-View/" itemprop="url" rel="index">
                    <span itemprop="name">Custom View</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <meta name="referrer" content="no-referrer">

<h2 id="5-2-SVG-动画"><a href="#5-2-SVG-动画" class="headerlink" title="5.2 SVG 动画"></a>5.2 SVG 动画</h2><h4 id="5-2-1-概述"><a href="#5-2-1-概述" class="headerlink" title="5.2.1 概述"></a>5.2.1 概述</h4><p>SVG 全称是 Scalable Vector Graphics（可缩放矢量图形），即 SVG 是矢量图。与矢量图对应的是位图，Bitmap 就是位图，它由一个个像素点组成，当图片放大到一定大小时，就会出现马赛克现象，Photoshop 就是常用的位图处理软件。而矢量图则由一个个点组成，经过数学计算利用直线和曲线绘制而成，无论如何放大，都不会出现马赛克现象，Illustrator 就是常用的矢量图绘图软件。</p>
<p>SVG 与 Bitmap 相比有以下好处：</p>
<ul>
<li>SVG 使用 XML 格式定义图形，可被非常多的工具读取和修改。</li>
<li>SVG 由点来存储，由计算机根据点信息绘图，不会失真，无须根据分辨率适配多套图标。</li>
<li>SVG 的占用空间明显比 Bitmap 小。如 500px X 500px 的图像，转成 SVG 后占用的空间大小是 20KB，而 PNG 图片则需要 732KB 的空间。</li>
<li>SVG 可以转换为 Path 路径，与 Path 动画相结合，可以形成丰富的动画。</li>
</ul>
<p>对于 Android 5.0 以下的机型，可以通过引入 com.android.support:appcompat-v7:23.4.0 及以上版本进行支持。</p>
<p>Android 并没有对原生的 SVG 图像语法进行支持，而是以一种简化的方式对 SVG 进行兼容，也就是通过使用它的 path 标签，几乎可以实现 SVG 中的其他所有标签。这些东西可以通过工具来完成。</p>
<h4 id="5-2-2-vector-标签与图像显示"><a href="#5-2-2-vector-标签与图像显示" class="headerlink" title="5.2.2 vector 标签与图像显示"></a>5.2.2 vector 标签与图像显示</h4><p>res/drawable/svg.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:width=&quot;200dp&quot;</div><div class="line">    android:height=&quot;100dp&quot;</div><div class="line">    android:viewportWidth=&quot;100&quot;</div><div class="line">    android:viewportHeight=&quot;50&quot;&gt;</div><div class="line">    &lt;path</div><div class="line">        android:name=&quot;bar&quot;</div><div class="line">        android:pathData=&quot;M50,23 L100,23&quot;</div><div class="line">        android:strokeWidth=&quot;2&quot;</div><div class="line">        android:strokeColor=&quot;@color/colorAccent&quot;/&gt;</div><div class="line">&lt;/vector&gt;</div></pre></td></tr></table></figure></p>
<p>效果图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-c19a24bc41592925.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li>vector 标签：指定画布大小，上图蓝框区域。</li>
<li>path 标签：绘制路径，对应上图中的红色线段。</li>
<li>width &amp; height 属性：表示该 SVG 图形的具体大小。</li>
<li>viewportWidth &amp; viewportHeight 属性：表示 SVG 图形划分的比例。</li>
</ul>
<p>width &amp; height 类似于指定画布的大小，而 viewportWidth &amp; viewportHeight 则是指将画布的宽、高分为多少个点，而 Path 中的点坐标都是以 viewportWidth &amp; viewportHeight 的点数为坐标的，而不是 dp 值。此处将宽度 200dp 分为 100 个点，在高度 100dp 分为 50 个点，每个点有 2dp。而 path 中字母 M 表示 moveTo，字母 L 表示 lineTo，所以，这里代表从（50, 23) 到点 (100, 23) 画了一条线段。</p>
<h6 id="1-path-标签"><a href="#1-path-标签" class="headerlink" title="1. path 标签"></a>1. path 标签</h6><p>1）常用属性</p>
<ul>
<li>android:name：声明一个标记，类似于 ID。</li>
<li>android:pathData：对 SVG 矢量图的描述。</li>
<li>android:strokeWidth：画笔的宽度</li>
<li>android:fillColor：填充颜色。</li>
<li>android:fillAlpha：填充颜色的透明度。</li>
<li>android:strokeColor：描边颜色。</li>
<li>android:strokeWidth：描边宽度。</li>
<li>android:strokeAlpha：描边透明度。</li>
<li>android:strokeLineJoin：用于指定折线拐角形状，取值有 miter（结合处为锐角）、round（结合处为圆弧）、bevel（结合处为直线）。</li>
<li>android:strokeLineCap：画出线条的终点的形状（线帽），取值有 butt（无线帽）、round（圆形线帽）、square（方形线帽）</li>
<li>android:strokeMiterLimit：设置斜角的上限。当 strokeLineJoin 为 “round” 或 “bevel” 时，该属性无效。</li>
</ul>
<p>2）android:trimPathStart 属性<br>该属性用于指定路径从哪里开始，取值为 0~1，表示路径开始位置的百分比。取值为 0 时，表示从头开始；取值为 1 时，整条路径不可见。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;path</div><div class="line">    android:name=&quot;bar&quot;</div><div class="line">    android:pathData=&quot;M50,23 L100,23&quot;</div><div class="line">    android:strokeWidth=&quot;2&quot;</div><div class="line">    android:trimPathStart=&quot;0.5&quot;</div><div class="line">    android:strokeColor=&quot;@color/colorAccent&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-343a12e0dc24f75c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>灰色部分代表的是被删除的部分，实际上是不会显示出来的，这里只是为了展示效果，下同。</p>
<p>3）android:trimPathEnd 属性<br>该属性用于指定路径的结束位置，取值为 0~1，表是路径结束位置的百分比。取值为 1 时，路径正常结束；取值为 0 时，表示从开始位置就已经结束了，即整条路径不可见。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;path</div><div class="line">    android:name=&quot;bar&quot;</div><div class="line">    android:pathData=&quot;M50,23 L100,23&quot;</div><div class="line">    android:strokeWidth=&quot;2&quot;</div><div class="line">    android:trimPathEnd=&quot;0.8&quot;</div><div class="line">    android:strokeColor=&quot;@color/colorAccent&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-a913b917f9134edd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>4）android:trimPathOffset 属性<br>该属性用于指定路径的位移距离，取值 0~1。取值为 0 时，不位移；当取值 为 1 时，位移整条路径的长度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;path</div><div class="line">    android:name=&quot;bar&quot;</div><div class="line">    android:pathData=&quot;M50,23 L100,23&quot;</div><div class="line">    android:strokeWidth=&quot;2&quot;</div><div class="line">    android:trimPathStart=&quot;0.2&quot;</div><div class="line">    android:trimPathEnd=&quot;0.4&quot;</div><div class="line">    android:trimPathOffset=&quot;0.6&quot;</div><div class="line">    android:strokeColor=&quot;@color/colorAccent&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-b3fd2fce5e592895.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>5）android:pathData 属性<br>指定 SVG 图像的显示内容。</p>
<ul>
<li>M = moveTo(M X,Y)：将画笔移动到指定的坐标位置。</li>
<li>L = lineTo(L X,Y)：画直线到指定的坐标位置。</li>
<li>H = horizontal lineTo(H X)：画水平线到指定的 X 坐标位置。</li>
<li>V = vertical lineTo(V Y)：画垂直线到指定的 Y 坐标位置。</li>
<li>C = curveTo(C X1,Y1,X2,Y2,ENDX,ENDY)：三阶贝济埃曲线。</li>
<li>S = smooth curveTo(S X2,Y2,ENDX,ENDY)：三阶贝济埃曲线。S 指令会将上一条指令的终点作为这条指令的起始点。</li>
<li>Q = quadratic Bezier curve(Q X,Y,ENDX,ENDY)：二阶贝济埃曲线。</li>
<li>T = smooth quadratic Bezier curveTo(T ENDX,ENDY)：映射前面路径后的终点。</li>
<li>A = elliptical Arc(A RX,RY,XROTATION,FLAG1,FLAG2,X,Y)：弧线。</li>
<li>Z = closePath()：关闭路径。</li>
</ul>
<p>使用上面的指令时，需要注意的几点：</p>
<ul>
<li>坐标轴以（0,0）位中心，X轴水平向右，Y轴水平向下。</li>
<li>所有指令大小写均可，大写绝对定位，参照全局坐标系，小写相对定位，参照父容器坐标系。</li>
<li>指令和数据间的空格可以无视。</li>
<li>同一指令出现多次可以用一个。</li>
</ul>
<h6 id="2-group-标签"><a href="#2-group-标签" class="headerlink" title="2. group 标签"></a>2. group 标签</h6><p>group 标签用于定义一系列路径或者将 path 标签分组。具有以下常用属性。</p>
<ul>
<li>android:name：组的名称，用于与动画相关联。</li>
<li>android:rotation：指定该组图像的旋转度数。</li>
<li>android:pivotX：定义缩放和旋转该组时的 X 参考点。</li>
<li>android:pivotY：定义缩放和旋转该组时的 Y 参考点。</li>
<li>android:scaleX：指定该组 X 轴缩放大小。</li>
<li>android:scaleY：指定该组 Y 轴缩放大小。</li>
<li>android:translateX：指定该组沿 X 轴平移的距离。</li>
<li>android:translateY：指定该组沿 Y 轴平移的距离。</li>
</ul>
<p>示例：围绕画布中心旋转 90 度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:width=&quot;200dp&quot;</div><div class="line">    android:height=&quot;100dp&quot;</div><div class="line">    android:viewportWidth=&quot;100&quot;</div><div class="line">    android:viewportHeight=&quot;50&quot;&gt;</div><div class="line">    &lt;group</div><div class="line">        android:rotation=&quot;90&quot;</div><div class="line">        android:pivotX=&quot;50&quot;</div><div class="line">        android:pivotY=&quot;25&quot;&gt;</div><div class="line">        &lt;path</div><div class="line">            android:name=&quot;bar&quot;</div><div class="line">            android:pathData=&quot;M50,23 L100,23&quot;</div><div class="line">            android:strokeWidth=&quot;2&quot;</div><div class="line">            android:strokeColor=&quot;@color/colorAccent&quot;/&gt;</div><div class="line">    &lt;/group&gt;</div><div class="line">&lt;/vector&gt;</div></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-574df53f3790cc98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h6 id="3-制作-SVG-图像"><a href="#3-制作-SVG-图像" class="headerlink" title="3. 制作 SVG 图像"></a>3. 制作 SVG 图像</h6><p>方法一：设计软件<br>如果有绘图基础，可以直接使用 Illustrator 或在线 SVG 工具制作 SVG 图像（如 <a href="http://editor.method.ac/），或者通过" target="_blank" rel="external">http://editor.method.ac/），或者通过</a> SVG 源文件下载网站下载后进行编辑。</p>
<p>方法二：Iconfont<br>有很多 Iconfont 开源网站，比如国内的阿里巴巴矢量图库，地址为 <a href="http://www.iconfont.cn/。" target="_blank" rel="external">http://www.iconfont.cn/。</a></p>
<h6 id="4-在-Android-中引入-SVG-图像"><a href="#4-在-Android-中引入-SVG-图像" class="headerlink" title="4. 在 Android 中引入 SVG 图像"></a>4. 在 Android 中引入 SVG 图像</h6><p>在 Android 中是不支持 SVG 图像解析的，我们必须将 SVG 图像转换为 vector 标签描述，这里同样有两种方法。</p>
<p>方法一：<a href="http://inloop.github.io/svg2android/" target="_blank" rel="external">在线转换</a>。<br>This tool has been deprecated. Use official <a href="https://developer.android.com/studio/write/vector-asset-studio#svg" target="_blank" rel="external"><strong>Vector Asset Studio</strong></a> instead.</p>
<p>方法二：Vector Asset Studio<br>Android Studio 2.0 及以上版本中支持创建 Vector 文件，如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-9ff6527094fa10b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-818c4a056b161b50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h6 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h6><p>1）引入兼容包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">compile &apos;com.android.support:appcompat-v7:23.4.0&apos;</div><div class="line">// 或使用 androidx</div><div class="line">implementation &apos;androidx.appcompat:appcompat:1.0.2&apos;</div></pre></td></tr></table></figure></p>
<p>在项目的 build.gradle 脚本中添加对 Vector 兼容性的支持。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    defaultConfig &#123;</div><div class="line">        vectorDrawables.useSupportLibrary = true</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2）生成 Vector 图像<br>使用前面例子中的一条横线的 Vector 图像（src/drawable/svg.xml）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:width=&quot;200dp&quot;</div><div class="line">    android:height=&quot;100dp&quot;</div><div class="line">    android:viewportWidth=&quot;100&quot;</div><div class="line">    android:viewportHeight=&quot;50&quot;&gt;</div><div class="line">    &lt;path</div><div class="line">        android:name=&quot;bar&quot;</div><div class="line">        android:pathData=&quot;M50,23 L100,23&quot;</div><div class="line">        android:strokeWidth=&quot;2&quot;</div><div class="line">        android:strokeColor=&quot;@color/colorAccent&quot;/&gt;</div><div class="line">&lt;/vector&gt;</div></pre></td></tr></table></figure></p>
<p>3）在 ImageView、ImageButton 中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;ImageView</div><div class="line">    android:id=&quot;@+id/iv&quot;</div><div class="line">    android:layout_width=&quot;wrap_content&quot;</div><div class="line">    android:layout_height=&quot;wrap_content&quot;</div><div class="line">    app:srcCompat=&quot;@drawable/svg&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>在代码中设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ImageView iv = findViewById(R.id.iv);</div><div class="line">iv.setImageResource(R.drawable.svg);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>本人测试使用 android:background=”@drawable/svg” 也是正常的。测试机型 Pixel XL，Android 7.1.2。</p>
</blockquote>
<p>4）在 Button、RadioButton 中使用<br>Button 并不能直接通过 app:srcCompat 属性来使用 Vector 图像，而需要通过 selector 标签来使用（selector_svg.xml）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</div><div class="line">    &lt;item android:drawable=&quot;@drawable/svg&quot; android:state_pressed=&quot;true&quot;/&gt;</div><div class="line">    &lt;item android:drawable=&quot;@drawable/svg&quot;/&gt;</div><div class="line">&lt;/selector&gt;</div></pre></td></tr></table></figure></p>
<p>如果到这里并不能直接运行，需要把下面这段代码放在 Activity 的前面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line">    static &#123;</div><div class="line">        AppCompatDelegate.setCompatVectorFromResourcesEnabled(true);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>本人测试可以直接使用 android:background=”@drawable/svg” 并且不需要在 Activity 中加入上述代码 即可正常运行。测试机型 Pixel XL，Android 7.1.2。</p>
</blockquote>
<h4 id="5-2-3-动态-Vector"><a href="#5-2-3-动态-Vector" class="headerlink" title="5.2.3 动态 Vector"></a>5.2.3 动态 Vector</h4><p>实现 Vector 动画，步骤如下：<br>1）使用上述 drawable/svg.xml<br>2）创建 animator/anim_trim_start.xml 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:propertyName=&quot;trimPathStart&quot;</div><div class="line">    android:valueFrom=&quot;0&quot;</div><div class="line">    android:valueTo=&quot;1&quot;</div><div class="line">    android:duration=&quot;2000&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>3）关联 Vector &amp; Animator。drawable/animated_vector.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;animated-vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:drawable=&quot;@drawable/svg&quot;&gt;</div><div class="line">    &lt;target</div><div class="line">        android:animation=&quot;@animator/anim_trim_start&quot;</div><div class="line">        android:name=&quot;bar&quot;/&gt;</div><div class="line">&lt;/animated-vector&gt;</div></pre></td></tr></table></figure></p>
<p>4）最后在代码中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        final ImageView imageView = findViewById(R.id.iv);</div><div class="line">        AnimatedVectorDrawableCompat compat = AnimatedVectorDrawableCompat.create(</div><div class="line">                MainActivity.this, R.drawable.animated_vector);</div><div class="line">        imageView.setImageDrawable(compat);</div><div class="line"></div><div class="line"></div><div class="line">        findViewById(R.id.btn).setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                ((Animatable) imageView.getDrawable()).start();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>效果图如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14186083-07e5d6f4bfb689d8.gif?imageMogr2/auto-orient/strip" alt=""></p>
<h4 id="5-2-4-示例：输入搜索动画"><a href="#5-2-4-示例：输入搜索动画" class="headerlink" title="5.2.4 示例：输入搜索动画"></a>5.2.4 示例：输入搜索动画</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a5ed5dd59e09fc2c.gif?imageMogr2/auto-orient/strip" alt=""></p>
<h6 id="1-准备-SVG-图像"><a href="#1-准备-SVG-图像" class="headerlink" title="1. 准备 SVG 图像"></a>1. 准备 SVG 图像</h6><p>res/drawable/svg.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:width=&quot;150dp&quot;</div><div class="line">    android:height=&quot;24dp&quot;</div><div class="line">    android:viewportWidth=&quot;150&quot;</div><div class="line">    android:viewportHeight=&quot;24&quot;&gt;</div><div class="line">    &lt;!-- 搜索图形 --&gt;</div><div class="line">    &lt;path</div><div class="line">        android:name=&quot;search&quot;</div><div class="line">        android:pathData=&quot;M141,17 A9,9 0 1,1 142,16 L149,23&quot;</div><div class="line">        android:strokeWidth=&quot;2&quot;</div><div class="line">        android:strokeColor=&quot;@color/colorAccent&quot;/&gt;</div><div class="line">    &lt;path</div><div class="line">        android:name=&quot;bar&quot;</div><div class="line">        android:trimPathStart=&quot;1&quot;</div><div class="line">        android:pathData=&quot;M0,23 L149,23&quot;</div><div class="line">        android:strokeWidth=&quot;2&quot;</div><div class="line">        android:strokeColor=&quot;@color/colorAccent&quot;/&gt;</div><div class="line">&lt;/vector&gt;</div></pre></td></tr></table></figure></p>
<h6 id="2-准备动画"><a href="#2-准备动画" class="headerlink" title="2. 准备动画"></a>2. 准备动画</h6><p>res/animator/anim_bar_trim_start.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:propertyName=&quot;trimPathStart&quot;</div><div class="line">    android:valueFrom=&quot;0&quot;</div><div class="line">    android:valueTo=&quot;1&quot;</div><div class="line">    android:valueType=&quot;floatType&quot;</div><div class="line">    android:duration=&quot;500&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>res/animator/anim_search_trim_start.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:propertyName=&quot;trimPathEnd&quot;</div><div class="line">    android:valueFrom=&quot;0&quot;</div><div class="line">    android:valueTo=&quot;1&quot;</div><div class="line">    android:valueType=&quot;floatType&quot;</div><div class="line">    android:duration=&quot;500&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>关联 Vector &amp; Animator<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;animated-vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:drawable=&quot;@drawable/svg&quot;&gt;</div><div class="line">    &lt;target</div><div class="line">        android:animation=&quot;@animator/anim_bar_trim_start&quot;</div><div class="line">        android:name=&quot;bar&quot;/&gt;</div><div class="line">    &lt;target</div><div class="line">        android:animation=&quot;@animator/anim_search_trim_start&quot;</div><div class="line">        android:name=&quot;search&quot;/&gt;</div><div class="line">&lt;/animated-vector&gt;</div></pre></td></tr></table></figure></p>
<h6 id="3-布局与开始动画"><a href="#3-布局与开始动画" class="headerlink" title="3. 布局与开始动画"></a>3. 布局与开始动画</h6><p>res/layout/act_main.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;FrameLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:padding=&quot;20dp&quot; &gt;</div><div class="line">    &lt;EditText</div><div class="line">        android:id=&quot;@+id/edit&quot;</div><div class="line">        android:layout_width=&quot;150dp&quot;</div><div class="line">        android:layout_height=&quot;24dp&quot;</div><div class="line">        android:hint=&quot;点击输入&quot;</div><div class="line">        android:background=&quot;@null&quot;/&gt;</div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/iv&quot;</div><div class="line">        android:layout_width=&quot;150dp&quot;</div><div class="line">        android:layout_height=&quot;24dp&quot; /&gt;</div><div class="line">&lt;/FrameLayout&gt;</div></pre></td></tr></table></figure></p>
<p>开始动画代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        final ImageView imageView = findViewById(R.id.iv);</div><div class="line">        // 将焦点放在 ImageView 上</div><div class="line">        imageView.setFocusable(true);</div><div class="line">        imageView.setFocusableInTouchMode(true);</div><div class="line">        imageView.requestFocus();</div><div class="line">        imageView.requestFocusFromTouch();</div><div class="line"></div><div class="line">        EditText editText = findViewById(R.id.edit);</div><div class="line">        editText.setOnFocusChangeListener(new View.OnFocusChangeListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onFocusChange(View v, boolean hasFocus) &#123;</div><div class="line">                AnimatedVectorDrawableCompat compat = AnimatedVectorDrawableCompat.create(</div><div class="line">                        MainActivity.this, R.drawable.animated_vector);</div><div class="line">                imageView.setImageDrawable(compat);</div><div class="line">                ((Animatable) imageView.getDrawable()).start();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">78</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
