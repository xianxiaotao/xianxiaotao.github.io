<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>先小涛</title>
  
  <subtitle>我至诚我道</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-05T00:49:35.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>先小涛</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>精通 Android 自定义 View 目录</title>
    <link href="http://yoursite.com/2200/01/01/Custom%20View/00%20Android%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E7%9B%AE%E5%BD%95/"/>
    <id>http://yoursite.com/2200/01/01/Custom View/00 Android 自定义控件 目录/</id>
    <published>2199-12-31T16:00:00.000Z</published>
    <updated>2019-11-05T00:49:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇从自定义控件的动画、绘图、视图三方面入手，分别讲解与自定义控件相关的各种知识，给大家系统的梳理相关知识。不仅适合 Android 初、中级水平从业者，也适合高水平从业者查漏补缺使用。</p><p>内容摘自启舰所著的书籍《Android 自定义控件开发入门与实践》。</p><h2 id="第1章-绘图基础"><a href="#第1章-绘图基础" class="headerlink" title="第1章  绘图基础"></a>第1章  绘图基础</h2><h3 id="1-1-基本图形绘制"><a href="#1-1-基本图形绘制" class="headerlink" title="1.1 基本图形绘制"></a><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/" target="_blank" rel="external">1.1 基本图形绘制</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/#jump1" target="_blank" rel="external">1.1.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/#jump2" target="_blank" rel="external">1.1.2 画笔的基本设置</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/#jump3" target="_blank" rel="external">1.1.3 Canvas使用基础</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/#jump4" target="_blank" rel="external">1.1.4 Rect与RectF</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/#jump5" target="_blank" rel="external">1.1.5 Color</a></p><h3 id="1-2-路径"><a href="#1-2-路径" class="headerlink" title="1.2 路径"></a><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/" target="_blank" rel="external">1.2 路径</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/#jump1" target="_blank" rel="external">1.2.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/#jump2" target="_blank" rel="external">1.2.2 直线路径</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/#jump3" target="_blank" rel="external">1.2.3 弧线路径</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/#jump4" target="_blank" rel="external">1.2.4 addXXX系列函数</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/#jump5" target="_blank" rel="external">1.2.5 填充模式</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/#jump6" target="_blank" rel="external">1.2.6 重置路径</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/#jump7" target="_blank" rel="external">1.2.7 示例:蜘蛛网状图</a></p><h3 id="1-3-文字"><a href="#1-3-文字" class="headerlink" title="1.3 文字"></a><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/" target="_blank" rel="external">1.3 文字</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/#jump1" target="_blank" rel="external">1.3.1 Paint设置</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/#jump2" target="_blank" rel="external">1.3.2 Canvas绘制文本</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/#jump3" target="_blank" rel="external">1.3.3 设置字体样式</a></p><h3 id="1-4-Region"><a href="#1-4-Region" class="headerlink" title="1.4 Region"></a><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Region/" target="_blank" rel="external">1.4 Region</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Region/#jump1" target="_blank" rel="external">1.4.1 构造Region</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Region/#jump2" target="_blank" rel="external">1.4.2 枚举区域——RegionIterator类</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Region/#jump3" target="_blank" rel="external">1.4.3 区域相交</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Region/#jump4" target="_blank" rel="external">1.4.4 其他函数</a></p><h3 id="1-5-Canvas-画布"><a href="#1-5-Canvas-画布" class="headerlink" title="1.5 Canvas(画布)"></a><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Canvas/" target="_blank" rel="external">1.5 Canvas(画布)</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Canvas/#jump1" target="_blank" rel="external">1.5.1 Canvas变换</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Canvas/#jump2" target="_blank" rel="external">1.5.2 画布的保存与恢复</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Canvas/#jump3" target="_blank" rel="external">1.5.3 示例一:圆形头像</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Canvas/#jump4" target="_blank" rel="external">1.5.4 示例二:裁剪动画</a></p><h3 id="1-6-控件的使用方法"><a href="#1-6-控件的使用方法" class="headerlink" title="1.6 控件的使用方法"></a><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/" target="_blank" rel="external">1.6 控件的使用方法</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#jump1" target="_blank" rel="external">1.6.1 控件概述</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#jump2" target="_blank" rel="external">1.6.2 通过XML引入控件</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#jump3" target="_blank" rel="external">1.6.3 动态添加控件</a></p><h2 id="第2章-视图动画"><a href="#第2章-视图动画" class="headerlink" title="第2章 视图动画"></a>第2章 视图动画</h2><h3 id="2-1-视图动画标签"><a href="#2-1-视图动画标签" class="headerlink" title="2.1 视图动画标签"></a><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/" target="_blank" rel="external">2.1 视图动画标签</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/#jump1" target="_blank" rel="external">2.1.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/#jump2" target="_blank" rel="external">2.1.2 scale 标签</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/#jump3" target="_blank" rel="external">2.1.3 Animation 继承属性</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/#jump4" target="_blank" rel="external">2.1.4 alpha 标签</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/#jump5" target="_blank" rel="external">2.1.5 rotate 标签</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/#jump6" target="_blank" rel="external">2.1.6 translate 标签</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/#jump7" target="_blank" rel="external">2.1.7 set 标签</a></p><h3 id="2-2-视图动画的代码实现"><a href="#2-2-视图动画的代码实现" class="headerlink" title="2.2 视图动画的代码实现"></a><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/" target="_blank" rel="external">2.2 视图动画的代码实现</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/#jump1" target="_blank" rel="external">2.2.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/#jump2" target="_blank" rel="external">2.2.2 ScaleAnimation</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/#jump3" target="_blank" rel="external">2.2.3 AlphaAnimation</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/#jump4" target="_blank" rel="external">2.2.4 RotateAnimation</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/#jump5" target="_blank" rel="external">2.2.5 TranslateAnimation</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/#jump6" target="_blank" rel="external">2.2.6 AnimationSet</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/#jump7" target="_blank" rel="external">2.2.7 Animation</a></p><h3 id="2-3-插值器初探"><a href="#2-3-插值器初探" class="headerlink" title="2.3 插值器初探"></a><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/" target="_blank" rel="external">2.3 插值器初探</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump1" target="_blank" rel="external">2.3.1 AccelerateDecelerateInterpolator</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump2" target="_blank" rel="external">2.3.2 AccelerateInterpolator</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump3" target="_blank" rel="external">2.3.3 DecelerateInterpolator</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump4" target="_blank" rel="external">2.3.4 LinearInterpolator</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump5" target="_blank" rel="external">2.3.5 BounceInterpolator</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump6" target="_blank" rel="external">2.3.6 AnticipateInterpolator</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump7" target="_blank" rel="external">2.3.7 OvershootInterpolator</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump8" target="_blank" rel="external">2.3.8 AnticipateOvershootInterpolator</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump9" target="_blank" rel="external">2.3.9 CycleInterpolator</a></p><h3 id="2-4-动画示例"><a href="#2-4-动画示例" class="headerlink" title="2.4 动画示例"></a><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E5%8A%A8%E7%94%BB%E7%A4%BA%E4%BE%8B/" target="_blank" rel="external">2.4 动画示例</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E5%8A%A8%E7%94%BB%E7%A4%BA%E4%BE%8B/#jump1" target="_blank" rel="external">2.4.1 镜头由远及近效果</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E5%8A%A8%E7%94%BB%E7%A4%BA%E4%BE%8B/#jump2" target="_blank" rel="external">2.4.2 加载框效果</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E5%8A%A8%E7%94%BB%E7%A4%BA%E4%BE%8B/#jump3" target="_blank" rel="external">2.4.3 扫描动画</a></p><h3 id="2-5-逐帧动画"><a href="#2-5-逐帧动画" class="headerlink" title="2.5 逐帧动画"></a><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E9%80%90%E5%B8%A7%E5%8A%A8%E7%94%BB/" target="_blank" rel="external">2.5 逐帧动画</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E9%80%90%E5%B8%A7%E5%8A%A8%E7%94%BB/#jump1" target="_blank" rel="external">2.5.1 XML 实现</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E9%80%90%E5%B8%A7%E5%8A%A8%E7%94%BB/#jump2" target="_blank" rel="external">2.5.2 代码实现</a></p><h2 id="第3章-属性动画"><a href="#第3章-属性动画" class="headerlink" title="第3章 属性动画"></a>第3章 属性动画</h2><h3 id="3-1-ValueAnimator-的基本使用"><a href="#3-1-ValueAnimator-的基本使用" class="headerlink" title="3.1 ValueAnimator 的基本使用"></a><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ValueAnimator%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">3.1 ValueAnimator 的基本使用</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ValueAnimator%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#jump1" target="_blank" rel="external">3.1.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ValueAnimator%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#jump2" target="_blank" rel="external">3.1.2 ValueAnimator 的简单使用</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ValueAnimator%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#jump3" target="_blank" rel="external">3.1.3 常用函数</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ValueAnimator%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#jump4" target="_blank" rel="external">3.1.4 示例：弹跳加载中效果</a></p><h3 id="3-2-自定义插值器与-Evaluator"><a href="#3-2-自定义插值器与-Evaluator" class="headerlink" title="3.2 自定义插值器与 Evaluator"></a><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E5%80%BC%E5%99%A8%E4%B8%8E%20Evaluator/" target="_blank" rel="external">3.2 自定义插值器与 Evaluator</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E5%80%BC%E5%99%A8%E4%B8%8E%20Evaluator/#jump1" target="_blank" rel="external">3.2.1 自定义插值器</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E5%80%BC%E5%99%A8%E4%B8%8E%20Evaluator/#jump2" target="_blank" rel="external">3.2.2 Evaluator</a></p><h3 id="3-3-ValueAnimator-进阶——ofObject"><a href="#3-3-ValueAnimator-进阶——ofObject" class="headerlink" title="3.3 ValueAnimator 进阶——ofObject"></a><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ofObject/" target="_blank" rel="external">3.3 ValueAnimator 进阶——ofObject</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ofObject/#jump1" target="_blank" rel="external">3.3.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ofObject/#jump2" target="_blank" rel="external">3.3.2 示例：抛物动画</a></p><h3 id="3-4-ObjectAnimator"><a href="#3-4-ObjectAnimator" class="headerlink" title="3.4 ObjectAnimator"></a><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ObjectAnimator/" target="_blank" rel="external">3.4 ObjectAnimator</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ObjectAnimator/#jump1" target="_blank" rel="external">3.4.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ObjectAnimator/#jump2" target="_blank" rel="external">3.4.2 ObjectAnimator 动画原理</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ObjectAnimator/#jump3" target="_blank" rel="external">3.4.3 自定义 ObjectAnimator 属性</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ObjectAnimator/#jump4" target="_blank" rel="external">3.4.4 何时需要实现对应的 get 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ObjectAnimator/#jump5" target="_blank" rel="external">3.4.5 常用函数</a></p><h3 id="3-5-组合动画——AnimatorSet"><a href="#3-5-组合动画——AnimatorSet" class="headerlink" title="3.5 组合动画——AnimatorSet"></a><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94AnimatorSet/" target="_blank" rel="external">3.5 组合动画——AnimatorSet</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94AnimatorSet/#jump1" target="_blank" rel="external">3.5.1 playSequentially() 与 playTogether() 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94AnimatorSet/#jump2" target="_blank" rel="external">3.5.2 AnimatorSet.Builder</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94AnimatorSet/#jump3" target="_blank" rel="external">3.5.3 AnimatorSet 监听器</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94AnimatorSet/#jump4" target="_blank" rel="external">3.5.4 常用函数</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94AnimatorSet/#jump5" target="_blank" rel="external">3.5.5 示例：路径动画</a></p><h3 id="3-6-Animator-动画的-XML-实现"><a href="#3-6-Animator-动画的-XML-实现" class="headerlink" title="3.6 Animator 动画的 XML 实现"></a><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94Animator%20%E5%8A%A8%E7%94%BB%E7%9A%84%20XML%20%E5%AE%9E%E7%8E%B0/" target="_blank" rel="external">3.6 Animator 动画的 XML 实现</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94Animator%20%E5%8A%A8%E7%94%BB%E7%9A%84%20XML%20%E5%AE%9E%E7%8E%B0/#jump1" target="_blank" rel="external">3.6.1 animator 标签</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94Animator%20%E5%8A%A8%E7%94%BB%E7%9A%84%20XML%20%E5%AE%9E%E7%8E%B0/#jump2" target="_blank" rel="external">3.6.2 objectAnimator 标签</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94Animator%20%E5%8A%A8%E7%94%BB%E7%9A%84%20XML%20%E5%AE%9E%E7%8E%B0/#jump3" target="_blank" rel="external">3.6.3 set 标签</a></p><h2 id="第4章-属性动画进阶"><a href="#第4章-属性动画进阶" class="headerlink" title="第4章 属性动画进阶"></a>第4章 属性动画进阶</h2><h3 id="4-1-PropertyValuesHolder-与-Keyframe"><a href="#4-1-PropertyValuesHolder-与-Keyframe" class="headerlink" title="4.1 PropertyValuesHolder 与 Keyframe"></a><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94PropertyValuesHolder%20%E4%B8%8E%20Keyframe/" target="_blank" rel="external">4.1 PropertyValuesHolder 与 Keyframe</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94PropertyValuesHolder%20%E4%B8%8E%20Keyframe/#jump1" target="_blank" rel="external">4.1.1 PropertyValuesHolder</a><br><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94PropertyValuesHolder%20%E4%B8%8E%20Keyframe/#jump2" target="_blank" rel="external">4.1.2 Keyframe</a><br><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94PropertyValuesHolder%20%E4%B8%8E%20Keyframe/#jump3" target="_blank" rel="external">4.1.3 PropertyValuesHolder 其他函数</a><br><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94PropertyValuesHolder%20%E4%B8%8E%20Keyframe/#jump4" target="_blank" rel="external">4.1.4 示例：电话响铃效果</a></p><h3 id="4-2-ViewPropertyAnimator"><a href="#4-2-ViewPropertyAnimator" class="headerlink" title="4.2 ViewPropertyAnimator"></a><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94ViewPropertyAnimator/" target="_blank" rel="external">4.2 ViewPropertyAnimator</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94ViewPropertyAnimator/#jump1" target="_blank" rel="external">4.2.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94ViewPropertyAnimator/#jump2" target="_blank" rel="external">4.2.2 常用函数</a></p><h3 id="4-3-为-ViewGroup-内的组件添加动画"><a href="#4-3-为-ViewGroup-内的组件添加动画" class="headerlink" title="4.3 为 ViewGroup 内的组件添加动画"></a><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E4%B8%BA%20ViewGroup%20%E5%86%85%E7%9A%84%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB/" target="_blank" rel="external">4.3 为 ViewGroup 内的组件添加动画</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E4%B8%BA%20ViewGroup%20%E5%86%85%E7%9A%84%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB/#jump1" target="_blank" rel="external">4.3.1 animateLayoutChanges 属性</a><br><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E4%B8%BA%20ViewGroup%20%E5%86%85%E7%9A%84%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB/#jump2" target="_blank" rel="external">4.3.2 LayoutTransition</a><br><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E4%B8%BA%20ViewGroup%20%E5%86%85%E7%9A%84%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB/#jump3" target="_blank" rel="external">4.3.3 其他函数</a></p><h3 id="4-4-开源动画库-NineOldAndroids"><a href="#4-4-开源动画库-NineOldAndroids" class="headerlink" title="4.4 开源动画库 NineOldAndroids"></a><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94NineOldAndroids/" target="_blank" rel="external">4.4 开源动画库 NineOldAndroids</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94NineOldAndroids/#jump1" target="_blank" rel="external">4.4.1 NineOldAndroids 中的 ViewPropertyAnimator</a><br><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94NineOldAndroids/#jump2" target="_blank" rel="external">4.4.2 NineOldAndroids 中的 ViewHelper</a></p><h2 id="第5章-动画进阶"><a href="#第5章-动画进阶" class="headerlink" title="第5章 动画进阶"></a>第5章 动画进阶</h2><h3 id="5-1-利用-PathMeasure-实现路径动画"><a href="#5-1-利用-PathMeasure-实现路径动画" class="headerlink" title="5.1 利用 PathMeasure 实现路径动画"></a><a href="https://xianxiaotao.github.io/2019/07/05/Custom%20View/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/" target="_blank" rel="external">5.1 利用 PathMeasure 实现路径动画</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/05/Custom%20View/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/#jump1" target="_blank" rel="external">5.1.1 初始化</a><br><a href="https://xianxiaotao.github.io/2019/07/05/Custom%20View/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/#jump2" target="_blank" rel="external">5.1.2 简单函数使用</a><br><a href="https://xianxiaotao.github.io/2019/07/05/Custom%20View/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/#jump3" target="_blank" rel="external">5.1.3 getSegment() 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/05/Custom%20View/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/#jump4" target="_blank" rel="external">5.1.4 getPosTan() 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/05/Custom%20View/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/#jump5" target="_blank" rel="external">5.1.5 getMatrix() 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/05/Custom%20View/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/#jump6" target="_blank" rel="external">5.1.6 示例：支付宝支付成功动画</a></p><h3 id="5-2-SVG-动画"><a href="#5-2-SVG-动画" class="headerlink" title="5.2 SVG 动画"></a><a href="https://xianxiaotao.github.io/2019/07/05/Custom%20View/05.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94SVG%20%E5%8A%A8%E7%94%BB/" target="_blank" rel="external">5.2 SVG 动画</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/05/Custom%20View/05.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94SVG%20%E5%8A%A8%E7%94%BB/#jump1" target="_blank" rel="external">5.2.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/05/Custom%20View/05.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94SVG%20%E5%8A%A8%E7%94%BB/#jump2" target="_blank" rel="external">5.2.2 vector 标签与图像显示</a><br><a href="https://xianxiaotao.github.io/2019/07/05/Custom%20View/05.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94SVG%20%E5%8A%A8%E7%94%BB/#jump3" target="_blank" rel="external">5.2.3 动态 Vector</a><br><a href="https://xianxiaotao.github.io/2019/07/05/Custom%20View/05.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94SVG%20%E5%8A%A8%E7%94%BB/#jump4" target="_blank" rel="external">5.2.4 示例：输入搜索动画</a></p><h2 id="第6章-Paint-基本使用"><a href="#第6章-Paint-基本使用" class="headerlink" title="第6章 Paint 基本使用"></a>第6章 Paint 基本使用</h2><h3 id="6-1-硬件加速"><a href="#6-1-硬件加速" class="headerlink" title="6.1 硬件加速"></a><a href="https://xianxiaotao.github.io/2019/07/06/Custom%20View/06.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/" target="_blank" rel="external">6.1 硬件加速</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/06/Custom%20View/06.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/#jump1" target="_blank" rel="external">6.1.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/06/Custom%20View/06.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/#jump2" target="_blank" rel="external">6.1.2 软件绘制与硬件加速的区别</a><br><a href="https://xianxiaotao.github.io/2019/07/06/Custom%20View/06.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/#jump3" target="_blank" rel="external">6.1.3 禁用 GPU 硬件加速的方法</a></p><h3 id="6-2-文字"><a href="#6-2-文字" class="headerlink" title="6.2 文字"></a><a href="https://xianxiaotao.github.io/2019/07/06/Custom%20View/06.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/" target="_blank" rel="external">6.2 文字</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/06/Custom%20View/06.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/#jump1" target="_blank" rel="external">6.2.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/06/Custom%20View/06.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/#jump2" target="_blank" rel="external">6.2.2 绘图四格线与 FontMetrics</a><br><a href="https://xianxiaotao.github.io/2019/07/06/Custom%20View/06.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/#jump3" target="_blank" rel="external">6.2.3 常用函数</a><br><a href="https://xianxiaotao.github.io/2019/07/06/Custom%20View/06.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/#jump4" target="_blank" rel="external">6.2.4 示例：定点写字</a></p><h3 id="6-3-Paint-常用函数"><a href="#6-3-Paint-常用函数" class="headerlink" title="6.3 Paint 常用函数"></a><a href="https://xianxiaotao.github.io/2019/07/06/Custom%20View/06.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" target="_blank" rel="external">6.3 Paint 常用函数</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/06/Custom%20View/06.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/#jump1" target="_blank" rel="external">6.3.1 基本设置函数</a><br><a href="https://xianxiaotao.github.io/2019/07/06/Custom%20View/06.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/#jump2" target="_blank" rel="external">6.3.2 字体相关函数</a></p><h2 id="第7章-绘图进阶"><a href="#第7章-绘图进阶" class="headerlink" title="第7章 绘图进阶"></a>第7章 绘图进阶</h2><h3 id="7-1-贝济埃曲线"><a href="#7-1-贝济埃曲线" class="headerlink" title="7.1 贝济埃曲线"></a><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E8%B4%9D%E6%B5%8E%E5%9F%83%E6%9B%B2%E7%BA%BF/" target="_blank" rel="external">7.1 贝济埃曲线</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E8%B4%9D%E6%B5%8E%E5%9F%83%E6%9B%B2%E7%BA%BF/#jump1" target="_blank" rel="external">7.1.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E8%B4%9D%E6%B5%8E%E5%9F%83%E6%9B%B2%E7%BA%BF/#jump2" target="_blank" rel="external">7.1.2 贝济埃曲线之 quadTo</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E8%B4%9D%E6%B5%8E%E5%9F%83%E6%9B%B2%E7%BA%BF/#jump3" target="_blank" rel="external">7.1.3 贝济埃曲线之 rQuadTo</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E8%B4%9D%E6%B5%8E%E5%9F%83%E6%9B%B2%E7%BA%BF/#jump4" target="_blank" rel="external">7.1.4 示例：波浪效果</a></p><h3 id="7-2-setShadowLayer-与阴影效果"><a href="#7-2-setShadowLayer-与阴影效果" class="headerlink" title="7.2 setShadowLayer 与阴影效果"></a><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94setShadowLayer%20%E4%B8%8E%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/" target="_blank" rel="external">7.2 setShadowLayer 与阴影效果</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94setShadowLayer%20%E4%B8%8E%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/#jump1" target="_blank" rel="external">7.2.1 构造函数</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94setShadowLayer%20%E4%B8%8E%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/#jump2" target="_blank" rel="external">7.2.2 清除阴影</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94setShadowLayer%20%E4%B8%8E%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/#jump3" target="_blank" rel="external">7.2.3 示例：给文字添加阴影</a></p><h3 id="7-3-BlurMaskFilter-发光效果和图片阴影"><a href="#7-3-BlurMaskFilter-发光效果和图片阴影" class="headerlink" title="7.3 BlurMaskFilter 发光效果和图片阴影"></a><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94BlurMaskFilter%20%E5%8F%91%E5%85%89%E6%95%88%E6%9E%9C%E4%B8%8E%E5%9B%BE%E7%89%87%E9%98%B4%E5%BD%B1/" target="_blank" rel="external">7.3 BlurMaskFilter 发光效果和图片阴影</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94BlurMaskFilter%20%E5%8F%91%E5%85%89%E6%95%88%E6%9E%9C%E4%B8%8E%E5%9B%BE%E7%89%87%E9%98%B4%E5%BD%B1/#jump1" target="_blank" rel="external">7.3.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94BlurMaskFilter%20%E5%8F%91%E5%85%89%E6%95%88%E6%9E%9C%E4%B8%8E%E5%9B%BE%E7%89%87%E9%98%B4%E5%BD%B1/#jump2" target="_blank" rel="external">7.3.2 给图片添加纯色阴影</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94BlurMaskFilter%20%E5%8F%91%E5%85%89%E6%95%88%E6%9E%9C%E4%B8%8E%E5%9B%BE%E7%89%87%E9%98%B4%E5%BD%B1/#jump3" target="_blank" rel="external">7.3.3 封装控件</a></p><h3 id="7-4-Shader-与-BitmapShader"><a href="#7-4-Shader-与-BitmapShader" class="headerlink" title="7.4 Shader 与 BitmapShader"></a><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B8%8E%20BitmapShader/" target="_blank" rel="external">7.4 Shader 与 BitmapShader</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B8%8E%20BitmapShader/#jump1" target="_blank" rel="external">7.4.1 Shader 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B8%8E%20BitmapShader/#jump2" target="_blank" rel="external">7.4.2 BitmapShader 的基本用法</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B8%8E%20BitmapShader/#jump3" target="_blank" rel="external">7.4.3 示例一：望远镜效果</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B8%8E%20BitmapShader/#jump4" target="_blank" rel="external">7.4.4 示例二：生成不规则头像</a></p><h3 id="7-5-Shader-之-LinearGradient"><a href="#7-5-Shader-之-LinearGradient" class="headerlink" title="7.5 Shader 之 LinearGradient"></a><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20LinearGradient/" target="_blank" rel="external">7.5 Shader 之 LinearGradient</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20LinearGradient/#jump1" target="_blank" rel="external">7.5.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20LinearGradient/#jump2" target="_blank" rel="external">7.5.2 示例：闪光文字效果</a></p><h3 id="7-6-Shader-之-RadialGradient"><a href="#7-6-Shader-之-RadialGradient" class="headerlink" title="7.6 Shader 之 RadialGradient"></a><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20RadialGradient/" target="_blank" rel="external">7.6 Shader 之 RadialGradient</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20RadialGradient/#jump1" target="_blank" rel="external">7.6.1 双色渐变</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20RadialGradient/#jump2" target="_blank" rel="external">7.6.2 多色渐变</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20RadialGradient/#jump3" target="_blank" rel="external">7.6.3 TileMode 填充模式</a></p><h2 id="第8章-混合模式"><a href="#第8章-混合模式" class="headerlink" title="第8章 混合模式"></a>第8章 混合模式</h2><h3 id="8-1-混合模式之-AvoidXfermode"><a href="#8-1-混合模式之-AvoidXfermode" class="headerlink" title="8.1 混合模式之 AvoidXfermode"></a><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AvoidXfermode/" target="_blank" rel="external">8.1 混合模式之 AvoidXfermode</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AvoidXfermode/#jump1" target="_blank" rel="external">8.1.1 混合模式概述</a><br><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AvoidXfermode/#jump2" target="_blank" rel="external">8.1.2 AvoidXfermode</a><br><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AvoidXfermode/#jump3" target="_blank" rel="external">8.1.3 AvoidXfermode 绘制原理</a><br><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AvoidXfermode/#jump4" target="_blank" rel="external">8.1.4 AvoidXfermode 之 Mode.AVOID</a></p><h3 id="8-2-混合模式之-PorterDuffXfermode"><a href="#8-2-混合模式之-PorterDuffXfermode" class="headerlink" title="8.2 混合模式之 PorterDuffXfermode"></a><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode/" target="_blank" rel="external">8.2 混合模式之 PorterDuffXfermode</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode/#jump1" target="_blank" rel="external">8.2.1 PorterDuffXfermode 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode/#jump2" target="_blank" rel="external">8.2.2 颜色叠加相关模式</a></p><h3 id="8-3-PorterDuffXfermode-之源图像模式"><a href="#8-3-PorterDuffXfermode-之源图像模式" class="headerlink" title="8.3 PorterDuffXfermode 之源图像模式"></a><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode%20%E4%B9%8B%E6%BA%90%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">8.3 PorterDuffXfermode 之源图像模式</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode%20%E4%B9%8B%E6%BA%90%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F/#jump1" target="_blank" rel="external">8.3.1 Mode.SRC</a><br><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode%20%E4%B9%8B%E6%BA%90%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F/#jump2" target="_blank" rel="external">8.3.2 Mode.SRC_IN</a><br><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode%20%E4%B9%8B%E6%BA%90%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F/#jump3" target="_blank" rel="external">8.3.3 Mode.SRC_OUT</a><br><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode%20%E4%B9%8B%E6%BA%90%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F/#jump4" target="_blank" rel="external">8.3.4 Mode.SRC_OVER</a><br><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode%20%E4%B9%8B%E6%BA%90%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F/#jump5" target="_blank" rel="external">8.3.5 Mode.SRC_ATOP</a></p><h3 id="8-4-目标图像模式与其他模式"><a href="#8-4-目标图像模式与其他模式" class="headerlink" title="8.4 目标图像模式与其他模式"></a><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%9B%AE%E6%A0%87%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">8.4 目标图像模式与其他模式</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%9B%AE%E6%A0%87%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F/#jump1" target="_blank" rel="external">8.4.1 目标图像模式</a><br><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%9B%AE%E6%A0%87%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F/#jump2" target="_blank" rel="external">8.4.2 其他模式——Mode.CLEAR</a><br><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%9B%AE%E6%A0%87%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F/#jump3" target="_blank" rel="external">8.4.3 模式总结</a></p><h2 id="第9章-Canvas-与图层"><a href="#第9章-Canvas-与图层" class="headerlink" title="第9章 Canvas 与图层"></a>第9章 Canvas 与图层</h2><h3 id="9-1-获取-Canvas-对象的方法"><a href="#9-1-获取-Canvas-对象的方法" class="headerlink" title="9.1 获取 Canvas 对象的方法"></a><a href="https://xianxiaotao.github.io/2019/07/09/Custom%20View/09.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96%20Canvas%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/" target="_blank" rel="external">9.1 获取 Canvas 对象的方法</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/09/Custom%20View/09.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96%20Canvas%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/#jump1" target="_blank" rel="external">9.1.1 方法一：重写 onDraw()、dispatchDraw() 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/09/Custom%20View/09.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96%20Canvas%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/#jump2" target="_blank" rel="external">9.1.2 方法二：使用 Bitmap 创建</a><br><a href="https://xianxiaotao.github.io/2019/07/09/Custom%20View/09.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96%20Canvas%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/#jump3" target="_blank" rel="external">9.1.3 方法三：调用 SurfaceHolder.lockCanvas() 函数</a></p><h3 id="9-2-图层与画布"><a href="#9-2-图层与画布" class="headerlink" title="9.2 图层与画布"></a><a href="https://xianxiaotao.github.io/2019/07/09/Custom%20View/09.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E5%9B%BE%E5%B1%82%E4%B8%8E%E7%94%BB%E5%B8%83/" target="_blank" rel="external">9.2 图层与画布</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/09/Custom%20View/09.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E5%9B%BE%E5%B1%82%E4%B8%8E%E7%94%BB%E5%B8%83/#jump1" target="_blank" rel="external">9.2.1 saveLayer() 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/09/Custom%20View/09.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E5%9B%BE%E5%B1%82%E4%B8%8E%E7%94%BB%E5%B8%83/#jump2" target="_blank" rel="external">9.2.2 画布与图层</a><br><a href="https://xianxiaotao.github.io/2019/07/09/Custom%20View/09.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E5%9B%BE%E5%B1%82%E4%B8%8E%E7%94%BB%E5%B8%83/#jump3" target="_blank" rel="external">9.2.3 saveLayer() &amp; saveLayerAlpha()</a></p><h3 id="9-3-Flag-的具体含义-已过时"><a href="#9-3-Flag-的具体含义-已过时" class="headerlink" title="9.3 Flag 的具体含义 已过时"></a><a href="https://xianxiaotao.github.io/2019/07/09/Custom%20View/09.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94Flag%20%E7%9A%84%E5%85%B7%E4%BD%93%E5%90%AB%E4%B9%89/" target="_blank" rel="external">9.3 Flag 的具体含义 已过时</a></h3><h3 id="9-4-恢复画布"><a href="#9-4-恢复画布" class="headerlink" title="9.4 恢复画布"></a><a href="https://xianxiaotao.github.io/2019/07/09/Custom%20View/09.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E6%81%A2%E5%A4%8D%E7%94%BB%E5%B8%83/" target="_blank" rel="external">9.4 恢复画布</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/09/Custom%20View/09.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E6%81%A2%E5%A4%8D%E7%94%BB%E5%B8%83/#jump1" target="_blank" rel="external">9.4.1 restoreToCount(int count)</a><br><a href="https://xianxiaotao.github.io/2019/07/09/Custom%20View/09.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E6%81%A2%E5%A4%8D%E7%94%BB%E5%B8%83/#jump2" target="_blank" rel="external">9.4.2 restore() &amp; restoreToCount(int count) 的关系</a></p><h2 id="第10章-Android-画布"><a href="#第10章-Android-画布" class="headerlink" title="第10章 Android 画布"></a>第10章 Android 画布</h2><h3 id="10-1-ShapeDrawable"><a href="#10-1-ShapeDrawable" class="headerlink" title="10.1 ShapeDrawable"></a><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94ShapeDrawable/" target="_blank" rel="external">10.1 ShapeDrawable</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94ShapeDrawable/#jump1" target="_blank" rel="external">10.1.1 shape 标签与 GradientDrawable</a><br><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94ShapeDrawable/#jump2" target="_blank" rel="external">10.1.2 ShapDrawable 的构造函数</a><br><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94ShapeDrawable/#jump3" target="_blank" rel="external">10.1.3 常用函数</a><br><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94ShapeDrawable/#jump4" target="_blank" rel="external">10.1.4 自定义 Drawable</a><br><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94ShapeDrawable/#jump5" target="_blank" rel="external">10.1.5 Drawable 与 Bitmap 对比</a></p><h3 id="10-2-Bitmap"><a href="#10-2-Bitmap" class="headerlink" title="10.2 Bitmap"></a><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap/" target="_blank" rel="external">10.2 Bitmap</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap/#jump1" target="_blank" rel="external">10.2.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap/#jump2" target="_blank" rel="external">10.2.2 创建 Bitmap 方法一：BitmapFactory</a><br><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap/#jump3" target="_blank" rel="external">10.2.3 BitmapFactory.Options</a><br><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap/#jump4" target="_blank" rel="external">10.2.4 创建 Bitmap 方法二：Bitmap 静态方法</a><br><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap/#jump5" target="_blank" rel="external">10.2.5 常用函数</a><br><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap/#jump6" target="_blank" rel="external">10.2.6 常见问题</a></p><h3 id="10-3-SurfaceView"><a href="#10-3-SurfaceView" class="headerlink" title="10.3 SurfaceView"></a><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94SurfaceView/" target="_blank" rel="external">10.3 SurfaceView</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94SurfaceView/#jump1" target="_blank" rel="external">10.3.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94SurfaceView/#jump2" target="_blank" rel="external">10.3.2 基本用法</a><br><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94SurfaceView/#jump3" target="_blank" rel="external">10.3.3 双缓冲技术</a></p><h2 id="第11章-Matrix-与坐标变换"><a href="#第11章-Matrix-与坐标变换" class="headerlink" title="第11章 Matrix 与坐标变换"></a>第11章 Matrix 与坐标变换</h2><h3 id="11-1-矩阵运算"><a href="#11-1-矩阵运算" class="headerlink" title="11.1 矩阵运算"></a><a href="https://xianxiaotao.github.io/2019/07/11/Custom%20View/11.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/" target="_blank" rel="external">11.1 矩阵运算</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/11/Custom%20View/11.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/#jump1" target="_blank" rel="external">11.1.1 矩阵的加法与减法</a><br><a href="https://xianxiaotao.github.io/2019/07/11/Custom%20View/11.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/#jump2" target="_blank" rel="external">11.1.2 矩阵与数的乘法</a><br><a href="https://xianxiaotao.github.io/2019/07/11/Custom%20View/11.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/#jump3" target="_blank" rel="external">11.1.3 矩阵与矩阵的乘法</a></p><h3 id="11-2-ColorMatrix-色彩变换"><a href="#11-2-ColorMatrix-色彩变换" class="headerlink" title="11.2 ColorMatrix 色彩变换"></a><a href="https://xianxiaotao.github.io/2019/07/11/Custom%20View/11.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94ColorMatrix%20%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2/" target="_blank" rel="external">11.2 ColorMatrix 色彩变换</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/11/Custom%20View/11.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94ColorMatrix%20%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2/#jump1" target="_blank" rel="external">11.2.1 色彩变换矩阵</a><br><a href="https://xianxiaotao.github.io/2019/07/11/Custom%20View/11.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94ColorMatrix%20%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2/#jump2" target="_blank" rel="external">11.2.2 色彩的几种运算方式</a><br><a href="https://xianxiaotao.github.io/2019/07/11/Custom%20View/11.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94ColorMatrix%20%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2/#jump3" target="_blank" rel="external">11.2.3 ColorMatrix 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/11/Custom%20View/11.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94ColorMatrix%20%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2/#jump4" target="_blank" rel="external">11.2.4 ColorMatrix 相乘</a></p><h2 id="第12章-封装控件"><a href="#第12章-封装控件" class="headerlink" title="第12章 封装控件"></a>第12章 封装控件</h2><h3 id="12-1-自定义属性与自定义-Style"><a href="#12-1-自定义属性与自定义-Style" class="headerlink" title="12.1 自定义属性与自定义 Style"></a><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%20Style/" target="_blank" rel="external">12.1 自定义属性与自定义 Style</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%20Style/#jump1" target="_blank" rel="external">12.1.1 示例</a><br><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%20Style/#jump2" target="_blank" rel="external">12.1.2 在 XML 中使用自定义的属性</a><br><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%20Style/#jump3" target="_blank" rel="external">12.1.3 在代码中获取自定义属性的值</a><br><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%20Style/#jump4" target="_blank" rel="external">12.1.4 declare-styleable 标签其他属性的用法</a></p><h3 id="12-2-测量与布局"><a href="#12-2-测量与布局" class="headerlink" title="12.2 测量与布局"></a><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E6%B5%8B%E9%87%8F%E5%92%8C%E5%B8%83%E5%B1%80/" target="_blank" rel="external">12.2 测量与布局</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E6%B5%8B%E9%87%8F%E5%92%8C%E5%B8%83%E5%B1%80/#jump1" target="_blank" rel="external">12.2.1 ViewGroup 绘制流程</a><br><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E6%B5%8B%E9%87%8F%E5%92%8C%E5%B8%83%E5%B1%80/#jump2" target="_blank" rel="external">12.2.2 onMeasure() 函数与 MeasureSpec</a><br><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E6%B5%8B%E9%87%8F%E5%92%8C%E5%B8%83%E5%B1%80/#jump3" target="_blank" rel="external">12.2.3 onLayout() 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E6%B5%8B%E9%87%8F%E5%92%8C%E5%B8%83%E5%B1%80/#jump4" target="_blank" rel="external">12.2.4 获取子控件 margin 值的方法</a></p><h3 id="12-3-实现-FlowLayout-容器"><a href="#12-3-实现-FlowLayout-容器" class="headerlink" title="12.3 实现 FlowLayout 容器"></a><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%20FlowLayout%20%E5%AE%B9%E5%99%A8/" target="_blank" rel="external">12.3 实现 FlowLayout 容器</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%20FlowLayout%20%E5%AE%B9%E5%99%A8/#jump1" target="_blank" rel="external">12.3.1 XML 布局</a><br><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%20FlowLayout%20%E5%AE%B9%E5%99%A8/#jump2" target="_blank" rel="external">12.3.2 提取 margin 值与重写 onMeasure() 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%20FlowLayout%20%E5%AE%B9%E5%99%A8/#jump3" target="_blank" rel="external">12.3.3 完整代码</a></p><h2 id="第13章-控件高级属性"><a href="#第13章-控件高级属性" class="headerlink" title="第13章 控件高级属性"></a>第13章 控件高级属性</h2><h3 id="13-1-GestureDetector-手势检测"><a href="#13-1-GestureDetector-手势检测" class="headerlink" title="13.1 GestureDetector 手势检测"></a><a href="https://xianxiaotao.github.io/2019/07/13/Custom%20View/13.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94GestureDetector%20%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B/" target="_blank" rel="external">13.1 GestureDetector 手势检测</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/13/Custom%20View/13.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94GestureDetector%20%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B/#jump1" target="_blank" rel="external">13.1.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/13/Custom%20View/13.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94GestureDetector%20%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B/#jump2" target="_blank" rel="external">13.1.2 GestureDetector.OnGestureListener</a><br><a href="https://xianxiaotao.github.io/2019/07/13/Custom%20View/13.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94GestureDetector%20%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B/#jump3" target="_blank" rel="external">13.1.3 GestureDetector.OnDoubleTapListener</a><br><a href="https://xianxiaotao.github.io/2019/07/13/Custom%20View/13.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94GestureDetector%20%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B/#jump4" target="_blank" rel="external">13.1.4 GestureDetector.SimpleOnGestureListener</a><br><a href="https://xianxiaotao.github.io/2019/07/13/Custom%20View/13.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94GestureDetector%20%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B/#jump5" target="_blank" rel="external">13.1.5 onFling() 函数的应用</a></p><h3 id="13-2-Window-与-WindowManager"><a href="#13-2-Window-与-WindowManager" class="headerlink" title="13.2 Window 与 WindowManager"></a><a href="https://xianxiaotao.github.io/2019/07/13/Custom%20View/13.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94Window%20%E4%B8%8E%20WindowManager/" target="_blank" rel="external">13.2 Window 与 WindowManager</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/13/Custom%20View/13.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94Window%20%E4%B8%8E%20WindowManager/#jump1" target="_blank" rel="external">13.2.1 Window 与 WindowManager 的关系</a><br><a href="https://xianxiaotao.github.io/2019/07/13/Custom%20View/13.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94Window%20%E4%B8%8E%20WindowManager/#jump2" target="_blank" rel="external">13.2.2 示例：腾讯手机管家悬浮窗的小火箭效果</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇从自定义控件的动画、绘图、视图三方面入手，分别讲解与自定义控件相关的各种知识，给大家系统的梳理相关知识。不仅适合 Android 初、中级水平从业者，也适合高水平从业者查漏补缺使用。&lt;/p&gt;
&lt;p&gt;内容摘自启舰所著的书籍《Android 自定义控件开发入门与实践》。&lt;/
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>X001 圆角圆形 ImageView</title>
    <link href="http://yoursite.com/2019/09/01/Custom%20View/X001%20%E5%9C%86%E8%A7%92%E5%9C%86%E5%BD%A2%20ImageView/"/>
    <id>http://yoursite.com/2019/09/01/Custom View/X001 圆角圆形 ImageView/</id>
    <published>2019-08-31T16:00:00.000Z</published>
    <updated>2020-01-24T05:02:47.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-99c14f4dff5bc857.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>鉴于 Android 提供的 ImageView 控件已经非常完善，不仅处理好了各种缩放问题，而且有着很好的兼容性，还实现了显示图片等一系列的任务，我们只要在它的基础上添加一个显示圆角圆形的功能即可。</p><h3 id="一、属性配置"><a href="#一、属性配置" class="headerlink" title="一、属性配置"></a>一、属性配置</h3><p>首先创建一个 res/values/attrs.xml 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">    &lt;declare-styleable name=&quot;RoundImageView&quot;&gt;</div><div class="line">        &lt;attr name=&quot;type&quot; format=&quot;enum&quot;&gt;</div><div class="line">            &lt;enum name=&quot;circle&quot; value=&quot;1&quot;/&gt;</div><div class="line">            &lt;enum name=&quot;round&quot; value=&quot;2&quot;/&gt;</div><div class="line">        &lt;/attr&gt;</div><div class="line">        &lt;attr name=&quot;radius&quot; format=&quot;dimension&quot;/&gt;</div><div class="line">    &lt;/declare-styleable&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure></p><h3 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h3><h4 id="1-思路"><a href="#1-思路" class="headerlink" title="1. 思路"></a>1. 思路</h4><ul><li>定义一个 Java 类 RoundImageView，继承自 ImageView，重写其构造方法，获取配置属性进行初始化。</li><li>重写 onMeasure 方法，当模式为圆形的时候使其控件的宽高一致。</li><li>重写 onDraw 方法，增加两种模式处理逻辑。</li></ul><h4 id="2-完整代码"><a href="#2-完整代码" class="headerlink" title="2. 完整代码"></a>2. 完整代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.content.Context;</div><div class="line">import android.content.res.TypedArray;</div><div class="line">import android.graphics.Bitmap;</div><div class="line">import android.graphics.BitmapShader;</div><div class="line">import android.graphics.Canvas;</div><div class="line">import android.graphics.Matrix;</div><div class="line">import android.graphics.Paint;</div><div class="line">import android.graphics.RectF;</div><div class="line">import android.graphics.Shader;</div><div class="line">import android.graphics.drawable.Drawable;</div><div class="line">import android.os.Build;</div><div class="line">import android.util.AttributeSet;</div><div class="line">import android.util.TypedValue;</div><div class="line"></div><div class="line">import androidx.appcompat.widget.AppCompatImageView;</div><div class="line"></div><div class="line">public class RoundImageView extends AppCompatImageView &#123;</div><div class="line"></div><div class="line">    private static final int MODE_NONE = 0;         // 普通模式，默认</div><div class="line">    private static final int MODE_CIRCLE = 1;       // 圆形模式</div><div class="line">    private static final int MODE_ROUND = 2;        // 圆角矩形模式</div><div class="line"></div><div class="line">    private int currMode = MODE_NONE;</div><div class="line">    private int currRound = dp2px(10);              // 圆角半径</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private RectF mRectF = null;</div><div class="line">    private Drawable mPreDrawable = null;</div><div class="line"></div><div class="line">    public RoundImageView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        initViews();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public RoundImageView(Context context, AttributeSet attrs) &#123;</div><div class="line">        this(context, attrs, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public RoundImageView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">        obtainStyledAttrs(context, attrs, defStyleAttr);</div><div class="line">        initViews();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void obtainStyledAttrs(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.RoundImageView,</div><div class="line">                defStyleAttr, 0);</div><div class="line">        currMode = a.getInt(R.styleable.RoundImageView_type, MODE_NONE);</div><div class="line">        currRound = a.getDimensionPixelSize(R.styleable.RoundImageView_radius, currRound);</div><div class="line">        a.recycle();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initViews() &#123;</div><div class="line">        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);</div><div class="line">        mRectF = new RectF();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">        if (currMode == MODE_CIRCLE) &#123;</div><div class="line">            int result = Math.min(getMeasuredWidth(), getMeasuredHeight());</div><div class="line">            setMeasuredDimension(result, result);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        Drawable drawable = getDrawable();</div><div class="line">        Matrix drawMatrix = getImageMatrix();</div><div class="line">        if (drawable == null) &#123;</div><div class="line">            return; // couldn&apos;t resolve the URI</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (drawable.getIntrinsicWidth() == 0 || drawable.getIntrinsicHeight() == 0) &#123;</div><div class="line">            return; // nothing to draw (empty bounds)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (drawMatrix == null &amp;&amp; getPaddingTop() == 0 &amp;&amp; getPaddingLeft() == 0) &#123;</div><div class="line">            drawable.draw(canvas);</div><div class="line">        &#125; else &#123;</div><div class="line">            final int saveCount = canvas.getSaveCount();</div><div class="line">            canvas.save();</div><div class="line"></div><div class="line">            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123;</div><div class="line">                if (getCropToPadding()) &#123;</div><div class="line">                    final int scrollX = getScrollX();</div><div class="line">                    final int scrollY = getScrollY();</div><div class="line">                    canvas.clipRect(scrollX + getPaddingLeft(), scrollY + getPaddingTop(),</div><div class="line">                            scrollX + getRight() - getLeft() - getPaddingRight(),</div><div class="line">                            scrollY + getBottom() - getTop() - getPaddingBottom());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            canvas.translate(getPaddingLeft(), getPaddingTop());</div><div class="line">            // 当为圆形模式的时候</div><div class="line">            if (currMode == MODE_CIRCLE) &#123;</div><div class="line">                setBitmapShader(drawable);</div><div class="line">                canvas.drawCircle(getWidth() / 2f, getHeight() / 2f, getWidth() / 2f, mPaint);</div><div class="line">            &#125;</div><div class="line">            // 当为圆角模式的时候</div><div class="line">            else if (currMode == MODE_ROUND) &#123;</div><div class="line">                setBitmapShader(drawable);</div><div class="line">                mRectF.set(getPaddingLeft(), getPaddingTop(), getWidth() - getPaddingRight(), getHeight() - getPaddingBottom());</div><div class="line">                canvas.drawRoundRect(mRectF, currRound, currRound, mPaint);</div><div class="line">            &#125; else &#123;</div><div class="line">                if (drawMatrix != null) &#123;</div><div class="line">                    canvas.concat(drawMatrix);</div><div class="line">                &#125;</div><div class="line">                drawable.draw(canvas);</div><div class="line">            &#125;</div><div class="line">            canvas.restoreToCount(saveCount);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void setBitmapShader(Drawable drawable) &#123;</div><div class="line">        // 防止多次重 new 对象</div><div class="line">        if (drawable != null &amp;&amp; drawable != mPreDrawable) &#123;</div><div class="line">            Bitmap bitmap = drawable2Bitmap(drawable);</div><div class="line">            mPaint.setShader(new BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP));</div><div class="line">            mPreDrawable = drawable;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * drawable 转换成 bitmap</div><div class="line">     */</div><div class="line">    private Bitmap drawable2Bitmap(Drawable drawable) &#123;</div><div class="line">        if (drawable == null) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        Bitmap bitmap = Bitmap.createBitmap(getWidth(), getHeight(), Bitmap.Config.ARGB_8888);</div><div class="line">        Canvas canvas = new Canvas(bitmap);</div><div class="line">        // 根据传递的 scaleType 获取 matrix 对象，设置给 bitmap</div><div class="line">        Matrix matrix = getImageMatrix();</div><div class="line">        if (matrix != null) &#123;</div><div class="line">            canvas.concat(matrix);</div><div class="line">        &#125;</div><div class="line">        drawable.draw(canvas);</div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private int dp2px(float value) &#123;</div><div class="line">        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, value,</div><div class="line">                getResources().getDisplayMetrics());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 onDraw 方法中，以下代码是我们添加的逻辑，其余代码为 ImageView 源代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Drawable drawable = getDrawable();</div><div class="line">Matrix drawMatrix = getImageMatrix();</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">// 当为圆形模式的时候</div><div class="line">if (currMode == MODE_CIRCLE) &#123;</div><div class="line">    setBitmapShader(drawable);</div><div class="line">    canvas.drawCircle(getWidth() / 2f, getHeight() / 2f, getWidth() / 2f, mPaint);</div><div class="line">&#125;</div><div class="line">// 当为圆角模式的时候</div><div class="line">else if (currMode == MODE_ROUND) &#123;</div><div class="line">    setBitmapShader(drawable);</div><div class="line">    mRectF.set(getPaddingLeft(), getPaddingTop(), getWidth() - getPaddingRight(), getHeight() - getPaddingBottom());</div><div class="line">    canvas.drawRoundRect(mRectF, currRound, currRound, mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="3-在布局文件中使用"><a href="#3-在布局文件中使用" class="headerlink" title="3. 在布局文件中使用"></a>3. 在布局文件中使用</h4><p>效果如首图所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line"></div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;/&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot; /&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;</div><div class="line">            android:scaleType=&quot;centerCrop&quot; /&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line"></div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;</div><div class="line">            app:type=&quot;round&quot;/&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            app:type=&quot;round&quot;/&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;</div><div class="line">            android:scaleType=&quot;centerCrop&quot;</div><div class="line">            app:type=&quot;round&quot;/&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line"></div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;</div><div class="line">            app:type=&quot;circle&quot;/&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            app:type=&quot;circle&quot;/&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;</div><div class="line">            android:scaleType=&quot;centerCrop&quot;</div><div class="line">            app:type=&quot;circle&quot;/&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line"></div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;</div><div class="line">        android:layout_marginTop=&quot;10dp&quot;&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_margin=&quot;10dp&quot;</div><div class="line">            android:layout_width=&quot;50dp&quot;</div><div class="line">            android:layout_height=&quot;50dp&quot;</div><div class="line">            android:src=&quot;@color/colorAccent&quot; /&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_margin=&quot;10dp&quot;</div><div class="line">            android:layout_width=&quot;50dp&quot;</div><div class="line">            android:layout_height=&quot;50dp&quot;</div><div class="line">            android:src=&quot;@color/colorAccent&quot;</div><div class="line">            app:type=&quot;round&quot; /&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_margin=&quot;10dp&quot;</div><div class="line">            android:layout_width=&quot;50dp&quot;</div><div class="line">            android:layout_height=&quot;50dp&quot;</div><div class="line">            android:src=&quot;@color/colorAccent&quot;</div><div class="line">            app:type=&quot;circle&quot; /&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14186083-99c14f4dff5bc857.png?imag
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>14 设计模式——模板方法模式</title>
    <link href="http://yoursite.com/2019/08/20/PATTERN/14%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/20/PATTERN/14 设计模式——模板方法模式/</id>
    <published>2019-08-19T17:00:00.000Z</published>
    <updated>2020-03-04T15:35:14.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><hr><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>模板方法（Template Method）模式：<strong>定义一个操作中的算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</strong>。</p><p>在面向对象开发过程中，通常会遇到这样的一个问题，我们知道一个算法所需的关键步骤，并确定了这些步骤的执行顺序，但是某些步骤的具体实现是未知的，或者说某些步骤的实现是会随着环境的变化而改变的。</p><p>例如，执行程序的流程大致如下：<br>1）检查代码的正确性；<br>2）链接相关的类库；<br>3）编译相关代码；<br>4）执行程序。</p><p>对于不同的程序设计语言，上述 4 个步骤都是不一样的，但是它们的执行流程都是固定的，这类问题的解决方案就是模板方法模式。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li><li>它在父类中提取了公共的部分代码，便于代码复用。</li><li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li><li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>多个子类有公有的方法，并且逻辑基本相同是。</li><li>重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能由各个子类实现。</li><li>重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为。</li></ul><hr><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><hr><p>模板方法模式需要注意抽象类与具体子类之间的协作。它用到了虚函数的多态性技术以及“不用调用我，让我来调用你”的反向控制技术。现在来介绍它们的基本结构。</p><p>模式包含以下主要角色。</p><ul><li>AbstractClass：抽象类，定义了一整套算法框架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。<ul><li>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</li><li>基本方法：是整个算法中的一个步骤，包含以下几种类型。<ul><li>抽象方法：在抽象类中申明，由具体子类实现。</li><li>具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。</li><li>钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</li></ul></li></ul></li><li>ConcreteClass：具体实现类，根据需要去实现抽象类中的方法。</li></ul><p>其结构图如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0df76e430f09a758.gif?imageMogr2/auto-orient/strip" alt=""></p><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class TemplateMethodPattern &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        AbstractClass tm = new ConcreteClass();</div><div class="line">        tm.TemplateMethod();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 抽象类</div><div class="line">abstract class AbstractClass &#123;</div><div class="line">    // 模板方法，不允许覆写</div><div class="line">    public final void TemplateMethod() &#123;</div><div class="line">        SpecificMethod();</div><div class="line">        abstractMethod1();</div><div class="line">        abstractMethod2();</div><div class="line">    &#125;</div><div class="line">    // 具体方法</div><div class="line">    public void SpecificMethod() &#123;</div><div class="line">        System.out.println(&quot;抽象类中的具体方法被调用...&quot;);</div><div class="line">    &#125;</div><div class="line">    public abstract void abstractMethod1(); // 抽象方法1</div><div class="line">    public abstract void abstractMethod2(); // 抽象方法2</div><div class="line">&#125;</div><div class="line">// 具体子类</div><div class="line">class ConcreteClass extends AbstractClass &#123;</div><div class="line">    public void abstractMethod1() &#123;</div><div class="line">        System.out.println(&quot;抽象方法1的实现被调用...&quot;);</div><div class="line">    &#125;</div><div class="line">    public void abstractMethod2() &#123;</div><div class="line">        System.out.println(&quot;抽象方法2的实现被调用...&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><hr><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>以送快递为例，快递员送快递基本就是一套固定的流程：收到快递 &gt;&gt; 准备派送 &gt;&gt; 联系收货人 &gt;&gt; 确定结果。</p><p>定义算法框架，这里是快递员派送快递的步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">// 抽象快递员类</div><div class="line">public abstract class Postman &#123;</div><div class="line">    // 派送流程</div><div class="line">    // 这里申明为final，不希望子类覆盖这个方法，防止更改流程的执行顺序</div><div class="line">    public final void post() &#123;</div><div class="line">        prepare();      // 准备派送</div><div class="line">        call();         // 联系收货人</div><div class="line">        if (isSign()) &#123; // 是否签收</div><div class="line">            sign();     // 签收</div><div class="line">        &#125; else &#123;</div><div class="line">            refuse();   //拒签</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 准备操作，固定流程，父类实现</div><div class="line">    protected void prepare() &#123;</div><div class="line">        System.out.println(&quot;快递已达到，准备派送&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 联系收货人，联系人不一样，所以为抽象方法，子类实现</div><div class="line">    protected abstract void call();</div><div class="line"></div><div class="line">    // 是否签收,这个是钩子方法，用来控制流程的走向</div><div class="line">    protected boolean isSign() &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 签收，这个是固定流程，父类实现</div><div class="line">    protected void sign() &#123;</div><div class="line">        System.out.println(&quot;客户已签收，上报系统&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 拒签，空实现，这个也是钩子方法，子类可以跟进实际来决定是否去实现这个方法</div><div class="line">    protected void refuse() &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>根据需要去实现抽象类中的方法，下面以派送给两个不同的人为例，其中一个签收，另一个拒收：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 派送给 A 先生</div><div class="line">public class PostA extends Postman &#123;</div><div class="line">    // 联系收货，实现父类的抽象方法</div><div class="line">    @Override</div><div class="line">    protected void call() &#123;</div><div class="line">        System.out.println(&quot;联系A先生并送到门口&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 派送给 B 先生</div><div class="line">public class PostB extends Postman &#123;</div><div class="line">    // 联系收货，实现父类的抽象方法</div><div class="line">    @Override</div><div class="line">    protected void call() &#123;</div><div class="line">        System.out.println(&quot;联系B先生并送到门口&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 是否签收，覆盖父类的钩子方法，控制流程的走向</div><div class="line">    @Override</div><div class="line">    protected boolean isSign() &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 拒签，覆盖父类的钩子方法</div><div class="line">    @Override</div><div class="line">    protected void refuse() &#123;</div><div class="line">        System.out.println(&quot;拒绝签收：商品不符&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>客户端测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void test()&#123;</div><div class="line">    System.out.println(&quot;----派送A----&quot;);</div><div class="line">    Postman postA=new PostA();</div><div class="line">    postA.post();</div><div class="line">    System.out.println(&quot;----派送B----&quot;);</div><div class="line">    Postman postB=new PostB();</div><div class="line">    postB.post();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">----派送A----</div><div class="line">快递已达到，准备派送</div><div class="line">联系A先生并送到门口</div><div class="line">客户已签收，上报系统</div><div class="line">----派送B----</div><div class="line">快递已达到，准备派送</div><div class="line">联系B先生并送到门口</div><div class="line">拒绝签收：商品不符</div></pre></td></tr></table></figure></p><hr><h3 id="ANDROID-源码中的实现"><a href="#ANDROID-源码中的实现" class="headerlink" title="ANDROID 源码中的实现"></a>ANDROID 源码中的实现</h3><hr><p>在 ANDROID 中，使用模板方法模式的示例有很多。例如：Activity 的生命周期函数、View 的 draw 方法 和 AsyncTask 类。</p><p>AsyncTask 的整个执行过程其实是一个框架，具体的实现都需要子类来完成，而且它执行的算法框架是固定的，调用 execute 后会依次执行 onPreExecute、doInBackground、onPostExecute，当然也可以通过 onProgressUpdate 来更新进度。</p><p>AsyncTask 的 execute 方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">@MainThread</div><div class="line">public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</div><div class="line">    return executeOnExecutor(sDefaultExecutor, params);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@MainThread</div><div class="line">public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,</div><div class="line">                                                                   Params... params) &#123;</div><div class="line">    if (mStatus != Status.PENDING) &#123;</div><div class="line">        switch (mStatus) &#123;</div><div class="line">            case RUNNING:</div><div class="line">                throw new IllegalStateException(&quot;Cannot execute task:&quot;</div><div class="line">                        + &quot; the task is already running.&quot;);</div><div class="line">            case FINISHED:</div><div class="line">                throw new IllegalStateException(&quot;Cannot execute task:&quot;</div><div class="line">                        + &quot; the task has already been executed &quot;</div><div class="line">                        + &quot;(a task can be executed only once)&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mStatus = Status.RUNNING;</div><div class="line">    onPreExecute();</div><div class="line"></div><div class="line">    mWorker.mParams = params;</div><div class="line">    exec.execute(mFuture);</div><div class="line"></div><div class="line">    return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看到 execute 方法是一个 final 方法，它调用了 executeOnExecutor 方法。如果不是 Pending 状态会抛出依次，这也解释了为什么 AsyncTask 只能被执行一次，因为 AsyncTask 的 Running 和 Finished 状态都会抛出异常，因此每次使用 AsyncTask 时都需要重新创建一个对象。</p><p>继续往下看，在 executeOnExecutor 方法中首先执行了 onPreExecute 方法，因为 AsyncTask 的要求是需要在 UI 线程中调用 execute 方法。因此，onPreExecute 方法也在 UI 线程中执行，然后将 params 参数传递给 mWorker 对象的 mParams 字段，并且执行了 exec.execute(mFuture) 方法。而 mWorker 和 mFuture 这两个字段都是在构造函数中初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public AsyncTask(@Nullable Looper callbackLooper) &#123;</div><div class="line">    // 构建一个 Worker 对象</div><div class="line">    mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">        public Result call() throws Exception &#123;</div><div class="line">            mTaskInvoked.set(true);</div><div class="line">            Result result = null;</div><div class="line">            try &#123;</div><div class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">                // 调用 doInBackground</div><div class="line">                result = doInBackground(mParams);</div><div class="line">                Binder.flushPendingCommands();</div><div class="line">            &#125; catch (Throwable tr) &#123;</div><div class="line">                mCancelled.set(true);</div><div class="line">                throw tr;</div><div class="line">            &#125; finally &#123;</div><div class="line">                postResult(result);</div><div class="line">            &#125;</div><div class="line">            return result;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">        @Override</div><div class="line">        protected void done() &#123;</div><div class="line">            try &#123;</div><div class="line">                postResultIfNotInvoked(get());</div><div class="line">            &#125; </div><div class="line">            // 代码省略</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>mWorker 的 call 方法会调用 doInBackground，并且在 finally 方法里面将 result 通过 postResult 方法传递出去。</p><p>mFuture 包装了 mWorker 对象，在这个 mFuture 对象的 run 函数中又会调用 mWorker 对象的 call 方法，在 call 方法中调用了 doInBackground 函数。因为 mFuture 提交给了线程池来执行，所以使得 doInBackground 执行在非 UI 线程。得到 doInBackground 的结果后，通过 postResult 传递结果给 UI 线程。</p><p>postResult 方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private Result postResult(Result result) &#123;</div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</div><div class="line">            new AsyncTaskResult&lt;Result&gt;(this, result));</div><div class="line">    message.sendToTarget();</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>postResult 方法把一个消息（MESSAGE_POST_RESULT）发送给 Handler 执行。Handler 是 InternalHandler 类型。当 InternalHandler 接到 MESSAGE_POST_RESULT 类型的消息时，就会调用 result.mTask.finish() 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">private static class InternalHandler extends Handler &#123;</div><div class="line">    public InternalHandler(Looper looper) &#123;</div><div class="line">        super(looper);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</div><div class="line">    @Override</div><div class="line">    public void handleMessage(Message msg) &#123;</div><div class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class="line">        switch (msg.what) &#123;</div><div class="line">            case MESSAGE_POST_RESULT:</div><div class="line">                // There is only one result</div><div class="line">                // 调用了 AsyncTask 的 finish 方法</div><div class="line">                result.mTask.finish(result.mData[0]);</div><div class="line">                break;</div><div class="line">            case MESSAGE_POST_PROGRESS:</div><div class="line">                result.mTask.onProgressUpdate(result.mData);</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void finish(Result result) &#123;</div><div class="line">        if (isCancelled()) &#123;</div><div class="line">            onCancelled(result);</div><div class="line">        &#125; else &#123;</div><div class="line">            // 结果通过 onPostExecute 回调给用户</div><div class="line">            onPostExecute(result);</div><div class="line">        &#125;</div><div class="line">        mStatus = Status.FINISHED;  // 修改状态</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>AsyncTask 的 finish 方法又调用了 onPostExecute ，这个时候执行过程就完成了。</p><p>总之，execute 方法内部封装了 onPreExecute、doInBackground、onPostExecute 这个逻辑流程，用户可以根据自己的需求再覆写这几个方法，使得用户可以很方便地使用异步任务来完成耗时地操作以及更新UI，这其实就是通过线程池来执行耗时地任务，得到结果之后，通过 Handler 将结果传递到 UI 线程来执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;hr&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;模板方法（Template 
      
    
    </summary>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/categories/PATTERN/"/>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/tags/PATTERN/"/>
    
  </entry>
  
  <entry>
    <title>13 设计模式——迭代器模式</title>
    <link href="http://yoursite.com/2019/08/19/PATTERN/13%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/19/PATTERN/13 设计模式——迭代器模式/</id>
    <published>2019-08-18T17:00:00.000Z</published>
    <updated>2020-03-04T13:34:12.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><hr><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>迭代器（Iterator）模式：<strong>提供一种方法顺序访问一个容器对象中的各个元素，而又不需暴露该对象的内部细节</strong>。</p><p>在程序设计中，经常要访问一个聚合对象中的各个元素，如数据结构中的链表遍历，通常的做法是将链表的创建和遍历都放在同一个类中，但这种方式不利于程序的扩展，如果要更换遍历方法就必须修改程序源代码，这违背了 “开闭原则”。</p><p>既然将遍历方法封装在聚合类中不可取，那么聚合类中不提供遍历方法，将遍历方法由用户自己实现是否可行呢？答案是同样不可取，因为这种方式会存在两个缺点：暴露了聚合类的内部表示，使其数据不安全；增加了客户的负担。</p><p><strong>迭代器模式</strong>能较好地克服以上缺点，它在客户访问类与聚合类之间插入一个迭代器，这分离了聚合对象与其遍历行为，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则”，如 Java 中的 Collection、List、Set、Map 等都包含了迭代器。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>访问一个聚合对象的内容而无须暴露它的内部表示。</li><li>遍历任务交由迭代器完成，这简化了聚合类。</li><li>它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。</li><li>增加新的聚合类和迭代器类都很方便，无须修改原有代码。</li><li>封装性良好，为遍历不同的聚合结构提供一个统一的接口。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>增加了类的个数，这在一定程度上增加了系统的复杂性。</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>遍历一个容器对象时。</li></ul><hr><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><hr><p>迭代器模式是通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现的，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明地访问聚合的内部数据。现在我们来分析其基本结构与实现方法。</p><p>模式包含以下主要角色。</p><ul><li>Iterator（迭代器接口）：负责定义、访问和遍历元素的接口。</li><li>ConcreteIterator（具体迭代器类）：实现迭代器接口。</li><li>Aggregate（容器接口）：定义容器的基本功能以及提供创建迭代器的接口。</li><li>ConcreteAggregate（具体容器类）：实现容器接口中的功能。</li><li>Client（客户端类）：即要使用迭代器模式的地方。</li></ul><p>其结构图如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f3ac7a8df08cf0bf.gif?imageMogr2/auto-orient/strip" alt=""></p><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public class IteratorPattern &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Aggregate&lt;String&gt; aggregate = new ConcreteAggregate&lt;&gt;(); </div><div class="line">        aggregate.add(&quot;中山大学&quot;); </div><div class="line">        aggregate.add(&quot;华南理工&quot;); </div><div class="line">        aggregate.add(&quot;韶关学院&quot;);</div><div class="line">        System.out.print(&quot;聚合的内容有：&quot;);</div><div class="line">        Iterator&lt;String&gt; it = aggregate.getIterator(); </div><div class="line">        while (it.hasNext()) &#123;</div><div class="line">            System.out.print(it.next() + &quot;\t&quot;); </div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;\nFirst：&quot; + it.first());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 抽象聚合</div><div class="line">interface Aggregate&lt;T&gt; &#123; </div><div class="line">    void add(T obj); </div><div class="line">    void remove(T obj); </div><div class="line">    Iterator&lt;T&gt; iterator(); </div><div class="line">&#125;</div><div class="line">// 具体聚合，具体容器</div><div class="line">class ConcreteAggregate&lt;T&gt; implements Aggregate&lt;T&gt; &#123; </div><div class="line">    private List&lt;T&gt; list = new ArrayList&lt;T&gt;(); </div><div class="line">    public void add(T obj) &#123; </div><div class="line">        list.add(obj); </div><div class="line">    &#125;</div><div class="line">    public void remove(T obj) &#123; </div><div class="line">        list.remove(obj); </div><div class="line">    &#125;</div><div class="line">    public Iterator&lt;T&gt; getIterator() &#123; </div><div class="line">        return(new ConcreteIterator&lt;T&gt;(list)); </div><div class="line">    &#125;     </div><div class="line">&#125;</div><div class="line">// 抽象迭代器</div><div class="line">interface Iterator&lt;T&gt; &#123;</div><div class="line">    T first();</div><div class="line">    T next();</div><div class="line">    boolean hasNext();</div><div class="line">&#125;</div><div class="line">// 具体迭代器</div><div class="line">class ConcreteIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123; </div><div class="line">    private List&lt;T&gt; list; </div><div class="line">    private int index = -1; </div><div class="line">    public ConcreteIterator(List&lt;T&gt; list) &#123; </div><div class="line">        this.list = list; </div><div class="line">    &#125; </div><div class="line">    public boolean hasNext() &#123; </div><div class="line">        return index &lt; list.size() - 1;</div><div class="line">    &#125;</div><div class="line">    public T first() &#123;</div><div class="line">        index = 0;</div><div class="line">        return list.get(index);</div><div class="line">    &#125;</div><div class="line">    public T next() &#123; </div><div class="line">        T obj = null; </div><div class="line">        if (this.hasNext()) &#123; </div><div class="line">            obj = list.get(++index); </div><div class="line">        &#125; </div><div class="line">        return obj; </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><hr><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>用迭代器模式编写一个浏览婺源旅游风景图的程序。</p><p>分析：婺源的名胜古迹较多，要设计一个查看相关景点图片和简介的程序，用“迭代器模式”设计比较合适。</p><p>首先，设计一个婺源景点（WyViewSpot）类来保存每张图片的名称与简介；再设计一个景点集（ViewSpotSet）接口，它是抽象聚合类，提供了增加和删除婺源景点的方法，以及获取迭代器的方法。</p><p>然后，定义一个婺源景点集（WyViewSpotSet）类，它是具体聚合类，用 ArrayList 来保存所有景点信息，并实现父类中的抽象方法；再定义婺源景点的抽象迭代器（ViewSpotltemtor）接口，其中包含了查看景点信息的相关方法。</p><p>最后，定义婺源景点的具体迭代器（WyViewSpotlterator）类，它实现了父类的抽象方法。</p><p>程序代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">// 婺源景点类</div><div class="line">class WyViewSpot &#123;</div><div class="line">    private String name;</div><div class="line">    private String introduce;</div><div class="line">    WyViewSpot(String name, String Introduce) &#123;</div><div class="line">        this.name = name;</div><div class="line">        this.introduce = introduce;</div><div class="line">    &#125;</div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line">    public String getIntroduce() &#123;</div><div class="line">        return introduce;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽象聚合：婺源景点集接口</div><div class="line">interface ViewSpotSet &#123;</div><div class="line">    void add(WyViewSpot obj);</div><div class="line">    void remove(WyViewSpot obj);</div><div class="line">    ViewSpotIterator iterator();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体聚合：婺源景点集</div><div class="line">class WyViewSpotSet implements ViewSpotSet &#123;</div><div class="line">    private List&lt;WyViewSpot&gt; list = new ArrayList&lt;&gt;();</div><div class="line">    public void add(WyViewSpot obj) &#123;</div><div class="line">        list.add(obj);</div><div class="line">    &#125;</div><div class="line">    public void remove(WyViewSpot obj) &#123;</div><div class="line">        list.remove(obj);</div><div class="line">    &#125;</div><div class="line">    public ViewSpotIterator iterator() &#123;</div><div class="line">        return(new WyViewSpotIterator(list));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽象迭代器：婺源景点迭代器接口</div><div class="line">interface ViewSpotIterator &#123;</div><div class="line">    boolean hasNext();</div><div class="line">    WyViewSpot next();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体迭代器：婺源景点迭代器</div><div class="line">class WyViewSpotIterator implements ViewSpotIterator &#123;</div><div class="line">    private List&lt;WyViewSpot&gt; list;</div><div class="line">    private int index = -1;</div><div class="line">    public WyViewSpotIterator(List&lt;WyViewSpot&gt; list) &#123;</div><div class="line">        this.list = list;</div><div class="line">    &#125;</div><div class="line">    public boolean hasNext() &#123;</div><div class="line">        return index &lt; list.size() - 1;</div><div class="line">    &#125;</div><div class="line">    public WyViewSpot next() &#123;</div><div class="line">        return list.get(++index);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>由于聚合与迭代器的关系非常密切，所以大多数语言在实现聚合类时都提供了迭代器类，因此大数情况下使用语言中已有的聚合类的迭代器就已经够了。</p><hr><h3 id="ANDROID-源码中的实现"><a href="#ANDROID-源码中的实现" class="headerlink" title="ANDROID 源码中的实现"></a>ANDROID 源码中的实现</h3><hr><p>ANDROID 中典型的迭代器模式例子是数据库查询使用 Cursor，当我们使用 SQLiteDatabase 的 query 方法查询数据时，会返回一个 Cursor 游标对象，该游标对象实质就是一个具体的迭代器，我们可以使用它遍历数据库查询所得到的结果集。</p><p>首先定义一个 SQLiteOpenHelper：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class DBHelper extends SQLiteOpenHelper &#123;</div><div class="line"></div><div class="line">    public DBHelper(Context context) &#123;</div><div class="line">        super(context, &quot;DB_AIGE&quot;, null, 1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(SQLiteDatabase db) &#123;</div><div class="line">        db.execSQL(&quot;CREATE TABLE table_aige (_id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, sex TEXT)&quot;);</div><div class="line">        db.execSQL(&quot;INSERT INTO table_aige (name, sex) values (&apos;Aige&apos;, &apos;man&apos;)&quot;);</div><div class="line">        db.execSQL(&quot;INSERT INTO table_aige (name, sex) values (&apos;SMBrother&apos;, &apos;man&apos;)&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>构造 ContentProvider：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public class DataProvider extends ContentProvider &#123;</div><div class="line"></div><div class="line">    private DBHelper dbHelper;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onCreate() &#123;</div><div class="line">        dbHelper = new DBHelper(getContext());</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) &#123;</div><div class="line">        SQLiteDatabase db = dbHelper.getReadableDatabase();</div><div class="line">        return db.query(&quot;table_aige&quot;, projection, null, null, null, null, null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public String getType(@NonNull Uri uri) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 Activity 使用 ContentProvider：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class IteratorActivity extends ListActivity &#123;</div><div class="line"></div><div class="line">    private static final Uri URI = Uri.parse(&quot;content://com.android.androidsamples.dataprovider/table_aige&quot;);</div><div class="line"></div><div class="line">    private static final String[] PROJECTION = new String[]&#123;&quot;name&quot;, &quot;sex&quot;&#125;;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        Cursor cursor = getContentResolver().query(URI, PROJECTION, null, null, null);</div><div class="line"></div><div class="line">        List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;&gt;();</div><div class="line">        cursor.moveToFirst();</div><div class="line">        do &#123;</div><div class="line">            Map&lt;String, String&gt; item = new HashMap&lt;&gt;();</div><div class="line">            item.put(&quot;name&quot;, cursor.getString(0));</div><div class="line">            item.put(&quot;sex&quot;, cursor.getString(1));</div><div class="line">            list.add(item);</div><div class="line">        &#125; while (cursor.moveToNext());</div><div class="line">        cursor.close();</div><div class="line">        setListAdapter(new SimpleAdapter(this, list, android.R.layout.simple_list_item_2,</div><div class="line">                new String[]&#123;&quot;name&quot;, &quot;sex&quot;&#125;, new int[]&#123;android.R.id.text1, android.R.id.text2&#125;));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注册组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;activity android:name=&quot;.iterator.IteratorActivity&quot; /&gt;</div><div class="line">&lt;provider android:authorities=&quot;com.android.androidsamples.dataprovider&quot; </div><div class="line">        android:name=&quot;.iterator.DataProvider&quot;/&gt;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;hr&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;迭代器（Iterator）模
      
    
    </summary>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/categories/PATTERN/"/>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/tags/PATTERN/"/>
    
  </entry>
  
  <entry>
    <title>12 设计模式——备忘录模式</title>
    <link href="http://yoursite.com/2019/08/18/PATTERN/12%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/18/PATTERN/12 设计模式——备忘录模式/</id>
    <published>2019-08-17T17:00:00.000Z</published>
    <updated>2020-03-04T04:55:06.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><hr><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>备忘录（Memento）模式：<strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将该对象恢复到先前保存的状态</strong>。</p><p>其实很多应用软件都使用了该模式，如 Word、记事本、Photoshop、Eclipse 等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 IE 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。</p><p>备忘录模式能记录一个对象的内部状态，当用户后悔时能撤销当前操作，使数据恢复到它原先的状态。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</li><li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li><li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>需要保存一个对象在某一时刻的状态或部分状态。</li><li>如果用一个接口来让其他对象得到这些状态，将会暴露对象的实现细节并破坏对象的封装性，一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态。</li></ul><hr><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><hr><p>模式包含以下主要角色。</p><ul><li>Originator（发起人角色）：负责创建一个备忘录（Memoto），能够记录内部状态，以及恢复原来记录的状态。并且能够决定哪些状态是需要备忘的。</li><li>Memoto（备忘录角色）：将发起人（Originator）对象的内部状态存储起来；并且可以防止发起人（Originator）之外的对象访问备忘录（Memoto）。</li><li>Caretaker（负责人角色）：负责保存备忘录（Memoto），不能对备忘录（Memoto）的内容进行操作和访问，只能将备忘录传递给其他对象。</li></ul><p>其结构图如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-3ab336b83af0aa4f.gif?imageMogr2/auto-orient/strip" alt=""></p><p>备忘录模式的实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public class MementoPattern &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Originator originator = new Originator();</div><div class="line">        Caretaker caretaker = new Caretaker();       </div><div class="line">        originator.setState(&quot;S0&quot;); </div><div class="line">        System.out.println(&quot;初始状态:&quot; + originator.getState());           </div><div class="line">        caretaker.setMemento(originator.createMemento()); // 保存状态      </div><div class="line">        originator.setState(&quot;S1&quot;); </div><div class="line">        System.out.println(&quot;新的状态:&quot; + originator.getState());        </div><div class="line">        originator.restoreMemento(caretaker.getMemento()); // 恢复状态</div><div class="line">        System.out.println(&quot;恢复状态:&quot; + originator.getState());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 备忘录</div><div class="line">class Memento &#123; </div><div class="line">    private String state; </div><div class="line">    public Memento(String state) &#123; </div><div class="line">        this.state=state; </div><div class="line">    &#125;     </div><div class="line">    public void setState(String state) &#123; </div><div class="line">        this.state=state; </div><div class="line">    &#125;</div><div class="line">    public String getState() &#123; </div><div class="line">        return state; </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 发起人</div><div class="line">class Originator &#123; </div><div class="line">    private String state;     </div><div class="line">    public void setState(String state) &#123; </div><div class="line">        this.state=state; </div><div class="line">    &#125;</div><div class="line">    public String getState() &#123; </div><div class="line">        return state; </div><div class="line">    &#125;</div><div class="line">    public Memento createMemento() &#123; </div><div class="line">        return new Memento(state); </div><div class="line">    &#125; </div><div class="line">    public void restoreMemento(Memento m) &#123; </div><div class="line">        this.setState(m.getState()); </div><div class="line">    &#125; </div><div class="line">&#125;</div><div class="line">// 管理者</div><div class="line">class Caretaker &#123; </div><div class="line">    private Memento memento;       </div><div class="line">    public void setMemento(Memento m) &#123; </div><div class="line">        memento=m; </div><div class="line">    &#125;</div><div class="line">    public Memento getMemento() &#123; </div><div class="line">        return memento; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><hr><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>以游戏存档为例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Originator</div><div class="line"> * 这里则是游戏类，游戏类提供存档和读档的功能</div><div class="line"> */</div><div class="line">public class Game &#123;</div><div class="line">    private int mLevel = 1; // 等级</div><div class="line">    private int mCoin = 0;  // 金币数量</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;game&#123;&quot; +</div><div class="line">                &quot;mLevel=&quot; + mLevel +</div><div class="line">                &quot;, mCoin=&quot; + mCoin +</div><div class="line">                &apos;&#125;&apos;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void play() &#123;</div><div class="line">        System.out.println(&quot;升级了&quot;);</div><div class="line">        mLevel++;</div><div class="line">        System.out.println(&quot;当前等级为:&quot; + mLevel);</div><div class="line">        System.out.println(&quot;获得金币:32&quot;);</div><div class="line">        mCoin += 32;</div><div class="line">        System.out.println(&quot;当前金币数量为:&quot; + mCoin);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void exit() &#123;</div><div class="line">        System.out.println(&quot;退出游戏&quot;);</div><div class="line">        System.out.println(&quot;退出游戏时的属性 : &quot; + toString());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 创建备忘录,即游戏存档</div><div class="line">    public Memento createMemento() &#123;</div><div class="line">        Memento memento = new Memento();</div><div class="line">        memento.level = mLevel;</div><div class="line">        memento.coin = mCoin;</div><div class="line">        return memento;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setMemento(Memento memento) &#123;</div><div class="line">        mLevel = memento.level;</div><div class="line">        mCoin = memento.coin;</div><div class="line">        System.out.println(&quot;读取存档信息:&quot; + toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Memento</div><div class="line"> * 负责将游戏类的内部状态存储起来</div><div class="line"> */</div><div class="line">public class Memento &#123;</div><div class="line">    public int level;   // 等级</div><div class="line">    public int coin;    // 金币数量</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Caretaker</div><div class="line"> * 备忘录管理类</div><div class="line"> */</div><div class="line">public class Caretaker &#123;</div><div class="line">    private Memento mMemento;</div><div class="line"></div><div class="line">    public void setMemento(Memento memento) &#123;</div><div class="line">        mMemento = memento;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Memento getMemento() &#123;</div><div class="line">        return mMemento;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>客户端测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void test() &#123;</div><div class="line">    System.out.println(&quot;首次进入游戏&quot;);</div><div class="line">    Game game = new Game();</div><div class="line">    game.play();</div><div class="line">    Memento memento = game.createMemento(); // 创建存档</div><div class="line">    Caretaker caretaker = new Caretaker();</div><div class="line">    caretaker.setMemento(memento);          // 保存存档</div><div class="line">    game.exit();</div><div class="line"></div><div class="line">    System.out.println(&quot;-------------&quot;);</div><div class="line">    System.out.println(&quot;二次进入游戏&quot;);</div><div class="line">    Game secondGame = new Game();</div><div class="line">    secondGame.setMemento(caretaker.getMemento()); // 读取存档</div><div class="line">    secondGame.play(); </div><div class="line">    secondGame.exit();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">首次进入游戏</div><div class="line">升级了</div><div class="line">当前等级为:2</div><div class="line">获得金币:32</div><div class="line">当前金币数量为:32</div><div class="line">退出游戏</div><div class="line">退出游戏时的属性 : game&#123;mLevel=2, mCoin=32&#125;</div><div class="line">-------------</div><div class="line">二次进入游戏</div><div class="line">读取存档信息:game&#123;mLevel=2, mCoin=32&#125;</div><div class="line">升级了</div><div class="line">当前等级为:3</div><div class="line">获得金币:32</div><div class="line">当前金币数量为:64</div><div class="line">退出游戏</div><div class="line">退出游戏时的属性 : game&#123;mLevel=3, mCoin=64&#125;</div></pre></td></tr></table></figure></p><hr><h3 id="ANDROID-源码中的实现"><a href="#ANDROID-源码中的实现" class="headerlink" title="ANDROID 源码中的实现"></a>ANDROID 源码中的实现</h3><hr><p>状态保存是 ANDROID 中备忘录模式的典型使用，主要对应 Activity的两个回调方法 onSaveInstanceState() 和 onRestoreInstanceState()。</p><p>onSaveInstanceState 方法的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">protected void onSaveInstanceState(Bundle outState) &#123;</div><div class="line">    // 存储当前窗口的视图树的状态</div><div class="line">    outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());</div><div class="line"></div><div class="line">    outState.putInt(LAST_AUTOFILL_ID, mLastAutofillId);</div><div class="line">    // 存储 fragment 的状态</div><div class="line">    Parcelable p = mFragments.saveAllState();</div><div class="line">    if (p != null) &#123;</div><div class="line">        outState.putParcelable(FRAGMENTS_TAG, p);</div><div class="line">    &#125;</div><div class="line">    // 存储自动填充的字段</div><div class="line">    if (mAutoFillResetNeeded) &#123;</div><div class="line">        outState.putBoolean(AUTOFILL_RESET_NEEDED, true);</div><div class="line">        getAutofillManager().onSaveInstanceState(outState);</div><div class="line">    &#125;</div><div class="line">    // 如果用户还设置了 Activity 的 ActivityLifecycleCallbacks，</div><div class="line">    // 那么调用这些 ActivityLifecycleCallbacks 的 onSaveInstanceState 进行存储状态</div><div class="line">    getApplication().dispatchActivitySaveInstanceState(this, outState);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上述 onSaveInstanceState 函数中，主要分为如下 3 步：<br>1）存储窗口的视图树的状态；<br>2）存储 Fragment 的状态<br>3）调用 ActivityLifecycleCallbacks 的 onSaveInstanceState 函数进行状态存储。</p><p>我们先看第一步，在这一步将 Window 对象中的视图树中欧冠各个 View 状态存储到 Bundle 中。这样一来，当用户重新进入到该 Activity 时，用户 UI 的结构、状态才会被重新恢复，以此来保证用户界面的一致性。Window 类的具体实现类是 PhoneWindow，其中 saveHierarchyState 方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public Bundle saveHierarchyState() &#123;</div><div class="line">    Bundle outState = new Bundle();</div><div class="line">    if (mContentParent == null) &#123;</div><div class="line">        return outState;</div><div class="line">    &#125;</div><div class="line">    // 通过 SparseArray 类来存储，这相当于一个 key 为整型的 map</div><div class="line">    SparseArray&lt;Parcelable&gt; states = new SparseArray&lt;Parcelable&gt;();</div><div class="line">    // 调用 mContentParent 的 saveHierarchyState 方法，这个 mContentParent 就是调用 Activity 的 </div><div class="line">    // setContentView 函数设置的内容视图，它是内容视图的根节点，在这里存储整棵视图树的结构。</div><div class="line">    mContentParent.saveHierarchyState(states);</div><div class="line">    // 将视图树结构放到 outState 中</div><div class="line">    outState.putSparseParcelableArray(VIEWS_TAG, states);</div><div class="line"></div><div class="line">    // 保存当前界面中获取了焦点的 View</div><div class="line">    // Save the focused view ID.</div><div class="line">    final View focusedView = mContentParent.findFocus();</div><div class="line">    if (focusedView != null &amp;&amp; focusedView.getId() != View.NO_ID) &#123;</div><div class="line">        // 持有焦点的 View 必须要设置 id，否则重新进入该界面时不会恢复它的焦点状态</div><div class="line">        outState.putInt(FOCUSED_ID_TAG, focusedView.getId());</div><div class="line">    &#125;</div><div class="line">    // 存储整个面板的状态</div><div class="line">    // save the panels</div><div class="line">    SparseArray&lt;Parcelable&gt; panelStates = new SparseArray&lt;Parcelable&gt;();</div><div class="line">    savePanelState(panelStates);</div><div class="line">    if (panelStates.size() &gt; 0) &#123;</div><div class="line">        outState.putSparseParcelableArray(PANELS_TAG, panelStates);</div><div class="line">    &#125;</div><div class="line">    // 存储 ActionBar 的状态</div><div class="line">    if (mDecorContentParent != null) &#123;</div><div class="line">        SparseArray&lt;Parcelable&gt; actionBarStates = new SparseArray&lt;Parcelable&gt;();</div><div class="line">        mDecorContentParent.saveToolbarHierarchyState(actionBarStates);</div><div class="line">        outState.putSparseParcelableArray(ACTION_BAR_TAG, actionBarStates);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return outState;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 saveHierarchyState 中，主要时存储了与当前 UI、ActionBar 相关的 View 状态，这里用 mContentParent 来分析。这个 mContentParent 就是我们通过 Activity 的 setContentView 函数设置的内容视图，它是整个内容视图的根节点，存储它层级结构中的 View 状态也就存储了用户界面的状态。mContentParent 是一个 ViewGroup 对象，但是，saveHierarchyState 并不是在 ViewGroup 中，而是在 ViewGroup 的父类 View。</p><p>View 的 saveHierarchyState 方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public void saveHierarchyState(SparseArray&lt;Parcelable&gt; container) &#123;</div><div class="line">    dispatchSaveInstanceState(container);</div><div class="line">&#125;</div><div class="line"></div><div class="line">protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) &#123;</div><div class="line">    // 注意：如果 View 没有设置 id，那么这个 View 的状态将不会被存储。</div><div class="line">    if (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == 0) &#123;</div><div class="line">        mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;</div><div class="line">        // 调用 onSaveInstanceState 获取自身的状态</div><div class="line">        Parcelable state = onSaveInstanceState();</div><div class="line">        if ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == 0) &#123;</div><div class="line">            throw new IllegalStateException(</div><div class="line">                    &quot;Derived class did not call super.onSaveInstanceState()&quot;);</div><div class="line">        &#125;</div><div class="line">        if (state != null) &#123;</div><div class="line">            // 将自身状态放到 container 中，key 为 id、value 为自身状态。</div><div class="line">            container.put(mID, state);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// View 类默认存储的状态为空</div><div class="line">protected Parcelable onSaveInstanceState() &#123;</div><div class="line">    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;</div><div class="line">    ...</div><div class="line">    return BaseSavedState.EMPTY_STATE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 View 类中的 saveHierarchyState 函数调用了 dispatchSaveInstanceState 函数来存储自身的状态，而 ViewGroup 则覆写了 dispatchSaveInstanceState 函数来存储自身以及子视图的状态，函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) &#123;</div><div class="line">    super.dispatchSaveInstanceState(container);</div><div class="line">    final int count = mChildrenCount;</div><div class="line">    final View[] children = mChildren;</div><div class="line">    for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">        View c = children[i];</div><div class="line">        if ((c.mViewFlags &amp; PARENT_SAVE_DISABLED_MASK) != PARENT_SAVE_DISABLED) &#123;</div><div class="line">            c.dispatchSaveInstanceState(container);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>dispatchSaveInstanceState 会首先调用 super 的方法存储自身的状态，然后调用每个子视图的 dispatchSaveInstanceState。</p><blockquote><p>注意：如果 View 没有设置 id，那么这个 View 的状态将不会被存储。设置了这个 id 也要保证在一个 Activity 的布局中必须是唯一的，否则会出现状态覆盖的情况。</p></blockquote><p>这些被存储的状态通过 onSaveInstanceState 函数得到，但在 View 类中我们看到返回的是一个空状态。这就意味着，当我们需要存储 View 状态是，需要覆写 onSaveInstanceState 方法，将要存储的数据放到 Parcelable 对象中，并且将它返回。我们看看 TextView 的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public Parcelable onSaveInstanceState() &#123;</div><div class="line">    Parcelable superState = super.onSaveInstanceState();</div><div class="line">    </div><div class="line">    // 代码省略</div><div class="line">    </div><div class="line">    // 存储 TextView 的 start、end 以及文本内容</div><div class="line">    if (freezesText || hasSelection) &#123;</div><div class="line">        SavedState ss = new SavedState(superState);</div><div class="line"></div><div class="line">        if (freezesText) &#123;</div><div class="line">            if (mText instanceof Spanned) &#123;</div><div class="line">                final Spannable sp = new SpannableStringBuilder(mText);</div><div class="line"></div><div class="line">                if (mEditor != null) &#123;</div><div class="line">                    removeMisspelledSpans(sp);</div><div class="line">                    sp.removeSpan(mEditor.mSuggestionRangeSpan);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ss.text = sp;</div><div class="line">            &#125; else &#123;</div><div class="line">                ss.text = mText.toString();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (hasSelection) &#123;</div><div class="line">            // XXX Should also save the current scroll position!</div><div class="line">            ss.selStart = start;</div><div class="line">            ss.selEnd = end;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 代码省略</div><div class="line"></div><div class="line">        return superState;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>存储完 Window 的视图树状态后，会存储每个 Fragment 的状态，调用它们的 onSaveInstanceState 方法。最后调用 ActivityLifecycleCallbacks 的 onSaveInstanceState。</p><p>P 版本（Android 9）之前，onSaveInstanceState 会在 onStop 之前调用。P 版本（Android 9）之后，onSaveInstanceState 会在 onStop 之后调用。ActivityThread 的 performStopActivity 会调用 callActivityOnStop。callActivityOnStop 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">private void callActivityOnStop(ActivityClientRecord r, boolean saveState, String reason) &#123;</div><div class="line">    // Before P onSaveInstanceState was called before onStop, starting with P it&apos;s</div><div class="line">    // called after. Before Honeycomb state was always saved before onPause.</div><div class="line">    final boolean shouldSaveState = saveState &amp;&amp; !r.activity.mFinished &amp;&amp; r.state == null</div><div class="line">            &amp;&amp; !r.isPreHoneycomb();</div><div class="line">    final boolean isPreP = r.isPreP();</div><div class="line">    if (shouldSaveState &amp;&amp; isPreP) &#123;</div><div class="line">        callActivityOnSaveInstanceState(r);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        r.activity.performStop(false /*preserveWindow*/, reason);</div><div class="line">    &#125; catch (SuperNotCalledException e) &#123;</div><div class="line">        throw e;</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        if (!mInstrumentation.onException(r.activity, e)) &#123;</div><div class="line">            throw new RuntimeException(</div><div class="line">                    &quot;Unable to stop activity &quot;</div><div class="line">                            + r.intent.getComponent().toShortString()</div><div class="line">                            + &quot;: &quot; + e.toString(), e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    r.setState(ON_STOP);</div><div class="line"></div><div class="line">    if (shouldSaveState &amp;&amp; !isPreP) &#123;</div><div class="line">        callActivityOnSaveInstanceState(r);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>callActivityOnSaveInstanceState 方法会将状态信息存储到 ActivityClientRecord 对象的 state 字段中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private void callActivityOnSaveInstanceState(ActivityClientRecord r) &#123;</div><div class="line">    r.state = new Bundle();</div><div class="line">    r.state.setAllowFds(false);</div><div class="line">    if (r.isPersistable()) &#123;</div><div class="line">        r.persistentState = new PersistableBundle();</div><div class="line">        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state,</div><div class="line">                r.persistentState);</div><div class="line">    &#125; else &#123;</div><div class="line">        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 ActivityThread 类的 performLaunchActivity 方法会回调 onCreate，将 ActivityClientRecord 对象的 state 字段传递给 onCreate。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</div><div class="line">    ...</div><div class="line">    if (r.isPersistable()) &#123;</div><div class="line">        mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</div><div class="line">    &#125; else &#123;</div><div class="line">        mInstrumentation.callActivityOnCreate(activity, r.state);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    return activity;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 ActivityThread 类的 handleStartActivity 方法中会调用 callActivityOnRestoreInstanceState 恢复 InstanceState。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void handleStartActivity(ActivityClientRecord r,</div><div class="line">                                PendingTransactionActions pendingActions) &#123;</div><div class="line">    ...</div><div class="line">    // Restore instance state</div><div class="line">    if (pendingActions.shouldRestoreInstanceState()) &#123;</div><div class="line">        if (r.isPersistable()) &#123;</div><div class="line">            if (r.state != null || r.persistentState != null) &#123;</div><div class="line">                mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</div><div class="line">                        r.persistentState);</div><div class="line">            &#125;</div><div class="line">        &#125; else if (r.state != null) &#123;</div><div class="line">            mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>总结：</p><ul><li>Bundle 对应备忘录：Android 的状态，包括视图树状态和 Fragment 状态以及生命周期状态都是通过 Bundle 这个数据结构存储键值对的 Parcel 对象保存的，特别注意一点，对于同一个 Activity的视图放到一个 Bundle 中用 SparceArray（类似 HashMap 不过空间使用效率更高，内部查找二分法，而且键只能是整数）来存储。键：ViewId。值：对应的 Parcel 对象，所以 ViewId 不能重复，不然会覆盖。</li><li>Activity 对应备忘录管理类。严格来说应该是 Activity 中的内部属性。mActivities 实际是一个 ActivityClientRecord 集合，每个 Activity 的信息对应一个 ActivityClientRecord，相应的键是 Token。ActivityClientRecord 的 Bundle 类型的 State 对应 Bundle（备忘录）。</li><li>View 和 Fragment 等都对应 Originator 类，他们都需要伴随 Activity 的生命周期函数 onSaveInstanceState() 和 OnRestoreInstanceState() 通过 Bundle 这种数据结构完成自己状态的管理。</li></ul><hr><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><hr><p>简化版记事本：保存、撤销、重做。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">public class NoteEditText extends AppCompatEditText &#123;</div><div class="line">    public NoteEditText(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public NoteEditText(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public NoteEditText(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 创建备忘录对象，即存储编辑器的指定数据</div><div class="line">    public Memo createMemo() &#123;</div><div class="line">        Memo memo = new Memo();</div><div class="line">        memo.text = getText().toString();</div><div class="line">        memo.cursor = getSelectionStart();</div><div class="line">        return memo;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 从备忘录中恢复数据，设置光标位置</div><div class="line">    public void restore(Memo memo) &#123;</div><div class="line">        setText(memo.text);</div><div class="line">        setSelection(memo.cursor);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Memo &#123;</div><div class="line">    public String text;</div><div class="line">    public int cursor;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 负责管理 Memo 对象</div><div class="line">public class NoteCaretaker &#123;</div><div class="line">    // 最大存储数量</div><div class="line">    private static final int MAX = 30;</div><div class="line">    // 存储 30 条记录</div><div class="line">    private List&lt;Memo&gt; mMemos = new ArrayList&lt;&gt;(MAX);</div><div class="line">    private int mIndex = 0;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 保存备忘录到记录列表中</div><div class="line">     * @param memo Memo</div><div class="line">     */</div><div class="line">    public void saveMemo(Memo memo) &#123;</div><div class="line">        if (mMemos.size() &gt; MAX) &#123;</div><div class="line">            mMemos.remove(0);</div><div class="line">        &#125;</div><div class="line">        mMemos.add(memo);</div><div class="line">        mIndex = mMemos.size() - 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 获取上一个存档信息，相当于撤销功能</div><div class="line">    public Memo getPrevMemo() &#123;</div><div class="line">        mIndex = mIndex &gt; 0 ? --mIndex : mIndex;</div><div class="line">        return mMemos.get(mIndex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 获取下一个存档信息，相当于重做功能</div><div class="line">    public Memo getNextMemo() &#123;</div><div class="line">        mIndex = mIndex &lt; mMemos.size() - 1 ? ++mIndex : mIndex;</div><div class="line">        return mMemos.get(mIndex);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 TestActivity 的代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public class TestActivity extends BaseActivity &#123;</div><div class="line"></div><div class="line">    private NoteEditText mNoteEditText;</div><div class="line">    private TextView mSaveBtn;</div><div class="line">    private ImageView mUndoBtn;</div><div class="line">    private ImageView mRedoBtn;</div><div class="line">    private NoteCaretaker mCaretaker = new NoteCaretaker();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_test);</div><div class="line"></div><div class="line">        initViews();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initViews() &#123;</div><div class="line">        mNoteEditText = findViewById(R.id.et_note);</div><div class="line">        mSaveBtn = findViewById(R.id.btn_save);</div><div class="line">        mUndoBtn = findViewById(R.id.btn_undo);</div><div class="line">        mRedoBtn = findViewById(R.id.btn_redo);</div><div class="line"></div><div class="line">        mSaveBtn.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                mCaretaker.saveMemo(mNoteEditText.createMemo());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        mUndoBtn.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                mNoteEditText.restore(mCaretaker.getPrevMemo());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        mRedoBtn.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                mNoteEditText.restore(mCaretaker.getNextMemo());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>附 res/layout/test.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.xxt.xtest.demo.NoteEditText</div><div class="line">        android:id=&quot;@+id/et_note&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;0dp&quot;</div><div class="line">        android:layout_weight=&quot;1&quot;</div><div class="line">        android:gravity=&quot;left&quot;</div><div class="line">        android:hint=&quot;写点嘛~&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;RelativeLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:paddingLeft=&quot;50dp&quot;</div><div class="line">        android:paddingRight=&quot;50dp&quot;</div><div class="line">        android:paddingBottom=&quot;10dp&quot;&gt;</div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/btn_undo&quot;</div><div class="line">            android:layout_width=&quot;30dp&quot;</div><div class="line">            android:layout_height=&quot;30dp&quot;</div><div class="line">            android:layout_alignParentLeft=&quot;true&quot;</div><div class="line">            android:layout_alignParentStart=&quot;true&quot;</div><div class="line">            android:src=&quot;@drawable/undo&quot;/&gt;</div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/btn_save&quot;</div><div class="line">            android:layout_width=&quot;wrap_content&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:layout_centerInParent=&quot;true&quot;</div><div class="line">            android:text=&quot;保存&quot;</div><div class="line">            android:textSize=&quot;20sp&quot;</div><div class="line">            android:textColor=&quot;#000&quot;/&gt;</div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/btn_redo&quot;</div><div class="line">            android:layout_width=&quot;30dp&quot;</div><div class="line">            android:layout_height=&quot;30dp&quot;</div><div class="line">            android:layout_alignParentRight=&quot;true&quot;</div><div class="line">            android:layout_alignParentEnd=&quot;true&quot;</div><div class="line">            android:src=&quot;@drawable/redo&quot;/&gt;</div><div class="line">    &lt;/RelativeLayout&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a2925a1807fb7c36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;hr&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;备忘录（Memento）模式
      
    
    </summary>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/categories/PATTERN/"/>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/tags/PATTERN/"/>
    
  </entry>
  
  <entry>
    <title>11 设计模式——观察者模式</title>
    <link href="http://yoursite.com/2019/08/17/PATTERN/11%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/17/PATTERN/11 设计模式——观察者模式/</id>
    <published>2019-08-16T17:00:00.000Z</published>
    <updated>2020-03-03T15:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><hr><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>观察者（Observer）模式：<strong>定义对象间的一种一个对多的依赖关系，当一个对象的状态发送改变时，所以依赖于它的对象都得到通知并被自动更新</strong>。这种模式有时又称作发布—订阅模式、模型—视图模式，它是对象行为型模式。</p><p>观察者模式是一个使用率非常高的模式，它最常用的地方是 GUI 系统、订阅——发布系统。因为这个模式的一个重要作用就是解耦，将被观察者和观察者解耦，使得它们之间的依赖性更小，甚至做到毫无依赖。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li><li>目标与观察者之间建立了一套触发机制。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li><li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>关联行为场景。需要注意的是，关联行为是可拆分的，而不是“组合”关系。</li><li>事件多级触发场景。</li><li>跨系统的信息交换场景，如消息队列、事件总线的处理机制。</li></ul><h4 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h4><ul><li>常见的发布—订阅模式。</li><li>ListView 的 Adapter 的 notifyDataSetChanged 更新方法。</li><li>BroadcastReceiver。</li><li>开源库 EventBus。</li><li>RxJava。</li></ul><hr><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><hr><p>观察者模式包含以下主要角色。</p><ul><li>抽象主题（Subject）：也就是被观察（Observable）的角色。它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</li><li>具体主题（ConcreteSubject）：也就是具体被观察者（ConcreteObservable）。它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li><li>抽象观察者（Observer）：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</li><li>具体观察者（ConcreteObserver）：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</li></ul><p>其结构图如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ef244b435a52a1b5.gif?imageMogr2/auto-orient/strip" alt=""></p><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">public class ObserverPattern &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Subject subject = new ConcreteSubject();</div><div class="line">        Observer observer1 = new ConcreteObserver1();</div><div class="line">        Observer observer2 = new ConcreteObserver2();</div><div class="line">        subject.add(observer1);</div><div class="line">        subject.add(observer2);</div><div class="line">        subject.notifyObserver();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//  抽象目标，被观察者</div><div class="line">abstract class Subject &#123;</div><div class="line">    // 观察者集合</div><div class="line">    protected List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;();   </div><div class="line">    // 增加观察者方法</div><div class="line">    public void add(Observer observer) &#123;</div><div class="line">        observers.add(observer);</div><div class="line">    &#125;    </div><div class="line">    // 删除观察者方法</div><div class="line">    public void remove(Observer observer) &#123;</div><div class="line">        observers.remove(observer);</div><div class="line">    &#125;   </div><div class="line">    public abstract void notifyObserver(); // 通知观察者方法</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体目标，具体被观察者</div><div class="line">class ConcreteSubject extends Subject &#123;</div><div class="line">    public void notifyObserver() &#123;</div><div class="line">        System.out.println(&quot;具体目标发生改变...&quot;);</div><div class="line">        System.out.println(&quot;--------------&quot;);       </div><div class="line">       </div><div class="line">        for(Object obs:observers) &#123;</div><div class="line">            // 通知所有观察者</div><div class="line">            ((Observer)obs).response();</div><div class="line">        &#125;</div><div class="line">    &#125;          </div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽象观察者</div><div class="line">interface Observer &#123;</div><div class="line">    void response(); // 反应</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体观察者 1</div><div class="line">class ConcreteObserver1 implements Observer &#123;</div><div class="line">    public void response() &#123;</div><div class="line">        System.out.println(&quot;具体观察者1作出反应！&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体观察者1</div><div class="line">class ConcreteObserver2 implements Observer &#123;</div><div class="line">    public void response() &#123;</div><div class="line">        System.out.println(&quot;具体观察者2作出反应！&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们也可以利用 JDK 中 Observable 类和 Observer 接口实现。观察者实现 Observer 接口，被观察者继承 Observable 类。被观察者通过 Observable 类的 addObserver 方法添加观察者。其代码形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">// 具体观察者</div><div class="line">public class MyObserver implements Observer &#123;</div><div class="line">    private String mName;</div><div class="line"></div><div class="line">    public MyObserver(String name) &#123;</div><div class="line">        mName = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void update(Observable o, Object arg) &#123;</div><div class="line">        System.out.println(mName + &quot;--&gt;&quot; + &quot;update: &quot; + arg);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体被观察者</div><div class="line">public class MyObservable extends Observable &#123;</div><div class="line">    public void sendChangeMsg(String content) &#123;</div><div class="line">        // 方法继承自 Observable，标示状态或是内容发生改变</div><div class="line">        setChanged();</div><div class="line"></div><div class="line">        // 方法继承自 Observable，通知所有观察者，最后会调用每个 Observer 的 update 方法</div><div class="line">        notifyObservers(content);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试</div><div class="line">public class ObserverPatternTest &#123;</div><div class="line">    @Test</div><div class="line">    public void test1() throws Exception &#123;</div><div class="line">        MyObservable myObservable = new MyObservable();</div><div class="line"></div><div class="line">        MyObserver myObserver1 = new MyObserver(&quot;observer-1&quot;);</div><div class="line">        MyObserver myObserver2 = new MyObserver(&quot;observer-2&quot;);</div><div class="line">        myObservable.addObserver(myObserver1);</div><div class="line">        myObservable.addObserver(myObserver2);</div><div class="line"></div><div class="line">        // 发布消息</div><div class="line">        myObservable.sendChangeMsg(&quot;发布更新啦&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>被观察者通过 setChanged() 方法标示改变，通过 notifyObservers 方法通知所有观察者。notifyObservers 方法会遍历所有的观察者 Observer，并调用它们的 update 方法。notifyObservers 方法中的参数就是最后传到观察者 update 方法的参数 Object arg。</p><hr><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>利用观察者模式设计一个程序，分析“人民币汇率”的升值或贬值对进口公司的进口产品成本或出口公司的出口产品收入以及公司的利润率的影响。</p><p>分析：当“人民币汇率”升值时，进口公司的进口产品成本降低且利润率提升，出口公司的出口产品收入降低且利润率降低；当“人民币汇率”贬值时，进口公司的进口产品成本提升且利润率降低，出口公司的出口产品收入提升且利润率提升。</p><p>这里的汇率（Rate）类是抽象目标类，它包含了保存观察者（Company）的 List 和增加/删除观察者的方法，以及有关汇率改变的抽象方法 change(int number)；而人民币汇率（RMBRate）类是具体目标， 它实现了父类的 change(int number) 方法，即当人民币汇率发生改变时通过相关公司；公司（Company）类是抽象观察者，它定义了一个有关汇率反应的抽象方法 response(int number)；进口公司（ImportCompany）类和出口公司（ExportCompany）类是具体观察者类，它们实现了父类的 response(int number) 方法，即当它们接收到汇率发生改变的通知时作为相应的反应。下图所示是其结构图。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-04bef627a9b8c679.gif?imageMogr2/auto-orient/strip" alt=""></p><p>程序代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public class RMBRateTest &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Rate rate = new RMBRate();</div><div class="line">        Company watcher1 = new ImportCompany();</div><div class="line">        Company watcher2 = new ExportCompany();          </div><div class="line">        rate.add(watcher1); </div><div class="line">        rate.add(watcher2);      </div><div class="line">        rate.change(10);</div><div class="line">        rate.change(-9);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽象目标：汇率</div><div class="line">abstract class Rate &#123;</div><div class="line">    protected List&lt;Company&gt; companies = new ArrayList&lt;Company&gt;();   </div><div class="line">    // 增加观察者方法</div><div class="line">    public void add(Company company) &#123;</div><div class="line">        companies.add(company);</div><div class="line">    &#125;</div><div class="line">    // 删除观察者方法</div><div class="line">    public void remove(Company company) &#123;</div><div class="line">        companies.remove(company);</div><div class="line">    &#125;</div><div class="line">    public abstract void change(int number);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体目标：人民币汇率</div><div class="line">class RMBRate extends Rate &#123;</div><div class="line">    public void change(int number) &#123;       </div><div class="line">        for(Company observer : companies) &#123;</div><div class="line">            ((Company) observer).response(number);</div><div class="line">        &#125;       </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽象观察者：公司</div><div class="line">interface Company &#123;</div><div class="line">    void response(int number);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体观察者1：进口公司 </div><div class="line">class ImportCompany implements Company &#123;</div><div class="line">    public void response(int number) &#123;</div><div class="line">        if (number&gt;0) &#123;</div><div class="line">            System.out.println(&quot;人民币汇率升值&quot;+number+&quot;个基点，降低了进口产品成本，提升了进口公司利润率。&quot;); </div><div class="line">        &#125; else if (number&lt;0) &#123;</div><div class="line">            System.out.println(&quot;人民币汇率贬值&quot;+(-number)+&quot;个基点，提升了进口产品成本，降低了进口公司利润率。&quot;); </div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125; </div><div class="line"></div><div class="line">// 具体观察者2：出口公司</div><div class="line">class ExportCompany implements Company &#123;</div><div class="line">    public void response(int number) &#123;</div><div class="line">        if (number&gt;0) &#123;</div><div class="line">            System.out.println(&quot;人民币汇率升值&quot;+number+&quot;个基点，降低了出口产品收入，降低了出口公司的销售利润率。&quot;); </div><div class="line">        &#125; else if(number&lt;0) &#123;</div><div class="line">            System.out.println(&quot;人民币汇率贬值&quot;+(-number)+&quot;个基点，提升了出口产品收入，提升了出口公司的销售利润率。&quot;); </div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">人民币汇率升值10个基点，降低了进口产品成本，提升了进口公司利润率。</div><div class="line">人民币汇率升值10个基点，降低了出口产品收入，降低了出口公司的销售利润率。</div><div class="line">人民币汇率贬值9个基点，提升了进口产品成本，降低了进口公司利润率。</div><div class="line">人民币汇率贬值9个基点，提升了出口产品收入，提升了出口公司的销售利润率。</div></pre></td></tr></table></figure></p><hr><h3 id="ANDROID-源码中的实现"><a href="#ANDROID-源码中的实现" class="headerlink" title="ANDROID 源码中的实现"></a>ANDROID 源码中的实现</h3><hr><p>ListView 是 ANDROID 中最重要的控件之一，而 ListView 最重要的一个功能就是 Adapter。当我们往 ListView 添加数据后，都会调用 Adapter 的 notifyDataSetChanged() 方法，通知界面刷新。这是一个典型的观察者模式案例。我们追踪 notifyDataSetChanged() 这个方法，它定义在 BaseAdapter 中，具体代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public abstract class BaseAdapter implements ListAdapter, SpinnerAdapter &#123;</div><div class="line">    // 数据集（被观察者）</div><div class="line">    private final DataSetObservable mDataSetObservable = new DataSetObservable();</div><div class="line">    </div><div class="line">    // 代码省略</div><div class="line"></div><div class="line">    public void registerDataSetObserver(DataSetObserver observer) &#123;</div><div class="line">        mDataSetObservable.registerObserver(observer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void unregisterDataSetObserver(DataSetObserver observer) &#123;</div><div class="line">        mDataSetObservable.unregisterObserver(observer);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 当数据集变化时，通知所有观察者</div><div class="line">     */</div><div class="line">    public void notifyDataSetChanged() &#123;</div><div class="line">        mDataSetObservable.notifyChanged();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>追踪 mDataSetObservable.notifyChanged() 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 数据集被观察者</div><div class="line"> */</div><div class="line">public class DataSetObservable extends Observable&lt;DataSetObserver&gt; &#123;</div><div class="line">    // 调用每个观察者的 onChange 函数来通知它们被观察者发生了变化</div><div class="line">    public void notifyChanged() &#123;</div><div class="line">        synchronized (mObservers) &#123;</div><div class="line">            for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123;</div><div class="line">                mObservers.get(i).onChanged();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 代码省略</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>而这些观察者是 ListView 通过 setAdapter 方法产生的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void setAdapter(ListAdapter adapter) &#123;</div><div class="line">    // 如果已经有了一个 Adapter，那么先注销该 Adapter 对应的观察者</div><div class="line">    if (mAdapter != null &amp;&amp; mDataSetObserver != null) &#123;</div><div class="line">        mAdapter.unregisterDataSetObserver(mDataSetObserver);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 代码省略</div><div class="line"></div><div class="line">    super.setAdapter(adapter);</div><div class="line"></div><div class="line">    if (mAdapter != null) &#123;</div><div class="line">        mAreAllItemsSelectable = mAdapter.areAllItemsEnabled();</div><div class="line">        mOldItemCount = mItemCount;</div><div class="line">        // 获取数据的数量</div><div class="line">        mItemCount = mAdapter.getCount();</div><div class="line">        checkFocus();</div><div class="line">        // 注意这里：创建一个数据集观察者</div><div class="line">        mDataSetObserver = new AdapterDataSetObserver();</div><div class="line">        // 将这个观察者注册到 Adapter 中，实际上是注册到 DataSetObservable 中</div><div class="line">        mAdapter.registerDataSetObserver(mDataSetObserver);</div><div class="line"></div><div class="line">        // 代码省略</div><div class="line">    &#125; else &#123;</div><div class="line">        // 代码省略</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    requestLayout();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>观察者 AdapterDataSetObserver 定义在 ListView 的父类 AbsListView 中，具体代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public abstract class AbsListView extends AdapterView&lt;ListAdapter&gt; implements TextWatcher,</div><div class="line">        ViewTreeObserver.OnGlobalLayoutListener, Filter.FilterListener,</div><div class="line">        ViewTreeObserver.OnTouchModeChangeListener,</div><div class="line">        RemoteViewsAdapter.RemoteAdapterConnectionCallback &#123;</div><div class="line"></div><div class="line">    // 代码省略</div><div class="line"></div><div class="line">    class AdapterDataSetObserver extends AdapterView&lt;ListAdapter&gt;.AdapterDataSetObserver &#123;</div><div class="line">        @Override</div><div class="line">        public void onChanged() &#123;</div><div class="line">            super.onChanged();</div><div class="line">            if (mFastScroll != null) &#123;</div><div class="line">                mFastScroll.onSectionsChanged();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onInvalidated() &#123;</div><div class="line">            super.onInvalidated();</div><div class="line">            if (mFastScroll != null) &#123;</div><div class="line">                mFastScroll.onSectionsChanged();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通过 super.onChanged() 继续跟踪。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public abstract class AdapterView&lt;T extends Adapter&gt; extends ViewGroup &#123;</div><div class="line"></div><div class="line">    // 代码省略</div><div class="line"></div><div class="line">    class AdapterDataSetObserver extends DataSetObserver &#123;</div><div class="line"></div><div class="line">        private Parcelable mInstanceState = null;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onChanged() &#123;</div><div class="line">            mDataChanged = true;</div><div class="line">            mOldItemCount = mItemCount;</div><div class="line">            mItemCount = getAdapter().getCount();</div><div class="line"></div><div class="line">            // Detect the case where a cursor that was previously invalidated has</div><div class="line">            // been repopulated with new data.</div><div class="line">            if (AdapterView.this.getAdapter().hasStableIds() &amp;&amp; mInstanceState != null</div><div class="line">                    &amp;&amp; mOldItemCount == 0 &amp;&amp; mItemCount &gt; 0) &#123;</div><div class="line">                AdapterView.this.onRestoreInstanceState(mInstanceState);</div><div class="line">                mInstanceState = null;</div><div class="line">            &#125; else &#123;</div><div class="line">                rememberSyncState();</div><div class="line">            &#125;</div><div class="line">            checkFocus();</div><div class="line">            // 重新布局 ListView、GridView 等 AdapterView 组件</div><div class="line">            requestLayout();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 代码省略</div><div class="line">    </div><div class="line">        public void clearSavedState() &#123;</div><div class="line">            mInstanceState = null;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>到这里我们就知道了，当 ListView 的数据发生变化时，调用 Adapter 的 notifyDataSetChanged 函数，这个函数又会调用 DataSetObservable 的 notifyChanged 函数，这个函数会调用所有观察者（AdapterDataSetObserver）的 onChanged 方法，在 onChanged 函数中又会调用 ListView  重新布局的函数使得 ListView 刷新界面。这就是一个观察者模式！</p><hr><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><hr><p>利用观察者模式设计一个学校铃声的事件处理程序。</p><p>分析：在本实例中，学校的“铃”是事件源和目标，“老师”和“学生”是事件监听器和具体观察者，“铃声”是事件类。学生和老师来到学校的教学区，都会注意学校的铃，这叫事件绑定；当上课时间或下课时间到，会触发铃发声，这时会生成“铃声”事件；学生和老师听到铃声会开始上课或下课，这叫事件处理。这个实例非常适合用观察者模式实现，下图给出了学校铃声的事件模型。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-495f8bd557e07c06.gif?imageMogr2/auto-orient/strip" alt=""></p><p>现在用“观察者模式”来实现该事件处理模型。首先，定义一个铃声事件（RingEvent）类，它记录了铃声的类型（上课铃声/下课铃声）；再定义一个学校的铃（BellEventSource）类，它是事件源，是观察者目标类，该类里面包含了监听器容器 listener，可以绑定监听者（学生或老师），并且有产生铃声事件和通知所有监听者的方法；然后，定义一声事件监听者（BellEventListener）类，它是抽象观察者，它包含了铃声事件处理方法 heardBell(RingEvent e)；最后，定义老师类（TeachEventListener）和学生类（StuEventListener），它们是事件监听器，是具体观察者，听到铃声会去上课或下课。下图给出了学校铃声事件处理程序的结构。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4fc93200df08a7c0.gif?imageMogr2/auto-orient/strip" alt=""></p><p>程序代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">public class BellEventTest &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        BellEventSource bell = new BellEventSource();    // 铃（事件源）    </div><div class="line">        bell.addPersonListener(new TeachEventListener()); // 注册监听器（老师）</div><div class="line">        bell.addPersonListener(new StudentEventListener());    // 注册监听器（学生）</div><div class="line">        bell.ring(true);   // 打上课铃声</div><div class="line">        System.out.println(&quot;------------&quot;);</div><div class="line">        bell.ring(false);  // 打下课铃声</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 铃声事件类：用于封装事件源及一些与事件相关的参数</div><div class="line">class RingEvent extends EventObject &#123;   </div><div class="line">    private static final long serialVersionUID = 1L;</div><div class="line">    private boolean sound;    // true 表示上课铃声，false 表示下课铃声</div><div class="line">    public RingEvent(Object source,boolean sound) &#123;</div><div class="line">        super(source);</div><div class="line">        this.sound=sound;</div><div class="line">    &#125;   </div><div class="line">    public void setSound(boolean sound) &#123;</div><div class="line">        this.sound=sound;</div><div class="line">    &#125;</div><div class="line">    public boolean getSound() &#123;</div><div class="line">        return this.sound;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 目标类：事件源，铃</div><div class="line">class BellEventSource &#123;    </div><div class="line">    private List&lt;BellEventListener&gt; listener; // 监听器容器</div><div class="line">    public BellEventSource() &#123; </div><div class="line">        listener = new ArrayList&lt;BellEventListener&gt;();        </div><div class="line">    &#125;</div><div class="line">    // 给事件源绑定监听器 </div><div class="line">    public void addPersonListener(BellEventListener ren) &#123; </div><div class="line">        listener.add(ren); </div><div class="line">    &#125;</div><div class="line">    // 事件触发器：敲钟，当铃声 sound 的值发生变化时，触发事件。</div><div class="line">    public void ring(boolean sound) &#123;</div><div class="line">        String type = sound? &quot;上课铃&quot; : &quot;下课铃&quot;;</div><div class="line">        System.out.println(type+&quot;响！&quot;);</div><div class="line">        RingEvent event = new RingEvent(this, sound);     </div><div class="line">        notifies(event);    // 通知注册在该事件源上的所有监听器                </div><div class="line">    &#125;   </div><div class="line">    // 当事件发生时,通知绑定在该事件源上的所有监听器做出反应（调用事件处理方法）</div><div class="line">    protected void notifies(RingEvent e) &#123; </div><div class="line">        BellEventListener person; </div><div class="line">        Iterator&lt;BellEventListener&gt; iterator = listener.iterator(); </div><div class="line">        while(iterator.hasNext()) &#123; </div><div class="line">            person = iterator.next(); </div><div class="line">            person.heardBell(e); </div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽象观察者类：铃声事件监听器</div><div class="line">interface  BellEventListener extends EventListener &#123;</div><div class="line">    // 事件处理方法，听到铃声</div><div class="line">    void heardBell(RingEvent e);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//具体观察者类：老师事件监听器</div><div class="line">class TeachEventListener implements BellEventListener &#123;</div><div class="line">    public void heardBell(RingEvent e) &#123;        </div><div class="line">        if (e.getSound()) &#123;</div><div class="line">            System.out.println(&quot;老师上课了...&quot;);           </div><div class="line">        &#125; else &#123;</div><div class="line">            System.out.println(&quot;老师下课了...&quot;);   </div><div class="line">        &#125;          </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体观察者类：学生事件监听器</div><div class="line">class StudentEventListener implements BellEventListener &#123;</div><div class="line">    public void heardBell(RingEvent e) &#123;        </div><div class="line">        if (e.getSound()) &#123;</div><div class="line">            System.out.println(&quot;同学们，上课了...&quot;);           </div><div class="line">        &#125; else &#123;</div><div class="line">            System.out.println(&quot;同学们，下课了...&quot;);   </div><div class="line">        &#125;          </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">上课铃响！</div><div class="line">老师上课了...</div><div class="line">同学们，上课了...</div><div class="line">------------</div><div class="line">下课铃响！</div><div class="line">老师下课了...</div><div class="line">同学们，下课了...</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;hr&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;观察者（Observer）模
      
    
    </summary>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/categories/PATTERN/"/>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/tags/PATTERN/"/>
    
  </entry>
  
  <entry>
    <title>10 设计模式——命令模式</title>
    <link href="http://yoursite.com/2019/08/16/PATTERN/10%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/16/PATTERN/10 设计模式——命令模式/</id>
    <published>2019-08-15T17:00:00.000Z</published>
    <updated>2020-03-03T13:39:35.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><hr><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>命令（Command）模式：<strong>将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作</strong>。</p><p>在软件开发系统中，常常出现“方法的请求者”与“方法的实现者”之间存在紧密的耦合关系。这不利于软件功能的扩展与维护。例如，想对行为进行“撤销、重做、记录”等处理都很不方便，因此“如何将方法的请求者与方法的实现者解耦？”变得很重要，命令模式能很好地解决这个问题。</p><p>在现实生活中，这样的例子也很多，例如，电视机遥控器（命令发送者）通过按钮（具体命令）来遥控电视机（命令接收者），还有计算机键盘上的“功能键”等。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>对于大多数请求——响应模式的功能，比较适合使用命令模式。</p><ul><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li><li>系统需要在不同的时间指定请求、将请求排队（如：线程池+工作队列）和执行请求。</li><li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作（比如系统挂掉之后重启做一些恢复操作，还有数据库的事务等）。</li><li>系统需要将一组操作组合在一起，即支持宏命令。</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。</li><li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。</li><li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li><li>方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>可能产生大量具体命令类。因为计对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。</p><hr><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><hr><p>命令模式包含以下主要角色。</p><ul><li>抽象命令类（Command）：声明执行命令的接口，拥有执行命令的抽象方法 execute()。</li><li>具体命令角色（Concrete Command）：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。</li><li>实现者/接收者（Receiver）：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li><li>调用者/请求者（Invoker）：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li></ul><p>其结构图如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-cfc7f6f783091bfa.gif?imageMogr2/auto-orient/strip" alt=""></p><p>命令模式的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public class CommandPattern &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Receiver receiver = new Receiver();</div><div class="line">        Command cmd = new ConcreteCommand(receiver);</div><div class="line">        Invoker invoker = new Invoker(cmd);</div><div class="line">        invoker.call();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 调用者</div><div class="line">class Invoker &#123;</div><div class="line">    private Command command;</div><div class="line">    public Invoker(Command command) &#123;</div><div class="line">        this.command=command;</div><div class="line">    &#125;</div><div class="line">    public void setCommand(Command command) &#123;</div><div class="line">        this.command=command;</div><div class="line">    &#125;</div><div class="line">    public void call() &#123;</div><div class="line">        // 调用具体命令对象的相关方法，执行具体命令</div><div class="line">        command.execute();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽象命令</div><div class="line">interface Command &#123;</div><div class="line">    void execute();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体命令</div><div class="line">class ConcreteCommand implements Command &#123;</div><div class="line">    private Receiver receiver;</div><div class="line">    ConcreteCommand(Receiver receiver) &#123;</div><div class="line">        this.receiver = receiver;</div><div class="line">    &#125;</div><div class="line">    public void execute() &#123;</div><div class="line">        receiver.action();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 接收者</div><div class="line">class Receiver &#123;</div><div class="line">    // 真正执行具体命令逻辑的方法</div><div class="line">    public void action() &#123;</div><div class="line">        System.out.println(&quot;接收者执行具体操作&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><hr><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>用命令模式实现客户去餐馆吃早餐的实例。</p><p>分析：客户去餐馆可选择的早餐有肠粉、河粉和馄饨等，客户可向服务员选择以上早餐中的若干种，服务员将客户的请求交给相关的厨师去做。这里的点早餐相当于“命令”，服务员相当于“调用者”，厨师相当于“接收者”，所以用命令模式实现比较合适。</p><p>首先，定义一个早餐类（Breakfast），它是抽象命令类，有抽象方法 cooking()，说明要做什么；再定义其子类肠粉类（ChangFen）、馄饨类（HunTun）和河粉类（HeFen），它们是具体命令类，实现早餐类的 cooking() 方法，但它们不会具体做，而是交给具体的厨师去做；具体厨师类有肠粉厨师（ChangFenChef）、馄蚀厨师（HunTunChef）和河粉厨师（HeFenChef），他们是命令的接收者，所以把每个厨师类定义为 JFrame 的子类；最后，定义服务员类（Waiter），它接收客户的做菜请求，并发出做菜的命令。客户类是通过服务员类来点菜的，下图所示是其结构图。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-fe94a57ee9420e84.gif?imageMogr2/auto-orient/strip" alt=""></p><p>程序代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line">public class CookingCommand &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Breakfast food1 = new ChangFen();</div><div class="line">        Breakfast food2 = new HunTun();</div><div class="line">        Breakfast food3 = new HeFen();</div><div class="line">        Waiter waiter = new Waiter();</div><div class="line">        waiter.setChangFen(food1);//设置肠粉菜单</div><div class="line">        waiter.setHunTun(food2);  //设置河粉菜单</div><div class="line">        waiter.setHeFen(food3);   //设置馄饨菜单</div><div class="line">        waiter.chooseChangFen();  //选择肠粉</div><div class="line">        waiter.chooseHeFen();     //选择河粉</div><div class="line">        waiter.chooseHunTun();    //选择馄饨</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 调用者：服务员</div><div class="line">class Waiter &#123;</div><div class="line">    private Breakfast changFen, hunTun, heFen;</div><div class="line">    public void setChangFen(Breakfast f) &#123;</div><div class="line">        changFen = f;</div><div class="line">    &#125;</div><div class="line">    public void setHunTun(Breakfast f) &#123;</div><div class="line">        hunTun=f;</div><div class="line">    &#125;</div><div class="line">    public void setHeFen(Breakfast f) &#123;</div><div class="line">        heFen=f;</div><div class="line">    &#125;</div><div class="line">    public void chooseChangFen() &#123;</div><div class="line">        changFen.cooking();</div><div class="line">    &#125;</div><div class="line">    public void chooseHunTun() &#123;</div><div class="line">        hunTun.cooking();</div><div class="line">    &#125;</div><div class="line">    public void chooseHeFen() &#123;</div><div class="line">        heFen.cooking();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽象命令：早餐</div><div class="line">interface Breakfast &#123;</div><div class="line">    void cooking();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体命令：肠粉</div><div class="line">class ChangFen implements Breakfast &#123;</div><div class="line">    private ChangFenChef receiver;</div><div class="line">    ChangFen() &#123;</div><div class="line">        receiver = new ChangFenChef();</div><div class="line">    &#125;</div><div class="line">    public void cooking() &#123;       </div><div class="line">        receiver.cooking();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体命令：馄饨</div><div class="line">class HunTun implements Breakfast &#123;</div><div class="line">    private HunTunChef receiver;</div><div class="line">    HunTun() &#123;</div><div class="line">        receiver=new HunTunChef();</div><div class="line">    &#125;</div><div class="line">    public void cooking() &#123;</div><div class="line">        receiver.cooking();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体命令：河粉</div><div class="line">class HeFen implements Breakfast &#123;</div><div class="line">    private HeFenChef receiver;</div><div class="line">    HeFen() &#123;</div><div class="line">        receiver=new HeFenChef();</div><div class="line">    &#125;</div><div class="line">    public void cooking() &#123;</div><div class="line">        receiver.cooking();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 接收者：肠粉厨师</div><div class="line">class ChangFenChef extends JFrame &#123;   </div><div class="line">    private static final long serialVersionUID = 1L;</div><div class="line">    JLabel l = new JLabel();</div><div class="line">    ChangFenChef() &#123;</div><div class="line">        super(&quot;煮肠粉&quot;);</div><div class="line">        l.setIcon(new ImageIcon(&quot;src/command/ChangFen.jpg&quot;));</div><div class="line">        this.add(l);</div><div class="line">        this.setLocation(30, 30);</div><div class="line">        this.pack();</div><div class="line">        this.setResizable(false);</div><div class="line">        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);   </div><div class="line">    &#125;</div><div class="line">    public void cooking() &#123;</div><div class="line">        this.setVisible(true);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 接收者：馄饨厨师</div><div class="line">class HunTunChef extends JFrame &#123;</div><div class="line">    private static final long serialVersionUID=1L;</div><div class="line">    JLabel l = new JLabel();</div><div class="line">    HunTunChef() &#123;</div><div class="line">        super(&quot;煮馄饨&quot;);</div><div class="line">        l.setIcon(new ImageIcon(&quot;src/command/HunTun.jpg&quot;));</div><div class="line">        this.add(l);</div><div class="line">        this.setLocation(350, 50);</div><div class="line">        this.pack();</div><div class="line">        this.setResizable(false);</div><div class="line">        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    </div><div class="line">    &#125;</div><div class="line">    public void cooking() &#123;</div><div class="line">        this.setVisible(true);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 接收者：河粉厨师</div><div class="line">class HeFenChef extends JFrame &#123;</div><div class="line">    private static final long serialVersionUID=1L;</div><div class="line">    JLabel l = new JLabel();</div><div class="line">    HeFenChef() &#123;</div><div class="line">        super(&quot;煮河粉&quot;);</div><div class="line">        l.setIcon(new ImageIcon(&quot;src/command/HeFen.jpg&quot;));</div><div class="line">        this.add(l);</div><div class="line">        this.setLocation(200, 280);</div><div class="line">        this.pack();</div><div class="line">        this.setResizable(false);</div><div class="line">        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</div><div class="line">    &#125;</div><div class="line">    public void cooking() &#123;</div><div class="line">        this.setVisible(true);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><hr><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><hr><p>命令模式在 GUI 上应用广泛，比如手写签名功能，需要提供撤销或重做等功能。</p><ul><li>首先声明一个抽象接口 IBrush，用它定义不同笔触需要实现的方法。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public interface IBrush &#123;</div><div class="line">    /**</div><div class="line">     * 触点接触时</div><div class="line">     * @param path  路径对象</div><div class="line">     * @param x     当前位置的 x 坐标</div><div class="line">     * @param y     当前位置的 y 坐标</div><div class="line">     */</div><div class="line">    void down(Path path, float x, float y);</div><div class="line">    /**</div><div class="line">     * 触点移动时</div><div class="line">     * @param path  路径对象</div><div class="line">     * @param x     当前位置的 x 坐标</div><div class="line">     * @param y     当前位置的 y 坐标</div><div class="line">     */</div><div class="line">    void move(Path path, float x, float y);</div><div class="line">    /**</div><div class="line">     * 触点离开时</div><div class="line">     * @param path  路径对象</div><div class="line">     * @param x     当前位置的 x 坐标</div><div class="line">     * @param y     当前位置的 y 坐标</div><div class="line">     */</div><div class="line">    void up(Path path, float x, float y);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>为了简便起见，这里只定义两种类型的笔触，一种为普通的线条，另一种为由圆点组成的线条轨迹。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// 普通笔触</div><div class="line">public class NormalBrush implements IBrush &#123;</div><div class="line">    @Override</div><div class="line">    public void down(Path path, float x, float y) &#123;</div><div class="line">        path.moveTo(x, y);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void move(Path path, float x, float y) &#123;</div><div class="line">        path.lineTo(x, y);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void up(Path path, float x, float y) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 圆形笔触</div><div class="line">public class CircleBrush implements IBrush &#123;</div><div class="line">    @Override</div><div class="line">    public void down(Path path, float x, float y) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void move(Path path, float x, float y) &#123;</div><div class="line">        path.addCircle(x, y, 10, Path.Direction.CCW);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void up(Path path, float x, float y) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>对于每一次路径的绘制，都可以有两个命令，一个是绘制命令，另一个是撤销命令，我们将其封装为一个命令接口。注意，这里结合命令模式去构思。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public interface IDraw &#123;</div><div class="line">    /**</div><div class="line">     * 绘制命令</div><div class="line">     * @param canvas  画布对象</div><div class="line">     */</div><div class="line">    void draw(Canvas canvas);</div><div class="line">    /**</div><div class="line">     * 撤销命令</div><div class="line">     */</div><div class="line">    void undo();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>这里只有一种绘制路径方法，即一个具体命令。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class DrawPath implements IDraw &#123;</div><div class="line">    public Path path;      // 需要绘制的路径</div><div class="line">    public Paint paint;    // 绘制画笔</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void draw(Canvas canvas) &#123;</div><div class="line">        canvas.drawPath(path, paint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void undo() &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>需要一个请求者角色（Invoker）来对命令做进一步封装。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">public class DrawInvoker &#123;</div><div class="line">    // 绘制列表</div><div class="line">    private List&lt;DrawPath&gt; drawList = Collections.synchronizedList(new ArrayList&lt;DrawPath&gt;());</div><div class="line">    // 重做列表</div><div class="line">    private List&lt;DrawPath&gt; redoList = Collections.synchronizedList(new ArrayList&lt;DrawPath&gt;());</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 增加一个命令</div><div class="line">     * @param command DrawPath</div><div class="line">     */</div><div class="line">    public void add(DrawPath command) &#123;</div><div class="line">        redoList.clear();</div><div class="line">        drawList.add(command);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 撤销上一步命令</div><div class="line">     */</div><div class="line">    public void undo() &#123;</div><div class="line">        if (drawList.size() &gt; 0) &#123;</div><div class="line">            int index = drawList.size() - 1;</div><div class="line">            DrawPath undo = drawList.get(index);</div><div class="line">            drawList.remove(index);</div><div class="line">            undo.undo();</div><div class="line">            redoList.add(undo);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 重做上一步撤销的命令</div><div class="line">     */</div><div class="line">    public void redo() &#123;</div><div class="line">        if (redoList.size() &gt; 0) &#123;</div><div class="line">            int index = redoList.size() - 1;</div><div class="line">            DrawPath redoCommand = redoList.get(index);</div><div class="line">            redoList.remove(index);</div><div class="line">            drawList.add(redoCommand);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 执行命令</div><div class="line">     */</div><div class="line">    public void execute(Canvas canvas) &#123;</div><div class="line">        if (drawList != null) &#123;</div><div class="line">            for (DrawPath tmp : drawList) &#123;</div><div class="line">                tmp.draw(canvas);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 是否可以重做</div><div class="line">     */</div><div class="line">    public boolean canRedo() &#123;</div><div class="line">        return  redoList.size() &gt; 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 是否可以撤销</div><div class="line">     */</div><div class="line">    public boolean canUndo() &#123;</div><div class="line">        return  drawList.size() &gt; 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>需要一个具体的接收者，这里承担重任的是一个 SurfaceView 对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line">public class DrawCanvas extends SurfaceView implements SurfaceHolder.Callback &#123;</div><div class="line">    // 标识是否可以绘制、绘制线程是否可以运行</div><div class="line">    public boolean isDrawing, isRunning;</div><div class="line"></div><div class="line">    private Bitmap mBitmap;         // 绘制到的位图对象</div><div class="line">    private DrawInvoker mInvoker;   // 绘制命令请求对象</div><div class="line">    private DrawThread mThread;     // 绘制线程</div><div class="line"></div><div class="line">    public DrawCanvas(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mInvoker = new DrawInvoker();</div><div class="line">        mThread = new DrawThread();</div><div class="line"></div><div class="line">        getHolder().addCallback(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void surfaceCreated(SurfaceHolder holder) &#123;</div><div class="line">        isRunning = true;</div><div class="line">        mThread.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123;</div><div class="line">        mBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.RGB_565);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void surfaceDestroyed(SurfaceHolder holder) &#123;</div><div class="line">        boolean retry = true;</div><div class="line">        isRunning = false;</div><div class="line">        while (retry) &#123;</div><div class="line">            try &#123;</div><div class="line">                mThread.join();</div><div class="line">                retry = false;</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 增加一条绘制路径</div><div class="line">     * @param path DrawPath</div><div class="line">     */</div><div class="line">    public void add(DrawPath path) &#123;</div><div class="line">        mInvoker.add(path);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 撤销上一步的绘制</div><div class="line">     */</div><div class="line">    public void undo() &#123;</div><div class="line">        isDrawing = true;</div><div class="line">        mInvoker.undo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 重做上一步撤销的绘制</div><div class="line">     */</div><div class="line">    public void redo() &#123;</div><div class="line">        isDrawing = true;</div><div class="line">        mInvoker.redo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 是否可以重做</div><div class="line">     */</div><div class="line">    public boolean canRedo() &#123;</div><div class="line">        return mInvoker.canRedo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 是否可以撤销</div><div class="line">     */</div><div class="line">    public boolean canUndo() &#123;</div><div class="line">        return mInvoker.canUndo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class DrawThread extends Thread &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            Canvas canvas = null;</div><div class="line">            while (isRunning) &#123;</div><div class="line">                if (isDrawing) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        canvas = getHolder().lockCanvas();</div><div class="line">                        if (mBitmap == null) &#123;</div><div class="line">                            mBitmap = Bitmap.createBitmap(1, 1, Bitmap.Config.ARGB_8888);</div><div class="line">                        &#125;</div><div class="line">                        Canvas c = new Canvas(mBitmap);</div><div class="line">                        c.drawColor(0, PorterDuff.Mode.CLEAR);</div><div class="line"></div><div class="line">                        canvas.drawColor(0, PorterDuff.Mode.CLEAR);</div><div class="line">                        mInvoker.execute(c);</div><div class="line">                        canvas.drawBitmap(mBitmap, 0, 0, null);</div><div class="line">                    &#125; finally &#123;</div><div class="line">                        getHolder().unlockCanvasAndPost(canvas);</div><div class="line">                    &#125;</div><div class="line">                    isDrawing = false;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>最后在 Activity 中整合各个功能模块。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.graphics.Paint;</div><div class="line">import android.graphics.Path;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.view.MotionEvent;</div><div class="line">import android.view.View;</div><div class="line">import android.widget.Button;</div><div class="line"></div><div class="line">import com.xxt.xtest.demo.CircleBrush;</div><div class="line">import com.xxt.xtest.demo.DrawCanvas;</div><div class="line">import com.xxt.xtest.demo.DrawPath;</div><div class="line">import com.xxt.xtest.demo.IBrush;</div><div class="line">import com.xxt.xtest.demo.NormalBrush;</div><div class="line"></div><div class="line">public class TestActivity extends BaseActivity &#123;</div><div class="line">    private DrawCanvas mCanvas; // 绘制画布</div><div class="line">    private DrawPath mPath;     // 路径绘制命令</div><div class="line">    private Paint mPaint;       // 画笔对象</div><div class="line">    private IBrush mBrush;      // 笔触对象</div><div class="line"></div><div class="line">    private Button btnRedo, btnUndo;    // 重做、撤销按钮</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_test);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(0xFFFFFFFF);</div><div class="line">        mPaint.setStrokeWidth(3);</div><div class="line"></div><div class="line">        mBrush = new NormalBrush();</div><div class="line"></div><div class="line">        mCanvas = findViewById(R.id.draw_canvas);</div><div class="line">        mCanvas.setOnTouchListener(new DrawTouchListener());</div><div class="line"></div><div class="line">        btnRedo = findViewById(R.id.redo_btn);</div><div class="line">        btnRedo.setEnabled(false);</div><div class="line">        btnUndo = findViewById(R.id.undo_btn);</div><div class="line">        btnUndo.setEnabled(false);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void onClick(View view) &#123;</div><div class="line">        switch (view.getId()) &#123;</div><div class="line">            case R.id.red_btn:</div><div class="line">                mPaint = new Paint();</div><div class="line">                mPaint.setStrokeWidth(3);</div><div class="line">                mPaint.setColor(0xFFFF0000);</div><div class="line">                break;</div><div class="line">            case R.id.green_btn:</div><div class="line">                mPaint = new Paint();</div><div class="line">                mPaint.setStrokeWidth(3);</div><div class="line">                mPaint.setColor(0xFF00FF00);</div><div class="line">                break;</div><div class="line">            case R.id.blue_btn:</div><div class="line">                mPaint = new Paint();</div><div class="line">                mPaint.setStrokeWidth(3);</div><div class="line">                mPaint.setColor(0xFF0000FF);</div><div class="line">                break;</div><div class="line">            case R.id.normal_brush_btn:</div><div class="line">                mBrush = new NormalBrush();</div><div class="line">                break;</div><div class="line">            case R.id.circle_brush_btn:</div><div class="line">                mBrush = new CircleBrush();</div><div class="line">                break;</div><div class="line">            case R.id.undo_btn:</div><div class="line">                mCanvas.undo();</div><div class="line">                if (!mCanvas.canUndo()) &#123;</div><div class="line">                    btnUndo.setEnabled(false);</div><div class="line">                &#125;</div><div class="line">                btnRedo.setEnabled(true);</div><div class="line">                break;</div><div class="line">            case R.id.redo_btn:</div><div class="line">                mCanvas.redo();</div><div class="line">                if (!mCanvas.canRedo()) &#123;</div><div class="line">                    btnRedo.setEnabled(false);</div><div class="line">                &#125;</div><div class="line">                btnUndo.setEnabled(true);</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class DrawTouchListener implements View.OnTouchListener &#123;</div><div class="line">        @Override</div><div class="line">        public boolean onTouch(View v, MotionEvent event) &#123;</div><div class="line">            if (MotionEvent.ACTION_DOWN == event.getAction()) &#123;</div><div class="line">                mPath = new DrawPath();</div><div class="line">                mPath.paint = mPaint;</div><div class="line">                mPath.path = new Path();</div><div class="line">                mBrush.down(mPath.path, event.getX(), event.getY());</div><div class="line">            &#125; else if (MotionEvent.ACTION_MOVE == event.getAction()) &#123;</div><div class="line">                mBrush.move(mPath.path, event.getX(), event.getY());</div><div class="line">            &#125; else if (MotionEvent.ACTION_UP == event.getAction()) &#123;</div><div class="line">                mBrush.up(mPath.path, event.getX(), event.getY());</div><div class="line">                mCanvas.add(mPath);</div><div class="line">                mCanvas.isDrawing = true;</div><div class="line">                btnUndo.setEnabled(true);</div><div class="line">                btnRedo.setEnabled(false);</div><div class="line">            &#125;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>res/layout/act_test.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line">    &lt;com.xxt.xtest.demo.DrawCanvas</div><div class="line">        android:id=&quot;@+id/draw_canvas&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;0dp&quot;</div><div class="line">        android:layout_weight=&quot;1&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;&gt;</div><div class="line">        &lt;Button</div><div class="line">            android:id=&quot;@+id/red_btn&quot;</div><div class="line">            android:layout_width=&quot;0dp&quot;</div><div class="line">            android:layout_weight=&quot;1&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:onClick=&quot;onClick&quot;</div><div class="line">            android:textColor=&quot;#FF0000&quot;</div><div class="line">            android:text=&quot;红色&quot; /&gt;</div><div class="line">        &lt;Button</div><div class="line">            android:id=&quot;@+id/green_btn&quot;</div><div class="line">            android:layout_width=&quot;0dp&quot;</div><div class="line">            android:layout_weight=&quot;1&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:onClick=&quot;onClick&quot;</div><div class="line">            android:textColor=&quot;#00FF00&quot;</div><div class="line">            android:text=&quot;绿色&quot; /&gt;</div><div class="line">        &lt;Button</div><div class="line">            android:id=&quot;@+id/blue_btn&quot;</div><div class="line">            android:layout_width=&quot;0dp&quot;</div><div class="line">            android:layout_weight=&quot;1&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:onClick=&quot;onClick&quot;</div><div class="line">            android:textColor=&quot;#0000FF&quot;</div><div class="line">            android:text=&quot;蓝色&quot; /&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;&gt;</div><div class="line">        &lt;Button</div><div class="line">            android:id=&quot;@+id/normal_brush_btn&quot;</div><div class="line">            android:layout_width=&quot;0dp&quot;</div><div class="line">            android:layout_weight=&quot;1&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:onClick=&quot;onClick&quot;</div><div class="line">            android:text=&quot;普通笔刷&quot; /&gt;</div><div class="line">        &lt;Button</div><div class="line">            android:id=&quot;@+id/circle_brush_btn&quot;</div><div class="line">            android:layout_width=&quot;0dp&quot;</div><div class="line">            android:layout_weight=&quot;1&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:onClick=&quot;onClick&quot;</div><div class="line">            android:text=&quot;圆形笔刷&quot; /&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;&gt;</div><div class="line">        &lt;Button</div><div class="line">            android:id=&quot;@+id/undo_btn&quot;</div><div class="line">            android:layout_width=&quot;0dp&quot;</div><div class="line">            android:layout_weight=&quot;1&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:onClick=&quot;onClick&quot;</div><div class="line">            android:text=&quot;撤销&quot; /&gt;</div><div class="line">        &lt;Button</div><div class="line">            android:id=&quot;@+id/redo_btn&quot;</div><div class="line">            android:layout_width=&quot;0dp&quot;</div><div class="line">            android:layout_weight=&quot;1&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:onClick=&quot;onClick&quot;</div><div class="line">            android:text=&quot;重做&quot; /&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>效果图如下</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-57d2cfc82b98e8cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;hr&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;命令（Command）模式：
      
    
    </summary>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/categories/PATTERN/"/>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/tags/PATTERN/"/>
    
  </entry>
  
  <entry>
    <title>09 设计模式——解释器模式</title>
    <link href="http://yoursite.com/2019/08/15/PATTERN/09%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/15/PATTERN/09 设计模式——解释器模式/</id>
    <published>2019-08-14T17:00:00.000Z</published>
    <updated>2020-03-03T05:02:39.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>参考链接：<br><a href="https://www.jianshu.com/p/331f47bb8e26" target="_blank" rel="external">设计模式 | 解释器模式及典型应用</a><br><a href="http://c.biancheng.net/view/1402.html" target="_blank" rel="external">解释器模式（详解版）</a></p><hr><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>解释器（Interpreter）模式：<strong>给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文</strong>。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>在软件开发中，会遇到有些问题多次重复出现，而且有一定的相似性和规律性。如果将它们归纳成一种简单的语言，那么这些问题实例将是该语言的一些句子，这样就可以用“编译原理”中的解释器模式来实现了。</p><p>虽然使用解释器模式的实例不是很多，但对于满足以上特点，且对运行效率要求不是很高的应用实例，如果用解释器模式来实现，其效果是非常好的。比如<strong>正则表达式、XML文档解释</strong>等领域。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。</li><li>容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。</li><li>会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。</li><li>可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。</li></ul><hr><h3 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h3><hr><h4 id="文法、句子、语法树"><a href="#文法、句子、语法树" class="headerlink" title="文法、句子、语法树"></a>文法、句子、语法树</h4><p>解释器模式常用于对简单语言的编译或分析实例中，为了掌握好它的结构与实现，必须先了解编译原理中的“文法、句子、语法树”等相关概念。</p><h5 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h5><p>文法是用于描述语言的语法结构的形式规则。没有规矩不成方圆，例如，有些人认为完美爱情的准则是“相互吸引、感情专一、任何一方都没有恋爱经历”，虽然最后一条准则较苛刻，但任何事情都要有规则，语言也一样，不管它是机器语言还是自然语言，都有它自己的文法规则。例如，中文中的“句子”的文法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">〈主语〉::=〈代词〉|〈名词〉</div><div class="line">〈谓语〉::=〈动词〉</div><div class="line">〈宾语〉::=〈代词〉|〈名词〉</div><div class="line">〈代词〉你|我|他</div><div class="line">〈名词〉7大学生I筱霞I英语</div><div class="line">〈动词〉::=是|学习</div></pre></td></tr></table></figure></p><p>这里的符号“::=”表示“定义为”的意思，用“〈”和“〉”括住的是非终结符，没有括住的是终结符。</p><h5 id="句子"><a href="#句子" class="headerlink" title="句子"></a>句子</h5><p>句子是语言的基本单位，是语言集中的一个元素，它由终结符构成，能由“文法”推导出。例如，上述文法可以推出“我是大学生”，所以它是句子。</p><h5 id="语法树"><a href="#语法树" class="headerlink" title="语法树"></a>语法树</h5><p>语法树是句子结构的一种树型表示，它代表了句子的推导结果，它有利于理解句子语法结构的层次。下图所示是“我是大学生”的语法树。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7e95a18623742e1e.gif?imageMogr2/auto-orient/strip" alt=""></p><h4 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>解释器模式包含以下主要角色。</p><ul><li>抽象表达式（Abstract Expression）：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</li><li>终结符表达式（Terminal    Expression）：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</li><li>非终结符表达式（Nonterminal Expression）：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</li><li>环境（Context）：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</li><li>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d96ee97e5419f1a7.gif?imageMogr2/auto-orient/strip" alt="解释器模式的结构图"></p><h4 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>解释器模式实现的关键是定义文法规则、设计终结符类与非终结符类、画出结构图，必要时构建语法树，其代码结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 抽象表达式类</div><div class="line">interface AbstractExpression &#123;</div><div class="line">    public Object interpret(String info);    // 解释方法</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 终结符表达式类</div><div class="line">class TerminalExpression implements AbstractExpression &#123;</div><div class="line">    public Object interpret(String info) &#123;</div><div class="line">        // 对终结符表达式的处理</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 非终结符表达式类</div><div class="line">class NonterminalExpression implements AbstractExpression &#123;</div><div class="line">    private AbstractExpression exp1;</div><div class="line">    private AbstractExpression exp2;</div><div class="line">    public Object interpret(String info) &#123;</div><div class="line">        // 非对终结符表达式的处理</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 环境类</div><div class="line">class Context &#123;</div><div class="line">    private AbstractExpression exp;</div><div class="line">    public Context() &#123;</div><div class="line">        // 数据初始化</div><div class="line">    &#125;</div><div class="line">    public void operation(String info) &#123;</div><div class="line">        // 调用相关表达式类的解释方法</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><hr><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>需求：比如算数表达式 m + n + p。代表数字的m、n、p三个字符看成终结符号，+ 看做非终结符号。</p><p>1、抽象的算术运算解释器，为所有解释器共性的提取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public abstract class ArithmeticExpression &#123;</div><div class="line">    /**</div><div class="line">     * 抽象的解析方法</div><div class="line">     * 具体的解析逻辑由具体的子类实现</div><div class="line">     * @return 解析得到具体的值</div><div class="line">     */</div><div class="line">    public abstract int interpret();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>2、数字解释器，仅仅为了解释数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class NumExpression extends ArithmeticExpression &#123;</div><div class="line">    private int num;</div><div class="line"></div><div class="line">    public NumExpression(int num) &#123;</div><div class="line">        this.num = num;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int interpret() &#123;</div><div class="line">        return num;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>3、运算符号抽象解释器，为所有运算符号解释器共性的提取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public abstract class OperatorExpression extends ArithmeticExpression &#123;</div><div class="line">    // 声明两个成员变量存储运算符号两边的数字解释器</div><div class="line">    protected ArithmeticExpression exp1, exp2;</div><div class="line"></div><div class="line">    public OperatorExpression(ArithmeticExpression exp1, ArithmeticExpression exp2) &#123;</div><div class="line">        this.exp1 = exp1;</div><div class="line">        this.exp2 = exp2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>4、加法运算抽象解释器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class AdditionExpression extends OperatorExpression &#123;</div><div class="line">    public AdditionExpression(ArithmeticExpression exp1, ArithmeticExpression exp2) &#123;</div><div class="line">        super(exp1, exp2);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int interpret() &#123;</div><div class="line">        return exp1.interpret() + exp2.interpret();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>5、处理与解释相关的一些业务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class Calculator &#123;</div><div class="line">    // 声明一个 Stack 栈存储并操作所有相关的解释器</div><div class="line">    private Stack&lt;ArithmeticExpression&gt; mExpStack = new Stack&lt;&gt;();</div><div class="line"></div><div class="line">    public Calculator(String expression) &#123;</div><div class="line">        // 声明两个 TerminalExpression 类型的临时变量，存储运算符左右两边的数字解释器</div><div class="line">        ArithmeticExpression exp1, exp2;</div><div class="line"></div><div class="line">        String[] elements = expression.split(&quot; &quot;);</div><div class="line"></div><div class="line">        // 循环遍历表达式元素数组</div><div class="line">        for (int i = 0; i &lt; elements.length; i++) &#123;</div><div class="line">            // 判断运算符号</div><div class="line">            switch (elements[i].charAt(0)) &#123;</div><div class="line">                case &apos;+&apos;:   // 如果是加号</div><div class="line">                    // 将栈中的解释器弹出作为运算符号右边的解释器</div><div class="line">                    exp1 = mExpStack.pop();</div><div class="line">                    // 同时将运算符号数组下标下一个元素构造为一个数字解释器</div><div class="line">                    exp2 = new NumExpression(Integer.valueOf(elements[++i]));</div><div class="line">                    // 通过尚明两个数字解释器构造加法运算解释器</div><div class="line">                    mExpStack.push(new AdditionExpression(exp1, exp2));</div><div class="line">                    break;    </div><div class="line">                default:    // 如果是数字</div><div class="line">                    // 直接构造数字解释器并压入栈</div><div class="line">                    mExpStack.push(new NumExpression(Integer.valueOf(elements[i])));</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int calculate() &#123;</div><div class="line">        return mExpStack.pop().interpret();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>6、客户类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Calculator calculator = new Calculator(&quot;1 + 2 + 3 + 10&quot;);</div><div class="line">        System.out.println(calculator.calculate());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>此时只是定义了加法运算，如果需要增加减法运算，则可以在 Calculator 中增加以下分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">case &apos;-&apos;:   //如果是减号</div><div class="line">    exp1 = mExpStack.pop();</div><div class="line">    exp2 = new NumExpression(Integer.valueOf(elements[++i]));</div><div class="line">    mExpStack.push(new SubtractionExpression(exp1, exp2));</div><div class="line">    break;</div></pre></td></tr></table></figure></p><p>此时，在 Client 中就可以开始使用了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Calculator calculator = new Calculator(&quot;1 - 2 - 3 + 10&quot;);</div><div class="line">        System.out.println(calculator.calculate());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><hr><h3 id="ANDROID-源码中的实现"><a href="#ANDROID-源码中的实现" class="headerlink" title="ANDROID 源码中的实现"></a>ANDROID 源码中的实现</h3><hr><p>AndroidManifest.xml 配置文件的读取。源代码追踪关键词：PackageParser 类的 parseSplitApk()、parseSplitApplication() 方法。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-db1c250de134f85f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="parseSplitApplication"></p><hr><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><hr><p>用解释器模式设计一个“韶粵通”公交车卡的读卡器程序。</p><p>说明：假如“韶粵通”公交车读卡器可以判断乘客的身份，如果是“韶关”或者“广州”的“老人” “妇女”“儿童”就可以免费乘车，其他人员乘车一次扣 2 元。</p><p>分析：本实例用“解释器模式”设计比较适合，首先设计其文法规则如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;expression&gt; ::= &lt;city&gt;的&lt;person&gt;</div><div class="line">&lt;city&gt; ::= 韶关|广州</div><div class="line">&lt;person&gt; ::= 老人|妇女|儿童</div></pre></td></tr></table></figure></p><p>然后，根据文法规则按以下步骤设计公交车卡的读卡器程序的类图。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b44052f9073ec65a.gif?imageMogr2/auto-orient/strip" alt=""></p><p>程序代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">/*文法规则</div><div class="line">  &lt;expression&gt; ::= &lt;city&gt;的&lt;person&gt;</div><div class="line">  &lt;city&gt; ::= 韶关|广州</div><div class="line">  &lt;person&gt; ::= 老人|妇女|儿童</div><div class="line">*/</div><div class="line">public class InterpreterPatternDemo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Context bus = new Context();</div><div class="line">        bus.freeRide(&quot;韶关的老人&quot;);</div><div class="line">        bus.freeRide(&quot;韶关的年轻人&quot;);</div><div class="line">        bus.freeRide(&quot;广州的妇女&quot;);</div><div class="line">        bus.freeRide(&quot;广州的儿童&quot;);</div><div class="line">        bus.freeRide(&quot;山东的儿童&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽象表达式类</div><div class="line">interface Expression &#123;</div><div class="line">    public boolean interpret(String info);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 终结符表达式类</div><div class="line">class TerminalExpression implements Expression &#123;</div><div class="line">    private Set&lt;String&gt; set = new HashSet&lt;String&gt;();</div><div class="line">    public TerminalExpression(String[] data) &#123;</div><div class="line">        for(int i=0; i&lt;data.length; i++) set.add(data[i]);</div><div class="line">    &#125;</div><div class="line">    public boolean interpret(String info) &#123;</div><div class="line">        if (set.contains(info)) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 非终结符表达式类</div><div class="line">class AndExpression implements Expression &#123;</div><div class="line">    private Expression city;    </div><div class="line">    private Expression person;</div><div class="line">    public AndExpression(Expression city,Expression person) &#123;</div><div class="line">        this.city=city;</div><div class="line">        this.person=person;</div><div class="line">    &#125;</div><div class="line">    public boolean interpret(String info) &#123;</div><div class="line">        String s[] = info.split(&quot;的&quot;);       </div><div class="line">        return city.interpret(s[0]) &amp;&amp; person.interpret(s[1]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 环境类</div><div class="line">class Context &#123;</div><div class="line">    private String[] cities = &#123;&quot;韶关&quot;,&quot;广州&quot;&#125;;</div><div class="line">    private String[] persons = &#123;&quot;老人&quot;,&quot;妇女&quot;,&quot;儿童&quot;&#125;;</div><div class="line">    private Expression cityPerson;</div><div class="line">    public Context() &#123;</div><div class="line">        Expression city = new TerminalExpression(cities);</div><div class="line">        Expression person = new TerminalExpression(persons);</div><div class="line">        cityPerson = new AndExpression(city,person);</div><div class="line">    &#125;</div><div class="line">    public void freeRide(String info) &#123;</div><div class="line">        boolean ok = cityPerson.interpret(info);</div><div class="line">        if (ok) System.out.println(&quot;您是&quot;+info+&quot;，您本次乘车免费！&quot;);</div><div class="line">        else System.out.println(info+&quot;，您不是免费人员，本次乘车扣费2元！&quot;);   </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">您是韶关的老人，您本次乘车免费！</div><div class="line">韶关的年轻人，您不是免费人员，本次乘车扣费2元！</div><div class="line">您是广州的妇女，您本次乘车免费！</div><div class="line">您是广州的儿童，您本次乘车免费！</div><div class="line">山东的儿童，您不是免费人员，本次乘车扣费2元！</div></pre></td></tr></table></figure></p><h4 id="数学公式解析器"><a href="#数学公式解析器" class="headerlink" title="数学公式解析器"></a>数学公式解析器</h4><p>在项目开发中，如果要对数据表达式进行分析与计算，无须再用解释器模式进行设计了，Java 提供了以下强大的数学公式解析器：Expression4J、MESP(Math Expression String Parser) 和 Jep 等，它们可以解释一些复杂的文法，功能强大，使用简单。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class JepDemo &#123;</div><div class="line">    public static void main(String[] args) throws JepException &#123;</div><div class="line">        Jep jep = new Jep();</div><div class="line">        // 定义要计算的数据表达式</div><div class="line">        String 存款利息 = &quot;本金*利率*时间&quot;;</div><div class="line">        // 给相关变量赋值</div><div class="line">        jep.addVariable(&quot;本金&quot;,10000);</div><div class="line">        jep.addVariable(&quot;利率&quot;,0.038);</div><div class="line">        jep.addVariable(&quot;时间&quot;,2);</div><div class="line">        jep.parse(存款利息);    // 解析表达式</div><div class="line">        Object accrual=jep.evaluate();    // 计算</div><div class="line">        System.out.println(&quot;存款利息：&quot; + accrual);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">存款利息：760.0</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;参考链接：&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/331f47bb8e26&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;设计
      
    
    </summary>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/categories/PATTERN/"/>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/tags/PATTERN/"/>
    
  </entry>
  
  <entry>
    <title>08 设计模式——责任链模式</title>
    <link href="http://yoursite.com/2019/08/14/PATTERN/08%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/14/PATTERN/08 设计模式——责任链模式/</id>
    <published>2019-08-13T17:00:00.000Z</published>
    <updated>2020-03-02T18:21:41.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><hr><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>责任链模式：<strong>使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连城一条链，并沿着这条链传递该请求，直到有对象处理它为止</strong>。</p><p>它是行为型设计模式之一。我们将多个节点首尾相连构成的模型称为链，而每个节点都可以拆开再连接。因此，链式结构具有很好的灵活性。将这样一种结构应用于编程领域，将每一个节点看作是一个对象，每一个对象拥有不同的处理逻辑，将一个请求从链式的首端发出，沿着链的路径依次传递给每一个节点对象，直至有对象处理这个请求为止。我们将这样的一种模式称为<strong>责任链模式</strong>。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>多个对象可以处理同一请求，但具体由哪个对象处理则在运行时动态决定。<br>在请求处理者不明确的情况下向多个对象中的一个提交一个请求。<br>需要动态指定一组对象处理请求。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong>：对请求者和处理者关系解耦，提高代码的灵活性。<br><strong>缺点</strong>：如果处理者太多，那么遍历必定会影响性能。</p><h4 id="UML-关系图"><a href="#UML-关系图" class="headerlink" title="UML 关系图"></a>UML 关系图</h4><h5 id="简化版-UML-类图"><a href="#简化版-UML-类图" class="headerlink" title="简化版 UML 类图"></a>简化版 UML 类图</h5><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e1892ae495a60100.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>根据类图我们可以得出如下简化版的通用模板代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">// 抽象处理者</div><div class="line">abstract class Handler &#123;</div><div class="line">    protected Handler successor;    // 下一个节点的处理者</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 请求处理</div><div class="line">     * @param condition 请求条件</div><div class="line">     */</div><div class="line">    public abstract void handleRequest(String condition);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体的处理者 1</div><div class="line">class ConcreteHandler1 extends Handler &#123;</div><div class="line">    @Override</div><div class="line">    public void handleRequest(String condition) &#123;</div><div class="line">        if (&quot;ConcreteHandler1&quot;.equals(condition)) &#123;</div><div class="line">            System.out.println(&quot;ConcreteHandler1 handled&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            successor.handleRequest(condition);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体的处理者 2</div><div class="line">class ConcreteHandler2 extends Handler &#123;</div><div class="line">    @Override</div><div class="line">    public void handleRequest(String condition) &#123;</div><div class="line">        if (&quot;ConcreteHandler2&quot;.equals(condition)) &#123;</div><div class="line">            System.out.println(&quot;ConcreteHandler2 handled&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            successor.handleRequest(condition);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 客户类</div><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ConcreteHandler1 handler1 = new ConcreteHandler1();</div><div class="line">        ConcreteHandler2 handler2 = new ConcreteHandler2();</div><div class="line">        handler1.successor = handler2;</div><div class="line">        handler2.successor = handler1;</div><div class="line">        handler1.handleRequest(&quot;ConcreteHandler2&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>角色介绍：</p><ul><li>Handler：抽象处理者角色，声明一个请求处理的方法，并在其中保持一个对下一个处理节点 Handler 对象的引用。</li><li>ConcreteHandler：具体处理者角色，对请求进行处理，如果不能处理则将该请求转发给下一个节点上的处理对象。</li></ul><h5 id="完整版-UML-类图"><a href="#完整版-UML-类图" class="headerlink" title="完整版 UML 类图"></a>完整版 UML 类图</h5><p>上面的请求形式为固定的字符串，处理规则为该字符串是否与之匹配。然而在大多数情况下，责任链中的请求和对应的处理规则是不尽相同的，在这种情况下可以将请求进行封装，同时对请求的处理规则也进行封装作为一个独立的对象。类图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-bb2f101a9bf496a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对应模板代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line">// 抽象处理者</div><div class="line">abstract class AbstractHandler &#123;</div><div class="line">    protected AbstractHandler nextHandler;    // 下一个节点上的处理者对象</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 处理请求</div><div class="line">     * @param request 请求对象</div><div class="line">     */</div><div class="line">    public final void handleRequest(AbstractRequest request) &#123;</div><div class="line">        if (getHandlerLevel() == request.getRequestLevel()) &#123;</div><div class="line">            // 一致则由该处理对象处理</div><div class="line">            handle(request);</div><div class="line">        &#125; else &#123;</div><div class="line">            // 否则将该请求转发给下一个节点上的请求对象</div><div class="line">            if (nextHandler != null) &#123;</div><div class="line">                nextHandler.handleRequest(request);</div><div class="line">            &#125; else &#123;</div><div class="line">                System.out.println(&quot;All of handler can not handle the request&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected abstract int getHandlerLevel();</div><div class="line">    // 每个处理者对象的具体处理方式</div><div class="line">    protected abstract void handle(AbstractRequest request);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽象请求者</div><div class="line">abstract class AbstractRequest &#123;</div><div class="line">    private Object obj; // 处理对象</div><div class="line"></div><div class="line">    public AbstractRequest(Object obj) &#123;</div><div class="line">        this.obj = obj;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Object getContent() &#123;</div><div class="line">        return obj;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 获取请求级别</div><div class="line">    public abstract int getRequestLevel();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体处理者</div><div class="line">class Handler1 extends AbstractHandler &#123;</div><div class="line">    @Override</div><div class="line">    protected int getHandlerLevel() &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void handle(AbstractRequest request) &#123;</div><div class="line">        System.out.println(&quot;Handler1 handle request: &quot;</div><div class="line">                + request.getRequestLevel());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Handler2 extends AbstractHandler &#123;</div><div class="line">    @Override</div><div class="line">    protected int getHandlerLevel() &#123;</div><div class="line">        return 2;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void handle(AbstractRequest request) &#123;</div><div class="line">        System.out.println(&quot;Handler2 handle request: &quot;</div><div class="line">                + request.getRequestLevel());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Handler3 extends AbstractHandler &#123;</div><div class="line">    @Override</div><div class="line">    protected int getHandlerLevel() &#123;</div><div class="line">        return 3;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void handle(AbstractRequest request) &#123;</div><div class="line">        System.out.println(&quot;Handler3 handle request: &quot;</div><div class="line">                + request.getRequestLevel());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体请求者</div><div class="line">class ConcreteRequest1 extends AbstractRequest &#123;</div><div class="line">    public ConcreteRequest1(Object obj) &#123;</div><div class="line">        super(obj);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public int getRequestLevel() &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ConcreteRequest2 extends AbstractRequest &#123;</div><div class="line">    public ConcreteRequest2(Object obj) &#123;</div><div class="line">        super(obj);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public int getRequestLevel() &#123;</div><div class="line">        return 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ConcreteRequest3 extends AbstractRequest &#123;</div><div class="line">    public ConcreteRequest3(Object obj) &#123;</div><div class="line">        super(obj);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public int getRequestLevel() &#123;</div><div class="line">        return 3;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面是客户类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // 构造 3 个处理者对象</div><div class="line">        AbstractHandler handler1 = new Handler1();</div><div class="line">        AbstractHandler handler2 = new Handler2();</div><div class="line">        AbstractHandler handler3 = new Handler3();</div><div class="line">        // 设置当前处理者对象的下一个节点的处理者对象</div><div class="line">        handler1.nextHandler = handler2;</div><div class="line">        handler2.nextHandler = handler3;</div><div class="line">        // 构造 3 个请求者对象</div><div class="line">        AbstractRequest request1 = new ConcreteRequest1(&quot;Request1&quot;);</div><div class="line">        AbstractRequest request2 = new ConcreteRequest2(&quot;Request2&quot;);</div><div class="line">        AbstractRequest request3 = new ConcreteRequest3(&quot;Request3&quot;);</div><div class="line">        // 总是从链式的首端发起请求</div><div class="line">        handler1.handleRequest(request1);</div><div class="line">        handler1.handleRequest(request2);</div><div class="line">        // 不从链式的首端发起请求</div><div class="line">        handler2.handleRequest(request3);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>对于责任链中的一个处理者对象，其只有两个行为：一是处理请求，而是将请求转发给下一个节点。不允许某个处理者对象在处理了请求后又将请求转发给上一个节点的情况。对于一条责任链来说，一个请求最终只有两种情况：一是被某个处理对象所处理，另一个是所有对象均未对其处理。前一种情况称之为纯的责任链，后一种情况称之为不纯的责任链。</p><hr><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>小先向组长报销 5 万元费用，组长一看是笔不小的数目，他没有权限审批，于是组长拿着票据去找部门主管；主管的权限内只能批五千以下的费用，于是主管又跑去找经理；经理权限也不够直接奔向老板的办公室。使用责任链模式的代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">// 抽象领导者</div><div class="line">abstract class Leader &#123;</div><div class="line">    protected Leader nextHandler;    // 上一级领导处理者</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 处理报账请求</div><div class="line">     * @param money 能批复的报账额度</div><div class="line">     */</div><div class="line">    public final void handleRequest(int money) &#123;</div><div class="line">        if (money &lt;= limit()) &#123;</div><div class="line">            handle(money);</div><div class="line">        &#125; else &#123;</div><div class="line">            if (nextHandler != null) &#123;</div><div class="line">                nextHandler.handleRequest(money);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 自身能批复的额度权限</div><div class="line">    protected abstract int limit();</div><div class="line">    // 处理报账行为</div><div class="line">    protected abstract void handle(int money);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 各个具体的领导者</div><div class="line">class GroupLeader extends Leader &#123;</div><div class="line">    @Override</div><div class="line">    protected int limit() &#123;</div><div class="line">        return 1000;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void handle(int money) &#123;</div><div class="line">        System.out.println(&quot;组长批复报销&quot; + money + &quot;元&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Director extends Leader &#123;</div><div class="line">    @Override</div><div class="line">    protected int limit() &#123;</div><div class="line">        return 5000;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void handle(int money) &#123;</div><div class="line">        System.out.println(&quot;主管批复报销&quot; + money + &quot;元&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Manager extends Leader &#123;</div><div class="line">    @Override</div><div class="line">    protected int limit() &#123;</div><div class="line">        return 10000;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void handle(int money) &#123;</div><div class="line">        System.out.println(&quot;经理批复报销&quot; + money + &quot;元&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Boss extends Leader &#123;</div><div class="line">    @Override</div><div class="line">    protected int limit() &#123;</div><div class="line">        return Integer.MAX_VALUE;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void handle(int money) &#123;</div><div class="line">        System.out.println(&quot;老板批复报销&quot; + money + &quot;元&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 客户类</div><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // 构造各个领导对象</div><div class="line">        GroupLeader groupLeader = new GroupLeader();</div><div class="line">        Director director = new Director();</div><div class="line">        Manager manager = new Manager();</div><div class="line">        Boss boss = new Boss();</div><div class="line">        // 设置上一级领导处理对象</div><div class="line">        groupLeader.nextHandler = director;</div><div class="line">        director.nextHandler = manager;</div><div class="line">        manager.nextHandler = boss;</div><div class="line">        // 发起报账请求</div><div class="line">        groupLeader.handleRequest(50000);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>责任链模式的灵活之处在于请求的发起可以从责任链的任何一个节点处开始，同时也可以改变责任链内部传递的规则。比如，直接越过组长找主管报账，或者直接将经理设置为组长的上一级节点。</p><hr><h3 id="ANDROID-源码中的责任链模式实现"><a href="#ANDROID-源码中的责任链模式实现" class="headerlink" title="ANDROID 源码中的责任链模式实现"></a>ANDROID 源码中的责任链模式实现</h3><hr><p>责任链模式在 ANDROID 源码中比较类似的实现莫过于对事件的分发处理，每当用户解除屏幕时，ANDROID 都会将对应的事件包装成一个事件对象从 ViewTree 的顶部自上而下地分发传递。而 ViewGroup 中执行事件派发的方法是 dispatchTouchEvent，在该方法中其对事件进行了统一的分发。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div></pre></td><td class="code"><pre><div class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class="line">    if (mInputEventConsistencyVerifier != null) &#123;</div><div class="line">        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 对于辅助功能的事件处理</div><div class="line">    if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</div><div class="line">        ev.setTargetAccessibilityFocus(false);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    boolean handled = false;</div><div class="line">    if (onFilterTouchEventForSecurity(ev)) &#123;</div><div class="line">        final int action = ev.getAction();</div><div class="line">        final int actionMasked = action &amp; MotionEvent.ACTION_MASK;</div><div class="line"></div><div class="line">        // 处理原始的 DOWN 事件</div><div class="line">        if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">            // 这里主要是在新事件开始时处理完上一个事件</div><div class="line">            cancelAndClearTouchTargets(ev);</div><div class="line">            resetTouchState();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 检查事件拦截</div><div class="line">        final boolean intercepted;</div><div class="line">        if (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">                || mFirstTouchTarget != null) &#123;</div><div class="line">            final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</div><div class="line">            if (!disallowIntercept) &#123;</div><div class="line">                intercepted = onInterceptTouchEvent(ev);</div><div class="line">                ev.setAction(action); // 恢复事件防止其改变</div><div class="line">            &#125; else &#123;</div><div class="line">                intercepted = false;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            intercepted = true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 如果事件被拦截了，则进行正常的事件分发</div><div class="line">        if (intercepted || mFirstTouchTarget != null) &#123;</div><div class="line">            ev.setTargetAccessibilityFocus(false);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 检查事件是否取消</div><div class="line">        final boolean canceled = resetCancelNextUpFlag(this)</div><div class="line">                || actionMasked == MotionEvent.ACTION_CANCEL;</div><div class="line"></div><div class="line">        // 如果有必要的话，为 DOWN 事件检查所有的目标对象</div><div class="line">        final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;</div><div class="line">        TouchTarget newTouchTarget = null;</div><div class="line">        boolean alreadyDispatchedToNewTouchTarget = false;</div><div class="line">        // 如果事件未被取消且未被拦截</div><div class="line">        if (!canceled &amp;&amp; !intercepted) &#123;</div><div class="line">            // 如果有辅助功能的参与，则直接将事件投递到对应的 View</div><div class="line">            // 否则将事件分发给所有的子 View</div><div class="line">            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</div><div class="line">                    ? findChildWithAccessibilityFocus() : null;</div><div class="line">            // 如果事件为起始事件</div><div class="line">            if (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</div><div class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</div><div class="line">                final int actionIndex = ev.getActionIndex(); // always 0 for down</div><div class="line">                final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)</div><div class="line">                        : TouchTarget.ALL_POINTER_IDS;</div><div class="line"></div><div class="line">                removePointersFromTouchTargets(idBitsToAssign);</div><div class="line"></div><div class="line">                final int childrenCount = mChildrenCount;</div><div class="line">                // 如果 newTouchTarget 为空且子元素不为 0</div><div class="line">                if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123;</div><div class="line">                    final float x = ev.getX(actionIndex);</div><div class="line">                    final float y = ev.getY(actionIndex);</div><div class="line">                    // 自上而下去寻找一个可以接收该事件的子 View</div><div class="line">                    final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</div><div class="line">                    final boolean customOrder = preorderedList == null</div><div class="line">                            &amp;&amp; isChildrenDrawingOrderEnabled();</div><div class="line">                    final View[] children = mChildren;</div><div class="line">                    // 遍历子元素</div><div class="line">                    for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;</div><div class="line">                        final int childIndex = getAndVerifyPreorderedIndex(</div><div class="line">                                childrenCount, i, customOrder);</div><div class="line">                        final View child = getAndVerifyPreorderedView(</div><div class="line">                                preorderedList, children, childIndex);</div><div class="line"></div><div class="line">                        if (childWithAccessibilityFocus != null) &#123;</div><div class="line">                            if (childWithAccessibilityFocus != child) &#123;</div><div class="line">                                continue;</div><div class="line">                            &#125;</div><div class="line">                            childWithAccessibilityFocus = null;</div><div class="line">                            i = childrenCount - 1;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        // 如果子元素无法接收 PointerEvent 或这个事件点压根就没有</div><div class="line">                        // 落在子元素的边界范围内，那么就跳出该次循环继续遍历</div><div class="line">                        if (!canViewReceivePointerEvents(child)</div><div class="line">                                || !isTransformedTouchPointInView(x, y, child, null)) &#123;</div><div class="line">                            ev.setTargetAccessibilityFocus(false);</div><div class="line">                            continue;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        // 找到 Event 该由哪个子元素持有</div><div class="line">                        newTouchTarget = getTouchTarget(child);</div><div class="line">                        if (newTouchTarget != null) &#123;</div><div class="line">                            newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">                            break;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        resetCancelNextUpFlag(child);</div><div class="line">                        // 投递事件执行触摸操作</div><div class="line">                        // 如果子元素还是一个 ViewGroup，则递归调用重复此过程</div><div class="line">                        // 如果子元素是一个 View，那么会调用 View 的 dispatchTouchEvent，</div><div class="line">                        // 并最终有 onTouchEvent 处理</div><div class="line">                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</div><div class="line">                            // 子 View 在其边界范围内接收该事件</div><div class="line">                            mLastTouchDownTime = ev.getDownTime();</div><div class="line">                            if (preorderedList != null) &#123;</div><div class="line">                                for (int j = 0; j &lt; childrenCount; j++) &#123;</div><div class="line">                                    if (children[childIndex] == mChildren[j]) &#123;</div><div class="line">                                        mLastTouchDownIndex = j;</div><div class="line">                                        break;</div><div class="line">                                    &#125;</div><div class="line">                                &#125;</div><div class="line">                            &#125; else &#123;</div><div class="line">                                mLastTouchDownIndex = childIndex;</div><div class="line">                            &#125;</div><div class="line">                            mLastTouchDownX = ev.getX();</div><div class="line">                            mLastTouchDownY = ev.getY();</div><div class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">                            alreadyDispatchedToNewTouchTarget = true;</div><div class="line">                            break;</div><div class="line">                        &#125;</div><div class="line">                        ev.setTargetAccessibilityFocus(false);</div><div class="line">                    &#125;</div><div class="line">                    if (preorderedList != null) preorderedList.clear();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // 如果没有发现子元素可以持有该次事件</div><div class="line">                if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123;</div><div class="line">                    newTouchTarget = mFirstTouchTarget;</div><div class="line">                    while (newTouchTarget.next != null) &#123;</div><div class="line">                        newTouchTarget = newTouchTarget.next;</div><div class="line">                    &#125;</div><div class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mFirstTouchTarget == null) &#123;</div><div class="line">            // 重点：dispatchTransformedTouchEvent</div><div class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, null,</div><div class="line">                    TouchTarget.ALL_POINTER_IDS);</div><div class="line">        &#125; else &#123;</div><div class="line">            TouchTarget predecessor = null;</div><div class="line">            TouchTarget target = mFirstTouchTarget;</div><div class="line">            while (target != null) &#123;</div><div class="line">                final TouchTarget next = target.next;</div><div class="line">                if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</div><div class="line">                    handled = true;</div><div class="line">                &#125; else &#123;</div><div class="line">                    final boolean cancelChild = resetCancelNextUpFlag(target.child)</div><div class="line">                            || intercepted;</div><div class="line">                    // 重点：dispatchTransformedTouchEvent</div><div class="line">                    if (dispatchTransformedTouchEvent(ev, cancelChild,</div><div class="line">                            target.child, target.pointerIdBits)) &#123;</div><div class="line">                        handled = true;</div><div class="line">                    &#125;</div><div class="line">                    if (cancelChild) &#123;</div><div class="line">                        if (predecessor == null) &#123;</div><div class="line">                            mFirstTouchTarget = next;</div><div class="line">                        &#125; else &#123;</div><div class="line">                            predecessor.next = next;</div><div class="line">                        &#125;</div><div class="line">                        target.recycle();</div><div class="line">                        target = next;</div><div class="line">                        continue;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                predecessor = target;</div><div class="line">                target = next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">    </div><div class="line">    return handled;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里我们主要看看 dispatchTransformedTouchEvent 方法是如何调度子元素 dispatchTouchEvent 方法的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,</div><div class="line">                                              View child, int desiredPointerIdBits) &#123;</div><div class="line">    final boolean handled;</div><div class="line">    final int oldAction = event.getAction();</div><div class="line">    // 如果事件被取消</div><div class="line">    if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</div><div class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</div><div class="line">        // 如果没有子元素，则会调用父类的 dispatchTouchEvent。这里的父类终会为 View 类</div><div class="line">        if (child == null) &#123;</div><div class="line">            handled = super.dispatchTouchEvent(event);</div><div class="line">        &#125; else &#123;</div><div class="line">            // 如果有子元素则传递 cancel 事件</div><div class="line">            handled = child.dispatchTouchEvent(event);</div><div class="line">        &#125;</div><div class="line">        event.setAction(oldAction);</div><div class="line">        return handled;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 计算即将被传递的点的数量</div><div class="line">    final int oldPointerIdBits = event.getPointerIdBits();</div><div class="line">    final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</div><div class="line"></div><div class="line">    // 如果没有相应的点，那么就丢弃该事件</div><div class="line">    if (newPointerIdBits == 0) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 声明临时变量保存坐标转换后的 MotionEvent</div><div class="line">    final MotionEvent transformedEvent;</div><div class="line">    if (newPointerIdBits == oldPointerIdBits) &#123;</div><div class="line">        // 如果子元素为空或者有一个单位矩阵</div><div class="line">        if (child == null || child.hasIdentityMatrix()) &#123;</div><div class="line">            if (child == null) &#123;</div><div class="line">                // 为空则调用父类 dispatchTouchEvent</div><div class="line">                handled = super.dispatchTouchEvent(event);</div><div class="line">            &#125; else &#123;</div><div class="line">                // 否则尝试获取 xy 方向上的偏移量（如果通过 scrollTo 或 scrollBy</div><div class="line">                // 对子视图进行滚动的话）</div><div class="line">                final float offsetX = mScrollX - child.mLeft;</div><div class="line">                final float offsetY = mScrollY - child.mTop;</div><div class="line">                // 将 MotionEvent 进行坐标变换</div><div class="line">                event.offsetLocation(offsetX, offsetY);</div><div class="line">                // 再将变换后的 MotionEvent 传递给子元素</div><div class="line">                handled = child.dispatchTouchEvent(event);</div><div class="line">                // 复位 MotionEvent 以便以后再次使用</div><div class="line">                event.offsetLocation(-offsetX, -offsetY);</div><div class="line">            &#125;</div><div class="line">            // 如果通过以上的逻辑判断，当前事件被持有则可以直接返回</div><div class="line">            return handled;</div><div class="line">        &#125;</div><div class="line">        transformedEvent = MotionEvent.obtain(event);</div><div class="line">    &#125; else &#123;</div><div class="line">        transformedEvent = event.split(newPointerIdBits);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Perform any necessary transformations and dispatch.</div><div class="line">    if (child == null) &#123;</div><div class="line">        handled = super.dispatchTouchEvent(transformedEvent);</div><div class="line">    &#125; else &#123;</div><div class="line">        final float offsetX = mScrollX - child.mLeft;</div><div class="line">        final float offsetY = mScrollY - child.mTop;</div><div class="line">        transformedEvent.offsetLocation(offsetX, offsetY);</div><div class="line">        if (! child.hasIdentityMatrix()) &#123;</div><div class="line">            transformedEvent.transform(child.getInverseMatrix());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        handled = child.dispatchTouchEvent(transformedEvent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Done.</div><div class="line">    transformedEvent.recycle();</div><div class="line">    return handled;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ViewGroup 事件投递的递归调用就类似于一条责任链，一旦其寻找到责任者，那么将由责任者持有并消费掉该次事件，具体地体现在<br>View 的 onTouchEvent 方法中返回值的设置，如果 onTouchEvent 返回 false，那么意味着当前 View 不会是该次事件的责任人，将不会持有；如果为 true 则相反，此时 View 会持有该事件并不再向外传递。</p><hr><h3 id="责任链模式实战"><a href="#责任链模式实战" class="headerlink" title="责任链模式实战"></a>责任链模式实战</h3><hr><p>ANDROID 中的 BroastCast 分为两种，一种是普通广播，另一种是有序广播。普通广播是异步的，发出时可以被所有的接收者收到。而有序广播是根据优先级依次传播的，直到有接收者将其终止或者所有接收者都不终止它。有序广播的这一特性与我们的责任链模式很相近，我们可以轻松地实现一种全局的责任链事件处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;hr&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;责任链模式：&lt;strong&gt;
      
    
    </summary>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/categories/PATTERN/"/>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/tags/PATTERN/"/>
    
  </entry>
  
  <entry>
    <title>07 设计模式——状态模式</title>
    <link href="http://yoursite.com/2019/08/13/PATTERN/07%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/13/PATTERN/07 设计模式——状态模式/</id>
    <published>2019-08-12T17:00:00.000Z</published>
    <updated>2020-03-02T11:15:59.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><hr><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>状态模式：<strong>当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类</strong>。</p><p>状态模式中的行为是由状态来决定的，不同的状态下有不同的行为。状态模式和策略模式的结构几乎完全一样，但它们的目的、本质却完全不一样。状态模式的行为是平行的、不可替换的，策略模式的行为是彼此独立、可相互替换的。用一句话来表述，状态模式把对象的行为包装在不同状态对象里，每一个状态对象都有一个共同的抽象状态基类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为。</li><li>代码中包含大量与对象状态有关的条件语句，例如，一个操作中含有庞大的多分支语句（if-else 或 switch-case），且这些分支依赖于该对象的状态。</li></ul><p>状态模式将每一个条件分支放入一个独立的类中，这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化，这样通过多态来去除过多的、重复的 if-else 等分支语句。</p><h4 id="UML-关系图"><a href="#UML-关系图" class="headerlink" title="UML 关系图"></a>UML 关系图</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-050ce5696b445d29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图中的角色介绍：</p><ul><li>Context：环境类，定义客户端感兴趣的接口，维护一个 State 子类的实例，这个实例定义了对象当前状态。</li><li>State：抽象状态类或状态接口，定义一个或一组接口，表示该状态下的行为。</li><li>ConcreteStateA、ConcreteStateB：具体状态类，每个具体状态类实现抽象状态类中定义的接口，从而达到不同状态下的不同行为。</li></ul><hr><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>以电视遥控器为例来演示一下状态模式的实现。我们先将电视的状态简单分为开机状态和关机状态，在开机状态下可以通过遥控器进行频道切换、调整音量等操作，但是，此时重复按开机键是无效的；而在关机状态下，频道切换、调整音量、关机都是无效的操作，只有按开机按钮时会生效。</p><h4 id="未使用状态模式"><a href="#未使用状态模式" class="headerlink" title="未使用状态模式"></a>未使用状态模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">// 电视遥控器,含有 开机,关机,下一个频道,上一个频道,调高音量,调低音量</div><div class="line">public class TVController &#123;</div><div class="line">    // 开机状态</div><div class="line">    private final static int POWER_ON = 1;</div><div class="line"></div><div class="line">    // 关机状态</div><div class="line">    private final static int POWER_OFF = 2;</div><div class="line"></div><div class="line">    private int state = POWER_OFF;</div><div class="line"></div><div class="line">    public void powerOn() &#123;</div><div class="line">        if (state == POWER_OFF) &#123;</div><div class="line">            System.out.println(&quot;开机啦&quot;);</div><div class="line">        &#125;</div><div class="line">        state = POWER_ON;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void powerOff() &#123;</div><div class="line">        if (state == POWER_ON) &#123;</div><div class="line">            System.out.println(&quot;关机啦&quot;);</div><div class="line">        &#125;</div><div class="line">        state = POWER_OFF;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void nextChannel() &#123;</div><div class="line">        if (state == POWER_ON) &#123;</div><div class="line">            System.out.println(&quot;下一个频道&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            System.out.println(&quot;两个红灯提示没有开机&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void prevChannel() &#123;</div><div class="line">        if (state == POWER_ON) &#123;</div><div class="line">            System.out.println(&quot;上一个频道&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            System.out.println(&quot;两个红灯提示没有开机&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void turnUp() &#123;</div><div class="line">        if (state == POWER_ON) &#123;</div><div class="line">            System.out.println(&quot;调高音量&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            System.out.println(&quot;两个红灯提示没有开机&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void turnDown() &#123;</div><div class="line">        if (state == POWER_ON) &#123;</div><div class="line">            System.out.println(&quot;调低音量&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            System.out.println(&quot;两个红灯提示没有开机&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，在 TVController 类中，通过 state 字段存储了电视的状态，并且在各个操作中根据状态来判断是否该执行。这就导致了在每个功能中都需要使用 if-else，代码重复、相对较为混乱，这是在只有两个状态和几个简单功能函数的情况下，那么当状态变成 5 个、功能函数变为 10 个呢？每个函数中都要用 if-else 进行判断，而这些代码都充斥在一个类中，这些重复的代码无法被提取出来，这使得这个类变得越来越难以维护。</p><h4 id="使用状态模式"><a href="#使用状态模式" class="headerlink" title="使用状态模式"></a>使用状态模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">// 电视状态接口，定义电视操作的函数</div><div class="line">public interface TvState &#123;</div><div class="line">    public void nextChannel();</div><div class="line">    public void prevChannel();</div><div class="line">    public void turnUp();</div><div class="line">    public void turnDown();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 关机状态，此时只有开机功能是有效的</div><div class="line">public class PowerOffStatus implements TvState&#123;</div><div class="line">    @Override</div><div class="line">    public void nextChannel() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void prevChannel() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void turnUp() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void turnDown() &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 开机状态，此时再出发开机功能不能做任何操作</div><div class="line">public class PowerOnState implements TvState &#123;</div><div class="line">    @Override</div><div class="line">    public void nextChannel() &#123;</div><div class="line">        System.out.println(&quot;下一个频道&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void prevChannel() &#123;</div><div class="line">        System.out.println(&quot;上一个频道&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void turnUp() &#123;</div><div class="line">        System.out.println(&quot;声音调大&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void turnDown() &#123;</div><div class="line">        System.out.println(&quot;声音调小&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 电源操作接口</div><div class="line">public interface PowerController &#123;</div><div class="line">    public void powerOn();</div><div class="line">    public void powerOff();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 电视遥控器，类似于经典状态模式中的 Context</div><div class="line">public class TvController implements PowerController &#123;</div><div class="line">    TvState tvState;</div><div class="line"></div><div class="line">    public void setTvState(TvState tvState) &#123;</div><div class="line">        this.tvState = tvState;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void powerOn() &#123;</div><div class="line">        setTvState(new PowerOnState());</div><div class="line">        System.out.println(&quot;开机啦&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void powerOff() &#123;</div><div class="line">        setTvState(new PowerOffStatus());</div><div class="line">        System.out.println(&quot;关机啦&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void nextChannel()&#123;</div><div class="line">        tvState.nextChannel();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void prevChannel()&#123;</div><div class="line">        tvState.prevChannel();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void turnUp()&#123;</div><div class="line">        tvState.turnUp();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void turnDown()&#123;</div><div class="line">        tvState.turnDown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>客户端调用代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    TvController tvController = new TvController();</div><div class="line">    // 设置开机状态</div><div class="line">    tvController.powerOn();</div><div class="line">    // 下一个频道</div><div class="line">    tvController.nextChannel();</div><div class="line">    // 调高音量</div><div class="line">    tvController.turnUp();</div><div class="line">    // 设置关机状态</div><div class="line">    tvController.powerOff();</div><div class="line">    // 调低音量，此时不会生效</div><div class="line">    tvController.turnDown();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">开机啦</div><div class="line">下一个频道</div><div class="line">声音调大</div><div class="line">关机啦</div></pre></td></tr></table></figure></p><hr><h3 id="状态模式实战"><a href="#状态模式实战" class="headerlink" title="状态模式实战"></a>状态模式实战</h3><hr><p>在开发过程中，我们用到状态模式最常见的地方应该是用户登录系统。在用户已登录和未登录的情况下，对于同一事件的处理行为是不一样的。例如，在新浪微博中，用户在未登录的情况下点击转发或评论按钮，此时会先让用户登录，然后再执行操作；如果是已登录的情况下，那么用户可以直接进行操作。</p><p>首先抽象出状态类，定义两个操作接口：转发和评论。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public interface UserState &#123;</div><div class="line">    /**</div><div class="line">     * 转发</div><div class="line">     */</div><div class="line">    public void forward(Context context);</div><div class="line">    /**</div><div class="line">     * 评论</div><div class="line">     */</div><div class="line">    public void comment(Context context);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后实现两个状态子类：已登录状态类、未登录状态类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 已登录状态</div><div class="line">public class LoggedState implements UserState &#123;</div><div class="line">    @Override</div><div class="line">    public void forward(Context context) &#123;</div><div class="line">        Toast.makeText(context, &quot;转发成功&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void comment(Context context) &#123;</div><div class="line">        Toast.makeText(context, &quot;评论成功&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 未登录状态</div><div class="line">public class LogoutState implements UserState &#123;</div><div class="line">    @Override</div><div class="line">    public void forward(Context context) &#123;</div><div class="line">        gotoLoginActivity(context);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void comment(Context context) &#123;</div><div class="line">        gotoLoginActivity(context);</div><div class="line">    &#125;</div><div class="line">    private void gotoLoginActivity(Context context) &#123;</div><div class="line">        Intent intent = new Intent(context, LoginActivity.class)</div><div class="line">        startActivity(context);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>最后实现 Context 角色，即用户的操作对象和状态管理对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class LoginContext &#123;</div><div class="line">    // 用户状态，默认为未登录状态</div><div class="line">    private UserState userState = new LogoutState();</div><div class="line">    // 单例</div><div class="line">    private static LoginContext loginContext = new LoginContext();</div><div class="line">    private LoginContext() &#123;&#125;</div><div class="line"></div><div class="line">    public LoginContext getLoginContext() &#123;</div><div class="line">        return loginContext;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setUserState(UserState userState) &#123;</div><div class="line">        this.userState = userState;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void forward(Context context) &#123;</div><div class="line">        userState.forward(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void comment(Context context) &#123;</div><div class="line">        userState.comment(context);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>客户端调用样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 转发微博</div><div class="line">LoginContext.getLoginContext().forward(MainActivity.this)</div><div class="line">// 分享微博</div><div class="line">LoginContext.getLoginContext().comment(MainActivity.this)</div><div class="line">// 登录成功后修改为已登录状态</div><div class="line">LoginContext.getLoginContext().setUserState(new LoggedState())</div><div class="line">// 注销登录，修改为未登录状态</div><div class="line">LoginContext.getLoginContext().setUserState(new LogoutState());</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;hr&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;状态模式：&lt;strong&gt;当
      
    
    </summary>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/categories/PATTERN/"/>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/tags/PATTERN/"/>
    
  </entry>
  
  <entry>
    <title>06 设计模式——策略模式</title>
    <link href="http://yoursite.com/2019/08/12/PATTERN/06%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/12/PATTERN/06 设计模式——策略模式/</id>
    <published>2019-08-11T17:00:00.000Z</published>
    <updated>2020-02-25T16:01:14.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><hr><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>策略模式：<strong>策略模式定义了一系列算法，并将每一个算法封装起来，而且使它们可以相互替换。策略模式让算法独立于使用它的客户端而独立变化</strong>。</p><p>在软件开发中常常遇到这样的情况：实现某一功能可以有多种算法或者策略，我们根据实际情况选择不同的算法或者策略来完成该功能。例如，排序算法，可以使用插入排序、归并排序、冒泡排序等。</p><p>针对这种情况，一种常规的方法是将多种算法写到一个类中。例如，需要提供多种排序算法，可以将这些算法写到一个类中，每一个方法对应一个具体的排序算法；当然，也可以将这些排序算法封装在一个统一的方法中，通过 if…else… 或者 case 等条件判断语句来选择具体的算法。这两种实现方法我们都可以称为硬编码。然而，当很多算法集中在一个类中时，这个类就会变得臃肿，维护成本会变高，在维护时也更容易引发错误。如果我们需要增加一种新的排序算法，需要修改封装算法类的源代码。这就明显违反了开闭原则和单一职责原则。</p><p>如果将这些算法或者策略抽象出来，提供一个统一的接口，不同的算法或者策略有不同的实现类，这样在程序客户端就可以通过注入不同的实现对象来实现算法或者策略的动态替换，这种模式的可扩展性、可维护性也就更高，也就是我们要说的<strong>策略模式</strong>。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>结构清晰明了、使用简单直观；</li><li>耦合度相对而言较低，扩展方便；</li><li>操作封装也更为彻底，数据更为安全。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>随着策略的增加，子类也会变得繁多。</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>针对同一类型问题的多种处理方式，仅仅是具体行为有差别时。</li><li>需要安全地封装多种同一类型的操作时。</li><li>出现同一抽象类有多个子类，而又需要使用 if-else 或者 switch-case 来选择具体子类时。</li></ul><h4 id="UML-关系图"><a href="#UML-关系图" class="headerlink" title="UML 关系图"></a>UML 关系图</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b576235c8d49057c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图中的角色介绍：</p><ul><li>Context：用来操作策略的上下文环境；</li><li>Strategy：策略的抽象；</li><li>ConcreteStrategyA、ConcreteStrategyB：具体的策略实现。</li></ul><hr><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>下面我们以计算不同交通工具的车费来简单看看策略模式的实现。</p><h4 id="常规实现"><a href="#常规实现" class="headerlink" title="常规实现"></a>常规实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public class PriceCalculator &#123;</div><div class="line">    // 公交车类型</div><div class="line">    private static final int BUS = 1;</div><div class="line">    // 地铁类型</div><div class="line">    private static final int SUBWAY = 2;</div><div class="line"></div><div class="line">    public int calculatePrice(int km, int type) &#123;</div><div class="line">        if (type == BUS) &#123;</div><div class="line">            return busPrice(km);</div><div class="line">        &#125; else if (type == SUBWAY) &#123;</div><div class="line">            return subwayPrice(km);</div><div class="line">        &#125;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 十公里之内一元，超过十公里之后每加一元钱可以乘 5 公里</div><div class="line">     * @param km 公里数</div><div class="line">     * @return 公交车车费</div><div class="line">     */</div><div class="line">    private int busPrice(int km) &#123;</div><div class="line">        // 超过十公里的总距离</div><div class="line">        int extraTotal = km - 10;</div><div class="line">        // 超过的距离是 5 公里的倍数</div><div class="line">        int extraFactor = extraTotal / 5;</div><div class="line">        // 超过的距离对 5 公里取余</div><div class="line">        int fraction = extraTotal % 5;</div><div class="line">        // 价格计算</div><div class="line">        int price = 1 + extraFactor * 1 ;</div><div class="line">        return fraction &gt; 0 ? ++price : price;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 6 公里（含）内 3 元；6 ~ 12 公里（含）4 元；</div><div class="line">     * 12 ~ 22 公里（含）5元；22 ~ 32 公里（含）6元；</div><div class="line">     * @param km 公里数</div><div class="line">     * @return 地铁车费</div><div class="line">     */</div><div class="line">    private int subwayPrice(int km) &#123;</div><div class="line">        if (km &lt;= 6) &#123;</div><div class="line">            return 3;</div><div class="line">        &#125; else if (km &lt;= 12) &#123;</div><div class="line">            return 4;</div><div class="line">        &#125; else if (km &lt;= 22) &#123;</div><div class="line">            return 5;</div><div class="line">        &#125; else if (km &lt;= 32) &#123;</div><div class="line">            return 6;</div><div class="line">        &#125;</div><div class="line">        // 其他距离简化为 7 元</div><div class="line">        return 7;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PriceCalculator 类很明显地问题就是并不是单一职责，首先他承担了计算公交车和地铁乘坐价格的职责；另一个问题就是通过 if-else 的形式来判断使用哪种计算形式。当我们增加一种出行方式时，如出租车，那么我们就需要在 PriceCalculator 中增加一个方法来计算出租车出行的价格，并且再 calculatePrice(int km, int type) 函数中增加一个判断，代码添加后大致如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class PriceCalculator &#123;</div><div class="line">    // 公交车类型</div><div class="line">    private static final int BUS = 1;</div><div class="line">    // 地铁类型</div><div class="line">    private static final int SUBWAY = 2;</div><div class="line">    // 出租车类型</div><div class="line">    private static final int TEXI = 3;</div><div class="line"></div><div class="line">    public int calculatePrice(int km, int type) &#123;</div><div class="line">        if (type == BUS) &#123;</div><div class="line">            return busPrice(km);</div><div class="line">        &#125; else if (type == SUBWAY) &#123;</div><div class="line">            return subwayPrice(km);</div><div class="line">        &#125; else if (type == TEXI) &#123;</div><div class="line">            return taxiPrice(km);</div><div class="line">        &#125;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 简单计算为每公里 2 元钱</div><div class="line">     * @param km 公里数</div><div class="line">     * @return 出租车费</div><div class="line">     */</div><div class="line">    private int taxiPrice(int km) &#123;</div><div class="line">        return km * 2;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 其他代码</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>此时代码已经比较混乱，各种 if-else 缠绕其中。当价格的计算方法变化时，需要直接修改这个类中的代码，那么很可能有一段代码是其他几个计算方法所共同使用的，这就容易引入错误。另外，在增加出行方式时，需要手动修改，添加 if-else。这类代码必然是难以应对变化的，难以维护的。下面我们对上述示例用策略模式进行重构。</p><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>首先需要定义一个抽象的价格计算接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public interface CalculateStrategy &#123;</div><div class="line">    /**</div><div class="line">     * 按距离来计算价格</div><div class="line">     * @param km 公里数</div><div class="line">     * @return 价格</div><div class="line">     */</div><div class="line">    int calculatePrice(int km);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>对于每一种出行方式我们都有一个独立的计算策略类，这些策略类都实现了 CalculateStrategy 接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">// 公交车价格计算策略</div><div class="line">public class BusStrategy implements CalculateStrategy &#123;</div><div class="line">    /**</div><div class="line">     * 十公里之内一元，超过十公里之后每加一元钱可以乘 5 公里</div><div class="line">     * @param km 公里数</div><div class="line">     * @return 公交车车费</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public int calculatePrice(int km) &#123;</div><div class="line">        // 超过十公里的总距离</div><div class="line">        int extraTotal = km - 10;</div><div class="line">        // 超过的距离是 5 公里的倍数</div><div class="line">        int extraFactor = extraTotal / 5;</div><div class="line">        // 超过的距离对 5 公里取余</div><div class="line">        int fraction = extraTotal % 5;</div><div class="line">        // 价格计算</div><div class="line">        int price = 1 + extraFactor * 1 ;</div><div class="line">        return fraction &gt; 0 ? ++price : price;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 地铁价格计算策略</div><div class="line">public class SubwayStrategy implements CalculateStrategy &#123;</div><div class="line">    /**</div><div class="line">     * 6 公里（含）内 3 元；6 ~ 12 公里（含）4 元；</div><div class="line">     * 12 ~ 22 公里（含）5元；22 ~ 32 公里（含）6元；</div><div class="line">     * @param km 公里数</div><div class="line">     * @return 地铁车费</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public int calculatePrice(int km) &#123;</div><div class="line">        if (km &lt;= 6) &#123;</div><div class="line">            return 3;</div><div class="line">        &#125; else if (km &lt;= 12) &#123;</div><div class="line">            return 4;</div><div class="line">        &#125; else if (km &lt;= 22) &#123;</div><div class="line">            return 5;</div><div class="line">        &#125; else if (km &lt;= 32) &#123;</div><div class="line">            return 6;</div><div class="line">        &#125;</div><div class="line">        // 其他距离简化为 7 元</div><div class="line">        return 7;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>再创建一个扮演 Context 角色的类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class TrafficCalculator &#123;</div><div class="line">    private CalculateStrategy mStrategy;</div><div class="line"></div><div class="line">    public CalculateStrategy getStrategy() &#123;</div><div class="line">        return mStrategy;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setStrategy(CalculateStrategy strategy) &#123;</div><div class="line">        this.mStrategy = strategy;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        TrafficCalculator calculator = new TrafficCalculator();</div><div class="line">        calculator.setStrategy(new BusStrategy());</div><div class="line">        calculator.calculatePrice(16);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这种方案在隐藏实现的同时，可扩展性变得很强。例如，当我们需要增加出租车的计算策略时，只需要添加一个出租车计算策略类，然后将该策略设置给 TrafficCalculator。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 出租车价格计算策略</div><div class="line">public class TaxiStrategy implements CalculateStrategy &#123;</div><div class="line">    /**</div><div class="line">     * 简单计算为每公里 2 元钱</div><div class="line">     * @param km 公里数</div><div class="line">     * @return 出租车费</div><div class="line">     */</div><div class="line">    private int taxiPrice(int km) &#123;</div><div class="line">        return km * 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>讲策略注入到 TrafficCalculator 中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">TrafficCalculator calculator = new TrafficCalculator();</div><div class="line">calculator.setmStrategy(new TaxiStrategy());</div><div class="line">calculator.calculatePrice(16);</div></pre></td></tr></table></figure></p><hr><h3 id="模式在-ANDROID-中的应用"><a href="#模式在-ANDROID-中的应用" class="headerlink" title="模式在 ANDROID 中的应用"></a>模式在 ANDROID 中的应用</h3><hr><p>ANDROID 中属性动画的时间差值器分为线性差值器、加速减速差值器等，这些差值器里面就用到了策略模式来隔离不同的动画速率计算算法。源码追踪关键方法依次为：</p><ul><li>View：<br>boolean draw(Canvas canvas, ViewGroup parent, long drawingTime)<br>private boolean applyLegacyAnimation(ViewGroup parent, long drawingTime, Animation a, boolean scalingRequired)</li><li>Animation：<br>public boolean getTransformation(long currentTime, Transformation outTransformation,float scale)<br>public boolean getTransformation(long currentTime, Transformation outTransformation)</li><li>Interpolator：<br>float getInterpolation(float input)</li></ul><p>插值器在属性动画中扮演了很重要的角色。它将动画的速率计算封装到一个抽象中，也就是 Interpolator 中，该接口只有一个 getInterpolation(float input) 方法，通过这个方法来修改动画的流逝时间比，依次达到动画的加速、减速等效果，结构如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-594f6a6d59530211.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>Interpolator 就是这个计算策略的抽象，LinearInterpolator、CycleInterpolator 等插值器就是具体的实现策略，通过注入不同的插值器实现不同的动态效果。</p><hr><h3 id="策略模式实战"><a href="#策略模式实战" class="headerlink" title="策略模式实战"></a>策略模式实战</h3><hr><p>在我们加载图片项目 ImageLoader 中，加载请求会被封装成一个 Request 对象添加到请求队列中，ImageLoader 会为每个请求分配一个序列号，越晚加入的请求序列号值越大，默认情况下 ImageLoader 会按照先后顺序加载图片。但是现实中，我们可能需要最后添加到队列的请求先被执行。例如，在滚动 ListView 时，最后一项肯定是最晚被加载的，此时它却显示在屏幕上的，而其它优先被加载的请求却不在屏幕显示范围。当需求是在屏幕上显示的 Item View 的图片优先被加载，我们就需要 ImageLoader 支持从请求队列的尾部开始加载。也就是，这里至少需要两种策略。</p><p>依照策略模式，代码实现如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 加载策略接口</div><div class="line"> */</div><div class="line">public interface LoadPolicy &#123;</div><div class="line">    int compare(BitmapRequest request1, BitmapRequest request2);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 顺序加载策略</div><div class="line"> */</div><div class="line">public class SerialPolicy implements LoadPolicy &#123;</div><div class="line">    @Override</div><div class="line">    public int compare(BitmapRequest request1, BitmapRequest request2) &#123;</div><div class="line">        return request1.serialNum - request2.serialNum;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 逆序加载策略</div><div class="line"> */</div><div class="line">public class SerialPolicy implements LoadPolicy &#123;</div><div class="line">    @Override</div><div class="line">    public int compare(BitmapRequest request1, BitmapRequest request2) &#123;</div><div class="line">        return request2.serialNum - request1.serialNum;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class BitmapRequest implements Comparable&lt;BitmapRequest&gt; &#123;</div><div class="line">    // 加载策略，默认顺序加载策略</div><div class="line">    private LoadPolicy mLoadPolicy = new SerialPolicy();</div><div class="line"></div><div class="line">    public void setLoadPolicy(LoadPolicy loadPolicy) &#123;</div><div class="line">        this.mLoadPolicy = loadPolicy;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int compareTo(BitmapRequest another) &#123;</div><div class="line">        return mLoadPolicy.compare(this, another);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;hr&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;策略模式：&lt;strong&gt;策
      
    
    </summary>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/categories/PATTERN/"/>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/tags/PATTERN/"/>
    
  </entry>
  
  <entry>
    <title>05 设计模式——抽象工厂模式</title>
    <link href="http://yoursite.com/2019/08/11/PATTERN/05%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/11/PATTERN/05 设计模式——抽象工厂模式/</id>
    <published>2019-08-10T17:00:00.000Z</published>
    <updated>2020-02-25T13:00:33.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><hr><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>抽象工厂模式：<strong>为创建一组相关或者相互依赖的对象提供一个接口，而无需指定它们的具体类</strong>。</p><p>可以说是工厂方法模式的升级版，当需要创建的产品有多个产品线（产品族）时使用抽象工厂模式是比较好的选择。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。</li><li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。</li><li>增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。</li><li>开闭原则的倾斜性<br>1）增加产品族：对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。<br>2）增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。</li></ul><blockquote><p>正因为抽象工厂模式存在“开闭原则”的倾斜性，它以一种倾斜的方式来满足“开闭原则”，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。</p></blockquote><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>在以下情况下可以考虑使用抽象工厂模式：</p><ul><li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。</li><li>系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。</li><li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一制作水果蛋糕用的水果–草莓和芒果，草莓和芒果之间没有直接关系，但它们都是属于水果。</li><li>产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</li></ul><h4 id="UML关系图"><a href="#UML关系图" class="headerlink" title="UML关系图"></a>UML关系图</h4><p><img src="https://upload-images.jianshu.io/upload_images/5733856-9e2f3e0a0a90ca9f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt=""></p><p>抽象工厂模式中有如下角色：</p><ul><li>AbstractFactory：抽象工厂，它声明了用来创建不同产品的方法。</li><li>ConcreteFactory：具体工厂，实现抽象工厂中定义的创建产品的方法。</li><li>AbstractProduct：抽象产品，为每种产品声明业务方法。比如上图的AbstractProductA和 AbstractProductB。</li><li>ConcreteProduct：具体产品，定义具体工厂生产的具体产品，并实现抽象产品中定义的业务方法。</li></ul><hr><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>联想和惠普生产的电脑分为了两个产品线，一个台式机，一个是笔记本。为了解决增加产品线的问题，我们用抽象工厂模式来进行实现。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7a0c61e51d5048f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p><strong>抽象产品</strong><br>两个抽象产品类分别为 DesktopComputer 和 NotebookComputer ，用来定义两个产品线：台式机和笔记本。它们都定义了start方法，用来启动电脑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public abstract class DesktopComputer &#123;</div><div class="line">  public abstract void start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public abstract class NotebookComputer &#123;</div><div class="line">   public abstract void start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p><strong>具体产品</strong><br>具体产品为联想和惠普旗下的台式机和笔记本，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class LenovoDesktopComputer extends DesktopComputer &#123;</div><div class="line">    @Override</div><div class="line">    public void start() &#123;</div><div class="line">        System.out.println(&quot;联想台式电脑启动&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class HpDesktopComputer extends DesktopComputer &#123;</div><div class="line">    @Override</div><div class="line">    public void start() &#123;</div><div class="line">        System.out.println(&quot;惠普台式电脑启动&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class LenovoNotebookComputer extends NotebookComputer &#123;</div><div class="line">    @Override</div><div class="line">    public void start() &#123;</div><div class="line">        System.out.println(&quot;联想笔记本电脑启动&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class HpNotebookComputer extends NotebookComputer &#123;</div><div class="line">    @Override</div><div class="line">    public void start() &#123;</div><div class="line">        System.out.println(&quot;惠普笔记本电脑启动&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p><strong>抽象工厂</strong><br>定义了两个方法，分别用来生产台式电脑和笔记本电脑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public abstract class ComputerFactory &#123;</div><div class="line">    public abstract DesktopComputer createDesktopComputer();</div><div class="line">    public abstract NotebookComputer createNotebookComputer();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p><strong>具体工厂</strong><br>联想工厂和惠普工厂用来生产台式机和笔记本这两个不同产品线的电脑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class LenovoFactory extends ComputerFactory &#123;</div><div class="line">    @Override</div><div class="line">    public DesktopComputer createDesktopComputer() &#123;</div><div class="line">        return new LenovoDesktopComputer();</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public NotebookComputer createNotebookComputer() &#123;</div><div class="line">        return new LenovoNotebookComputer();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class HpFactory extends ComputerFactory &#123;</div><div class="line">    @Override</div><div class="line">    public DesktopComputer createDesktopComputer() &#123;</div><div class="line">        return new HpDesktopComputer();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public NotebookComputer createNotebookComputer() &#123;</div><div class="line">        return new HpNotebookComputer();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>客户端调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[]args) &#123;</div><div class="line">        ComputerFactory lenocoFactory=new LenovoFactory();</div><div class="line">        lenocoFactory.createDesktopComputer().start();</div><div class="line">        lenocoFactory.createNotebookComputer().start();</div><div class="line">        ComputerFactory hpFactory=new HpFactory();</div><div class="line">        hpFactory.createDesktopComputer().start();</div><div class="line">        hpFactory.createNotebookComputer().start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><hr><h3 id="模式在-ANDROID-中的应用"><a href="#模式在-ANDROID-中的应用" class="headerlink" title="模式在 ANDROID 中的应用"></a>模式在 ANDROID 中的应用</h3><hr><p>对于 ANDROID 来说，抽象工厂的一个更好的应用是在主题修改上。比如我们的应用中有两套主题，分别为亮色主题 LightTheme 和 暗色主题 DarkTheme。这两种主题我们可以通过一个抽象的类或接口来定义，而在对应主题下我们又有各类不同的 UI 元素，比如 Button、TextView、Dialog、ActionBar 等，这些 UI 元素都会分别对应不同的主题，这些 UI 元素我们也可以通过抽象的类或接口，抽象的主题、具体的主题、抽象的 UI 元素和具体的 UI 元素之间的关系就是抽象工厂模式最好的体现。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-701a3c0b435c4aa9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>代码略…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;hr&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;抽象工厂模式：&lt;strong
      
    
    </summary>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/categories/PATTERN/"/>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/tags/PATTERN/"/>
    
  </entry>
  
  <entry>
    <title>04 设计模式——工厂方法模式</title>
    <link href="http://yoursite.com/2019/08/10/PATTERN/04%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/10/PATTERN/04 设计模式——工厂方法模式/</id>
    <published>2019-08-09T17:00:00.000Z</published>
    <updated>2020-02-25T09:34:27.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><hr><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>工厂方法模式：<strong>定义一个用于创建对象的接口，让子类决定实例化哪个类</strong>。</p><p>工厂方法模式（FACTORY METHOD）是一种常用的类创建型设计模式，此模式的核心精神是封装类中变化的部分，提取其中个性化善变的部分为独立类，通过依赖注入以达到解耦、复用和方便后期维护拓展的目的。在任何需要生成复杂对象的地方，都可以使用工厂方法模式。复杂对象适合使用工厂模式，用 new 就可以完成创建的对象无需使用工厂模式。</p><p>它的核心结构有四个角色，分别是抽象工厂；具体工厂；抽象产品；具体产品。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-057281a7dd7e2590.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>通用模式代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">// 抽象产品类</div><div class="line">public abstract class Product &#123;</div><div class="line">    /**</div><div class="line">     * 产品类的抽象方法，由具体的产品类去实现</div><div class="line">     */</div><div class="line">    public abstract void method();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 具体产品类 A</div><div class="line">public class ConcreteProductA extends Product &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void method() &#123;</div><div class="line">        System.out.println(&quot;产品 A&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体产品类 B</div><div class="line">public class ConcreteProductB extends Product &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void method() &#123;</div><div class="line">        System.out.println(&quot;产品 B&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 抽象工厂类</div><div class="line">public abstract class Factory &#123;</div><div class="line">    /**</div><div class="line">     * 抽象工厂方法，具体由子类去实现</div><div class="line">     * @return 具体的产品类型</div><div class="line">     */</div><div class="line">    public abstract Product createProduct();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 具体工厂类</div><div class="line">public class ConcreteFactory extends Factory &#123;</div><div class="line">    @Override</div><div class="line">    public Product createProduct() &#123;</div><div class="line">        return new ConcreteProductA();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Factory factory = new ConcreteFactory();</div><div class="line">Product p = factory.createProduct();</div><div class="line">p.method();</div></pre></td></tr></table></figure></p><p>这里我们得到的产品对象时 ConcreteProductA 的实例，如果想得到 ConcreteProductB 的实例，更改 ConcreteFactory 中的逻辑即可；或者是新建一个 Factory 的具体实现子类，专门生产 ConcreteProductB 的实例。当然，我们也可以利用反射的方式来简化操作。具体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public abstract class Factory &#123;</div><div class="line">    /**</div><div class="line">     * @param clz 产品对象类型</div><div class="line">     * @return 具体的产品类型</div><div class="line">     */</div><div class="line">    public abstract &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; clz);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ConcreteFactory extends Factory &#123;</div><div class="line">    @Override</div><div class="line">    public &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; clz) &#123;</div><div class="line">        Product p = null;</div><div class="line">        try &#123;</div><div class="line">            p = (Product) Class.forName(clz.getName()).newInstance();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return (T) p;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Factory factory = new ConcreteFactory();</div><div class="line">Product productA = factory.createProduct(ConcreteProductA.class);</div><div class="line">Product productB = factory.createProduct(ConcreteProductB.class);</div><div class="line">productA.method();</div><div class="line">productB.method();</div></pre></td></tr></table></figure></p><p>当我们的工厂只有一个的时候，可以简化掉抽象工厂类，并提供一个静态方法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Factory &#123;</div><div class="line">    public static Product createProduct() &#123;</div><div class="line">        return new ConcreteProductA();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>工厂方法模式是完全符合设计原则的，其降低了对象之间的耦合度。而且，工厂方法模式依赖于抽象的架构，其将实例化的任务交由子类去完成，有非常好的扩展性。</p><hr><h3 id="示例：数据持久化"><a href="#示例：数据持久化" class="headerlink" title="示例：数据持久化"></a>示例：数据持久化</h3><hr><p>ANDROID 中数据持久化为我们提供了 SharePreference、 SQLite 和普通的文件存储等方式。但是对数据的操作都是增删改查，可以把这些共同的操作抽象出来作为抽象产品类，然后每一种持久化方法作为具体产品。</p><p>抽象产品中定义操作的方法，即增删改查。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public abstract class AbstractIoHandler &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 添加个人信息</div><div class="line">     *</div><div class="line">     * @param id 身份证号码</div><div class="line">     * @param name 姓名</div><div class="line">     */</div><div class="line">    public abstract void add(String id, String name);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 根据ID删除一条信息</div><div class="line">     *</div><div class="line">     * @param id 身份证</div><div class="line">     */</div><div class="line">    public abstract void remove(String id);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 更新个人信息</div><div class="line">     *</div><div class="line">     * @param id 身份证</div><div class="line">     * @param name 姓名</div><div class="line">     */</div><div class="line">    public abstract void update(String id, String name);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 查询ID对应的信息</div><div class="line">     *</div><div class="line">     * @param id 身份证</div><div class="line">     * @return 人名</div><div class="line">     */</div><div class="line">    public abstract String query(String id);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>具体的产品，持久化的类型，比如利用文件来持久化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class FileHandler extends AbstractIoHandler &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void add(String id, String name)&#123;</div><div class="line">        //业务处理</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void remove(String id) &#123;</div><div class="line">        //业务处理</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void update(String id, String name) &#123;</div><div class="line">        //业务处理</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String query(String id) &#123;</div><div class="line">        return &quot;&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后是我们的工厂方法，这里仍然采用反射的方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class IoFactory &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取IoHandler</div><div class="line">     *</div><div class="line">     * @param clz AbstractIoHandler类型的类</div><div class="line">     * @return AbstractIoHandler对象</div><div class="line">     */</div><div class="line">    public static &lt;T extends AbstractIoHandler&gt; T getIoHandler(Class&lt;T&gt; clz) &#123;</div><div class="line">        AbstractIoHandler handler = null;</div><div class="line">        try &#123;</div><div class="line">            handler = (AbstractIoHandler) Class.forName(clz.getName()).newInstance();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return (T) handler;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在需要进行数据持久化的地方调用工厂方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">AbstractIoHandler ioHandler = IoFactory.getIoHandler(FileHandler.class);</div><div class="line">System.out.println(ioHandler.query(&quot;123456&quot;));</div></pre></td></tr></table></figure></p><p>这里的例子简化了很多，还有数据库 SQLite 以及 SharePreference 的持久化的类就没有写了。</p><hr><h3 id="ANDROID-源码中的工厂方法模式实现"><a href="#ANDROID-源码中的工厂方法模式实现" class="headerlink" title="ANDROID 源码中的工厂方法模式实现"></a>ANDROID 源码中的工厂方法模式实现</h3><hr><p>在 ANDROID 中对工厂方法模式的应用有很多，例如下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends Activity &#123;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(new LinearLayout(this));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Activity 中的 onCreate 方法就相当于一个工厂方法。为什么呢？因为我们知道 LinearLayout 是一个 ViewGroup，而 ViewGroup 又继承于 View，简单地说就是，所有控件都是 View 的子类，上面的代码中，我们在 MainActivity 的 onCreate 方法中构造一个 View 对象，并设置为当前界面的 ContentView 返回给 framework 处理，如果现在又有一个 LoginActivity，这时我们又在其 onCreate 方法中通过 setContentView 方法设置另外不同的 View，这是不是就是一个工厂模式的结构呢？</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4a8f4026116b9489.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;hr&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;工厂方法模式：&lt;strong
      
    
    </summary>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/categories/PATTERN/"/>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/tags/PATTERN/"/>
    
  </entry>
  
  <entry>
    <title>03 设计模式——原型模式</title>
    <link href="http://yoursite.com/2019/08/09/PATTERN/03%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/09/PATTERN/03 设计模式——原型模式/</id>
    <published>2019-08-08T17:00:00.000Z</published>
    <updated>2020-02-25T06:14:23.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><hr><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>原型模式：<strong>用原型实例指定创建对象的种类，并通过复制这些原型创建新的对象</strong>。</p><p>原型模式是一个创建型的模式。该模式应该有一个样板实例，用户从这个样板对象中复制出一个内部属性一致的对象，这个过程也就是我们俗称的“克隆”。被复制的实例就是我们所称的“原型”，这个原型是可定制的。原型模式多用于创建复杂的或者构造耗时的实例，因为这种情况下，复制一个已经存在的实例可使程序运行更高效。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>1）类初始化需要消耗非常多的资源，这个资源包括数据、硬件资源等，通过原型复制避免这些消耗。<br>2）通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，这时可以使用原型模式。<br>3）一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式复制多个对象供调用者使用，即保护性拷贝。</p><blockquote><p>需要注意的是，通过实现 Cloneable 接口的原型模式在调用 clone 函数构造实例时并不一定比通过 new 操作速度快，只有当通过 new 构造对象较为耗时或者成本高时，通过 clone 方法才能够获得效率上的提升。因此，在使用 Cloneable 接口时需要考虑构建对象的成本以及做一些效率上的测试。当然，实现原型模式不一定非要实现 Cloneable 接口，也有其他的实现方式，见后文。</p></blockquote><h4 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0f7404098cf4ccf9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>Client：客户端用户。<br>Prototype：抽象类或者接口，声明具备 clone 能力。<br>ConcretePrototype：具体的原型类。</p><hr><h3 id="示例：文档拷贝"><a href="#示例：文档拷贝" class="headerlink" title="示例：文档拷贝"></a>示例：文档拷贝</h3><hr><p>在这个例子中，首先创建了一个文档对象，即 WordDocument，这个文档中含有文字和图片。用户经过了长时间的编辑后，打算对该文档做进一步的编辑。但是，这个编辑后的文档是否会被采用还不确定。因此，为了安全起见，用户需要将当前文档拷贝一份，然后再在文档副本上进行修改。如此，这个原始文档就是我们上述所说的样板实例，也就是将要被“克隆”的对象，我们称为“原型”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public class WordDocument implements Cloneable &#123;</div><div class="line">    // 文本</div><div class="line">    private String text;</div><div class="line">    // 图片</div><div class="line">    private ArrayList&lt;String&gt; images = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    public WordDocument() &#123;</div><div class="line">        System.out.println(&quot;---WordDocument 构造函数---&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected WordDocument clone() &#123;</div><div class="line">        try &#123;</div><div class="line">            WordDocument document = (WordDocument) super.clone();</div><div class="line">            document.text = this.text;</div><div class="line">            document.images = this.images;</div><div class="line">            return document;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getText() &#123;</div><div class="line">        return text;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setText(String text) &#123;</div><div class="line">        this.text = text;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ArrayList&lt;String&gt; getImages() &#123;</div><div class="line">        return images;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void addImage(String img) &#123;</div><div class="line">        images.add(img);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 打印文档内容</div><div class="line">     */</div><div class="line">    public void showDocument() &#123;</div><div class="line">        System.out.println(&quot;---Word content start---&quot;);</div><div class="line">        System.out.println(&quot;Text : &quot; + text);</div><div class="line">        System.out.println(&quot;images list : &quot;);</div><div class="line">        for (String name : images) &#123;</div><div class="line">            System.out.println(&quot;image name : &quot; + name);</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;---Word content end---&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通过 WordDocument 类模拟了 Word 文档中的基本元素，即文字和图片。WordDocument 在该原型模式示例中扮演的角色为 ConcretePrototype，而 Cloneable 的角色则为 Prototype。WordDocument 中的 clone 方法用以实现对象克隆。注意，<strong>这个方法并不是 Cloneable 接口的，而是 Object 中的方法</strong>。Cloneable 也是一个标识接口，它表明这个类的对象是可拷贝的。如果没有实现 Cloneable 接口却调用了 clone() 函数将抛出异常。在这个示例中，我们通过实现 Cloneable 接口和覆写 clone 方法实现原型模式。</p><p>下面看看 Client 端的调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">WordDocument originDoc = new WordDocument();</div><div class="line">originDoc.setText(&quot;这是一篇文档&quot;);</div><div class="line">originDoc.addImage(&quot;图片1&quot;);</div><div class="line">originDoc.addImage(&quot;图片2&quot;);</div><div class="line">originDoc.addImage(&quot;图片3&quot;);</div><div class="line">originDoc.showDocument();</div><div class="line"></div><div class="line">WordDocument doc2 = originDoc.clone();</div><div class="line">doc2.showDocument();</div><div class="line"></div><div class="line">doc2.setText(&quot;这是修改过的文档&quot;);</div><div class="line">doc2.addImage(&quot;图片4&quot;);</div><div class="line">doc2.showDocument();</div><div class="line"></div><div class="line">originDoc.showDocument();</div></pre></td></tr></table></figure></p><p>输出结果如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">---WordDocument 构造函数---</div><div class="line">---Word content start---</div><div class="line">Text : 这是一篇文档</div><div class="line">images list : </div><div class="line">image name : 图片1</div><div class="line">image name : 图片2</div><div class="line">image name : 图片3</div><div class="line">---Word content end---</div><div class="line">---Word content start---</div><div class="line">Text : 这是一篇文档</div><div class="line">images list : </div><div class="line">image name : 图片1</div><div class="line">image name : 图片2</div><div class="line">image name : 图片3</div><div class="line">---Word content end---</div><div class="line">---Word content start---</div><div class="line">Text : 这是修改过的文档</div><div class="line">images list : </div><div class="line">image name : 图片1</div><div class="line">image name : 图片2</div><div class="line">image name : 图片3</div><div class="line">image name : 图片4</div><div class="line">---Word content end---</div><div class="line">---Word content start---</div><div class="line">Text : 这是一篇文档</div><div class="line">images list : </div><div class="line">image name : 图片1</div><div class="line">image name : 图片2</div><div class="line">image name : 图片3</div><div class="line">image name : 图片4</div><div class="line">---Word content end---</div></pre></td></tr></table></figure></p><p>从上面可以看到，doc2 是通过 originDoc.clone() 创建的，并且 doc2 第一次输出的时候和 originDoc 输出是一样的，即 doc2 是 originDoc 的一份拷贝，它们的内容是一样的，而 doc2 修改了文本内容以后并不影响 originDoc 的文本内容，这就保证了 originDoc 的安全性。还需要注意的是，通过 clone 拷贝对象时并不会执行构造函数。</p><p>但是，originDoc 的图片列表内容（images）被更改了，这是为什么呢？因为上述示例只是一个<strong>浅拷贝</strong>。</p><hr><h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><hr><ul><li>浅拷贝又叫影子拷贝，上面我们在拷贝文档时并没有把原文档中的字段都重新构造了一遍，而只是拷贝了引用，也就是副文档的字段引用原始文档的字段，这样的话修改副文档中的内容就会连原始文档也改掉了，这就是浅拷贝。</li><li>深拷贝就是在浅拷贝的基础上，对于引用类型的字段也要采用拷贝的形式，比如上面的 images，而像 String、int 这些基本数据类型则没关系</li></ul><p>所以在运用原型模式时建议大家还是用深拷贝。下面我们把上面的浅拷贝改成深拷贝，clone 方法修改如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected WordDocument clone() &#123;</div><div class="line">    try &#123;</div><div class="line">        WordDocument document = (WordDocument) super.clone();</div><div class="line">        document.text = this.text;</div><div class="line">        // document.images = this.images;</div><div class="line">        // 对 images 对象也调用 clone() 函数，进行深拷贝</div><div class="line">        document.images = (ArrayList&lt;String&gt;) this.images.clone();</div><div class="line">        return document;</div><div class="line"></div><div class="line">    &#125;catch (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><hr><h3 id="ANDROID-源码中的原型模式"><a href="#ANDROID-源码中的原型模式" class="headerlink" title="ANDROID 源码中的原型模式"></a>ANDROID 源码中的原型模式</h3><hr><p>在 Android 中，Intent 可能是我们最早接触的几个类型之一，它用于跳转 Activity、启动服务、发布广播等功能，它是 Android 系统各组件之间的纽带，也是组件之间传递数据的载体，正式 Intent 的存在才使得 Android 各个组件之间的耦合性很低，Android 的组件才如此灵活。</p><p>下面以 Intent 来分析源码中的原型模式，首先看如下示例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Uri uri = Uri.parse(&quot;smsto:0800000123&quot;);</div><div class="line">Intent shareIntent = new Intent(Intent.ACTION_SENDTO, uri);</div><div class="line">shareIntent.putExtra(&quot;sms_body&quot;, &quot;The SMS text&quot;);</div><div class="line">// 克隆副本</div><div class="line">Intent intent = (Intent) shareIntent.clone();</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p><p>通过 shareIntent.clone 方法拷贝了一个对象 Intent，然后执行 startActivity(intent)，随即就进入了短信页面，号码为 0800000123，文本内容为 The SMS text，即这些内容都与 shareIntent 一致。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-35fea9630edfbef6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>我们看看 Intent 的 clone() 方法是如何实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public class Intent implements Parcelable, Cloneable &#123;</div><div class="line">    @Override</div><div class="line">    public Object clone() &#123;</div><div class="line">        return new Intent(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Copy constructor.</div><div class="line">     */</div><div class="line">    public Intent(Intent o) &#123;</div><div class="line">        this(o, COPY_MODE_ALL);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Intent(Intent o, @CopyMode int copyMode) &#123;</div><div class="line">        this.mAction = o.mAction;</div><div class="line">        this.mData = o.mData;</div><div class="line">        this.mType = o.mType;</div><div class="line">        this.mPackage = o.mPackage;</div><div class="line">        this.mComponent = o.mComponent;</div><div class="line"></div><div class="line">        if (o.mCategories != null) &#123;</div><div class="line">            this.mCategories = new ArraySet&lt;&gt;(o.mCategories);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (copyMode != COPY_MODE_FILTER) &#123;</div><div class="line">            this.mFlags = o.mFlags;</div><div class="line">            this.mContentUserHint = o.mContentUserHint;</div><div class="line">            this.mLaunchToken = o.mLaunchToken;</div><div class="line">            if (o.mSourceBounds != null) &#123;</div><div class="line">                this.mSourceBounds = new Rect(o.mSourceBounds);</div><div class="line">            &#125;</div><div class="line">            if (o.mSelector != null) &#123;</div><div class="line">                this.mSelector = new Intent(o.mSelector);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (copyMode != COPY_MODE_HISTORY) &#123;</div><div class="line">                if (o.mExtras != null) &#123;</div><div class="line">                    this.mExtras = new Bundle(o.mExtras);</div><div class="line">                &#125;</div><div class="line">                if (o.mClipData != null) &#123;</div><div class="line">                    this.mClipData = new ClipData(o.mClipData);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                if (o.mExtras != null &amp;&amp; !o.mExtras.maybeIsEmpty()) &#123;</div><div class="line">                    this.mExtras = Bundle.STRIPPED;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 代码省略</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>clone 方法并没有调用 super.clone() 来实现对象拷贝，而是调用了 new Intent(this)。在上文中我们提到过，使用 clone 和 new 需要根据构造对象的成本来决定。如果对象的构造成本比较高或者构造较为麻烦，那么使用 clone() 函数效率较高，否则可以使用 new 的形式。</p><hr><h3 id="原型模式实战"><a href="#原型模式实战" class="headerlink" title="原型模式实战"></a>原型模式实战</h3><hr><p>在开发中，我们有时候会满足一些需求，就是有的对象的内容只允许客户端程序读取，而不允许修改，比如用户登录信息。我们通常会用 LoginSession 保存用户的登录信息，这些用户信息可能在 APP 的其他模块被用来做登录校验、用户个人信息显示等。但是，这些信息在客户端程序是不允许修改的。此时，就需要使用原型模式来进行保护性拷贝。表现形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">// 用户实体类</div><div class="line">public class User implements Cloneable &#123;</div><div class="line">    private int age;</div><div class="line">    private String name;</div><div class="line">    private String phoneNum;</div><div class="line">    private Address address;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected Object clone() &#123;</div><div class="line">        User user = null;</div><div class="line">        try &#123;</div><div class="line">            user = (User) super.clone();</div><div class="line">            // 深拷贝</div><div class="line">            user.address = (Address) this.address.clone();</div><div class="line">        &#125; catch (CloneNotSupportedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return user;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // setter &amp; getter</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 用户地址类</div><div class="line">public class Address implements Cloneable &#123;</div><div class="line">    private String city;</div><div class="line">    private String district;</div><div class="line">    private String street;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected Object clone() &#123;</div><div class="line">        Address address = new Address();</div><div class="line">        address.city = this.city;</div><div class="line">        address.district = this.district;</div><div class="line">        address.street = this.street;</div><div class="line"></div><div class="line">        return address;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // setter &amp; getter</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 登录接口</div><div class="line">public interface ILogin &#123;</div><div class="line">    void login();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 登录实现</div><div class="line">public class LoginImpl implements ILogin &#123;</div><div class="line">    @Override</div><div class="line">    public void login() &#123;</div><div class="line">        User loggedUser = new User();</div><div class="line"></div><div class="line">        // 获取用户信息</div><div class="line">        // ...</div><div class="line"></div><div class="line">        // 成功登录后，将用户信息保存到 Session 中</div><div class="line">        LoginSession.getInstance().setLoggedUser(loggedUser);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 登录 Session</div><div class="line">public class LoginSession &#123;</div><div class="line">    // 已登录用户信息</div><div class="line">    private User loggedUser;</div><div class="line"></div><div class="line">    private LoginSession() &#123;&#125;</div><div class="line">    private static class LoginSessionHolder &#123;</div><div class="line">        private static final LoginSession sLoginSession = new LoginSession();</div><div class="line">    &#125;</div><div class="line">    public static LoginSession getInstance() &#123;</div><div class="line">        return LoginSessionHolder.sLoginSession;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 设置已登录的用户信息，不对外开放</div><div class="line">    void setLoggedUser(User user) &#123;</div><div class="line">        loggedUser = user;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public User getLoggedUser() &#123;</div><div class="line">        if (null == loggedUser) return null;</div><div class="line">        return  (User)loggedUser.clone();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这就使得在任何地方调用 getLoggedUser 函数获取到的用户对象都是一个拷贝对象，即使客户端代码一不小心修改了这个拷贝对象，也不会影响最初的已登录用户对象，对已登录用户信息的修改只能通过 setLoggedUser 这个方法，而只有与 LoginSession 在同一个包下的类才能访问这个包级私有方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;hr&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;原型模式：&lt;strong&gt;用
      
    
    </summary>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/categories/PATTERN/"/>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/tags/PATTERN/"/>
    
  </entry>
  
  <entry>
    <title>02 设计模式——建造者模式</title>
    <link href="http://yoursite.com/2019/08/08/PATTERN/02%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/08/PATTERN/02 设计模式——建造者模式/</id>
    <published>2019-08-07T17:00:00.000Z</published>
    <updated>2020-02-20T16:33:03.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><hr><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>建造者模式：<strong>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</strong>。</p><p>Builder 模式是一步一步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更精细地控制对象的构造流程。该模式是为了将构建复杂对象的过程和它的部件解耦，使得构建过程和部件的表示隔离开来。</p><p>因为一个负责对象有大量组成部分，如汽车有车轮、方向盘、发动机、车盘，还有各种小零件，如何将这些部件装配成一辆汽车，这个装配过程很漫长，也很复杂，对于这种情况，为了在构建过程中对外部隐藏实现细节，就可以使用 Builder 模式将部件和组装过程分离，使得构建过程和部件都可以自由扩展，两者之间的耦合也降到最低。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>1）相同的方法，不同的执行顺序，产生不同的事件结果时。<br>2）多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时。<br>3）产品类非常复杂，或者产品类中的调用顺序不同产生了不同的作用，这个时候使用建造者模式非常合适。<br>4）当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值时。</p><h4 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-3ce7e4cc79db97a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从上图可以看到，经典 Buider 模式中有四个角色：</p><ul><li>Product 产品类 —— 产品的抽象类；</li><li>Builder —— 抽象 Builder 类，规范产品的组建，一般是由子类实现具体的组建过程；</li><li>ConcreteBuilder —— 具体的 Builder 类；</li><li>Director —— 统一组装过程。</li></ul><hr><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><p>计算机的组装过程较为复杂，并且组装顺序是不固定的，为了易于理解，我们把计算机组装的过程简化为构建主机、设置操作系统、设置显示器 3 个部分，然后通过 Director 和具体的 Builder 来构建计算机对象。请看下面示例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">// 计算机抽象类，即 Product 角色</div><div class="line">public abstract class Computer &#123;</div><div class="line">    protected String mBoard;</div><div class="line">    protected String mDisplay;</div><div class="line">    protected String mOS;</div><div class="line"></div><div class="line">    protected Computer() &#123;&#125;</div><div class="line"></div><div class="line">    public void setBoard(String board) &#123;</div><div class="line">        this.mBoard = board;</div><div class="line">    &#125;</div><div class="line">    public void setDisplay(String display) &#123;</div><div class="line">        this.mDisplay = display;</div><div class="line">    &#125;</div><div class="line">    public abstract void setOS();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;Computer [&quot; + &quot;mBoard=&apos;&quot; + mBoard + &apos;\&apos;&apos; +</div><div class="line">                &quot;, mDisplay=&apos;&quot; + mDisplay + &apos;\&apos;&apos; + &quot;, mOS=&apos;&quot; + mOS + &apos;]&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体的 Computer 类，Macbook</div><div class="line">public class Macbook extends Computer &#123;</div><div class="line">    protected Macbook() &#123;&#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void setOS() &#123;</div><div class="line">        mOS = &quot;Mac OS X 10.10&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽象 Builder 类</div><div class="line">public abstract class Builder &#123;</div><div class="line">    public abstract void buildBoard(String board);</div><div class="line">    public abstract void buildDisplay(String display);</div><div class="line">    public abstract void buildOS();</div><div class="line">    public abstract Computer create();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体的 Builder 类，MacbookBuilder</div><div class="line">public class MacbookBuilder extends Builder &#123;</div><div class="line">    private Computer mComputer = new Macbook();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildBoard(String board) &#123;</div><div class="line">        mComputer.setBoard(board);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void buildDisplay(String display) &#123;</div><div class="line">        mComputer.setDisplay(display);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void buildOS() &#123;</div><div class="line">        mComputer.setOS();</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public Computer create() &#123;</div><div class="line">        return mComputer;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Director 类，负责构造 Computer</div><div class="line">public class Director &#123;</div><div class="line">    Builder mBuilder = null;</div><div class="line"></div><div class="line">    public Director(Builder builder) &#123;</div><div class="line">        this.mBuilder = builder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void construct(String board, String display) &#123;</div><div class="line">        mBuilder.buildBoard(board);</div><div class="line">        mBuilder.buildDisplay(display);</div><div class="line">        mBuilder.buildOS();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试代码</div><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Builder builder = new MacbookBuilder();</div><div class="line">        Director pcDirector = new Director(builder);</div><div class="line">        pcDirector.construct(&quot;英特尔主板&quot;, &quot;Retina 显示器&quot;);</div><div class="line">        System.out.println(&quot;Computer Info : &quot; + builder.create().toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>输出结果：</p><blockquote><p>Computer Info : Computer [mBoard=英特尔主板, mDisplay=Retina 显示器, mOS=Mac OS X 10.10]</p></blockquote><p>上述示例中，通过具体的 MacbookBuilder 来构建 Macbook 对象，而 Director 封装了构建复杂产品对象的过程，对外隐藏构建细节。Builder 与 Director 一起将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的对象。</p><p>值得注意的是，在现实开发过程当中，Director 角色经常会被省略。而直接使用一个 Builder 来进行对象的组装，这个 Builder 通常为链式调用，它的关键点是每个 setter 方法都返回自身，也就是 return this，这样就使得 setter 方法可以链式调用，代码大致如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new TestBuilder().setA(&quot;A&quot;).setB(&quot;B&quot;).create();</div></pre></td></tr></table></figure></p><p>通过这种形式不仅去除了 Director 角色，整个结构也更加简单，也能对 Product 对象的组装过程有更精细的控制。</p><hr><h3 id="ANDROID-源码中的-Builder-模式"><a href="#ANDROID-源码中的-Builder-模式" class="headerlink" title="ANDROID 源码中的 Builder 模式"></a>ANDROID 源码中的 Builder 模式</h3><hr><p>在 ANDROID 源码中，最常用到的 Builder 模式就是 AlertDialog.Builder，使用该 Builder 来构建复杂的 AlertDialog 对象。在开发过程中，我们经常用到 AlertDialog，具体示例如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">private void showDialog(final Context context) &#123;</div><div class="line">    AlertDialog.Builder builder = new AlertDialog.Builder(context);</div><div class="line">    builder.setIcon(R.drawable.taiji)</div><div class="line">            .setTitle(&quot;Title&quot;)</div><div class="line">            .setMessage(&quot;Message&quot;)</div><div class="line">            .setPositiveButton(&quot;Button1&quot;, new DialogInterface.OnClickListener() &#123;</div><div class="line">                @Override</div><div class="line">                public void onClick(DialogInterface dialog, int which) &#123;</div><div class="line">                    Toast.makeText(context, &quot;Button1&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">            .setNeutralButton(&quot;Button2&quot;, new DialogInterface.OnClickListener() &#123;</div><div class="line">                @Override</div><div class="line">                public void onClick(DialogInterface dialog, int which) &#123;</div><div class="line">                    Toast.makeText(context, &quot;Button2&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">            .setNegativeButton(&quot;Button3&quot;, new DialogInterface.OnClickListener() &#123;</div><div class="line">                @Override</div><div class="line">                public void onClick(DialogInterface dialog, int which) &#123;</div><div class="line">                    Toast.makeText(context, &quot;Button3&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">            .create()</div><div class="line">            .show();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>显示结果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-aada48ecfbd9eca5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从类名就可以看出这就是一个 Builder 模式，通过 Builder 对象来组装 Dialog 的各个部分，如 title、buttons、message 等，将 Dialog 的构造和表示进行分离。下面看看 AlertDialog 的相关源码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">public class AlertDialog extends AppCompatDialog implements DialogInterface &#123;</div><div class="line">    // AlertController 接收 Builder 成员变量 p 中的各个参数</div><div class="line">    final AlertController mAlert;</div><div class="line"></div><div class="line">    protected AlertDialog(@NonNull Context context, @StyleRes int themeResId) &#123;</div><div class="line">        super(context, resolveDialogTheme(context, themeResId));</div><div class="line">        // 构造 AlertController</div><div class="line">        mAlert = new AlertController(getContext(), this, getWindow());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void setTitle(CharSequence title) &#123;</div><div class="line">        super.setTitle(title);</div><div class="line">        mAlert.setTitle(title);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setMessage(CharSequence message) &#123;</div><div class="line">        mAlert.setMessage(message);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 代码省略</div><div class="line"></div><div class="line">    public static class Builder &#123;</div><div class="line">        // 1、存储 AlertDialog 的各个参数，如 title、message、icon 等</div><div class="line">        private final AlertController.AlertParams P;</div><div class="line">        private final int mTheme;</div><div class="line"></div><div class="line">        public Builder(@NonNull Context context) &#123;</div><div class="line">            this(context, resolveDialogTheme(context, 0));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public Builder(@NonNull Context context, @StyleRes int themeResId) &#123;</div><div class="line">            P = new AlertController.AlertParams(new ContextThemeWrapper(</div><div class="line">                    context, resolveDialogTheme(context, themeResId)));</div><div class="line">            mTheme = themeResId;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 代码省略</div><div class="line"></div><div class="line">        // 2、设置各种参数</div><div class="line">        public Builder setTitle(@Nullable CharSequence title) &#123;</div><div class="line">            P.mTitle = title;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        public Builder setMessage(@StringRes int messageId) &#123;</div><div class="line">            P.mMessage = P.mContext.getText(messageId);</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        public Builder setView(View view) &#123;</div><div class="line">            P.mView = view;</div><div class="line">            P.mViewLayoutResId = 0;</div><div class="line">            P.mViewSpacingSpecified = false;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 3、构建 AlertDialog，传递参数</div><div class="line">        public AlertDialog create() &#123;</div><div class="line">            // 4、调用 new AlertDialog 构造对象，并且将参数传递给个体 AlertDialog</div><div class="line">            final AlertDialog dialog = new AlertDialog(P.mContext, mTheme);</div><div class="line">            // 5、将 P 中的参数应用到 dialog 中的 mAlert 对象中</div><div class="line">            P.apply(dialog.mAlert);</div><div class="line">            dialog.setCancelable(P.mCancelable);</div><div class="line">            if (P.mCancelable) &#123;</div><div class="line">                dialog.setCanceledOnTouchOutside(true);</div><div class="line">            &#125;</div><div class="line">            dialog.setOnCancelListener(P.mOnCancelListener);</div><div class="line">            dialog.setOnDismissListener(P.mOnDismissListener);</div><div class="line">            if (P.mOnKeyListener != null) &#123;</div><div class="line">                dialog.setOnKeyListener(P.mOnKeyListener);</div><div class="line">            &#125;</div><div class="line">            return dialog;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上述代码中，Builder 类可以设置 AlertDialog 中的 title、message、button 等参数，这些参数都存储在类型为 AlertController.AlertParams 的成员变量 P 中，AlertController.AlertParams 中包含了与 AlertDialog 视图中对应的成员变量。在调用 Builder 类的 create 函数时会创建 AlertDialog，并且将 Builder 成员变量 P 中保存的参数应用到 AlertDialog 的 mAlert 对象中，即 P.apply(dialog.mAlert) 代码段。我们再看看 apply 函数的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public void apply(AlertController dialog) &#123;</div><div class="line">    if (mCustomTitleView != null) &#123;</div><div class="line">        dialog.setCustomTitle(mCustomTitleView);</div><div class="line">    &#125; else &#123;</div><div class="line">        if (mTitle != null) &#123;</div><div class="line">            dialog.setTitle(mTitle);</div><div class="line">        &#125;</div><div class="line">        if (mIcon != null) &#123;</div><div class="line">            dialog.setIcon(mIcon);</div><div class="line">        &#125;</div><div class="line">        if (mIconId != 0) &#123;</div><div class="line">            dialog.setIcon(mIconId);</div><div class="line">        &#125;</div><div class="line">        if (mIconAttrId != 0) &#123;</div><div class="line">            dialog.setIcon(dialog.getIconAttributeResId(mIconAttrId));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (mMessage != null) &#123;</div><div class="line">        dialog.setMessage(mMessage);</div><div class="line">    &#125;</div><div class="line">    if (mPositiveButtonText != null || mPositiveButtonIcon != null) &#123;</div><div class="line">        dialog.setButton(DialogInterface.BUTTON_POSITIVE, mPositiveButtonText,</div><div class="line">                mPositiveButtonListener, null, mPositiveButtonIcon);</div><div class="line">    &#125;</div><div class="line">    if (mNegativeButtonText != null || mNegativeButtonIcon != null) &#123;</div><div class="line">        dialog.setButton(DialogInterface.BUTTON_NEGATIVE, mNegativeButtonText,</div><div class="line">                mNegativeButtonListener, null, mNegativeButtonIcon);</div><div class="line">    &#125;</div><div class="line">    if (mNeutralButtonText != null || mNeutralButtonIcon != null) &#123;</div><div class="line">        dialog.setButton(DialogInterface.BUTTON_NEUTRAL, mNeutralButtonText,</div><div class="line">                mNeutralButtonListener, null, mNeutralButtonIcon);</div><div class="line">    &#125;</div><div class="line">    // For a list, the client can either supply an array of items or an</div><div class="line">    // adapter or a cursor</div><div class="line">    if ((mItems != null) || (mCursor != null) || (mAdapter != null)) &#123;</div><div class="line">        createListView(dialog);</div><div class="line">    &#125;</div><div class="line">    if (mView != null) &#123;</div><div class="line">        if (mViewSpacingSpecified) &#123;</div><div class="line">            dialog.setView(mView, mViewSpacingLeft, mViewSpacingTop, </div><div class="line">                    mViewSpacingRight, mViewSpacingBottom);</div><div class="line">        &#125; else &#123;</div><div class="line">            dialog.setView(mView);</div><div class="line">        &#125;</div><div class="line">    &#125; else if (mViewLayoutResId != 0) &#123;</div><div class="line">        dialog.setView(mViewLayoutResId);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 apply 函数中，只是将 AlertParams 参数设置到 AlertController 中，例如，将标题设置到 Dialog 对应的标题视图中，将 Message 设置到内容视图中等。当我们获取到 AlertDialog 对象后，通过 show 函数就可以显示这个对话框。而 show 函数最终调用的是 Dialog 类的 show 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class Dialog implements DialogInterface, Window.Callback,</div><div class="line">        KeyEvent.Callback, OnCreateContextMenuListener, </div><div class="line">        Window.OnWindowDismissedCallback &#123;</div><div class="line">    </div><div class="line">    // 代码省略</div><div class="line">    </div><div class="line">    public void show() &#123;</div><div class="line">        // 已经是显示状态，则return</div><div class="line">        if (mShowing) &#123;</div><div class="line">            if (mDecor != null) &#123;</div><div class="line">                if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123;</div><div class="line">                    mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);</div><div class="line">                &#125;</div><div class="line">                mDecor.setVisibility(View.VISIBLE);</div><div class="line">            &#125;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mCanceled = false;</div><div class="line"></div><div class="line">        // 1、onCreate 调用</div><div class="line">        if (!mCreated) &#123;</div><div class="line">            dispatchOnCreate(null);</div><div class="line">        &#125;</div><div class="line">        // 2、onStart</div><div class="line">        onStart();</div><div class="line">        // 3、获取 DecorView</div><div class="line">        mDecor = mWindow.getDecorView();</div><div class="line"></div><div class="line">        // 代码省略</div><div class="line"></div><div class="line">        // 4、获取布局参数</div><div class="line">        WindowManager.LayoutParams l = mWindow.getAttributes();</div><div class="line"></div><div class="line">        // 5、将 mDecor 添加到 WindowManager 中</div><div class="line">        mWindowManager.addView(mDecor, l);</div><div class="line">        mShowing = true;</div><div class="line">        // 发送一个显示 Dialog 的消息</div><div class="line">        sendShowMessage();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 show 函数中主要做了如下几个事情：<br>1）通过 dispatchOnCreate 函数来调用 AlertDialog 的 onCreate 函数；<br>2）然后调用 AlertDialog 的 onStart 函数；<br>3）最后将 Dialog 的 DecorView 添加到 WindowManager 中。</p><blockquote><p>这里的 AlertDialog.Builder 同时扮演了上文中提到的 Builder、ConcreteBuilder、Director 的角色，简化了 Builder 模式的设计。当模块比较稳定，不存在一些变化时，可以在经典模式实现的基础上做出一些精简，而不是照搬 GOF 上的经典实现，更不要生搬硬套，使程序失去架构之美。</p></blockquote><hr><h3 id="Builder-模式实战"><a href="#Builder-模式实战" class="headerlink" title="Builder 模式实战"></a>Builder 模式实战</h3><hr><p>配置 ImageLoader 的参数：缓存、图片加载中显示的图片、加载失败后显示的图片、图片加载策略、线程数等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line">    // 图片加载配置对象</div><div class="line">    private ImageLoaderConfig mConfig;</div><div class="line">    </div><div class="line">    // 省略单例模式代码</div><div class="line">    </div><div class="line">    // 初始化 ImageLoader</div><div class="line">    public void init(ImageLoaderConfig config) &#123;</div><div class="line">        mConfig = config;</div><div class="line">        // 检测配置的合法性，内部会根据配置做一些初始化操作</div><div class="line">        checkConfig();</div><div class="line">        // 代码省略</div><div class="line">    &#125;</div><div class="line">    // 代码省略</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>把配置的代码基本上都封装到了 ImageLoaderConfig 和 Builder 对象中。其代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">public class ImageLoaderConfig &#123;</div><div class="line">    // 图片缓存配置</div><div class="line">    private BitmapCache bitmapCache = new MemoryCache();</div><div class="line">    // 加载图片时的 loading 和加载失败的图片配置对象</div><div class="line">    private DisplayConfig displayConfig = new DisplayConfig();</div><div class="line">    // 加载策略</div><div class="line">    private LoadPolicy loadPolicy = new SerialPolicy();</div><div class="line">    // 线程数量，默认为 CPU 数量 + 1</div><div class="line">    private int threadCount = Runtime.getRuntime().availableProcessors() + 1;</div><div class="line"></div><div class="line">    private ImageLoaderConfig() &#123;&#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 配置类的 Builder</div><div class="line">     */</div><div class="line">    public static class Builder &#123;</div><div class="line">        BitmapCache bitmapCache = new MemoryCache();</div><div class="line">        DisplayConfig displayConfig = new DisplayConfig();</div><div class="line">        LoadPolicy loadPolicy = new SerialPolicy();</div><div class="line">        int threadCount = Runtime.getRuntime().availableProcessors() + 1;</div><div class="line"></div><div class="line">        public Builder setThreadCount(int threadCount) &#123;</div><div class="line">            this.threadCount = threadCount;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        public Builder setCache(BitmapCache bitmapCache) &#123;</div><div class="line">            this.bitmapCache = bitmapCache;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        public Builder setLoadingPlaceholder(int resId) &#123;</div><div class="line">            displayConfig.loadingResId = resId;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        public Builder setNotFoundPlaceholder(int resId) &#123;</div><div class="line">            displayConfig.failedResId = resId;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public Builder setLoadPolicy(LoadPolicy loadPolicy) &#123;</div><div class="line">            if (loadPolicy != null) &#123;</div><div class="line">                loadPolicy = loadPolicy;</div><div class="line">            &#125;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        void applyConfig(ImageLoaderConfig config) &#123;</div><div class="line">            config.bitmapCache = this.bitmapCache;</div><div class="line">            config.displayConfig = this.displayConfig;</div><div class="line">            config.loadPolicy = this.loadPolicy;</div><div class="line">            config.threadCount = this.threadCount;</div><div class="line">        &#125;</div><div class="line">        // 根据已经设置好的属性创建配置对象</div><div class="line">        public ImageLoaderConfig create() &#123;</div><div class="line">            ImageLoaderConfig config = new ImageLoaderConfig();</div><div class="line">            applyConfig(config);</div><div class="line">            return config;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通过将 ImageLoaderConfig 的构造函数、字段私有化，使得外部不能访问内部属性，用户唯一能够设置属性的地方就是通过 Builder 对象了，也就是说用户只能通过 Builder 对象构造 ImageLoaderConfig 对象，这就是构建和表示相分离。</p><p>用户的使用代码如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private void initImageLoader() &#123;</div><div class="line">    ImageLoaderConfig config = new ImageLoaderConfig.Builder()</div><div class="line">            .setLoadingPlaceholder(R.drawable.loading)</div><div class="line">            .setNotFoundPlaceholder(R.drawable.not_found)</div><div class="line">            .setCache(new DoubleCache(this))</div><div class="line">            .setThreadCount(4)</div><div class="line">            .setLoadPolicy(new ReversePolicy()).create();</div><div class="line">    ImageLoader.getInstance().init(config);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;hr&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;建造者模式：&lt;strong&gt;
      
    
    </summary>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/categories/PATTERN/"/>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/tags/PATTERN/"/>
    
  </entry>
  
  <entry>
    <title>02 设计模式——单例模式</title>
    <link href="http://yoursite.com/2019/08/07/PATTERN/01%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/07/PATTERN/01 设计模式——单例模式/</id>
    <published>2019-08-06T17:00:00.000Z</published>
    <updated>2020-02-20T13:39:26.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><hr><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>单例模式：<strong>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例</strong>。</p><p>确保某个类有且只有一个对象的场景，避免产生多个对象消耗过多的资源，或者某种类型的对象只应该有且只有一个。例如，创建一个对象需要消耗的资源过多，如要访问 IO 和数据库等资源，这是就要考虑使用单例模式。</p><p>实现单例模式主要有如下几个关键点：</p><ul><li>构造函数不对外开放，一般为 private；</li><li>通过一个静态方法或者枚举返回单例类对象；</li><li>确保单例类的对象有且只有一个，尤其是在多线程环境下；</li><li>确保单例类对象在反序列化时不会重新构建对象。</li></ul><blockquote><p>单例对象如果持有 Context，那么很容易引发内存泄漏，此时需要注意传递给单例对象的 Context 最好是 Application Context。</p></blockquote><hr><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p>在一个应用中，应该只有一个 ImageLoader 实例，这个 ImageLoader 中又含有线程池、缓存系统、网络请求等，很消耗资源。因此，没有理由让它构造多个实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line">    private static ImageLoader sInstance = new ImageLoader();</div><div class="line">    private ImageLoader() &#123;&#125;</div><div class="line">    public static ImageLoader getInstance() &#123;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上述写法又被称为<strong>饿汉式单例模式</strong>，在声明静态对象时就已经初始化，符合前面三条关键点，但在反序列化的情况下它们会重新创建对象。</p><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>我们知道通过序列化可以将一个单例的实例对象写到磁盘，然后再读回来，从而有效地获得一个实例。即使构造函数是私有的，反序列化时依然可以通过特殊的途径去创建类的一个新的实例，相当于调用该类的构造函数。反序列化操作提供了一个很特别的钩子函数，类中具有一个私有的 readResolve() 函数，这个函数可以让开发人员控制对象的反序列化。例如，如果要杜绝上述示例中的单例对象在反序列化时重新生成对象，那么必须加入 readResolve 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader implements Serializable &#123;</div><div class="line">    private static final long serialVersionUID = 0L;</div><div class="line">    private static ImageLoader sInstance = new ImageLoader();</div><div class="line">    </div><div class="line">    private ImageLoader() &#123;&#125;</div><div class="line">    </div><div class="line">    public static ImageLoader getInstance() &#123;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Object readResolve() throws ObjectStreamException &#123;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>也就是在 readResolve 方法中将单例对象返回，而不是重新生成一个新的对象。而对于枚举类，并不存在这个问题，因为即使反序列化它也不会重新生成新的实例。另外有两点需要注意：</p><ul><li>可序列化类中的字段类型不是 Java 的内置类型，那么该字段类型也需要实现 Serializable 接口；</li><li>如果调整了可序列化类的内部结构，例如新增、去除某个字段，但没有修改 serialVersionUID，那么会引发 java.io.InvalidClassException 异常或者导致某个属性为 0 或者 null。此时最好的方案是我们直接将 serialVersionUID 设置为 0L，这样即使修改了类的内部结构，我们反序列化不会抛出该异常，只是那些新修改的字段会为 0 或者 null。</li></ul><hr><h3 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h3><hr><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><p>懒汉模式是声明一个静态变量，并且在用户第一次调用 getInstance 时进行初始化，而上述的恶汉模式是在声明静态对象时就已经初始化。实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line">    private static ImageLoader sInstance;</div><div class="line">    private ImageLoader() &#123;&#125;</div><div class="line"></div><div class="line">    public static ImageLoader getInstance() &#123;</div><div class="line">        if (sInstance == null) &#123;</div><div class="line">            sInstance = new ImageLoader();</div><div class="line">        &#125;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这种模式不能保证在多线程环境下确保单例类的对象有且只有一个，所以我们会添加 synchronized 关键字进行同步。但若是将 synchronized 添加到 getInstance 函数上，会出现每次调用该方法都进行同步的情况，造成不必要的同步开销。代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line">    private static ImageLoader sInstance;</div><div class="line">    private ImageLoader() &#123;&#125;</div><div class="line"></div><div class="line">    public static synchronized ImageLoader getInstance() &#123;</div><div class="line">        if (sInstance == null) &#123;</div><div class="line">            sInstance = new ImageLoader();</div><div class="line">        &#125;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>上述方式不建议使用，但在它的基础上添加双重检查锁定机制（Double Check Lock，DCL）进行优化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line">    private static ImageLoader sInstance;</div><div class="line">    private ImageLoader() &#123;&#125;</div><div class="line"></div><div class="line">    public static ImageLoader getInstance() &#123;</div><div class="line">        if (sInstance == null) &#123;</div><div class="line">            synchronized (ImageLoader.class) &#123;</div><div class="line">                if (sInstance == null) &#123;</div><div class="line">                    sInstance = new ImageLoader();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样一来，DCL 解决了资源消耗、多余同步、线程安全等问题，似乎很完美，但笔者也不推荐这种写法。它还是会在某种情况下出现失效的问题，这个问题被称为双重检查锁定失效，在《Java 并发编程实践》一书的最后谈到了这个问题，并指出这种“优化”是丑陋的，不赞成使用。</p><h4 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h4><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line">    private ImageLoader() &#123;&#125;</div><div class="line">    public static ImageLoader getInstance() &#123;</div><div class="line">        return ImageLoaderHolder.sInstance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 静态内部类</div><div class="line">    private static class ImageLoaderHolder &#123;</div><div class="line">        private static final ImageLoader sInstance = new ImageLoader();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当第一次加载 ImageLoader 类时并不会初始化 sInstance，只有在第一次调用 ImageLoader 的 getInstance 方法时才会导致 sInstance 被初始化。因此，第一次调用 getInstance 方法会导致虚拟机加载 ImageLoaderHolder 类，这种方式不仅能确保线程安全，也能够保证单例对象的唯一性，同时也延迟了单例的实例化，所以这是推荐使用的单例模式实现方式。如果有反序列化的情况下，要加入 readResolve 方法，具体代码参考饿汉式反序列章节。</p><h4 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h4><p>前面讲解的单例模式实现方式不是稍显麻烦就是会在某些情况下出现问题，还有没有更简单的实现方式呢？我们看看下面的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public enum SingletonEnum &#123;</div><div class="line">    INSTANCE;</div><div class="line">    public void doSomething() &#123;</div><div class="line">        System.out.println(&quot;do sth.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>写法简单，而且保证线程安全、序列化与反序列化安全、反射安全。奈何 ANDROID 官网不建议使用 Enums，占用内存多（Enums often require more than twice as much memory as static constants.）。<a href="https://www.liaohuqiu.net/cn/posts/android-enum-memory-usage/" target="_blank" rel="external">关于 Enum 的使用博客</a>。</p><h4 id="使用容器实现单例模式"><a href="#使用容器实现单例模式" class="headerlink" title="使用容器实现单例模式"></a>使用容器实现单例模式</h4><p>具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class SingletonManager &#123;</div><div class="line">    private static Map&lt;String, Object&gt; objMap = new HashMap&lt;&gt;();</div><div class="line">    </div><div class="line">    private SingletonManager() &#123;&#125;</div><div class="line">    </div><div class="line">    public static void registerService(String key, Object instance) &#123;</div><div class="line">        if (!objMap.containsKey(key)) &#123;</div><div class="line">            objMap.put(key, instance);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static Object getService(String key) &#123;</div><div class="line">        return objMap.get(key);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在程序的初始，将多种单例类型注入到一个统一的管理类中，在使用时根据 key 获取对象对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合。</p><hr><h3 id="ANDROID-源码中的单例模式"><a href="#ANDROID-源码中的单例模式" class="headerlink" title="ANDROID 源码中的单例模式"></a>ANDROID 源码中的单例模式</h3><hr><p>在 ANDROID 系统中，我们经常会通过 Context 获取系统级别的服务，如 WindowsManagerService、ActivityManagerService 等，更常用的是一个 LayoutInflater 的类。这些服务会在合适的时候以单例的形式注册在系统中，在我们需要的时候就通过 Context 的 getSystemService(String name) 获取。我们以 LayoutInflater 为例来说明，平时我们使用 LayoutInflater 较为常见的地方是在 ListView 的 getView 方法中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void getView(int position, View convertView, ViewGroup parent) &#123;</div><div class="line">    View itemView = null;</div><div class="line">    if (convertView == null) &#123;</div><div class="line">        itemView = LayoutInflater.from(mContext).inflate(mLayoutId, null);</div><div class="line">        ...</div><div class="line">    &#125; else &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通常我们使用 LayoutInflater.from(Context) 来获取 LayoutInflater 服务，下面看看 LayoutInflater.from(Context) 的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static LayoutInflater from(Context context) &#123;</div><div class="line">    LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(</div><div class="line">            Context.LAYOUT_INFLATER_SERVICE);</div><div class="line">    if (LayoutInflater == null) &#123;</div><div class="line">        throw new AssertionError(&quot;LayoutInflater not found.&quot;);</div><div class="line">    &#125;</div><div class="line">    return LayoutInflater;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看到 from(Context) 函数内部调用的是 Context 类的 getSystemService(String key) 方法，我们跟踪到 Context 类看到，该类是抽象类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public abstract class Context &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>getView 中使用的 Context 对象的具体实现类是什么呢？其实在 Application、Activity、Service 中都会存在一个 Context 对象，即 Context 的总个数为 Activity 个数 + Service 个数 + 1。而 ListView 通常都是显示在 Activity 中，那么我们就以 Activity 中的 Context 来分析。</p><p>我们知道，一个 Activity 的入口是 ActivityThread 的 main 函数，在 main 函数中创建一个新的 ActivityThread 对象，并且启动消息循环（UI 线程），创建新的 Activity、新的 Context 对象，然后将该 Context 对象传递给 Activity。下面我们看看 ActivityThread 源代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    </div><div class="line">    // 代码省略</div><div class="line"></div><div class="line">    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</div><div class="line">    // 主线程消息循环</div><div class="line">    Looper.prepareMainLooper();</div><div class="line">    // 创建 ActivityThread 对象</div><div class="line">    ActivityThread thread = new ActivityThread();</div><div class="line">    thread.attach(false, startSeq);</div><div class="line"></div><div class="line">    if (sMainThreadHandler == null) &#123;</div><div class="line">        sMainThreadHandler = thread.getHandler();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Looper.loop();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">private void attach(boolean system, long startSeq) &#123;</div><div class="line">    sCurrentActivityThread = this;</div><div class="line">    mSystemThread = system;</div><div class="line">    // 不是系统应用</div><div class="line">    if (!system) &#123;</div><div class="line">        ViewRootImpl.addFirstDrawHandler(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                ensureJitEnabled();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;,</div><div class="line">                UserHandle.myUserId());</div><div class="line">        RuntimeInit.setApplicationObject(mAppThread.asBinder());</div><div class="line">        final IActivityManager mgr = ActivityManager.getService();</div><div class="line">        try &#123;</div><div class="line">            // 关联 mAppThread</div><div class="line">            mgr.attachApplication(mAppThread, startSeq);</div><div class="line">        &#125; catch (RemoteException ex) &#123;</div><div class="line">            throw ex.rethrowFromSystemServer();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 代码省略</div><div class="line">    &#125;</div><div class="line">    // 代码省略</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 main 方法中，我们创建一个 ActivityThread 对象后，调用了其 attach 函数，并且参数为 false，即非系统应用，会通过 Binder 机制与 ActivityManagerService 通信，并且最终调用 handleLaunchActivity 函数，该函数的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public Activity handleLaunchActivity(ActivityClientRecord r,</div><div class="line">            PendingTransactionActions pendingActions, Intent customIntent) &#123;</div><div class="line">    // 代码省略</div><div class="line">    final Activity a = performLaunchActivity(r, customIntent);</div><div class="line">    // 代码省略</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</div><div class="line">    // 代码省略</div><div class="line">    // 1、获取 Context 对象</div><div class="line">    ContextImpl appContext = createBaseContextForActivity(r);</div><div class="line">    Activity activity = null;</div><div class="line">    try &#123;</div><div class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</div><div class="line">        // 2、创建 Activity</div><div class="line">        activity = mInstrumentation.newActivity(</div><div class="line">                cl, component.getClassName(), r.intent);</div><div class="line">        // 代码省略</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        // 代码省略</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        // 创建 Application</div><div class="line">        Application app = r.packageInfo.makeApplication(false, mInstrumentation);</div><div class="line">        if (activity != null) &#123;</div><div class="line">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</div><div class="line">            Configuration config = new Configuration(mCompatConfiguration);</div><div class="line">            // 3、将 appContext 等对象 attach 到 activity 中</div><div class="line">            activity.attach(appContext, this, getInstrumentation(), r.token,</div><div class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</div><div class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</div><div class="line">                    r.referrer, r.voiceInteractor, window, r.configCallback);</div><div class="line">            // 代码省略</div><div class="line">            // 4、调用 Activity 的 onCreate 方法</div><div class="line">            if (r.isPersistable()) &#123;</div><div class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</div><div class="line">            &#125; else &#123;</div><div class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</div><div class="line">            &#125;</div><div class="line">            // 代码省略</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125; catch (SuperNotCalledException e) &#123;</div><div class="line">        throw e;</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        // 代码省略</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return activity;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">private ContextImpl createBaseContextForActivity(ActivityClientRecord r) &#123;</div><div class="line">    // 5、创建 Context 对象，实现类是 ContextImpl</div><div class="line">    ContextImpl appContext = ContextImpl.createActivityContext(</div><div class="line">            this, r.packageInfo, r.activityInfo, r.token, displayId, r.overrideConfig);</div><div class="line">    // 代码省略</div><div class="line">    return appContext;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通过上面 1~5 注释处的代码分析可以知道，Context 的实现类为 ContextImpl。继续跟踪 ContextImpl 类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class ContextImpl extends Context &#123;</div><div class="line">    // The system service cache for the system services that are cached per-ContextImpl.</div><div class="line">    final Object[] mServiceCache = SystemServiceRegistry.createServiceCache();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object getSystemService(String name) &#123;</div><div class="line">        return SystemServiceRegistry.getSystemService(this, name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 代码省略</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>继续跟踪 SystemServiceRegistry 类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">final class SystemServiceRegistry &#123;</div><div class="line">    // 1、Service 容器</div><div class="line">    private static final HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =</div><div class="line">            new HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();</div><div class="line"></div><div class="line">    // 2、注册服务器</div><div class="line">    private static &lt;T&gt; void registerService(String serviceName, Class&lt;T&gt; serviceClass,</div><div class="line">            ServiceFetcher&lt;T&gt; serviceFetcher) &#123;</div><div class="line">        SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);</div><div class="line">        SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 静态语句块，第一次加载该类时执行（只执行一次，保证实例的唯一性）</div><div class="line">    static &#123;</div><div class="line">        // 代码省略</div><div class="line">        // 注册 LayoutInflater Service</div><div class="line">        registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</div><div class="line">                new CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public LayoutInflater createService(ContextImpl ctx) &#123;</div><div class="line">                return new PhoneLayoutInflater(ctx.getOuterContext());</div><div class="line">            &#125;&#125;);</div><div class="line">        // 代码省略</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 根据 key 获取对应的服务</div><div class="line">    public static Object getSystemService(ContextImpl ctx, String name) &#123;</div><div class="line">        ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</div><div class="line">        return fetcher != null ? fetcher.getService(ctx) : null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 代码省略</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从 SystemServiceRegistry 类的部分代码中可以看到，在虚拟机第一次加载该类时会注册各种 ServiceFetcher，其中就包含了 LayoutInflater Service。将这些服务以键值对的形式储存在一个 HashMap 中，用户使用时只需要根据 key 来获取到对应的 ServiceFetcher，然后通过 ServiceFetcher 对象的 getService 函数来获取具体的服务对象。当第一次获取时，会调用 ServiceFetcher 的 createService 函数创建服务对象，然后将该对象缓存到一个列表中，下次再取时直接从缓存中获取，避免重复创建对象，从而达到单例的效果。这种模式就是前文描述的通过容器实现单例模式。系统核心服务以单例形式存在，减少了资源消耗。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;hr&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;单例模式：&lt;strong&gt;确
      
    
    </summary>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/categories/PATTERN/"/>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/tags/PATTERN/"/>
    
  </entry>
  
  <entry>
    <title>00.6 ANDROID 面向对象的六大原则——迪米特原则</title>
    <link href="http://yoursite.com/2019/08/06/PATTERN/00.6%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2019/08/06/PATTERN/00.6 ANDROID 面向对象的六大原则——迪米特原则/</id>
    <published>2019-08-05T17:00:00.000Z</published>
    <updated>2020-02-20T13:44:01.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><hr><p><a href="https://xianxiaotao.github.io/2019/08/01/PATTERN/01.1%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/" target="_blank" rel="external">第一篇：单一职责原则</a><br><a href="https://xianxiaotao.github.io/2019/08/02/PATTERN/01.2%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/" target="_blank" rel="external">第二篇：开闭原则</a><br><a href="https://xianxiaotao.github.io/2019/08/03/PATTERN/01.3%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/" target="_blank" rel="external">第三篇：里氏替换原则</a><br><a href="https://xianxiaotao.github.io/2019/08/04/PATTERN/01.4%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/" target="_blank" rel="external">第四篇：依赖倒置原则</a><br><a href="https://xianxiaotao.github.io/2019/08/05/PATTERN/01.5%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/" target="_blank" rel="external">第五篇：接口隔离原则</a><br><a href="">第六篇：本文</a></p><hr><h3 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h3><hr><p>英文全称为 Law of Demeter，LOD，也称为最少知识原则，意思都是<strong>一个对象应该对其他对象有最少的了解</strong>。通俗的讲，一个类应该对自己需要耦合或调用的类知道得最少，类的内部如何实现与调用者或者依赖者没关系，调用者或者依赖者只需要知道它需要的方法即可，其他的可一概不用管。类与类之间的关系越密切，耦合越大，当一个类发生变化时，对另一个类的影响也越大。</p><p>迪米特原则还有一个英文解释是 Only talk to your immediate friends，翻译过来就是：<strong>只与直接的朋友通信。</strong>什么叫做直接的朋友？每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就成为了朋友关系，这种关系的类型有很多，如组合、聚合、依赖等。</p><p>下面我们就以租房为例来讲讲迪米特原则的应用。</p><hr><h3 id="举例：在北京租房"><a href="#举例：在北京租房" class="headerlink" title="举例：在北京租房"></a>举例：在北京租房</h3><hr><p>在北京租房绝大多数都是通过中介找房。我们设定的情况为：我只要求房间的面积和租金，其他的一概不管，中介将符合我们要求的房子提供给我就可以。下面我们看看这个示例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 房间</div><div class="line"> */</div><div class="line">public class Room &#123;</div><div class="line">    public float area;</div><div class="line">    public float price;</div><div class="line"></div><div class="line">    public Room(float area, float price) &#123;</div><div class="line">        this.area = area;</div><div class="line">        this.price = price;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;Room&#123;&quot; + &quot;area=&quot; + area + &quot;, price=&quot; + price + &apos;&#125;&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 中介</div><div class="line"> */</div><div class="line">public class Mediator &#123;</div><div class="line">    List&lt;Room&gt; mRooms = new ArrayList&lt;&gt;();</div><div class="line">    </div><div class="line">    public Mediator() &#123;</div><div class="line">        for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">            mRooms.add(new Room(14 + i, (14 + i) * 150));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public List&lt;Room&gt; getAllRooms() &#123;</div><div class="line">        return mRooms;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 租户</div><div class="line"> */</div><div class="line">public class Tenant &#123;</div><div class="line">    public void rentRoom(float roomArea, float roomPrice, Mediator mediator) &#123;</div><div class="line">        List&lt;Room&gt; rooms = mediator.getAllRooms();</div><div class="line">        for (Room room : rooms) &#123;</div><div class="line">            if (isSuitable(roomArea, roomPrice, room)) &#123;</div><div class="line">                System.out.println(&quot;租到房间啦！&quot; + room);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private boolean isSuitable(float roomArea, float roomPrice, Room room) &#123;</div><div class="line">        return room.area &gt;= roomArea &amp;&amp; room.price &lt;= roomPrice;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从上面的代码可以看到，Tenant 不仅依赖了 Mediator 类，还需要频繁地与 Room 类打交道。租户类的要求只是通过中介找到一间适合自己的房间罢了，如果把这些检测条件都放在 Tenant 类中，那么中介类的功能就被弱化，而且导致了 Tenant 与 Room 的耦合较高，因为 Tenant 必须知道许多关于 Room 的细节。当 Room 变化时 Tenant 也必须跟着变化。Tenant 又与 Mediator 耦合，这就出现了纠缠不清的关系。这个时候就需要我们分清谁才是我们真正的“朋友”，在我们所设定的情况下，显然是 Mediator。上述代码的结构下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ef06a9294f269c90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>既然是耦合太严重，那我们就只能解耦了。首先要明确的是，我们只和我们的朋友通信，这里就是指 Mediator 对象。必须将 Room 相关的操作从 Tenant 中移除，而这些操作案例应该属于 Mediator。我们进行如下重构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 中介</div><div class="line"> */</div><div class="line">public class Mediator &#123;</div><div class="line">    List&lt;Room&gt; mRooms = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    public Mediator() &#123;</div><div class="line">        for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">            mRooms.add(new Room(14 + i, (14 + i) * 150));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Room rentOut(float area, float price) &#123;</div><div class="line">        for (Room room : mRooms) &#123;</div><div class="line">            if (isSuitable(area, price, room)) &#123;</div><div class="line">                return room;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private boolean isSuitable(float roomArea, float roomPrice, Room room) &#123;</div><div class="line">        return room.area &gt;= roomArea &amp;&amp; room.price &lt;= roomPrice;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 租户</div><div class="line"> */</div><div class="line">public class Tenant &#123;</div><div class="line">    public void rentRoom(float roomArea, float roomPrice, Mediator mediator) &#123;</div><div class="line">        mediator.rentOut(roomArea, roomPrice);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>重构后的结构图如下所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7c0beb82a0d5073c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>只是将对于 Room 的判定操作移到了 Mediator 类中，这本应该是 Mediator 的职责，根据租户设定的条件查找符合要求的房子，并且将结果交给租户就可以了。租户并不需要知道太多关于 Room 的细节，比如与房东签合同，房东的房产证是不是真的，房内的设施坏了之后要找谁谁修等。当我们通过我们的“朋友”——中介租了房之后，所有的事情我们都通过与中介沟通就好了，房东、维修师傅等这些角色并不是我们直接的“朋友”。“只与直接的朋友通信”这简单的几个字就能够将我们从复杂的关系网中抽离出来，使程序耦合度更低、稳定性更好。</p><hr><h3 id="举例二：ImageCache"><a href="#举例二：ImageCache" class="headerlink" title="举例二：ImageCache"></a>举例二：ImageCache</h3><hr><p>前面博客中的图片加载器项目，ImageCache 就是用户的直接朋友，而 SD 卡缓存内部使用了 FileOutputStream，这个 FileOutputStream 就不属于用户的直接朋友了。因此，用户完全不知道它的存在，用户只需要与 ImageCache 对象打交的即可。将图片存到 SD 卡中的代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// SD 卡缓存 DiskCache 类</div><div class="line">public class DiskCache implements ImageCache &#123;</div><div class="line">    private static String CACHE_DIR =</div><div class="line">            Environment.getExternalStorageDirectory() + &quot;/&quot;;</div><div class="line"></div><div class="line">    public Bitmap get(String url) &#123;</div><div class="line">        return BitmapFactory.decodeFile(CACHE_DIR</div><div class="line">                + ImageUtil.urlToMd5(url));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void put(String url, Bitmap bitmap) &#123;</div><div class="line">        FileOutputStream fileOutputStream = null;</div><div class="line">        try &#123;</div><div class="line">            fileOutputStream = new FileOutputStream(CACHE_DIR</div><div class="line">                    + ImageUtil.urlToMd5(url));</div><div class="line">            bitmap.compress(Bitmap.CompressFormat.PNG, 100, fileOutputStream);</div><div class="line">        &#125; catch (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            CloseUtils.closeQuietly(fileOutputStream);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>现在领导要求使用 jake wharton 的 DiskLruCache 来替换 FileOutputStream。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public void put(String url, Bitmap bitmap) &#123;</div><div class="line">    DiskLruCache.Editor editor = null;</div><div class="line">    try &#123;</div><div class="line">        editor = mDiskLruCache.edit(url);</div><div class="line">        if (null != editor) &#123;</div><div class="line">            OutputStream outputStream = editor.newOutputStream(0);</div><div class="line">            if (writeBitmapToDisk(bitmap, outputStream)) &#123;</div><div class="line">                // 写入 Disk 缓存</div><div class="line">                editor.commit();</div><div class="line">            &#125; else &#123;</div><div class="line">                editor.abort();</div><div class="line">            &#125;</div><div class="line">            CloseUtils.closeQuietly(outputStream);</div><div class="line">        &#125;</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>SD 卡缓存的具体实现虽然被替换了，但用户根本不会感知到。因为用户根本不知道 FileOutputStream 和 DiskLruCache 的存在，他们没有与 FileOutputStream 或 DiskLruCache 进行通信，他们只认识直接“朋友”——ImageCache，ImageCache 将一切细节隐藏在直接“朋友”的外衣之下，使得系统具有更低的耦合性和更好的可扩展性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://xianxiaotao.github.io/2019/08/01/PATTERN/01.1%20ANDROID%20%E9%9D%A2%E
      
    
    </summary>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/categories/PATTERN/"/>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/tags/PATTERN/"/>
    
  </entry>
  
  <entry>
    <title>00.5 ANDROID 面向对象的六大原则——接口隔离原则</title>
    <link href="http://yoursite.com/2019/08/05/PATTERN/00.5%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2019/08/05/PATTERN/00.5 ANDROID 面向对象的六大原则——接口隔离原则/</id>
    <published>2019-08-04T17:00:00.000Z</published>
    <updated>2020-02-20T13:43:51.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><hr><p><a href="https://xianxiaotao.github.io/2019/08/01/PATTERN/01.1%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/" target="_blank" rel="external">第一篇：单一职责原则</a><br><a href="https://xianxiaotao.github.io/2019/08/02/PATTERN/01.2%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/" target="_blank" rel="external">第二篇：开闭原则</a><br><a href="https://xianxiaotao.github.io/2019/08/03/PATTERN/01.3%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/" target="_blank" rel="external">第三篇：里氏替换原则</a><br><a href="https://xianxiaotao.github.io/2019/08/04/PATTERN/01.4%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/" target="_blank" rel="external">第四篇：依赖倒置原则</a><br><a href="">第五篇：本文</a><br><a href="https://xianxiaotao.github.io/2019/08/06/PATTERN/01.6%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99/" target="_blank" rel="external">第六篇：迪米特原则</a></p><hr><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><hr><p>英文全称是 Interface Segregation Principles，ISP。其定义是：<strong>客户端不应该依赖它不需要的接口</strong>。另一种定义是：<strong>类间的依赖关系应该建立在最小的接口上</strong>。接口隔离原则将非常庞大、臃肿的接口拆分成更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。接口隔离原则的目的是系统解开耦合，从而容易重构、更改和重新部署。</p><p>说白了就是，让客户端依赖的接口尽可能地小。这样说可能还有点抽象，我们还是以一个示例来说明一下。在此之前我们来说一个场景，在 Java 6 及之前的 JDK 版本，有一个非常讨厌的问题，那就是在使用了 OutputStream 或者其他可关闭的对象之后，我们必须保证他们最终被关闭了，我们的 SD 卡缓存类中就有这样的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public void put(String url, Bitmap bitmap) &#123;</div><div class="line">    FileOutputStream fileOutputStream = null;</div><div class="line">    try &#123;</div><div class="line">        fileOutputStream = new FileOutputStream(CACHE_DIR</div><div class="line">                + ImageUtil.urlToMd5(url));</div><div class="line">        bitmap.compress(Bitmap.CompressFormat.PNG, 100, fileOutputStream);</div><div class="line">    &#125; catch (FileNotFoundException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; finally &#123;</div><div class="line">        if (fileOutputStream != null) &#123;</div><div class="line">            try &#123;</div><div class="line">                fileOutputStream.close();</div><div class="line">            &#125; catch (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们看到的这段代码可读性非常差，各种 try…catch 嵌套都是些简单的代码，但是会严重影响代码的可读性，并且多层次的大括号很容易将代码写到错误的层级中。</p><p>在 Java 中有一个 Closeable 接口，该接口标识了一个可关闭的对象，它只有一个 close 方法。如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0f0d41101412f87c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>我们要讲的 FileOutputStream 类就实现了这个接口。我们从上图可以看到，还有 100 多个类实现了 Closeable 这个接口。这意味着，在关闭这 100 多个类型的对象时，都需要写出像 put 方法中 finally 代码段那样的代码。这还了得，反正我是不能忍。既然都是实现了 Closeable 接口，那只要一个方法统一来关闭这些对象不就可以了么？于是写来来如下的工具类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line">import java.io.Closeable;</div><div class="line"></div><div class="line">public class CloseUtils &#123;</div><div class="line"></div><div class="line">    private CloseUtils() &#123;&#125;</div><div class="line"></div><div class="line">    public static void closeQuietly(Closeable closeable) &#123;</div><div class="line">        if (null != closeable) &#123;</div><div class="line">            try &#123;</div><div class="line">                closeable.close();</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们再看看把这段代码运用到上述的 put 方法中的效果如何。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void put(String url, Bitmap bitmap) &#123;</div><div class="line">    FileOutputStream fileOutputStream = null;</div><div class="line">    try &#123;</div><div class="line">        fileOutputStream = new FileOutputStream(CACHE_DIR</div><div class="line">                + ImageUtil.urlToMd5(url));</div><div class="line">        bitmap.compress(Bitmap.CompressFormat.PNG, 100, fileOutputStream);</div><div class="line">    &#125; catch (FileNotFoundException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; finally &#123;</div><div class="line">        CloseUtils.closeQuietly(fileOutputStream);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>代码简洁了很多！而且这个 closeQuietly 方法可以运用到各类可关闭的对象中，保证了代码的重用性。CloseUtils 的 closeQuietly 方法的基本原理就是依赖于 Closeable 抽象而不是具体实现，并且建立在最小化依赖原则的基础上，它只需要知道这个对象是可关闭的，其他的一概不关心，也就是这里的接口隔离原则。</p><p>试想一下，如果在只是需要关闭一个对象时，它却暴露了其他的接口函数，如 OutputStream 的 write 方法，这就使得更多的细节暴露在客户端代码面前，不仅没有很好地隐藏实现，还增加了接口的使用难度。而通过 Closeable 接口将可关闭的对象抽象起来，这样只需要客户端依赖于 Closeable 就可以对客户端隐藏其他的接口信息，客户端代码只需要知道这个对象可关闭（只可调用 close 方法）即可。</p><p>之前博客中设计的 ImageLoader 持有的 ImageCache 就是接口隔离原则的运用。ImageLoader 只需要知道该缓存对象有存、取缓存图片的接口即可，其他的一概不管，这就使得缓存功能的具体实现对 ImageLoader 隐藏。这就是用最小化接口隔离了实现类的细节，也促使我们将庞大的接口拆分到更细粒度的接口当中，这使得我们的系统具有更低的耦合性、更高的灵活性。</p><hr><h3 id="举例：拆分接口"><a href="#举例：拆分接口" class="headerlink" title="举例：拆分接口"></a>举例：拆分接口</h3><hr><p>依据接口隔离原则，将下图中臃肿的接口 I 拆分为独立的几个接口。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1cd2d3c76d59ad0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>类 A 依赖接口 I 中的方法1、方法2、方法3，类 PA 是对类 A 依赖的实现。类 B 依赖接口 I 中的方法1、方法4、方法5，类 PB 是对类 B 依赖的实现。对于类 PA 和类 PB 来说，虽然他们都存在着用不到的方法（也就是图中划红线的方法），但由于实现了接口 I，所以也必须要实现这些用不到的方法。用代码表示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">interface I &#123;</div><div class="line">    void method1();</div><div class="line">    void method2();</div><div class="line">    void method3();</div><div class="line">    void method4();</div><div class="line">    void method5();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class A &#123;</div><div class="line">    public void depend1(I i)&#123;</div><div class="line">        i.method1();</div><div class="line">    &#125;</div><div class="line">    public void depend2(I i)&#123;</div><div class="line">        i.method2();</div><div class="line">    &#125;</div><div class="line">    public void depend3(I i)&#123;</div><div class="line">        i.method3();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class B &#123;</div><div class="line">    public void depend1(I i)&#123;</div><div class="line">        i.method1();</div><div class="line">    &#125;</div><div class="line">    public void depend2(I i)&#123;</div><div class="line">        i.method4();</div><div class="line">    &#125;</div><div class="line">    public void depend3(I i)&#123;</div><div class="line">        i.method5();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class PA implements I &#123;</div><div class="line">    public void method1() &#123;</div><div class="line">        System.out.println(&quot;类 PA 实现接口 I 的方法1&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method2() &#123;</div><div class="line">        System.out.println(&quot;类 PA 实现接口 I 的方法2&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method3() &#123;</div><div class="line">        System.out.println(&quot;类 PA 实现接口 I 的方法3&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 对于类 PA 来说，method4 和 method5 不是必需的，但是由于接口 I 中有这两个方法</div><div class="line">    // 所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现</div><div class="line">    public void method4() &#123;&#125;</div><div class="line">    public void method5() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class PB implements I &#123;</div><div class="line">    public void method1() &#123;</div><div class="line">        System.out.println(&quot;类 PB 实现接口 I 的方法1&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 对于类 PB 来说，method2 和 method3 不是必需的，但是由于接口 I 中有这两个方法</div><div class="line">    // 所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现</div><div class="line">    public void method2() &#123;&#125;</div><div class="line">    public void method3() &#123;&#125;</div><div class="line"></div><div class="line">    public void method4() &#123;</div><div class="line">        System.out.println(&quot;类 PB 实现接口 I 的方法4&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method5() &#123;</div><div class="line">        System.out.println(&quot;类 PB 实现接口 I 的方法5&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        A a = new A();</div><div class="line">        a.depend1(new PA());</div><div class="line">        a.depend2(new PA());</div><div class="line">        a.depend3(new PA());</div><div class="line"></div><div class="line">        B b = new B();</div><div class="line">        b.depend1(new PB());</div><div class="line">        b.depend2(new PB());</div><div class="line">        b.depend3(new PB());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口 I 进行拆分。在这里我们将原有的接口 I 拆分为三个接口，拆分后的设计如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-83e0173046673597.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>代码更改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">interface I1 &#123;</div><div class="line">    void method1();</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface I2 &#123;</div><div class="line">    void method2();</div><div class="line">    void method3();</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface I3 &#123;</div><div class="line">    void method4();</div><div class="line">    void method5();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class A &#123;</div><div class="line">    public void depend1(I1 i)&#123;</div><div class="line">        i.method1();</div><div class="line">    &#125;</div><div class="line">    public void depend2(I2 i)&#123;</div><div class="line">        i.method2();</div><div class="line">    &#125;</div><div class="line">    public void depend3(I2 i)&#123;</div><div class="line">        i.method3();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class B &#123;</div><div class="line">    public void depend1(I1 i)&#123;</div><div class="line">        i.method1();</div><div class="line">    &#125;</div><div class="line">    public void depend2(I3 i)&#123;</div><div class="line">        i.method4();</div><div class="line">    &#125;</div><div class="line">    public void depend3(I3 i)&#123;</div><div class="line">        i.method5();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class PA implements I1, I2 &#123;</div><div class="line">    public void method1() &#123;</div><div class="line">        System.out.println(&quot;类 PA 实现接口 I1 的方法1&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method2() &#123;</div><div class="line">        System.out.println(&quot;类 PA 实现接口 I2 的方法2&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method3() &#123;</div><div class="line">        System.out.println(&quot;类 PA 实现接口 I2 的方法3&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class PB implements I1, I3 &#123;</div><div class="line">    public void method1() &#123;</div><div class="line">        System.out.println(&quot;类 PB 实现接口 I1 的方法1&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method4() &#123;</div><div class="line">        System.out.println(&quot;类 PB 实现接口 I2 的方法4&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method5() &#123;</div><div class="line">        System.out.println(&quot;类 PB 实现接口 I2 的方法5&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为 3 个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p><p>说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</p><p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p><ul><li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化，所以一定要适度。</li><li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><p>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://xianxiaotao.github.io/2019/08/01/PATTERN/01.1%20ANDROID%20%E9%9D%A2%E
      
    
    </summary>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/categories/PATTERN/"/>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/tags/PATTERN/"/>
    
  </entry>
  
  <entry>
    <title>00.4 ANDROID 面向对象的六大原则——依赖倒置原则</title>
    <link href="http://yoursite.com/2019/08/04/PATTERN/00.4%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2019/08/04/PATTERN/00.4 ANDROID 面向对象的六大原则——依赖倒置原则/</id>
    <published>2019-08-03T17:00:00.000Z</published>
    <updated>2020-02-20T13:43:41.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><hr><p><a href="https://xianxiaotao.github.io/2019/08/01/PATTERN/01.1%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/" target="_blank" rel="external">第一篇：单一职责原则</a><br><a href="https://xianxiaotao.github.io/2019/08/02/PATTERN/01.2%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/" target="_blank" rel="external">第二篇：开闭原则</a><br><a href="https://xianxiaotao.github.io/2019/08/03/PATTERN/01.3%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/" target="_blank" rel="external">第三篇：里氏替换原则</a><br><a href="">第四篇：本文</a><br><a href="https://xianxiaotao.github.io/2019/08/05/PATTERN/01.5%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/" target="_blank" rel="external">第五篇：接口隔离原则</a><br><a href="https://xianxiaotao.github.io/2019/08/06/PATTERN/01.6%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99/" target="_blank" rel="external">第六篇：迪米特原则</a></p><hr><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>英文全称是 Dependence Inversion Principle，缩写 DIP。它指代了一种特定的解耦形式，使得高层次的模块不依赖于低层次模块的实现细节，即依赖模块被颠倒了。它包含了以下几个含义：</p><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象；</li><li>抽象不应该依赖细节；</li><li>细节应该依赖抽象。</li></ul><p>在 Java 语言中，抽象就是指接口或抽象类，两者都是不能直接被实例化的；细节就是实现类，实现接口或继承抽象类而产生的类就是细节，可以被直接实例化 (new)。高层模块就是调用端，底层模块就是具体实现类。依赖倒置原则在 Java 语言中的表现就是：<strong>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。</strong>概括的说就是<strong>面向接口编程</strong>，或者说面向抽象编程，这里的抽象指的是接口或者抽象类。</p><p>如果类与类直接依赖于细节，那么它们直接就有直接的耦合，当具体实现变化时，意味着要同时修改依赖者的代码，这限制了系统的可扩展性。</p><p>在下面的代码中，ImageLoader 直接依赖于 MemoryCache，这个 MemoryCache 是一个具体实现，而不是一个抽象类或者接口。这导致了 ImageLoader 直接依赖了具体细节，当 MemoryCache 不能满足 ImageLoader 而需要被其他缓存实现替换时，此时就必须修改 ImageLoader 的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line">    // 内存缓存（直接依赖于细节）</div><div class="line">    MemoryCache mMemoryCache = new MemoryCache();</div><div class="line">    </div><div class="line">    // 加载图片到 ImageView 中</div><div class="line">    public void displayImage(String url, ImageView imageView) &#123;</div><div class="line">        Bitmap bitmap = mMemoryCache.get(url);</div><div class="line">        if (bitmap == null) &#123;</div><div class="line">            downloadImage(url, imageView);</div><div class="line">        &#125; else &#123;</div><div class="line">            imageView.setImageBitmap(bitmap);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void setImageCache(MemoryCache cache) &#123;</div><div class="line">        mMemoryCache = cache;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>随着产品的升级，用户发现 MemoryCache 已经不能满足需求，用户需要的 ImageLoader 可以将图片同时缓存到内存和 SD 卡中，或者可以让用户自定义实现缓存。修改原有代码也不符合开闭原则。</p><p>正确的做法是依照依赖倒置原则依赖抽象，而不依赖具体实现。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public interface ImageCache &#123;</div><div class="line">    Bitmap get(String url);</div><div class="line">    void put(String url, Bitmap bitmap);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ImageLoader &#123;</div><div class="line">    // 图片缓存类，依赖于抽象，并且有一个默认的实现</div><div class="line">    ImageCache mImageCache = new MemoryCache();</div><div class="line"></div><div class="line">    // 加载图片到 ImageView 中</div><div class="line">    public void displayImage(String url, ImageView imageView) &#123;</div><div class="line">        Bitmap bitmap = mMemoryCache.get(url);</div><div class="line">        if (bitmap == null) &#123;</div><div class="line">            downloadImage(url, imageView);</div><div class="line">        &#125; else &#123;</div><div class="line">            imageView.setImageBitmap(bitmap);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 注入缓存实现</div><div class="line">    public void setImageCache(ImageCache cache) &#123;</div><div class="line">        mImageCache = cache;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里，我们建立了 ImageCache 抽象，并且让 ImageLoader 依赖于抽象而不是具体细节。当需求发生变化时，我们只需要实现 ImageCache 类或者继承其他已有的 ImageCache 子类完成相应的缓存功能，然后将具体的实现注入到 ImageLoader 即可实现缓存功能的替换，这就保证了缓存系统的可扩展性，有了拥抱变化的能力，这就是依赖倒置原则。</p><hr><h3 id="举例：涛哥开奔驰"><a href="#举例：涛哥开奔驰" class="headerlink" title="举例：涛哥开奔驰"></a>举例：涛哥开奔驰</h3><hr><p>先不考虑依赖倒置原则，看一下如下的设计：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2b425fd147530af4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从上面的类图中可以看出，司机类和奔驰车类都属于细节，并没有实现或继承抽象，它们是对象级别的耦合。通过类图可以看出司机有一个 drive() 方法，用来开车，奔驰车有一个 run() 方法，用来表示车辆运行，并且奔驰车类依赖于司机类，用户模块表示高层模块，负责调用司机类和奔驰车类。</p><p>可用以下代码表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class Driver &#123;</div><div class="line">    // 司机的主要职责就是驾驶汽车</div><div class="line">    public void drive(Benz benz)&#123;</div><div class="line">        benz.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Benz &#123;</div><div class="line">    // 汽车肯定会跑</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(&quot;奔驰汽车开始运行...&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 高层模块</div><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Driver taoGe = new Driver();</div><div class="line">        Benz benz = new Benz();</div><div class="line">        // 司机开奔驰车</div><div class="line">        taoGe.drive(benz);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样的设计乍一看好像也没有问题，涛哥只管开着他的奔驰车就好。但是假如有一天他不想开奔驰了，想换一辆宝马车玩玩怎么办呢？我们当然可以新建一个宝马车类，也给它弄一个 run() 方法，但问题是，这辆车有是有了，但是涛哥却不能开啊，因为司机类里面并没有宝马车的依赖。要想解决问题，只能修改代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class BMW &#123;</div><div class="line">    public void run()&#123;</div><div class="line">        System.out.println(&quot;宝马汽车开始运行...&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面的设计没有使用依赖倒置原则，我们已经发现，模块与模块之间耦合度太高，生产力太低，只要需求一变就需要大面积重构，说明这样的设计是不合理。现在我们引入依赖倒置原则，重新设计的类图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-22580545a2617fb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可用以下代码表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">// 将司机模块抽象为一个接口</div><div class="line">public interface IDriver &#123;</div><div class="line">    void drive(ICar car);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Driver implements IDriver &#123;</div><div class="line">    public void drive(ICar car)&#123;</div><div class="line">        car.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 将汽车模块抽象为一个接口：可以是奔驰汽车，也可以是宝马汽车</div><div class="line">public interface ICar &#123;</div><div class="line">    void run();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Benz implements ICar &#123;</div><div class="line">    public void run()&#123;</div><div class="line">        System.out.println(&quot;奔驰汽车开始运行...&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class BMW implements ICar &#123;</div><div class="line">    public void run()&#123;</div><div class="line">        System.out.println(&quot;宝马汽车开始运行...&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 高层模块</div><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        IDriver taoGe = new Driver();</div><div class="line">        ICar benz = new Benz();</div><div class="line">        // 涛哥开奔驰</div><div class="line">        taoGe.drive(benz);</div><div class="line">        // 涛哥开宝马</div><div class="line">        taoGe.drive(new BMW());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如此设计，涛哥再也不怕有新车不能开的情况了。</p><hr><h3 id="依赖的三种方法"><a href="#依赖的三种方法" class="headerlink" title="依赖的三种方法"></a>依赖的三种方法</h3><hr><p><strong>接口声明依赖对象</strong>： 在接口的方法中声明依赖对象，就如上面的例子。<br><strong>构造函数传递依赖对象</strong>：在类中通过构造函数声明依赖对象，按照依赖注入的说法，这种方式叫做构造函数注入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public interface IDriver &#123;</div><div class="line">    void drive();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Driver implements IDriver&#123;</div><div class="line">    private ICar car;</div><div class="line"></div><div class="line">    // 构造函数注入</div><div class="line">    public Driver(ICar car)&#123;</div><div class="line">        this.car = car;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void drive(ICar car)&#123;</div><div class="line">        this.car.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>Setter 方法传递依赖对象</strong>：在抽象中设置 Setter 方法声明依赖对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public interface IDriver&#123;</div><div class="line">    // 注入依赖</div><div class="line">    void setCar(ICar car);</div><div class="line">    void drive();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Driver implements IDriver &#123;</div><div class="line">    private ICar car;</div><div class="line"></div><div class="line">    public void setCar(ICar car)&#123;</div><div class="line">        this.car = car;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void drive()&#123;</div><div class="line">        this.car.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><hr><h3 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h3><hr><p>依赖倒置原则的本质就是通过抽象（抽象类或接口）使各个类或模块实现彼此独立，不互相影响，实现模块间的松耦合。在项目中使用这个规则需要以下原则：</p><ul><li><strong>每个类尽量都要有接口或抽象类，或者抽象类和接口都有。</strong></li><li><strong>变量的表面类型尽量是接口或者抽象类。</strong></li><li><strong>任何类都不应该从具体类派生。</strong></li><li><strong>尽量不要重写基类已经写好的方法</strong>（里式替换原则）。<br>如果基类是一个抽象类，而这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会有一定的影响。</li><li><strong>结合里式替换原则来使用</strong>： 结合里式替换原则和依赖倒置原则我们可以得出一个通俗的规则，接口负责定义 public 属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化。</li></ul><blockquote><p>总结：<strong>依赖倒置原则的核心就是面向抽象（抽象类或者接口）编程</strong>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://xianxiaotao.github.io/2019/08/01/PATTERN/01.1%20ANDROID%20%E9%9D%A2%E
      
    
    </summary>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/categories/PATTERN/"/>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/tags/PATTERN/"/>
    
  </entry>
  
  <entry>
    <title>00.3 ANDROID 面向对象的六大原则——里氏替换原则</title>
    <link href="http://yoursite.com/2019/08/03/PATTERN/00.3%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2019/08/03/PATTERN/00.3 ANDROID 面向对象的六大原则——里氏替换原则/</id>
    <published>2019-08-02T17:00:00.000Z</published>
    <updated>2020-02-20T13:43:25.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><hr><p><a href="https://xianxiaotao.github.io/2019/08/01/PATTERN/01.1%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/" target="_blank" rel="external">第一篇：单一职责原则</a><br><a href="https://xianxiaotao.github.io/2019/08/02/PATTERN/01.2%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/" target="_blank" rel="external">第二篇：开闭原则</a><br><a href="">第三篇：本文</a><br><a href="https://xianxiaotao.github.io/2019/08/04/PATTERN/01.4%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/" target="_blank" rel="external">第四篇：依赖倒置原则</a><br><a href="https://xianxiaotao.github.io/2019/08/05/PATTERN/01.5%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/" target="_blank" rel="external">第五篇：接口隔离原则</a><br><a href="https://xianxiaotao.github.io/2019/08/06/PATTERN/01.6%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99/" target="_blank" rel="external">第六篇：迪米特原则</a></p><hr><p>前一篇博文中的图片加载器项目，MemoryCache、DiskCache、DoubleCache 都可以替换 ImageCache 的工作，并且能够保证行为的正确性。ImageCache 建立了获取缓存图片、保存缓存图片的接口规范，MemoryCache 等根据接口规范实现了相应的功能，用户只需要在使用时指定具体的缓存对象就可以动态地替换 ImageLoader 中的缓存策略。这就使得 ImageLoader 的缓存系统具有了无限的可能性，也就是保证了可扩展性。</p><p>想象一种情况，当 ImageLoader 中的 setImageCache(ImageCache cache) 中的 cache 对象不能被子类所替换，那么用户如何设置不同的缓存对象，以及用户如何定义自己的缓存实现，通过前文中的 useDiskCache 方法吗？显然不是的，里氏替换原则就为这类问题提供了指导原则，也就是建立抽象，通过抽象建立规范，具体的实现在运行时替换掉抽象，保证系统的扩展性、灵活性。</p><p>开闭原则和里氏替换原则往往是生死相依、不离不弃的，通过里氏替换来达到对扩展开放，对修改关闭的效果。然而，这两个原则都同时强调了一个 OOP 的重要特性——抽象。因此，在开发过程中运用抽象是走向代码优化的重要一步。</p><hr><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><hr><p>里氏替换原则（Liskov Substitution Principle，LSP）有两种定义：<br>● <strong>If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.</strong>（如果对每一个类型为 S 的对象 o1，都有类型为 T 的对象 o2，使得以 T 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 S 是类型 T 的子类型。）</p><p>● <strong>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.</strong>（所有引用基类的地方必须能透明地使用其子类的对象。）</p><hr><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><hr><p>里氏替换原则的核心原理是抽象，抽象又依赖于继承这个特性。继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。</p><p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。</p><p>问题描述：<strong>有一功能 P1，由类 A 完成。现需要将功能 P1 进行扩展，扩展后的功能为 P，其中 P 由原有功能 P1 与新功能 P2 组成。新功能 P 由类 A 的子类 B 来完成，则子类 B 在完成新功能 P2 的同时，有可能会导致原有功能 P1 发生故障。</strong></p><p>解决方案：<strong>当使用继承时，遵循里氏替换原则</strong>。类 B 继承类 A 时，除添加新的方法完成新增功能 P2 外，尽量不要重写父类 A 的方法，也尽量不要重载父类 A 的方法。</p><p>举例说明：我们需要完成一个两数相减的功能 P1，由类 A 来负责。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class A &#123;</div><div class="line">    public int func1(int a, int b) &#123;</div><div class="line">        return a - b;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        A a = new A();</div><div class="line">        System.out.println(&quot;100-50=&quot; + a.func1(100, 50));</div><div class="line">        System.out.println(&quot;100-80=&quot; + a.func1(100, 80));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>运行结果：<br>100-50=50<br>100-80=20</p></blockquote><p>后来，我们需要增加一个新的功能 P2：完成两数相加，然后再与100求和，由类 B 来负责。即类 B 需要完成两个功能：</p><ul><li>P1：两数相减。</li><li>P2：两数相加，然后再加100。</li></ul><p>由于类 A 已经实现了第一个功能，所以类 B 继承类 A 后，只需要再完成第二个功能就可以了，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class B extends A &#123;</div><div class="line">    public int func1(int a, int b) &#123;</div><div class="line">        return a + b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int func2(int a, int b) &#123;</div><div class="line">        return func1(a, b) + 100;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        B b = new B();</div><div class="line">        System.out.println(&quot;100-50=&quot; + b.func1(100, 50));</div><div class="line">        System.out.println(&quot;100-80=&quot; + b.func1(100, 80));</div><div class="line">        System.out.println(&quot;100+20+100=&quot; + b.func2(100, 20));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>运行结果：<br>100-50=150<br>100-80=180<br>100+20+100=220</p></blockquote><p>我们发现原本运行正常的相减功能发生了错误。原因就是类 B 在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类 B 重写后的方法，造成原本运行正常的功能出现了错误。</p><p>在本例中，引用基类 A 完成的功能，换成子类 B 之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：<strong>原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。</strong></p><p>里氏替换原则通俗的来讲就是：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能。</strong>它包含以下4层含义：</p><ul><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法；</li><li>子类中可以增加自己特有的方法；</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松；</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li></ul><hr><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><hr><p>ANDROID 中的 Window 与 View 的关系，可以写成一个简单的示例，其 UML 图如下所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ae70d1d61a1d7785.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>具体的代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">// 窗口类</div><div class="line">public class Window &#123;</div><div class="line">    public void show(View child) &#123;</div><div class="line">        child.draw();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 建立视图抽象，测量视图的宽高为公用代码，绘制实现交给具体的子类</div><div class="line">public abstract class view &#123;</div><div class="line">    public abstract void draw();</div><div class="line">    public void measure(int width, int height) &#123;</div><div class="line">        // 测量视图大小</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 文本控件类的具体实现</div><div class="line">public class TextView extends View &#123;</div><div class="line">    public void draw() &#123;</div><div class="line">        // 绘制文本</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ImageView 的具体实现</div><div class="line">public class ImageView extends View &#123;</div><div class="line">    public void draw() &#123;</div><div class="line">        // 绘制图片</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上述示例中，Window 依赖于 View，而 View 定义了一个视图抽象，measure 是各个子类共享的方法，子类通过覆写 View 的 draw 方法实现具有各自特色的功能。在这里，这个功能就是绘制自身的内容。任何继承自 View 的子类都可以传递给 show 函数，就是所说的里氏替换。通过里氏替换，就可以自定义各式各样、千变万化的 View，然后传递给 Window，Window 负责组织 View，并将 View 显示到屏幕上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://xianxiaotao.github.io/2019/08/01/PATTERN/01.1%20ANDROID%20%E9%9D%A2%E
      
    
    </summary>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/categories/PATTERN/"/>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/tags/PATTERN/"/>
    
  </entry>
  
</feed>
