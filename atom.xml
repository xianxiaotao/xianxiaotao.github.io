<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>先小涛</title>
  
  <subtitle>我至诚我道</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-05T00:49:35.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>先小涛</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>精通 Android 自定义 View 目录</title>
    <link href="http://yoursite.com/2200/01/01/Custom%20View/00%20Android%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E7%9B%AE%E5%BD%95/"/>
    <id>http://yoursite.com/2200/01/01/Custom View/00 Android 自定义控件 目录/</id>
    <published>2199-12-31T16:00:00.000Z</published>
    <updated>2019-11-05T00:49:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇从自定义控件的动画、绘图、视图三方面入手，分别讲解与自定义控件相关的各种知识，给大家系统的梳理相关知识。不仅适合 Android 初、中级水平从业者，也适合高水平从业者查漏补缺使用。</p><p>内容摘自启舰所著的书籍《Android 自定义控件开发入门与实践》。</p><h2 id="第1章-绘图基础"><a href="#第1章-绘图基础" class="headerlink" title="第1章  绘图基础"></a>第1章  绘图基础</h2><h3 id="1-1-基本图形绘制"><a href="#1-1-基本图形绘制" class="headerlink" title="1.1 基本图形绘制"></a><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/" target="_blank" rel="external">1.1 基本图形绘制</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/#jump1" target="_blank" rel="external">1.1.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/#jump2" target="_blank" rel="external">1.1.2 画笔的基本设置</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/#jump3" target="_blank" rel="external">1.1.3 Canvas使用基础</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/#jump4" target="_blank" rel="external">1.1.4 Rect与RectF</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/#jump5" target="_blank" rel="external">1.1.5 Color</a></p><h3 id="1-2-路径"><a href="#1-2-路径" class="headerlink" title="1.2 路径"></a><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/" target="_blank" rel="external">1.2 路径</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/#jump1" target="_blank" rel="external">1.2.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/#jump2" target="_blank" rel="external">1.2.2 直线路径</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/#jump3" target="_blank" rel="external">1.2.3 弧线路径</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/#jump4" target="_blank" rel="external">1.2.4 addXXX系列函数</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/#jump5" target="_blank" rel="external">1.2.5 填充模式</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/#jump6" target="_blank" rel="external">1.2.6 重置路径</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/#jump7" target="_blank" rel="external">1.2.7 示例:蜘蛛网状图</a></p><h3 id="1-3-文字"><a href="#1-3-文字" class="headerlink" title="1.3 文字"></a><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/" target="_blank" rel="external">1.3 文字</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/#jump1" target="_blank" rel="external">1.3.1 Paint设置</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/#jump2" target="_blank" rel="external">1.3.2 Canvas绘制文本</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/#jump3" target="_blank" rel="external">1.3.3 设置字体样式</a></p><h3 id="1-4-Region"><a href="#1-4-Region" class="headerlink" title="1.4 Region"></a><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Region/" target="_blank" rel="external">1.4 Region</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Region/#jump1" target="_blank" rel="external">1.4.1 构造Region</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Region/#jump2" target="_blank" rel="external">1.4.2 枚举区域——RegionIterator类</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Region/#jump3" target="_blank" rel="external">1.4.3 区域相交</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Region/#jump4" target="_blank" rel="external">1.4.4 其他函数</a></p><h3 id="1-5-Canvas-画布"><a href="#1-5-Canvas-画布" class="headerlink" title="1.5 Canvas(画布)"></a><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Canvas/" target="_blank" rel="external">1.5 Canvas(画布)</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Canvas/#jump1" target="_blank" rel="external">1.5.1 Canvas变换</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Canvas/#jump2" target="_blank" rel="external">1.5.2 画布的保存与恢复</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Canvas/#jump3" target="_blank" rel="external">1.5.3 示例一:圆形头像</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Canvas/#jump4" target="_blank" rel="external">1.5.4 示例二:裁剪动画</a></p><h3 id="1-6-控件的使用方法"><a href="#1-6-控件的使用方法" class="headerlink" title="1.6 控件的使用方法"></a><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/" target="_blank" rel="external">1.6 控件的使用方法</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#jump1" target="_blank" rel="external">1.6.1 控件概述</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#jump2" target="_blank" rel="external">1.6.2 通过XML引入控件</a><br><a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#jump3" target="_blank" rel="external">1.6.3 动态添加控件</a></p><h2 id="第2章-视图动画"><a href="#第2章-视图动画" class="headerlink" title="第2章 视图动画"></a>第2章 视图动画</h2><h3 id="2-1-视图动画标签"><a href="#2-1-视图动画标签" class="headerlink" title="2.1 视图动画标签"></a><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/" target="_blank" rel="external">2.1 视图动画标签</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/#jump1" target="_blank" rel="external">2.1.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/#jump2" target="_blank" rel="external">2.1.2 scale 标签</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/#jump3" target="_blank" rel="external">2.1.3 Animation 继承属性</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/#jump4" target="_blank" rel="external">2.1.4 alpha 标签</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/#jump5" target="_blank" rel="external">2.1.5 rotate 标签</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/#jump6" target="_blank" rel="external">2.1.6 translate 标签</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A0%87%E7%AD%BE/#jump7" target="_blank" rel="external">2.1.7 set 标签</a></p><h3 id="2-2-视图动画的代码实现"><a href="#2-2-视图动画的代码实现" class="headerlink" title="2.2 视图动画的代码实现"></a><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/" target="_blank" rel="external">2.2 视图动画的代码实现</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/#jump1" target="_blank" rel="external">2.2.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/#jump2" target="_blank" rel="external">2.2.2 ScaleAnimation</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/#jump3" target="_blank" rel="external">2.2.3 AlphaAnimation</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/#jump4" target="_blank" rel="external">2.2.4 RotateAnimation</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/#jump5" target="_blank" rel="external">2.2.5 TranslateAnimation</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/#jump6" target="_blank" rel="external">2.2.6 AnimationSet</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/#jump7" target="_blank" rel="external">2.2.7 Animation</a></p><h3 id="2-3-插值器初探"><a href="#2-3-插值器初探" class="headerlink" title="2.3 插值器初探"></a><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/" target="_blank" rel="external">2.3 插值器初探</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump1" target="_blank" rel="external">2.3.1 AccelerateDecelerateInterpolator</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump2" target="_blank" rel="external">2.3.2 AccelerateInterpolator</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump3" target="_blank" rel="external">2.3.3 DecelerateInterpolator</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump4" target="_blank" rel="external">2.3.4 LinearInterpolator</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump5" target="_blank" rel="external">2.3.5 BounceInterpolator</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump6" target="_blank" rel="external">2.3.6 AnticipateInterpolator</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump7" target="_blank" rel="external">2.3.7 OvershootInterpolator</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump8" target="_blank" rel="external">2.3.8 AnticipateOvershootInterpolator</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump9" target="_blank" rel="external">2.3.9 CycleInterpolator</a></p><h3 id="2-4-动画示例"><a href="#2-4-动画示例" class="headerlink" title="2.4 动画示例"></a><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E5%8A%A8%E7%94%BB%E7%A4%BA%E4%BE%8B/" target="_blank" rel="external">2.4 动画示例</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E5%8A%A8%E7%94%BB%E7%A4%BA%E4%BE%8B/#jump1" target="_blank" rel="external">2.4.1 镜头由远及近效果</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E5%8A%A8%E7%94%BB%E7%A4%BA%E4%BE%8B/#jump2" target="_blank" rel="external">2.4.2 加载框效果</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E5%8A%A8%E7%94%BB%E7%A4%BA%E4%BE%8B/#jump3" target="_blank" rel="external">2.4.3 扫描动画</a></p><h3 id="2-5-逐帧动画"><a href="#2-5-逐帧动画" class="headerlink" title="2.5 逐帧动画"></a><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E9%80%90%E5%B8%A7%E5%8A%A8%E7%94%BB/" target="_blank" rel="external">2.5 逐帧动画</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E9%80%90%E5%B8%A7%E5%8A%A8%E7%94%BB/#jump1" target="_blank" rel="external">2.5.1 XML 实现</a><br><a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E9%80%90%E5%B8%A7%E5%8A%A8%E7%94%BB/#jump2" target="_blank" rel="external">2.5.2 代码实现</a></p><h2 id="第3章-属性动画"><a href="#第3章-属性动画" class="headerlink" title="第3章 属性动画"></a>第3章 属性动画</h2><h3 id="3-1-ValueAnimator-的基本使用"><a href="#3-1-ValueAnimator-的基本使用" class="headerlink" title="3.1 ValueAnimator 的基本使用"></a><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ValueAnimator%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">3.1 ValueAnimator 的基本使用</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ValueAnimator%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#jump1" target="_blank" rel="external">3.1.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ValueAnimator%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#jump2" target="_blank" rel="external">3.1.2 ValueAnimator 的简单使用</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ValueAnimator%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#jump3" target="_blank" rel="external">3.1.3 常用函数</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ValueAnimator%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#jump4" target="_blank" rel="external">3.1.4 示例：弹跳加载中效果</a></p><h3 id="3-2-自定义插值器与-Evaluator"><a href="#3-2-自定义插值器与-Evaluator" class="headerlink" title="3.2 自定义插值器与 Evaluator"></a><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E5%80%BC%E5%99%A8%E4%B8%8E%20Evaluator/" target="_blank" rel="external">3.2 自定义插值器与 Evaluator</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E5%80%BC%E5%99%A8%E4%B8%8E%20Evaluator/#jump1" target="_blank" rel="external">3.2.1 自定义插值器</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E5%80%BC%E5%99%A8%E4%B8%8E%20Evaluator/#jump2" target="_blank" rel="external">3.2.2 Evaluator</a></p><h3 id="3-3-ValueAnimator-进阶——ofObject"><a href="#3-3-ValueAnimator-进阶——ofObject" class="headerlink" title="3.3 ValueAnimator 进阶——ofObject"></a><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ofObject/" target="_blank" rel="external">3.3 ValueAnimator 进阶——ofObject</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ofObject/#jump1" target="_blank" rel="external">3.3.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ofObject/#jump2" target="_blank" rel="external">3.3.2 示例：抛物动画</a></p><h3 id="3-4-ObjectAnimator"><a href="#3-4-ObjectAnimator" class="headerlink" title="3.4 ObjectAnimator"></a><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ObjectAnimator/" target="_blank" rel="external">3.4 ObjectAnimator</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ObjectAnimator/#jump1" target="_blank" rel="external">3.4.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ObjectAnimator/#jump2" target="_blank" rel="external">3.4.2 ObjectAnimator 动画原理</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ObjectAnimator/#jump3" target="_blank" rel="external">3.4.3 自定义 ObjectAnimator 属性</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ObjectAnimator/#jump4" target="_blank" rel="external">3.4.4 何时需要实现对应的 get 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ObjectAnimator/#jump5" target="_blank" rel="external">3.4.5 常用函数</a></p><h3 id="3-5-组合动画——AnimatorSet"><a href="#3-5-组合动画——AnimatorSet" class="headerlink" title="3.5 组合动画——AnimatorSet"></a><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94AnimatorSet/" target="_blank" rel="external">3.5 组合动画——AnimatorSet</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94AnimatorSet/#jump1" target="_blank" rel="external">3.5.1 playSequentially() 与 playTogether() 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94AnimatorSet/#jump2" target="_blank" rel="external">3.5.2 AnimatorSet.Builder</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94AnimatorSet/#jump3" target="_blank" rel="external">3.5.3 AnimatorSet 监听器</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94AnimatorSet/#jump4" target="_blank" rel="external">3.5.4 常用函数</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94AnimatorSet/#jump5" target="_blank" rel="external">3.5.5 示例：路径动画</a></p><h3 id="3-6-Animator-动画的-XML-实现"><a href="#3-6-Animator-动画的-XML-实现" class="headerlink" title="3.6 Animator 动画的 XML 实现"></a><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94Animator%20%E5%8A%A8%E7%94%BB%E7%9A%84%20XML%20%E5%AE%9E%E7%8E%B0/" target="_blank" rel="external">3.6 Animator 动画的 XML 实现</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94Animator%20%E5%8A%A8%E7%94%BB%E7%9A%84%20XML%20%E5%AE%9E%E7%8E%B0/#jump1" target="_blank" rel="external">3.6.1 animator 标签</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94Animator%20%E5%8A%A8%E7%94%BB%E7%9A%84%20XML%20%E5%AE%9E%E7%8E%B0/#jump2" target="_blank" rel="external">3.6.2 objectAnimator 标签</a><br><a href="https://xianxiaotao.github.io/2019/07/03/Custom%20View/03.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94Animator%20%E5%8A%A8%E7%94%BB%E7%9A%84%20XML%20%E5%AE%9E%E7%8E%B0/#jump3" target="_blank" rel="external">3.6.3 set 标签</a></p><h2 id="第4章-属性动画进阶"><a href="#第4章-属性动画进阶" class="headerlink" title="第4章 属性动画进阶"></a>第4章 属性动画进阶</h2><h3 id="4-1-PropertyValuesHolder-与-Keyframe"><a href="#4-1-PropertyValuesHolder-与-Keyframe" class="headerlink" title="4.1 PropertyValuesHolder 与 Keyframe"></a><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94PropertyValuesHolder%20%E4%B8%8E%20Keyframe/" target="_blank" rel="external">4.1 PropertyValuesHolder 与 Keyframe</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94PropertyValuesHolder%20%E4%B8%8E%20Keyframe/#jump1" target="_blank" rel="external">4.1.1 PropertyValuesHolder</a><br><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94PropertyValuesHolder%20%E4%B8%8E%20Keyframe/#jump2" target="_blank" rel="external">4.1.2 Keyframe</a><br><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94PropertyValuesHolder%20%E4%B8%8E%20Keyframe/#jump3" target="_blank" rel="external">4.1.3 PropertyValuesHolder 其他函数</a><br><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94PropertyValuesHolder%20%E4%B8%8E%20Keyframe/#jump4" target="_blank" rel="external">4.1.4 示例：电话响铃效果</a></p><h3 id="4-2-ViewPropertyAnimator"><a href="#4-2-ViewPropertyAnimator" class="headerlink" title="4.2 ViewPropertyAnimator"></a><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94ViewPropertyAnimator/" target="_blank" rel="external">4.2 ViewPropertyAnimator</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94ViewPropertyAnimator/#jump1" target="_blank" rel="external">4.2.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94ViewPropertyAnimator/#jump2" target="_blank" rel="external">4.2.2 常用函数</a></p><h3 id="4-3-为-ViewGroup-内的组件添加动画"><a href="#4-3-为-ViewGroup-内的组件添加动画" class="headerlink" title="4.3 为 ViewGroup 内的组件添加动画"></a><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E4%B8%BA%20ViewGroup%20%E5%86%85%E7%9A%84%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB/" target="_blank" rel="external">4.3 为 ViewGroup 内的组件添加动画</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E4%B8%BA%20ViewGroup%20%E5%86%85%E7%9A%84%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB/#jump1" target="_blank" rel="external">4.3.1 animateLayoutChanges 属性</a><br><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E4%B8%BA%20ViewGroup%20%E5%86%85%E7%9A%84%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB/#jump2" target="_blank" rel="external">4.3.2 LayoutTransition</a><br><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E4%B8%BA%20ViewGroup%20%E5%86%85%E7%9A%84%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB/#jump3" target="_blank" rel="external">4.3.3 其他函数</a></p><h3 id="4-4-开源动画库-NineOldAndroids"><a href="#4-4-开源动画库-NineOldAndroids" class="headerlink" title="4.4 开源动画库 NineOldAndroids"></a><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94NineOldAndroids/" target="_blank" rel="external">4.4 开源动画库 NineOldAndroids</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94NineOldAndroids/#jump1" target="_blank" rel="external">4.4.1 NineOldAndroids 中的 ViewPropertyAnimator</a><br><a href="https://xianxiaotao.github.io/2019/07/04/Custom%20View/04.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94NineOldAndroids/#jump2" target="_blank" rel="external">4.4.2 NineOldAndroids 中的 ViewHelper</a></p><h2 id="第5章-动画进阶"><a href="#第5章-动画进阶" class="headerlink" title="第5章 动画进阶"></a>第5章 动画进阶</h2><h3 id="5-1-利用-PathMeasure-实现路径动画"><a href="#5-1-利用-PathMeasure-实现路径动画" class="headerlink" title="5.1 利用 PathMeasure 实现路径动画"></a><a href="https://xianxiaotao.github.io/2019/07/05/Custom%20View/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/" target="_blank" rel="external">5.1 利用 PathMeasure 实现路径动画</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/05/Custom%20View/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/#jump1" target="_blank" rel="external">5.1.1 初始化</a><br><a href="https://xianxiaotao.github.io/2019/07/05/Custom%20View/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/#jump2" target="_blank" rel="external">5.1.2 简单函数使用</a><br><a href="https://xianxiaotao.github.io/2019/07/05/Custom%20View/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/#jump3" target="_blank" rel="external">5.1.3 getSegment() 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/05/Custom%20View/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/#jump4" target="_blank" rel="external">5.1.4 getPosTan() 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/05/Custom%20View/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/#jump5" target="_blank" rel="external">5.1.5 getMatrix() 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/05/Custom%20View/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/#jump6" target="_blank" rel="external">5.1.6 示例：支付宝支付成功动画</a></p><h3 id="5-2-SVG-动画"><a href="#5-2-SVG-动画" class="headerlink" title="5.2 SVG 动画"></a><a href="https://xianxiaotao.github.io/2019/07/05/Custom%20View/05.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94SVG%20%E5%8A%A8%E7%94%BB/" target="_blank" rel="external">5.2 SVG 动画</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/05/Custom%20View/05.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94SVG%20%E5%8A%A8%E7%94%BB/#jump1" target="_blank" rel="external">5.2.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/05/Custom%20View/05.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94SVG%20%E5%8A%A8%E7%94%BB/#jump2" target="_blank" rel="external">5.2.2 vector 标签与图像显示</a><br><a href="https://xianxiaotao.github.io/2019/07/05/Custom%20View/05.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94SVG%20%E5%8A%A8%E7%94%BB/#jump3" target="_blank" rel="external">5.2.3 动态 Vector</a><br><a href="https://xianxiaotao.github.io/2019/07/05/Custom%20View/05.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94SVG%20%E5%8A%A8%E7%94%BB/#jump4" target="_blank" rel="external">5.2.4 示例：输入搜索动画</a></p><h2 id="第6章-Paint-基本使用"><a href="#第6章-Paint-基本使用" class="headerlink" title="第6章 Paint 基本使用"></a>第6章 Paint 基本使用</h2><h3 id="6-1-硬件加速"><a href="#6-1-硬件加速" class="headerlink" title="6.1 硬件加速"></a><a href="https://xianxiaotao.github.io/2019/07/06/Custom%20View/06.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/" target="_blank" rel="external">6.1 硬件加速</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/06/Custom%20View/06.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/#jump1" target="_blank" rel="external">6.1.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/06/Custom%20View/06.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/#jump2" target="_blank" rel="external">6.1.2 软件绘制与硬件加速的区别</a><br><a href="https://xianxiaotao.github.io/2019/07/06/Custom%20View/06.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/#jump3" target="_blank" rel="external">6.1.3 禁用 GPU 硬件加速的方法</a></p><h3 id="6-2-文字"><a href="#6-2-文字" class="headerlink" title="6.2 文字"></a><a href="https://xianxiaotao.github.io/2019/07/06/Custom%20View/06.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/" target="_blank" rel="external">6.2 文字</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/06/Custom%20View/06.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/#jump1" target="_blank" rel="external">6.2.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/06/Custom%20View/06.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/#jump2" target="_blank" rel="external">6.2.2 绘图四格线与 FontMetrics</a><br><a href="https://xianxiaotao.github.io/2019/07/06/Custom%20View/06.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/#jump3" target="_blank" rel="external">6.2.3 常用函数</a><br><a href="https://xianxiaotao.github.io/2019/07/06/Custom%20View/06.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/#jump4" target="_blank" rel="external">6.2.4 示例：定点写字</a></p><h3 id="6-3-Paint-常用函数"><a href="#6-3-Paint-常用函数" class="headerlink" title="6.3 Paint 常用函数"></a><a href="https://xianxiaotao.github.io/2019/07/06/Custom%20View/06.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" target="_blank" rel="external">6.3 Paint 常用函数</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/06/Custom%20View/06.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/#jump1" target="_blank" rel="external">6.3.1 基本设置函数</a><br><a href="https://xianxiaotao.github.io/2019/07/06/Custom%20View/06.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/#jump2" target="_blank" rel="external">6.3.2 字体相关函数</a></p><h2 id="第7章-绘图进阶"><a href="#第7章-绘图进阶" class="headerlink" title="第7章 绘图进阶"></a>第7章 绘图进阶</h2><h3 id="7-1-贝济埃曲线"><a href="#7-1-贝济埃曲线" class="headerlink" title="7.1 贝济埃曲线"></a><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E8%B4%9D%E6%B5%8E%E5%9F%83%E6%9B%B2%E7%BA%BF/" target="_blank" rel="external">7.1 贝济埃曲线</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E8%B4%9D%E6%B5%8E%E5%9F%83%E6%9B%B2%E7%BA%BF/#jump1" target="_blank" rel="external">7.1.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E8%B4%9D%E6%B5%8E%E5%9F%83%E6%9B%B2%E7%BA%BF/#jump2" target="_blank" rel="external">7.1.2 贝济埃曲线之 quadTo</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E8%B4%9D%E6%B5%8E%E5%9F%83%E6%9B%B2%E7%BA%BF/#jump3" target="_blank" rel="external">7.1.3 贝济埃曲线之 rQuadTo</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E8%B4%9D%E6%B5%8E%E5%9F%83%E6%9B%B2%E7%BA%BF/#jump4" target="_blank" rel="external">7.1.4 示例：波浪效果</a></p><h3 id="7-2-setShadowLayer-与阴影效果"><a href="#7-2-setShadowLayer-与阴影效果" class="headerlink" title="7.2 setShadowLayer 与阴影效果"></a><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94setShadowLayer%20%E4%B8%8E%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/" target="_blank" rel="external">7.2 setShadowLayer 与阴影效果</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94setShadowLayer%20%E4%B8%8E%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/#jump1" target="_blank" rel="external">7.2.1 构造函数</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94setShadowLayer%20%E4%B8%8E%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/#jump2" target="_blank" rel="external">7.2.2 清除阴影</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94setShadowLayer%20%E4%B8%8E%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/#jump3" target="_blank" rel="external">7.2.3 示例：给文字添加阴影</a></p><h3 id="7-3-BlurMaskFilter-发光效果和图片阴影"><a href="#7-3-BlurMaskFilter-发光效果和图片阴影" class="headerlink" title="7.3 BlurMaskFilter 发光效果和图片阴影"></a><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94BlurMaskFilter%20%E5%8F%91%E5%85%89%E6%95%88%E6%9E%9C%E4%B8%8E%E5%9B%BE%E7%89%87%E9%98%B4%E5%BD%B1/" target="_blank" rel="external">7.3 BlurMaskFilter 发光效果和图片阴影</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94BlurMaskFilter%20%E5%8F%91%E5%85%89%E6%95%88%E6%9E%9C%E4%B8%8E%E5%9B%BE%E7%89%87%E9%98%B4%E5%BD%B1/#jump1" target="_blank" rel="external">7.3.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94BlurMaskFilter%20%E5%8F%91%E5%85%89%E6%95%88%E6%9E%9C%E4%B8%8E%E5%9B%BE%E7%89%87%E9%98%B4%E5%BD%B1/#jump2" target="_blank" rel="external">7.3.2 给图片添加纯色阴影</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94BlurMaskFilter%20%E5%8F%91%E5%85%89%E6%95%88%E6%9E%9C%E4%B8%8E%E5%9B%BE%E7%89%87%E9%98%B4%E5%BD%B1/#jump3" target="_blank" rel="external">7.3.3 封装控件</a></p><h3 id="7-4-Shader-与-BitmapShader"><a href="#7-4-Shader-与-BitmapShader" class="headerlink" title="7.4 Shader 与 BitmapShader"></a><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B8%8E%20BitmapShader/" target="_blank" rel="external">7.4 Shader 与 BitmapShader</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B8%8E%20BitmapShader/#jump1" target="_blank" rel="external">7.4.1 Shader 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B8%8E%20BitmapShader/#jump2" target="_blank" rel="external">7.4.2 BitmapShader 的基本用法</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B8%8E%20BitmapShader/#jump3" target="_blank" rel="external">7.4.3 示例一：望远镜效果</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B8%8E%20BitmapShader/#jump4" target="_blank" rel="external">7.4.4 示例二：生成不规则头像</a></p><h3 id="7-5-Shader-之-LinearGradient"><a href="#7-5-Shader-之-LinearGradient" class="headerlink" title="7.5 Shader 之 LinearGradient"></a><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20LinearGradient/" target="_blank" rel="external">7.5 Shader 之 LinearGradient</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20LinearGradient/#jump1" target="_blank" rel="external">7.5.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20LinearGradient/#jump2" target="_blank" rel="external">7.5.2 示例：闪光文字效果</a></p><h3 id="7-6-Shader-之-RadialGradient"><a href="#7-6-Shader-之-RadialGradient" class="headerlink" title="7.6 Shader 之 RadialGradient"></a><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20RadialGradient/" target="_blank" rel="external">7.6 Shader 之 RadialGradient</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20RadialGradient/#jump1" target="_blank" rel="external">7.6.1 双色渐变</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20RadialGradient/#jump2" target="_blank" rel="external">7.6.2 多色渐变</a><br><a href="https://xianxiaotao.github.io/2019/07/07/Custom%20View/07.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20RadialGradient/#jump3" target="_blank" rel="external">7.6.3 TileMode 填充模式</a></p><h2 id="第8章-混合模式"><a href="#第8章-混合模式" class="headerlink" title="第8章 混合模式"></a>第8章 混合模式</h2><h3 id="8-1-混合模式之-AvoidXfermode"><a href="#8-1-混合模式之-AvoidXfermode" class="headerlink" title="8.1 混合模式之 AvoidXfermode"></a><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AvoidXfermode/" target="_blank" rel="external">8.1 混合模式之 AvoidXfermode</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AvoidXfermode/#jump1" target="_blank" rel="external">8.1.1 混合模式概述</a><br><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AvoidXfermode/#jump2" target="_blank" rel="external">8.1.2 AvoidXfermode</a><br><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AvoidXfermode/#jump3" target="_blank" rel="external">8.1.3 AvoidXfermode 绘制原理</a><br><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AvoidXfermode/#jump4" target="_blank" rel="external">8.1.4 AvoidXfermode 之 Mode.AVOID</a></p><h3 id="8-2-混合模式之-PorterDuffXfermode"><a href="#8-2-混合模式之-PorterDuffXfermode" class="headerlink" title="8.2 混合模式之 PorterDuffXfermode"></a><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode/" target="_blank" rel="external">8.2 混合模式之 PorterDuffXfermode</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode/#jump1" target="_blank" rel="external">8.2.1 PorterDuffXfermode 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode/#jump2" target="_blank" rel="external">8.2.2 颜色叠加相关模式</a></p><h3 id="8-3-PorterDuffXfermode-之源图像模式"><a href="#8-3-PorterDuffXfermode-之源图像模式" class="headerlink" title="8.3 PorterDuffXfermode 之源图像模式"></a><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode%20%E4%B9%8B%E6%BA%90%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">8.3 PorterDuffXfermode 之源图像模式</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode%20%E4%B9%8B%E6%BA%90%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F/#jump1" target="_blank" rel="external">8.3.1 Mode.SRC</a><br><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode%20%E4%B9%8B%E6%BA%90%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F/#jump2" target="_blank" rel="external">8.3.2 Mode.SRC_IN</a><br><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode%20%E4%B9%8B%E6%BA%90%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F/#jump3" target="_blank" rel="external">8.3.3 Mode.SRC_OUT</a><br><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode%20%E4%B9%8B%E6%BA%90%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F/#jump4" target="_blank" rel="external">8.3.4 Mode.SRC_OVER</a><br><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94PorterDuffXfermode%20%E4%B9%8B%E6%BA%90%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F/#jump5" target="_blank" rel="external">8.3.5 Mode.SRC_ATOP</a></p><h3 id="8-4-目标图像模式与其他模式"><a href="#8-4-目标图像模式与其他模式" class="headerlink" title="8.4 目标图像模式与其他模式"></a><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%9B%AE%E6%A0%87%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">8.4 目标图像模式与其他模式</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%9B%AE%E6%A0%87%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F/#jump1" target="_blank" rel="external">8.4.1 目标图像模式</a><br><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%9B%AE%E6%A0%87%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F/#jump2" target="_blank" rel="external">8.4.2 其他模式——Mode.CLEAR</a><br><a href="https://xianxiaotao.github.io/2019/07/08/Custom%20View/08.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%9B%AE%E6%A0%87%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F/#jump3" target="_blank" rel="external">8.4.3 模式总结</a></p><h2 id="第9章-Canvas-与图层"><a href="#第9章-Canvas-与图层" class="headerlink" title="第9章 Canvas 与图层"></a>第9章 Canvas 与图层</h2><h3 id="9-1-获取-Canvas-对象的方法"><a href="#9-1-获取-Canvas-对象的方法" class="headerlink" title="9.1 获取 Canvas 对象的方法"></a><a href="https://xianxiaotao.github.io/2019/07/09/Custom%20View/09.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96%20Canvas%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/" target="_blank" rel="external">9.1 获取 Canvas 对象的方法</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/09/Custom%20View/09.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96%20Canvas%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/#jump1" target="_blank" rel="external">9.1.1 方法一：重写 onDraw()、dispatchDraw() 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/09/Custom%20View/09.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96%20Canvas%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/#jump2" target="_blank" rel="external">9.1.2 方法二：使用 Bitmap 创建</a><br><a href="https://xianxiaotao.github.io/2019/07/09/Custom%20View/09.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96%20Canvas%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/#jump3" target="_blank" rel="external">9.1.3 方法三：调用 SurfaceHolder.lockCanvas() 函数</a></p><h3 id="9-2-图层与画布"><a href="#9-2-图层与画布" class="headerlink" title="9.2 图层与画布"></a><a href="https://xianxiaotao.github.io/2019/07/09/Custom%20View/09.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E5%9B%BE%E5%B1%82%E4%B8%8E%E7%94%BB%E5%B8%83/" target="_blank" rel="external">9.2 图层与画布</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/09/Custom%20View/09.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E5%9B%BE%E5%B1%82%E4%B8%8E%E7%94%BB%E5%B8%83/#jump1" target="_blank" rel="external">9.2.1 saveLayer() 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/09/Custom%20View/09.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E5%9B%BE%E5%B1%82%E4%B8%8E%E7%94%BB%E5%B8%83/#jump2" target="_blank" rel="external">9.2.2 画布与图层</a><br><a href="https://xianxiaotao.github.io/2019/07/09/Custom%20View/09.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E5%9B%BE%E5%B1%82%E4%B8%8E%E7%94%BB%E5%B8%83/#jump3" target="_blank" rel="external">9.2.3 saveLayer() &amp; saveLayerAlpha()</a></p><h3 id="9-3-Flag-的具体含义-已过时"><a href="#9-3-Flag-的具体含义-已过时" class="headerlink" title="9.3 Flag 的具体含义 已过时"></a><a href="https://xianxiaotao.github.io/2019/07/09/Custom%20View/09.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94Flag%20%E7%9A%84%E5%85%B7%E4%BD%93%E5%90%AB%E4%B9%89/" target="_blank" rel="external">9.3 Flag 的具体含义 已过时</a></h3><h3 id="9-4-恢复画布"><a href="#9-4-恢复画布" class="headerlink" title="9.4 恢复画布"></a><a href="https://xianxiaotao.github.io/2019/07/09/Custom%20View/09.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E6%81%A2%E5%A4%8D%E7%94%BB%E5%B8%83/" target="_blank" rel="external">9.4 恢复画布</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/09/Custom%20View/09.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E6%81%A2%E5%A4%8D%E7%94%BB%E5%B8%83/#jump1" target="_blank" rel="external">9.4.1 restoreToCount(int count)</a><br><a href="https://xianxiaotao.github.io/2019/07/09/Custom%20View/09.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Canvas%20%E4%B8%8E%E5%9B%BE%E5%B1%82%E2%80%94%E2%80%94%E6%81%A2%E5%A4%8D%E7%94%BB%E5%B8%83/#jump2" target="_blank" rel="external">9.4.2 restore() &amp; restoreToCount(int count) 的关系</a></p><h2 id="第10章-Android-画布"><a href="#第10章-Android-画布" class="headerlink" title="第10章 Android 画布"></a>第10章 Android 画布</h2><h3 id="10-1-ShapeDrawable"><a href="#10-1-ShapeDrawable" class="headerlink" title="10.1 ShapeDrawable"></a><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94ShapeDrawable/" target="_blank" rel="external">10.1 ShapeDrawable</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94ShapeDrawable/#jump1" target="_blank" rel="external">10.1.1 shape 标签与 GradientDrawable</a><br><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94ShapeDrawable/#jump2" target="_blank" rel="external">10.1.2 ShapDrawable 的构造函数</a><br><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94ShapeDrawable/#jump3" target="_blank" rel="external">10.1.3 常用函数</a><br><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94ShapeDrawable/#jump4" target="_blank" rel="external">10.1.4 自定义 Drawable</a><br><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94ShapeDrawable/#jump5" target="_blank" rel="external">10.1.5 Drawable 与 Bitmap 对比</a></p><h3 id="10-2-Bitmap"><a href="#10-2-Bitmap" class="headerlink" title="10.2 Bitmap"></a><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap/" target="_blank" rel="external">10.2 Bitmap</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap/#jump1" target="_blank" rel="external">10.2.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap/#jump2" target="_blank" rel="external">10.2.2 创建 Bitmap 方法一：BitmapFactory</a><br><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap/#jump3" target="_blank" rel="external">10.2.3 BitmapFactory.Options</a><br><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap/#jump4" target="_blank" rel="external">10.2.4 创建 Bitmap 方法二：Bitmap 静态方法</a><br><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap/#jump5" target="_blank" rel="external">10.2.5 常用函数</a><br><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94Bitmap/#jump6" target="_blank" rel="external">10.2.6 常见问题</a></p><h3 id="10-3-SurfaceView"><a href="#10-3-SurfaceView" class="headerlink" title="10.3 SurfaceView"></a><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94SurfaceView/" target="_blank" rel="external">10.3 SurfaceView</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94SurfaceView/#jump1" target="_blank" rel="external">10.3.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94SurfaceView/#jump2" target="_blank" rel="external">10.3.2 基本用法</a><br><a href="https://xianxiaotao.github.io/2019/07/10/Custom%20View/10.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94SurfaceView/#jump3" target="_blank" rel="external">10.3.3 双缓冲技术</a></p><h2 id="第11章-Matrix-与坐标变换"><a href="#第11章-Matrix-与坐标变换" class="headerlink" title="第11章 Matrix 与坐标变换"></a>第11章 Matrix 与坐标变换</h2><h3 id="11-1-矩阵运算"><a href="#11-1-矩阵运算" class="headerlink" title="11.1 矩阵运算"></a><a href="https://xianxiaotao.github.io/2019/07/11/Custom%20View/11.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/" target="_blank" rel="external">11.1 矩阵运算</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/11/Custom%20View/11.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/#jump1" target="_blank" rel="external">11.1.1 矩阵的加法与减法</a><br><a href="https://xianxiaotao.github.io/2019/07/11/Custom%20View/11.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/#jump2" target="_blank" rel="external">11.1.2 矩阵与数的乘法</a><br><a href="https://xianxiaotao.github.io/2019/07/11/Custom%20View/11.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/#jump3" target="_blank" rel="external">11.1.3 矩阵与矩阵的乘法</a></p><h3 id="11-2-ColorMatrix-色彩变换"><a href="#11-2-ColorMatrix-色彩变换" class="headerlink" title="11.2 ColorMatrix 色彩变换"></a><a href="https://xianxiaotao.github.io/2019/07/11/Custom%20View/11.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94ColorMatrix%20%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2/" target="_blank" rel="external">11.2 ColorMatrix 色彩变换</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/11/Custom%20View/11.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94ColorMatrix%20%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2/#jump1" target="_blank" rel="external">11.2.1 色彩变换矩阵</a><br><a href="https://xianxiaotao.github.io/2019/07/11/Custom%20View/11.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94ColorMatrix%20%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2/#jump2" target="_blank" rel="external">11.2.2 色彩的几种运算方式</a><br><a href="https://xianxiaotao.github.io/2019/07/11/Custom%20View/11.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94ColorMatrix%20%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2/#jump3" target="_blank" rel="external">11.2.3 ColorMatrix 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/11/Custom%20View/11.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94ColorMatrix%20%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2/#jump4" target="_blank" rel="external">11.2.4 ColorMatrix 相乘</a></p><h2 id="第12章-封装控件"><a href="#第12章-封装控件" class="headerlink" title="第12章 封装控件"></a>第12章 封装控件</h2><h3 id="12-1-自定义属性与自定义-Style"><a href="#12-1-自定义属性与自定义-Style" class="headerlink" title="12.1 自定义属性与自定义 Style"></a><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%20Style/" target="_blank" rel="external">12.1 自定义属性与自定义 Style</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%20Style/#jump1" target="_blank" rel="external">12.1.1 示例</a><br><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%20Style/#jump2" target="_blank" rel="external">12.1.2 在 XML 中使用自定义的属性</a><br><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%20Style/#jump3" target="_blank" rel="external">12.1.3 在代码中获取自定义属性的值</a><br><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%20Style/#jump4" target="_blank" rel="external">12.1.4 declare-styleable 标签其他属性的用法</a></p><h3 id="12-2-测量与布局"><a href="#12-2-测量与布局" class="headerlink" title="12.2 测量与布局"></a><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E6%B5%8B%E9%87%8F%E5%92%8C%E5%B8%83%E5%B1%80/" target="_blank" rel="external">12.2 测量与布局</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E6%B5%8B%E9%87%8F%E5%92%8C%E5%B8%83%E5%B1%80/#jump1" target="_blank" rel="external">12.2.1 ViewGroup 绘制流程</a><br><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E6%B5%8B%E9%87%8F%E5%92%8C%E5%B8%83%E5%B1%80/#jump2" target="_blank" rel="external">12.2.2 onMeasure() 函数与 MeasureSpec</a><br><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E6%B5%8B%E9%87%8F%E5%92%8C%E5%B8%83%E5%B1%80/#jump3" target="_blank" rel="external">12.2.3 onLayout() 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E6%B5%8B%E9%87%8F%E5%92%8C%E5%B8%83%E5%B1%80/#jump4" target="_blank" rel="external">12.2.4 获取子控件 margin 值的方法</a></p><h3 id="12-3-实现-FlowLayout-容器"><a href="#12-3-实现-FlowLayout-容器" class="headerlink" title="12.3 实现 FlowLayout 容器"></a><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%20FlowLayout%20%E5%AE%B9%E5%99%A8/" target="_blank" rel="external">12.3 实现 FlowLayout 容器</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%20FlowLayout%20%E5%AE%B9%E5%99%A8/#jump1" target="_blank" rel="external">12.3.1 XML 布局</a><br><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%20FlowLayout%20%E5%AE%B9%E5%99%A8/#jump2" target="_blank" rel="external">12.3.2 提取 margin 值与重写 onMeasure() 函数</a><br><a href="https://xianxiaotao.github.io/2019/07/12/Custom%20View/12.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%20FlowLayout%20%E5%AE%B9%E5%99%A8/#jump3" target="_blank" rel="external">12.3.3 完整代码</a></p><h2 id="第13章-控件高级属性"><a href="#第13章-控件高级属性" class="headerlink" title="第13章 控件高级属性"></a>第13章 控件高级属性</h2><h3 id="13-1-GestureDetector-手势检测"><a href="#13-1-GestureDetector-手势检测" class="headerlink" title="13.1 GestureDetector 手势检测"></a><a href="https://xianxiaotao.github.io/2019/07/13/Custom%20View/13.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94GestureDetector%20%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B/" target="_blank" rel="external">13.1 GestureDetector 手势检测</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/13/Custom%20View/13.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94GestureDetector%20%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B/#jump1" target="_blank" rel="external">13.1.1 概述</a><br><a href="https://xianxiaotao.github.io/2019/07/13/Custom%20View/13.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94GestureDetector%20%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B/#jump2" target="_blank" rel="external">13.1.2 GestureDetector.OnGestureListener</a><br><a href="https://xianxiaotao.github.io/2019/07/13/Custom%20View/13.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94GestureDetector%20%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B/#jump3" target="_blank" rel="external">13.1.3 GestureDetector.OnDoubleTapListener</a><br><a href="https://xianxiaotao.github.io/2019/07/13/Custom%20View/13.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94GestureDetector%20%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B/#jump4" target="_blank" rel="external">13.1.4 GestureDetector.SimpleOnGestureListener</a><br><a href="https://xianxiaotao.github.io/2019/07/13/Custom%20View/13.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94GestureDetector%20%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B/#jump5" target="_blank" rel="external">13.1.5 onFling() 函数的应用</a></p><h3 id="13-2-Window-与-WindowManager"><a href="#13-2-Window-与-WindowManager" class="headerlink" title="13.2 Window 与 WindowManager"></a><a href="https://xianxiaotao.github.io/2019/07/13/Custom%20View/13.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94Window%20%E4%B8%8E%20WindowManager/" target="_blank" rel="external">13.2 Window 与 WindowManager</a></h3><p><a href="https://xianxiaotao.github.io/2019/07/13/Custom%20View/13.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94Window%20%E4%B8%8E%20WindowManager/#jump1" target="_blank" rel="external">13.2.1 Window 与 WindowManager 的关系</a><br><a href="https://xianxiaotao.github.io/2019/07/13/Custom%20View/13.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94Window%20%E4%B8%8E%20WindowManager/#jump2" target="_blank" rel="external">13.2.2 示例：腾讯手机管家悬浮窗的小火箭效果</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇从自定义控件的动画、绘图、视图三方面入手，分别讲解与自定义控件相关的各种知识，给大家系统的梳理相关知识。不仅适合 Android 初、中级水平从业者，也适合高水平从业者查漏补缺使用。&lt;/p&gt;
&lt;p&gt;内容摘自启舰所著的书籍《Android 自定义控件开发入门与实践》。&lt;/
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>X001 圆角圆形 ImageView</title>
    <link href="http://yoursite.com/2019/09/01/Custom%20View/X001%20%E5%9C%86%E8%A7%92%E5%9C%86%E5%BD%A2%20ImageView/"/>
    <id>http://yoursite.com/2019/09/01/Custom View/X001 圆角圆形 ImageView/</id>
    <published>2019-08-31T16:00:00.000Z</published>
    <updated>2020-01-24T05:02:47.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-99c14f4dff5bc857.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>鉴于 Android 提供的 ImageView 控件已经非常完善，不仅处理好了各种缩放问题，而且有着很好的兼容性，还实现了显示图片等一系列的任务，我们只要在它的基础上添加一个显示圆角圆形的功能即可。</p><h3 id="一、属性配置"><a href="#一、属性配置" class="headerlink" title="一、属性配置"></a>一、属性配置</h3><p>首先创建一个 res/values/attrs.xml 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">    &lt;declare-styleable name=&quot;RoundImageView&quot;&gt;</div><div class="line">        &lt;attr name=&quot;type&quot; format=&quot;enum&quot;&gt;</div><div class="line">            &lt;enum name=&quot;circle&quot; value=&quot;1&quot;/&gt;</div><div class="line">            &lt;enum name=&quot;round&quot; value=&quot;2&quot;/&gt;</div><div class="line">        &lt;/attr&gt;</div><div class="line">        &lt;attr name=&quot;radius&quot; format=&quot;dimension&quot;/&gt;</div><div class="line">    &lt;/declare-styleable&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure></p><h3 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h3><h4 id="1-思路"><a href="#1-思路" class="headerlink" title="1. 思路"></a>1. 思路</h4><ul><li>定义一个 Java 类 RoundImageView，继承自 ImageView，重写其构造方法，获取配置属性进行初始化。</li><li>重写 onMeasure 方法，当模式为圆形的时候使其控件的宽高一致。</li><li>重写 onDraw 方法，增加两种模式处理逻辑。</li></ul><h4 id="2-完整代码"><a href="#2-完整代码" class="headerlink" title="2. 完整代码"></a>2. 完整代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.content.Context;</div><div class="line">import android.content.res.TypedArray;</div><div class="line">import android.graphics.Bitmap;</div><div class="line">import android.graphics.BitmapShader;</div><div class="line">import android.graphics.Canvas;</div><div class="line">import android.graphics.Matrix;</div><div class="line">import android.graphics.Paint;</div><div class="line">import android.graphics.RectF;</div><div class="line">import android.graphics.Shader;</div><div class="line">import android.graphics.drawable.Drawable;</div><div class="line">import android.os.Build;</div><div class="line">import android.util.AttributeSet;</div><div class="line">import android.util.TypedValue;</div><div class="line"></div><div class="line">import androidx.appcompat.widget.AppCompatImageView;</div><div class="line"></div><div class="line">public class RoundImageView extends AppCompatImageView &#123;</div><div class="line"></div><div class="line">    private static final int MODE_NONE = 0;         // 普通模式，默认</div><div class="line">    private static final int MODE_CIRCLE = 1;       // 圆形模式</div><div class="line">    private static final int MODE_ROUND = 2;        // 圆角矩形模式</div><div class="line"></div><div class="line">    private int currMode = MODE_NONE;</div><div class="line">    private int currRound = dp2px(10);              // 圆角半径</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private RectF mRectF = null;</div><div class="line">    private Drawable mPreDrawable = null;</div><div class="line"></div><div class="line">    public RoundImageView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        initViews();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public RoundImageView(Context context, AttributeSet attrs) &#123;</div><div class="line">        this(context, attrs, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public RoundImageView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">        obtainStyledAttrs(context, attrs, defStyleAttr);</div><div class="line">        initViews();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void obtainStyledAttrs(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.RoundImageView,</div><div class="line">                defStyleAttr, 0);</div><div class="line">        currMode = a.getInt(R.styleable.RoundImageView_type, MODE_NONE);</div><div class="line">        currRound = a.getDimensionPixelSize(R.styleable.RoundImageView_radius, currRound);</div><div class="line">        a.recycle();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initViews() &#123;</div><div class="line">        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);</div><div class="line">        mRectF = new RectF();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">        if (currMode == MODE_CIRCLE) &#123;</div><div class="line">            int result = Math.min(getMeasuredWidth(), getMeasuredHeight());</div><div class="line">            setMeasuredDimension(result, result);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        Drawable drawable = getDrawable();</div><div class="line">        Matrix drawMatrix = getImageMatrix();</div><div class="line">        if (drawable == null) &#123;</div><div class="line">            return; // couldn&apos;t resolve the URI</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (drawable.getIntrinsicWidth() == 0 || drawable.getIntrinsicHeight() == 0) &#123;</div><div class="line">            return; // nothing to draw (empty bounds)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (drawMatrix == null &amp;&amp; getPaddingTop() == 0 &amp;&amp; getPaddingLeft() == 0) &#123;</div><div class="line">            drawable.draw(canvas);</div><div class="line">        &#125; else &#123;</div><div class="line">            final int saveCount = canvas.getSaveCount();</div><div class="line">            canvas.save();</div><div class="line"></div><div class="line">            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123;</div><div class="line">                if (getCropToPadding()) &#123;</div><div class="line">                    final int scrollX = getScrollX();</div><div class="line">                    final int scrollY = getScrollY();</div><div class="line">                    canvas.clipRect(scrollX + getPaddingLeft(), scrollY + getPaddingTop(),</div><div class="line">                            scrollX + getRight() - getLeft() - getPaddingRight(),</div><div class="line">                            scrollY + getBottom() - getTop() - getPaddingBottom());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            canvas.translate(getPaddingLeft(), getPaddingTop());</div><div class="line">            // 当为圆形模式的时候</div><div class="line">            if (currMode == MODE_CIRCLE) &#123;</div><div class="line">                setBitmapShader(drawable);</div><div class="line">                canvas.drawCircle(getWidth() / 2f, getHeight() / 2f, getWidth() / 2f, mPaint);</div><div class="line">            &#125;</div><div class="line">            // 当为圆角模式的时候</div><div class="line">            else if (currMode == MODE_ROUND) &#123;</div><div class="line">                setBitmapShader(drawable);</div><div class="line">                mRectF.set(getPaddingLeft(), getPaddingTop(), getWidth() - getPaddingRight(), getHeight() - getPaddingBottom());</div><div class="line">                canvas.drawRoundRect(mRectF, currRound, currRound, mPaint);</div><div class="line">            &#125; else &#123;</div><div class="line">                if (drawMatrix != null) &#123;</div><div class="line">                    canvas.concat(drawMatrix);</div><div class="line">                &#125;</div><div class="line">                drawable.draw(canvas);</div><div class="line">            &#125;</div><div class="line">            canvas.restoreToCount(saveCount);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void setBitmapShader(Drawable drawable) &#123;</div><div class="line">        // 防止多次重 new 对象</div><div class="line">        if (drawable != null &amp;&amp; drawable != mPreDrawable) &#123;</div><div class="line">            Bitmap bitmap = drawable2Bitmap(drawable);</div><div class="line">            mPaint.setShader(new BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP));</div><div class="line">            mPreDrawable = drawable;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * drawable 转换成 bitmap</div><div class="line">     */</div><div class="line">    private Bitmap drawable2Bitmap(Drawable drawable) &#123;</div><div class="line">        if (drawable == null) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        Bitmap bitmap = Bitmap.createBitmap(getWidth(), getHeight(), Bitmap.Config.ARGB_8888);</div><div class="line">        Canvas canvas = new Canvas(bitmap);</div><div class="line">        // 根据传递的 scaleType 获取 matrix 对象，设置给 bitmap</div><div class="line">        Matrix matrix = getImageMatrix();</div><div class="line">        if (matrix != null) &#123;</div><div class="line">            canvas.concat(matrix);</div><div class="line">        &#125;</div><div class="line">        drawable.draw(canvas);</div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private int dp2px(float value) &#123;</div><div class="line">        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, value,</div><div class="line">                getResources().getDisplayMetrics());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 onDraw 方法中，以下代码是我们添加的逻辑，其余代码为 ImageView 源代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Drawable drawable = getDrawable();</div><div class="line">Matrix drawMatrix = getImageMatrix();</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">// 当为圆形模式的时候</div><div class="line">if (currMode == MODE_CIRCLE) &#123;</div><div class="line">    setBitmapShader(drawable);</div><div class="line">    canvas.drawCircle(getWidth() / 2f, getHeight() / 2f, getWidth() / 2f, mPaint);</div><div class="line">&#125;</div><div class="line">// 当为圆角模式的时候</div><div class="line">else if (currMode == MODE_ROUND) &#123;</div><div class="line">    setBitmapShader(drawable);</div><div class="line">    mRectF.set(getPaddingLeft(), getPaddingTop(), getWidth() - getPaddingRight(), getHeight() - getPaddingBottom());</div><div class="line">    canvas.drawRoundRect(mRectF, currRound, currRound, mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="3-在布局文件中使用"><a href="#3-在布局文件中使用" class="headerlink" title="3. 在布局文件中使用"></a>3. 在布局文件中使用</h4><p>效果如首图所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line"></div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;/&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot; /&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;</div><div class="line">            android:scaleType=&quot;centerCrop&quot; /&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line"></div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;</div><div class="line">            app:type=&quot;round&quot;/&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            app:type=&quot;round&quot;/&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;</div><div class="line">            android:scaleType=&quot;centerCrop&quot;</div><div class="line">            app:type=&quot;round&quot;/&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line"></div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;</div><div class="line">            app:type=&quot;circle&quot;/&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            app:type=&quot;circle&quot;/&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;100dp&quot;</div><div class="line">            android:layout_margin=&quot;20dp&quot;</div><div class="line">            android:src=&quot;@drawable/meinv&quot;</div><div class="line">            android:scaleType=&quot;centerCrop&quot;</div><div class="line">            app:type=&quot;circle&quot;/&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line"></div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;</div><div class="line">        android:layout_marginTop=&quot;10dp&quot;&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_margin=&quot;10dp&quot;</div><div class="line">            android:layout_width=&quot;50dp&quot;</div><div class="line">            android:layout_height=&quot;50dp&quot;</div><div class="line">            android:src=&quot;@color/colorAccent&quot; /&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_margin=&quot;10dp&quot;</div><div class="line">            android:layout_width=&quot;50dp&quot;</div><div class="line">            android:layout_height=&quot;50dp&quot;</div><div class="line">            android:src=&quot;@color/colorAccent&quot;</div><div class="line">            app:type=&quot;round&quot; /&gt;</div><div class="line">        &lt;com.xxt.xtest.RoundImageView</div><div class="line">            android:layout_margin=&quot;10dp&quot;</div><div class="line">            android:layout_width=&quot;50dp&quot;</div><div class="line">            android:layout_height=&quot;50dp&quot;</div><div class="line">            android:src=&quot;@color/colorAccent&quot;</div><div class="line">            app:type=&quot;circle&quot; /&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14186083-99c14f4dff5bc857.png?imag
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>01.3 ANDROID 面向对象的六大原则——里氏替换原则</title>
    <link href="http://yoursite.com/2019/08/03/PATTERN/01.3%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2019/08/03/PATTERN/01.3 ANDROID 面向对象的六大原则——里氏替换原则/</id>
    <published>2019-08-02T17:00:00.000Z</published>
    <updated>2020-02-18T13:26:48.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><hr><p><a href="https://xianxiaotao.github.io/2019/08/01/PATTERN/01.1%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/" target="_blank" rel="external">第一篇：单一职责原则</a><br><a href="https://xianxiaotao.github.io/2019/08/02/PATTERN/01.2%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/" target="_blank" rel="external">第二篇：开闭原则</a><br><a href="">第三篇：本文</a></p><hr><p>前一篇博文中的图片加载器项目，MemoryCache、DiskCache、DoubleCache 都可以替换 ImageCache 的工作，并且能够保证行为的正确性。ImageCache 建立了获取缓存图片、保存缓存图片的接口规范，MemoryCache 等根据接口规范实现了相应的功能，用户只需要在使用时指定具体的缓存对象就可以动态地替换 ImageLoader 中的缓存策略。这就使得 ImageLoader 的缓存系统具有了无限的可能性，也就是保证了可扩展性。</p><p>想象一种情况，当 ImageLoader 中的 setImageCache(ImageCache cache) 中的 cache 对象不能被子类所替换，那么用户如何设置不同的缓存对象，以及用户如何定义自己的缓存实现，通过前文中的 useDiskCache 方法吗？显然不是的，里氏替换原则就为这类问题提供了指导原则，也就是建立抽象，通过抽象建立规范，具体的实现在运行时替换掉抽象，保证系统的扩展性、灵活性。</p><p>开闭原则和里氏替换原则往往是生死相依、不离不弃的，通过里氏替换来达到对扩展开放，对修改关闭的效果。然而，这两个原则都同时强调了一个 OOP 的重要特性——抽象。因此，在开发过程中运用抽象是走向代码优化的重要一步。</p><hr><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><hr><p>里氏替换原则（Liskov Substitution Principle，LSP）有两种定义：<br>● <strong>If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.</strong>（如果对每一个类型为 S 的对象 o1，都有类型为 T 的对象 o2，使得以 T 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 S 是类型 T 的子类型。）</p><p>● <strong>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.</strong>（所有引用基类的地方必须能透明地使用其子类的对象。）</p><hr><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><hr><p>里氏替换原则的核心原理是抽象，抽象又依赖于继承这个特性。继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。</p><p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。</p><p>问题描述：<strong>有一功能 P1，由类 A 完成。现需要将功能 P1 进行扩展，扩展后的功能为 P，其中 P 由原有功能 P1 与新功能 P2 组成。新功能 P 由类 A 的子类 B 来完成，则子类 B 在完成新功能 P2 的同时，有可能会导致原有功能 P1 发生故障。</strong></p><p>解决方案：<strong>当使用继承时，遵循里氏替换原则</strong>。类 B 继承类 A 时，除添加新的方法完成新增功能 P2 外，尽量不要重写父类 A 的方法，也尽量不要重载父类 A 的方法。</p><p>举例说明：我们需要完成一个两数相减的功能 P1，由类 A 来负责。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class A &#123;</div><div class="line">    public int func1(int a, int b) &#123;</div><div class="line">        return a - b;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        A a = new A();</div><div class="line">        System.out.println(&quot;100-50=&quot; + a.func1(100, 50));</div><div class="line">        System.out.println(&quot;100-80=&quot; + a.func1(100, 80));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>运行结果：<br>100-50=50<br>100-80=20</p></blockquote><p>后来，我们需要增加一个新的功能 P2：完成两数相加，然后再与100求和，由类 B 来负责。即类 B 需要完成两个功能：</p><ul><li>P1：两数相减。</li><li>P2：两数相加，然后再加100。</li></ul><p>由于类 A 已经实现了第一个功能，所以类 B 继承类 A 后，只需要再完成第二个功能就可以了，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class B extends A &#123;</div><div class="line">    public int func1(int a, int b) &#123;</div><div class="line">        return a + b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int func2(int a, int b) &#123;</div><div class="line">        return func1(a, b) + 100;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        B b = new B();</div><div class="line">        System.out.println(&quot;100-50=&quot; + b.func1(100, 50));</div><div class="line">        System.out.println(&quot;100-80=&quot; + b.func1(100, 80));</div><div class="line">        System.out.println(&quot;100+20+100=&quot; + b.func2(100, 20));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>运行结果：<br>100-50=150<br>100-80=180<br>100+20+100=220</p></blockquote><p>我们发现原本运行正常的相减功能发生了错误。原因就是类 B 在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类 B 重写后的方法，造成原本运行正常的功能出现了错误。</p><p>在本例中，引用基类 A 完成的功能，换成子类 B 之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：<strong>原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。</strong></p><p>里氏替换原则通俗的来讲就是：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能。</strong>它包含以下4层含义：</p><ul><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法；</li><li>子类中可以增加自己特有的方法；</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松；</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li></ul><hr><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><hr><p>ANDROID 中的 Window 与 View 的关系，可以写成一个简单的示例，其 UML 图如下所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ae70d1d61a1d7785.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>具体的代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">// 窗口类</div><div class="line">public class Window &#123;</div><div class="line">    public void show(View child) &#123;</div><div class="line">        child.draw();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 建立视图抽象，测量视图的宽高为公用代码，绘制实现交给具体的子类</div><div class="line">public abstract class view &#123;</div><div class="line">    public abstract void draw();</div><div class="line">    public void measure(int width, int height) &#123;</div><div class="line">        // 测量视图大小</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 文本控件类的具体实现</div><div class="line">public class TextView extends View &#123;</div><div class="line">    public void draw() &#123;</div><div class="line">        // 绘制文本</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ImageView 的具体实现</div><div class="line">public class ImageView extends View &#123;</div><div class="line">    public void draw() &#123;</div><div class="line">        // 绘制图片</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上述示例中，Window 依赖于 View，而 View 定义了一个视图抽象，measure 是各个子类共享的方法，子类通过覆写 View 的 draw 方法实现具有各自特色的功能。在这里，这个功能就是绘制自身的内容。任何继承自 View 的子类都可以传递给 show 函数，就是所说的里氏替换。通过里氏替换，就可以自定义各式各样、千变万化的 View，然后传递给 Window，Window 负责组织 View，并将 View 显示到屏幕上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://xianxiaotao.github.io/2019/08/01/PATTERN/01.1%20ANDROID%20%E9%9D%A2%E
      
    
    </summary>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/categories/PATTERN/"/>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/tags/PATTERN/"/>
    
  </entry>
  
  <entry>
    <title>01.2 ANDROID 面向对象的六大原则——开闭原则</title>
    <link href="http://yoursite.com/2019/08/02/PATTERN/01.2%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2019/08/02/PATTERN/01.2 ANDROID 面向对象的六大原则——开闭原则/</id>
    <published>2019-08-01T17:00:00.000Z</published>
    <updated>2020-02-18T07:47:14.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><hr><p>请使用双缓存技术（内存、SD 卡）继续优化图片加载器？<br><a href="https://xianxiaotao.github.io/2019/08/01/PATTERN/01.1%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/" target="_blank" rel="external">图片加载器见第一篇：ANDROID 面向对象的六大原则——单一职责原则</a></p><hr><p>第一篇中已经实现了内存缓存类 ImageCache.java，我们还需要增加一个 SD 卡缓存类 DiskCache.java。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.graphics.Bitmap;</div><div class="line">import android.graphics.BitmapFactory;</div><div class="line">import android.os.Environment;</div><div class="line">import android.text.TextUtils;</div><div class="line"></div><div class="line">import java.io.FileNotFoundException;</div><div class="line">import java.io.FileOutputStream;</div><div class="line">import java.io.IOException;</div><div class="line">import java.io.UnsupportedEncodingException;</div><div class="line">import java.security.MessageDigest;</div><div class="line">import java.security.NoSuchAlgorithmException;</div><div class="line"></div><div class="line">public class DiskCache &#123;</div><div class="line"></div><div class="line">    // 图片缓存 SD 卡目录</div><div class="line">    private static String CACHE_DIR =</div><div class="line">            Environment.getExternalStorageDirectory() + &quot;/&quot;;</div><div class="line"></div><div class="line">    // 从 SD 卡缓存中获取图片</div><div class="line">    public Bitmap get(String url) &#123;</div><div class="line">        return BitmapFactory.decodeFile(CACHE_DIR + urlToMd5(url));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 将图片缓存到 SD 卡中</div><div class="line">    public void put(String url, Bitmap bitmap) &#123;</div><div class="line">        FileOutputStream fileOutputStream = null;</div><div class="line">        try &#123;</div><div class="line">            fileOutputStream = new FileOutputStream(CACHE_DIR + urlToMd5(url));</div><div class="line">            bitmap.compress(Bitmap.CompressFormat.PNG, 100, fileOutputStream);</div><div class="line">        &#125; catch (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (fileOutputStream != null) &#123;</div><div class="line">                try &#123;</div><div class="line">                    fileOutputStream.close();</div><div class="line">                &#125; catch (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private String urlToMd5(String url) &#123;</div><div class="line">        if (TextUtils.isEmpty(url)) &#123;</div><div class="line">            return &quot;&quot;;</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">            MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);</div><div class="line">            byte[] bytes = md5.digest(url.getBytes(&quot;UTF-8&quot;));</div><div class="line">            StringBuilder hex = new StringBuilder();</div><div class="line">            for (byte b : bytes) &#123;</div><div class="line">                hex.append(Integer.toHexString(b &amp; 0xff));</div><div class="line">            &#125;</div><div class="line">            hex.append(&quot;.png&quot;);</div><div class="line">            return hex.toString();</div><div class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</div><div class="line">            throw new RuntimeException(&quot;NoSuchAlgorithmException&quot;, e);</div><div class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</div><div class="line">            throw new RuntimeException(&quot;UnsupportedEncodingException&quot;, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后修改 ImageLoader.java 源码进行测试，可使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line"></div><div class="line">    // 图片缓存</div><div class="line">    // private ImageCache mImageCache = new ImageCache();</div><div class="line">    private DiskCache mImageCache = new DiskCache();</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>接下来要实现的是：<strong>首先使用内存缓存，如果内存缓存没有图片再使用 SD 卡缓存，如果 SD 卡中也没有图片，最后才从网络上获取。</strong></p><p>于是新建一个双缓存类 DoubleCache.java，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class DoubleCache &#123;</div><div class="line"></div><div class="line">    private ImageCache mMemoryCache = new ImageCache();</div><div class="line">    private DiskCache mDiskCache = new DiskCache();</div><div class="line"></div><div class="line">    public Bitmap get(String url) &#123;</div><div class="line">        Bitmap bitmap = mMemoryCache.get(url);</div><div class="line">        if (bitmap == null) &#123;</div><div class="line">            bitmap = mDiskCache.get(url);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void put(String url, Bitmap bitmap) &#123;</div><div class="line">        mMemoryCache.put(url, bitmap);</div><div class="line">        mDiskCache.put(url, bitmap);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>虽然双缓存技术很优秀，但是我们最好提供 API，让使用者可以灵活选择缓存方式：只选内存缓存、只选 SD 卡缓存或者选择双缓存方式。而不合格的程序员则会提供如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line"></div><div class="line">    // 图片缓存</div><div class="line">    private ImageCache mImageCache = new ImageCache();</div><div class="line">    // SD 卡缓存</div><div class="line">    private DiskCache mDiskCache = new DiskCache();</div><div class="line">    // 双缓存</div><div class="line">    private DoubleCache mDoubleCache = new DoubleCache();</div><div class="line">    // true: 单独使用 SD 卡缓存; false: 单独使用内存缓存</div><div class="line">    private boolean isUseDiskCache = false;</div><div class="line">    // true: 使用双缓存</div><div class="line">    private boolean isUseDoubleCache = false;</div><div class="line"></div><div class="line">    public void displayImage(final String url, final ImageView imageView) &#123;</div><div class="line">        Bitmap bmp = null;</div><div class="line">        if (isUseDoubleCache) &#123;</div><div class="line">            bmp = mDoubleCache.get(url);</div><div class="line">        &#125; else if (isUseDiskCache) &#123;</div><div class="line">            bmp = mDiskCache.get(url);</div><div class="line">        &#125; else &#123;</div><div class="line">            bmp = mImageCache.get(url);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    public void useDiskCache(boolean useDiskCache) &#123;</div><div class="line">        isUseDiskCache = useDiskCache;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void useDoubleCache(boolean useDoubleCache) &#123;</div><div class="line">        isUseDoubleCache = useDoubleCache;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上述代码中，要加入新的缓存实现时都需要修改 ImageLoader 类，然后通过一个布尔变量让用户选择使用哪种缓存。因此，就使得在 ImageLoader 中存在各种 if-else 判断语句，通过这些判断来确定使用哪种缓存。随着这些逻辑的引入，代码越来越复杂、脆弱。如果不小心写错了某个 if 条件，那就需要更多的时间来排除，整个 ImageLoader 类也会变得越来越臃肿。最重要的是，用户不能自己实现缓存注入到 ImageLoader 中，可扩展性差。</p><p><strong>软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是对于修改是封闭的，这就是开放——关闭原则。</strong></p><p>也就是说，当软件需要变化时，我们应该尽量通过扩展的方式实现变化，而不是通过修改已有的代码来实现。根据这一个原则，我们可以画出如下所示的 UML 图。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-27a4841b8ee201ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>按照上图进行以下重构：</p><p><strong>提取抽象接口</strong>，用来抽象图片缓存的功能。其声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface ImageCache &#123;</div><div class="line">    Bitmap get(String url);</div><div class="line">    void put(String url, Bitmap bitmap);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ImageCache 接口简单定义了获取、缓存图片两个函数，缓存的 key 是图片的 url，值是图片本身。内存缓存、SD 卡缓存、双缓存都实现了该接口，我们看看这几个缓存实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">// 内存缓存 MemoryCache 类</div><div class="line">public class MemoryCache implements ImageCache &#123;</div><div class="line">    private LruCache&lt;String, Bitmap&gt; mImageCache;</div><div class="line"></div><div class="line">    public MemoryCache() &#123;</div><div class="line">        initImageCache();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initImageCache() &#123;</div><div class="line">        int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);</div><div class="line">        final int cacheSize = maxMemory / 4;</div><div class="line">        mImageCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class="line">            @Override</div><div class="line">            protected int sizeOf(@NonNull String key, @NonNull Bitmap value) &#123;</div><div class="line">                return ImageUtil.getBitmapSize(value) / 1024;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void put(@NonNull String url, @NonNull Bitmap bitmap) &#123;</div><div class="line">        mImageCache.put(url, bitmap);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Bitmap get(@NonNull String url) &#123;</div><div class="line">        return mImageCache.get(url);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// SD 卡缓存 DiskCache 类</div><div class="line">public class DiskCache implements ImageCache &#123;</div><div class="line">    private static String CACHE_DIR =</div><div class="line">            Environment.getExternalStorageDirectory() + &quot;/&quot;;</div><div class="line"></div><div class="line">    public Bitmap get(String url) &#123;</div><div class="line">        return BitmapFactory.decodeFile(CACHE_DIR </div><div class="line">                + ImageUtil.urlToMd5(url));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void put(String url, Bitmap bitmap) &#123;</div><div class="line">        FileOutputStream fileOutputStream = null;</div><div class="line">        try &#123;</div><div class="line">            fileOutputStream = new FileOutputStream(CACHE_DIR </div><div class="line">                    + ImageUtil.urlToMd5(url));</div><div class="line">            bitmap.compress(Bitmap.CompressFormat.PNG, 100, fileOutputStream);</div><div class="line">        &#125; catch (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (fileOutputStream != null) &#123;</div><div class="line">                try &#123;</div><div class="line">                    fileOutputStream.close();</div><div class="line">                &#125; catch (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 双缓存 DoubleCache 类</div><div class="line">public class DoubleCache implements ImageCache &#123;</div><div class="line">    private MemoryCache mMemoryCache = new MemoryCache();</div><div class="line">    private DiskCache mDiskCache = new DiskCache();</div><div class="line"></div><div class="line">    public Bitmap get(String url) &#123;</div><div class="line">        Bitmap bitmap = mMemoryCache.get(url);</div><div class="line">        if (bitmap == null) &#123;</div><div class="line">            bitmap = mDiskCache.get(url);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void put(String url, Bitmap bitmap) &#123;</div><div class="line">        mMemoryCache.put(url, bitmap);</div><div class="line">        mDiskCache.put(url, bitmap);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后重构 ImageLoader，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line"></div><div class="line">    // 图片缓存，默认内存缓存</div><div class="line">    private ImageCache mImageCache = new MemoryCache();</div><div class="line"></div><div class="line">    // 线程池，线程数量为 CPU 的数量</div><div class="line">    private ExecutorService mExecutorService = Executors.newFixedThreadPool(</div><div class="line">            Runtime.getRuntime().availableProcessors());</div><div class="line"></div><div class="line">    // UI Handler</div><div class="line">    private Handler mUiHandler = new Handler(Looper.getMainLooper());</div><div class="line">    </div><div class="line">    // 注入缓存实现</div><div class="line">    public void setImageCache(ImageCache cache) &#123;</div><div class="line">        mImageCache = cache;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void displayImage(final String url, final ImageView imageView) &#123;</div><div class="line">        Bitmap bitmap = mImageCache.get(url);</div><div class="line">        if (bitmap != null) &#123;</div><div class="line">            imageView.setImageBitmap(bitmap);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 内存中没有，去加载</div><div class="line">        submitLoadRequest(url, imageView);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void submitLoadRequest(final String url, </div><div class="line">                                   final ImageView imageView) &#123;</div><div class="line">        imageView.setTag(url);</div><div class="line">        mExecutorService.submit(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                Bitmap bitmap = ImageUtil.downloadImage(url);</div><div class="line">                if (bitmap == null) return;</div><div class="line">                if (url.equals(imageView.getTag())) &#123;</div><div class="line">                    updateImageView(imageView, bitmap);</div><div class="line">                &#125;</div><div class="line">                mImageCache.put(url, bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 通知界面更新显示图片</div><div class="line">    private void updateImageView(final ImageView imageView,</div><div class="line">                                 final Bitmap bitmap) &#123;</div><div class="line">        mUiHandler.post(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                imageView.setImageBitmap(bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>附工具类 ImageUtil.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">public class ImageUtil &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 下载图片</div><div class="line">     * @param imageUrl 图片链接</div><div class="line">     * @return Bitmap</div><div class="line">     */</div><div class="line">    public static Bitmap downloadImage(String imageUrl) &#123;</div><div class="line">        if (TextUtils.isEmpty(imageUrl)) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        Bitmap bitmap = null;</div><div class="line">        try &#123;</div><div class="line">            URL url = new URL(imageUrl);</div><div class="line">            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 计算图片大小</div><div class="line">     * @param bitmap 图片</div><div class="line">     * @return int</div><div class="line">     */</div><div class="line">    public static int getBitmapSize(Bitmap bitmap) &#123;</div><div class="line">        if (bitmap == null) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</div><div class="line">            return bitmap.getAllocationByteCount();</div><div class="line">        &#125;</div><div class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB_MR1) &#123;</div><div class="line">            return bitmap.getByteCount();</div><div class="line">        &#125;</div><div class="line">        return bitmap.getRowBytes() * bitmap.getHeight();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 将图片 url 转换成字符串，用作文件名称</div><div class="line">     * @param url</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public static String urlToMd5(String url) &#123;</div><div class="line">        if (TextUtils.isEmpty(url)) &#123;</div><div class="line">            return &quot;&quot;;</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">            MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);</div><div class="line">            byte[] bytes = md5.digest(url.getBytes(&quot;UTF-8&quot;));</div><div class="line">            StringBuilder builder = new StringBuilder();</div><div class="line">            for (byte b : bytes) &#123;</div><div class="line">                builder.append(Integer.toHexString(b &amp; 0xff));</div><div class="line">            &#125;</div><div class="line">            builder.append(&quot;.png&quot;);</div><div class="line">            return builder.toString();</div><div class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</div><div class="line">            throw new RuntimeException(&quot;NoSuchAlgorithmException&quot;, e);</div><div class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</div><div class="line">            throw new RuntimeException(&quot;UnsupportedEncodingException&quot;, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>经过此次重构，没有了那么多的 if-else 语句，没有了各种各样的缓存实现对象、布尔变量，代码确实清晰简洁。用户可以通过setImageCache(ImageCache cache) 函数设置缓存实现，也就是通常说的依赖注入。具体如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">ImageLoader imageLoader = new ImageLoader();</div><div class="line">// 使用内存缓存</div><div class="line">imageLoader.setImageCache(new MemoryCache());</div><div class="line">// 使用 SD 卡缓存</div><div class="line">imageLoader.setImageCache(new DiskCache());</div><div class="line">// 使用双缓存</div><div class="line">imageLoader.setImageCache(new DoubleCache());</div><div class="line">// 使用自定义的图片缓存实现</div><div class="line">imageLoader.setImageCache(new ImageCache() &#123;</div><div class="line">    @Override</div><div class="line">    public Bitmap get(String url) &#123;</div><div class="line">        return null; // 从缓存中获取图片</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void put(String url, Bitmap bitmap) &#123;</div><div class="line">        // 缓存图片</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>在上述代码中，通过 setImageCache(ImageCache cache) 方法注入不同的缓存实现，这样不仅能够使 ImageLoader 更简单、健壮，也使得 ImageLoader 的可扩展性、灵活性更高。MemoryCache、DiskCache、DoubleCache 缓存图片的具体实现完全不一样，但是，它们的一个特点是，都实现了 ImageCache 接口。当用户需要自定义实现缓存策略时，只需要新建一个实现 ImageCache 接口的类，然后构造该类的对象，并且通过 setImageCache 函数注入到 ImageLoader 中，这样 ImageLoader 就实现了千变万化的缓存策略，且扩展这些缓存策略并不会导致 ImageLoader 类的修改。</p><p>开闭原则指导我们，当软件需要变化时，应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。但是通过继承等方式添加新的实现，这会导致类型的膨胀以及历史遗留代码的冗余。在开发过程中需要自己结合具体情况进行考量。</p><hr><h3 id="开闭原则概述"><a href="#开闭原则概述" class="headerlink" title="开闭原则概述"></a>开闭原则概述</h3><hr><p><strong>软件实体应当对扩展开放，对修改关闭 (Software entities should be open for extension, but closed for modification)。</strong></p><p><strong>开闭原则</strong>是面向对象设计中“可复用设计”的基石，是设计模式最基本的法则。其他五大设计原则和 23 种设计模式都可以看做是开闭原则的实现方法和手段。</p><p>说的通俗一点就是，已经开发好的软件实体（如类、模块、函数），在升级迭代引入新功能时，不应该修改已有的代码，而是在已有代码的基础上，添加新代码来实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;hr&gt;
&lt;p&gt;请使用双缓存技术（内存、SD 卡）继续优化图片加载器？&lt;br&gt;&lt;a href=&quot;https://xianxiaotao.github.io/2019/08/01/PATTE
      
    
    </summary>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/categories/PATTERN/"/>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/tags/PATTERN/"/>
    
  </entry>
  
  <entry>
    <title>01.1 ANDROID 面向对象的六大原则——单一职责原则</title>
    <link href="http://yoursite.com/2019/08/01/PATTERN/01.1%20ANDROID%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E2%80%94%E2%80%94%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2019/08/01/PATTERN/01.1 ANDROID 面向对象的六大原则——单一职责原则/</id>
    <published>2019-07-31T17:00:00.000Z</published>
    <updated>2020-02-18T05:15:31.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><hr><p>请实现一个简易的<strong>图片加载器</strong> (ImageLoader) ？</p><hr><p>以下是一个新手实现的图片加载器源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.graphics.Bitmap;</div><div class="line">import android.graphics.BitmapFactory;</div><div class="line">import android.os.Handler;</div><div class="line">import android.os.Looper;</div><div class="line">import android.text.TextUtils;</div><div class="line">import android.util.LruCache;</div><div class="line">import android.widget.ImageView;</div><div class="line"></div><div class="line">import java.net.HttpURLConnection;</div><div class="line">import java.net.URL;</div><div class="line">import java.util.concurrent.ExecutorService;</div><div class="line">import java.util.concurrent.Executors;</div><div class="line"></div><div class="line">public class ImageLoader &#123;</div><div class="line"></div><div class="line">    // 图片缓存</div><div class="line">    LruCache&lt;String, Bitmap&gt; mImageCache;</div><div class="line">    // 线程池，线程数量为 CPU 的数量</div><div class="line">    ExecutorService mExecutorService = Executors.newFixedThreadPool(</div><div class="line">            Runtime.getRuntime().availableProcessors());</div><div class="line">    // UI Handler</div><div class="line">    Handler mUiHandler = new Handler(Looper.getMainLooper());</div><div class="line"></div><div class="line">    public ImageLoader() &#123;</div><div class="line">        initImageCache();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 初始化内存缓存</div><div class="line">     */</div><div class="line">    private void initImageCache() &#123;</div><div class="line">        // 计算可用的最大内存</div><div class="line">        final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);</div><div class="line">        // 取四分之一的可用内存作为缓存</div><div class="line">        final int cacheSize = maxMemory / 4;</div><div class="line">        mImageCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class="line">            @Override</div><div class="line">            protected int sizeOf(String key, Bitmap bitmap) &#123;</div><div class="line">                return bitmap.getRowBytes() * bitmap.getHeight() / 1024;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 加载指定 url 的图片并显示</div><div class="line">     */</div><div class="line">    public void displayImage(final String url, final ImageView imageView) &#123;</div><div class="line">        // 先从内存中找</div><div class="line">        Bitmap bmp = mImageCache.get(url);</div><div class="line">        if (bmp != null) &#123;</div><div class="line">            imageView.setImageBitmap(bmp);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 内存中没有，去加载</div><div class="line">        imageView.setTag(url);</div><div class="line">        mExecutorService.submit(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                Bitmap bitmap = downloadImage(url);</div><div class="line">                if (bitmap == null) return;</div><div class="line">                if (url.equals(imageView.getTag())) &#123;</div><div class="line">                    updateImageView(imageView, bitmap);</div><div class="line">                &#125;</div><div class="line">                mImageCache.put(url, bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 通知界面更新显示图片</div><div class="line">     * @param imageView ImageView</div><div class="line">     * @param bitmap 位图</div><div class="line">     */</div><div class="line">    private void updateImageView(final ImageView imageView, </div><div class="line">                                 final Bitmap bitmap) &#123;</div><div class="line">        mUiHandler.post(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                imageView.setImageBitmap(bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 下载指定 url 的图片</div><div class="line">     * @param imageUrl 图片链接</div><div class="line">     * @return Bitmap</div><div class="line">     */</div><div class="line">    private Bitmap downloadImage(String imageUrl) &#123;</div><div class="line">        if (TextUtils.isEmpty(imageUrl)) return null;</div><div class="line"></div><div class="line">        Bitmap bitmap = null;</div><div class="line">        try &#123;</div><div class="line">            URL url = new URL(imageUrl);</div><div class="line">            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 动态申请权限</div><div class="line">requestRuntimePermission(new String[]&#123;&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&#125;, null);</div><div class="line">String url = &quot;https://upload-images.jianshu.io/upload_images/14186083-9bb468395ee3d048.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;;</div><div class="line">ImageView imageView = findViewById(R.id.image);</div><div class="line">new ImageLoader().displayImage(url, imageView);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-bc755e9afc10cbf3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片加载器"></p><blockquote><p>上述代码虽然满足功能需求，但是所有的功能代码都写在一个类中，这样随着功能的增多，ImageLoader 类会越来越大，代码也越来越负责，图片加载系统就越来越脆弱……</p></blockquote><p>我们可以参照<strong>单一职责原则</strong>，把 ImageLoader 拆分一下，让各个功能独立出来：</p><ul><li>ImageCache：用于处理图片缓存。</li><li>ImageUtil：图片工具类，如获取图片大小、下载图片等。</li></ul><p>改进后的源码：<br><strong>ImageLoader.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.graphics.Bitmap;</div><div class="line">import android.os.Handler;</div><div class="line">import android.os.Looper;</div><div class="line">import android.widget.ImageView;</div><div class="line"></div><div class="line">import java.util.concurrent.ExecutorService;</div><div class="line">import java.util.concurrent.Executors;</div><div class="line"></div><div class="line">public class ImageLoader &#123;</div><div class="line"></div><div class="line">    // 图片缓存</div><div class="line">    private ImageCache mImageCache = new ImageCache();</div><div class="line">    // 线程池，线程数量为 CPU 的数量</div><div class="line">    private ExecutorService mExecutorService = Executors.newFixedThreadPool(</div><div class="line">            Runtime.getRuntime().availableProcessors());</div><div class="line">    // UI Handler</div><div class="line">    private Handler mUiHandler = new Handler(Looper.getMainLooper());</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 加载指定 url 的图片并显示</div><div class="line">     */</div><div class="line">    public void displayImage(final String url, final ImageView imageView) &#123;</div><div class="line">        // 先从内存中找</div><div class="line">        Bitmap bmp = mImageCache.get(url);</div><div class="line">        if (bmp != null) &#123;</div><div class="line">            imageView.setImageBitmap(bmp);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 内存中没有，去加载</div><div class="line">        imageView.setTag(url);</div><div class="line">        mExecutorService.submit(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                Bitmap bitmap = ImageUtil.downloadImage(url);</div><div class="line">                if (bitmap == null) return;</div><div class="line">                if (url.equals(imageView.getTag())) &#123;</div><div class="line">                    updateImageView(imageView, bitmap);</div><div class="line">                &#125;</div><div class="line">                mImageCache.put(url, bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 通知界面更新显示图片</div><div class="line">     * @param imageView ImageView</div><div class="line">     * @param bitmap 位图</div><div class="line">     */</div><div class="line">    private void updateImageView(final ImageView imageView,</div><div class="line">                                 final Bitmap bitmap) &#123;</div><div class="line">        mUiHandler.post(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                imageView.setImageBitmap(bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>ImageCache.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.graphics.Bitmap;</div><div class="line"></div><div class="line">import androidx.annotation.NonNull;</div><div class="line">import androidx.collection.LruCache;</div><div class="line"></div><div class="line">public class ImageCache &#123;</div><div class="line"></div><div class="line">    // 图片缓存</div><div class="line">    private LruCache&lt;String, Bitmap&gt; mImageCache;</div><div class="line"></div><div class="line">    public ImageCache() &#123;</div><div class="line">        initImageCache();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initImageCache() &#123;</div><div class="line">        // 计算可使用的最大内存</div><div class="line">        int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);</div><div class="line">        // 取四分之一的可用内存作为缓存</div><div class="line">        final int cacheSize = maxMemory / 4;</div><div class="line">        mImageCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class="line">            @Override</div><div class="line">            protected int sizeOf(@NonNull String key, @NonNull Bitmap value) &#123;</div><div class="line">                return ImageUtil.getBitmapSize(value) / 1024;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void put(@NonNull String url, @NonNull Bitmap bitmap) &#123;</div><div class="line">        mImageCache.put(url, bitmap);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Bitmap get(@NonNull String url) &#123;</div><div class="line">        return mImageCache.get(url);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>ImageUtil.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.graphics.Bitmap;</div><div class="line">import android.graphics.BitmapFactory;</div><div class="line">import android.os.Build;</div><div class="line">import android.text.TextUtils;</div><div class="line"></div><div class="line">import java.net.HttpURLConnection;</div><div class="line">import java.net.URL;</div><div class="line"></div><div class="line">public class ImageUtil &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 下载图片</div><div class="line">     * @param imageUrl 图片链接</div><div class="line">     * @return Bitmap</div><div class="line">     */</div><div class="line">    public static Bitmap downloadImage(String imageUrl) &#123;</div><div class="line">        if (TextUtils.isEmpty(imageUrl)) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        Bitmap bitmap = null;</div><div class="line">        try &#123;</div><div class="line">            URL url = new URL(imageUrl);</div><div class="line">            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 计算图片大小</div><div class="line">     * @param bitmap 图片</div><div class="line">     * @return int</div><div class="line">     */</div><div class="line">    public static int getBitmapSize(Bitmap bitmap) &#123;</div><div class="line">        if (bitmap == null) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</div><div class="line">            return bitmap.getAllocationByteCount();</div><div class="line">        &#125;</div><div class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB_MR1) &#123;</div><div class="line">            return bitmap.getByteCount();</div><div class="line">        &#125;</div><div class="line">        return bitmap.getRowBytes() * bitmap.getHeight();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="单一职责原则概述"><a href="#单一职责原则概述" class="headerlink" title="单一职责原则概述"></a>单一职责原则概述</h3><hr><p><strong>应该有且仅有一个原因引起类的变更 (There should never be more than one reason for a class to change)。</strong></p><p>单一职责原则为我们提供了一个编写程序的准则，要求我们在编写类，抽象类，接口时，要使其功能职责单一纯碎，将导致其变更的因素缩减到最少。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起。一个职责的变化可能会影响或损坏其他职责的功能。而且职责越多，这个类变化的几率就会越大，类的稳定性就会越低。</p><p>在软件开发中，经常会遇到一个功能类 T 负责两个不同的职责：职责 P1，职责 P2。现因需求变更需要更改职责 P1 来满足新的业务需求，当我们实现完成后，发现因更改职责 P1 竟导致原本能够正常运行的职责 P2 发生故障。而修复职责 P2 又不得不更改职责 P1 的逻辑，这便是因为功能类 T 的职责不够单一，职责 P1 与职责 P2 耦合在一起导致的。</p><h3 id="附：动态权限申请代码"><a href="#附：动态权限申请代码" class="headerlink" title="附：动态权限申请代码"></a>附：动态权限申请代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.content.pm.PackageManager;</div><div class="line"></div><div class="line">import androidx.annotation.NonNull;</div><div class="line">import androidx.appcompat.app.AppCompatActivity;</div><div class="line">import androidx.core.app.ActivityCompat;</div><div class="line">import androidx.core.content.ContextCompat;</div><div class="line"></div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class BaseActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private PermissionListener mListener;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 权限申请</div><div class="line">     * @param permissions 待申请的权限集合</div><div class="line">     * @param listener  申请结果监听事件</div><div class="line">     */</div><div class="line">    protected void requestRuntimePermission(String[] permissions,</div><div class="line">                                            PermissionListener listener)&#123;</div><div class="line">        this.mListener = listener;</div><div class="line"></div><div class="line">        // 用于存放为授权的权限</div><div class="line">        List&lt;String&gt; permissionList = new ArrayList&lt;&gt;();</div><div class="line">        // 遍历传递过来的权限集合</div><div class="line">        for (String permission : permissions) &#123;</div><div class="line">            // 判断是否已经授权</div><div class="line">            if (ContextCompat.checkSelfPermission(this,permission)</div><div class="line">                    != PackageManager.PERMISSION_GRANTED)&#123;</div><div class="line">                // 未授权，则加入待授权的权限集合中</div><div class="line">                permissionList.add(permission);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 判断集合，如果集合不为空，则需要去授权</div><div class="line">        if (!permissionList.isEmpty()) &#123;</div><div class="line">            ActivityCompat.requestPermissions(this,</div><div class="line">                    permissionList.toArray(new String[permissionList.size()]),</div><div class="line">                    1);</div><div class="line">        &#125;</div><div class="line">        // 为空，则已经全部授权</div><div class="line">        else &#123;</div><div class="line">            if (listener != null) &#123;</div><div class="line">                listener.onGranted();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 权限申请结果</div><div class="line">     * @param requestCode  请求码</div><div class="line">     * @param permissions  所有的权限集合</div><div class="line">     * @param grantResults 授权结果集合</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void onRequestPermissionsResult(int requestCode,</div><div class="line">                                           @NonNull String[] permissions,</div><div class="line">                                           @NonNull int[] grantResults) &#123;</div><div class="line">        super.onRequestPermissionsResult(requestCode, permissions, </div><div class="line">                grantResults);</div><div class="line">        if (requestCode == 1 &amp;&amp; grantResults.length &gt; 0) &#123;</div><div class="line">            // 被用户拒绝的权限集合</div><div class="line">            List&lt;String&gt; deniedPermissions = new ArrayList&lt;&gt;();</div><div class="line">            // 用户通过的权限集合</div><div class="line">            List&lt;String&gt; grantedPermissions = new ArrayList&lt;&gt;();</div><div class="line">            for (int i = 0; i &lt; grantResults.length; i++) &#123;</div><div class="line">                // 获取授权结果，这是一个int类型的值</div><div class="line">                int grantResult = grantResults[i];</div><div class="line"></div><div class="line">                // 用户拒绝授权的权限</div><div class="line">                if (grantResult != PackageManager.PERMISSION_GRANTED)&#123;</div><div class="line">                    String permission = permissions[i];</div><div class="line">                    deniedPermissions.add(permission);</div><div class="line">                &#125;</div><div class="line">                // 用户同意的权限</div><div class="line">                else &#123;</div><div class="line">                    String permission = permissions[i];</div><div class="line">                    grantedPermissions.add(permission);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // 用户拒绝权限为空</div><div class="line">            if (deniedPermissions.isEmpty()) &#123;</div><div class="line">                if(mListener != null)&#123;</div><div class="line">                    mListener.onGranted();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            // 不为空</div><div class="line">            else &#123;</div><div class="line">                if(mListener != null)&#123;</div><div class="line">                    // 回调授权成功的接口</div><div class="line">                    mListener.onDenied(deniedPermissions);</div><div class="line">                    // 回调授权失败的接口</div><div class="line">                    mListener.onGranted(grantedPermissions);</div><div class="line">                    mListener.onDenied();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PermissionListener.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public interface PermissionListener &#123;</div><div class="line">    // 授权成功</div><div class="line">    void onGranted();</div><div class="line">    // 授权部分</div><div class="line">    void onGranted(List&lt;String&gt; grantedPermission);</div><div class="line">    // 拒绝授权</div><div class="line">    void onDenied(List&lt;String&gt; deniedPermission);</div><div class="line">    // 授权失败</div><div class="line">    void onDenied();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;hr&gt;
&lt;p&gt;请实现一个简易的&lt;strong&gt;图片加载器&lt;/strong&gt; (ImageLoader) ？&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;以下是一个新手实现的图片加载器源码：&lt;br&gt;&lt;figu
      
    
    </summary>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/categories/PATTERN/"/>
    
    
      <category term="PATTERN" scheme="http://yoursite.com/tags/PATTERN/"/>
    
  </entry>
  
  <entry>
    <title>T007 自定义控件 图文弹跳加载中效果</title>
    <link href="http://yoursite.com/2019/07/20/Custom%20View/T007%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E5%9B%BE%E6%96%87%E5%BC%B9%E8%B7%B3%E5%8A%A0%E8%BD%BD%E4%B8%AD%E6%95%88%E6%9E%9C/"/>
    <id>http://yoursite.com/2019/07/20/Custom View/T007 自定义控件 图文弹跳加载中效果/</id>
    <published>2019-07-19T16:00:00.000Z</published>
    <updated>2020-01-26T10:54:47.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-03b7334fbf14edfb.gif?imageMogr2/auto-orient/strip" alt=""></p><p>要想实现上述效果，需要准备三张图：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ca8cac0e6e5cd734.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading_text_1.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b525f50422a24b09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading_text_2.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a452b33c2f107f50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading_text_3.png"></p><p>然后让控件派生自 ImageView 类，这样才能方便地更改它的源文件内容。</p><p>想让图片上下跳动，可以利用 ValueAnimator 实时产生一个 0~200 的数值，然后让当前图片的位置实时向上移动 ValueAnimator 的动态值的高度即可。要让图片的位置实时向上移动，就需要先拿到初始状态下图片的位置。重写 onLayout(boolean changed, int left, int top, int right, int bottom) 函数，就可以拿到控件的初始高度 mTop，之后在每次 ValueAnimator 的动态值到来时，计算出当前控件的 top 位置，并将控件移动到这个位置就可以了。</p><p>即：自定义一个控件 LoadingImageView， 派生自 ImageView，然后重写 onLayout() 函数，拿到控件的初始 top 值。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class LoadingImageView extends AppCompatImageView &#123;</div><div class="line"></div><div class="line">    // 初始 top</div><div class="line">    private int mTop;</div><div class="line">    // 当前动画图片索引</div><div class="line">    private int mCurImgIndex = 0;</div><div class="line">    // 动画图片总张数</div><div class="line">    private static int mImgCount = 3;</div><div class="line"></div><div class="line">    public LoadingImageView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public LoadingImageView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public LoadingImageView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</div><div class="line">        super.onLayout(changed, left, top, right, bottom);</div><div class="line">        mTop = top;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>由于我们需要在刚展示图片时就开始动画，所以将动画的操作全部写在 init() 函数中。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private void init() &#123;</div><div class="line">    ValueAnimator valueAnimator = ValueAnimator.ofInt(0, 200, 0);</div><div class="line">    valueAnimator.setRepeatMode(ValueAnimator.RESTART);</div><div class="line">    valueAnimator.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">    valueAnimator.setDuration(1000);</div><div class="line">    valueAnimator.setInterpolator(new AccelerateInterpolator());</div><div class="line">    valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">            Integer dx = (Integer) animation.getAnimatedValue();</div><div class="line">            setTop(mTop - dx);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通过 (mTop - dx) 得到当前控件相对初始坐标上移 dx 距离后的最新坐标点，然后调用 setTop(int top) 函数将控件移动到当前位置。</p><p>接下来需要监听动画的开始和重复。当动画开始时，图片应该设置为 loading_text_1.png；在重复时，每重复一次应该更换一张图片。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">// 当前动画图片索引</div><div class="line">private int mCurImgIndex = 0;</div><div class="line">// 动画图片总张数</div><div class="line">private static int mImgCount = 3;</div><div class="line"></div><div class="line">private void init() &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    valueAnimator.addListener(new Animator.AnimatorListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onAnimationStart(Animator animation) &#123;</div><div class="line">            setImageDrawable(getResources().getDrawable(R.drawable.loading_text_1));</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void onAnimationEnd(Animator animation) &#123;&#125;</div><div class="line">        @Override</div><div class="line">        public void onAnimationCancel(Animator animation) &#123;&#125;</div><div class="line">        @Override</div><div class="line">        public void onAnimationRepeat(Animator animation) &#123;</div><div class="line">            mCurImgIndex++;</div><div class="line">            switch (mCurImgIndex % mImgCount) &#123;</div><div class="line">                case 0:</div><div class="line">                    setImageDrawable(getResources().getDrawable(R.drawable.loading_text_1));</div><div class="line">                    break;</div><div class="line">                case 1:</div><div class="line">                    setImageDrawable(getResources().getDrawable(R.drawable.loading_text_2));</div><div class="line">                    break;</div><div class="line">                case 2:</div><div class="line">                    setImageDrawable(getResources().getDrawable(R.drawable.loading_text_3));</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    valueAnimator.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在更改图片时，我们使用 mCurImgIndex 来累加当前重复的次数，通过与图片总张数 (mImgCount) 取余数，来决定这次重复使用的是哪张图片。</p><p>使用控件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.xxt.xtest.LoadingImageView</div><div class="line">        android:layout_width=&quot;50dp&quot;</div><div class="line">        android:layout_height=&quot;50dp&quot;</div><div class="line">        android:layout_margin=&quot;50dp&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>LoadingImageView 的完整代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.animation.Animator;</div><div class="line">import android.animation.ValueAnimator;</div><div class="line">import android.content.Context;</div><div class="line">import android.util.AttributeSet;</div><div class="line">import android.view.animation.AccelerateInterpolator;</div><div class="line"></div><div class="line">import androidx.appcompat.widget.AppCompatImageView;</div><div class="line"></div><div class="line">public class LoadingImageView extends AppCompatImageView &#123;</div><div class="line"></div><div class="line">    private int mTop;</div><div class="line">    // 当前动画图片索引</div><div class="line">    private int mCurImgIndex = 0;</div><div class="line">    // 动画图片总张数</div><div class="line">    private static int mImgCount = 3;</div><div class="line"></div><div class="line">    public LoadingImageView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public LoadingImageView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public LoadingImageView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        ValueAnimator valueAnimator = ValueAnimator.ofInt(0, 200, 0);</div><div class="line">        valueAnimator.setRepeatMode(ValueAnimator.RESTART);</div><div class="line">        valueAnimator.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">        valueAnimator.setDuration(1000);</div><div class="line">        valueAnimator.setInterpolator(new AccelerateInterpolator());</div><div class="line">        valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">                Integer dx = (Integer) animation.getAnimatedValue();</div><div class="line">                setTop(mTop - dx);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        valueAnimator.addListener(new Animator.AnimatorListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationStart(Animator animation) &#123;</div><div class="line">                setImageDrawable(getResources().getDrawable(R.drawable.loading_text_1));</div><div class="line">            &#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationEnd(Animator animation) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationCancel(Animator animation) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationRepeat(Animator animation) &#123;</div><div class="line">                mCurImgIndex++;</div><div class="line">                switch (mCurImgIndex % mImgCount) &#123;</div><div class="line">                    case 0:</div><div class="line">                        setImageDrawable(getResources().getDrawable(R.drawable.loading_text_1));</div><div class="line">                        break;</div><div class="line">                    case 1:</div><div class="line">                        setImageDrawable(getResources().getDrawable(R.drawable.loading_text_2));</div><div class="line">                        break;</div><div class="line">                    case 2:</div><div class="line">                        setImageDrawable(getResources().getDrawable(R.drawable.loading_text_3));</div><div class="line">                        break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        valueAnimator.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</div><div class="line">        super.onLayout(changed, left, top, right, bottom);</div><div class="line">        mTop = top;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14186083-03b7334fbf14edfb.gif?imag
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>T006 自定义控件 扫描雷达动画</title>
    <link href="http://yoursite.com/2019/07/19/Custom%20View/T006%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E6%89%AB%E6%8F%8F%E9%9B%B7%E8%BE%BE%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2019/07/19/Custom View/T006 自定义控件 扫描雷达动画/</id>
    <published>2019-07-18T16:00:00.000Z</published>
    <updated>2020-01-24T14:37:54.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d200aff4a7b219d9.gif?imageMogr2/auto-orient/strip" alt=""></p><h3 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h3><ul><li>表层是一张指针图，增加旋转动画，每旋转一周，增加一个波纹扩散动画效果。</li><li>波纹扩散动画效果是在底层的波纹图上实现缩放和透明度变化的组合动画。</li><li>使用容器来保存波纹扩散动画，便于复用。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c358aabf4dcd605b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="指针原图"></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1478d5d2bd1083fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="波纹原图"></p><h3 id="二、完整代码"><a href="#二、完整代码" class="headerlink" title="二、完整代码"></a>二、完整代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.animation.Animator;</div><div class="line">import android.animation.AnimatorSet;</div><div class="line">import android.animation.ObjectAnimator;</div><div class="line">import android.animation.ValueAnimator;</div><div class="line">import android.content.Context;</div><div class="line">import android.util.AttributeSet;</div><div class="line">import android.view.Gravity;</div><div class="line">import android.view.LayoutInflater;</div><div class="line">import android.view.View;</div><div class="line">import android.view.animation.LinearInterpolator;</div><div class="line">import android.widget.FrameLayout;</div><div class="line">import android.widget.ImageView;</div><div class="line">import android.widget.TextView;</div><div class="line"></div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class ScanningView extends FrameLayout &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 指针</div><div class="line">     */</div><div class="line">    private ImageView ivNeedle;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 波纹</div><div class="line">     */</div><div class="line">    private ImageView ivRipple;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 中间文字</div><div class="line">     */</div><div class="line">    private TextView tvTitle;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 装波纹的容器</div><div class="line">     */</div><div class="line">    private FrameLayout fl_move_circle;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 匀速插值器</div><div class="line">     */</div><div class="line">    private LinearInterpolator interpolator = new LinearInterpolator();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 准备动画</div><div class="line">     */</div><div class="line">    private AnimatorSet prepareAnim;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 指针旋转动画</div><div class="line">     */</div><div class="line">    private ObjectAnimator needleRotateAnim;</div><div class="line"></div><div class="line">    private List&lt;AnimatorSet&gt; animList = new ArrayList&lt;&gt;();</div><div class="line">    private int animCount = 3;</div><div class="line">    private int index = 0;</div><div class="line"></div><div class="line">    public ScanningView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        initView();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ScanningView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        initView();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initView()&#123;</div><div class="line">        View v = LayoutInflater.from(getContext()).inflate(R.layout.rotate_view,null);</div><div class="line">        ivNeedle = v.findViewById(R.id.iv_btn);</div><div class="line">        ivRipple = v.findViewById(R.id.iv_out_circle);</div><div class="line">        tvTitle = v.findViewById(R.id.tv_title);</div><div class="line">        fl_move_circle = v.findViewById(R.id.fl_move_circle);</div><div class="line">        addView(v, LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);</div><div class="line"></div><div class="line">        initAnim();</div><div class="line"></div><div class="line">        prepareAnim.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 初始化动画</div><div class="line">     * 准备动画 prepareAnim</div><div class="line">     * 扫描动画 scanningAnim</div><div class="line">     */</div><div class="line">    private void initAnim() &#123;</div><div class="line">        initPrepareAnim();</div><div class="line">        initScanningAnim();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initPrepareAnim() &#123;</div><div class="line">        // 开始循环的放大缩小波纹</div><div class="line">        ObjectAnimator outCircleAlpha = ObjectAnimator.ofFloat(ivRipple, &quot;alpha&quot;, 0.2f, 0.6f);</div><div class="line">        outCircleAlpha.setDuration(1000);</div><div class="line">        ObjectAnimator outCircleAnimX = ObjectAnimator.ofFloat(ivRipple, &quot;scaleX&quot;, 1f, 1.18f, 1f);</div><div class="line">        outCircleAnimX.setDuration(2000);</div><div class="line">        outCircleAnimX.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">        outCircleAnimX.setInterpolator(interpolator);</div><div class="line">        ObjectAnimator outCircleAnimY = ObjectAnimator.ofFloat(ivRipple, &quot;scaleY&quot;, 1f, 1.18f, 1f);</div><div class="line">        outCircleAnimY.setDuration(2000);</div><div class="line">        outCircleAnimY.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">        outCircleAnimY.setInterpolator(interpolator);</div><div class="line">        prepareAnim = new AnimatorSet();</div><div class="line">        prepareAnim.playTogether(outCircleAnimX, outCircleAnimY, outCircleAlpha);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initScanningAnim() &#123;</div><div class="line">        // 指针转动动画</div><div class="line">        needleRotateAnim = ObjectAnimator.ofFloat(ivNeedle, &quot;rotation&quot;, 0f, 360f);</div><div class="line">        needleRotateAnim.setDuration(1800);</div><div class="line">        needleRotateAnim.setInterpolator(interpolator);</div><div class="line">        needleRotateAnim.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">        needleRotateAnim.addListener(new Animator.AnimatorListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationStart(Animator animation) &#123;</div><div class="line">                playRippleAnim();</div><div class="line">            &#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationEnd(Animator animation) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationCancel(Animator animation) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationRepeat(Animator animation) &#123;</div><div class="line">                playRippleAnim();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initRippleAnim() &#123;</div><div class="line">        final ImageView imageView = new ImageView(getContext());</div><div class="line">        LayoutParams lp = new LayoutParams(dip2px(getContext(), 110), dip2px(getContext(), 110));</div><div class="line">        lp.gravity = Gravity.CENTER;</div><div class="line">        imageView.setLayoutParams(lp);</div><div class="line">        imageView.setImageResource(R.drawable.ripple);</div><div class="line">        fl_move_circle.addView(imageView);</div><div class="line">        ObjectAnimator outCircleAnimX = ObjectAnimator.ofFloat(imageView, &quot;scaleX&quot;, 1f, 5f);</div><div class="line">        ObjectAnimator outCircleAnimY = ObjectAnimator.ofFloat(imageView, &quot;scaleY&quot;, 1f, 5f);</div><div class="line">        ObjectAnimator alphaAnim = ObjectAnimator.ofFloat(imageView, &quot;alpha&quot;, 0.6f, 0);</div><div class="line">        outCircleAnimX.setDuration(5000);</div><div class="line">        outCircleAnimY.setDuration(5000);</div><div class="line">        alphaAnim.setDuration(5000);</div><div class="line">        final AnimatorSet animatorSet = new AnimatorSet();</div><div class="line">        animatorSet.playTogether(outCircleAnimX, outCircleAnimY, alphaAnim);</div><div class="line"></div><div class="line">        animList.add(animatorSet);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void playRippleAnim() &#123;</div><div class="line">        if (animList.size() &lt; animCount) &#123;</div><div class="line">            initRippleAnim();</div><div class="line">        &#125;</div><div class="line">        animList.get(index).start();</div><div class="line">        index++;</div><div class="line">        if (index == animCount) index = 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 模拟开始</div><div class="line">     */</div><div class="line">    public void onceClick()&#123;</div><div class="line">        // 取消掉循环的波纹</div><div class="line">        prepareAnim.cancel();</div><div class="line">        ivRipple.setVisibility(GONE);</div><div class="line"></div><div class="line">        needleRotateAnim.start();</div><div class="line">        tvTitle.setText(&quot;扫描中&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 根据手机的分辨率从 dip 的单位 转成为 px(像素)</div><div class="line">     */</div><div class="line">    public static int dip2px(Context context, float dpValue) &#123;</div><div class="line">        final float scale = context.getResources().getDisplayMetrics().density;</div><div class="line">        return (int) (dpValue * scale + 0.5f);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其布局文件 res/layout/scanning_view.xml 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:background=&quot;#69C8FA&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line"></div><div class="line">    &lt;FrameLayout</div><div class="line">        android:id=&quot;@+id/fl_move_circle&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/iv_out_circle&quot;</div><div class="line">        android:layout_width=&quot;110dp&quot;</div><div class="line">        android:layout_height=&quot;110dp&quot;</div><div class="line">        android:layout_gravity=&quot;center&quot;</div><div class="line">        android:alpha=&quot;0.6&quot;</div><div class="line">        android:src=&quot;@drawable/ripple&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/iv_btn&quot;</div><div class="line">        android:layout_width=&quot;110dp&quot;</div><div class="line">        android:layout_height=&quot;110dp&quot;</div><div class="line">        android:layout_gravity=&quot;center&quot;</div><div class="line">        android:src=&quot;@drawable/needle&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;TextView</div><div class="line">        android:id=&quot;@+id/tv_title&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:textColor=&quot;#ffffff&quot;</div><div class="line">        android:layout_gravity=&quot;center&quot;</div><div class="line">        android:text=&quot;点击扫描&quot;</div><div class="line">        android:textSize=&quot;10sp&quot;</div><div class="line">        android:layout_marginTop=&quot;13dp&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot; /&gt;</div><div class="line"></div><div class="line">&lt;/FrameLayout&gt;</div></pre></td></tr></table></figure></p><h3 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class DemoActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_demo);</div><div class="line"></div><div class="line">        final ScanningView view = findViewById(R.id.scanning);</div><div class="line">        view.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                view.onceClick();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.xxt.xtest.ScanningView</div><div class="line">        android:id=&quot;@+id/scanning&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14186083-d200aff4a7b219d9.gif?imag
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>T005 自定义控件 可配置加载 ImageView</title>
    <link href="http://yoursite.com/2019/07/18/Custom%20View/T005%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E5%8F%AF%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%20ImageView/"/>
    <id>http://yoursite.com/2019/07/18/Custom View/T005 自定义控件 可配置加载 ImageView/</id>
    <published>2019-07-17T16:00:00.000Z</published>
    <updated>2020-01-24T11:38:50.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-dd9b1010d91ba48c.gif?imageMogr2/auto-orient/strip" alt=""></p><p>原理很简单，使一张图围绕自己的中心点匀速旋转。完整代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.content.Context;</div><div class="line">import android.util.AttributeSet;</div><div class="line">import android.view.animation.Animation;</div><div class="line">import android.view.animation.LinearInterpolator;</div><div class="line">import android.view.animation.RotateAnimation;</div><div class="line"></div><div class="line">import androidx.annotation.Nullable;</div><div class="line">import androidx.appcompat.widget.AppCompatImageView;</div><div class="line"></div><div class="line">public class LoadingImageView extends AppCompatImageView &#123;</div><div class="line"></div><div class="line">    public LoadingImageView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public LoadingImageView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public LoadingImageView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        RotateAnimation rotateAnim = new RotateAnimation(0, 360,</div><div class="line">                Animation.RELATIVE_TO_SELF, 0.5f,</div><div class="line">                Animation.RELATIVE_TO_SELF, 0.5f);</div><div class="line">        rotateAnim.setRepeatCount(Animation.INFINITE);</div><div class="line">        rotateAnim.setDuration(1000);</div><div class="line">        rotateAnim.setInterpolator(new LinearInterpolator());</div><div class="line">        this.startAnimation(rotateAnim);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.xxt.xtest.LoadingImageView</div><div class="line">        android:layout_width=&quot;50dp&quot;</div><div class="line">        android:layout_height=&quot;50dp&quot;</div><div class="line">        android:layout_margin=&quot;50dp&quot;</div><div class="line">        android:src=&quot;@drawable/taiji&quot;/&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14186083-dd9b1010d91ba48c.gif?imag
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>T004 自定义控件 由远及近 ImageView</title>
    <link href="http://yoursite.com/2019/07/17/Custom%20View/T004%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E7%94%B1%E8%BF%9C%E5%8F%8A%E8%BF%91%20ImageView/"/>
    <id>http://yoursite.com/2019/07/17/Custom View/T004 自定义控件 由远及近 ImageView/</id>
    <published>2019-07-16T16:00:00.000Z</published>
    <updated>2020-01-24T04:42:13.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-817072fe0e22d8fd.gif?imageMogr2/auto-orient/strip" alt=""></p><p>参考知识点：<a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/#jump2" target="_blank" rel="external">ScaleAnimation</a>、<a href="https://xianxiaotao.github.io/2019/07/02/Custom%20View/02.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E5%99%A8%E5%88%9D%E6%8E%A2/#jump5" target="_blank" rel="external">BounceInterpolator</a></p><p>借助 ScaleAnimation 实现由远及近效果，首先需要让动画从控件某点（触屏点）为中心开始缩放；其次需要在动画结束后，将控件固定在放大后的状态；并使用回弹插值器。</p><p>上述效果图完整代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.content.Context;</div><div class="line">import android.util.AttributeSet;</div><div class="line">import android.view.MotionEvent;</div><div class="line">import android.view.animation.Animation;</div><div class="line">import android.view.animation.BounceInterpolator;</div><div class="line">import android.view.animation.ScaleAnimation;</div><div class="line"></div><div class="line">import androidx.annotation.Nullable;</div><div class="line">import androidx.appcompat.widget.AppCompatImageView;</div><div class="line"></div><div class="line">public class TouchImageView extends AppCompatImageView &#123;</div><div class="line"></div><div class="line">    private boolean isPlay = false;</div><div class="line"></div><div class="line">    public TouchImageView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TouchImageView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TouchImageView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        if (!isPlay) &#123;</div><div class="line">            isPlay = true;</div><div class="line"></div><div class="line">            float pivotXValue = (event.getX() - getLeft()) / getWidth();</div><div class="line">            float pivotYValue = (event.getY() - getTop()) / getHeight();</div><div class="line"></div><div class="line">            ScaleAnimation scaleAnim = new ScaleAnimation(1.0f, 3f, 1.0f, 3f,</div><div class="line">                    Animation.RELATIVE_TO_SELF, pivotXValue,</div><div class="line">                    Animation.RELATIVE_TO_SELF, pivotYValue);</div><div class="line">            scaleAnim.setDuration(3000);</div><div class="line">            scaleAnim.setFillAfter(true);</div><div class="line">            scaleAnim.setInterpolator(new BounceInterpolator());</div><div class="line">            this.startAnimation(scaleAnim);</div><div class="line">        &#125; else &#123;</div><div class="line">            this.clearAnimation();</div><div class="line">            isPlay = false;</div><div class="line">        &#125;</div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>之所以继承 ImageView，是为了复用其完善的图片显示功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14186083-817072fe0e22d8fd.gif?imag
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>T003 自定义控件 裁剪动画</title>
    <link href="http://yoursite.com/2019/07/16/Custom%20View/T003%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E8%A3%81%E5%89%AA%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2019/07/16/Custom View/T003 自定义控件 裁剪动画/</id>
    <published>2019-07-15T16:00:00.000Z</published>
    <updated>2020-01-24T04:42:51.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2cc64f1f2b5f86f5.gif?imageMogr2/auto-orient/strip" alt=""></p><p>参考知识点：<a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Canvas" target="_blank" rel="external">01.5 精通自定义 View 之绘图基础——Canvas</a></p><h3 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h3><p>这个动画的原理很简单，就是每次将裁剪区域变大，在裁剪区域内的图像就会显示出来，而裁剪区域之外的图像不会显示。而关键问题在于如何计算裁剪区域。</p><p>再来看一下动画截图，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1c8c6731e193d120.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从图示中可以看出，有两个裁剪区域。</p><p>裁剪区域一：从左向右，逐渐变大。假设宽度是 clipWidth，高度是 CLIP_HEIGHT，那么裁剪区域一所对应的 Rect 对象如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Rect(0, 0, clipWidth, CLIP_HEIGHT);</div></pre></td></tr></table></figure></p><p>裁剪区域二：从右向左，同样逐渐变大，它的宽度、高度都与裁剪区域一相同。但它是从右向左变化的，假设图片的宽度是 width，那么裁剪区域二所对应的 Rect 对象如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Rect(width - clipWidth, CLIP_HEIGHT, width, 2* CLIP_HEIGHT);</div></pre></td></tr></table></figure></p><h3 id="二、示例代码"><a href="#二、示例代码" class="headerlink" title="二、示例代码"></a>二、示例代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">public class ClipRegionView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap mBitmap;</div><div class="line">    private int clipWidth = 0;</div><div class="line">    private int width;</div><div class="line">    private int height;</div><div class="line">    private static final int CLIP_HEIGHT = 50;</div><div class="line">    private Path mPath;</div><div class="line">    private RectF mRect;</div><div class="line"></div><div class="line">    public ClipRegionView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.meinv);</div><div class="line">        width = mBitmap.getWidth();</div><div class="line">        height = mBitmap.getHeight();</div><div class="line">        mPath = new Path();</div><div class="line">        mRect = new RectF();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onSizeChanged(int w, int h, int oldW, int oldH) &#123;</div><div class="line">        super.onSizeChanged(w, h, oldW, oldH);</div><div class="line"></div><div class="line">        // 原图宽高超过控件自身宽高，进行缩放</div><div class="line">        if (width &gt; w || height &gt; h) &#123;</div><div class="line">            float scaleW = w * 1f / width;</div><div class="line">            float scaleH = h * 1f / height;</div><div class="line">            float scale = Math.min(scaleW, scaleH);</div><div class="line">            // 按比例重置参数</div><div class="line">            mBitmap = scaleBitmap(mBitmap, scale);</div><div class="line">            width = (int) (width * scale);</div><div class="line">            height = (int) (height * scale);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        mPath.reset();</div><div class="line">        int i = 0;</div><div class="line">        while (i * CLIP_HEIGHT &lt;= height) &#123;</div><div class="line">            if (i % 2 == 0) &#123;</div><div class="line">                mRect.set(0, i * CLIP_HEIGHT, clipWidth, (i+1) * CLIP_HEIGHT);</div><div class="line">            &#125; else &#123;</div><div class="line">                mRect.set(width - clipWidth, i * CLIP_HEIGHT, width, (i+1) * CLIP_HEIGHT);</div><div class="line">            &#125;</div><div class="line">            // 替换 Region.union 方法</div><div class="line">            mPath.addRect(mRect, Path.Direction.CCW);</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        // 因 canvas.clipRegion 方法过时，所以替换成 Path 相关 Api</div><div class="line">        canvas.clipPath(mPath);</div><div class="line">        canvas.drawBitmap(mBitmap, 0, 0, mPaint);</div><div class="line">        if (clipWidth &gt; width) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        clipWidth += 5;</div><div class="line">        invalidate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 按比例缩放图片</div><div class="line">     *</div><div class="line">     * @param origin 原图</div><div class="line">     * @param ratio  比例</div><div class="line">     * @return 新的bitmap</div><div class="line">     */</div><div class="line">    private Bitmap scaleBitmap(Bitmap origin, float ratio) &#123;</div><div class="line">        if (origin == null) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        int width = origin.getWidth();</div><div class="line">        int height = origin.getHeight();</div><div class="line">        Matrix matrix = new Matrix();</div><div class="line">        matrix.preScale(ratio, ratio);</div><div class="line">        Bitmap newBM = Bitmap.createBitmap(origin, 0, 0, width, height, matrix, false);</div><div class="line">        if (newBM.equals(origin)) &#123;</div><div class="line">            return newBM;</div><div class="line">        &#125;</div><div class="line">        origin.recycle();</div><div class="line">        return newBM;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过调用 invalidate() 函数的方式来重复触发 onDraw() 函数，然后在 onDraw() 函数中计算需要裁剪的画布。</p><p>在上述代码中，首先，由于 mPath 对象是每次都复用的，所以，在每次计算裁剪区域前, 都需要调用 mPath.reset() 函数将区域置空。</p><p>其次，根据计算裁剪区域的原理循环计算图片中每条间隔的裁剪区域并添加到 mPath 对象中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">while (i * CLIP_HEIGHT &lt;= height) &#123;</div><div class="line">    if (i % 2 == 0) &#123;</div><div class="line">        mRect.set(0, i * CLIP_HEIGHT, clipWidth, (i+1) * CLIP_HEIGHT);</div><div class="line">    &#125; else &#123;</div><div class="line">        mRect.set(width - clipWidth, i * CLIP_HEIGHT, width, (i+1) * CLIP_HEIGHT);</div><div class="line">    &#125;</div><div class="line">    // 替换 Region.union 方法</div><div class="line">    mPath.addRect(mRect, Path.Direction.CCW);</div><div class="line">    i++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>最后，将图片绘制在裁剪过的画布上，并渐变增大裁剪区域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">canvas.clipPath(mPath);</div><div class="line">canvas.drawBitmap(mBitmap, 0, 0, mPaint);</div><div class="line">clipWidth += 5;</div></pre></td></tr></table></figure></p><p>需要注意的是，当裁剪区域超过图像大小时，表示当前图像已经完全被绘制出来，可以暂停当前的绘制，以免浪费 CPU 资源。</p><p>当图片宽高超过控件自身大小时，裁剪动画效果很差，因此对原图进行缩放并重置参数。其效果图如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-64334c040329d581.gif?imageMogr2/auto-orient/strip" alt="有瑕疵的裁剪动画"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14186083-2cc64f1f2b5f86f5.gif?imag
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>T002 自定义控件 裁剪圆形和圆角头像</title>
    <link href="http://yoursite.com/2019/07/15/Custom%20View/T002%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E8%A3%81%E5%89%AA%E5%9C%86%E5%BD%A2%E5%92%8C%E5%9C%86%E8%A7%92%E5%A4%B4%E5%83%8F/"/>
    <id>http://yoursite.com/2019/07/15/Custom View/T002 自定义控件 裁剪圆形和圆角头像/</id>
    <published>2019-07-14T16:00:00.000Z</published>
    <updated>2020-01-24T04:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e55de3cecdfd0cbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>参考知识点：<a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Canvas" target="_blank" rel="external">01.5 精通自定义 View 之绘图基础——Canvas</a></p><h3 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h3><p>利用 clip 系列函数，通过与 Rect、Path、Region 取交、并、差等集合运算来获得最新的画布形状。此处只需要裁处圆形和圆角矩形，使用 Path 类构建即可，并用 clipPath 裁剪画布。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Path path = new Path();</div><div class="line">RectF rect = new RectF(50, 50, 240, 200);</div><div class="line">path.addRoundRect(rect, 10, 10, Path.Direction.CCW);</div><div class="line">// float[] radii = &#123;10,15,20,25,30,35,40,45&#125;;</div><div class="line">// path.addRoundRect(rect, radii, Path.Direction.CW);</div><div class="line"></div><div class="line">canvas.clipPath(path);</div></pre></td></tr></table></figure></p><h3 id="二、步骤"><a href="#二、步骤" class="headerlink" title="二、步骤"></a>二、步骤</h3><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class RoundImageView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line">    private Bitmap mBmp;</div><div class="line"></div><div class="line">    public RoundImageView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        // 禁用硬件加速</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPath = new Path();</div><div class="line">        mBmp = BitmapFactory.decodeResource(getResources(), R.drawable.meinv);</div><div class="line">        int x = mBmp.getWidth() / 2;</div><div class="line">        int y = mBmp.getHeight() / 2;</div><div class="line">        int r = Math.min(x, y);</div><div class="line">        mPath.addCircle(x, y, r, Path.Direction.CCW);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在使用 clip 系列函数时，要禁用硬件加速功能。然后利用 BitmapFactory.decodeResource() 函数从本地 res 文件夹中提取一个 Bitmap 文件。接着根据位图文件的大小，构造一条与图像大小相同的圆形路径。</p><h4 id="2-绘制圆形图像"><a href="#2-绘制圆形图像" class="headerlink" title="2. 绘制圆形图像"></a>2. 绘制圆形图像</h4><p>在绘图时，先将画布裁剪成圆形，再将位图画上去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line"></div><div class="line">    canvas.save();</div><div class="line">    canvas.clipPath(mPath);</div><div class="line">    canvas.drawBitmap(mBmp, 0, 0, mPaint);</div><div class="line">    canvas.restore();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4c70e591d12eea7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p><h4 id="4-绘制圆角图像"><a href="#4-绘制圆角图像" class="headerlink" title="4. 绘制圆角图像"></a>4. 绘制圆角图像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class RoundImageView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line">    private Bitmap mBmp;</div><div class="line">    private boolean isCircle = false;   // true：圆形图像；false：圆角矩形</div><div class="line"></div><div class="line">    public RoundImageView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        // 禁用硬件加速</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPath = new Path();</div><div class="line">        mBmp = BitmapFactory.decodeResource(getResources(), R.drawable.head);</div><div class="line">        if (isCircle) &#123;</div><div class="line">            int x = mBmp.getWidth() / 2;</div><div class="line">            int y = mBmp.getHeight() / 2;</div><div class="line">            int r = Math.min(x, y);</div><div class="line">            mPath.addCircle(x, y, r, Path.Direction.CCW);</div><div class="line">        &#125; else &#123;</div><div class="line">            RectF rectF = new RectF();</div><div class="line">            rectF.set(0, 0, mBmp.getWidth(), mBmp.getHeight());</div><div class="line">            mPath.addRoundRect(rectF, 20, 20, Path.Direction.CW);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        canvas.save();</div><div class="line">        canvas.clipPath(mPath);</div><div class="line">        canvas.drawBitmap(mBmp, 0, 0, mPaint);</div><div class="line">        canvas.restore();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14186083-51064ec4951773ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="圆角图像"></p><h3 id="三、优化"><a href="#三、优化" class="headerlink" title="三、优化"></a>三、优化</h3><p>对上述代码可以进行以下几个方面优化：</p><ul><li>参数可配置：圆形与圆角矩形切换、圆角大小、图片资源等。</li><li>图片缩放至控件大小。</li></ul><p>由于 Android 提供的 ImageView 已经处理好了各种缩放问题，我们可以在它的基础上添加一个显示圆角圆形的功能。<a href="https://xianxiaotao.github.io/2019/07/16/Custom%20View/X001%20%E5%9C%86%E8%A7%92%E5%9C%86%E5%BD%A2%20ImageView/" target="_blank" rel="external">详见博客：圆角圆形ImageView。</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14186083-e55de3cecdfd0cbc.png?imag
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>T001 自定义控件 蜘蛛网状图</title>
    <link href="http://yoursite.com/2019/07/14/Custom%20View/T001%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E8%9C%98%E8%9B%9B%E7%BD%91%E7%8A%B6%E5%9B%BE/"/>
    <id>http://yoursite.com/2019/07/14/Custom View/T001 自定义控件 蜘蛛网状图/</id>
    <published>2019-07-13T16:00:00.000Z</published>
    <updated>2020-01-16T09:01:32.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-69b3cadcd1005e2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>参考知识点：<a href="https://xianxiaotao.github.io/2019/07/01/Custom%20View/01.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84/" target="_blank" rel="external">01.2 精通自定义 View 之绘图基础——路径</a></p><p>从效果图中可以看出，我们要先画出一个网格，默认网格数和边角数都是 6。在代码中，为了简化逻辑，我们会将所有可变的内容，比如画笔颜色、网格数、边角数设为固定值。其实这些值都应该在初始化的时候通过对应的 set 函数设置到自定义控件内部，大家可以自行补充。</p><h3 id="一、初始化"><a href="#一、初始化" class="headerlink" title="一、初始化"></a>一、初始化</h3><p>不要在 onDraw() 函数中创建变量，所以必然会有一个初始化函数，用于在创建控件的时候初始化画笔等参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class SpiderView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mRadarPaint;                  // 蜘蛛网</div><div class="line">    private Paint mRadarLinePaint;              // 蜘蛛网辐射的六根线</div><div class="line">    private Paint mValuePaint;                  // 数据</div><div class="line"></div><div class="line">    private int mRadarPaintColor = 0xFF0099CC;  // 网格默认颜色</div><div class="line">    private Path mPath;</div><div class="line"></div><div class="line">    public SpiderView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * init view</div><div class="line">     * Paint、Path</div><div class="line">     */</div><div class="line">    private void init() &#123;</div><div class="line">        mRadarPaint = generatePaint(mRadarPaintColor, Paint.Style.FILL);</div><div class="line">        mRadarLinePaint = generatePaint(Color.WHITE, Paint.Style.STROKE);</div><div class="line">        mValuePaint = generatePaint(0xAFFF0000, Paint.Style.FILL);</div><div class="line"></div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 初始化画笔</div><div class="line">     * @param color 画笔颜色</div><div class="line">     * @param style 画笔样式</div><div class="line">     * @return Paint</div><div class="line">     */</div><div class="line">    private Paint generatePaint(int color, Paint.Style style) &#123;</div><div class="line">        Paint paint = new Paint();</div><div class="line">        paint.setColor(color);</div><div class="line">        paint.setStyle(style);</div><div class="line">        paint.setAntiAlias(true);</div><div class="line">        return paint;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里初始化了三个画笔，其中 mRadarPaint 是用来绘制蜘蛛网格的，类型设置为填充 (也可以设置为描边)；mRadarLinePaint 是用来绘制蜘蛛网格辐射的六根线，白色描边；而 mValuePaint 是用来绘制结果图的，所以设置成带透明的红色画笔，样式为填充。</p><h3 id="二、获得布局中心"><a href="#二、获得布局中心" class="headerlink" title="二、获得布局中心"></a>二、获得布局中心</h3><p>在 onSizeChanged(int w, int h, int oldW, int oldH) 函数中，根据 View 的长、宽，获取整个布局的中心坐标，因为整个雷达都是从这个中心坐标开始绘制的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private float radius;                       // 网格最大半径</div><div class="line">private int centerX;                        // 中心 X</div><div class="line">private int centerY;                        // 中心 Y</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void onSizeChanged(int w, int h, int oldW, int oldH) &#123;</div><div class="line">    // 获得布局中心</div><div class="line">    centerX = w / 2;</div><div class="line">    centerY = h / 2;</div><div class="line">    radius = Math.min(w, h) / 2f * 0.8f;</div><div class="line">    postInvalidate();</div><div class="line">    super.onSizeChanged(w, h, oldW, oldH);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们知道，在控件大小发生变化时，都会通过 onSizeChanged() 函数通知我们当前控件的大小。所以，我们只需要重写 onSizeChanged() 函数，即可得知当前控件的最新大小。</p><p>为了不顶边，将蜘蛛网的半径设置为 Math.min(w, h) / 2f * 0.8f 。</p><p>然后依据绘图中心，分别绘制蜘蛛网格、网格中线、数据图，即可完成整个效果图的绘制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line">    // 绘制蜘蛛网格</div><div class="line">    drawPolygon(canvas);</div><div class="line">    // 绘制中线</div><div class="line">    drawLines(canvas);</div><div class="line">    // 画数据图</div><div class="line">    drawRegion(canvas);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="三、绘制蜘蛛网格"><a href="#三、绘制蜘蛛网格" class="headerlink" title="三、绘制蜘蛛网格"></a>三、绘制蜘蛛网格</h3><p>下面我们就要绘制蜘蛛网格了，效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c1605cd5fc5aca77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p><p>很显然，蜘蛛网格是利用 Path 的 moveTo() 和 lineTo() 函数一圈圈画出来的，我们需要计算出每个转折点的位置。比如，计算下图中所标记点的 x, y 坐标。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1ccb35d364a464c5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>很明显，标记点在半径的 3/4 位置，而标记点与中心点的连线与 X 轴的夹角为 a，所以由图可得:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x = centX + 3/4 * radius * sina;</div><div class="line">y = centY + 3/4 * radius * cosa;</div></pre></td></tr></table></figure></p><p>因为我们共画了 6 个角，所以每个角的度数应该是 360°/6 = 60°。<br>依据上面的原理，列出画蜘蛛网格的代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">private int count = 6;                      // 多边形，默认值为 6</div><div class="line">private double angle = 2 * Math.PI / count; // 角度，值为 2π / count，默认</div><div class="line">private int maxValue = 4;                   // 最大值</div><div class="line"></div><div class="line">private void drawPolygon(Canvas canvas) &#123;</div><div class="line">    float r = radius / maxValue;            // r是蜘蛛丝之间的间距</div><div class="line">    for (int i = 1; i &lt;= maxValue; i++) &#123;   // 中心点不用绘制</div><div class="line">        float curR = r * i;                 // 当前半径</div><div class="line">        mPath.reset();</div><div class="line">        for (int j = 0; j &lt; count; j++) &#123;</div><div class="line">            if (j == 0) &#123;</div><div class="line">                mPath.moveTo(centerX + curR, centerY);</div><div class="line">            &#125; else &#123;</div><div class="line">                // 根据半径，计算出蜘蛛丝上每个点的坐标</div><div class="line">                float x = (float) (centerX + curR * Math.cos(angle * j));</div><div class="line">                float y = (float) (centerY + curR * Math.sin(angle * j));</div><div class="line">                mPath.lineTo(x, y);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        mPath.close();                      // 闭合路径</div><div class="line">        mRadarPaint.setAlpha(getRadarPaintColor(i));</div><div class="line">        canvas.drawPath(mPath, mRadarPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="四、画网格中线"><a href="#四、画网格中线" class="headerlink" title="四、画网格中线"></a>四、画网格中线</h3><p>在画完蜘蛛网格以后，我们需要画从网格中心到末端的直线，代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private void drawLines(Canvas canvas) &#123;</div><div class="line">    for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">        mPath.reset();</div><div class="line">        mPath.moveTo(centerX, centerY);</div><div class="line">        float x = (float) (centerX + radius * Math.cos(angle * i));</div><div class="line">        float y = (float) (centerY + radius * Math.sin(angle * i));</div><div class="line">        mPath.lineTo(x, y);</div><div class="line">        canvas.drawPath(mPath, mRadarLinePaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1b4ac177fa2e347f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网格中线效果图"></p><p>绘制原理与绘制蜘蛛网格是一样的，先找到各个末端点的坐标，然后画一条从中心点到末端点的连线即可。</p><h3 id="五、画数据图"><a href="#五、画数据图" class="headerlink" title="五、画数据图"></a>五、画数据图</h3><p>绘制数据区域其实也很简单，首先要确定每个数据点的位置。当然，网格线中的每一层网格都应该对应一个数值，在这里为了方便起见，将网格的最大值设为 4，即每一层数值是按 1,2,3,4 分布的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private int maxValue = 4;                   // 最大值</div><div class="line">private double[] data = &#123;2,3,1,3,4,3&#125;;      // 数据</div><div class="line"></div><div class="line">private void drawRegion(Canvas canvas) &#123;</div><div class="line">    mPath.reset();</div><div class="line">    for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">        double percent = data[i] / maxValue;</div><div class="line">        float x = (float) (centerX + radius * Math.cos(angle * i) * percent);</div><div class="line">        float y = (float) (centerY + radius * Math.sin(angle * i) * percent);</div><div class="line">        if (i == 0) &#123;</div><div class="line">            mPath.moveTo(x, centerY);</div><div class="line">        &#125; else &#123;</div><div class="line">            mPath.lineTo(x, y);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    canvas.drawPath(mPath, mValuePaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1b41b211cf4a3646.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p><h3 id="六、完整代码"><a href="#六、完整代码" class="headerlink" title="六、完整代码"></a>六、完整代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line">package com.xxt.xtest;</div><div class="line"></div><div class="line">import android.content.Context;</div><div class="line">import android.graphics.Canvas;</div><div class="line">import android.graphics.Color;</div><div class="line">import android.graphics.Paint;</div><div class="line">import android.graphics.Path;</div><div class="line">import android.util.AttributeSet;</div><div class="line">import android.view.View;</div><div class="line"></div><div class="line">import androidx.annotation.Nullable;</div><div class="line"></div><div class="line">public class SpiderView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mRadarPaint;                  // 蜘蛛网</div><div class="line">    private Paint mRadarLinePaint;              // 蜘蛛网辐射的六根线</div><div class="line">    private Paint mValuePaint;                  // 数据</div><div class="line"></div><div class="line">    private int mRadarPaintColor = 0xFF0099CC;  // 网格默认颜色</div><div class="line">    private Path mPath;</div><div class="line"></div><div class="line">    private float radius;                       // 网格最大半径</div><div class="line">    private int centerX;                        // 中心 X</div><div class="line">    private int centerY;                        // 中心 Y</div><div class="line"></div><div class="line">    private int count = 6;                      // 多边形，默认值为 6</div><div class="line">    private double angle = 2 * Math.PI / count; // 角度，值为 2π / count，默认</div><div class="line">    private int maxValue = 4;                   // 最大值</div><div class="line">    private double[] data = &#123;2,3,1,3,4,3&#125;;      // 数据</div><div class="line"></div><div class="line">    public SpiderView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * init view</div><div class="line">     * Paint、Path</div><div class="line">     */</div><div class="line">    private void init() &#123;</div><div class="line">        mRadarPaint = generatePaint(mRadarPaintColor, Paint.Style.FILL);</div><div class="line">        mRadarLinePaint = generatePaint(Color.WHITE, Paint.Style.STROKE);</div><div class="line">        mValuePaint = generatePaint(0xAFFF0000, Paint.Style.FILL);</div><div class="line"></div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onSizeChanged(int w, int h, int oldW, int oldH) &#123;</div><div class="line">        // 获得布局中心</div><div class="line">        centerX = w / 2;</div><div class="line">        centerY = h / 2;</div><div class="line">        radius = Math.min(w, h) / 2f * 0.8f;</div><div class="line">        postInvalidate();</div><div class="line">        super.onSizeChanged(w, h, oldW, oldH);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        // 绘制蜘蛛网格</div><div class="line">        drawPolygon(canvas);</div><div class="line">        // 绘制中线</div><div class="line">        drawLines(canvas);</div><div class="line">        // 画数据图</div><div class="line">        drawRegion(canvas);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void drawPolygon(Canvas canvas) &#123;</div><div class="line">        float r = radius / maxValue;            // r是蜘蛛丝之间的间距</div><div class="line">        for (int i = 1; i &lt;= maxValue; i++) &#123;   // 中心点不用绘制</div><div class="line">            float curR = r * i;                 // 当前半径</div><div class="line">            mPath.reset();</div><div class="line">            for (int j = 0; j &lt; count; j++) &#123;</div><div class="line">                if (j == 0) &#123;</div><div class="line">                    mPath.moveTo(centerX + curR, centerY);</div><div class="line">                &#125; else &#123;</div><div class="line">                    // 根据半径，计算出蜘蛛丝上每个点的坐标</div><div class="line">                    float x = (float) (centerX + curR * Math.cos(angle * j));</div><div class="line">                    float y = (float) (centerY + curR * Math.sin(angle * j));</div><div class="line">                    mPath.lineTo(x, y);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            mPath.close();                      // 闭合路径</div><div class="line">            mRadarPaint.setAlpha(getRadarPaintColor(i));</div><div class="line">            canvas.drawPath(mPath, mRadarPaint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void drawLines(Canvas canvas) &#123;</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            mPath.reset();</div><div class="line">            mPath.moveTo(centerX, centerY);</div><div class="line">            float x = (float) (centerX + radius * Math.cos(angle * i));</div><div class="line">            float y = (float) (centerY + radius * Math.sin(angle * i));</div><div class="line">            mPath.lineTo(x, y);</div><div class="line">            canvas.drawPath(mPath, mRadarLinePaint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void drawRegion(Canvas canvas) &#123;</div><div class="line">        mPath.reset();</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            double percent = data[i] / maxValue;</div><div class="line">            float x = (float) (centerX + radius * Math.cos(angle * i) * percent);</div><div class="line">            float y = (float) (centerY + radius * Math.sin(angle * i) * percent);</div><div class="line">            if (i == 0) &#123;</div><div class="line">                mPath.moveTo(x, centerY);</div><div class="line">            &#125; else &#123;</div><div class="line">                mPath.lineTo(x, y);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        canvas.drawPath(mPath, mValuePaint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 初始化画笔</div><div class="line">     * @param color 画笔颜色</div><div class="line">     * @param style 画笔样式</div><div class="line">     * @return Paint</div><div class="line">     */</div><div class="line">    private Paint generatePaint(int color, Paint.Style style) &#123;</div><div class="line">        Paint paint = new Paint();</div><div class="line">        paint.setColor(color);</div><div class="line">        paint.setStyle(style);</div><div class="line">        paint.setAntiAlias(true);</div><div class="line">        return paint;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 由内到外，增加透明度</div><div class="line">     * @param i 第几个网格，从中心点算起</div><div class="line">     * @return int alpha 值</div><div class="line">     */</div><div class="line">    private int getRadarPaintColor(int i) &#123;</div><div class="line">        if (i &gt; count || i &lt; 1) &#123;</div><div class="line">            return 0xFF;</div><div class="line">        &#125;</div><div class="line">        int alpha = Color.alpha(mRadarPaintColor);</div><div class="line">        int colorStep = alpha / (maxValue - 1) - 10;</div><div class="line">        alpha = alpha - colorStep * (i - 1);</div><div class="line">        return alpha;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14186083-69b3cadcd1005e2b.png?imag
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>13.2 精通自定义 View 之控件高级属性——Window 与 WindowManager</title>
    <link href="http://yoursite.com/2019/07/13/Custom%20View/13.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94Window%20%E4%B8%8E%20WindowManager/"/>
    <id>http://yoursite.com/2019/07/13/Custom View/13.2 精通自定义 View 之控件高级属性——Window 与 WindowManager/</id>
    <published>2019-07-12T18:00:00.000Z</published>
    <updated>2019-10-23T06:33:54.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>Window 表示窗口，在某些特殊的时候，比如需要在桌面或者锁屏上显示一些类似悬浮窗的效果，就需要用到 Window。Android 中所有的视图都是通过 Window 来呈现的，不管是 Activity、Dialog 还是 Toast，它们的视图实际上都是附加在 Window 上的。而 WindowManager 则提供了对这些 Window 的统一管理功能。</p><p><div id="jump1"></div></p><h3 id="13-2-1-Window-与-WindowManager-的联系"><a href="#13-2-1-Window-与-WindowManager-的联系" class="headerlink" title="13.2.1 Window 与 WindowManager 的联系"></a>13.2.1 Window 与 WindowManager 的联系</h3><p>为了分析 Window 的工作机制，我们需要了解如何使用 WindowManager 来添加一个 Window。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">WindowManager manager = (WindowManager) getSystemService(Context.WINDOW_SERVICE);</div><div class="line">WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams(width, height, type, flags, format);</div><div class="line">manager.addView(btn, layoutParams);</div></pre></td></tr></table></figure></p><p>上面的伪代码看起来非常简单，在构建 WindowManager.LayoutParams 时，其中的 type 和 flags 参数比较重要。</p><p>flags 参数有很多选项，用来控制 Window 的显示特性。我们来看几个常用的选项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static final int FLAG_NOT_FOCUSABLE = 0x00000008;</div></pre></td></tr></table></figure></p><p>表示此 Window 不需要获取焦点，不接收各种输入时间，此标记会同时启用 FLAG_NOT_TOUCH_MODEL，最终事件会直接传递给下层具有焦点的 Window。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static final int FLAG_NOT_TOUCH_MODEL = 0x00000020;</div></pre></td></tr></table></figure></p><p>自己 Window 区域内的事件自己处理；自己 Window 区域外的事件传递给底层 Window 处理。一般这个选项会默认开启，否则其他 Window 无法接收事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static final int FLAG_SHOW_WHEN_LOCKED = 0x00080000;</div></pre></td></tr></table></figure></p><p>可以让此 Window 显示在锁屏上。</p><p>type 参数是 int 类型的，表示 Window 的类型。Window 有三种类型：应用 Window、子 Window 和系统 Window。应用 Window 对应着一个 Activity。子 Window 不能独立存在，它需要附属在特定的父 Window 中，比如 Dialog 就是一个子 Window。系统 Window 是需要声明权限才能创建的，比如 Toast 和系统状态栏都是系统 Window。</p><p>Window 是分层的，层级大的 Window 会覆盖在层级小的 Window 上面。</p><ul><li>应用 Window 的层级范围：1 ~ 99。</li><li>子 Window 的层级范围：1000 ~ 1999。</li><li>系统 Window 的层级范围：2000 ~ 2999。</li></ul><p>type 参数就对应这些数字。如果想让 Window 置于顶层，则采用较大的层级即可；如果是系统类型的 Window，则需要在 AndroidMenifest.xml 中配置如下权限声明，否则会报权限不足的错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;</div></pre></td></tr></table></figure></p><p>WindowManager 提供的功能很简单，常用的只有三个方法，即添加 View、更新 View 和删除 View。这三个方法定义在 ViewManager 中，而 WindowManager 继承自 ViewManager。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@SystemService(Context.WINDOW_SERVICE)</div><div class="line">public interface WindowManager extends ViewManager &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public interface ViewManager &#123;</div><div class="line">    public void addView(View view, ViewGroup.LayoutParams params);</div><div class="line">    public void updateViewLayout(View view, ViewGroup.LayoutParams params);</div><div class="line">    public void removeView(View view);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><div id="jump2"></div></p><h3 id="13-2-2-示例：悬浮窗"><a href="#13-2-2-示例：悬浮窗" class="headerlink" title="13.2.2 示例：悬浮窗"></a>13.2.2 示例：悬浮窗</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4cd1f019e2f0d37f.gif?imageMogr2/auto-orient/strip" alt=""></p><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity implements View.OnTouchListener, View.OnClickListener &#123;</div><div class="line"></div><div class="line">    private ImageView mImageView;</div><div class="line">    private WindowManager.LayoutParams mLayoutParams;</div><div class="line">    private WindowManager mWindowManager;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</div><div class="line">            Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);</div><div class="line">            startActivityForResult(intent, 100);</div><div class="line">        &#125;</div><div class="line">        initView();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initView() &#123;</div><div class="line">        findViewById(R.id.add_btn).setOnClickListener(this);</div><div class="line">        findViewById(R.id.rmv_btn).setOnClickListener(this);</div><div class="line">        mWindowManager = (WindowManager) getApplicationContext().getSystemService(Context.WINDOW_SERVICE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onClick(View v) &#123;</div><div class="line">        if (v.getId() == R.id.add_btn) &#123;</div><div class="line">            mImageView = new ImageView(this);</div><div class="line">            mImageView.setBackgroundResource(R.mipmap.ic_launcher_round);</div><div class="line">            mLayoutParams = new WindowManager.LayoutParams(</div><div class="line">                    WindowManager.LayoutParams.WRAP_CONTENT,</div><div class="line">                    WindowManager.LayoutParams.WRAP_CONTENT,</div><div class="line">                    2099,</div><div class="line">                    WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL</div><div class="line">                    | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE</div><div class="line">                    | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED,</div><div class="line">                    PixelFormat.TRANSPARENT );</div><div class="line">            mLayoutParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_ERROR;</div><div class="line">            mLayoutParams.gravity = Gravity.TOP | Gravity.LEFT;</div><div class="line">            mLayoutParams.x = 0;</div><div class="line">            mLayoutParams.y = 300;</div><div class="line">            mImageView.setOnTouchListener(this);</div><div class="line">            mWindowManager.addView(mImageView, mLayoutParams);</div><div class="line">        &#125; else if (v.getId() == R.id.rmv_btn) &#123;</div><div class="line">            if (mWindowManager != null &amp;&amp; mImageView != null) &#123;</div><div class="line">                mWindowManager.removeViewImmediate(mImageView);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouch(View v, MotionEvent event) &#123;</div><div class="line">        int rawX = (int) event.getRawX();</div><div class="line">        int rawY = (int) event.getRawY();</div><div class="line"></div><div class="line">        if (event.getAction() == MotionEvent.ACTION_MOVE) &#123;</div><div class="line">            mLayoutParams.x = rawX;</div><div class="line">            mLayoutParams.y = rawY;</div><div class="line">            mWindowManager.updateViewLayout(mImageView, mLayoutParams);</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123;</div><div class="line">        super.onActivityResult(requestCode, resultCode, data);</div><div class="line">        if (requestCode == 100) &#123;</div><div class="line">            initView();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;Window 表示窗口，在某些特殊的时候，比如需要在桌面或者锁屏上显示一些类似悬浮窗的效果，就需要用到 Window。Android 中所有的视图都是通过 Window 来呈现的，不
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>13.1 精通自定义 View 之控件高级属性——GestureDetector 手势检测</title>
    <link href="http://yoursite.com/2019/07/13/Custom%20View/13.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E6%8E%A7%E4%BB%B6%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94GestureDetector%20%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B/"/>
    <id>http://yoursite.com/2019/07/13/Custom View/13.1 精通自定义 View 之控件高级属性——GestureDetector 手势检测/</id>
    <published>2019-07-12T17:00:00.000Z</published>
    <updated>2019-10-23T04:00:49.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><div id="jump1"></div></p><h3 id="13-1-1-概述"><a href="#13-1-1-概述" class="headerlink" title="13.1.1 概述"></a>13.1.1 概述</h3><p>GestureDetector，手势检测类，通过这个类可以识别很多手势。在识别出手势之后，具体的事物处理则交由程序员自己来实现。</p><p>此类提供了两个接口（OnGestureListener、OnDoubleTapListener）和一个外部类（SimpleOnGestureListener）。这个外部类其实是两个接口中所有函数的集成，它包含了这两个接口里所有必须实现的函数，而且都已经被重写，但所有函数体都是空的。该类是一个静态类，程序员可以在外部继承这个类，重写里面的手势处理函数。</p><p><div id="jump2"></div></p><h3 id="13-1-2-GestureDetector-OnGestureListener-接口"><a href="#13-1-2-GestureDetector-OnGestureListener-接口" class="headerlink" title="13.1.2 GestureDetector.OnGestureListener 接口"></a>13.1.2 GestureDetector.OnGestureListener 接口</h3><h4 id="1-基本讲解"><a href="#1-基本讲解" class="headerlink" title="1. 基本讲解"></a>1. 基本讲解</h4><p>如果我们写一个类并继承自 OnGestureListener，则会提示有几个必须重写的函数。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">private class GestureListener implements GestureDetector.OnGestureListener &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onDown(MotionEvent e) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onShowPress(MotionEvent e) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onSingleTapUp(MotionEvent e) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onLongPress(MotionEvent e) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这些函数在什么情况下才会被触发呢？</p><ul><li>onDown(MotionEvent e)：用户按下屏幕就会触发该函数。</li><li>onShowPress(MotionEvent e)：如果按下的时间超过瞬间，而且在按下的时候没有松开或者是拖动的，该函数就会被触发。</li><li>onLongPress(MotionEvent e)：长按触摸屏，超过一定时长，就会触发这个函数。</li></ul><p>触发顺序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onDown —&gt; onShowPress —&gt; onLongPress</div></pre></td></tr></table></figure></p><ul><li>onSingleTapUp(MotionEvent e)：一次单独的轻击抬起操作，也就是轻击一下屏幕，立刻抬起来，才会触发这个函数。当然，如果除 down 以外还有其他操作，就不再算是单独操作了，也就不会触发这个函数。</li></ul><p>单击一下非常快的（不滑动）Touchup，触发顺序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onDown —&gt; onSingleTapUp —&gt; onSingleTapConfirmed</div></pre></td></tr></table></figure></p><p>单击一下稍微慢一点的（不滑动）Touchup，触发顺序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onDown —&gt; onShowPress —&gt; onSingleTapUp —&gt; onSingleTapConfirmed</div></pre></td></tr></table></figure></p><ul><li>onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY)：滑屏，用户按下触摸屏、快速移动后松开，由一个 MotionEvent ACTION_DOWN、多个 ACTION_MOVE、一个 ACTION_UP 触发。</li><li>onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY)：在屏幕上拖动事件。无论是用手拖动 View，还是以抛的动作滚动，都会多次触发这个函数，在 ACTION_MOVE 动作发生时就会触发该函数。</li></ul><p>滑屏，即手指出动屏幕后，稍微滑动后立即松开，触发顺序为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onDown —&gt; onScroll —&gt; onScroll —&gt; onScroll —&gt; ... —&gt; onFling</div></pre></td></tr></table></figure></p><p>拖动，触发顺序为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onDown —&gt; onScroll —&gt; onScroll —&gt; onFling</div></pre></td></tr></table></figure></p><p>可见，无论是滑屏还是拖动，影响的只是中间 onScroll 被触发的数量而已，最终都会触发 onFling 事件。</p><h4 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h4><p>要使用 GestureDetector，有四步要走。<br>1）创建 OnGestureListener() 监听函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 可以构造实例</div><div class="line">GestureDetector.OnGestureListener listener = new GestureDetector.OnGestureListener() &#123;&#125;;</div><div class="line"></div><div class="line">// 也可以构造类</div><div class="line">private class GestureListener implements GestureDetector.OnGestureListener &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>2）创建 GestureDetector 实例 mGestureDetector。<br>构造函数有以下几个，根据需要选择即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GestureDetector(OnGestureListener listener)</div><div class="line">GestureDetector(Context context, OnGestureListener listener)</div><div class="line">GestureDetector(Context context, OnGestureListener listener, Handler handler)</div><div class="line">GestureDetector(Context context, OnGestureListener listener, Handler handler, boolean unused)</div></pre></td></tr></table></figure></p><p>3）在 onTouch(View v, MotionEvent event) 中进行拦截。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean onTouch(View v, MotionEvent event) &#123;</div><div class="line">    return mGestureDetector.onTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>4）绑定控件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TextView tv = findViewById(R.id.tv);</div><div class="line">tv.setOnTouchListener(this);</div></pre></td></tr></table></figure></p><p>完整代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity implements View.OnTouchListener &#123;</div><div class="line"></div><div class="line">    private GestureDetector mGestureDetector;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        mGestureDetector = new GestureDetector(new GestureListener());</div><div class="line"></div><div class="line">        TextView tv = findViewById(R.id.tv);</div><div class="line">        tv.setOnTouchListener(this);</div><div class="line">        tv.setFocusable(true);</div><div class="line">        tv.setClickable(true);</div><div class="line">        tv.setLongClickable(true);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouch(View v, MotionEvent event) &#123;</div><div class="line">        return mGestureDetector.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class GestureListener implements GestureDetector.OnGestureListener &#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public boolean onDown(MotionEvent e) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onDown&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onShowPress(MotionEvent e) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onShowPress&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public boolean onSingleTapUp(MotionEvent e) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onSingleTapUp&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onScroll&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onLongPress(MotionEvent e) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onLongPress&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onFling&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><div id="jump3"></div></p><h3 id="13-1-3-GestureDetector-OnDoubleTapListener-接口"><a href="#13-1-3-GestureDetector-OnDoubleTapListener-接口" class="headerlink" title="13.1.3 GestureDetector.OnDoubleTapListener 接口"></a>13.1.3 GestureDetector.OnDoubleTapListener 接口</h3><h4 id="1-构建"><a href="#1-构建" class="headerlink" title="1. 构建"></a>1. 构建</h4><p>有两种方式设置双击监听。<br>方法一：新建一个类，同时派生自 OnGestureListener 和 OnDoubleTapListener。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private class GestureListener implements GestureDetector.OnGestureListener,  </div><div class="line">        GestureDetector.OnDoubleTapListener &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>方法二：<br>使用 GestureDetector.setOnDoubleTapListener() 函数设置双击监听。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 构建 GestureDetector 实例</div><div class="line">mGestureDetector = new GestureDetector(new GestureListener());</div><div class="line"></div><div class="line">private class GestureListener implements GestureDetector.OnGestureListener &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 设置双击监听</div><div class="line">mGestureDetector.setOnDoubleTapListener(new DoubleTapListener());</div><div class="line">private class DoubleTapListener implements GestureDetector.OnDoubleTapListener &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>无论方法一还是方法二，都需要派生自 GestureDetector.OnGestureListener。</p><h4 id="2-函数讲解"><a href="#2-函数讲解" class="headerlink" title="2. 函数讲解"></a>2. 函数讲解</h4><p>先来看下 OnDoubleTapListener 接口必须重写的三个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private class DoubleTapListener implements GestureDetector.OnDoubleTapListener &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onSingleTapConfirmed(MotionEvent e) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onDoubleTap(MotionEvent e) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onDoubleTapEvent(MotionEvent e) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>onSingleTapConfirmed(MotionEvent e)：单击事件，用来判定该次单击是 SingleTap，而不是 DoubleTap。如果连续单击两次，就是 DoubleTap 手势；如果只单击一次，系统等待一段时间后没有收到第二次单击，则判定该次单击为 SingleTap，而不是 DoubleTap，然后触发 SingleTapConfirm 事件。触发顺序是：onDown —&gt; onSingleTapUp —&gt; onSingleTapConfirmed。有这样一个函数 onSingleTapUp()，它和 onSingleTapConfirmed() 函数容易混淆。二者的区别是：对于 onSingleTapUp() 函数来说，只要手抬起就会被触发；而对于 onSingleTapConfirmed() 函数来说，如果双击，则该函数就不会被触发。</li><li>onDoubleTap(MotionEvent e)：双击事件。</li><li>onDoubleTapEvent(MotionEvent e)：双击间隔中发生的动作。指在触发 onDoubleTap 以后，在双击之间发生的其他动作，包含 down、up 和 move 事件。</li></ul><p>在 13.1.2 节例子的基础上，添加双击监听，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity implements View.OnTouchListener &#123;</div><div class="line"></div><div class="line">    private GestureDetector mGestureDetector;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        mGestureDetector = new GestureDetector(new GestureListener());</div><div class="line">        mGestureDetector.setOnDoubleTapListener(new DoubleTapListener());</div><div class="line"></div><div class="line">        TextView tv = findViewById(R.id.tv);</div><div class="line">        tv.setOnTouchListener(this);</div><div class="line">        tv.setFocusable(true);</div><div class="line">        tv.setClickable(true);</div><div class="line">        tv.setLongClickable(true);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouch(View v, MotionEvent event) &#123;</div><div class="line">        return mGestureDetector.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class GestureListener implements GestureDetector.OnGestureListener &#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public boolean onDown(MotionEvent e) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onDown&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onShowPress(MotionEvent e) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onShowPress&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public boolean onSingleTapUp(MotionEvent e) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onSingleTapUp&quot;);</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onScroll&quot;);</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onLongPress(MotionEvent e) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onLongPress&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onFling&quot;);</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class DoubleTapListener implements GestureDetector.OnDoubleTapListener &#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public boolean onSingleTapConfirmed(MotionEvent e) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onSingleTapConfirmed&quot;);</div><div class="line">            Toast.makeText(MainActivity.this, &quot;onSingleTapConfirmed&quot;, Toast.LENGTH_LONG).show();</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public boolean onDoubleTap(MotionEvent e) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onDoubleTap&quot;);</div><div class="line">            Toast.makeText(MainActivity.this, &quot;onDoubleTap&quot;, Toast.LENGTH_LONG).show();</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public boolean onDoubleTapEvent(MotionEvent e) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;onDoubleTapEvent:&quot; + e.getAction());</div><div class="line">            Toast.makeText(MainActivity.this, &quot;onDoubleTapEvent&quot;, Toast.LENGTH_LONG).show();</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>双击所对应的事件触发顺序如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d8ed3d75951e7a32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>第二次单击时，先触发 onDoubleTap，再触发 onDown。</li><li>在触发 onDoubleTap 以后，就开始触发 onDoubleTapEvent。onDoubleTapEvent 后面的数字代表当前的事件，0 代表 ACTION_DOWN，1 代表 ACTION_UP，2 代表 ACTION_MOVE。</li></ul><p>轻轻单击一下，对应的事件触发顺序如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-6662fcd81e5a2fa5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><div id="jump4"></div></p><h3 id="13-1-4-GestureDetector-SimpleOnGestureListener-类"><a href="#13-1-4-GestureDetector-SimpleOnGestureListener-类" class="headerlink" title="13.1.4 GestureDetector.SimpleOnGestureListener 类"></a>13.1.4 GestureDetector.SimpleOnGestureListener 类</h3><p>SimpleOnGestureListener 类与 OnGestureListener 和 OnDoubleTapListener 接口的不同之处在于：<br>1）这是一个类，在它的基础上新建类，要用 extends 派生，而不能用 implements 继承。<br>2）OnGestureListener 和 OnDoubleTapListener 接口里的函数都是被强制重写的，即使用不到也要重写出来一个空函数；而在 SimpleOnGestureListener 类的实例或派生类中不必如此，可以根据情况，用到哪个函数就重写哪个函数，因为 SimpleOnGestureListener 类本身已经实现了这两个接口中的所有函数，只是里面全是空的而已。</p><p>下面利用 SimpleOnGestureListener 类来重新实现前面的几个效果，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity implements View.OnTouchListener &#123;</div><div class="line"></div><div class="line">    private GestureDetector mGestureDetector;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        mGestureDetector = new GestureDetector(new XSimpleGestureListener());</div><div class="line"></div><div class="line">        TextView tv = findViewById(R.id.tv);</div><div class="line">        tv.setOnTouchListener(this);</div><div class="line">        tv.setFocusable(true);</div><div class="line">        tv.setClickable(true);</div><div class="line">        tv.setLongClickable(true);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouch(View v, MotionEvent event) &#123;</div><div class="line">        return mGestureDetector.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class XSimpleGestureListener extends GestureDetector.SimpleOnGestureListener &#123;</div><div class="line"></div><div class="line">        /***** OnGestureListener 的函数 *****/</div><div class="line">        public boolean onDown(MotionEvent e) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void onShowPress(MotionEvent e) &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public boolean onSingleTapUp(MotionEvent e) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void onLongPress(MotionEvent e) &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /***** OnDoubleTapListener 的函数 *****/</div><div class="line">        public boolean onDoubleTap(MotionEvent e) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public boolean onDoubleTapEvent(MotionEvent e) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public boolean onSingleTapConfirmed(MotionEvent e) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><div id="jump5"></div></p><h3 id="13-1-5-onFling-函数的应用"><a href="#13-1-5-onFling-函数的应用" class="headerlink" title="13.1.5 onFling() 函数的应用"></a>13.1.5 onFling() 函数的应用</h3><p>可以利用 onFling() 函数来识别当前用户是在左滑还是在右滑。先来看一下 onFling() 函数的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY)</div></pre></td></tr></table></figure></p><p>参数：</p><ul><li>e1：第一个 ACTION_DOWN MotionEvent。</li><li>e2：最后一个 ACTION_DOWN MotionEvent。</li><li>velocityX：X 轴上的移动速度，单位为像素/秒。</li><li>velocityY：Y 轴上的移动速度，单位为像素/秒。</li></ul><p>实现的功能：当用户向左滑动距离超过 100 像素，且滑动速度超过 100 像素/秒时，即判断为向左滑动；向右同理。核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private class XSimpleGestureListener extends GestureDetector.SimpleOnGestureListener &#123;</div><div class="line"></div><div class="line">    final int FLING_MIN_DISTANCE = 100;</div><div class="line">    final int FLING_MIN_VELOCITY = 100;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123;</div><div class="line">        // 向左滑</div><div class="line">        if (e1.getX() - e2.getX() &gt; FLING_MIN_DISTANCE</div><div class="line">                &amp;&amp; Math.abs(velocityX) &gt; FLING_MIN_VELOCITY) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;Fling left&quot;);</div><div class="line">        &#125;</div><div class="line">        // 向右滑</div><div class="line">        else if (e2.getX() - e1.getX() &gt; FLING_MIN_DISTANCE</div><div class="line">                &amp;&amp; Math.abs(velocityX) &gt; FLING_MIN_VELOCITY) &#123;</div><div class="line">            Log.i(&quot;MyGesture&quot;, &quot;Fling right&quot;);</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;div id=&quot;jump1&quot;&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h3 id=&quot;13-1-1-概述&quot;&gt;&lt;a href=&quot;#13-1-1-概述&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>12.3 精通自定义 View 之封装控件——实现 FlowLayout 容器</title>
    <link href="http://yoursite.com/2019/07/12/Custom%20View/12.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%20FlowLayout%20%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2019/07/12/Custom View/12.3 精通自定义 View 之封装控件——实现 FlowLayout 容器/</id>
    <published>2019-07-11T19:00:00.000Z</published>
    <updated>2019-11-01T06:52:29.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-3322140af46dbd6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="FlowLayout 容器效果图"></p><p><div id="jump1"></div></p><h3 id="12-3-1-XML-布局"><a href="#12-3-1-XML-布局" class="headerlink" title="12.3.1 XML 布局"></a>12.3.1 XML 布局</h3><p>先定义一个 style 标签，这是为 FlowLayout 中的 TextView 定义的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;resources&gt;</div><div class="line">    ...</div><div class="line">    &lt;style name=&quot;text_flag&quot;&gt;</div><div class="line">        &lt;item name=&quot;android:layout_width&quot;&gt;wrap_content&lt;/item&gt;</div><div class="line">        &lt;item name=&quot;android:layout_height&quot;&gt;wrap_content&lt;/item&gt;</div><div class="line">        &lt;item name=&quot;android:layout_margin&quot;&gt;4dp&lt;/item&gt;</div><div class="line">        &lt;item name=&quot;android:background&quot;&gt;@drawable/flag&lt;/item&gt;</div><div class="line">        &lt;item name=&quot;android:textColor&quot;&gt;#FFFFFF&lt;/item&gt;</div><div class="line">    &lt;/style&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure></p><p>/res/drawable/flag.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;shape</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:shape=&quot;rectangle&quot;&gt;</div><div class="line">    &lt;solid android:color=&quot;@color/colorAccent&quot;/&gt;</div><div class="line">    &lt;padding</div><div class="line">        android:top=&quot;5dp&quot;</div><div class="line">        android:bottom=&quot;5dp&quot;</div><div class="line">        android:left=&quot;10dp&quot;</div><div class="line">        android:right=&quot;10dp&quot;/&gt;</div><div class="line">    &lt;corners android:radius=&quot;30dp&quot;/&gt;</div><div class="line">&lt;/shape&gt;</div></pre></td></tr></table></figure></p><p>act_main.xml 的布局代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line">    &lt;com.xxt.xtest.FlowLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;&gt;</div><div class="line">        &lt;TextView</div><div class="line">            style=&quot;@style/text_flag&quot;</div><div class="line">            android:text=&quot;Welcome&quot;/&gt;</div><div class="line">        &lt;TextView</div><div class="line">            style=&quot;@style/text_flag&quot;</div><div class="line">            android:text=&quot;IT 工程师&quot;/&gt;</div><div class="line">        &lt;TextView</div><div class="line">            style=&quot;@style/text_flag&quot;</div><div class="line">            android:text=&quot;我真是可以的&quot;/&gt;</div><div class="line">        &lt;TextView</div><div class="line">            style=&quot;@style/text_flag&quot;</div><div class="line">            android:text=&quot;你觉得呢&quot;/&gt;</div><div class="line">        &lt;TextView</div><div class="line">            style=&quot;@style/text_flag&quot;</div><div class="line">            android:text=&quot;不要只知道挣钱&quot;/&gt;</div><div class="line">        &lt;TextView</div><div class="line">            style=&quot;@style/text_flag&quot;</div><div class="line">            android:text=&quot;努力 ing&quot;/&gt;</div><div class="line">        &lt;TextView</div><div class="line">            style=&quot;@style/text_flag&quot;</div><div class="line">            android:text=&quot;I thick i can&quot;/&gt;</div><div class="line">    &lt;/com.xxt.xtest.FlowLayout&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p><div id="jump2"></div></p><h3 id="12-3-2-提取-margin-值与重写-onMeasure-函数"><a href="#12-3-2-提取-margin-值与重写-onMeasure-函数" class="headerlink" title="12.3.2 提取 margin 值与重写 onMeasure() 函数"></a>12.3.2 提取 margin 值与重写 onMeasure() 函数</h3><h4 id="1-提取-margin-值"><a href="#1-提取-margin-值" class="headerlink" title="1. 提取 margin 值"></a>1. 提取 margin 值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class FlowLayout extends ViewGroup &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected LayoutParams generateLayoutParams(LayoutParams p) &#123;</div><div class="line">        return new MarginLayoutParams(p);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public LayoutParams generateLayoutParams(AttributeSet attrs) &#123;</div><div class="line">        return new MarginLayoutParams(getContext(), attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected LayoutParams generateDefaultLayoutParams() &#123;</div><div class="line">        return new MarginLayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2-重写-onMeasure-函数"><a href="#2-重写-onMeasure-函数" class="headerlink" title="2. 重写 onMeasure() 函数"></a>2. 重写 onMeasure() 函数</h4><p>要实现 FlowLayout，必然涉及下面几个问题。<br><strong>1）何时换行</strong><br>从效果图中可以看到，FlowLayout 的布局是一行行的，如果当期已经放不下一个控件了，就把这个控件移到下一行显示。所以需要一个变量来计算当前行已经占据的宽度，以判断剩下的空间是否还能容得下下一个控件。<br><strong>2）如何得到 FlowLayout 的宽度</strong><br>FlowLayout 的宽度是所有行宽度的最大值，所以我们要记录每一行所占据的宽度值，进而找到所有值中的最大值。<br><strong>3）如何得到 FlowLayout 的高度</strong><br>FlowLayout 的高度是每一行高度的总和，而每一行的高度则取该行中所有控件高度的最大值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">    super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">    int measureWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">    int measureHeight = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">    int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">    int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"></div><div class="line">    int lineWidth = 0;      // 记录每一行的宽度</div><div class="line">    int lineHeight = 0;     // 记录每一行的高度</div><div class="line">    int width = 0;          // 记录整个 FlowLayout 的宽度</div><div class="line">    int height = 0;         // 记录整个 FlowLayout 的高度</div><div class="line"></div><div class="line">    int count = getChildCount();</div><div class="line">    for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">        View child = getChildAt(i);</div><div class="line">        measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">        // 计算控件的宽高时，要加上上下左右的 margin 值</div><div class="line">        MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">        int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;</div><div class="line">        int childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;</div><div class="line"></div><div class="line">        if (lineWidth + childWidth &gt; measureWidth) &#123;</div><div class="line">            // 需要换行</div><div class="line">            width = Math.max(lineWidth, childWidth);</div><div class="line">            height += lineHeight;</div><div class="line">            // 当前行放不下当前控件，而将此控件调到下一行</div><div class="line">            // 所以将此控件的高度和宽度初始化给 lineWidth、lineHeight</div><div class="line">            lineWidth = childWidth;</div><div class="line">            lineHeight = childHeight;</div><div class="line">        &#125; else &#123;</div><div class="line">            // 否则累加值 lineWidth，lineHeight 并取最大高度</div><div class="line">            lineWidth += childWidth;</div><div class="line">            lineHeight = Math.max(lineHeight, childHeight);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 因为最后一行是不会超出 width 范围的，所以需要单独处理</div><div class="line">        if (i == count - 1) &#123;</div><div class="line">            width = Math.max(width, lineWidth);</div><div class="line">            height += lineHeight;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    setMeasuredDimension((measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth : width,</div><div class="line">            (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight : height);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="3-重写-onLayout-函数——布局所有子控件"><a href="#3-重写-onLayout-函数——布局所有子控件" class="headerlink" title="3. 重写 onLayout() 函数——布局所有子控件"></a>3. 重写 onLayout() 函数——布局所有子控件</h4><p>在 onLayout() 函数中需要一个个布局子控件。由于控件要后移和换行，所以我们要标记当前控件的 top 坐标和 left 坐标。然后计算每个控件的 top 坐标和 left 坐标，再调用 layout(int left, int top, int right, int bottom)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">    int count = getChildCount();</div><div class="line">    int lineWidth = 0;      // 累加当前行的行宽</div><div class="line">    int lineHeight = 0;     // 当前行的行高</div><div class="line">    int top = 0, left = 0;  // 当前控件的 top 坐标和 left 坐标</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">        View child = getChildAt(i);</div><div class="line">        MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">        int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;</div><div class="line">        int childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;</div><div class="line">        if (childWidth + lineWidth &gt; getMeasuredWidth()) &#123;</div><div class="line">            // 如果换行，则当前控件将放到下一行，从最左边开始，所以 left 就是 0；</div><div class="line">            // 而 top 则需要加上上一行的行高，才是这个控件的 top 坐标</div><div class="line">            top += lineHeight;</div><div class="line">            left = 0;</div><div class="line">            lineHeight = childHeight;</div><div class="line">            lineWidth = childWidth;</div><div class="line">        &#125; else &#123;</div><div class="line">            lineHeight = Math.max(lineHeight, childHeight);</div><div class="line">            lineWidth += childWidth;</div><div class="line">        &#125;</div><div class="line">        // 计算 childView 的 left、top、right、bottom</div><div class="line">        int lc = left + lp.leftMargin;</div><div class="line">        int tc = top + lp.topMargin;</div><div class="line">        int rc = lc + child.getMeasuredWidth();</div><div class="line">        int bc = tc + child.getMeasuredHeight();</div><div class="line">        child.layout(lc, tc, rc, bc);</div><div class="line">        // 将 left 置为下一个子控件的起始点</div><div class="line">        left += childWidth;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><div id="jump3"></div></p><h3 id="12-3-3-完整代码"><a href="#12-3-3-完整代码" class="headerlink" title="12.3.3 完整代码"></a>12.3.3 完整代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line">public class FlowLayout extends ViewGroup &#123;</div><div class="line"></div><div class="line">    public FlowLayout(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">        int measureWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        int measureHeight = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">        int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">        int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"></div><div class="line">        int lineWidth = 0;      // 记录每一行的宽度</div><div class="line">        int lineHeight = 0;     // 记录每一行的高度</div><div class="line">        int width = 0;          // 记录整个 FlowLayout 的宽度</div><div class="line">        int height = 0;         // 记录整个 FlowLayout 的高度</div><div class="line"></div><div class="line">        int count = getChildCount();</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            View child = getChildAt(i);</div><div class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">            // 计算控件的宽高时，要加上上下左右的 margin 值</div><div class="line">            MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">            int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;</div><div class="line">            int childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;</div><div class="line"></div><div class="line">            if (lineWidth + childWidth &gt; measureWidth) &#123;</div><div class="line">                // 需要换行</div><div class="line">                width = Math.max(lineWidth, childWidth);</div><div class="line">                height += lineHeight;</div><div class="line">                // 当前行放不下当前控件，而将此控件调到下一行</div><div class="line">                // 所以将此控件的高度和宽度初始化给 lineWidth、lineHeight</div><div class="line">                lineWidth = childWidth;</div><div class="line">                lineHeight = childHeight;</div><div class="line">            &#125; else &#123;</div><div class="line">                // 否则累加值 lineWidth，lineHeight 并取最大高度</div><div class="line">                lineWidth += childWidth;</div><div class="line">                lineHeight = Math.max(lineHeight, childHeight);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // 因为最后一行是不会超出 width 范围的，所以需要单独处理</div><div class="line">            if (i == count - 1) &#123;</div><div class="line">                width = Math.max(width, lineWidth);</div><div class="line">                height += lineHeight;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setMeasuredDimension((measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth : width,</div><div class="line">                (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight : height);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">        int count = getChildCount();</div><div class="line">        int lineWidth = 0;      // 累加当前行的行宽</div><div class="line">        int lineHeight = 0;     // 当前行的行高</div><div class="line">        int top = 0, left = 0;  // 当前控件的 top 坐标和 left 坐标</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            View child = getChildAt(i);</div><div class="line">            MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">            int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;</div><div class="line">            int childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;</div><div class="line">            if (childWidth + lineWidth &gt; getMeasuredWidth()) &#123;</div><div class="line">                // 如果换行，则当前控件将放到下一行，从最左边开始，所以 left 就是 0；</div><div class="line">                // 而 top 则需要加上上一行的行高，才是这个控件的 top 坐标</div><div class="line">                top += lineHeight;</div><div class="line">                left = 0;</div><div class="line">                lineHeight = childHeight;</div><div class="line">                lineWidth = childWidth;</div><div class="line">            &#125; else &#123;</div><div class="line">                lineHeight = Math.max(lineHeight, childHeight);</div><div class="line">                lineWidth += childWidth;</div><div class="line">            &#125;</div><div class="line">            // 计算 childView 的 left、top、right、bottom</div><div class="line">            int lc = left + lp.leftMargin;</div><div class="line">            int tc = top + lp.topMargin;</div><div class="line">            int rc = lc + child.getMeasuredWidth();</div><div class="line">            int bc = tc + child.getMeasuredHeight();</div><div class="line">            child.layout(lc, tc, rc, bc);</div><div class="line">            // 将 left 置为下一个子控件的起始点</div><div class="line">            left += childWidth;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected LayoutParams generateLayoutParams(LayoutParams p) &#123;</div><div class="line">        return new MarginLayoutParams(p);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public LayoutParams generateLayoutParams(AttributeSet attrs) &#123;</div><div class="line">        return new MarginLayoutParams(getContext(), attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected LayoutParams generateDefaultLayoutParams() &#123;</div><div class="line">        return new MarginLayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14186083-3322140af46dbd6a.png?imag
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>12.2 精通自定义 View 之封装控件——测量和布局</title>
    <link href="http://yoursite.com/2019/07/12/Custom%20View/12.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E6%B5%8B%E9%87%8F%E5%92%8C%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2019/07/12/Custom View/12.2 精通自定义 View 之封装控件——测量和布局/</id>
    <published>2019-07-11T18:00:00.000Z</published>
    <updated>2019-11-01T08:40:12.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><div id="jump1"></div></p><h3 id="12-2-1-ViewGroup-绘制流程"><a href="#12-2-1-ViewGroup-绘制流程" class="headerlink" title="12.2.1 ViewGroup 绘制流程"></a>12.2.1 ViewGroup 绘制流程</h3><p>View 和 ViewGroup 的绘制流程基本相同，只是在 ViewGroup 中不仅要绘制自己，还要绘制其中的子控件，而 View 只需要绘制自己就可以了。</p><p>绘制流程分为三步：测量、布局、绘制，分别对应 onMeasure()、onLayout()、onDraw() 函数。</p><ul><li>onMeasure()：测量当前控件的大小，为正式布局提供建议（注意：只是建议，至于用不用，要看 onLayout() 函数）。</li><li>onLayout()：使用 layout() 函数对所有字控件进行布局。</li><li>onDraw()：根据布局的位置绘图。</li></ul><p><div id="jump2"></div></p><h3 id="12-2-2-onMeasure-函数与-MeasureSpec"><a href="#12-2-2-onMeasure-函数与-MeasureSpec" class="headerlink" title="12.2.2 onMeasure() 函数与 MeasureSpec"></a>12.2.2 onMeasure() 函数与 MeasureSpec</h3><p>布局绘画涉及两个过程：测量过程和布局过程。测量过程通过 measure() 函数来实现，是 View 树自顶向下的遍历，每个 View 在循环过程中将尺寸细节往下传递，当测量过程完成以后，所有的 View 都存储了自己的尺寸。布局过程则通过 layout() 函数来实现，也是自顶向下的，在这个过程中，每个父 View 负责通过计算好的尺寸放置它的子 View。</p><p>onMeasure() 函数是用来测量当前控件大小的，给 onLayout() 函数提供数值参考。需要特别注意的是，测量完成以后，要通过 setMeasuredDimension(int, int) 函数设置给系统。</p><h4 id="1-onMeasure-函数"><a href="#1-onMeasure-函数" class="headerlink" title="1. onMeasure() 函数"></a>1. onMeasure() 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)</div></pre></td></tr></table></figure><p>参数 widthMeasureSpec 和 heightMeasureSpec 是父类传递给当前 View 的一个建议值，即想把当前 View 的尺寸设置为宽 widthMeasureSpec、高 heightMeasureSpec。</p><h4 id="2-MeasureSpec-的组成"><a href="#2-MeasureSpec-的组成" class="headerlink" title="2. MeasureSpec 的组成"></a>2. MeasureSpec 的组成</h4><p>widthMeasureSpec 和 heightMeasureSpec 转换为二进制数字表示，它们都是 32 位的，前 2 位代表模式（mode），后面 30 位代表数值（size）。</p><h5 id="1）模式分类"><a href="#1）模式分类" class="headerlink" title="1）模式分类"></a>1）模式分类</h5><table><thead><tr><th style="text-align:center">模式</th><th style="text-align:center">二进制值</th><th style="text-align:left">含义</th><th style="text-align:left">对应 XML</th></tr></thead><tbody><tr><td style="text-align:center">UNSPECIFIED</td><td style="text-align:center">00000000…00000000</td><td style="text-align:left">父元素不对子元素的确切大小，子元素可以得到任意想要的大小</td><td style="text-align:left">不常用</td></tr><tr><td style="text-align:center">EXACTLY</td><td style="text-align:center">01000000…00000000</td><td style="text-align:left">父元素决定子元素的确切大小，子元素将被限定在给定的边界里而忽略它本身的大小</td><td style="text-align:left">match_parent、具体数值</td></tr><tr><td style="text-align:center">AT_MOST</td><td style="text-align:center">10000000…00000000</td><td style="text-align:left">子元素至多达到指定大小的值</td><td style="text-align:left">wrap_content</td></tr></tbody></table><h5 id="2）模式提取"><a href="#2）模式提取" class="headerlink" title="2）模式提取"></a>2）模式提取</h5><p>使用 &amp; 位运算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private static final int MODE_SHIFT = 30;</div><div class="line">// 对应：11000000 00000000 00000000 00000000</div><div class="line">private static final int MODE_MASK  = 0x3 &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line">// 提取模式</div><div class="line">public static int getMode(int measureSpec) &#123;</div><div class="line">    return (measureSpec &amp; MODE_MASK);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 提取数值</div><div class="line">public static int getSize(int measureSpec) &#123;</div><div class="line">    return (measureSpec &amp; ~MODE_MASK);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h5 id="3）MeasureSpec"><a href="#3）MeasureSpec" class="headerlink" title="3）MeasureSpec"></a>3）MeasureSpec</h5><p>Android 已经为我们提供了 MeasureSpec 类来实现模式和数值的提取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MeasureSpec.getMode(int spec)  // 获取模式</div><div class="line">MeasureSpec.getSize(int spec)  // 获取数值</div></pre></td></tr></table></figure></p><p>另外，模式的取值为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MeasureSpec.UNSPECIFIED</div><div class="line">MeasureSpec.EXACTLY</div><div class="line">MeasureSpec.AT_MOST</div></pre></td></tr></table></figure></p><p>实际运用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">    super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">    int measureWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">    int measureHeight = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">    int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">    int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"></div><div class="line">    // 计算过程</div><div class="line">    ...</div><div class="line"></div><div class="line">    setMeasuredDimension((measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth : width,</div><div class="line">            (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight : height);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><div id="jump3"></div></p><h3 id="12-2-3-onLayout-函数"><a href="#12-2-3-onLayout-函数" class="headerlink" title="12.2.3 onLayout() 函数"></a>12.2.3 onLayout() 函数</h3><p>onLayout() 是实现所有子控件布局的函数。那关于它自己的布局怎么办呢？是在父控件中由它的父控件完成的。就这样一层一层地向上由各自的父控件完成对自己的布局，直到所有控件的顶层节点。在所有的控件的顶部有一个 ViewRoot，它才是所有控件的祖先节点。</p><p>ViewRoot 使用 setFrame(l, t, r, b) 函数中设置自己的位置，设置结束以后才会调用 onLayout(changed, l, t, r, b) 函数来设置内部所有子控件的位置。</p><p>示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-20a27ee32d8e2121.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public class MyLinLayout extends ViewGroup &#123;</div><div class="line"></div><div class="line">    public MyLinLayout(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">        int measureWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        int measureHeight = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">        int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">        int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"></div><div class="line">        int height = 0;</div><div class="line">        int width = 0;</div><div class="line">        int count = getChildCount();</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            // 测量子控件</div><div class="line">            View child = getChildAt(i);</div><div class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">            // 获得子控件的宽高</div><div class="line">            int childWidth = child.getMeasuredWidth();</div><div class="line">            int childHeight = child.getMeasuredHeight();</div><div class="line">            // 得到最大宽度，并且累加高度</div><div class="line">            height += childHeight;</div><div class="line">            width = Math.max(childWidth, width);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setMeasuredDimension((measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth : width,</div><div class="line">                (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight : height);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">        int top = 0;</div><div class="line">        int count = getChildCount();</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            View child = getChildAt(i);</div><div class="line">            int childWidth = child.getMeasuredWidth();</div><div class="line">            int childHeight = child.getMeasuredHeight();</div><div class="line"></div><div class="line">            child.layout(0, top, childWidth, top + childHeight);</div><div class="line">            top += childHeight;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>res/layout/act_main.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;com.xxt.xtest.MyLinLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:background=&quot;#FF00FF&quot;&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;first view&quot;</div><div class="line">        android:background=&quot;#FF0000&quot;/&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;second view&quot;</div><div class="line">        android:background=&quot;#00FF00&quot;/&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;third view&quot;</div><div class="line">        android:background=&quot;#0000FF&quot;/&gt;</div><div class="line">&lt;/com.xxt.xtest.MyLinLayout&gt;</div></pre></td></tr></table></figure></p><blockquote><p>注意：getMeasuredWidth() 与 getWidth() 获得的值大部分时候是相同的，但含义却是根本不一样的。前者是在 measure() 过程结束后就可以获取到宽度值，而后者是要在 layout() 过程结束后才能获取到宽度值；前者的值是通过 setMeasuredDimension() 函数来进行设置的，而后者的值是通过 layout(left, top, right, bottom) 函数来进行设置的。</p></blockquote><p><div id="jump4"></div></p><h3 id="12-2-4-获取子控件-margin-值的方法"><a href="#12-2-4-获取子控件-margin-值的方法" class="headerlink" title="12.2.4 获取子控件 margin 值的方法"></a>12.2.4 获取子控件 margin 值的方法</h3><h4 id="1-获取方法及示例"><a href="#1-获取方法及示例" class="headerlink" title="1. 获取方法及示例"></a>1. 获取方法及示例</h4><p>在上面 MyLinLayout 例子的基础上，添加 layout_margin 参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;com.xxt.xtest.MyLinLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;wrap_content&quot;</div><div class="line">    android:background=&quot;#FF00FF&quot;&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_marginTop=&quot;10dp&quot;</div><div class="line">        android:text=&quot;first view&quot;</div><div class="line">        android:background=&quot;#FF0000&quot;/&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_marginTop=&quot;20dp&quot;</div><div class="line">        android:text=&quot;second view&quot;</div><div class="line">        android:background=&quot;#00FF00&quot;/&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_marginTop=&quot;30dp&quot;</div><div class="line">        android:text=&quot;third view&quot;</div><div class="line">        android:background=&quot;#0000FF&quot;/&gt;</div><div class="line">&lt;/com.xxt.xtest.MyLinLayout&gt;</div></pre></td></tr></table></figure></p><p>重写 generateLayoutParams() 和 generateDefaultLayoutParams()，返回对应的 MarginLayoutParams() 函数的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected LayoutParams generateLayoutParams(LayoutParams p) &#123;</div><div class="line">    return new MarginLayoutParams(p);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public LayoutParams generateLayoutParams(AttributeSet attrs) &#123;</div><div class="line">    return new MarginLayoutParams(getContext(), attrs);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">protected LayoutParams generateDefaultLayoutParams() &#123;</div><div class="line">    return new MarginLayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>重写 onMeasure() 和 onLayout() 函数，修正获取子控件的宽高逻辑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">    View child = getChildAt(i);</div><div class="line">    // 获得子控件的宽高</div><div class="line">    MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">    int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;</div><div class="line">    int childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>最终效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4a0a7e96f37e4116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>完整代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">public class MyLinLayout extends ViewGroup &#123;</div><div class="line"></div><div class="line">    public MyLinLayout(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">        int measureWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        int measureHeight = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">        int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">        int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"></div><div class="line">        int height = 0;</div><div class="line">        int width = 0;</div><div class="line">        int count = getChildCount();</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            // 测量子控件</div><div class="line">            View child = getChildAt(i);</div><div class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">            // 获得子控件的宽高</div><div class="line">            MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">            int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;</div><div class="line">            int childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;</div><div class="line">            // 得到最大宽度，并且累加高度</div><div class="line">            height += childHeight;</div><div class="line">            width = Math.max(childWidth, width);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setMeasuredDimension((measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth : width,</div><div class="line">                (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight : height);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">        int top = 0;</div><div class="line">        int count = getChildCount();</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            View child = getChildAt(i);</div><div class="line">            // 获得子控件的宽高</div><div class="line">            MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">            int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;</div><div class="line">            int childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;</div><div class="line"></div><div class="line">            child.layout(0, top, childWidth, top + childHeight);</div><div class="line">            top += childHeight;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected LayoutParams generateLayoutParams(LayoutParams p) &#123;</div><div class="line">        return new MarginLayoutParams(p);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public LayoutParams generateLayoutParams(AttributeSet attrs) &#123;</div><div class="line">        return new MarginLayoutParams(getContext(), attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected LayoutParams generateDefaultLayoutParams() &#123;</div><div class="line">        return new MarginLayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h4><p>在 container 中初始化子控件时，会调用 LayoutParams generateLayoutParams(LayoutParams p) 函数来为子控件生成对应的布局属性，但默认只生成 layout_width 和 layout_height 所对应的布局参数，即在正常情况下调用 generateLayoutParams() 函数生成的 LayoutParams 实例是不能获取到 margin 值的。所以，如我我们还需要与 margin 相关的参数，就只能重写 generateLayoutParams() 函数，返回派生自 LayoutParams 的子类 MarginLayoutParams，根据类的多态性，可以直接将其强转成 MarginLayoutParams 实例。为了安全起见，也可以利用 instanceof 来进行判断。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;div id=&quot;jump1&quot;&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h3 id=&quot;12-2-1-ViewGroup-绘制流程&quot;&gt;&lt;a href=&quot;#12-2-1-ViewGroup-绘制流程&quot; 
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>12.1 精通自定义 View 之封装控件——自定义属性与自定义 Style</title>
    <link href="http://yoursite.com/2019/07/12/Custom%20View/12.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%20Style/"/>
    <id>http://yoursite.com/2019/07/12/Custom View/12.1 精通自定义 View 之封装控件——自定义属性与自定义 Style/</id>
    <published>2019-07-11T17:00:00.000Z</published>
    <updated>2019-11-01T03:42:45.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><div id="jump1"></div></p><h3 id="12-1-1-示例"><a href="#12-1-1-示例" class="headerlink" title="12.1.1 示例"></a>12.1.1 示例</h3><h4 id="1-自定义-Style-和属性"><a href="#1-自定义-Style-和属性" class="headerlink" title="1. 自定义 Style 和属性"></a>1. 自定义 Style 和属性</h4><p>1）自定义一个类 MyTextView<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class MyTextView extends AppCompatTextView &#123;</div><div class="line">    public MyTextView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public MyTextView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public MyTextView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>2）新建 res/values/attrs.xml 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">    &lt;declare-styleable name=&quot;MyTextView&quot;&gt;</div><div class="line">        &lt;attr name=&quot;header&quot; format=&quot;reference&quot;/&gt;</div><div class="line">        &lt;attr name=&quot;headerHeight&quot; format=&quot;dimension&quot;/&gt;</div><div class="line">        &lt;attr name=&quot;headerVisibleHeight&quot; format=&quot;dimension&quot;/&gt;</div><div class="line">        &lt;attr name=&quot;age&quot;&gt;</div><div class="line">            &lt;flag name=&quot;child&quot; value=&quot;10&quot;/&gt;</div><div class="line">            &lt;flag name=&quot;young&quot; value=&quot;18&quot;/&gt;</div><div class="line">            &lt;flag name=&quot;old&quot; value=&quot;60&quot;/&gt;</div><div class="line">        &lt;/attr&gt;</div><div class="line">    &lt;/declare-styleable&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure></p><ul><li>reference 指的是从 string.xml、drawable.xml、color.xml 等文件中引用过来的值。</li><li>flag 是自己定义的，类似于 android:gravity=”top”。</li><li>dimension 指的是从 dimensions.xml 文件中引用过来的值。注意，这里如果是 dp，就会进行像素转换。</li></ul><blockquote><p>注意：declare-styleable 的 name 值对应所定义的类名。自定义属性值可以组合使用。比如 <attr name="border_color" format="color | reference"> 表示既可以自定义 color 值 (比如 #ff00ff)，也可以利用 @color/xxx 来引用 colors.xml 中已有的值。</attr></p></blockquote><p><div id="jump2"></div></p><h3 id="12-1-2-在-XML-中使用自定义的属性"><a href="#12-1-2-在-XML-中使用自定义的属性" class="headerlink" title="12.1.2 在 XML 中使用自定义的属性"></a>12.1.2 在 XML 中使用自定义的属性</h3><p>res/layout/act_main.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:attrstest=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line">    &lt;com.xxt.xtest.MyTextView</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        attrstest:header=&quot;@drawable/head&quot;</div><div class="line">        attrstest:headerHeight=&quot;300dp&quot;</div><div class="line">        attrstest:headerVisibleHeight=&quot;100dp&quot;</div><div class="line">        attrstest:age=&quot;young&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>下面代码是导入自定义的属性集，使 XML 能识别我们自定义的属性。attrstest 是自定义的，可随意定义为 xxx，对应的访问自定义控件的方式就是 xxx:headerHeight=”300dp”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xmlns:attrstest=&quot;http://schemas.android.com/apk/res-auto&quot;</div></pre></td></tr></table></figure></p><p><div id="jump3"></div></p><h3 id="12-1-3-在代码中获取自定义属性的值"><a href="#12-1-3-在代码中获取自定义属性的值" class="headerlink" title="12.1.3 在代码中获取自定义属性的值"></a>12.1.3 在代码中获取自定义属性的值</h3><p>使用代码获取用户所定义的某个属性的值，主要使用 TypedArray 类，这个类提供了获取某个属性值的所有方法，如下所示。需要注意的是，在使用完以后必须调用 TypedArray 类的 recycle() 函数来释放资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">typedArray.getInt(int index, float defValue)</div><div class="line">typedArray.getDimension(int index, float defValue)</div><div class="line">typedArray.getBoolean(int index, float defValue)</div><div class="line">typedArray.getColor(int index, float defValue)</div><div class="line">typedArray.getString(int index)</div><div class="line">typedArray.getDrawable(int index)</div><div class="line">typedArray.getResources()</div><div class="line"></div><div class="line">typedArray.recycle()</div></pre></td></tr></table></figure></p><p>使用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class MyTextView extends AppCompatTextView &#123;</div><div class="line"></div><div class="line">    public MyTextView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MyTextView);</div><div class="line">        float headerHeight = typedArray.getDimension(R.styleable.MyTextView_headerHeight, -1);</div><div class="line">        int age = typedArray.getInt(R.styleable.MyTextView_age, -1);</div><div class="line">        Drawable drawable = typedArray.getDrawable(R.styleable.MyTextView_header);</div><div class="line">        typedArray.recycle();</div><div class="line">        String text = &quot;headerHeight:&quot; + headerHeight + &quot; age:&quot; + age;</div><div class="line">        this.setText(text);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0460193d30e7a4eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><div id="jump4"></div></p><h3 id="12-1-4-declare-styleable-标签其他属性的用法"><a href="#12-1-4-declare-styleable-标签其他属性的用法" class="headerlink" title="12.1.4 declare-styleable 标签其他属性的用法"></a>12.1.4 declare-styleable 标签其他属性的用法</h3><h4 id="1-reference：参考某一资源-ID"><a href="#1-reference：参考某一资源-ID" class="headerlink" title="1. reference：参考某一资源 ID"></a>1. reference：参考某一资源 ID</h4><p>属性定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name=&quot;名称&quot;&gt;</div><div class="line">    &lt;attr name=&quot;background&quot; format=&quot;reference&quot;/&gt;</div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure></p><p>属性使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;ImageView</div><div class="line">    android:layout_width=&quot;42dip&quot;</div><div class="line">    android:layout_height=&quot;42dip&quot;</div><div class="line">    android:background=&quot;@drawable/图片 ID&quot;/&gt;</div></pre></td></tr></table></figure></p><h4 id="2-color：颜色值"><a href="#2-color：颜色值" class="headerlink" title="2. color：颜色值"></a>2. color：颜色值</h4><p>属性定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name=&quot;名称&quot;&gt;</div><div class="line">    &lt;attr name=&quot;textColor&quot; format=&quot;color&quot;/&gt;</div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure></p><p>属性使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;TextView</div><div class="line">    android:layout_width=&quot;42dip&quot;</div><div class="line">    android:layout_height=&quot;42dip&quot;</div><div class="line">    android:textColor=&quot;#00FF00&quot;/&gt;</div></pre></td></tr></table></figure></p><h4 id="3-boolean：布尔值"><a href="#3-boolean：布尔值" class="headerlink" title="3. boolean：布尔值"></a>3. boolean：布尔值</h4><p>属性定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name=&quot;名称&quot;&gt;</div><div class="line">    &lt;attr name=&quot;focusable&quot; format=&quot;boolean&quot;/&gt;</div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure></p><p>属性使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Button</div><div class="line">    android:layout_width=&quot;42dip&quot;</div><div class="line">    android:layout_height=&quot;42dip&quot;</div><div class="line">    android:focusable=&quot;true&quot;/&gt;</div></pre></td></tr></table></figure></p><h4 id="4-dimension：尺寸值"><a href="#4-dimension：尺寸值" class="headerlink" title="4. dimension：尺寸值"></a>4. dimension：尺寸值</h4><p>属性定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name=&quot;名称&quot;&gt;</div><div class="line">    &lt;attr name=&quot;layout_width&quot; format=&quot;dimension&quot;/&gt;</div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure></p><p>属性使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Button</div><div class="line">    android:layout_width=&quot;42dip&quot;</div><div class="line">    android:layout_height=&quot;42dip&quot;/&gt;</div></pre></td></tr></table></figure></p><h4 id="5-float：浮点值"><a href="#5-float：浮点值" class="headerlink" title="5. float：浮点值"></a>5. float：浮点值</h4><p>属性定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name=&quot;AlphaAnimation&quot;&gt;</div><div class="line">    &lt;attr name=&quot;fromAlpha&quot; format=&quot;float&quot;/&gt;</div><div class="line">    &lt;attr name=&quot;toAlpha&quot; format=&quot;float&quot;/&gt;</div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure></p><p>属性使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Alpha</div><div class="line">    android:fromAlpha=&quot;1.0&quot;</div><div class="line">    android:toAlpha=&quot;0.7&quot;/&gt;</div></pre></td></tr></table></figure></p><h4 id="6-integer：整型值"><a href="#6-integer：整型值" class="headerlink" title="6. integer：整型值"></a>6. integer：整型值</h4><p>属性定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name=&quot;AnimatedRotateDrawable&quot;&gt;</div><div class="line">    &lt;attr name=&quot;visible&quot;/&gt;</div><div class="line">    &lt;attr name=&quot;frameDuration&quot; format=&quot;integer&quot;/&gt;</div><div class="line">    &lt;attr name=&quot;framesCount&quot; format=&quot;integer&quot;/&gt;</div><div class="line">    &lt;attr name=&quot;pivotX&quot;/&gt;</div><div class="line">    &lt;attr name=&quot;pivotY&quot;/&gt;</div><div class="line">    &lt;attr name=&quot;drawable&quot;/&gt;</div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure></p><p>属性使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;animated-rotate</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:drawable=&quot;@drawable/图片 ID&quot;</div><div class="line">    android:pivotX=&quot;50%&quot;</div><div class="line">    android:pivotY=&quot;50%&quot;</div><div class="line">    android:framesCount=&quot;12&quot;</div><div class="line">    android:frameDuration=&quot;100&quot;/&gt;</div></pre></td></tr></table></figure></p><h4 id="7-string：字符串"><a href="#7-string：字符串" class="headerlink" title="7. string：字符串"></a>7. string：字符串</h4><p>属性定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name=&quot;MapView&quot;&gt;</div><div class="line">    &lt;attr name=&quot;apiKey&quot; format=&quot;string&quot;/&gt;</div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure></p><p>属性使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;com.google.android.maps.MapView</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:apiKey=&quot;FJA802hFS01jhFDA9oAFAoFJAFDA9oAFAo&quot;/&gt;</div></pre></td></tr></table></figure></p><h4 id="8-fraction：百分数"><a href="#8-fraction：百分数" class="headerlink" title="8. fraction：百分数"></a>8. fraction：百分数</h4><p>属性定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name=&quot;RotateDrawable&quot;&gt;</div><div class="line">    &lt;attr name=&quot;visible&quot;/&gt;</div><div class="line">    &lt;attr name=&quot;fromDegrees&quot; format=&quot;float&quot;/&gt;</div><div class="line">    &lt;attr name=&quot;toDegrees&quot; format=&quot;float&quot;/&gt;</div><div class="line">    &lt;attr name=&quot;pivotX&quot; format=&quot;fraction&quot;/&gt;</div><div class="line">    &lt;attr name=&quot;pivotY&quot; format=&quot;fraction&quot;/&gt;</div><div class="line">    &lt;attr name=&quot;drawable&quot;/&gt;</div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure></p><p>属性使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;rotate</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:interpolator=&quot;@anim/动画 ID&quot;</div><div class="line">    android:fromDegrees=&quot;0&quot;</div><div class="line">    android:toDegrees=&quot;360&quot;</div><div class="line">    android:pivotX=&quot;200%&quot;</div><div class="line">    android:pivotY=&quot;300%&quot;</div><div class="line">    android:duration=&quot;5000&quot;</div><div class="line">    android:repeatMode=&quot;restart&quot;</div><div class="line">    android:repeatCount=&quot;infinite&quot;/&gt;</div></pre></td></tr></table></figure></p><h4 id="9-enum：枚举值"><a href="#9-enum：枚举值" class="headerlink" title="9. enum：枚举值"></a>9. enum：枚举值</h4><p>属性定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name=&quot;名称&quot;&gt;</div><div class="line">    &lt;attr name=&quot;orientation&quot;&gt;</div><div class="line">        &lt;enum name=&quot;horizontal&quot; value=&quot;0&quot;/&gt;</div><div class="line">        &lt;enum name=&quot;vertical&quot; value=&quot;1&quot;/&gt;</div><div class="line">    &lt;/attr&gt;</div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure></p><p>属性使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><h4 id="10-flag：位或运算"><a href="#10-flag：位或运算" class="headerlink" title="10. flag：位或运算"></a>10. flag：位或运算</h4><p>属性定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name=&quot;名称&quot;&gt;</div><div class="line">    &lt;attr name=&quot;windowSoftInputMode&quot;&gt;</div><div class="line">        &lt;flag name=&quot;stateUnspecified&quot; value=&quot;0&quot;/&gt;</div><div class="line">        &lt;flag name=&quot;stateUnchanged&quot; value=&quot;1&quot;/&gt;</div><div class="line">        &lt;flag name=&quot;stateHidden&quot; value=&quot;2&quot;/&gt;</div><div class="line">        &lt;flag name=&quot;stateAlwaysHidden&quot; value=&quot;3&quot;/&gt;</div><div class="line">        &lt;flag name=&quot;stateVisible&quot; value=&quot;4&quot;/&gt;</div><div class="line">        &lt;flag name=&quot;stateAlwaysVisible&quot; value=&quot;5&quot;/&gt;</div><div class="line">        &lt;flag name=&quot;adjustUnspecified&quot; value=&quot;0x00&quot;/&gt;</div><div class="line">        &lt;flag name=&quot;adjustResize&quot; value=&quot;0x10&quot;/&gt;</div><div class="line">        &lt;flag name=&quot;adjustPan&quot; value=&quot;0x20&quot;/&gt;</div><div class="line">        &lt;flag name=&quot;adjustNothing&quot; value=&quot;0x30&quot;/&gt;</div><div class="line">    &lt;/attr&gt;</div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure></p><p>属性使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;Activity</div><div class="line">    android:name=&quot;.StyleAndThemeActivity&quot;</div><div class="line">    android:label=&quot;@string/app_name&quot;</div><div class="line">    android:windowSoftInputMode=&quot;stateUnspecified | stateUnchanged | stateHidden&quot;&gt;</div><div class="line">    &lt;intent-filter&gt;</div><div class="line">        &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;</div><div class="line">        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;</div><div class="line">    &lt;/intent-filter&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><blockquote><p>特别注意：属性在定义时可以指定多种类型的值。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name=&quot;名称&quot;&gt;</div><div class="line">    &lt;attr name=&quot;background&quot; format=&quot;reference|color&quot;/&gt;</div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;div id=&quot;jump1&quot;&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h3 id=&quot;12-1-1-示例&quot;&gt;&lt;a href=&quot;#12-1-1-示例&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>11.2 精通自定义 View 之 Matrix 与坐标变换——ColorMatrix 色彩变换</title>
    <link href="http://yoursite.com/2019/07/11/Custom%20View/11.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94ColorMatrix%20%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2/"/>
    <id>http://yoursite.com/2019/07/11/Custom View/11.2 精通自定义 View 之 Matrix 与坐标变换——ColorMatrix 色彩变换/</id>
    <published>2019-07-10T18:00:00.000Z</published>
    <updated>2019-10-22T08:20:35.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><div id="jump1"></div></p><h3 id="11-2-1-色彩变换矩阵"><a href="#11-2-1-色彩变换矩阵" class="headerlink" title="11.2.1 色彩变换矩阵"></a>11.2.1 色彩变换矩阵</h3><p>对于色彩的存储，Bitmap 类使用一个 32 位的数值来保存，红、绿、蓝及透明度各占 8 位，每个色彩分量的取值范围是 0~255。透明度为 0 表示完全透明，为 255 时色彩完全可见。</p><h4 id="1-色彩信息的矩阵表示"><a href="#1-色彩信息的矩阵表示" class="headerlink" title="1. 色彩信息的矩阵表示"></a>1. 色彩信息的矩阵表示</h4><p>由于一个色彩信息包含 R、G、B、Alpha 信息,所以,我们必然要使用一个四阶色彩变 换矩阵来修改色彩的每一个分量值。<br>$$ \left[ \begin{matrix} Red &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; Green &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; Blue &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; Alpha \end{matrix} \right]$$</p><blockquote><p>注意:对于色彩变换矩阵，这里的色彩顺序是 R、G、B、A，而不是 A、R、G、B。</p></blockquote><p>如果想将色彩 (0,255,0,255) 更改为半透明，则可以使用下面的矩阵运算来表示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-65968173a9ff1c69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上面使用四阶矩阵完全可以改变图片的 RGBA 值，但考虑一种情况：如果我们只想在原有的 R 色上增加一些分量呢?</p><p>这时，我们就得再多加一阶来表示平移变换。所，一个既包含线性变换又包含平移变换的组合变换称为仿射变换。使用四阶色彩变换矩阵来修改色彩，只能对色彩的每个分量值进行乘(除)运算。如果要对这些分量值进行加减法运算(平移变换)，则只能通过五阶矩阵来完成。</p><p>考虑下面这个变换：<br>1）红色分量值更改为原来的 2 倍。<br>2）绿色分量值增加 100。</p><p>这个变换使用四阶矩阵的乘法无法实现。所以，应该在四阶色彩变换矩阵上增加一个“哑元坐标”，来实现所列的矩阵运算。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-53ad1961066a0714.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在这个矩阵中，分量值用的是 100。</p><h4 id="2-Android-中的色彩变换矩阵"><a href="#2-Android-中的色彩变换矩阵" class="headerlink" title="2. Android 中的色彩变换矩阵"></a>2. Android 中的色彩变换矩阵</h4><p>在 Android 中，色彩变换矩阵的表示形式也是五阶的。所以，在默认情况下，色彩变换矩阵的形式如下:<br>$$ \left[ \begin{matrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0\end{matrix} \right]$$</p><p>Android 中的色彩变换矩阵是用 ColorMatrix 类来表示的。使用 ColorMatrix 类的方法如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123;</div><div class="line">       1, 0, 0, 0, 0,</div><div class="line">       0, 1, 0, 0, 0,</div><div class="line">       0, 0, 1, 0, 0,</div><div class="line">       0, 0, 0, 0.5, 0,</div><div class="line">&#125;);</div><div class="line">mPaint.setColorFilter(new ColorMatrixColorFilter(colorMatrix));</div></pre></td></tr></table></figure></p><p>有关 setColorFilter() 函数的其他用法，将在本节末尾详细讲解。</p><h4 id="3-示例：彩色图片的蓝色通道输出"><a href="#3-示例：彩色图片的蓝色通道输出" class="headerlink" title="3. 示例：彩色图片的蓝色通道输出"></a>3. 示例：彩色图片的蓝色通道输出</h4><p>下面以为 Bitmap 应用 ColorMatrix 类为例,代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line">    private Paint mPaint = new Paint();</div><div class="line">    private Bitmap bitmap;  // 位图</div><div class="line">    private Rect rect;</div><div class="line">    private ColorMatrixColorFilter colorMatrixColorFilter;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint.setAntiAlias(true);</div><div class="line">        // 获取位图</div><div class="line">        bitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.dog);</div><div class="line">        rect = new Rect();</div><div class="line">        // 生成色彩变换矩阵</div><div class="line">        ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123;</div><div class="line">                0, 0, 0, 0, 0,</div><div class="line">                0, 0, 0, 0, 0,</div><div class="line">                0, 0, 1, 0, 0,</div><div class="line">                0, 0, 0, 1, 0,</div><div class="line">        &#125;);</div><div class="line">        colorMatrixColorFilter = new ColorMatrixColorFilter(colorMatrix);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        rect.set(0, 0, 500, 500 * bitmap.getHeight() / bitmap.getWidth());</div><div class="line">        // 绘制原始位图</div><div class="line">        canvas.drawBitmap(bitmap, null, rect, mPaint);</div><div class="line">        canvas.translate(510, 0);</div><div class="line"></div><div class="line">        mPaint.setColorFilter(colorMatrixColorFilter);</div><div class="line">        canvas.drawBitmap(bitmap, null, rect, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里分两次绘制了一个 Bitmap，先绘制了一个原始图像,然后利用 ColorMatrix 类生成了 一个仅包含蓝色的图像。用过 Photoshop 的读者应该很清楚,这跟 Photoshop 中蓝色通道的效 果是一致的。效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-40bfc3d34d47dc8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><div id="jump2"></div></p><h3 id="11-2-2-色彩的几种运算方式"><a href="#11-2-2-色彩的几种运算方式" class="headerlink" title="11.2.2 色彩的几种运算方式"></a>11.2.2 色彩的几种运算方式</h3><h4 id="1-色彩的平移运算"><a href="#1-色彩的平移运算" class="headerlink" title="1. 色彩的平移运算"></a>1. 色彩的平移运算</h4><p>1）增加色彩饱和度<br>色彩的平移运算实际上就是色彩的加法运算，其实就是在色彩变换矩阵的最后一列加上某个值，这样可以增加特定色彩的饱和度。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-32174d42e4b29379.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>比如，同样是上面的图片，我们给它应用下面的色彩值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123;</div><div class="line">       1, 0, 0, 0, 0,</div><div class="line">       0, 1, 0, 0, 50,</div><div class="line">       0, 0, 1, 0, 0,</div><div class="line">       0, 0, 0, 1, 0,</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>在绿色值上添加增量 50，即增大绿色的饱和度。效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0be65968c5d44c47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>同样，左侧是原图，右侧是增大绿色饱和度后的效果。大家要特别注意的是，由于图片是由一个个像素组成的，所以用每个像素所对应的色彩数组来乘以色彩变换矩阵，结果就是变换后的当前点的颜色值。在应用 ColorMatrix 类后，图片中每个像素的绿色值都增加了 50, 从小狗的脸上也可以看出来。</p><p>2）色彩反转/反相功能<br>色彩平移除增加指定色彩的饱和度以外，另一个应用就是色彩反转，也就是 Photoshop 中的反相功能。色彩反转就是求出每个色彩的补值来作为目标图像的对应颜色值。示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123;</div><div class="line">        -1, 0, 0, 0, 255,</div><div class="line">        0, -1, 0, 0, 255,</div><div class="line">        0, 0, -1, 0, 255,</div><div class="line">        0, 0, 0, 1, 0,</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-45b981d952839f0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="2-色彩的缩放运算"><a href="#2-色彩的缩放运算" class="headerlink" title="2. 色彩的缩放运算"></a>2. 色彩的缩放运算</h4><p>1）调节亮度<br>色彩的缩放运算其实就是色彩的乘法运算。将色彩变换矩阵对角线上分别代表 R、G、B、 A 的几个值分别乘以指定的值，就是所谓的缩放运算，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-bd12812a0945e1a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>我们可以针对某个颜色值进行放大/缩小运算。但是当对 R、G、B、A 同时进行放大/缩小运算时，就是对亮度进行调节。</p><p>看下面将亮度增大 1.2 倍的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123;</div><div class="line">        1.2f, 0, 0, 0, 0,</div><div class="line">        0, 1.2f, 0, 0, 0,</div><div class="line">        0, 0, 1.2f, 0, 0,</div><div class="line">        0, 0, 0, 1, 0,</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-89be53a5c44e1d14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>2）通道输出<br>由于在色彩变换矩阵中对角线上的数的取值范围为 0~1，所以，当取 0 时，这个色彩就完全不显示；当 R、G 都取 0，而独有 B 取 1 时,就只显示蓝色，所形成的图像也就是我们通常所说的蓝色通道。看一下几个通道输出的效果图，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b3ba32645756773a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 红色通道矩阵</div><div class="line">ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123;</div><div class="line">        1, 0, 0, 0, 0,</div><div class="line">        0, 0, 0, 0, 0,</div><div class="line">        0, 0, 0, 0, 0,</div><div class="line">        0, 0, 0, 1, 0,</div><div class="line">&#125;);</div><div class="line">// 绿色通道矩阵</div><div class="line">ColorMatrix colorMatrix2 = new ColorMatrix(new float[]&#123;</div><div class="line">        0, 0, 0, 0, 0,</div><div class="line">        0, 1, 0, 0, 0,</div><div class="line">        0, 0, 0, 0, 0,</div><div class="line">        0, 0, 0, 1, 0,</div><div class="line">&#125;);</div><div class="line">// 蓝色通道矩阵</div><div class="line">ColorMatrix colorMatrix3 = new ColorMatrix(new float[]&#123;</div><div class="line">        0, 0, 0, 0, 0,</div><div class="line">        0, 0, 0, 0, 0,</div><div class="line">        0, 0, 1, 0, 0,</div><div class="line">        0, 0, 0, 1, 0,</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h4 id="3-色彩的旋转运算"><a href="#3-色彩的旋转运算" class="headerlink" title="3. 色彩的旋转运算"></a>3. 色彩的旋转运算</h4><p>RGB 色是如何旋转的呢？首先用 R、G、B 三色建立立体坐标系，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-48b458e1e54db702.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>所以，我们可以把一个色彩值看成三维空间里的一个点，色彩值的三个分量可以看成该点的坐标(三维坐标)。我们先不考虑在三个维度综合情况下是怎么旋转的，来看看将某个轴作为 Z 轴，在另外两个轴形成的平面上旋转的情况。下图分析了将蓝色轴作为 Z 轴，仅在红 — 绿平面上旋转 a 度的情况。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d71bec3124ade35c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到，在旋转后，原 R 在 R 轴上的分量变为原 Rxcosa，原 G 在 R 轴上也有了分量，但分量落在了负轴上，所以要减去这部分分量，最终的结果是最终的 R=原 R×cosa-原 G×sina。 下面来看一下几种旋转计算及结果矩阵(注意：这几张图只标记了原 X 轴色彩分量的旋转，没有把 Y 轴色彩分量的旋转标记出来)。</p><p>1）绕蓝色轴旋转 θ 度</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-16150536456eb83f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对应的色彩变换矩阵如下：<br>$$ \left[ \begin{matrix} cosθ &amp; sinθ &amp; 0 &amp; 0 &amp; 0\ -sinθ &amp; cosθ &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\end{matrix} \right]$$</p><p>2）绕红色轴旋转 θ 度</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ff2dadf5ca618b87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对应的色彩变换矩阵如下：<br>$$ \left[ \begin{matrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; cosθ &amp; sinθ &amp; 0 &amp; 0\ 0 &amp; -sinθ &amp; cosθ &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\end{matrix} \right]$$</p><p>3）绕绿色轴旋转 θ 度</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7dc283195247047d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对应的色彩变换矩阵如下：<br>$$ \left[ \begin{matrix} cosθ &amp; 0 &amp; -sinθ &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0\ sinθ &amp; 0 &amp; cosθ &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\end{matrix} \right]$$</p><p>当围绕红色轴进行色彩旋转时，由于当前红色轴的色彩是不变的,而仅利用三角函数来动态变更绿色和蓝色的颜色值，这种改变就叫作色相调节。当围绕红色轴旋转时，是对图片进行红色色相的调节；当围绕蓝色轴旋转时，是对图片进行蓝色色相的调节；当围绕绿色轴旋转时，是对图片进行绿色色相的调节。</p><p>下面我们会再次讲到 ColorMatrix 的色彩旋转函数，这里先理解原理，代码和效果后面会给出。</p><h4 id="4-色彩的投射运算"><a href="#4-色彩的投射运算" class="headerlink" title="4. 色彩的投射运算"></a>4. 色彩的投射运算</h4><p>我们再回过头来看看色彩变换矩阵运算的公式，如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-06dc50244970cb7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在上式中，把红色运算单独标记出来。在运算中，它们就是利用 G、B、A 的颜色值的分量来增加红色值的。</p><p>来看具体的运算：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-9c329370c6741f14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>注意：最终结果的 220=0.2×100+1×200，可见绿色分量在原有绿色分量的基础上增加了红色分量值的 0.2 倍。利用其他色彩分量的倍数来更改自己色彩分量的值，这种运算就叫作投射运算。</p></blockquote><p>在对下图中阴影部分的值进行修改时，所使用的增加值来自其他色彩分量的信息。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2ab0e18e38b1a69d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>应用一：黑白图片</strong><br>色彩投射的一个最简单的应用就是将彩色图片变为黑白图片。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123;</div><div class="line">        0.213f, 0.715f, 0.072f, 0, 0,</div><div class="line">        0.213f, 0.715f, 0.072f, 0, 0,</div><div class="line">        0.213f, 0.715f, 0.072f, 0, 0,</div><div class="line">        0, 0, 0, 1, 0,</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4432b05b5b2d8427.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>首先了解一下去色原理：只要把 R、G、B 三通道的色彩信息设置成一样，即 R=G=B，图像就变成了灰色。并且，为了保证图像亮度不变，同一个通道中的 R+G+B=1，如 0.213+0.715+0.072=1。</p><p>下面谈一下 0.213、0.715、0.072 这三个数字的由来。</p><p>按理说应该把 R、G、B 平分，都是 0.3333333。三个数字应该是根据色彩光波频率及色彩心理学计算出来的。</p><p>在作用于人眼的光线中，彩色光要明显强于无色光。如果对一张图像按 RGB 平分理论给图像去色，人眼就会明显感觉到图像变暗了(当然可能有心理上的原因，也有光波的科学依据)。另外，在彩色图像中能够识别的一些细节也可能会丢失。</p><p>所以 Google 最终给出的颜色值就是上面的三个数字：0.213、0.715、0.072。我们在给图像去色时保留了大量的 G 通道信息，使得图像不至于变暗或者绿色信息不至于丢失。</p><p><strong>应用二：色彩反色</strong><br>利用色彩变换矩阵将两个颜色反转，这种操作就叫作色彩反色。比如，将红色和绿色反色(红绿反色)，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123;</div><div class="line">        0, 1, 0, 0, 0,</div><div class="line">        1, 0, 0, 0, 0,</div><div class="line">        0, 0, 1, 0, 0,</div><div class="line">        0, 0, 0, 1, 0,</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-56ec63b6df2ee7eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>左侧为原图，右侧为红绿反色以后的效果图。</p><p>从色彩变换矩阵中可以看出，红绿反色的关键在于，第一行用绿色来代替红色，第二行用红色来代替绿色。类似的可以有红蓝反色、绿蓝反色等，对应矩阵难度不大，就不再细讲了。</p><p><strong>应用三：照片变旧</strong><br>投射运算的另一个应用是照片变旧，其对应的矩阵如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123;</div><div class="line">        1/2f, 1/2f, 1/2f, 0, 0,</div><div class="line">        1/3f, 1/3f, 1/3f, 0, 0,</div><div class="line">        1/4f, 1/4f, 1/4f, 0, 0,</div><div class="line">        0, 0, 0, 1, 0,</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-554ef9bc51e003f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><div id="jump3"></div></p><h3 id="11-2-3-ColorMatrix-函数"><a href="#11-2-3-ColorMatrix-函数" class="headerlink" title="11.2.3 ColorMatrix 函数"></a>11.2.3 ColorMatrix 函数</h3><p>上一小节讲述了利用色彩变换矩阵来进行的一些运算，但这些都是需要特定的色彩设计基础的。在 Android 中，ColorMatrix 自带一些函数，用来帮助我们完成调整饱和度、色彩旋转等操作。</p><h4 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1. 构造函数"></a>1. 构造函数</h4><p>ColorMatrix 共有三个构造函数，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ColorMatrix()</div><div class="line">ColorMatrix(float[] src)</div><div class="line">ColorMatrix(ColorMatrix src)</div></pre></td></tr></table></figure></p><p>在这三个构造函数中，我们已经使用过第二个构造函数；至于第三个构造函数，就是利用另一个 ColorMatrix 实例来复制一个一样的 ColorMatrix 对象。</p><h4 id="2-设置和重置函数"><a href="#2-设置和重置函数" class="headerlink" title="2. 设置和重置函数"></a>2. 设置和重置函数</h4><p>第一个构造函数 ColorMatrix() 需要与其他函数共用才行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void set(ColorMatrix src)</div><div class="line">public void set(float[] src)</div><div class="line">public void reset()</div></pre></td></tr></table></figure></p><p>上面的函数是设置和重置函数，重置后，对应的数组如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Set this colormatrix to identity: </div><div class="line"> * [ 1 0 0 0 0   -redvector</div><div class="line"> *   0 1 0 0 0   -greenvector</div><div class="line"> *   0 0 1 0 0   -bluevector</div><div class="line"> *   0 0 0 1 0 ] -alphavector</div><div class="line"> */</div></pre></td></tr></table></figure></p><h4 id="3-setSaturation-函数——设置饱和度"><a href="#3-setSaturation-函数——设置饱和度" class="headerlink" title="3. setSaturation() 函数——设置饱和度"></a>3. setSaturation() 函数——设置饱和度</h4><p>我们可以通过色彩的平移运算单独增强 R、G、B 其中一个分量的饱和度，但当我们需要整体增强色彩饱和度时，需要如何来做呢？ ColorMatrix 提供了一个函数来整体增强色彩饱和度，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 整体增强色彩饱和度，即同时增强 R、G、B 的色彩饱和度 </div><div class="line">public void setSaturation(float sat)</div></pre></td></tr></table></figure></p><p>其中，参数 float sat 表示把当前色彩饱和度放大的倍数。当取值为 0 时，表示完全无色彩，即灰度图像(黑白图像)；当取值为 1 时，表示色彩不变动；;当取值大于 1 时，显示色彩过度饱和。</p><p>举个例子：滑块默认在 1 倍的位置，向左到底是 0，向右到底是 20(饱和度放大 20 倍)。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c05e54e35dba0905.gif?imageMogr2/auto-orient/strip" alt=""></p><p>布局非常简单，下面是一张图片，上面是一个 SeekBar，核心处理代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private SeekBar mSeekBar;</div><div class="line">    private ImageView mImageView;</div><div class="line">    private Bitmap mOriginBmp, mTempBmp;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        mImageView = findViewById(R.id.img);</div><div class="line">        mSeekBar = findViewById(R.id.seek_bar);</div><div class="line">        mOriginBmp = BitmapFactory.decodeResource(getResources(), R.drawable.meinv);</div><div class="line">        mTempBmp = Bitmap.createBitmap(mOriginBmp.getWidth(), mOriginBmp.getHeight(), Bitmap.Config.ARGB_8888);</div><div class="line">        mSeekBar.setMax(20);</div><div class="line">        mSeekBar.setProgress(1);</div><div class="line">        mSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123;</div><div class="line">                Bitmap bitmap = handleColorMatrixBmp(progress);</div><div class="line">                mImageView.setImageBitmap(bitmap);</div><div class="line">            &#125;</div><div class="line">            @Override</div><div class="line">            public void onStartTrackingTouch(SeekBar seekBar) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onStopTrackingTouch(SeekBar seekBar) &#123;&#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Bitmap handleColorMatrixBmp(int progress)&#123;</div><div class="line">        // 创建一个相同尺寸的可变的位图区，用于绘制调色后的图片</div><div class="line">        Canvas canvas = new Canvas(mTempBmp);</div><div class="line">        // 得到画笔对象</div><div class="line">        Paint paint = new Paint();</div><div class="line">        ColorMatrix mSaturationMatrix = new ColorMatrix();</div><div class="line">        mSaturationMatrix.setSaturation(progress);</div><div class="line">        // 设置色彩变换效果</div><div class="line">        paint.setColorFilter(new ColorMatrixColorFilter(mSaturationMatrix));</div><div class="line">        // 将色彩变换后的图片输出到新创建的位图区</div><div class="line">        canvas.drawBitmap(mOriginBmp, 0, 0, paint);</div><div class="line">        // 返回新的位图,即调色处理后的图片</div><div class="line">        return mTempBmp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>布局：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;</div><div class="line">    android:background=&quot;#EEE&quot;&gt;</div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;40dp&quot;</div><div class="line">        android:gravity=&quot;center_vertical&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;&gt;</div><div class="line">        &lt;TextView</div><div class="line">            android:layout_width=&quot;wrap_content&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:text=&quot;饱和度&quot;/&gt;</div><div class="line">        &lt;SeekBar</div><div class="line">            android:id=&quot;@+id/seek_bar&quot;</div><div class="line">            android:layout_width=&quot;match_parent&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot; /&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/img&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:src=&quot;@drawable/meinv&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><h4 id="4-setScale-函数——色彩缩放"><a href="#4-setScale-函数——色彩缩放" class="headerlink" title="4. setScale() 函数——色彩缩放"></a>4. setScale() 函数——色彩缩放</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void setScale(float rScale, float gScale, float bScale,float aScale)</div></pre></td></tr></table></figure><p>这个函数共有 4 个参数，分别对应 R、G、B、A 颜色值的缩放倍数。比如，在小狗图片中,绿色占大部分，所以我们仅将绿色放大 1.3 倍。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-94625175286b6f21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line">    private Paint mPaint = new Paint();</div><div class="line">    private Bitmap bitmap;  // 位图</div><div class="line">    private Rect rect;</div><div class="line">    private ColorMatrixColorFilter colorMatrixColorFilter;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint.setAntiAlias(true);</div><div class="line">        // 获取位图</div><div class="line">        bitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.dog);</div><div class="line">        rect = new Rect();</div><div class="line">        // 生成色彩变换矩阵</div><div class="line">        ColorMatrix colorMatrix = new ColorMatrix();</div><div class="line">        colorMatrix.setScale(1,1.3f,1,1);</div><div class="line">        colorMatrixColorFilter = new ColorMatrixColorFilter(colorMatrix);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        rect.set(0, 0, 500, 500 * bitmap.getHeight() / bitmap.getWidth());</div><div class="line">        // 绘制原始位图</div><div class="line">        canvas.drawBitmap(bitmap, null, rect, mPaint);</div><div class="line">        canvas.translate(510, 0);</div><div class="line">        mPaint.setColorFilter(colorMatrixColorFilter);</div><div class="line">        canvas.drawBitmap(bitmap, null, rect, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="5-setRotate-函数——色彩旋转"><a href="#5-setRotate-函数——色彩旋转" class="headerlink" title="5. setRotate() 函数——色彩旋转"></a>5. setRotate() 函数——色彩旋转</h4><p>上面在讲解色彩旋转运算时，列出了在色彩旋转时的效果和原理。由于涉及正、余弦函数的计算，而且这些公式推导起来具有一定的难度，所以 Android 已经封装好了色彩旋转的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 将旋转围绕某一个颜色轴进行</div><div class="line"> * axis=0 围绕红色轴旋转</div><div class="line"> * axis=1 围绕绿色轴旋转</div><div class="line"> * axis=2 围绕蓝色轴旋转</div><div class="line"> */</div><div class="line">public void setRotate(int axis, float degrees);</div></pre></td></tr></table></figure></p><ul><li>int axis：表示围绕哪个轴旋转，取值为0、1、2。当取值为 0 时，表示围绕红色轴旋转；当取值为 1 时，表示围绕绿色轴旋转；当取值为 2 时，表示围绕蓝色轴旋转。</li><li>float degrees：表示旋转的度数。</li></ul><p>同样利用上面色彩旋转的图像和滑动条的框架，来看一下当围绕某一个颜色轴旋转时色相变化的效果。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-8c23292396f0f991.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private SeekBar mSeekBar;</div><div class="line">    private ImageView mImageView;</div><div class="line">    private Bitmap mOriginBmp, mTempBmp;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        mImageView = findViewById(R.id.img);</div><div class="line">        mSeekBar = findViewById(R.id.seek_bar);</div><div class="line">        mOriginBmp = BitmapFactory.decodeResource(getResources(), R.drawable.meinv);</div><div class="line">        mTempBmp = Bitmap.createBitmap(mOriginBmp.getWidth(), mOriginBmp.getHeight(), Bitmap.Config.ARGB_8888);</div><div class="line">        mSeekBar.setMax(360);</div><div class="line">        mSeekBar.setProgress(180);</div><div class="line">        mSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123;</div><div class="line">                Bitmap bitmap = handleColorMatrixBmp(progress);</div><div class="line">                mImageView.setImageBitmap(bitmap);</div><div class="line">            &#125;</div><div class="line">            @Override</div><div class="line">            public void onStartTrackingTouch(SeekBar seekBar) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onStopTrackingTouch(SeekBar seekBar) &#123;&#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Bitmap handleColorMatrixBmp(int progress) &#123;</div><div class="line">        Canvas canvas = new Canvas(mTempBmp);</div><div class="line">        Paint paint = new Paint();</div><div class="line">        ColorMatrix colorMatrix = new ColorMatrix();</div><div class="line">        colorMatrix.setRotate(0,progress - 180);</div><div class="line">        paint.setColorFilter(new ColorMatrixColorFilter(colorMatrix));</div><div class="line">        canvas.drawBitmap(mOriginBmp, 0, 0, paint);</div><div class="line">        return mTempBmp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>将当前 progress 位置减去 180，即中间位置的数字。所以，中间位置的色彩旋转度数为 0，整个旋转度数的范围是 -180°~180°；360° 正好是正/余弦函数的一个最小正周期。</p><p>上面的效果针对的是红色色相。同理，可以得到围绕绿色轴旋转的效果图。</p><p><div id="jump4"></div></p><h3 id="11-2-4-ColorMatrix-相乘"><a href="#11-2-4-ColorMatrix-相乘" class="headerlink" title="11.2.4 ColorMatrix 相乘"></a>11.2.4 ColorMatrix 相乘</h3><p>矩阵相乘涉及三个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void setConcat(ColorMatrix matA, ColorMatrix matB)</div></pre></td></tr></table></figure></p><p>这个函数接收两个 ColorMatrix 矩阵 matA 和 matB，乘法规则为 matA×matB，然后将结果作为当前 ColorMatrix 的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void preConcat(ColorMatrix preMatrix)</div></pre></td></tr></table></figure></p><p>假设当前矩阵为 A，那么 preConcat() 函数的含义就是将当前的矩阵 A 乘以 preMatrix。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void postConcat(ColorMatrix postMatrix)</div></pre></td></tr></table></figure></p><p>postConcat() 函数的含义就是 postMatrix 乘以当前矩阵 A。</p><p>由于这部分内容基本用不到，有关这几个函数的具体应用这里就不再详细讲述，有兴趣的读者可以参考 <a href="http://blog.csdn.net/harvic880925/article/details/51187277" target="_blank" rel="external">Paint 之 ColorMatrix 与滤镜效果</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;div id=&quot;jump1&quot;&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h3 id=&quot;11-2-1-色彩变换矩阵&quot;&gt;&lt;a href=&quot;#11-2-1-色彩变换矩阵&quot; class=&quot;headerlin
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>11.1 精通自定义 View 之 Matrix 与坐标变换——矩阵运算</title>
    <link href="http://yoursite.com/2019/07/11/Custom%20View/11.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Matrix%20%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2019/07/11/Custom View/11.1 精通自定义 View 之 Matrix 与坐标变换——矩阵运算/</id>
    <published>2019-07-10T17:00:00.000Z</published>
    <updated>2019-10-22T08:19:31.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><div id="jump1"></div></p><h3 id="11-1-1-矩阵的加法和减法"><a href="#11-1-1-矩阵的加法和减法" class="headerlink" title="11.1.1 矩阵的加法和减法"></a>11.1.1 矩阵的加法和减法</h3><h4 id="1-运算规则"><a href="#1-运算规则" class="headerlink" title="1. 运算规则"></a>1. 运算规则</h4><p>$$设矩阵 A=\left[ \begin{matrix} a~11~ &amp; a~12~ &amp; \cdots &amp; a~1n~ \ a~21~ &amp; a~22~ &amp; \cdots &amp; a~2n~ \ \vdots &amp; \vdots &amp; &amp; \vdots \ a~n1~ &amp; a~n2~ &amp; \cdots &amp; a~nn~ \end{matrix} \right]$$</p><p>$$设矩阵 B=\left[ \begin{matrix} b~11~ &amp; b~12~ &amp; \cdots &amp; b~1n~ \ b~21~ &amp; b~22~ &amp; \cdots &amp; b~2n~ \ \vdots &amp; \vdots &amp; &amp; \vdots \ b~n1~ &amp; b~n2~ &amp; \cdots &amp; b~nn~ \end{matrix} \right]$$</p><p>$$则 A±B=\left[ \begin{matrix} a~11~ ± b~11~ &amp; a~12~ ± b~12~ &amp; \cdots &amp; a~1n ± ~b~1n~ \ a~21~ ± b~21~ &amp; a~22~ ± b~22~ &amp; \cdots &amp; a~2n ± ~b~2n~ \ \vdots &amp; \vdots &amp; &amp; \vdots \ a~n1~ ± b~n1~ &amp; a~n2~ ± b~n2~ &amp; \cdots &amp; a~nn ± ~b~nn~ \end{matrix} \right]$$</p><p>简而言之，两个矩阵相加减，即它们相同位置的元素相加减。</p><blockquote><p>注意：只有对于两个行数、列数分别相等的矩阵(同型矩阵)，加减法运算才有意义,即 加减法运算是可行的。</p></blockquote><h4 id="2-运算性质"><a href="#2-运算性质" class="headerlink" title="2. 运算性质"></a>2. 运算性质</h4><p>满足交换律和结合律。<br>交换律：A+B=B+A。<br>结合律：(A+B)+C= A+(B+C)。</p><p><div id="jump2"></div></p><h3 id="11-1-2-矩阵与数的乘法"><a href="#11-1-2-矩阵与数的乘法" class="headerlink" title="11.1.2 矩阵与数的乘法"></a>11.1.2 矩阵与数的乘法</h3><h4 id="1-运算规则-1"><a href="#1-运算规则-1" class="headerlink" title="1. 运算规则"></a>1. 运算规则</h4><p>数 λ 乘以矩阵 A，就是将数 λ 乘以矩阵 A 中的每一个元素，记为 λA 或 Aλ。<br>特别地，称-A 为 A=(a~ij~)~m×s~ 的负矩阵。</p><h4 id="2-运算性质-1"><a href="#2-运算性质-1" class="headerlink" title="2. 运算性质"></a>2. 运算性质</h4><p>满足结合律和分配律。<br>结合律：(λμ)A=λ(μA)；(λ+μ)A =λA+μA。<br>分配律：λ (A+B)=λA+λB。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-72a55598f7926e58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><div id="jump3"></div></p><h3 id="11-1-3-矩阵与矩阵的乘法"><a href="#11-1-3-矩阵与矩阵的乘法" class="headerlink" title="11.1.3 矩阵与矩阵的乘法"></a>11.1.3 矩阵与矩阵的乘法</h3><h4 id="1-运算规则-2"><a href="#1-运算规则-2" class="headerlink" title="1. 运算规则"></a>1. 运算规则</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-9a3e7c8dee62bf16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>矩阵乘法其实并不难，它的意思就是将第一个矩阵 A 的第一行与第二个矩阵 B 的第一列的数字分别相乘，得到的结果相加，最终的值作为结果矩阵的第(1,1)位置的值(第一行第一列)。</p><p>同样，A 矩阵的第一行与 B 矩阵的第二列的数字分别相乘，然后相加，最终的值作为结果矩阵第(1,2)位置的值(第一行第二列)。</p><p>再如，A 矩阵的第二行与 B 矩阵的第一列的数字分别相乘，然后相加，最终的值作为结果矩阵的第(2,1)位置的值(第二行第一列)。</p><p>这里主要说明两个问题：</p><ul><li>A 矩阵的列数必须与 B 矩阵的行数相同，才能相乘。因为我们需要把 A 矩阵一行中的各个数字与 B 矩阵一列中的各个数字分别相乘，所以 A 矩阵的列数与 B 矩阵的行数必须相同。</li><li>矩阵 A 乘以矩阵 B 和矩阵 B 乘以矩阵 A 的结果必然是不一样的。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/14186083-01b6708b87550939.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="2-运算性质-2"><a href="#2-运算性质-2" class="headerlink" title="2. 运算性质"></a>2. 运算性质</h4><p>1）结合律：(AB)C=A(BC)。<br>2）分配律：A(B±C)=AB±AC(左分配律)；(B±C)A=BA±CA(右分配律)。<br>3）(λA)B=λ(AB)=A(λB)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;div id=&quot;jump1&quot;&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h3 id=&quot;11-1-1-矩阵的加法和减法&quot;&gt;&lt;a href=&quot;#11-1-1-矩阵的加法和减法&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>10.3 精通自定义 View 之 Android 画布——SurfaceView</title>
    <link href="http://yoursite.com/2019/07/10/Custom%20View/10.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Android%20%E7%94%BB%E5%B8%83%E2%80%94%E2%80%94SurfaceView/"/>
    <id>http://yoursite.com/2019/07/10/Custom View/10.3 精通自定义 View 之 Android 画布——SurfaceView/</id>
    <published>2019-07-09T19:00:00.000Z</published>
    <updated>2019-10-31T08:04:37.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><div id="jump1"></div></p><h3 id="10-3-1-概述"><a href="#10-3-1-概述" class="headerlink" title="10.3.1 概述"></a>10.3.1 概述</h3><p>Android 屏幕刷新的时间间隔是 16ms，如果 View 能够在 16ms 内完成所需执行的绘图操作，那么在视觉上，界面就是流畅的；否则就会出现卡顿。很多时候，在自定义 View 的日志中，经常会看到如下警告：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Skipped 60 frames! The application may be doing too much work on its main thread</div></pre></td></tr></table></figure></p><p>之所以会出现这些警告，大部分是因为我们在绘制过程中不单单执行了绘图操作，也夹杂了很多逻辑处理，导致在指定的 16ms 内并没有完成绘制，出现界面卡顿和警告。为了解决这个问题，Android 引入了 SurfaceView。它在两个方面改进了 View 的绘图操作：</p><ul><li>使用双缓冲技术。</li><li>自带画布，支持在子线程中更新画布内容。</li></ul><p>所谓双缓冲技术，简单来讲，就是多加一块缓冲画布，当需要执行绘图操作时，现在缓冲画布上绘制，绘制好后直接将缓冲画布上的内容更新到主画布上。这样，在屏幕更新时，只需把换缓冲画布上的内容照样画过来就可以了，就不会存在逻辑处理时间的问题，也就解决了超时绘制的问题。具体详见 10.3.3。</p><p>虽然 SurfaceView 在处理耗时操作时很有用，但正是因为在新的线程中更新画面，所以不会阻塞主线程。但这也带来了另一个问题，就是事件同步。比如，你触摸了屏幕，SurfaceView 就会调用线程来处理，当线程过多时，一般就需要一个线程队列来保存触摸事件，这会稍稍复杂一点，因为涉及线程同步。</p><p>总之，View 和 SurfaceView 都有各自的应用场景：</p><ul><li>当界面需要被动更新时，用 View 较好。比如，与手势交互的场景，因为画面的更新是依赖 onTouch 来完成的，所以可以直接使用 invalidate() 函数。在这种情况下，这一次 Touch 和下一次 Touch 间隔的时间比较长，不会产生影响。</li><li>当界面需要主动更新，用 SurfaceView 较好。比如一个人在一直跑动，这就需要一个单独的线程不停地重绘人的状态，避免阻塞主线程。显然 View 不合适，需要 SurfaceView 来控制。</li><li>当界面绘制需要频繁刷新，或者刷新是数据处理量比较大时，就应该用 SurfaceView 来实现，比如视频播放及 Camera。</li></ul><p><div id="jump2"></div></p><h3 id="10-3-2-SurfaceView-的基本用法"><a href="#10-3-2-SurfaceView-的基本用法" class="headerlink" title="10.3.2 SurfaceView 的基本用法"></a>10.3.2 SurfaceView 的基本用法</h3><h4 id="1-实现-View-功能"><a href="#1-实现-View-功能" class="headerlink" title="1. 实现 View 功能"></a>1. 实现 View 功能</h4><p>SurfaceView 派生自 View，所以 SurfaceView 能使用 View 中的所有方法，但要注意，View 中的所有方法都是在主线程中执行。下面使用 SurfaceView 来实现捕捉用户手势轨迹的自定义控件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public class TestView extends SurfaceView &#123;</div><div class="line"></div><div class="line">    private Path mPath;</div><div class="line">    private Paint mPaint;</div><div class="line"></div><div class="line">    public TestView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs, int defStyle) &#123;</div><div class="line">        super(context, attrs, defStyle);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        // setWillNotDraw(false);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(5);</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        int x = (int) event.getX();</div><div class="line">        int y = (int) event.getY();</div><div class="line">        if (event.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">            mPath.moveTo(x, y);</div><div class="line">            Log.d(&quot;xian&quot;, &quot;ACTION_DOWN&quot;);</div><div class="line">            return true;</div><div class="line">        &#125; else if (event.getAction() == MotionEvent.ACTION_MOVE) &#123;</div><div class="line">            mPath.lineTo(x, y);</div><div class="line">        &#125;</div><div class="line">        postInvalidate();</div><div class="line">        Log.d(&quot;xian&quot;, &quot;invalidate&quot;);</div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        Log.d(&quot;xian&quot;, &quot;onDraw&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然而，效果却是不显示手势轨迹，而一直显示黑屏。查看日志，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-da5c709d3abc8755.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从日志中可以看出，上述代码只调用了 postInavidate() 函数，而没有调用 onDraw() 函数。这是为什么呢？当你把 init() 函数中注释掉的一行代码打开以后，就会发现可以看到手势轨迹了。</p><p><strong>setWillNotDraw(boolean willNotDraw)</strong> 这个函数存在于 View 类中，它主要用在 View 派生子类的初始化中，如果参数 willNotDraw 取 true，则表示当前控件没有绘制内容，当屏幕重绘的时候，这个控件不需要绘制，所以在重绘的时候也就不会调用这个类的 onDraw() 函数。相反，如果参数 willNotDraw 取 false，则表示当前控件在每次重绘时，都需要绘制该控件。可见，setWillNotDraw 其实是一种优化策略，它让控件显示地告诉系统，在重绘屏幕时，哪个控件需要重绘，哪个控件不需要重绘，这样就可以大大提高重绘效率。</p><p>一般而言，想 LinearLayout、RelativeLayout 等布局控件，它们的主要功能是布局其中的控件，它们本身是没有东西需要绘制的，所以它们在构造的时候都会显示设置 setWillNotDraw(true)</p><p>总结：</p><ul><li>原本能够通过派生自 View 实现的控件，依然可以通过 SurfaceView 来实现，因为 SurfaceView 派生自 View。</li><li>当 SurfaceView 需要使用 View 的 onDraw() 函数来重绘控件时，需要在初始化的时候调用 setWillNotDraw(false)，否则 onDraw() 函数不会被调用。</li><li>View 中的所有方法都是在主线程中执行的，所以并不建议使用 SurfaceView 重写 View 的 onDraw() 函数来实现自定义控件，而要使用 SurfaceView 特有的双缓冲机制绘图。</li></ul><h4 id="2-使用缓冲-Canvas-绘图"><a href="#2-使用缓冲-Canvas-绘图" class="headerlink" title="2. 使用缓冲 Canvas 绘图"></a>2. 使用缓冲 Canvas 绘图</h4><p>通过以下方式来获取 SurfaceView 自带的画布。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SurfaceHolder surfaceHolder = getHolder();</div><div class="line">Canvas canvas = surfaceHolder.lockCanvas();</div><div class="line">// TODO 绘图操作</div><div class="line">surfaceHolder.unlockCanvasAndPost(canvas);</div></pre></td></tr></table></figure></p><p>前面说过线程同步问题，所以需要给获取的缓冲画布进行加锁，防止被其他线程更改；当绘图操作完成以后，将缓冲画布释放，并将所画内容更新到主线程的画布上，显示在屏幕上。使用缓冲画布来改造上面的示例代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public class TestView extends SurfaceView &#123;</div><div class="line"></div><div class="line">    private Path mPath;</div><div class="line">    private Paint mPaint;</div><div class="line"></div><div class="line">    public TestView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs, int defStyle) &#123;</div><div class="line">        super(context, attrs, defStyle);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(5);</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        int x = (int) event.getX();</div><div class="line">        int y = (int) event.getY();</div><div class="line">        if (event.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">            mPath.moveTo(x, y);</div><div class="line">            return true;</div><div class="line">        &#125; else if (event.getAction() == MotionEvent.ACTION_MOVE) &#123;</div><div class="line">            mPath.lineTo(x, y);</div><div class="line">        &#125;</div><div class="line">        drawCanvas();</div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void drawCanvas() &#123;</div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                SurfaceHolder surfaceHolder = getHolder();</div><div class="line">                Canvas canvas = surfaceHolder.lockCanvas();</div><div class="line">                if (canvas != null) &#123;</div><div class="line">                    canvas.drawPath(mPath, mPaint);</div><div class="line">                &#125;</div><div class="line">                surfaceHolder.unlockCanvasAndPost(canvas);</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注意，onTouchEvent() 函数是在主线程执行的，所以我们需要开启子线程更新画布。效果图如下。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-14619c98984a1666.gif?imageMogr2/auto-orient/strip" alt=""></p><h4 id="3-监听-Surface-生命周期"><a href="#3-监听-Surface-生命周期" class="headerlink" title="3. 监听 Surface 生命周期"></a>3. 监听 Surface 生命周期</h4><p>与 SurfaceView 相关的有三个概念：Surface、SurfaceView、SurfaceHolder。这三个概念是典型的 MVC 模式 (Model-View-Controller)。Surface 是 Model，保存着缓冲画布和绘图内容相关的各种信息；SurfaceView 是 View，负责将 Surface 中存储的数据展示在 View 上；SurfaceHolder 是 Controller，使用它才能操作 Surface 中的数据。</p><p>生命周期监听函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">SurfaceHolder surfaceHolder = getHolder();</div><div class="line">surfaceHolder.addCallback(new SurfaceHolder.Callback() &#123;</div><div class="line">    @Override</div><div class="line">    public void surfaceCreated(SurfaceHolder holder) &#123;</div><div class="line">        // 当 Surface 对象被创建后，该函数就会被立即调用</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123;</div><div class="line">        // 当 Surface 发生任何结构性的变化时（格式或者大小），该函数就会被立即调用</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void surfaceDestroyed(SurfaceHolder holder) &#123;</div><div class="line">        // 当 Surface 对象将要被销毁时，该函数就会被立即调用</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>示例：动态背景效果</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-bdaa5b67454c3d29.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">public class TestView extends SurfaceView &#123;</div><div class="line"></div><div class="line">    private SurfaceHolder mHolder;</div><div class="line">    private boolean flag = false;                   // 线程标示</div><div class="line">    private Bitmap mBgBitmap;                       // 背景图</div><div class="line"></div><div class="line">    private float mSurfaceWidth, mSurfaceHeight;    // 屏幕宽高</div><div class="line">    private int mBitPosX;                           // 开始绘制的图片的 x 坐标</div><div class="line">    private Canvas mCanvas;</div><div class="line">    private Thread mThread;</div><div class="line"></div><div class="line">    // 背景移动状态</div><div class="line">    private enum State &#123;</div><div class="line">        LEFT, RIGHT</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 默认向左</div><div class="line">    private State state = State.LEFT;</div><div class="line">    private final int BITMAP_STEP = 5;              // 背景画布移动步伐</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mHolder = getHolder();</div><div class="line">        mHolder.addCallback(new SurfaceHolder.Callback() &#123;</div><div class="line">            @Override</div><div class="line">            public void surfaceCreated(SurfaceHolder holder) &#123;</div><div class="line">                flag = true;</div><div class="line">                startAnimation();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void surfaceDestroyed(SurfaceHolder holder) &#123;</div><div class="line">                flag = false;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void startAnimation() &#123;</div><div class="line">        mSurfaceWidth = getWidth();</div><div class="line">        mSurfaceHeight = getHeight();</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            // 按比例缩放图片，是高度充满屏幕</div><div class="line">            Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.qingmingshanghetu);</div><div class="line">            float width = mSurfaceHeight / bitmap.getHeight() * bitmap.getWidth();</div><div class="line">            mBgBitmap = Bitmap.createScaledBitmap(bitmap, (int)width, (int)mSurfaceHeight, true);</div><div class="line">        &#125; catch (OutOfMemoryError error) &#123;</div><div class="line">            error.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mBgBitmap == null) return;</div><div class="line"></div><div class="line">        // 开始绘图</div><div class="line">        mThread = new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                while (flag) &#123;</div><div class="line">                    mCanvas = mHolder.lockCanvas();</div><div class="line">                    drawView();</div><div class="line">                    mHolder.unlockCanvasAndPost(mCanvas);</div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(16);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        mThread.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void drawView() &#123;</div><div class="line">        if (mCanvas == null) return;</div><div class="line"></div><div class="line">        // 清空屏幕</div><div class="line">        mCanvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);</div><div class="line">        // 从 mBitPosX 开始绘制屏幕背景</div><div class="line">        mCanvas.drawBitmap(mBgBitmap, mBitPosX, 0, null);</div><div class="line"></div><div class="line">        // 图片滚动效果</div><div class="line">        switch (state) &#123;</div><div class="line">            case LEFT:</div><div class="line">                mBitPosX -= BITMAP_STEP;    // 画布左移</div><div class="line">                break;</div><div class="line">            case RIGHT:</div><div class="line">                mBitPosX += BITMAP_STEP;    // 画布右移</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        if (mBitPosX &lt;= -mSurfaceWidth / 2) &#123;</div><div class="line">            state = State.RIGHT;</div><div class="line">        &#125;</div><div class="line">        if (mBitPosX &gt;= 0) &#123;</div><div class="line">            state = State.LEFT;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><div id="jump3"></div></p><h3 id="10-3-3-SurfaceView-双缓冲技术"><a href="#10-3-3-SurfaceView-双缓冲技术" class="headerlink" title="10.3.3 SurfaceView 双缓冲技术"></a>10.3.3 SurfaceView 双缓冲技术</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>双缓冲技术需要两个图形缓冲区：前端缓冲区和后端缓冲区。前端缓冲区对应当前屏幕正在显示的内容，而后端缓冲区是接下来要渲染的图形缓冲区。通过 surfaceHolder.lockCanvas() 函数获得的缓冲区是后端缓冲区。当绘图完成以后，调用 surfaceHolder.unlockCanvasAndPost(mCanvas) 函数将后端缓冲区与前端缓冲区交换，后端缓冲区变成前端缓冲区，将内容显示在屏幕上；而原来的前端缓冲区则变成后端缓冲区，等待下一次的 surfaceHolder.lockCanvas() 函数调用返回给用户使用，如此反复。</p><p>正是由于两块画布交替用来绘图，在绘图完成以后相互交换位置，而且在绘图完成以后直接更新到屏幕上，所以才使得绘图效率大大提高。而这样做却造成了一个问题：两块画布上的内容肯定会存在不一致的情况，尤其是在多线程的情况下。比如，我们利用一个线程操作 A、B 两款画布，目前 A 画布是屏幕画布，所以，当线程要绘图是，获得的缓冲画布是 B。在更新以后，B 画布更新到屏幕上，A 画布与 B 画布交换位置。而这时，如果线程再次申请画布，则将获取到 A 画布。如果 A 画布与 B 画布上的内容不一样，那么，在 A 画布上继续作画肯定会与预想的不一样。</p><p>示例：每获取一次画布写一个数字，循环 10 次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class TestView extends SurfaceView &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPaint.setTextSize(30);</div><div class="line"></div><div class="line">        getHolder().addCallback(new SurfaceHolder.Callback() &#123;</div><div class="line">            @Override</div><div class="line">            public void surfaceCreated(SurfaceHolder holder) &#123;</div><div class="line">                drawText(holder);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void surfaceDestroyed(SurfaceHolder holder) &#123;&#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void drawText(SurfaceHolder holder) &#123;</div><div class="line">        for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">            Canvas canvas = holder.lockCanvas();</div><div class="line">            if (canvas != null) &#123;</div><div class="line">                canvas.drawText(i + &quot;&quot;, i * 30, 50, mPaint);</div><div class="line">            &#125;</div><div class="line">            holder.unlockCanvasAndPost(canvas);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-fbeb48f18a692e38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>按照我们的逻辑，如果有两块缓冲画布，那么结果应该是 1 3 5 7 9。因为最后一个更新的数字必然是 9，而往前推，每次间隔使用画布，跟 9 在同一块画布上的必然是 1 3 5 7，其他数字都在另一块画布上。但结果为什么是 0 3 6 9 呢？这是因为这里有三块缓冲画布。</p><p>如果我们在绘图时使用单独的线程，而且每次绘图完成以后，让线程休眠一段时间，就可以明显地看到每次所绘制的数字了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">private void drawText(final SurfaceHolder holder) &#123;</div><div class="line">    new Thread(new Runnable() &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">                Canvas canvas = holder.lockCanvas();</div><div class="line">                if (canvas != null) &#123;</div><div class="line">                    canvas.drawText(i + &quot;&quot;, i * 100, 150, mPaint);</div><div class="line">                &#125;</div><div class="line">                holder.unlockCanvasAndPost(canvas);</div><div class="line"></div><div class="line">                try &#123;</div><div class="line">                    Thread.sleep(600);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c701c355e280c4a5.gif?imageMogr2/auto-orient/strip" alt=""></p><p>从效果图中可以看出每次获取到的画布上所绘制的内容，很明显，0、1、2 这三个数字是分别在三块空白的画布上绘制的，之后的每个数字都是依次在这三块画布上绘制的。</p><p>有关 Surface 中缓冲画布的数量，<a href="https//source.android.com/devices/graphics/arch-sh.html">Google 给出的解释</a> 是：Surface 中缓冲画布的数量是根据需求动态分配的。如果用户获取画布的频率较慢，那么将会分配两块缓冲画布；否则，将分配 3 的倍数缓冲画布，具体分配多少块，视情况而定。</p><h4 id="2-双缓冲技术局部更新原理"><a href="#2-双缓冲技术局部更新原理" class="headerlink" title="2. 双缓冲技术局部更新原理"></a>2. 双缓冲技术局部更新原理</h4><p>SurfaceView 支持局部更新，可以通过 Canvas lockCanvas(Rect dirty) 函数指定获取画布的区域和大小。画布以外的地方会将现在屏幕上的内容复制过来，以保持与屏幕一致；而画布以内的区域则保持原画布内容。</p><ul><li>lockCanvas()：用于获取整屏画布，屏幕内容不会被更新到画布上，画布保持原画布内容。</li><li>lockCanvas(Rect dirty)：用于获取指定区域的画布，画布以外的区域会保持与屏幕内容一致，画布以内的区域依然保持原画布内容。</li></ul><p>示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-eb901bc2d0c506ff.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">public class TestView extends SurfaceView &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.argb(0x1F, 0xFF, 0xFF, 0xFF));</div><div class="line">        mPaint.setTextSize(60);</div><div class="line"></div><div class="line">        getHolder().addCallback(new SurfaceHolder.Callback() &#123;</div><div class="line">            @Override</div><div class="line">            public void surfaceCreated(SurfaceHolder holder) &#123;</div><div class="line">                drawText(holder);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void surfaceDestroyed(SurfaceHolder holder) &#123;&#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void drawText(final SurfaceHolder holder) &#123;</div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                // 先进行清屏操作</div><div class="line">                while (true) &#123;</div><div class="line">                    Rect dirtyRect = new Rect(0, 0, 1, 1);</div><div class="line">                    Canvas canvas = holder.lockCanvas(dirtyRect);</div><div class="line">                    Rect canvasRect = canvas.getClipBounds();</div><div class="line">                    if (getWidth() == canvasRect.width() &amp;&amp; getHeight() == canvasRect.height()) &#123;</div><div class="line">                        canvas.drawColor(Color.BLACK);</div><div class="line">                        holder.unlockCanvasAndPost(canvas);</div><div class="line">                    &#125; else &#123;</div><div class="line">                        holder.unlockCanvasAndPost(canvas);</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                // 画图</div><div class="line">                for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">                    // 画大方</div><div class="line">                    if (i == 0) &#123;</div><div class="line">                        Canvas canvas = holder.lockCanvas(new Rect(10, 10, 600, 600));</div><div class="line">                        canvas.drawColor(Color.RED);</div><div class="line">                        holder.unlockCanvasAndPost(canvas);</div><div class="line">                    &#125;</div><div class="line">                    // 画中方</div><div class="line">                    if (i == 1) &#123;</div><div class="line">                        Canvas canvas = holder.lockCanvas(new Rect(30, 30, 570, 570));</div><div class="line">                        canvas.drawColor(Color.GREEN);</div><div class="line">                        holder.unlockCanvasAndPost(canvas);</div><div class="line">                    &#125;</div><div class="line">                    // 画小方</div><div class="line">                    if (i == 2) &#123;</div><div class="line">                        Canvas canvas = holder.lockCanvas(new Rect(60, 60, 540, 540));</div><div class="line">                        canvas.drawColor(Color.BLUE);</div><div class="line">                        holder.unlockCanvasAndPost(canvas);</div><div class="line">                    &#125;</div><div class="line">                    // 画圆形</div><div class="line">                    if (i == 3) &#123;</div><div class="line">                        Canvas canvas = holder.lockCanvas(new Rect(200, 200, 400, 400));</div><div class="line">                        mPaint.setColor(Color.argb(0x3F, 0xFF, 0xFF, 0xFF));</div><div class="line">                        canvas.drawCircle(300, 300, 100, mPaint);</div><div class="line">                        holder.unlockCanvasAndPost(canvas);</div><div class="line">                    &#125;</div><div class="line">                    // 写数字</div><div class="line">                    if (i == 4) &#123;</div><div class="line">                        Canvas canvas = holder.lockCanvas(new Rect(250, 250, 350, 350));</div><div class="line">                        mPaint.setColor(Color.RED);</div><div class="line">                        canvas.drawText(i + &quot;&quot;, 300, 300, mPaint);</div><div class="line">                        holder.unlockCanvasAndPost(canvas);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(800);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>分析过程略，得出以下几个结论：</p><ul><li>缓冲画布的存取遵循 LRU（先进先出）策略。</li><li>画布以内的区域仍在原缓冲画布上叠加作画，画布以外的区域是从屏幕上直接复制过来的。</li><li>为了防止画布以内的缓冲画布本身的图像与所画内容产生冲突，在对画布以内的区域作画时，建议先清空画布。</li></ul><h4 id="3-局部更新为何要先清屏"><a href="#3-局部更新为何要先清屏" class="headerlink" title="3. 局部更新为何要先清屏"></a>3. 局部更新为何要先清屏</h4><p>因为这里有三块缓冲画布，有一块画布初始化地被显示在屏幕上，已经被默认填充为黑色，而另外两块画布都还没有被画过。虽然我们指定了获取画布的区域范围，但是系统认为，整块画布都是脏区域，都应该被画上，所以会返回屏幕大小的画布。只有将每块画布都划过以后，才会按照我们指定的区域来返回画布大小。</p><h4 id="4-双缓冲技术解决方案"><a href="#4-双缓冲技术解决方案" class="headerlink" title="4. 双缓冲技术解决方案"></a>4. 双缓冲技术解决方案</h4><p><strong>方案一：保存所有要绘制的内容，全屏重绘</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public class TestView extends SurfaceView &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPaint.setTextSize(100);</div><div class="line"></div><div class="line">        getHolder().addCallback(new SurfaceHolder.Callback() &#123;</div><div class="line">            @Override</div><div class="line">            public void surfaceCreated(SurfaceHolder holder) &#123;</div><div class="line">                drawText(holder);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void surfaceDestroyed(SurfaceHolder holder) &#123;&#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private List&lt;Integer&gt; mInts = new ArrayList&lt;&gt;();</div><div class="line">    private void drawText(final SurfaceHolder holder) &#123;</div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">                    Canvas canvas = holder.lockCanvas();</div><div class="line">                    mInts.add(i);</div><div class="line">                    if (canvas != null) &#123;</div><div class="line">                        for (int num : mInts) &#123;</div><div class="line">                            canvas.drawText(num + &quot;&quot;, num * 100, 150, mPaint);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(600);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    holder.unlockCanvasAndPost(canvas);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-61a0cdaa7a0e2c86.gif?imageMogr2/auto-orient/strip" alt=""></p><p><strong>方案二：在内容不交叉时，可以采用增量绘制</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7e353a9c3a6ce7e6.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">private void drawText(final SurfaceHolder holder) &#123;</div><div class="line">    new Thread(new Runnable() &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            // 先进行清屏操作</div><div class="line">            while (true) &#123;</div><div class="line">                Rect dirtyRect = new Rect(0, 0, 1, 1);</div><div class="line">                Canvas canvas = holder.lockCanvas(dirtyRect);</div><div class="line">                Rect canvasRect = canvas.getClipBounds();</div><div class="line">                if (getWidth() == canvasRect.width() &amp;&amp; getHeight() == canvasRect.height()) &#123;</div><div class="line">                    canvas.drawColor(Color.BLACK);</div><div class="line">                    holder.unlockCanvasAndPost(canvas);</div><div class="line">                &#125; else &#123;</div><div class="line">                    holder.unlockCanvasAndPost(canvas);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            // 画图</div><div class="line">            for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">                int itemWidth = 100;</div><div class="line">                int itemHeight = 100;</div><div class="line">                Rect rect = new Rect(i*itemWidth, 0, (i+1)*itemWidth-10, itemHeight);</div><div class="line">                Canvas canvas = holder.lockCanvas(rect);</div><div class="line">                if (canvas != null) &#123;</div><div class="line">                    canvas.drawColor(Color.GREEN);</div><div class="line">                    canvas.drawText(i + &quot;&quot;, i*itemWidth+10, itemHeight/2f, mPaint);</div><div class="line">                &#125;</div><div class="line">                holder.unlockCanvasAndPost(canvas);</div><div class="line"></div><div class="line">                try &#123;</div><div class="line">                    Thread.sleep(600);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>局部更新清屏代码，在每次开始运行程序时，在获取第二缓冲画布时，依然是全屏画布。但是同样的代码，从任务列表恢复程序时，又运行正常。百思不得其解！！！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;div id=&quot;jump1&quot;&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h3 id=&quot;10-3-1-概述&quot;&gt;&lt;a href=&quot;#10-3-1-概述&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
</feed>
