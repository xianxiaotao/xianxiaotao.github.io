<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>先小涛</title>
  
  <subtitle>我至诚我道</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-30T10:49:57.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>先小涛</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>精通 Android 自定义 View 目录</title>
    <link href="http://yoursite.com/2200/01/01/Custom%20View/00%20Android%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%20%E7%9B%AE%E5%BD%95/"/>
    <id>http://yoursite.com/2200/01/01/Custom View/00 Android 自定义控件 目录/</id>
    <published>2199-12-31T16:00:00.000Z</published>
    <updated>2019-09-30T10:49:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇从自定义控件的动画、绘图、视图三方面入手，分别讲解与自定义控件相关的各种知识，给大家系统的梳理相关知识。不仅适合 Android 初、中级水平从业者，也适合高水平从业者查漏补缺使用。</p><p>内容摘自启舰所著的书籍《Android 自定义控件开发入门与实践》。</p><h2 id="第1章-绘图基础"><a href="#第1章-绘图基础" class="headerlink" title="第1章  绘图基础"></a>第1章  绘图基础</h2><h3 id="1-1-基本图形绘制"><a href="#1-1-基本图形绘制" class="headerlink" title="1.1 基本图形绘制"></a>1.1 基本图形绘制</h3><p>1.1.1 概述<br>1.1.2 画笔的基本设置<br>1.1.3 Canvas使用基础<br>1.1.4 Rect与RectF<br>1.1.5 Color</p><h3 id="1-2-路径"><a href="#1-2-路径" class="headerlink" title="1.2 路径"></a>1.2 路径</h3><p>1.2.1 概述<br>1.2.2 直线路径<br>1.2.3 弧线路径<br>1.2.4 addXXX系列函数<br>1.2.5 填充模式<br>1.2.6 重置路径<br>1.2.7 示例:蜘蛛网状图</p><h3 id="1-3-文字"><a href="#1-3-文字" class="headerlink" title="1.3 文字"></a>1.3 文字</h3><p>1.3.1 Paint设置<br>1.3.2 Canvas绘制文本<br>1.3.3 设置字体样式</p><h3 id="1-4-Region"><a href="#1-4-Region" class="headerlink" title="1.4 Region"></a>1.4 Region</h3><p>1.4.1 构造Region<br>1.4.2 枚举区域——RegionIterator类<br>1.4.3 区域相交<br>1.4.4 其他函数</p><h3 id="1-5-Canvas-画布"><a href="#1-5-Canvas-画布" class="headerlink" title="1.5 Canvas(画布)"></a>1.5 Canvas(画布)</h3><p>1.5.1 Canvas变换<br>1.5.2 画布的保存与恢复<br>1.5.3 示例一:圆形头像<br>1.5.4 示例二:裁剪动画</p><h3 id="1-6-控件的使用方法"><a href="#1-6-控件的使用方法" class="headerlink" title="1.6 控件的使用方法"></a>1.6 控件的使用方法</h3><p>1.6.1 控件概述<br>1.6.2 通过XML引入控件<br>1.6.3 动态添加控件</p><h2 id="第2章-视图动画"><a href="#第2章-视图动画" class="headerlink" title="第2章 视图动画"></a>第2章 视图动画</h2><h3 id="2-1-视图动画标签"><a href="#2-1-视图动画标签" class="headerlink" title="2.1 视图动画标签"></a>2.1 视图动画标签</h3><p>2.1.1 概述<br>2.1.2 scale 标签<br>2.1.3 alpha 标签<br>2.1.4 rotate 标签<br>2.1.5 translate 标签<br>2.1.6 set 标签</p><h3 id="2-2-视图动画的代码实现"><a href="#2-2-视图动画的代码实现" class="headerlink" title="2.2 视图动画的代码实现"></a>2.2 视图动画的代码实现</h3><p>2.2.1 概述<br>2.2.2 ScaleAnimation<br>2.2.3 AlphaAnimation<br>2.2.4 RotateAnimation<br>2.2.5 TranslateAnimation<br>2.2.6 AnimationSet<br>2.2.7 Animation</p><h3 id="2-3-插值器初探"><a href="#2-3-插值器初探" class="headerlink" title="2.3 插值器初探"></a>2.3 插值器初探</h3><p>2.3.1 AccelerateDecelerateInterpolator<br>2.3.2 AccelerateInterpolator<br>2.3.3 DecelerateInterpolator<br>2.3.4 LinearInterpolator<br>2.3.5 BounceInterpolator<br>2.3.6 AnticipateInterpolator<br>2.3.7 OvershootInterpolator<br>2.3.8 AnticipateOvershootInterpolator<br>2.3.9 CycleInterpolator</p><h3 id="2-4-动画示例"><a href="#2-4-动画示例" class="headerlink" title="2.4 动画示例"></a>2.4 动画示例</h3><p>2.4.1 镜头由远及近效果<br>2.4.2 加载框效果<br>2.4.3 扫描动画</p><h3 id="2-5-逐帧动画"><a href="#2-5-逐帧动画" class="headerlink" title="2.5 逐帧动画"></a>2.5 逐帧动画</h3><p>2.5.1 XML 实现<br>2.5.2 代码实现</p><h2 id="第3章-属性动画"><a href="#第3章-属性动画" class="headerlink" title="第3章 属性动画"></a>第3章 属性动画</h2><h3 id="3-1-ValueAnimator-的基本使用"><a href="#3-1-ValueAnimator-的基本使用" class="headerlink" title="3.1 ValueAnimator 的基本使用"></a>3.1 ValueAnimator 的基本使用</h3><p>3.1.1 概述<br>3.1.2 ValueAnimator 的简单使用<br>3.1.3 常用函数<br>3.1.4 示例：弹跳加载中效果</p><h3 id="3-2-自定义插值器与-Evaluator"><a href="#3-2-自定义插值器与-Evaluator" class="headerlink" title="3.2 自定义插值器与 Evaluator"></a>3.2 自定义插值器与 Evaluator</h3><p>3.2.1 自定义插值器<br>3.2.2 Evaluator</p><h3 id="3-3-ValueAnimator-进阶——ofObject"><a href="#3-3-ValueAnimator-进阶——ofObject" class="headerlink" title="3.3 ValueAnimator 进阶——ofObject"></a>3.3 ValueAnimator 进阶——ofObject</h3><p>3.3.1 概述<br>3.3.2 示例：抛物动画</p><h3 id="3-4-ObjectAnimator"><a href="#3-4-ObjectAnimator" class="headerlink" title="3.4 ObjectAnimator"></a>3.4 ObjectAnimator</h3><p>3.4.1 概述<br>3.4.2 ObjectAnimator 动画原理<br>3.4.3 自定义 ObjectAnimator 属性<br>3.4.4 何时需要实现对应的 get 函数<br>3.4.5 常用函数</p><h3 id="3-5-组合动画——AnimatorSet"><a href="#3-5-组合动画——AnimatorSet" class="headerlink" title="3.5 组合动画——AnimatorSet"></a>3.5 组合动画——AnimatorSet</h3><p>3.5.1 playSequentially() 与 playTogether() 函数<br>3.5.2 AnimatorSet.Builder<br>3.5.3 AnimatorSet 监听器<br>3.5.4 常用函数<br>3.5.5 示例：路径动画</p><h3 id="3-6-Animator-动画的-XML-实现"><a href="#3-6-Animator-动画的-XML-实现" class="headerlink" title="3.6 Animator 动画的 XML 实现"></a>3.6 Animator 动画的 XML 实现</h3><p>3.6.1 animator 标签<br>3.6.2 objectAnimator 标签<br>3.6.3 set 标签</p><h2 id="第4章-属性动画进阶"><a href="#第4章-属性动画进阶" class="headerlink" title="第4章 属性动画进阶"></a>第4章 属性动画进阶</h2><h3 id="4-1-PropertyValuesHolder-与-Keyframe"><a href="#4-1-PropertyValuesHolder-与-Keyframe" class="headerlink" title="4.1 PropertyValuesHolder 与 Keyframe"></a>4.1 PropertyValuesHolder 与 Keyframe</h3><p>4.1.1 PropertyValuesHolder<br>4.1.2 Keyframe<br>4.1.3 PropertyValuesHolder 其他函数<br>4.1.4 示例：电话响铃效果</p><h3 id="4-2-ViewPropertyAnimator"><a href="#4-2-ViewPropertyAnimator" class="headerlink" title="4.2 ViewPropertyAnimator"></a>4.2 ViewPropertyAnimator</h3><p>4.2.1 概述<br>4.2.2 常用函数</p><h3 id="4-3-为-ViewGroup-内的组件添加动画"><a href="#4-3-为-ViewGroup-内的组件添加动画" class="headerlink" title="4.3 为 ViewGroup 内的组件添加动画"></a>4.3 为 ViewGroup 内的组件添加动画</h3><p>4.3.1 animateLayoutChanges 属性<br>4.3.2 LayoutTransition<br>4.3.3 其他函数</p><h3 id="4-4-开源动画库-NineOldAndroids"><a href="#4-4-开源动画库-NineOldAndroids" class="headerlink" title="4.4 开源动画库 NineOldAndroids"></a>4.4 开源动画库 NineOldAndroids</h3><p>4.4.1 NineOldAndroids 中的 ViewPropertyAnimator<br>4.4.2 NineOldAndroids 中的 ViewHelper</p><h2 id="第5章-动画进阶"><a href="#第5章-动画进阶" class="headerlink" title="第5章 动画进阶"></a>第5章 动画进阶</h2><h3 id="5-1-利用-PathMeasure-实现路径动画"><a href="#5-1-利用-PathMeasure-实现路径动画" class="headerlink" title="5.1 利用 PathMeasure 实现路径动画"></a>5.1 利用 PathMeasure 实现路径动画</h3><p>5.1.1 初始化<br>5.1.2 简单函数使用<br>5.1.3 getSegment() 函数<br>5.1.4 getPosTan() 函数<br>5.1.5 getMatrix() 函数<br>5.1.6 示例：支付宝支付成功动画</p><h3 id="5-2-SVG-动画"><a href="#5-2-SVG-动画" class="headerlink" title="5.2 SVG 动画"></a>5.2 SVG 动画</h3><p>5.2.1 概述<br>5.2.2 vector 标签与图像显示<br>5.2.3 动态 Vector<br>5.2.4 示例：输入搜索动画</p><h2 id="第6章-Paint-基本使用"><a href="#第6章-Paint-基本使用" class="headerlink" title="第6章 Paint 基本使用"></a>第6章 Paint 基本使用</h2><h3 id="6-1-硬件加速"><a href="#6-1-硬件加速" class="headerlink" title="6.1 硬件加速"></a>6.1 硬件加速</h3><p>6.1.1 概述<br>6.1.2 软件绘制与硬件加速的区别<br>6.1.3 禁用 GPU 硬件加速的方法</p><h3 id="6-2-文字"><a href="#6-2-文字" class="headerlink" title="6.2 文字"></a>6.2 文字</h3><p>6.2.1 概述<br>6.2.2 绘图四格线与 FontMetrics<br>6.2.3 常用函数<br>6.2.4 示例：定点写字</p><h3 id="6-3-Paint-常用函数"><a href="#6-3-Paint-常用函数" class="headerlink" title="6.3 Paint 常用函数"></a>6.3 Paint 常用函数</h3><p>6.3.1 基本设置函数<br>6.3.2 字体相关函数</p><h2 id="第7章-绘图进阶"><a href="#第7章-绘图进阶" class="headerlink" title="第7章 绘图进阶"></a>第7章 绘图进阶</h2><h3 id="7-1-贝济埃曲线"><a href="#7-1-贝济埃曲线" class="headerlink" title="7.1 贝济埃曲线"></a>7.1 贝济埃曲线</h3><p>7.1.1 概述<br>7.1.2 贝济埃曲线之 quadTo<br>7.1.3 贝济埃曲线之 rQuadTo<br>7.1.4 示例：波浪效果</p><h3 id="7-2-setShadowLayer-与阴影效果"><a href="#7-2-setShadowLayer-与阴影效果" class="headerlink" title="7.2 setShadowLayer 与阴影效果"></a>7.2 setShadowLayer 与阴影效果</h3><p>7.2.1 构造函数<br>7.2.2 清除阴影<br>7.2.3 示例：给文字添加阴影</p><h3 id="7-3-BlurMaskFilter-发光效果和图片阴影"><a href="#7-3-BlurMaskFilter-发光效果和图片阴影" class="headerlink" title="7.3 BlurMaskFilter 发光效果和图片阴影"></a>7.3 BlurMaskFilter 发光效果和图片阴影</h3><p>7.3.1 概述<br>7.3.2 给图片添加纯色阴影</p><h3 id="7-4-Shader-与-BitmapShader"><a href="#7-4-Shader-与-BitmapShader" class="headerlink" title="7.4 Shader 与 BitmapShader"></a>7.4 Shader 与 BitmapShader</h3><p>7.4.1 Shader 概述<br>7.4.2 BitmapShader 的基本用法<br>7.4.3 示例一：望远镜效果<br>7.4.4 示例二：生成不规则头像</p><h3 id="7-5-Shader-之-LinearGradient"><a href="#7-5-Shader-之-LinearGradient" class="headerlink" title="7.5 Shader 之 LinearGradient"></a>7.5 Shader 之 LinearGradient</h3><p>7.5.1 概述<br>7.5.2 示例：闪光文字效果</p><h3 id="7-6-Shader-之-RadialGradient"><a href="#7-6-Shader-之-RadialGradient" class="headerlink" title="7.6 Shader 之 RadialGradient"></a>7.6 Shader 之 RadialGradient</h3><p>7.6.1 双色渐变<br>7.6.2 多色渐变<br>7.6.3 TileMode 填充模式</p><h2 id="第8章-混合模式"><a href="#第8章-混合模式" class="headerlink" title="第8章 混合模式"></a>第8章 混合模式</h2><h3 id="8-1-混合模式之-AvoidXfermode"><a href="#8-1-混合模式之-AvoidXfermode" class="headerlink" title="8.1 混合模式之 AvoidXfermode"></a>8.1 混合模式之 AvoidXfermode</h3><p>8.1.1 混合模式概述<br>8.1.2 AvoidXfermode<br>8.1.3 AvoidXfermode 绘制原理<br>8.1.4 AvoidXfermode 之 Mode.AVOID</p><h3 id="8-2-混合模式之-PorterDuffXfermode"><a href="#8-2-混合模式之-PorterDuffXfermode" class="headerlink" title="8.2 混合模式之 PorterDuffXfermode"></a>8.2 混合模式之 PorterDuffXfermode</h3><p>8.2.1 PorterDuffXfermode 概述<br>8.2.2 颜色叠加相关模式</p><h3 id="8-3-PorterDuffXfermode-之源图像模式"><a href="#8-3-PorterDuffXfermode-之源图像模式" class="headerlink" title="8.3 PorterDuffXfermode 之源图像模式"></a>8.3 PorterDuffXfermode 之源图像模式</h3><p>8.3.1 Mode.SRC<br>8.3.2 Mode.SRC_IN<br>8.3.3 Mode.SRC_OUT<br>8.3.4 Mode.SRC_OVER<br>8.3.5 Mode.SRC_ATOP</p><h3 id="8-4-目标图像模式与其他模式"><a href="#8-4-目标图像模式与其他模式" class="headerlink" title="8.4 目标图像模式与其他模式"></a>8.4 目标图像模式与其他模式</h3><p>8.4.1 目标图像模式<br>8.4.2 其他模式——Mode.CLEAR<br>8.4.3 模式总结</p><h2 id="第9章-Canvas-与图层"><a href="#第9章-Canvas-与图层" class="headerlink" title="第9章 Canvas 与图层"></a>第9章 Canvas 与图层</h2><h3 id="9-1-获取-Canvas-对象的方法"><a href="#9-1-获取-Canvas-对象的方法" class="headerlink" title="9.1 获取 Canvas 对象的方法"></a>9.1 获取 Canvas 对象的方法</h3><p>9.1.1 方法一：重写 onDraw()、dispatchDraw() 函数<br>9.1.2 方法二：使用 Bitmap 创建<br>9.1.3 方法三：调用 SurfaceHolder.lockCanvas() 函数</p><h3 id="9-2-图层与画布"><a href="#9-2-图层与画布" class="headerlink" title="9.2 图层与画布"></a>9.2 图层与画布</h3><p>9.2.1 saveLayer() 函数<br>9.2.2 画布与图层<br>9.2.3 saveLayer() &amp; saveLayerAlpha()</p><h3 id="9-3-Flag-的具体含义"><a href="#9-3-Flag-的具体含义" class="headerlink" title="9.3 Flag 的具体含义"></a>9.3 Flag 的具体含义</h3><p>9.3.1 MATRIX_SAVE_FLAG<br>9.3.2 CLIP_SAVE_FLAG<br>9.3.3 FULL_COLOR_LAYER_SAVE_FLAG &amp; HAS_ALPHA_LAYER_SAVE_FLAG<br>9.3.4 CLIP_TO_LAYER_SAVE_FLAG<br>9.3.5 ALL_SAVE_FLAG</p><h3 id="9-4-恢复画布"><a href="#9-4-恢复画布" class="headerlink" title="9.4 恢复画布"></a>9.4 恢复画布</h3><p>9.4.1 restoreToCount(int count)<br>9.4.2 restore() &amp; restoreToCount(int count) 的关系</p><h2 id="第10章-Android-画布"><a href="#第10章-Android-画布" class="headerlink" title="第10章 Android 画布"></a>第10章 Android 画布</h2><h3 id="10-1-ShapeDrawable"><a href="#10-1-ShapeDrawable" class="headerlink" title="10.1 ShapeDrawable"></a>10.1 ShapeDrawable</h3><p>10.1.1 shape 标签与 GradientDrawable<br>10.1.2 ShapDrawable 的构造函数<br>10.1.3 常用函数<br>10.1.4 自定义 Drawable<br>10.1.5 Drawable 与 Bitmap 对比</p><h3 id="10-2-Bitmap"><a href="#10-2-Bitmap" class="headerlink" title="10.2 Bitmap"></a>10.2 Bitmap</h3><p>10.2.1 概述<br>10.2.2 创建 Bitmap 方法一：BitmapFactory<br>10.2.3 BitmapFactory.Options<br>10.2.4 创建 Bitmap 方法二：Bitmap 静态方法<br>10.2.5 常用函数<br>10.2.6 常见问题</p><h3 id="10-3-SurfaceView"><a href="#10-3-SurfaceView" class="headerlink" title="10.3 SurfaceView"></a>10.3 SurfaceView</h3><p>10.3.1 概述<br>10.3.2 基本用法<br>10.3.3 双缓冲技术</p><h2 id="第11章-Matrix-与坐标变换"><a href="#第11章-Matrix-与坐标变换" class="headerlink" title="第11章 Matrix 与坐标变换"></a>第11章 Matrix 与坐标变换</h2><h3 id="11-1-矩阵运算"><a href="#11-1-矩阵运算" class="headerlink" title="11.1 矩阵运算"></a>11.1 矩阵运算</h3><p>11.1.1 矩阵的加法与减法<br>11.1.2 矩阵与数的乘法<br>11.1.3 矩阵与矩阵的乘法<br>11.1.4 </p><h3 id="11-2-ColorMatrix-色彩变换"><a href="#11-2-ColorMatrix-色彩变换" class="headerlink" title="11.2 ColorMatrix 色彩变换"></a>11.2 ColorMatrix 色彩变换</h3><p>11.2.1 色彩变换矩阵<br>11.2.2 色彩的几种运算方式<br>11.2.3 ColorMatrix 函数<br>11.2.4 ColorMatrix 相乘</p><h2 id="第12章-封装控件"><a href="#第12章-封装控件" class="headerlink" title="第12章 封装控件"></a>第12章 封装控件</h2><h3 id="12-1-自定义属性与自定义-Style"><a href="#12-1-自定义属性与自定义-Style" class="headerlink" title="12.1 自定义属性与自定义 Style"></a>12.1 自定义属性与自定义 Style</h3><p>12.1.1 概述<br>12.1.2 declare-styleable 标签的使用方法<br>12.1.3 在 XML 中使用自定义的属性<br>12.1.4 在代码中获取自定义属性的值<br>12.1.5 declare-styleable 标签其他属性的用法</p><h3 id="12-2-测量与布局"><a href="#12-2-测量与布局" class="headerlink" title="12.2 测量与布局"></a>12.2 测量与布局</h3><p>12.2.1 ViewGroup 绘制流程<br>12.2.2 onMeasure() 函数与 MeasureSpec<br>12.2.3 onLayout() 函数<br>12.2.4 获取子控件 margin 值的方法</p><h3 id="12-3-实现-FlowLayout-容器"><a href="#12-3-实现-FlowLayout-容器" class="headerlink" title="12.3 实现 FlowLayout 容器"></a>12.3 实现 FlowLayout 容器</h3><p>12.3.1 XML 布局<br>12.3.2 提取 margin 值与重写 onMeasure() 函数</p><h2 id="第13章-控件高级属性"><a href="#第13章-控件高级属性" class="headerlink" title="第13章 控件高级属性"></a>第13章 控件高级属性</h2><h3 id="13-1-GestureDetector-手势检测"><a href="#13-1-GestureDetector-手势检测" class="headerlink" title="13.1 GestureDetector 手势检测"></a>13.1 GestureDetector 手势检测</h3><p>13.1.1 概述<br>13.1.2 GestureDetector.OnGestureListener<br>13.1.3 GestureDetector.OnDoubleTapListener<br>13.1.4 GestureDetector.SimpleOnGestureListener<br>13.1.5 onFling() 函数的应用</p><h3 id="13-2-Window-与-WindowManager"><a href="#13-2-Window-与-WindowManager" class="headerlink" title="13.2 Window 与 WindowManager"></a>13.2 Window 与 WindowManager</h3><p>13.2.1 Window 与 WindowManager 的关系<br>13.2.2 示例：腾讯手机管家悬浮窗的小火箭效果</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇从自定义控件的动画、绘图、视图三方面入手，分别讲解与自定义控件相关的各种知识，给大家系统的梳理相关知识。不仅适合 Android 初、中级水平从业者，也适合高水平从业者查漏补缺使用。&lt;/p&gt;
&lt;p&gt;内容摘自启舰所著的书籍《Android 自定义控件开发入门与实践》。&lt;/
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>07.6 精通自定义 View 之 绘图进阶——Shader 之 RadialGradient</title>
    <link href="http://yoursite.com/2019/07/07/Custom%20View/07.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20RadialGradient/"/>
    <id>http://yoursite.com/2019/07/07/Custom View/07.6 精通自定义 View 之 绘图进阶——Shader 之 RadialGradient/</id>
    <published>2019-07-06T22:00:00.000Z</published>
    <updated>2019-10-04T07:27:18.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>RadialGradient 是 Shader 的另一种实现，它的含义是放射渐变，即它会像一个放射源一样，从一个点开始向外扩散，从一种颜色变成另一种颜色。</p><h3 id="7-6-1-双色渐变"><a href="#7-6-1-双色渐变" class="headerlink" title="7.6.1 双色渐变"></a>7.6.1 双色渐变</h3><p>RadialGradient 有两个构造函数，分别能完成双色渐变和多色渐变。双色渐变的构造函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RadialGradient(float centerX, float centerY, float radius, </div><div class="line">        int centerColor, int edgeColor, Shader.TileMode tileMode)</div></pre></td></tr></table></figure></p><ul><li>centerX：渐变中心点X坐标。</li><li>centerY：渐变中心点Y坐标。</li><li>radius：渐变半径。</li><li>centerColor：渐变的起始颜色，即渐变中心点的颜色,取值类型必须是八位的0xAARRGGBB色值！透明底Alpha值不能省略，不然不会显示出颜色。</li><li>edgeColor：渐变结束时的颜色，即渐变圆边缘的颜色，同样，取值类型必须是八位的0xAARRGGBB色值。</li><li>TileMode：与我们前面讲的各个Shader一样，用于指定当控件区域大于指定的渐变区域时，空白区域的颜色填充方式。</li></ul><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class TestView extends AppCompatTextView &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private RadialGradient mRadialGradient;</div><div class="line">    private int mRadius;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = getPaint();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</div><div class="line">        super.onSizeChanged(w, h, oldw, oldh);</div><div class="line">        mRadius = w / 5;</div><div class="line">        mRadialGradient = new RadialGradient(w / 2f, h / 2f, mRadius, 0xffff0000, 0xff00ff00, Shader.TileMode.CLAMP);</div><div class="line">        mPaint.setShader(mRadialGradient);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawCircle(getWidth()/2f, getHeight()/2f, mRadius, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-22066725bd2f934f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="7-6-2-多色渐变"><a href="#7-6-2-多色渐变" class="headerlink" title="7.6.2 多色渐变"></a>7.6.2 多色渐变</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RadialGradient(float centerX, float centerY, float radius, </div><div class="line">        int[] colors, float[] stops, Shader.TileMode tileMode)</div></pre></td></tr></table></figure><ul><li>int[] colors：表示所需要的渐变颜色数组。<br>+float[] stops：表示每个渐变颜色所在的位置百分点，取值 0~1，数量必须与 colors 数组保持一致，不然直接 crash。一般第一个数值取 0，最后一个数值取 1，比如，取一个位置数组：{0.2,0.5,0.8}，起始点是0.2百分比位置，结束点是0.8百分比位置，而 0~0.2 百分比位置和 0.8~1.0 百分比的位置都是没有指定颜色的。这些位置的颜色就是根据我们指定的 TileMode 空白区域填充模式来自行填充。但有时效果我们是不可控的。所以，为了方便起见，建议大家 stop 数组的起始和终止数值设为 0 和 1。</li></ul><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class TestView extends AppCompatTextView &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private RadialGradient mRadialGradient;</div><div class="line">    private int mRadius;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = getPaint();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</div><div class="line">        super.onSizeChanged(w, h, oldw, oldh);</div><div class="line">        mRadius = w / 5;</div><div class="line">        int[] colors = &#123;0xffff0000, 0xff00ff00, 0xff0000ff, 0xffffff00&#125;;</div><div class="line">        float[] stops = &#123;0f, 0.2f, 0.5f, 1f&#125;;</div><div class="line">        mRadialGradient = new RadialGradient(w / 2f, h / 2f, mRadius, colors, stops, Shader.TileMode.CLAMP);</div><div class="line">        mPaint.setShader(mRadialGradient);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawCircle(getWidth()/2f, getHeight()/2f, mRadius, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d5a4aac06acfb365.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="7-6-3-TileMode-填充模式"><a href="#7-6-3-TileMode-填充模式" class="headerlink" title="7.6.3 TileMode 填充模式"></a>7.6.3 TileMode 填充模式</h3><p>在 RadialGradient 构造函数中，只有一个 TileMode 参数，这说明当填充空白区域时，X 轴和 Y 轴使用同一种填充模式。而不能像 BitmapShader 那样分别指定 X 轴与 Y 轴的填充参数。</p><p>分别设置填充模式为：TileMode.CLAMP、TileMode.MIRROR、TileMode.REPEAT。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7290d14d66a44d1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TileMode.CLAMP"></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-034e859f3e78b1a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TileMode.MIRROR"></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-84766214e50ca249.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TileMode.REPEAT"></p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class TestView extends AppCompatTextView &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private RadialGradient mGradient;</div><div class="line">    private int mRadius;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = getPaint();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</div><div class="line">        super.onSizeChanged(w, h, oldw, oldh);</div><div class="line">        mRadius = w / 10;</div><div class="line">        mGradient = new RadialGradient(w / 2f, h / 2f, mRadius, 0xffff0000, 0xff00ff00, Shader.TileMode.REPEAT);</div><div class="line">        mPaint.setShader(mGradient);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawRect(0, 0, getWidth(), getHeight(), mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="7-6-4-示例：水波纹按钮效果"><a href="#7-6-4-示例：水波纹按钮效果" class="headerlink" title="7.6.4 示例：水波纹按钮效果"></a>7.6.4 示例：水波纹按钮效果</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c5bfca27e35260ff.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">public class TestView extends AppCompatButton &#123;</div><div class="line"></div><div class="line">    private int mX, mY;</div><div class="line">    private ObjectAnimator mAnimator;</div><div class="line">    private int DEFAULT_RADIUS = 50;</div><div class="line">    private int mCurRadius = 0;</div><div class="line">    private RadialGradient mRadialGradient;</div><div class="line">    private Paint mPaint;</div><div class="line"></div><div class="line">    public TestView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs, int defStyle) &#123;</div><div class="line">        super(context, attrs, defStyle);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE,null);</div><div class="line">        mPaint = new Paint();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line"></div><div class="line">        if (mX != event.getX() || mY != mY) &#123;</div><div class="line">            mX = (int) event.getX();</div><div class="line">            mY = (int) event.getY();</div><div class="line"></div><div class="line">            setRadius(DEFAULT_RADIUS);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (event.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line"></div><div class="line">            return true;</div><div class="line">        &#125; else if (event.getAction() == MotionEvent.ACTION_UP) &#123;</div><div class="line"></div><div class="line">            if (mAnimator != null &amp;&amp; mAnimator.isRunning()) &#123;</div><div class="line">                mAnimator.cancel();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (mAnimator == null) &#123;</div><div class="line">                mAnimator = ObjectAnimator.ofInt(this,&quot;radius&quot;,DEFAULT_RADIUS, getWidth());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mAnimator.setInterpolator(new AccelerateInterpolator());</div><div class="line">            mAnimator.addListener(new Animator.AnimatorListener() &#123;</div><div class="line">                @Override</div><div class="line">                public void onAnimationStart(Animator animation) &#123;&#125;</div><div class="line">                @Override</div><div class="line">                public void onAnimationEnd(Animator animation) &#123;</div><div class="line">                    setRadius(0);</div><div class="line">                &#125;</div><div class="line">                @Override</div><div class="line">                public void onAnimationCancel(Animator animation) &#123;&#125;</div><div class="line">                @Override</div><div class="line">                public void onAnimationRepeat(Animator animation) &#123;&#125;</div><div class="line">            &#125;);</div><div class="line">            mAnimator.start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setRadius(final int radius) &#123;</div><div class="line">        mCurRadius = radius;</div><div class="line">        if (mCurRadius &gt; 0) &#123;</div><div class="line">            mRadialGradient = new RadialGradient(mX, mY, mCurRadius, 0x00FFFFFF, 0xFF58FAAC, Shader.TileMode.CLAMP);</div><div class="line">            mPaint.setShader(mRadialGradient);</div><div class="line">        &#125;</div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        canvas.drawCircle(mX, mY, mCurRadius, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;RadialGradient 是 Shader 的另一种实现，它的含义是放射渐变，即它会像一个放射源一样，从一个点开始向外扩散，从一种颜色变成另一种颜色。&lt;/p&gt;
&lt;h3 id=&quot;7
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>07.5 精通自定义 View 之 绘图进阶——Shader 之 LinearGradient</title>
    <link href="http://yoursite.com/2019/07/07/Custom%20View/07.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B9%8B%20LinearGradient/"/>
    <id>http://yoursite.com/2019/07/07/Custom View/07.5 精通自定义 View 之 绘图进阶——Shader 之 LinearGradient/</id>
    <published>2019-07-06T21:00:00.000Z</published>
    <updated>2019-10-04T07:26:26.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>通过 LinearGradient 可以实现线性渐变效果。</p><h3 id="7-5-1-概述"><a href="#7-5-1-概述" class="headerlink" title="7.5.1 概述"></a>7.5.1 概述</h3><h4 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1. 构造函数"></a>1. 构造函数</h4><p>第一个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public LinearGradient(float x0, float y0, float x1, float y1,</div><div class="line">        int color0, int color1, TileMode tile)</div></pre></td></tr></table></figure></p><ul><li>(x0,y0) ：起始渐变点坐标；(x1,y1) ：结束渐变点坐标。</li><li>color0：起始颜色；color1：终止颜色。颜色值必须使用 0xAARRGGBB 形式的 16 进制表示，表示透明度的 AA 一定不能少。</li><li>TileMode tile：与 BitmapShader 一样，用于指定控件区域大于指定的渐变区域时，空白区域的颜色填充方法。</li></ul><p>第二个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public LinearGradient(float x0, float y0, float x1, float y1,</div><div class="line">        int colors[], float positions[], TileMode tile)</div></pre></td></tr></table></figure></p><ul><li>colors[]：用于指定渐变的颜色值数组。同样，颜色值必须使用 0xAARRGGBB 形式的 16 进制表示，表示透明度的 AA 一定不能少。</li><li>positions[]：与渐变的颜色相对应，取值是 0-1 的 float 类型，表示在每一个颜色在整条渐变线中的百分比位置</li></ul><h4 id="2-双色渐变使用示例"><a href="#2-双色渐变使用示例" class="headerlink" title="2. 双色渐变使用示例"></a>2. 双色渐变使用示例</h4><p>自定义一个从左到右的双色渐变控件，代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private int mWidth, mHeight;</div><div class="line">    private LinearGradient mLinearGradient;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</div><div class="line">        super.onSizeChanged(w, h, oldw, oldh);</div><div class="line">        mWidth = getMeasuredWidth();</div><div class="line">        mHeight = getMeasuredHeight();</div><div class="line">        mLinearGradient = new LinearGradient(0, mHeight / 2f, mWidth, mHeight / 2f,</div><div class="line">                0xFFFF0000, 0xFF00FF00, Shader.TileMode.CLAMP);</div><div class="line">        mPaint.setShader(mLinearGradient);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawRect(0, 0, mWidth, mHeight, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-bd6dbc498b7ed192.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="3-多色渐变使用示例"><a href="#3-多色渐变使用示例" class="headerlink" title="3. 多色渐变使用示例"></a>3. 多色渐变使用示例</h4><p>在上面示例的基础上，使用多色渐变来构造 LinearGradient 实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private int mWidth, mHeight;</div><div class="line">    private LinearGradient mLinearGradient;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</div><div class="line">        super.onSizeChanged(w, h, oldw, oldh);</div><div class="line">        mWidth = getMeasuredWidth();</div><div class="line">        mHeight = getMeasuredHeight();</div><div class="line">        int[] colors = &#123;0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFFFFFF00, 0xFF00FFFF&#125;;</div><div class="line">        float[] pos = &#123;0f, 0.2f, 0.4f, 0.6f, 1.0f&#125;;</div><div class="line">        mLinearGradient = new LinearGradient(0, mHeight / 2f, mWidth, mHeight / 2f,</div><div class="line">                colors, pos, Shader.TileMode.CLAMP);</div><div class="line">        mPaint.setShader(mLinearGradient);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawRect(0, 0, mWidth, mHeight, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2d1eccd29d3cf068.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从这里可以看出，渐变的开始点同样是控件左边中点，渐变的结束点也同样是控件右边中点；这里我们指定了五种渐变颜色，而且指定了每个颜色的位置，前四种颜色是按 20% 均匀分布的，最后两种颜色相距 40%；最后通过 canvas.drawRect() 函数把整个控件区域画出来。</p><p>注意：colors 和 pos 的个数一定要相等，也就是说必须指定每一个颜色值的位置。如果元素个数不相等，则会直接报错，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b3a9b6144803c90f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="4-TileMode-填充模式"><a href="#4-TileMode-填充模式" class="headerlink" title="4. TileMode 填充模式"></a>4. TileMode 填充模式</h4><p>从构造函数中可以看出，LiearGradient 只有一个 TileMode 参数，这说明 X 轴与 Y 轴共用这一个 TileMode 填充参数，而不能像 BitmapShader 那样分别指定 X 轴与 Y 轴的填充参数。</p><p>示例：分别指定不同的填充模式</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d78f1af0694fccb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="从上到下依次为：CLAMP、MIRROR、REPEAT"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private int mWidth, mHeight;</div><div class="line">    private LinearGradient mGradientCLAMP, mGradientMIRROR, mGradientREPEAT;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</div><div class="line">        super.onSizeChanged(w, h, oldw, oldh);</div><div class="line">        mWidth = getMeasuredWidth();</div><div class="line">        mHeight = 200;</div><div class="line">        int[] colors = &#123;0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFFFFFF00, 0xFF00FFFF&#125;;</div><div class="line">        float[] pos = &#123;0f, 0.2f, 0.4f, 0.6f, 1.0f&#125;;</div><div class="line">        mGradientCLAMP = new LinearGradient(0, 0, mWidth / 2f, mHeight / 2f,</div><div class="line">                colors, pos, Shader.TileMode.CLAMP);</div><div class="line">        mGradientMIRROR = new LinearGradient(0, mHeight, mWidth / 2f, mHeight * 3f / 2,</div><div class="line">                colors, pos, Shader.TileMode.MIRROR);</div><div class="line">        mGradientREPEAT = new LinearGradient(0, mHeight * 2f, mWidth / 2f, mHeight*5 / 2f,</div><div class="line">                colors, pos, Shader.TileMode.REPEAT);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        mPaint.setShader(mGradientCLAMP);</div><div class="line">        canvas.drawRect(0, 0, mWidth, mHeight, mPaint);</div><div class="line">        mPaint.setShader(mGradientMIRROR);</div><div class="line">        canvas.drawRect(0, mHeight, mWidth, mHeight * 2, mPaint);</div><div class="line">        mPaint.setShader(mGradientREPEAT);</div><div class="line">        canvas.drawRect(0, mHeight * 2, mWidth, mHeight * 3, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="5-Shader-填充与显示区域"><a href="#5-Shader-填充与显示区域" class="headerlink" title="5. Shader 填充与显示区域"></a>5. Shader 填充与显示区域</h4><p>所有 Shader 都是一样的：Shader 的布局和显示是分离的；Shader 总是从控件的左上角开始布局的；如果单张图片无法覆盖整个控件，则会使用 TileMode 重复模式来填充空白区域；而 canvas.draw 系列函数则只表示哪部分区域被显示出来。</p><p>下面利用 drawText() 函数实现一个渐变文字效果。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d3c178884edce57a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private String mText;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setTextSize(80);</div><div class="line">        mText = &quot;欢迎关注先先生的Blog&quot;;</div><div class="line"></div><div class="line">        float width = mPaint.measureText(mText);</div><div class="line">        int[] colors = &#123;0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFFFFFF00, 0xFF00FFFF&#125;;</div><div class="line">        float[] pos = &#123;0f, 0.2f, 0.4f, 0.6f, 1.0f&#125;;</div><div class="line">        LinearGradient gradient = new LinearGradient(0, 0, width / 2f, 0,</div><div class="line">                colors, pos, Shader.TileMode.MIRROR);</div><div class="line">        mPaint.setShader(gradient);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawText(mText, 0, 100, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="7-5-2-示例：闪光文字效果"><a href="#7-5-2-示例：闪光文字效果" class="headerlink" title="7.5.2 示例：闪光文字效果"></a>7.5.2 示例：闪光文字效果</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1df20933fc32f800.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public class TestView extends AppCompatTextView &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private LinearGradient mLinearGradient;</div><div class="line">    private int mDx;</div><div class="line">    private Matrix mMatrix;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = getPaint();</div><div class="line">        mMatrix = new Matrix();</div><div class="line">        int length = (int) mPaint.measureText(getText().toString());</div><div class="line">        createAnim(length);</div><div class="line">        createLinearGradient(length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void createAnim(int length) &#123;</div><div class="line">        ValueAnimator animator = ValueAnimator.ofInt(0, 2 * length);</div><div class="line">        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">                mDx = (Integer) animation.getAnimatedValue();</div><div class="line">                postInvalidate();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        animator.setRepeatMode(ValueAnimator.RESTART);</div><div class="line">        animator.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">        animator.setDuration(2000);</div><div class="line">        animator.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void createLinearGradient(int length) &#123;</div><div class="line">        mLinearGradient = new LinearGradient(-length, 0, 0, 0,</div><div class="line">                new int[]&#123;getCurrentTextColor(), 0xFF00FF00, getCurrentTextColor()&#125;,</div><div class="line">                new float[]&#123;0, 0.5f, 1&#125;,</div><div class="line">                Shader.TileMode.CLAMP);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        mMatrix.reset();</div><div class="line">        mMatrix.setTranslate(mDx, 0);</div><div class="line">        mLinearGradient.setLocalMatrix(mMatrix);</div><div class="line">        mPaint.setShader(mLinearGradient);</div><div class="line"></div><div class="line">        super.onDraw(canvas);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 res/layout/act_main.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line">    &lt;com.xxt.xtest.TestView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_margin=&quot;20dp&quot;</div><div class="line">        android:textSize=&quot;24sp&quot;</div><div class="line">        android:text=&quot;欢迎关注先先生的Blog&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>控件派生自 TextView 的子类，所以可以使用 TextView 的自带方法 getCurrentTextColor() 来获取文字颜色、画笔、文字长度等；利用 Shader.setLocalMatrix(Matrix localM) 设置逐渐平移的矩阵，最后用 ValueAnimator 来控制矩阵平移的位移 mDx，移动距离是从 0 到两倍的 text 距离。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;


&lt;p&gt;通过 LinearGradient 可以实现线性渐变效果。&lt;/p&gt;
&lt;h3 id=&quot;7-5-1-概述&quot;&gt;&lt;a href=&quot;#7-5-1-概述&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>07.4 精通自定义 View 之 绘图进阶——Shader 与 BitmapShader</title>
    <link href="http://yoursite.com/2019/07/07/Custom%20View/07.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Shader%20%E4%B8%8E%20BitmapShader/"/>
    <id>http://yoursite.com/2019/07/07/Custom View/07.4 精通自定义 View 之 绘图进阶——Shader 与 BitmapShader/</id>
    <published>2019-07-06T20:00:00.000Z</published>
    <updated>2019-10-04T07:25:32.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="7-4-1-Shader-概述"><a href="#7-4-1-Shader-概述" class="headerlink" title="7.4.1 Shader 概述"></a>7.4.1 Shader 概述</h3><p>Shader 在三维软件中称之为着色器，是用来给空白图形上色用的。在 PhotoShop 中有一个印章工具，能够指定印章的样式来填充图形。印章的样式可以是图像、颜色、渐变色等。这里的 Shader 实现的效果与印章类似。我们也是通过给 Shader 指定对应的图像、渐变色等来填充图形的。Paint 中有一个函数专门用于设置 Shader，其声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public Shader setShader(Shader shader)</div></pre></td></tr></table></figure></p><p>Shader 类只是一个基类，其中只有两个函数 setLocalMatrix(Matrix localM) 和 getLocalMatrix(Matrix localM)，用来设置坐标变换矩阵的。</p><p>Shader 类其实是一个空类，它的功能主要是靠它的派生类来实现的。继承关系如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f0612d7804eb21c1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="7-4-2-BitmapShader-的基本用法"><a href="#7-4-2-BitmapShader-的基本用法" class="headerlink" title="7.4.2 BitmapShader 的基本用法"></a>7.4.2 BitmapShader 的基本用法</h3><p>它的构造函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public BitmapShader(Bitmap bitmap, TileMode tileX, TileMode tileY)</div></pre></td></tr></table></figure></p><p>这就相当于 PhotoShop 中的印章工具，bitmap 用来指定图案，tileX 用来指定当 X 轴超出单个图片大小时时所使用的重复策略，同样 tileY 用于指定当 Y 轴超出单个图片大小时时所使用的重复策略。</p><p>其中TileMode的取值有：</p><ul><li>TileMode.CLAMP：用边缘色彩填充多余空间。</li><li>TileMode.REPEAT：重复原图像来填充多余空间。</li><li>TileMode.MIRROR：重复使用镜像模式的图像来填充多余空间。</li></ul><h4 id="1-示例"><a href="#1-示例" class="headerlink" title="1. 示例"></a>1. 示例</h4><p>这里使用的印章图像如下图所示 (dog.png)。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-06b392e88addc2f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>中间是一幅小狗头像，四周被四种不同的颜色给包围。设置 Shader 的完整代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        Bitmap mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.dog_edge);</div><div class="line">        mPaint.setShader(new BitmapShader(mBitmap, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawRect(0, 0, getWidth(), getHeight(), mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果图如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-3148e2d732cb7ba9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>给自定义的控件添加上宽高限制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;!--&lt;com.xxt.xtest.TestView</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot; /&gt;--&gt;</div><div class="line">&lt;com.xxt.xtest.TestView</div><div class="line">    android:layout_width=&quot;300dp&quot;</div><div class="line">    android:layout_height=&quot;450dp&quot;</div><div class="line">    android:layout_gravity=&quot;center_horizontal&quot;/&gt;</div></pre></td></tr></table></figure></p><p>效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-6d202b7ca6dc61aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从效果图中可以看出：</p><ul><li>在 X 轴和 Y 轴都使用 REPEAT 模式下，在超出单个图像的区域后，就会重复绘制这个图像。</li><li>绘制是从控件的左上角开始的，而不是从屏幕原点开始的。这点很好理解，因为我们只会在自定义控件上绘图，不会在全屏幕上绘图。</li></ul><h4 id="2-TileMode-模式解析"><a href="#2-TileMode-模式解析" class="headerlink" title="2. TileMode 模式解析"></a>2. TileMode 模式解析</h4><p>上面初步看到了 REPEAT 模式的用法，现在我们分别来看在各个模式下的不同表现。<br><strong>1）TileMode.REPEAT 模式：重复原图像来填充多余空间</strong><br>在更改模式时，只需要更新setShader里的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mPaint.setShader(new BitmapShader(mBmp, TileMode.REPEAT, TileMode.REPEAT));</div></pre></td></tr></table></figure></p><p>在这里，X 轴、Y 轴全部设置成 REPEAT 模式，所以当控件的显示范围超出了单个图的显示范围时，在 X 轴上将使用 REPEAT 模式；同样，在 Y 轴上也将使用 REPEAT 模式。</p><p><strong>2）TileMode.MIRROR 模式：重复使用镜像模式的图像来填充多余空间</strong><br>同样，将 X 轴、Y 轴全部改为 MIRROR 模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mPaint.setShader(new BitmapShader(mBmp, TileMode.MIRROR, TileMode.MIRROR));</div></pre></td></tr></table></figure></p><p>效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1acfebf405a0e336.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在 X 轴上每两张图片的显示都像镜子一样翻转一下。同样，在 Y 轴上每两张图片的显示也都像镜子一样翻转一下。所以这就是镜相效果的作用，镜相效果其实就是在显示下一图片的时候，就相当于两张图片中间放了一个镜子一样。</p><p><strong>3）TileMode.CLAMP：用边缘色彩填充多余空间</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mPaint.setShader(new BitmapShader(mBmp, TileMode.CLAMP, TileMode.CLAMP));</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a3d0c5b36c613db1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>CLAMP 模式的意思就是当控件区域超过当前单个图片的大小时，空白位置的颜色填充就用图片的边缘颜色来填充。</p><p><strong>4）TileMode.CLAMP 与填充顺序</strong><br>当 X 轴、Y 轴全部都是 CLAMP 模式时，X 轴的空白区域会用图像的右侧边缘颜色来填充；Y 轴的空白区域会用图像的底部的边缘颜色来填充，那效果应该是这样的：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-8a5b91ff64280b8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>明显右下角的空白位置根本与图像是不沾边的，那它要用什么颜色来填充呢？是填充上方的蓝色还是填充左侧的绿色呢？</p><p>从最终的效果图来看，这部分填充的颜色是绿色的，可为什么呢？其实这是跟填充顺序有关的，并且是先填充竖向再填充横向。如果是先填充横向再填充竖向，那么右下角颜色应该是蓝色。</p><p><strong>4）使用混合填充模式</strong><br>比如在 X 轴填充空白区域时使用 MIRROR 样式、在填充 Y 轴空白区域时使用REPEAT样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mPaint.setShader(new BitmapShader(mBmp, TileMode.MIRROR, TileMode.REPEAT));</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-9dbadb9051f8c178.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从效果图中可以看出来，首先使用 REPEAT 模式填充 Y 轴，然后使用 MIRROR 模式填充 X 轴。</p><blockquote><p>总之：无论哪两种模式混合或者相同模式，都是先填充 Y 轴，然后填充 X 轴。</p></blockquote><h4 id="3-绘图位置与图像显示"><a href="#3-绘图位置与图像显示" class="headerlink" title="3. 绘图位置与图像显示"></a>3. 绘图位置与图像显示</h4><p>在上面的例子中，我们利用 drawRect 把整个控件大小都给覆盖了，那假如我们只画一个小矩形而不完全覆盖整个控件，那我们 setShader() 函数中所设置的图片是从哪里开始画的呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        Bitmap mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.dog_edge);</div><div class="line">        mPaint.setShader(new BitmapShader(mBitmap, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        float left = getWidth() / 3f;</div><div class="line">        float top = getHeight() / 3f;</div><div class="line">        float right = getWidth() * 2f / 3;</div><div class="line">        float bottom = getHeight() * 2f / 3;</div><div class="line">        canvas.drawRect(left,top,right,bottom, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>即在绘图时，并不是完全覆盖控件大小的，而是取控件中间位置的 1/3 区域显示的。效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-bebdbf0c243f7d16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="7-4-3-示例一：望远镜效果"><a href="#7-4-3-示例一：望远镜效果" class="headerlink" title="7.4.3 示例一：望远镜效果"></a>7.4.3 示例一：望远镜效果</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d4a84ed28fe1ee93.gif?imageMogr2/auto-orient/strip" alt=""></p><p>这里要实现的效果是：根据手指所在的位置，把对应的图像绘制出来。这样看起来就是望远镜效果了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Rect mRect;</div><div class="line">    private int mDx = -1;</div><div class="line">    private int mDy = -1;</div><div class="line">    private Bitmap mBitmap, mBitmapBg;</div><div class="line">    private int mRadius = 300;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.meinv);</div><div class="line">        mRect = new Rect();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        switch (event.getAction()) &#123;</div><div class="line">            case MotionEvent.ACTION_DOWN:</div><div class="line">                mDx = (int) event.getX();</div><div class="line">                mDy = (int) event.getY();</div><div class="line">                invalidate();</div><div class="line">                return true;</div><div class="line">            case MotionEvent.ACTION_MOVE:</div><div class="line">                mDx = (int) event.getX();</div><div class="line">                mDy = (int) event.getY();</div><div class="line">                break;</div><div class="line">            case MotionEvent.ACTION_UP:</div><div class="line">            case MotionEvent.ACTION_CANCEL:</div><div class="line">                mDx = -1;</div><div class="line">                mDy = -1;</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        invalidate();</div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        if (mBitmapBg == null) &#123;</div><div class="line">            mBitmapBg = Bitmap.createBitmap(getWidth(), getHeight(), Bitmap.Config.ARGB_8888);</div><div class="line">            Canvas canvasBg = new Canvas(mBitmapBg);</div><div class="line">            mRect.set(0, 0, getWidth(), getHeight());</div><div class="line">            canvasBg.drawBitmap(mBitmap, null, mRect, mPaint);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mDx != -1 &amp;&amp; mDy != -1) &#123;</div><div class="line">            mPaint.setShader(new BitmapShader(mBitmapBg, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT));</div><div class="line">            canvas.drawCircle(mDx, mDy, mRadius, mPaint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们主要来看下 OnDraw() 函数：<br>在 onDraw() 函数中，第一部分，就是新建一个空白的 bitmap，这个 bitmap 的大小与控件一样，然后把我们的背景图进行拉伸，画到这个空白的 bitmap 上。由于这里的 canvasBg 是用 mBitmapBg 创建的，所以所画的任何图像都会直接显示在 mBitmapBg 上，而我们创建的 mBitmapBg 是与控件一样大的，所以当把 mBitmapBg 做为 Shader 来设置给 mPaint 时，mBitmapBg 会正好覆盖整个控件，而不会有多余的空白像素。</p><p>这里需要注意的就是我们在将原图像画到 mBitmapBg 时，进行了拉伸压缩，把它拉伸到和当前控件一样大小。然后利用 OnMotionEvent 来捕捉用户的手指位置，当用户手指下按时，在手指位置画一个半径为 mRadius 的圆形，把对应的位置的图像显示出来就可以了。</p><h3 id="7-4-4-示例二：生成不规则头像"><a href="#7-4-4-示例二：生成不规则头像" class="headerlink" title="7.4.4 示例二：生成不规则头像"></a>7.4.4 示例二：生成不规则头像</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-817a7e05511f03bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>res/values/attrs.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">    &lt;declare-styleable name=&quot;TestView&quot;&gt;</div><div class="line">        &lt;attr name=&quot;src&quot; format=&quot;reference&quot; /&gt;</div><div class="line">        &lt;attr name=&quot;format&quot; format=&quot;enum&quot;&gt;</div><div class="line">            &lt;enum name=&quot;circle&quot; value=&quot;0&quot;/&gt;</div><div class="line">            &lt;enum name=&quot;rectTangle&quot; value=&quot;1&quot;/&gt;</div><div class="line">        &lt;/attr&gt;</div><div class="line">        &lt;attr name=&quot;radius&quot; format=&quot;integer&quot; /&gt;</div><div class="line">    &lt;/declare-styleable&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure></p><p>自定义控件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap mBitmap;</div><div class="line">    private BitmapShader mBitmapShader;</div><div class="line">    private int mEnumFormat = 0;</div><div class="line">    private int mRadius = 5;</div><div class="line">    private RectF mRectF;</div><div class="line">    private Matrix mMatrix;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) throws Exception&#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init(context,attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs, int defStyle) throws Exception&#123;</div><div class="line">        super(context, attrs, defStyle);</div><div class="line">        init(context,attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init(Context context,AttributeSet attrs) throws Exception&#123;</div><div class="line">        // 提取属性定义</div><div class="line">        TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.TestView);</div><div class="line">        int BitmapID = typedArray.getResourceId(R.styleable.TestView_src,-1);</div><div class="line">        if (BitmapID == -1)&#123;</div><div class="line">            throw new Exception(&quot;TestView 需要定义 Src 属性，而且必须是图像&quot;);</div><div class="line">        &#125;</div><div class="line">        mBitmap = BitmapFactory.decodeResource(getResources(),BitmapID);</div><div class="line">        mEnumFormat = typedArray.getInt(R.styleable.TestView_format,0);</div><div class="line">        if (mEnumFormat == 1)&#123;</div><div class="line">            mRadius = typedArray.getInt(R.styleable.TestView_radius,5);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        typedArray.recycle();</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mBitmapShader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);</div><div class="line">        mRectF = new RectF();</div><div class="line">        mMatrix = new Matrix();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">        int measureWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        int measureHeight = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">        int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">        int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"></div><div class="line">        int width = mBitmap.getWidth();</div><div class="line">        int height = mBitmap.getHeight();</div><div class="line">        width = (measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth: width;</div><div class="line">        height = (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight: height;</div><div class="line">        setMeasuredDimension(width, height);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        float scale = (float) getWidth()/mBitmap.getWidth();</div><div class="line">        mMatrix.reset();</div><div class="line">        mMatrix.setScale(scale, scale);</div><div class="line">        mBitmapShader.setLocalMatrix(mMatrix);</div><div class="line">        mPaint.setShader(mBitmapShader);</div><div class="line"></div><div class="line">        float half = getWidth() / 2f;</div><div class="line"></div><div class="line">        if (mEnumFormat == 0)&#123;</div><div class="line">            canvas.drawCircle(half, half, getWidth() / 2f, mPaint);</div><div class="line">        &#125; else if(mEnumFormat == 1)&#123;</div><div class="line">            mRectF.set(0, 0, getWidth(), getHeight());</div><div class="line">            canvas.drawRoundRect(mRectF, mRadius, mRadius, mPaint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 XML 中使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:padding=&quot;20dp&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line">    &lt;com.xxt.xtest.TestView</div><div class="line">        android:layout_width=&quot;50dp&quot;</div><div class="line">        android:layout_height=&quot;50dp&quot;</div><div class="line">        app:src=&quot;@drawable/meinv&quot;</div><div class="line">        app:format=&quot;circle&quot;/&gt;</div><div class="line">    &lt;com.xxt.xtest.TestView</div><div class="line">        android:layout_width=&quot;100dp&quot;</div><div class="line">        android:layout_height=&quot;100dp&quot;</div><div class="line">        app:src=&quot;@drawable/head&quot;</div><div class="line">        app:format=&quot;circle&quot;/&gt;</div><div class="line">    &lt;com.xxt.xtest.TestView</div><div class="line">        android:layout_width=&quot;100dp&quot;</div><div class="line">        android:layout_height=&quot;100dp&quot;</div><div class="line">        android:layout_marginTop=&quot;10dp&quot;</div><div class="line">        app:src=&quot;@drawable/meinv&quot;</div><div class="line">        app:format=&quot;rectTangle&quot;</div><div class="line">        app:radius=&quot;10&quot;/&gt;</div><div class="line">    &lt;com.xxt.xtest.TestView</div><div class="line">        android:layout_width=&quot;130dp&quot;</div><div class="line">        android:layout_height=&quot;130dp&quot;</div><div class="line">        android:layout_marginTop=&quot;10dp&quot;</div><div class="line">        app:src=&quot;@drawable/head&quot;</div><div class="line">        app:format=&quot;rectTangle&quot;</div><div class="line">        app:radius=&quot;30&quot;/&gt;</div><div class="line">    &lt;com.xxt.xtest.TestView</div><div class="line">        android:layout_width=&quot;150dp&quot;</div><div class="line">        android:layout_height=&quot;150dp&quot;</div><div class="line">        android:layout_marginTop=&quot;10dp&quot;</div><div class="line">        app:src=&quot;@drawable/meinv&quot;</div><div class="line">        app:format=&quot;rectTangle&quot;</div><div class="line">        app:radius=&quot;70&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h3 id=&quot;7-4-1-Shader-概述&quot;&gt;&lt;a href=&quot;#7-4-1-Shader-概述&quot; class=&quot;headerlink&quot; title=&quot;7.4.1 Shader 概述&quot;
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>07.3 精通自定义 View 之 绘图进阶——BlurMaskFilter 发光效果与图片阴影</title>
    <link href="http://yoursite.com/2019/07/07/Custom%20View/07.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94BlurMaskFilter%20%E5%8F%91%E5%85%89%E6%95%88%E6%9E%9C%E4%B8%8E%E5%9B%BE%E7%89%87%E9%98%B4%E5%BD%B1/"/>
    <id>http://yoursite.com/2019/07/07/Custom View/07.3 精通自定义 View 之 绘图进阶——BlurMaskFilter 发光效果与图片阴影/</id>
    <published>2019-07-06T19:00:00.000Z</published>
    <updated>2019-10-04T07:24:20.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2c82cb72b3789dbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在这张效果图中涉及三个发光效果：文字、图形和位图。</p><p>从最后一张美女位图所形成的发光效果中可以看到，与 setShadowLayer() 函数一样，发光效果也只会影响边缘部分图像，内部图像是不受影响的。</p><p>从第三幅图像（红绿各一半的位图）中可以看到：发光效果是无法指定发光颜色的，采用边缘部分的颜色取样来进行模糊发光。所以边缘是什么颜色，发出的光也就是什么颜色的。</p><p>所以初步我们对发光效果有如下结论：</p><ul><li>与 setShadowLayer() 函数一样，发光效果使用的也是高斯模糊算法，并且只会影响边缘部分图像，内部图像是不受影响的。</li><li>发光效果是无法指定发光颜色的，采用边缘部分的颜色取样来进行模糊发光。所以边缘是什么颜色，发出的光也就是什么颜色的。</li></ul><h3 id="7-3-1-概述"><a href="#7-3-1-概述" class="headerlink" title="7.3.1 概述"></a>7.3.1 概述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public MaskFilter setMaskFilter(MaskFilter maskfilter)</div></pre></td></tr></table></figure><p>setMaskFilter() 函数中的 MaskFilter 也是没有具体实现的，是通过派生子类来实现具体的不同功能的。MaskFilter 有两个派生类：BlurMaskFilter 和 EmbossMaskFilter。其中，BlurMaskFilter 就能够实现发光效果；而 EmbossMaskFilter 则可以用于实现浮雕效果，用处很少，这里就不再讲解了。另一点需要注意的是，setMaskFilter() 函数是不支持硬件加速的，必须关闭硬件加速才可以。</p><p>BlurMaskFilter 的构造函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public BlurMaskFilter(float radius, Blur style)</div></pre></td></tr></table></figure></p><ul><li>float radius：用来定义模糊半径，同样是高斯模糊算法。</li><li>Blur style：发光样式，有内 Blur.INNER(内发光)、Blur.SOLID(外发光)、Blur.NORMAL(内外发光)、Blur.OUTER(仅发光部分可见)。</li></ul><p>上面效果图的示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint = new Paint();</div><div class="line">    private Bitmap mHeadBmp;</div><div class="line">    private Rect mRect;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init()&#123;</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setTextSize(50);</div><div class="line">        mHeadBmp = BitmapFactory.decodeResource(getResources(), R.drawable.head);</div><div class="line">        mRect = new Rect();</div><div class="line">        mPaint.setMaskFilter(new BlurMaskFilter(40, BlurMaskFilter.Blur.SOLID));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        canvas.drawText(&quot;xian小涛&quot;,100,100, mPaint);</div><div class="line">        canvas.drawCircle(300,300,50, mPaint);</div><div class="line">        mRect.set(300,500,300 + mHeadBmp.getWidth(),500 + mHeadBmp.getHeight());</div><div class="line">        canvas.drawBitmap(mHeadBmp,null, mRect, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>BlurStyle 发光效果图</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a54f96eedd8b3cf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="依次为：Blur.INNER(内发光)、Blur.SOLID(外发光)、Blur.NORMAL(内外发光)、Blur.OUTER(仅发光部分可见)"></p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private BlurMaskFilter inner, solid, normal, outer;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line"></div><div class="line">        inner = new BlurMaskFilter(40, BlurMaskFilter.Blur.INNER);</div><div class="line">        solid = new BlurMaskFilter(40, BlurMaskFilter.Blur.SOLID);</div><div class="line">        normal = new BlurMaskFilter(40, BlurMaskFilter.Blur.NORMAL);</div><div class="line">        outer = new BlurMaskFilter(40, BlurMaskFilter.Blur.OUTER);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        mPaint.setMaskFilter(inner);</div><div class="line">        canvas.drawCircle(200,200,100, mPaint);</div><div class="line"></div><div class="line">        canvas.translate(300, 0);</div><div class="line">        mPaint.setMaskFilter(solid);</div><div class="line">        canvas.drawCircle(200,200,100, mPaint);</div><div class="line"></div><div class="line">        canvas.translate(300, 0);</div><div class="line">        mPaint.setMaskFilter(normal);</div><div class="line">        canvas.drawCircle(200,200,100, mPaint);</div><div class="line"></div><div class="line">        canvas.translate(300, 0);</div><div class="line">        mPaint.setMaskFilter(outer);</div><div class="line">        canvas.drawCircle(200,200,100, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>其中，Blur.OUTER 比较特殊，在这种模式下仅显示发光效果，会把原图像中除发光部分外的其他部分全部变为透明。</p></blockquote><h3 id="7-3-2-给图片添加纯色阴影"><a href="#7-3-2-给图片添加纯色阴影" class="headerlink" title="7.3.2 给图片添加纯色阴影"></a>7.3.2 给图片添加纯色阴影</h3><p>大家是否可以看出来发光效果与 setShadowLayer() 函数所生成的阴影之间有什么联系？</p><p>先来分析一下 setShadowLayer() 函数的阴影形成过程（假定阴影画笔是灰色）。对于文字和图形，它首先产生一个跟原型一样的灰色副本。然后对这个灰色副本应用 BlurMaskFilter，使其内外发光；这样就形成了所谓的阴影，当然最后再偏移一段距离。</p><p>所以，我们要给图片添加灰色阴影效果，就可以仿照这个过程：先绘制一幅跟图片一样大小的灰色图像，然后给这个灰色图形应用 BlurMaskFilter 使其内外发光，最后偏移原图形一段距离绘制阴影。</p><p>这里涉及到三个点：</p><ul><li>绘制一幅跟图片一样大小的灰色图像。</li><li>对灰色图像应用 BlurMaskFilter 使其内外发光。</li><li>偏移原图形一段距离绘制阴影。</li></ul><h4 id="1-抽取灰色图像"><a href="#1-抽取灰色图像" class="headerlink" title="1. 抽取灰色图像"></a>1. 抽取灰色图像</h4><p>首先来看怎么能绘出一个指定位图所对应的灰色图像。我们知道 canvas.drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint) 中的画笔颜色对画出来的位图是没有任何影响的，所以，如果我们需要画一张对应的灰色图像，就需要新建一张一样大小的空白图，而且新图片的透明度要与原图片保持一致。这样一来，如何从原图片中抽出 Alpha 值成为关键。即我们只需要创建一个与原图片一样大小且Alpha相同的图片即可。</p><p>其实，Bitmap 中已经存在抽取出只具有 Alpha 值图片的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public Bitmap extractAlpha();</div></pre></td></tr></table></figure></p><p>这个函数的功能是：新建一张空白图片，该图片具有与原图片一样的 Alpha 值，把这个新建的 Bitmap 作为结果返回。这个空白图片中每个像素都具有与原图片一样的 Alpha 值，而且具体的颜色是在使用canvas.drawBitmap() 函数绘制时由传入的画笔颜色指定的。</p><p><strong>总结：extractAlpha() 会新建一幅仅具有 Alpha 值的空白图像，而且这张图像的颜色是在使用 canvas.drawBitmap() 函数绘制时传入的画笔颜色指定的。</strong></p><p>下面拿一张图片来做实验，这张 PNG 图片中，只有一只小狗，其余地方都是透明色。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0fa63d9969df5489.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>下面分别利用 extractAlpha() 函数画出该图片所对应的灰色和黑色阴影，效果图如下所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ca07885ef1838c7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原图、灰色阴影、黑色阴影"></p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap mBitmap, mAlphaBmp;</div><div class="line">    private Rect mRect;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mRect = new Rect();</div><div class="line">        mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.dog);</div><div class="line">        mAlphaBmp = mBitmap.extractAlpha();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        int width = 200;</div><div class="line">        int height = width * mAlphaBmp.getHeight() / mAlphaBmp.getWidth();</div><div class="line">        // 绘制原图</div><div class="line">        mRect.set(50, 50, 50 + width, 50 + height);</div><div class="line">        canvas.drawBitmap(mBitmap, null, mRect, mPaint);</div><div class="line">        // 绘制灰色阴影</div><div class="line">        canvas.translate(width + 100, 0);</div><div class="line">        mPaint.setColor(Color.GRAY);</div><div class="line">        canvas.drawBitmap(mAlphaBmp, null, mRect, mPaint);</div><div class="line">        // 绘制黑色阴影</div><div class="line">        canvas.translate(width + 100, 0);</div><div class="line">        mPaint.setColor(Color.BLACK);</div><div class="line">        canvas.drawBitmap(mAlphaBmp, null, mRect, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="2-绘制阴影"><a href="#2-绘制阴影" class="headerlink" title="2. 绘制阴影"></a>2. 绘制阴影</h4><p>在上面灰色纯色图像的基础上，将此灰色图像使用 BlurMaskFilter 使其内外发光。然后再在灰色模糊阴影的基础上画上原图像，就形成了模糊阴影。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap mBitmap, mAlphaBmp;</div><div class="line">    private Rect mRect;</div><div class="line">    private BlurMaskFilter mFilter;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mRect = new Rect();</div><div class="line">        mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.dog);</div><div class="line">        mAlphaBmp = mBitmap.extractAlpha();</div><div class="line">        mFilter = new BlurMaskFilter(30, BlurMaskFilter.Blur.NORMAL);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        int width = 200;</div><div class="line">        int height = width * mAlphaBmp.getHeight() / mAlphaBmp.getWidth();</div><div class="line">        mRect.set(50, 50, 50 + width, 50 + height);</div><div class="line"></div><div class="line">        // 绘制灰色阴影</div><div class="line">        mPaint.setColor(Color.GRAY);</div><div class="line">        mPaint.setMaskFilter(mFilter);</div><div class="line">        canvas.drawBitmap(mAlphaBmp, null, mRect, mPaint);</div><div class="line"></div><div class="line">        // 绘制原图</div><div class="line">        mPaint.setMaskFilter(null);</div><div class="line">        canvas.translate(-10, -10);</div><div class="line">        canvas.drawBitmap(mBitmap, null, mRect, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-64d6af67e125a769.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="7-3-3-封装控件"><a href="#7-3-3-封装控件" class="headerlink" title="7.3.3 封装控件"></a>7.3.3 封装控件</h3><p>将它封装成一个控件，具有如下功能：</p><ul><li>让用户定义图片内容。</li><li>让用户定义偏移距离。</li><li>让用户定义阴影颜色和阴影模糊程度。</li><li>可以使用wrap_content属性自适应大小。</li></ul><blockquote><p>下面程序经过多次测试，效果并不完美，待完善。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7a5cfd013c874038.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>res/values/xshadow.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">    &lt;declare-styleable name=&quot;XShadowImageView&quot;&gt;</div><div class="line">        &lt;attr name=&quot;src&quot; format=&quot;reference&quot;/&gt;</div><div class="line">        &lt;attr name=&quot;shadowDx&quot; format=&quot;integer&quot; /&gt;</div><div class="line">        &lt;attr name=&quot;shadowDy&quot; format=&quot;integer&quot; /&gt;</div><div class="line">        &lt;attr name=&quot;shadowColor&quot; format=&quot;color&quot;/&gt;</div><div class="line">        &lt;attr name=&quot;shadowRadius&quot; format=&quot;float&quot;/&gt;</div><div class="line">    &lt;/declare-styleable&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure></p><p>src/…/XShadowImageView.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">public class XShadowImageView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Bitmap mBitmap, mShadowBitmap;</div><div class="line">    private int mDx, mDy;</div><div class="line">    private float mRadius;</div><div class="line">    private int mShadowColor;</div><div class="line">    private BlurMaskFilter mBlurMaskFilter;</div><div class="line">    private Rect mRect;</div><div class="line"></div><div class="line">    public XShadowImageView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public XShadowImageView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">        init(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        // 禁用硬件加速</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line"></div><div class="line">        // 提取属性</div><div class="line">        TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.XShadowImageView);</div><div class="line">        mDx = ta.getInt(R.styleable.XShadowImageView_shadowDx, 0);</div><div class="line">        mDy = ta.getInt(R.styleable.XShadowImageView_shadowDy, 0);</div><div class="line">        mRadius = ta.getFloat(R.styleable.XShadowImageView_shadowRadius, 0);</div><div class="line">        mShadowColor = ta.getInt(R.styleable.XShadowImageView_shadowColor, Color.BLACK);</div><div class="line">        int bitmapId = ta.getResourceId(R.styleable.XShadowImageView_src, -1);</div><div class="line">        if (bitmapId != -1) &#123;</div><div class="line">            mBitmap = BitmapFactory.decodeResource(getResources(), bitmapId);</div><div class="line">        &#125;</div><div class="line">        ta.recycle();</div><div class="line"></div><div class="line">        // 其他初始化</div><div class="line">        mRect = new Rect();</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(mShadowColor);</div><div class="line">        mBlurMaskFilter = new BlurMaskFilter(mRadius, BlurMaskFilter.Blur.NORMAL);</div><div class="line">        if (mBitmap != null) &#123;</div><div class="line">            mShadowBitmap = mBitmap.extractAlpha();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">        int measureWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        int measureHeight = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">        int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">        int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"></div><div class="line">        int width = mBitmap.getWidth();</div><div class="line">        int height = mBitmap.getHeight();</div><div class="line">        width = (measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth: width;</div><div class="line">        height = (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight: height;</div><div class="line">        setMeasuredDimension(width, height);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        if (mBitmap != null) &#123;</div><div class="line">            int width = getWidth() - mDx;</div><div class="line">            int height = getHeight() - mDy;</div><div class="line"></div><div class="line">            // 绘制阴影</div><div class="line">            mPaint.setMaskFilter(mBlurMaskFilter);</div><div class="line">            mRect.set(mDx, mDy, width, height);</div><div class="line">            canvas.drawBitmap(mShadowBitmap, null, mRect, mPaint);</div><div class="line"></div><div class="line">            // 绘制原图像</div><div class="line">            mPaint.setMaskFilter(null);</div><div class="line">            mRect.set(0, 0, width, height);</div><div class="line">            canvas.drawBitmap(mBitmap, null, mRect, mPaint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.xxt.xtest.XShadowImageView</div><div class="line">        android:layout_width=&quot;100dp&quot;</div><div class="line">        android:layout_height=&quot;100dp&quot;</div><div class="line">        android:layout_gravity=&quot;center_horizontal&quot;</div><div class="line">        app:src=&quot;@drawable/head&quot;</div><div class="line">        app:shadowDx=&quot;30&quot;</div><div class="line">        app:shadowDy=&quot;30&quot;</div><div class="line">        app:shadowRadius=&quot;30.0&quot;</div><div class="line">        app:shadowColor=&quot;@android:color/black&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;com.xxt.xtest.XShadowImageView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_gravity=&quot;center_horizontal&quot;</div><div class="line">        app:src=&quot;@drawable/head&quot;</div><div class="line">        app:shadowDx=&quot;30&quot;</div><div class="line">        app:shadowDy=&quot;30&quot;</div><div class="line">        app:shadowRadius=&quot;30.0&quot;</div><div class="line">        app:shadowColor=&quot;@android:color/holo_red_dark&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;com.xxt.xtest.XShadowImageView</div><div class="line">        android:layout_width=&quot;260dp&quot;</div><div class="line">        android:layout_height=&quot;360dp&quot;</div><div class="line">        android:layout_gravity=&quot;center_horizontal&quot;</div><div class="line">        app:src=&quot;@drawable/meinv&quot;</div><div class="line">        app:shadowDx=&quot;40&quot;</div><div class="line">        app:shadowDy=&quot;40&quot;</div><div class="line">        app:shadowRadius=&quot;40.0&quot;</div><div class="line">        app:shadowColor=&quot;@android:color/holo_red_dark&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;


&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14186083-2c82cb72b3789dbb.png?ima
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>07.2 精通自定义 View 之 绘图进阶——setShadowLayer 与阴影效果</title>
    <link href="http://yoursite.com/2019/07/07/Custom%20View/07.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94setShadowLayer%20%E4%B8%8E%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/"/>
    <id>http://yoursite.com/2019/07/07/Custom View/07.2 精通自定义 View 之 绘图进阶——setShadowLayer 与阴影效果/</id>
    <published>2019-07-06T18:00:00.000Z</published>
    <updated>2019-10-04T07:23:02.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>利用 layer-list 只能实现按钮的阴影效果，对于文字和图片都无法实现阴影效果，除了 layer-list，我们只能用自定义控件来实现阴影效果了，Paint 中有一个专门用来实现阴影效果的函数 setShadowLayer，我们先来看看这个函数实现的阴影效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-fea6ceb64d2ef245.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从效果图中可以看出 setShadowLayer 函数能够实现：</p><ul><li>定制阴影模糊程度</li><li>定制阴影偏移距离</li><li>清除阴影和显示阴影</li></ul><h3 id="7-2-1-setShadowLayer-构造函数"><a href="#7-2-1-setShadowLayer-构造函数" class="headerlink" title="7.2.1 setShadowLayer() 构造函数"></a>7.2.1 setShadowLayer() 构造函数</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void setShadowLayer(float radius, float dx, float dy, int color)</div></pre></td></tr></table></figure><ul><li>float radius：意思是模糊半径，radius 越大越模糊，越小越清晰，但是如果 radius 设置为0，则阴影消失不见。</li><li>float dx：阴影的横向偏移距离，正值向右偏移，负值向左偏移。</li><li>float dy：阴影的纵向偏移距离，正值向下偏移，负值向上偏移。</li><li>int color：绘制阴影的画笔颜色，即阴影的颜色（对图片阴影无效）。</li></ul><p>setShadowLayer 使用的是高斯模糊算法，高斯模糊的具体算法是：对于正在处理的每一个像素，取周围若干个像素的 RGB 值并且平均，然后这个平均值就是模糊处理过的像素。如果对图片中的所有像素都这么处理的话，处理完成的图片就会变得模糊。其中，所取周围像素的半径就是模糊半径。所以，模糊半径越大，所得平均像素与原始像素相差就越大，也就越模糊。</p><p>绘制阴影的画笔颜色为什么对图片无效？</p><p>从上面的效果图中可以看出，使用 setShadowLayer 所产生的阴影，对于文字和绘制的图形的阴影都是使用自定义的阴影画笔颜色来画的；而图片的阴影则是直接产生一张相同的图片，仅对阴影图片的边缘进行模糊。之所以生成一张相同的背景图片，是因为如果统一使用某一种颜色来做阴影可能会与图片的颜色相差很大，而且不协调，比如某张图片的色彩非常丰富，而阴影如果使用灰色来做，可能就会显得很突兀，所以为了解决这个问题，针对图片的阴影就不再是统一颜色了，而是复制出这张图片，把复制出的图片的边缘进行模糊，做为阴影。但这样又会引起一个问题，就是如果我们想把图片的阴影做成灰色怎么办？使用 setShadowLayer 自动生成阴影是没办法了，在下篇我们会具体来讲，如何给图片添加指定颜色的阴影。</p><blockquote><p>注意：setShadowLayer 只有文字绘制阴影支持硬件加速，其它都不支持硬件加速，为了方便起见，需要在自定义控件中禁用硬件加速。</p></blockquote><h4 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-fc3493677e1727cb.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint = new Paint();</div><div class="line">    private Bitmap mHeadBmp;</div><div class="line">    private Rect mRect;</div><div class="line">    private int mRadius = 1;</div><div class="line">    private int mDx = 10;</div><div class="line">    private int mDy = 10;</div><div class="line">    private boolean mSetShadow = true;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init()&#123;</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setTextSize(50);</div><div class="line">        mHeadBmp = BitmapFactory.decodeResource(getResources(), R.drawable.head);</div><div class="line">        mRect = new Rect();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        if (mSetShadow) &#123;</div><div class="line">            mPaint.setShadowLayer(mRadius, mDx, mDy, Color.GRAY);</div><div class="line">        &#125; else &#123;</div><div class="line">            mPaint.clearShadowLayer();</div><div class="line">        &#125;</div><div class="line">        canvas.drawText(&quot;xian小涛&quot;,100,100, mPaint);</div><div class="line">        canvas.drawCircle(200,200,50, mPaint);</div><div class="line">        mRect.set(200,300,200 + mHeadBmp.getWidth(),300 + mHeadBmp.getHeight());</div><div class="line">        canvas.drawBitmap(mHeadBmp,null, mRect, mPaint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void changeRadius() &#123;</div><div class="line">        mRadius++;</div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void changeDx() &#123;</div><div class="line">        mDx+=5;</div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void changeDy() &#123;</div><div class="line">        mDy+=5;</div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void clearShadow()&#123;</div><div class="line">        mSetShadow = false;</div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void showShadow()&#123;</div><div class="line">        mSetShadow = true;</div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123;</div><div class="line"></div><div class="line">    private TestView mView;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        mView = findViewById(R.id.view);</div><div class="line">        findViewById(R.id.radius_btn).setOnClickListener(this);</div><div class="line">        findViewById(R.id.dx_btn).setOnClickListener(this);</div><div class="line">        findViewById(R.id.dy_btn).setOnClickListener(this);</div><div class="line">        findViewById(R.id.clear_btn).setOnClickListener(this);</div><div class="line">        findViewById(R.id.show_btn).setOnClickListener(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onClick(View v) &#123;</div><div class="line">        switch (v.getId())&#123;</div><div class="line">            case R.id.radius_btn:</div><div class="line">                mView.changeRadius();</div><div class="line">                break;</div><div class="line">            case R.id.dx_btn:</div><div class="line">                mView.changeDx();</div><div class="line">                break;</div><div class="line">            case R.id.dy_btn:</div><div class="line">                mView.changeDy();</div><div class="line">                break;</div><div class="line">            case R.id.clear_btn:</div><div class="line">                mView.clearShadow();</div><div class="line">                break;</div><div class="line">            case R.id.show_btn:</div><div class="line">                mView.showShadow();</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="7-2-2-清除阴影"><a href="#7-2-2-清除阴影" class="headerlink" title="7.2.2 清除阴影"></a>7.2.2 清除阴影</h3><p>清除阴影其实有两个方法，可以将setShadowLayer的radius的值设为0，也可以使用专门的清除阴影的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void clearShadowLayer()</div></pre></td></tr></table></figure></p><p>具体效果见上面例子。</p><h3 id="7-2-3-示例：给文字添加阴影"><a href="#7-2-3-示例：给文字添加阴影" class="headerlink" title="7.2.3 示例：给文字添加阴影"></a>7.2.3 示例：给文字添加阴影</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-37733c90da49b0ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从图中可以看到，TextView、Button、EditText 中的文字自定添加了阴影。而且对于 EditText 而言，新输入的文字依然有阴影效果。</p><p>setShadowLayer 是 API 1 就已经引入的函数，而且添加了 TextView 类 和 TextView 的派生类来支持阴影设置。TextView 的派生类如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b2bc9117410494fb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="1-通过-XML-属性添加阴影"><a href="#1-通过-XML-属性添加阴影" class="headerlink" title="1. 通过 XML 属性添加阴影"></a>1. 通过 XML 属性添加阴影</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;TextView</div><div class="line">    ......</div><div class="line">    android:shadowRadius=&quot;3&quot;</div><div class="line">    android:shadowDx=&quot;5&quot;</div><div class="line">    android:shadowDy=&quot;5&quot;</div><div class="line">    android:shadowColor=&quot;@android:color/darker_gray&quot;/&gt;</div></pre></td></tr></table></figure><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line"></div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;使用XML添加阴影效果&quot;</div><div class="line">        android:shadowRadius=&quot;3&quot;</div><div class="line">        android:shadowDx=&quot;5&quot;</div><div class="line">        android:shadowDy=&quot;5&quot;</div><div class="line">        android:shadowColor=&quot;@android:color/darker_gray&quot;/&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/radius_btn&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;使用XML添加阴影效果&quot;</div><div class="line">        android:shadowRadius=&quot;3&quot;</div><div class="line">        android:shadowDx=&quot;5&quot;</div><div class="line">        android:shadowDy=&quot;5&quot;</div><div class="line">        android:shadowColor=&quot;@android:color/darker_gray&quot;/&gt;</div><div class="line">    &lt;EditText</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;使用XML添加阴影效果&quot;</div><div class="line">        android:shadowRadius=&quot;3&quot;</div><div class="line">        android:shadowDx=&quot;5&quot;</div><div class="line">        android:shadowDy=&quot;5&quot;</div><div class="line">        android:shadowColor=&quot;@android:color/darker_gray&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><h4 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h4><p>TextView 及其派生类都有一个 Paint.setShadowLayer 的同名方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void setShadowLayer(float radius, float dx, float dy, int color)</div></pre></td></tr></table></figure></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TextView tv = findViewById(R.id.tv);</div><div class="line">tv.setShadowLayer(3, 5, 5, Color.GRAY);</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;利用 layer-list 只能实现按钮的阴影效果，对于文字和图片都无法实现阴影效果，除了 layer-list，我们只能用自定义控件来实现阴影效果了，Paint 中有一个专门用来实
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>07.1 精通自定义 View 之 绘图进阶——贝济埃曲线</title>
    <link href="http://yoursite.com/2019/07/07/Custom%20View/07.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E8%B4%9D%E6%B5%8E%E5%9F%83%E6%9B%B2%E7%BA%BF/"/>
    <id>http://yoursite.com/2019/07/07/Custom View/07.1 精通自定义 View 之 绘图进阶——贝济埃曲线/</id>
    <published>2019-07-06T17:00:00.000Z</published>
    <updated>2019-10-04T07:22:00.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="7-1-1-概述"><a href="#7-1-1-概述" class="headerlink" title="7.1.1 概述"></a>7.1.1 概述</h3><p>在 Path 的系列函数中，除了一些基本的设置和绘图用法外，还有一个强大的工具——贝济埃曲线。它能将利用 moveTo、lineTo 连接的生硬路径变得平滑，也能够实现很多炫酷的效果，比如水波纹等。</p><h4 id="1-贝赛尔曲线来源"><a href="#1-贝赛尔曲线来源" class="headerlink" title="1. 贝赛尔曲线来源"></a>1. 贝赛尔曲线来源</h4><p>贝塞尔曲线于 1962 年，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由 Paul de Casteljau 于 1959 年运用 de Casteljau 算法开发，以稳定数值的方法求出贝塞尔曲线。</p><p>在数学的数值分析领域中，贝赛尔曲线（Bézier 曲线）是电脑图形学中相当重要的参数曲线。更高维度的广泛化贝塞尔曲线就称作贝塞尔曲面，其中贝塞尔三角是一种特殊的实例。</p><h4 id="2-贝济埃曲线公式"><a href="#2-贝济埃曲线公式" class="headerlink" title="2. 贝济埃曲线公式"></a>2. 贝济埃曲线公式</h4><p><strong>1）一阶贝济埃曲线</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d7535084366336a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-88a1d9f33c56d0d5?imageMogr2/auto-orient/strip" alt=""></p><p>P0 为起点、P1 为终点，t 表示当前时间，B(t) 表示公式的结果值。<br>注意，曲线的意义就是公式结果 B(t) 随时间的变化，其取值所形成的轨迹。在动画中，黑色点表示在当前时间 t 下公式 B(t) 的取值。而红色的那条线就不在各个时间点下不同取值的 B(t) 所形成的轨迹。</p><p>总而言之：对于一阶贝济埃曲线，大家可以理解为在起始点和终点形成的这条直线上，匀速移动的点。</p><p><strong>2）二阶贝济埃曲线</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d0fab250e052d246?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-723ce7c1ee1e0016?imageMogr2/auto-orient/strip" alt=""></p><p>在这里 P0 是起始点，P2 是终点，P1 是控制点。<br>假设将时间定在 t=0.25 的时刻，此时的状态如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b43003ea2bdfb507?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>首先，P0 点和 P1 点形成了一条贝济埃曲线，还记得我们上面对一阶贝济埃曲线的总结么：就是一个点在这条直线上做匀速运动；所以 P0-P1 这条直线上的移动的点就是 Q0。</p><p>同样，P1、P2 形成了一条一阶贝济埃曲线，在这条一阶贝济埃曲线上，它们的随时间移动的点是 Q1。</p><p>最后，动态点 Q0 和 Q1 又形成了一条一阶贝济埃曲线，在它们这条一阶贝济埃曲线动态移动的点是 B。而 B 的移动轨迹就是这个二阶贝济埃曲线的最终形态。从上面的讲解大家也可以知道，之所以叫它二阶贝济埃曲线是因为，B 的移动轨迹是建立在两个一阶贝济埃曲线的中间点 Q0、Q1 的基础上的。</p><p>在理解了二阶贝赛尔曲线的形成原理以后，我们就不难理解三阶贝赛尔曲线了。</p><p><strong>3）三阶贝济埃曲线</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-044ad9428fcbbc29?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-2c38ba6a9c8950a3?imageMogr2/auto-orient/strip" alt=""></p><p>同样，我们取其中一点来讲解轨迹的形成原理，当 t=0.25 时,此时状态如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f67fcc49e576bc40?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>同样，P0 是起始点，P3 是终点；P1 是第一个控制点，P2 是第二个控制点。</p><p>首先，这里有三条一阶贝济埃曲线，分别是 P0-P1、P1-P2、P2-P3，他们随时间变化的点分别为 Q0、Q1、Q2。然后是由 Q0、Q1、Q2 这三个点，再次连接，形成了两条一阶贝济埃曲线，分别是Q0-Q1、Q1-Q2，他们随时间变化的点为 R0、R1。</p><p>同样，R0 和 R1 同样可以连接形成一条一阶贝济埃曲线，在 R0-R1 这条贝赛尔曲线上随时间移动的点是 B，而 B 的移动轨迹就是这个三阶贝济埃曲线的最终形状。</p><p>从上面的解析大家可以看出，所谓几阶贝济埃曲线，全部是由一条条一阶贝济埃曲线搭起来的。在上图中，形成一阶贝济埃曲线的直线是灰色的，形成二阶贝济埃曲线线是绿色的，形成三阶贝济埃曲线的线是蓝色的。</p><p>在理解了上面的二阶和三阶贝济埃曲线以后，我们再来看几个贝济埃曲线的动态图。</p><p><strong>4）四阶贝济埃曲线</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-91e7647f793fd876?imageMogr2/auto-orient/strip" alt=""></p><p><strong>5）五阶贝济埃曲线</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e28ef335e39c174f?imageMogr2/auto-orient/strip" alt=""></p><h4 id="3-贝济埃曲线与-PhotoShop-钢笔工具"><a href="#3-贝济埃曲线与-PhotoShop-钢笔工具" class="headerlink" title="3. 贝济埃曲线与 PhotoShop 钢笔工具"></a>3. 贝济埃曲线与 PhotoShop 钢笔工具</h4><p>在专业绘图工具 Photoshop 中，有一个钢笔工具，它使用的路径弯曲效果就是二阶贝济埃曲线，下面利用 Photoshop 的钢笔工具来得出二阶贝济埃曲线的相关控制点。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-003dae5d4ff785c8?imageMogr2/auto-orient/strip" alt=""></p><p>我们拿最终成形的图形来看一下为什么钢笔工具是二阶贝济埃曲线：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-cb15295694db8eff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>右图演示的假设某一点 t=0.25 时，动态点 B 的位置图。<br>同样，这里 P0 是起始点，P2 是终点，P1 是控制点。<br>P0-P1、P1-P2 形成了第一层的一阶贝济埃曲线。它们随时间的动态点分别是 Q0、Q1；动态点 Q0、Q1 又形成了第二层的一阶贝济埃曲线，它们的动态点是 B。而 B 的轨迹跟钢笔工具的形状是完全一样的，所以说钢笔工具的拉伸效果使用的是二阶贝济埃曲线。</p><p>这里需要注意的是，我们在使用钢笔工具时，拖动的是 P5 点。其实二阶贝济埃曲线的控制点是其对面的 P1 点，钢笔工具这样设计是当然是因为操作起来比较方便。</p><h3 id="7-1-2-贝济埃曲线之-quadTo"><a href="#7-1-2-贝济埃曲线之-quadTo" class="headerlink" title="7.1.2 贝济埃曲线之 quadTo"></a>7.1.2 贝济埃曲线之 quadTo</h3><p>在 Path 类中有四个方法与贝济埃曲线相关，分别是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 二阶济埃尔</div><div class="line">public void quadTo(float x1, float y1, float x2, float y2)</div><div class="line">public void rQuadTo(float dx1, float dy1, float dx2, float dy2)</div><div class="line">// 三阶济埃尔</div><div class="line">public void cubicTo(float x1, float y1, float x2, float y2,float x3, float y3)</div><div class="line">public void rCubicTo(float x1, float y1, float x2, float y2,float x3, float y3)</div></pre></td></tr></table></figure></p><p>在这四个函数中 quadTo、rQuadTo 是二阶贝济埃曲线，cubicTo、rCubicTo 是三阶贝济埃曲线；我们这篇文章以二阶贝济埃曲线的 quadTo、rQuadTo 为主，三阶贝济埃曲线 cubicTo、rCubicTo 用的使用方法与二阶贝济埃曲线类似，用处也比较少，这篇就不再细讲了。</p><h4 id="1-quadTo-使用原理"><a href="#1-quadTo-使用原理" class="headerlink" title="1. quadTo 使用原理"></a>1. quadTo 使用原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void quadTo(float x1, float y1, float x2, float y2)</div></pre></td></tr></table></figure><p>参数中 (x1,y1) 是控制点坐标，(x2,y2) 是终点坐标。<br>大家可能会有一个疑问：有控制点和终点坐标，那起始点是多少呢？<br>整条线的起始点是通过 Path.moveTo(x,y) 来指定的，而如果我们连续调用 quadTo()，前一个 quadTo() 的终点，就是下一个 quadTo() 函数的起点；如果初始没有调用 Path.moveTo(x,y) 来指定起始点，则默认以控件左上角(0,0)为起始点。大家可能还是有点迷糊，下面我们就举个例子来看看，我们利用 quadTo() 来画下面的这条波浪线：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-8c334c61c48848cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>下面分析一下，在这条路径轨迹中，控制点分别在哪个位置，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e37060659bbc933e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>我们先看 P0-P2 这条轨迹，P0 是起点，假设位置坐标是 (100,300)，P2 是终点，假充位置坐标是 (300,300)；在以 P0 为起始点，P2 为终点这条二阶贝济埃曲线上，P1 是控制点，很明显 P1 大概在 P0、P2 中间的位置，所以它的 X 坐标应该是 200，关于 Y 坐标，我们无法确定，但很明显的是 P1 在 P0、P2 点的上方，也就是它的 Y 值比它们的小，所以根据钢笔工具上面的位置，我们让 P1 的比 P0、P2 的小 100，所以 P1的坐标是 (200，200)。</p><p>同理，不难求出在 P2-P4 这条二阶贝济埃曲线上，它们的控制点 P3 的坐标位置应该是 (400,400)。</p><p>所以我们就可以自定义一个控件，并重写它的 onDraw() 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setStrokeWidth(4);</div><div class="line">        mPaint.setColor(Color.GRAY);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setAntiAlias(true);</div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        mPath.moveTo(100, 300);</div><div class="line">        mPath.quadTo(200, 200, 300, 300);</div><div class="line">        mPath.quadTo(400, 400, 500, 300);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通过这个例子希望大家知道两点：</p><ul><li>整条线的起始点是通过 Path.moveTo(x,y) 来指定的，如果初始没有调用 Path.moveTo(x,y) 来指定起始点，则默认以控件左上角 (0,0) 为起始点。</li><li>如果我们连续调用 quadTo()，前一个 quadTo() 的终点，就是下一个 quadTo() 函数的起点。</li></ul><h4 id="2-示例：手指轨迹"><a href="#2-示例：手指轨迹" class="headerlink" title="2. 示例：手指轨迹"></a>2. 示例：手指轨迹</h4><p>要实现手指轨迹其实是非常简单的，我们只需要在自定义中拦截 OnTouchEvent，然后根据手指的移动轨迹来绘制 Path 即可。最简单的方法就是直接使用 Path.lineTo() 就能实现把各个点连接起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(4);</div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        switch (event.getAction())&#123;</div><div class="line">            case MotionEvent.ACTION_DOWN:</div><div class="line">                mPath.moveTo(event.getX(), event.getY());</div><div class="line">                return true;</div><div class="line">            case MotionEvent.ACTION_MOVE:</div><div class="line">                mPath.lineTo(event.getX(), event.getY());</div><div class="line">                invalidate();</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>虽然实现了画出手指的移动轨迹，但我们仔细来看看画出来的图：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d6cd12f5a2fbbdd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>我们把轨迹放大，明显看出，在两个点连接处有明显的转折，而且在轨迹顶部位置横纵坐标变化比较快的位置，看起来跟图片这大后的马赛克一样；利用 Path 绘图，是不可能出现马赛克的，因为除了 Bitmap 以外的任何 canvas 绘图全部都是矢量图，也就是利用数学公式来作出来的图，无论放在多大屏幕上，都不可能会出现马赛克。这里利用 Path 绘图，在轨迹顶部之所以看起来像是马赛克是因为这个轨迹是由各个不同点之间连线写出来的，而之间并没有平滑过渡，所以当坐标变化比较剧烈时，线与线之间的转折就显得特别明显了。</p><p>所以要想优化这种效果，就得实现线与线之间的平滑过渡，很显然，二阶贝济埃曲线就是干这个事的。下面我们就利用我们新学的 Path.quadTo 函数来重新实现下移动轨迹效果。</p><h4 id="3-优化：使用-Path-quadTo-函数实现手势过渡"><a href="#3-优化：使用-Path-quadTo-函数实现手势过渡" class="headerlink" title="3. 优化：使用 Path.quadTo() 函数实现手势过渡"></a>3. 优化：使用 Path.quadTo() 函数实现手势过渡</h4><p>使用 Path.lineTo() 的最大问题就是线段转折处不够平滑。Path.quadTo() 可以实现平滑过渡，但使用 Path.quadTo() 的最大问题是，如何找到起始点和结束点。</p><p>下图中，有用绿点表示的三个点，连成的两条直线，很明显他们转折处是有明显折痕的</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-88af940cfd85bb19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>下面我们在 PhotoShop 中利用钢笔工具，看如何才能实现这两条线之间的转折。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-65b3cc5c9634eb46?imageMogr2/auto-orient/strip" alt=""></p><p>最终的贝济埃曲线连接如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b26dea192018dcc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从这两个线段中可以看出，我们使用 Path.lineTo() 的时候，是直接把手指触点 A、B、C 给连起来。而钢笔工具要实现这三个点间的流畅过渡，就只能将这两个线段的中间点做为起始点和结束点，而将手指的倒数第二个触点 B 做为控制点。</p><p>大家可能会觉得，那这样，在结束的时候，A 到 P0 和 P1 到 C1 的这段距离岂不是没画进去？是的，如果 Path 最终没有 close 的话，这两段距离是被抛弃掉的。因为手指间滑动时，每两个点间的距离很小，所以 P1 到 C 之间的距离可以忽略不计。</p><p>下面我们就利用这种方法在photoshop中求证，在连接多个线段时，是否能行？</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c8dbebc11cee4204.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在这个图形中，有很多点连成了弯弯曲曲的线段，我们利用上面我们讲的，将两个线段的中间做为二阶贝济埃曲线的起始点和终点，把上一个手指的位置做为控制点，来看看是否真的能组成平滑的连线<br>整个连接过程如动画所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c2167deb01b0a691?imageMogr2/auto-orient/strip" alt=""></p><p>在最终的路径中看来，各个点间的连线是非常平滑的。从这里也可以看出，在为了实现平滑效果，我们只能把开头的线段一半和结束的线段的一半抛弃掉。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a218b1d8f0dce88d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line">    private float mPreX, mPreY;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(4);</div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        switch (event.getAction())&#123;</div><div class="line">            case MotionEvent.ACTION_DOWN:</div><div class="line">                mPath.moveTo(event.getX(), event.getY());</div><div class="line">                mPreX = event.getX();</div><div class="line">                mPreY = event.getY();</div><div class="line">                return true;</div><div class="line">            case MotionEvent.ACTION_MOVE:</div><div class="line">                float endX = (mPreX + event.getX()) / 2;</div><div class="line">                float endY = (mPreY + event.getY()) / 2;</div><div class="line">                mPath.quadTo(mPreX, mPreY, endX, endY);</div><div class="line">                mPreX = event.getX();</div><div class="line">                mPreY = event.getY();</div><div class="line">                invalidate();</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="7-1-3-贝济埃曲线之-rQuadTo"><a href="#7-1-3-贝济埃曲线之-rQuadTo" class="headerlink" title="7.1.3 贝济埃曲线之 rQuadTo"></a>7.1.3 贝济埃曲线之 rQuadTo</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void rQuadTo(float dx1, float dy1, float dx2, float dy2)</div></pre></td></tr></table></figure><ul><li>dx1：控制点 X 坐标，表示相对上一个终点 X 坐标的位移坐标，可为负值，正值表示相加，负值表示相减。</li><li>dy1：控制点 Y 坐标，表示相对上一个终点 Y 坐标的位移坐标。同样可为负值，正值表示相加，负值表示相减。</li><li>dx2：终点 X 坐标，同样是一个相对坐标，相对上一个终点 X 坐标的位移值，可为负值，正值表示相加，负值表示相减。</li><li>dy2：终点 Y 坐标，同样是一个相对，相对上一个终点 Y 坐标的位移值。可为负值，正值表示相加，负值表示相减。</li></ul><p>这四个参数都是传递的都是相对值，相对上一个终点的位移值。</p><p>比如，我们上一个终点坐标是 (300,400) 那么利用，rQuadTo(100,-100,200,100) 得到的控制点坐标是 (300+100, 400-100) 即 (500,300)；同样，得到的终点坐标是 (300+200, 400+100)，即 (500,500)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 利用 quadTo 定义一个绝对坐标：</div><div class="line">path.moveTo(300,400);</div><div class="line">path.quadTo(500,300,500,500);</div><div class="line"></div><div class="line">// 与利用 rQuadTo 定义相对坐标是等价的：</div><div class="line">path.moveTo(300,400);</div><div class="line">path.rQuadTo(100,-100,200,100)</div></pre></td></tr></table></figure></p><h4 id="2-使用-rQuadTo-函数实现波浪线"><a href="#2-使用-rQuadTo-函数实现波浪线" class="headerlink" title="2. 使用 rQuadTo() 函数实现波浪线"></a>2. 使用 rQuadTo() 函数实现波浪线</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mPath.moveTo(100, 300);</div><div class="line">/*</div><div class="line">mPath.quadTo(200, 200, 300, 300);</div><div class="line">mPath.quadTo(400, 400, 500, 300);</div><div class="line">*/</div><div class="line">// 替换成</div><div class="line">mPath.rQuadTo(100, -100, 200, 0);</div><div class="line">mPath.rQuadTo(100, 100, 200, 0);</div><div class="line">canvas.drawPath(mPath, mPaint);</div></pre></td></tr></table></figure><p>第一句：path.rQuadTo(100,-100,200,0); 是建立在 (100,300) 这个点基础上来计算相对坐标的，所以：<br>控制点X坐标 = 上一个终点X坐标+控制点X位移 = 100+100=200；<br>控制点Y坐标 = 上一个终点Y坐标+控制点Y位移 = 300-100=200；<br>终点X坐标 = 上一个终点X坐标+终点X位移 = 100+200=300；<br>终点Y坐标 = 上一个终点Y坐标+终点Y位移 = 300+0=300;<br>所以这句与 path.quadTo(200,200,300,300); 对等的。</p><p>第二句：path.rQuadTo(100,100,200,0); 是建立在它的前一个终点即 (300,300) 的基础上来计算相对坐标的，所以：<br>控制点X坐标 = 上一个终点X坐标+控制点X位移 = 300+100=200；<br>控制点Y坐标 = 上一个终点Y坐标+控制点Y位移 = 300+100=200；<br>终点X坐标 = 上一个终点X坐标+终点X位移 = 300+200=500；<br>终点Y坐标 = 上一个终点Y坐标+终点Y位移 = 300+0=300;<br>所以这句与 path.quadTo(400,400,500,300); 对等的。</p><p>最终效果也是一样的。</p><p>通过这个例子，只想让大家明白一点：rQuadTo(float dx1, float dy1, float dx2, float dy2) 中的位移坐标，都是以上一个终点位置为基准来做偏移的。</p><h3 id="7-1-4-示例：波浪效果"><a href="#7-1-4-示例：波浪效果" class="headerlink" title="7.1.4 示例：波浪效果"></a>7.1.4 示例：波浪效果</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-500be19b0bdb1bd8.gif?imageMogr2/auto-orient/strip" alt=""></p><p>我们将 mPath 的起始位置向左移一个波长，然后利用 for 循环画出当前屏幕中可能容得下的所有波。然后画一个波的左右两个半波：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 画的是一个波长中的前半个波</div><div class="line">mPath.rQuadTo(halfWaveLen/2, -100, halfWaveLen, 0); </div><div class="line">// 画的是一个波长中的后半个波</div><div class="line">mPath.rQuadTo(halfWaveLen/2, 100, halfWaveLen, 0);</div></pre></td></tr></table></figure></p><p>大家在这里可以看到，屏幕左右都多画了一个波长的图形。这是为了波形移动做准备的。</p><p>让波纹动起来其实挺简单，利用调用在 path.moveTo 的时候，将起始点向右移动即可实现移动，而且只要我们移动一个波长的长度，波纹就会重合，就可以实现无限循环了。</p><p>完整的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line">    private int mItemWaveLength = 1000;</div><div class="line">    private int dx;</div><div class="line"></div><div class="line">    public TestView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPath = new Path();</div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setStyle(Paint.Style.FILL_AND_STROKE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        mPath.reset();</div><div class="line">        int originY = 300;</div><div class="line">        int halfWaveLen = mItemWaveLength/2;</div><div class="line">        mPath.moveTo(-mItemWaveLength+dx,originY);</div><div class="line">        for (int i = -mItemWaveLength; i&lt;=getWidth()+mItemWaveLength; i+=mItemWaveLength)&#123;</div><div class="line">            mPath.rQuadTo(halfWaveLen/2f,-100,halfWaveLen,0);</div><div class="line">            mPath.rQuadTo(halfWaveLen/2f,100,halfWaveLen,0);</div><div class="line">        &#125;</div><div class="line">        mPath.lineTo(getWidth(),getHeight());</div><div class="line">        mPath.lineTo(0,getHeight());</div><div class="line">        mPath.close();</div><div class="line"></div><div class="line">        canvas.drawPath(mPath,mPaint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void startAnim()&#123;</div><div class="line">        ValueAnimator animator = ValueAnimator.ofInt(0,mItemWaveLength);</div><div class="line">        animator.setDuration(2000);</div><div class="line">        animator.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">        animator.setInterpolator(new LinearInterpolator());</div><div class="line">        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">                dx = (int)animation.getAnimatedValue();</div><div class="line">                postInvalidate();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        animator.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用 TestView<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        TestView view = findViewById(R.id.view);</div><div class="line">        view.startAnim();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h3 id=&quot;7-1-1-概述&quot;&gt;&lt;a href=&quot;#7-1-1-概述&quot; class=&quot;headerlink&quot; title=&quot;7.1.1 概述&quot;&gt;&lt;/a&gt;7.1.1 概述&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>06.3 精通自定义 View 之 Paint 基本使用——常用函数</title>
    <link href="http://yoursite.com/2019/07/06/Custom%20View/06.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/07/06/Custom View/06.3 精通自定义 View 之 Paint 基本使用——常用函数/</id>
    <published>2019-07-05T19:00:00.000Z</published>
    <updated>2019-10-04T07:20:12.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="6-1-1-基本函数设置"><a href="#6-1-1-基本函数设置" class="headerlink" title="6.1.1 基本函数设置"></a>6.1.1 基本函数设置</h3><p>我们先来看一下paint中基本设置的函数都有哪些。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 重置画笔</div><div class="line">reset()</div><div class="line">// 给画笔设置颜色值</div><div class="line">setColor(int color)</div><div class="line">// 设置颜色，利用 ARGB 分开设置</div><div class="line">setARGB(int a, int r, int g, int b)</div><div class="line">// 设置画笔透明度</div><div class="line">setAlpha(int a)</div><div class="line">// 设置画笔样式，取值有：Paint.Style.FILL、STROKE、FILL_AND_STROKE</div><div class="line">setStyle(Paint.Style style)</div><div class="line">// 设置画笔宽度</div><div class="line">setStrokeWidth(float width)</div><div class="line">// 设置画笔是否抗锯齿</div><div class="line">setAntiAlias(boolean aa)</div><div class="line"></div><div class="line">// 设置线冒样式，取值有Cap.ROUND(圆形线冒)、</div><div class="line">// Cap.SQUARE(方形线冒)、Paint.Cap.BUTT(无线冒)</div><div class="line">setStrokeCap(Paint.Cap cap)</div><div class="line">// 设置线段连接处样式，取值有：Join.MITER（结合处为锐角）、</div><div class="line">// Join.Round(结合处为圆弧)、Join.BEVEL(结合处为直线)</div><div class="line">setStrokeJoin(Paint.Join join)</div><div class="line">// 设置笔画的倾斜度，区别不明显</div><div class="line">setStrokeMiter(float miter)</div><div class="line">// 设置路径样式。取值类型是所有派生自 PathEffect 的子类：</div><div class="line">// ComposePathEffect、CornerPathEffect、DashPathEffect、</div><div class="line">// DiscretePathEffect、PathDashPathEffect、SumPathEffect</div><div class="line">setPathEffect(PathEffect effect)</div></pre></td></tr></table></figure></p><h4 id="1-setStrokeCap-Paint-Cap-cap"><a href="#1-setStrokeCap-Paint-Cap-cap" class="headerlink" title="1. setStrokeCap(Paint.Cap cap)"></a>1. setStrokeCap(Paint.Cap cap)</h4><p>设置线帽样式，取值有 Cap.ROUND (圆形线帽)、Cap.SQUARE (方形线帽)、Paint.Cap.BUTT (无线帽)</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-8d1fcbc504d407cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>红线左侧多出来的区域就是线帽。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setStrokeWidth(80);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setAntiAlias(true);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        // 无线帽</div><div class="line">        mPaint.setStrokeCap(Paint.Cap.BUTT);</div><div class="line">        canvas.drawLine(100, 200, 400, 200, mPaint);</div><div class="line">        // 方形线帽</div><div class="line">        mPaint.setStrokeCap(Paint.Cap.SQUARE);</div><div class="line">        canvas.drawLine(100, 400, 400, 400, mPaint);</div><div class="line">        // 圆形线帽</div><div class="line">        mPaint.setStrokeCap(Paint.Cap.ROUND);</div><div class="line">        canvas.drawLine(100, 600, 400, 600, mPaint);</div><div class="line"></div><div class="line">        // 画辅助线</div><div class="line">        mPaint.reset();</div><div class="line">        mPaint.setStrokeWidth(2);</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        canvas.drawLine(100, 50, 100, 750, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2-setStrokeJoin-Paint-Join-join"><a href="#2-setStrokeJoin-Paint-Join-join" class="headerlink" title="2. setStrokeJoin(Paint.Join join)"></a>2. setStrokeJoin(Paint.Join join)</h4><p>参数取值有：Join.MITER (结合处为锐角)、Join.Round (结合处为圆弧)、Join.BEVEL(结合处为直线)</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4e349899a7f42832?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-10d2f61db3868fbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setStrokeWidth(40);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setAntiAlias(true);</div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        // 结合处为锐角 MITER</div><div class="line">        mPath.moveTo(100, 100);</div><div class="line">        mPath.lineTo(250, 100);</div><div class="line">        mPath.lineTo(100, 250);</div><div class="line">        mPaint.setStrokeJoin(Paint.Join.MITER);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        // 结合处为圆弧 ROUND</div><div class="line">        mPath.moveTo(300, 100);</div><div class="line">        mPath.lineTo(450, 100);</div><div class="line">        mPath.lineTo(300, 250);</div><div class="line">        mPaint.setStrokeJoin(Paint.Join.ROUND);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        // 结合处为直线 BEVEL</div><div class="line">        mPath.moveTo(500, 100);</div><div class="line">        mPath.lineTo(650, 100);</div><div class="line">        mPath.lineTo(500, 250);</div><div class="line">        mPaint.setStrokeJoin(Paint.Join.BEVEL);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3-setPathEffect-PathEffect-effect"><a href="#3-setPathEffect-PathEffect-effect" class="headerlink" title="3. setPathEffect(PathEffect effect)"></a>3. setPathEffect(PathEffect effect)</h4><p>设置路径样式。取值类型是所有派生自 PathEffect 的子类：ComposePathEffect、CornerPathEffect、DashPathEffect、DiscretePathEffect、PathDashPathEffect、SumPathEffect。</p><p>1）CornerPathEffect<br>它的作用就是将原来 Path 生硬的直线拐角，变成圆形拐角。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public CornerPathEffect(float radius)</div></pre></td></tr></table></figure></p><p>参数 radius：即当前连接两条直线所使用的圆的半径。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-fc5362e0bd2e16ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c6098ec540f11b5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line">    private CornerPathEffect effect100, effect200;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setStrokeWidth(4);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setAntiAlias(true);</div><div class="line">        mPath = new Path();</div><div class="line">        effect100 = new CornerPathEffect(100);</div><div class="line">        effect200 = new CornerPathEffect(200);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        mPath.moveTo(100,600);</div><div class="line">        mPath.lineTo(400,100);</div><div class="line">        mPath.lineTo(700,900);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line"></div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPaint.setPathEffect(effect100);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line"></div><div class="line">        mPaint.setColor(Color.BLUE);</div><div class="line">        mPaint.setPathEffect(effect200);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>2）DashPathEffect 虚线效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public DashPathEffect(float intervals[], float phase)</div></pre></td></tr></table></figure></p><p>phase：开始绘制的偏移值。<br>intervals[]：表示组成虚线的各个线段的长度；整条虚线就是由intervals[] 中这些基本线段循环组成的。比如，我们定义new float[] {20,10}；那这个虚线段就是由两段线段组成的，第一个可见的线段长为20，每二个线段不可见，长度为10。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b59d246d7eca5520?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于 intervals[] 数组的有两个限定：</p><ul><li>长度必须大于等于 2；因为必须有一个实线段和一个空线段来组成虚线。</li><li>个数必须为偶数，如果是基数，最后一个数字将被忽略；这个很好理解，因为一组虚线的组成必然是一个实线和一个空线成对组成的。</li></ul><p>示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-aed9539fe190586b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line">    private DashPathEffect effect1, effect2;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setStrokeWidth(4);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setAntiAlias(true);</div><div class="line">        mPath = new Path();</div><div class="line">        effect1 = new DashPathEffect(new float[]&#123;20,10,100,100&#125;,0);</div><div class="line">        effect2 = new DashPathEffect(new float[]&#123;20,10,50,100&#125;,15);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        mPath.moveTo(100,600);</div><div class="line">        mPath.lineTo(400,100);</div><div class="line">        mPath.lineTo(700,900);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line"></div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPaint.setPathEffect(effect1);</div><div class="line">        canvas.translate(0, 100);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line"></div><div class="line">        mPaint.setColor(Color.BLUE);</div><div class="line">        mPaint.setPathEffect(effect2);</div><div class="line">        canvas.translate(0, 100);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>3）DiscretePathEffect 离散路径效果<br>DiscretePathEffect 就是将原来路径分隔成定长的线段，然后将每条线段随机偏移一段位置，我们可以用它来模拟一种类似生锈铁丝的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public DiscretePathEffect(float segmentLength, float deviation)</div></pre></td></tr></table></figure></p><ul><li>参数 segmentLength：表示将原来的路径切成多长的线段。如果值为2，那么这个路径就会被切成一段段由长度为 2 的小线段。所以这个值越小，所切成的小线段越多；这个值越大，所切成的小线段越少。</li><li>参数 deviation：表示被切成的每个小线段的可偏移距离。值越大，就表示每个线段的可偏移距离就越大，就显得越凌乱，值越小，每个线段的可偏移原位置的距离就越小。</li></ul><p>示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-9d31b725f3a65625.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = getPaint();</div><div class="line">        mPath = getPath();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        // 第一条原生 Path</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        // 第二条 Path</div><div class="line">        canvas.translate(0,200);</div><div class="line">        mPaint.setPathEffect(new DiscretePathEffect(2,5));</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        // 第三条 Path</div><div class="line">        canvas.translate(0,200);</div><div class="line">        mPaint.setPathEffect(new DiscretePathEffect(6,5));</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        // 第四条 Path</div><div class="line">        canvas.translate(0,200);</div><div class="line">        mPaint.setPathEffect(new DiscretePathEffect(6,15));</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Path getPath()&#123;</div><div class="line">        Path path = new Path();</div><div class="line">        // 定义路径的起点</div><div class="line">        path.moveTo(0, 0);</div><div class="line"></div><div class="line">        // 定义路径的各个点</div><div class="line">        for (int i = 0; i &lt;= 40; i++) &#123;</div><div class="line">            path.lineTo(i*35, (float) (Math.random() * 150));</div><div class="line">        &#125;</div><div class="line">        return path;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Paint getPaint()&#123;</div><div class="line">        Paint paint = new Paint();</div><div class="line">        paint.setStrokeWidth(4);</div><div class="line">        paint.setColor(Color.GREEN);</div><div class="line">        paint.setStyle(Paint.Style.STROKE);</div><div class="line">        paint.setAntiAlias(true);</div><div class="line">        return paint;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>4）PathDashPathEffect 印章路径效果<br>它的作用就是用另一个路径图案做为印章，沿着指定路径一个个盖上去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public PathDashPathEffect(Path shape, float advance, float phase,Style style)</div></pre></td></tr></table></figure></p><ul><li>Path shape：表示印章路径，比如我们下面示例中的三角形加右上角一个点。</li><li>float advance：表示两个印章路径间的距离，印章间距离越大，间距就越大。</li><li>float phase：路径绘制偏移距离，与上面 DashPathEffect 中的 float phase 参数意义相同。</li><li>Style style：表示在遇到转角时，如何操作印章以使转角平滑过渡，取值有：Style.ROTATE，Style.MORPH，Style.TRANSLATE；Style.ROTATE 表示通过旋转印章来过渡转角；Style.MORPH 表示通过变形印章来过渡转角；Style.TRANSLATE 表示通过位移来过渡转角。</li></ul><p>示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4dfb51710a4d6aa1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line">    private PathDashPathEffect mEffectMORPH, mEffectROTATE, mEffectTRANSLATE;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint = getPaint();</div><div class="line">        mPath = getPath();</div><div class="line">        // 构建印章路径</div><div class="line">        Path stampPath = getStampPath();</div><div class="line">        stampPath.addCircle(0,0,3, Path.Direction.CCW);</div><div class="line">        mEffectMORPH = new PathDashPathEffect(stampPath,35,0, PathDashPathEffect.Style.MORPH);</div><div class="line">        mEffectROTATE = new PathDashPathEffect(stampPath,35,0, PathDashPathEffect.Style.ROTATE);</div><div class="line">        mEffectTRANSLATE = new PathDashPathEffect(stampPath,35,0, PathDashPathEffect.Style.TRANSLATE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        // 原始线</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        // 使用印章路径效果 MORPH</div><div class="line">        canvas.translate(0,200);</div><div class="line">        mPaint.setPathEffect(mEffectMORPH);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        // 使用印章路径效果 ROTATE</div><div class="line">        canvas.translate(0,200);</div><div class="line">        mPaint.setPathEffect(mEffectROTATE);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        // 使用印章路径效果 TRANSLATE</div><div class="line">        canvas.translate(0,200);</div><div class="line">        mPaint.setPathEffect(mEffectTRANSLATE);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Path getPath()&#123;</div><div class="line">        Path path = new Path();</div><div class="line">        // 定义路径的起点</div><div class="line">        path.moveTo(0, 0);</div><div class="line"></div><div class="line">        // 定义路径的各个点</div><div class="line">        for (int i = 0; i &lt;= 40; i++) &#123;</div><div class="line">            path.lineTo(i*35, (float) (Math.random() * 150));</div><div class="line">        &#125;</div><div class="line">        return path;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Path getStampPath()&#123;</div><div class="line">        Path path  = new Path();</div><div class="line">        path.moveTo(0,20);</div><div class="line">        path.lineTo(10,0);</div><div class="line">        path.lineTo(20,20);</div><div class="line">        path.close();</div><div class="line"></div><div class="line">        path.addCircle(0,0,3, Path.Direction.CCW);</div><div class="line">        return path;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Paint getPaint()&#123;</div><div class="line">        Paint paint = new Paint();</div><div class="line">        paint.setStrokeWidth(4);</div><div class="line">        paint.setColor(Color.GREEN);</div><div class="line">        paint.setStyle(Paint.Style.STROKE);</div><div class="line">        paint.setAntiAlias(true);</div><div class="line">        return paint;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>5）ComposePathEffect &amp; SumPathEffect<br>这两个都是用来合并两个特效的。但它们之间是有区别的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public ComposePathEffect(PathEffect outerpe, PathEffect innerpe)</div><div class="line">public SumPathEffect(PathEffect first, PathEffect second)</div></pre></td></tr></table></figure></p><p>ComposePathEffect 合并两个特效是有先后顺序的，它会先将第二个参数的 PathEffect innerpe 的特效作用于路径上，然后再在此加了特效的路径上作用第一个特效。</p><p>而 SumPathEffect 是分别对原始路径分别作用第一个特效和第二个特效。然后再将这两条路径合并，做为最终结果。</p><p>示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-5444bb1a116fd454?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 画原始路径</div><div class="line">Paint paint = getPaint();</div><div class="line">Path path = getPath();</div><div class="line">canvas.drawPath(path,paint);</div><div class="line"> </div><div class="line">// 仅应用圆角特效的路径</div><div class="line">canvas.translate(0,200);</div><div class="line">CornerPathEffect cornerPathEffect = new CornerPathEffect(100);</div><div class="line">paint.setPathEffect(cornerPathEffect);</div><div class="line">canvas.drawPath(path,paint);</div><div class="line"> </div><div class="line">// 仅应用虚线特效的路径</div><div class="line">canvas.translate(0,200);</div><div class="line">DashPathEffect dashPathEffect = new DashPathEffect(new float[]&#123;2,5,10,10&#125;,0);</div><div class="line">paint.setPathEffect(dashPathEffect);</div><div class="line">canvas.drawPath(path,paint);</div><div class="line"> </div><div class="line">// 利用 ComposePathEffect 先应用圆角特效，再应用虚线特效</div><div class="line">canvas.translate(0,200);</div><div class="line">ComposePathEffect composePathEffect = new ComposePathEffect(dashPathEffect,cornerPathEffect);</div><div class="line">paint.setPathEffect(composePathEffect);</div><div class="line">canvas.drawPath(path,paint);</div><div class="line"> </div><div class="line">// 利用 SumPathEffect，分别将圆角特效应用于原始路径，然后将生成的两条特效路径合并</div><div class="line">canvas.translate(0,200);</div><div class="line">paint.setStyle(Paint.Style.STROKE);</div><div class="line">SumPathEffect sumPathEffect = new SumPathEffect(cornerPathEffect,dashPathEffect);</div><div class="line">paint.setPathEffect(sumPathEffect);</div><div class="line">canvas.drawPath(path,paint);</div></pre></td></tr></table></figure><h3 id="6-1-2-字体相关函数"><a href="#6-1-2-字体相关函数" class="headerlink" title="6.1.2 字体相关函数"></a>6.1.2 字体相关函数</h3><p><strong>setTextSize(float textSize)</strong><br>设置文字大小</p><p><strong>setFakeBoldText(boolean fakeBoldText)</strong><br>设置是否为粗体文字</p><p><strong>setStrikeThruText(boolean strikeThruText)</strong><br>设置带有删除线效果</p><p><strong>setUnderlineText(boolean underlineText)</strong><br>设置下划线</p><p><strong>setTextAlign(Paint.Align align)</strong><br>设置开始绘图点位置</p><p><strong>setTextScaleX(float scaleX)</strong><br>水平拉伸设置</p><p><strong>setTextSkewX(float skewX)</strong><br>设置字体水平倾斜度，普通斜体字是-0.25，可见往右斜</p><p><strong>setTypeface(Typeface typeface)</strong><br>字体样式</p><p><strong>setLinearText(boolean linearText)</strong><br>设置是否打开线性文本标识；由于文本想要快速绘制出来，必然是需要提前缓存在显存中的，一般而言每个文字需要一个字节的大小来存储它（当然具体需要多少字节与编码方式有关），那如果是长篇文章，可见所需的大小可想而知。我们可以通过 setLinearText (true) 告诉 Android 我们不需要这样的文本缓存。但如果我们不用文本缓存，虽然能够省去一些内存空间，但这是以显示速度为代价的。</p><p>由于这个是 API 1 的函数，由于当时的 android 手机的内存大小还是很小的，所以尽量减少内存使用是每个应用的头等大事，在当时的的环境下这个函数还是很有用的。</p><p>但在今天，内存动不动就是 4G 以上了，文本缓存的所占的那点内存就微不足道了，没有哪个 APP 会牺牲性能来减少这点这内存占用了，所以这个函数基本没用了。</p><p><strong>setSubpixelText(boolean subpixelText)</strong><br>表示是否打开亚像素设置来绘制文本。亚像素的概念比较难理解，首先，我们都知道像素，比如一个 android 手机的分辨率是 1280<em>720，那就是指它的屏幕在垂直方向有 1280 个像素点，水平方向上有 720 个像素点。我们知道每个像素点都是一个独立显示一个颜色的个体。所以如果一副图片，在一个屏幕上用了 300</em>100 个相素点，而在另一个屏幕上却用了 450*150 个像素来显示。那么，请问在哪个屏幕上这张图片显示的更清晰？当然是第二个屏幕，因为它使用的像素点更多，所显示的细节更精细。</p><p>那么问题来了，android 设置在出厂时，设定的像素显示都是固定的几个范围：320<em>480，480</em>800，720<em>1280，1080</em>1920 等等；那么如何在同样的分辨率的显示器中增强显示清晰度呢？</p><p>亚像素的概念就油然而生了，亚像素就是把两个相邻的两个像素之间的距离再细分，再插入一些像素，这些通过程序加入的像素就是亚像素。在两个像素间插入的像素个数是通过程序计算出来的，一般是插入两个、三个或四个。</p><p>所以打开亚像素显示，是可以在增强文本显示清晰度的，但由于插入亚像素是通过程序计算而来的，所以会耗费一定的计算机性能。注意：亚像素是通过程序计算出来模拟插入的，在没有改变硬件构造的情况下，来改善屏幕分辨率大小。</p><p>亚像素显示，是仅在液晶显示器上使用的一种增强字体清晰度的技术。但这种技术有时会出现问题，用投影仪投射到白色墙壁上，会出出字体显示不正常的情况，而且对于老式的CRT显示器是根本不支持的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h3 id=&quot;6-1-1-基本函数设置&quot;&gt;&lt;a href=&quot;#6-1-1-基本函数设置&quot; class=&quot;headerlink&quot; title=&quot;6.1.1 基本函数设置&quot;&gt;&lt;/a&gt;6.1.
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>06.2 精通自定义 View 之 Paint 基本使用——文字</title>
    <link href="http://yoursite.com/2019/07/06/Custom%20View/06.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E6%96%87%E5%AD%97/"/>
    <id>http://yoursite.com/2019/07/06/Custom View/06.2 精通自定义 View 之 Paint 基本使用——文字/</id>
    <published>2019-07-05T18:00:00.000Z</published>
    <updated>2019-10-04T07:18:41.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="6-2-1-概述"><a href="#6-2-1-概述" class="headerlink" title="6.2.1 概述"></a>6.2.1 概述</h3><h4 id="1-四线格与基线"><a href="#1-四线格与基线" class="headerlink" title="1. 四线格与基线"></a>1. 四线格与基线</h4><p>小时候，我们在刚开始学习写字母时，用的本子是四线格的，我们必须把字母按照规则写在四线格内。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b796318147ad1ee8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在 canvas 在利用 drawText 绘制文字时，也是有规则的，这个规则就是基线！我们先来看一下什么是基线：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ab25407ebd89fbb0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可见基线就是四线格中的第三条线。也就是说，只要基线的位置定了，那文字的位置必然是定了的！</p><h4 id="2-canvas-drawText"><a href="#2-canvas-drawText" class="headerlink" title="2. canvas.drawText()"></a>2. canvas.drawText()</h4><p>1）canvas.drawText() 与基线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * text:要绘制的文字</div><div class="line"> * x：绘制原点x坐标</div><div class="line"> * y：绘制原点y坐标</div><div class="line"> * paint:用来做画的画笔</div><div class="line"> */</div><div class="line">public void drawText(String text, float x, float y, Paint paint)</div></pre></td></tr></table></figure></p><p>上面这个构造函数是最常用的 drawText 方法，传进去一个 String 对象就能画出对应的文字。但这里有两个参数需要非常注意，表示原点坐标的 x 和 y。很多同学可能会认为，这里传进去的原点参数 (x,y) 是所在绘制文字所在矩形的左上角的点。但实际上并不是！比如，我们上面如果要画 “harvic’s blog” 这几个字，这个原点坐标应当是下图中绿色小点的位置。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-6799d753bccdd71f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>一般而言，(x,y) 所代表的位置是所画图形对应的矩形的左上角点。但在 drawText 中是非常例外的，y 所代表的是基线的位置。</p><p>2）示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line"> </div><div class="line">    int baseLineX = 0;</div><div class="line">    int baseLineY = 200;</div><div class="line">    </div><div class="line">    // 画基线</div><div class="line">    Paint paint = new Paint();</div><div class="line">    paint.setColor(Color.RED);</div><div class="line">    canvas.drawLine(baseLineX, baseLineY, 3000, baseLineY, paint);</div><div class="line"> </div><div class="line">    // 写文字</div><div class="line">    paint.setColor(Color.GREEN);</div><div class="line">    paint.setTextSize(120); // 以px为单位</div><div class="line">    canvas.drawText(&quot;harvic\&apos;s blog&quot;, baseLineX, baseLineY, paint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>首先，我们把 (0,200) 所在的这条横线画出来，所以我先画了一条线从点坐标为 (0,200) 到点坐标为 (3000,200) 的一条直线，然后利用 canvas.drawText 以 (0,200) 为原点画出文字，最终效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ba0826eb929753ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>结论：</p><ul><li>drawText() 函数中的参数 y 是基线的位置。</li><li>一定要清楚的是，只要 x 坐标、基线位置、文字大小确定，文字的位置就是确定了。</li></ul><h4 id="3-paint-setTextAlign-函数"><a href="#3-paint-setTextAlign-函数" class="headerlink" title="3. paint.setTextAlign() 函数"></a>3. paint.setTextAlign() 函数</h4><p>在上面我们讲了，drawText() 函数中的 y 参数表示所要绘制文字的基线所在位置。从上面的例子中可以看到，绘制是从 x 坐标的右边开始的，但这并不是必然的结果。我们来看一张图：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-308a568c5c7ea992.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在 drawText(text, x, y, paint) 中传进去的原点坐标 (x,y)。其中，y 表示的基线的位置。那 x 代表什么呢？从上面的例子运行结果来看，应当是文字开始绘制的地方。</p><p>并不是！x 代表所要绘制文字所在矩形的相对位置。相对位置就是指指定点 (x,y) 在在所要绘制矩形的位置。我们知道所绘制矩形的纵坐标是由 y 值来确定的，而相对 x 坐标的位置，只有左、中、右三个位置了。也就是所绘制矩形可能是在 x 坐标的左侧绘制，也有可能在 x 坐标的中间，也有可能在 x 坐标的右侧。而定义在 x 坐标在所绘制矩形相对位置的函数是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 其中 Align 的取值为：Panit.Align.LEFT,Paint.Align.CENTER,Paint.Align.RIGHT</div><div class="line"> */</div><div class="line">Paint::setTextAlign(Align align);</div></pre></td></tr></table></figure></p><p>仍然使用上面的例子，当设置不同的 Align 取值时，效果如下图所示。<br><strong>Paint.Align.LEFT：</strong><br><img src="https://upload-images.jianshu.io/upload_images/14186083-7cbb15dc7967a198.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>Paint.Align.CENTER：</strong><br><img src="https://upload-images.jianshu.io/upload_images/14186083-dcdac7faa0f2601e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>Paint.Align.RIGHT：</strong><br><img src="https://upload-images.jianshu.io/upload_images/14186083-fe138d527ea49694.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="4-注意"><a href="#4-注意" class="headerlink" title="4. 注意"></a>4. 注意</h4><p>这里需要再次强调的是：相对位置是根据所要绘制文字所在矩形来计算的。比如，只写一个大写字母 A，将其相对位置设置为 Paint.Align.CENTER。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mPaint.setTextAlign(Paint.Align.CENTER);</div><div class="line">canvas.drawText(&quot;A&quot;, baseLineX, baseLineY, mPaint);</div></pre></td></tr></table></figure></p><p>效果如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e0e6bdfd3959f399.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="6-2-2-绘图四线格与-FontMetrics"><a href="#6-2-2-绘图四线格与-FontMetrics" class="headerlink" title="6.2.2 绘图四线格与 FontMetrics"></a>6.2.2 绘图四线格与 FontMetrics</h3><h4 id="1-文字的绘图四线格"><a href="#1-文字的绘图四线格" class="headerlink" title="1. 文字的绘图四线格"></a>1. 文字的绘图四线格</h4><p>除了基线以外，系统在绘制文字时还有 4 条线，分别是 ascent、descent、top、bottom，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f4f98522d06491b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>ascent：系统建议的，绘制单个字符时，字符应当的最高高度所在线。</li><li>descent：系统建议的，绘制单个字符时，字符应当的最低高度所在线。</li><li>top：可绘制的最高高度所在线。</li><li>bottom：可绘制的最低高度所在线。</li></ul><p>我们在绘制文字时，ascent 是推荐的绘制文字的最高高度，就表示在绘制文字时，尽力要在这个最高高度以下绘制文字。descent 是推荐的绘制文字的最底高度线，同样表示是在绘制文字时尽量在这个 descent 线以上来绘制文字。而 top 线则指该文字可以绘制的最高高度线，bottom 则是表示该文字可以绘制的最低高度线。ascent、descent 是系统建议上的绘制高度，而 top、bottom 则是物理上屏幕最高、最低可以画的高度值。</p><h4 id="2-FontMetrics"><a href="#2-FontMetrics" class="headerlink" title="2. FontMetrics"></a>2. FontMetrics</h4><p>1）FontMetrics 概述<br>我们知道基线的位置是我们在构造 drawText() 函数时由参数 y 来决定的，那 ascent、descent、top、bottom 这些线的位置要怎么计算出来呢？</p><p>Android 给我们提供了一个类：FontMetrics，它里面有四个成员变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FontMetrics::ascent;</div><div class="line">FontMetrics::descent;</div><div class="line">FontMetrics::top;</div><div class="line">FontMetrics::bottom;</div></pre></td></tr></table></figure></p><p>他们的意义与值的计算方法分别如下：</p><ul><li>ascent = ascent 线的 y 坐标 - baseline 线的 y 坐标。</li><li>descent = descent 线的 y 坐标 - baseline 线的 y 坐标。</li><li>top = top 线的 y 坐标 - baseline 线的 y 坐标。</li><li>bottom = bottom 线的 y 坐标 - baseline 线的 y 坐标。</li></ul><p>我们再来看个图：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0cfad062b77303f8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从这个图中，我们先说明两点，然后再回过头来看上面的公式：<br>1、X 轴，Y 轴的正方向走向是 X 轴向右是正方向，Y 轴向下是正方向，所以越往下 Y 坐标越大！<br>2、大家千万不要将 FontMetrics 中的 ascent、descent、top、bottom 与现实中的 ascent、descent、top、bottom 所在线混淆！这几条线是真实存在的，而 FontMetrics 中的 ascent、descent、top、bottom 这个变量的值就是用来计算这几条线的位置的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ascent = ascent线的y坐标 - baseline线的y坐标</div></pre></td></tr></table></figure></p><p>FontMetrics 的这几个变量的值都是以 baseline 为基准的，对于 ascent 来说，baseline 线在 ascent 线之下，所以必然 baseline 的 y 值要大于 ascent 线的 y 值，所以 ascent 变量的值是负的。</p><p>同理，对于 descent 而言：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">descent = descent线的y坐标 - baseline线的y坐标</div></pre></td></tr></table></figure></p><p>descent 线在 baseline 线之下，所以必然 descent 线的 y 坐标要大于 baseline 线的 y 坐标，所以 descent 变量的值必然是正数。</p><p>2）得到 Text 四线格的各线位置<br>先列出一个公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ascent 线 Y 坐标 = baseline 线 Y 坐标 + fontMetric.ascent</div></pre></td></tr></table></figure></p><p>推算过程如下：</p><p>因为 ascent 线的 Y 坐标等于 baseline 线的 Y 坐标减去从 baseline 线到 ascent 线的这段距离。也就是：(|fontMetric.ascent|表示取绝对值)。<br>ascent 线 Y 坐标 = baseline 线 Y 坐标 - |fontMetric.ascent|;<br>又因为 fontMetric.ascent 是负值，所以：<br>ascent 线 Y 坐标 = baseline 线 Y 坐标 - |fontMetric.ascent|;<br>ascent 线 Y 坐标 = baseline 线 Y 坐标 - (-fontMetric.ascent);<br>ascent 线 Y 坐标 = baseline 线 Y 坐标 + fontMetric.ascent;</p><p>这就是整个推算过程，没什么难度，同理可以得到：</p><ul><li>ascent 线 Y 坐标 = baseline 线的 y 坐标 + fontMetric.ascent；</li><li>descent 线 Y 坐标 = baseline 线的 y 坐标 + fontMetric.descent；</li><li>top 线 Y 坐标 = baseline 线的 y 坐标 + fontMetric.top；</li><li>bottom 线 Y 坐标 = baseline 线的 y 坐标 + fontMetric.bottom；</li></ul><p>3）获取 FontMetrics 对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Paint paint = new Paint();</div><div class="line">Paint.FontMetrics fm = paint.getFontMetrics();</div><div class="line">Paint.FontMetricsInt fmInt = paint.getFontMetricsInt();</div></pre></td></tr></table></figure></p><p>从这里可以看到，通过 paint.getFontMetrics() 得到对应的 FontMetrics 对象。这里还有另外一个 FontMetrics 同样的类叫做 FontMetricsInt，它的意义与 FontMetrics 完全相同，只是得到的值的类型不一样而已，FontMetricsInt 中的四个成员变量的值都是 Int 类型，而 FontMetrics 得到的四个成员变量的值则都是 float 类型的。</p><p>4）示例：计算 Text 四线格位置</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-dbe98aa14347e5e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Paint.FontMetrics mFm;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setTextSize(120);</div><div class="line">        mPaint.setTextAlign(Paint.Align.LEFT);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        int baseLineX = 0;</div><div class="line">        int baseLineY = 200;</div><div class="line"></div><div class="line">        // 写文字</div><div class="line">        canvas.drawText(&quot;harvic\&apos;s blog&quot;, baseLineX, baseLineY, mPaint);</div><div class="line">        // 计算各线在位置</div><div class="line">        mFm = mPaint.getFontMetrics();</div><div class="line">        float ascent = baseLineY + mFm.ascent;</div><div class="line">        float descent = baseLineY + mFm.descent;</div><div class="line">        float top = baseLineY + mFm.top;</div><div class="line">        float bottom = baseLineY + mFm.bottom;</div><div class="line">        // 画基线</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        canvas.drawLine(baseLineX, baseLineY, 3000, baseLineY, mPaint);</div><div class="line">        // 画 top</div><div class="line">        mPaint.setColor(Color.BLUE);</div><div class="line">        canvas.drawLine(baseLineX, top, 3000, top, mPaint);</div><div class="line">        // 画 ascent</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        canvas.drawLine(baseLineX, ascent, 3000, ascent, mPaint);</div><div class="line">        // 画 descent</div><div class="line">        mPaint.setColor(Color.YELLOW);</div><div class="line">        canvas.drawLine(baseLineX, descent, 3000, descent, mPaint);</div><div class="line">        // 画 bottom</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        canvas.drawLine(baseLineX, bottom, 3000, bottom, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="6-2-3-常用函数"><a href="#6-2-3-常用函数" class="headerlink" title="6.2.3 常用函数"></a>6.2.3 常用函数</h3><h4 id="1-字符串所占高度和宽度"><a href="#1-字符串所占高度和宽度" class="headerlink" title="1. 字符串所占高度和宽度"></a>1. 字符串所占高度和宽度</h4><p>1）高度<br>字符串所占高度很容易得到，直接用 bottom 线所在位置的 Y 坐标减去 top 线所在位置的 Y 坐标就是字符串所占的高度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mFm = mPaint.getFontMetricsInt();</div><div class="line">int top = baseLineY + fm.top;</div><div class="line">int bottom = baseLineY + fm.bottom;</div><div class="line">// 所占高度</div><div class="line">int height = bottom - top;</div></pre></td></tr></table></figure></p><p>2）、宽度<br>宽度是非常容易得到的，直接利用下面的函数就可以得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int width = mPaint.measureText(&quot;harvic&apos;s blog&quot;);</div></pre></td></tr></table></figure></p><h4 id="2-最小矩形"><a href="#2-最小矩形" class="headerlink" title="2. 最小矩形"></a>2. 最小矩形</h4><p>1）概述<br>要获取最小矩形，也是通过系统函数来获取的，函数及意义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 获取指定字符串所对应的最小矩形，以（0，0）点所在位置为基线</div><div class="line"> * @param text  要测量最小矩形的字符串</div><div class="line"> * @param start 要测量起始字符在字符串中的索引</div><div class="line"> * @param end   所要测量的字符的长度</div><div class="line"> * @param bounds 接收测量结果</div><div class="line"> */</div><div class="line">public void getTextBounds(String text, int start, int end, Rect bounds);</div></pre></td></tr></table></figure></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">String text = &quot;harvic\&apos;s blog&quot;;</div><div class="line">Paint paint = new Paint();</div><div class="line">// 设置paint</div><div class="line">paint.setTextSize(120); </div><div class="line"> </div><div class="line">Rect minRect = new Rect();</div><div class="line">paint.getTextBounds(text,0,text.length(),minRect);</div><div class="line">Log.e(&quot;xian&quot;,minRect.toShortString());</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-65a904e02b3acde3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到这个矩形的左上角位置为（8,-90），右下角的位置为（654,25）；大家可能会有疑问，为什么左上角的 Y 坐标是个负数？从代码中，我们也可以看到，我们并没有给 getTextBounds() 传递基线位置。那它就是以（0,0）为基线来得到这个最小矩形的！所以这个最小矩形的位置就是以（0,0）为基线的结果！</p><p>2）得到最小矩形的实际位置<br>我们先来看一个原理图：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-436e2f53ad881b18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在上面这个图中，我们将黑色矩形平行下移距离Y（黄色线依照的是基线的位置），那么平移后的左上角点的 y 坐标就是 y2 = y1 + Y。</p><p>同样的道理，由于 paint.getTextBounds() 得到最小矩形的基线是 y = 0；那我们直接将这个矩形移动 baseline 的距离就可以得到这个矩形实际应当在的位置了。</p><p>所以矩形应当所在实际位置的坐标是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Rect minRect = new Rect();</div><div class="line">paint.getTextBounds(text,0,text.length(),minRect);</div><div class="line">// 最小矩形，实际 top 位置</div><div class="line">int minTop = bounds.top + baselineY;</div><div class="line">// 最小矩形，实际 bottom 位置</div><div class="line">int minBottom = bounds.bottom + baselineY;</div></pre></td></tr></table></figure></p><p>3）完整的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line"></div><div class="line">    String text = &quot;harvic\&apos;s blog&quot;;</div><div class="line">    int baseLineY = 200;</div><div class="line">    int baseLineX = 0 ;</div><div class="line"></div><div class="line">    // 设置paint</div><div class="line">    Paint paint = new Paint();</div><div class="line">    paint.setTextSize(120); //以px为单位</div><div class="line">    paint.setTextAlign(Paint.Align.LEFT);</div><div class="line"></div><div class="line">    // 画text所占的区域</div><div class="line">    Paint.FontMetricsInt fm = paint.getFontMetricsInt();</div><div class="line">    int top = baseLineY + fm.top;</div><div class="line">    int bottom = baseLineY + fm.bottom;</div><div class="line">    int width = (int)paint.measureText(text);</div><div class="line">    Rect rect = new Rect(baseLineX,top,baseLineX+width,bottom);</div><div class="line"></div><div class="line">    paint.setColor(Color.GREEN);</div><div class="line">    canvas.drawRect(rect,paint);</div><div class="line"></div><div class="line">    // 画最小矩形</div><div class="line">    Rect minRect = new Rect();</div><div class="line">    paint.getTextBounds(text,0,text.length(),minRect);</div><div class="line">    minRect.top = baseLineY + minRect.top;</div><div class="line">    minRect.bottom = baseLineY + minRect.bottom;</div><div class="line">    paint.setColor(Color.RED);</div><div class="line">    canvas.drawRect(minRect,paint);</div><div class="line"></div><div class="line">    // 写文字</div><div class="line">    paint.setColor(Color.BLACK);</div><div class="line">    canvas.drawText(text, baseLineX, baseLineY, paint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ebb6cef9d9cbf11e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="6-2-4-示例：定点写字"><a href="#6-2-4-示例：定点写字" class="headerlink" title="6.2.4 示例：定点写字"></a>6.2.4 示例：定点写字</h3><h4 id="1-给定左上顶点绘图"><a href="#1-给定左上顶点绘图" class="headerlink" title="1. 给定左上顶点绘图"></a>1. 给定左上顶点绘图</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ea033f084880c022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在这个图中，我们给定左上角的位置，即 (left,top)；我们知道要画文字，drawText() 中传进去的 Y 坐标是基线的位置，所以我们就必须根据 top 的位置计算出 baseline 的位置。</p><p>我们来看一个公式：<br>FontMetrics.top = top - baseline;</p><p>所以：<br>baseline = top - FontMetrics.top;</p><p>因为 FontMetrics.top 是可以得到的，又因为我们的 top 坐标是给定的，所以通过这个公式就能得到 baseline 的位置了。</p><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Paint.FontMetrics mFm;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        mPaint.setTextSize(120);</div><div class="line">        mPaint.setTextAlign(Paint.Align.LEFT);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        mFm = mPaint.getFontMetrics();</div><div class="line">        float top = 0;</div><div class="line">        int baseLineX = 0;</div><div class="line">        float baseLineY = top - mFm.top;</div><div class="line"></div><div class="line">        // 写文字</div><div class="line">        canvas.drawText(&quot;harvic\&apos;s blog&quot;, 0, baseLineY, mPaint);</div><div class="line"></div><div class="line">        // 画基线</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        canvas.drawLine(baseLineX, baseLineY, 3000, baseLineY, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="2-给定中间线位置绘图"><a href="#2-给定中间线位置绘图" class="headerlink" title="2. 给定中间线位置绘图"></a>2. 给定中间线位置绘图</h4><p>先来看一张图：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1072d0900b738e32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在这个图中，总共有四条线：top 线、bottom 线、baseline 和 center线。其中 center 线正是在 top 线和 bottom 线的正中间。</p><p>为了方便推导公式，另外标了三个距离 A、B、C。显然，距离 A 和距离 C 是相等的，都等于文字所在矩形高度以的一半，即 A = C = (bottom - top)/2。</p><p>又因为：<br>bottom = baseline + FontMetrics.bottom<br>top = baseline + FontMetrics.top<br>将这两个公式代入上面的公式，就可得到：<br>A = C = (FontMetrics.bottom - FontMetrics.top)/2</p><p>而距离 B 则表示 center 线到 baseline 的距离。很显然距离<br>B = C - (bottom - baseline)</p><p>又因为：<br>FontMetrics.bottom = bottom - baseline<br>C = A<br>所以：<br>B = A - FontMetrics.bottom</p><p>从而有：<br>baseline = center + B = center + A - FontMetrics.bottom = center + (FontMetrics.bottom - FontMetrics.top)/2 - FontMetrics.bottom</p><p>根据上面的推导过程，我们最终可知，当给定中间线 center 位置以后，baseline 的位置为：<br>baseline = center + (FontMetrics.bottom - FontMetrics.top)/2 - FontMetrics.bottom</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h3 id=&quot;6-2-1-概述&quot;&gt;&lt;a href=&quot;#6-2-1-概述&quot; class=&quot;headerlink&quot; title=&quot;6.2.1 概述&quot;&gt;&lt;/a&gt;6.2.1 概述&lt;/h3&gt;&lt;h4
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>06.1 精通自定义 View 之 Paint 基本使用——硬件加速</title>
    <link href="http://yoursite.com/2019/07/06/Custom%20View/06.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%20Paint%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/"/>
    <id>http://yoursite.com/2019/07/06/Custom View/06.1 精通自定义 View 之 Paint 基本使用——硬件加速/</id>
    <published>2019-07-05T17:00:00.000Z</published>
    <updated>2019-10-04T07:17:23.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><a href="https://www.jianshu.com/p/7a832e074b69" target="_blank" rel="external">参考文档：硬件加速</a></p><h3 id="6-1-1-本质和原理"><a href="#6-1-1-本质和原理" class="headerlink" title="6.1.1 本质和原理"></a>6.1.1 本质和原理</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><p>所谓硬件加速，指的是把某些计算工作交给专门的硬件来做，而不是和普通的计算工作一样交给 CPU 来处理。这样不仅减轻了 CPU 的压力，而且由于有了「专人」的处理，这份计算工作的速度也被加快了。这就是「硬件加速」。</p><p>而对于 Android 来说，硬件加速有它专属的意思：在 Android 里，硬件加速专指把 View 中绘制的计算工作交给 GPU 来处理。进一步地再明确一下，这个「绘制的计算工作」指的就是把绘制方法中的那些 Canvas.drawXXX() 变成实际的像素这件事。</p><h4 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h4><p>在硬件加速关闭的时候，Canvas 绘制的工作方式是：把要绘制的内容写进一个 Bitmap，然后在之后的渲染过程中，这个 Bitmap 的像素内容被直接用于渲染到屏幕。这种绘制方式的主要计算工作在于把绘制操作转换为像素的过程（例如由一句 Canvas.drawCircle() 来获得一个具体的圆的像素信息），这个过程的计算是由 CPU 来完成的。大致就像这样：</p><p><img src="https://upload-images.jianshu.io/upload_images/2789715-2e12c05c18113d57.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/839/format/webp" alt=""></p><p>而开启硬件加速后，Canvas 的工作方式改变了：它把绘制的内容转为 GPU 的操作保存下来，然后交给 GPU 来完成显示工作。大致过程：</p><p><img src="https://upload-images.jianshu.io/upload_images/2789715-38ff7dae4e1cdd37.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/839/format/webp" alt=""></p><p>从上图可以看出，开启硬件加速后，绘制的计算工作有 CPU 交给 GPU，不过这怎么就能起到加速作用，让绘制变快了呢？</p><ul><li>本来CPU的工作，分摊一部分给GPU，自然可以提高效率；</li><li>相对于CPU来说，GPU自身的设计本来就对于很多常见类型内容的计算(例如简单的圆形、方形)具有优势；</li><li>由于绘制流程的不同；硬件加速在界面内容发生重绘的时候绘制流程可以得到优化，避免一些重复操作，从而大幅提升绘制效率。</li></ul><p>关于第三点，它的原理大致说一下：</p><p>关闭硬件加速时，绘制内容会被 CPU 转为实际的像素，然后直接渲染到屏幕，具体来说，这个 [实际的像素]，是由 bitmap 承载的，在界面的某个 View 由于内容发生改变而调用 invalidat() 方法时，如果没有开启硬件加速，为了正确计算 bitmap 的像素，这个 View 的父 View、父 View 的父 View 乃至一直向上知道最顶级的 View，以及所有和它相交的 View，都需要被调用 invalidate() 来重绘，一个View的改变使得大半个界面甚至整个界面重绘一遍，这个工作量是非常大的。</p><p>而在开启硬件加速时，绘制的内容会被转换成 GPU 的操作保存下来(承载的形式成为 displaylist，对应的类也叫作 DisplayList)，再转交给 GPU。由于所有绘制的内容都没有变成最终的像素，所以它们之间是相互独立的，那么在界面内容发生改变时，只需把发生了改变的 View 调用 invalidate() 方法以更新它所对应的 GPU 就好，至于它的父 View 和兄弟 View，只需要保持原样，那么这个工作量就很小了。</p><p>正是由于上面的原因，硬件加速不仅是由于 GPU 的引入提高效率，而且因为绘制机制的改变，而极大的提高了界面内容改变时的刷新效率。</p><p>总结：<strong>用了 GPU，绘制更快；绘制机制的改变，导致界面内容改变时的刷新效率极大提高。</strong></p><h3 id="6-1-2-在-Android-中的限制"><a href="#6-1-2-在-Android-中的限制" class="headerlink" title="6.1.2 在 Android 中的限制"></a>6.1.2 在 Android 中的限制</h3><p>可事实就是，硬件加速不止有好处，也有限制：收到 GPU 绘制方式的限制，Canvas 的有些方法在硬件加速开启时会失效或者无法正常工作，比如：开启硬件加速，clipPath() 在 API 18 及以上系统中才有效，具体的 API 限制和 API 版本的关系如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2789715-ea809b43011e9e11.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/783/format/webp" alt=""></p><p>所以，如果你对自定义控件有自定义绘制的内容，最好参照一下表格，确保你的绘制操作可以正确地在所有用户手机中正常显示，而不是只在你最新 Android 系统的 Nexus 或 Pixel 里测试一遍没问题就发布。那就小心被祭天了。</p><h3 id="6-1-3-禁用-GPU-硬件加速的方法"><a href="#6-1-3-禁用-GPU-硬件加速的方法" class="headerlink" title="6.1.3 禁用 GPU 硬件加速的方法"></a>6.1.3 禁用 GPU 硬件加速的方法</h3><p>1）在 AndroidManifest.xml 文件中为 application 标签添加如下属性，即可为整个应用程序开启/关闭硬件加速。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;application android:hardwareAccelerated=&quot;true&quot; ...&gt;</div></pre></td></tr></table></figure></p><p>2）在 AndroidManifest.xml 文件中为 activity 标签下使用 hardwareAccelerated 属性开启/关闭硬件加速。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;activity android:hardwareAccelerated=&quot;false&quot; ...&gt;</div></pre></td></tr></table></figure></p><p>3）在 Window 层级上使用如下代码开启硬件加速（Window 层级不支持关闭硬件加速）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getWindow().setFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);</div></pre></td></tr></table></figure></p><p>4）在 View 层级上使用如下代码关闭硬件加速(在 View 层级上不支持开启硬件加速)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setLayerType(LAYER_TYPE_SOFTWARE,null);</div></pre></td></tr></table></figure></p><p>或者在layout xml中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:layerType=&quot;software&quot; &gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>事实上，view.setLayerType(LAYER_TYPE_SOFTWARE, null) 这个方法的作用并不是关闭硬件加速，只是当它的参数为 LAYER_TYPE_SOFTWARE 的时候，可以顺便把硬件加速关掉而已；并且除了这个方法外，Android 并没有提供专门的 View 级别的硬件加速开关，所以它就顺便成了一个开关硬件加速的方法。</p><ul><li>参数为 LAYER_TYPE_SOFTWARE 时，使用软件来绘制 View Layer，绘制到一个 Bitmap，并顺便关闭硬件加速；</li><li>参数为 LAYER_TYPE_HARDWARE 时，使用 GPU 来绘制 View Layer，绘制到一个 OpenGL texture (如果硬件加速关闭，那么行为和 LAYER_TYPE_SOFTWARE 一致)；</li><li>参数为 LAYER_TYPE_NONE 时，关闭 View Layer。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/7a832e074b69&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考文档：硬件加速&lt;/
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>05.2 精通自定义 View 之动画进阶——SVG 动画</title>
    <link href="http://yoursite.com/2019/07/05/Custom%20View/05.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94SVG%20%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2019/07/05/Custom View/05.2 精通自定义 View 之动画进阶——SVG 动画/</id>
    <published>2019-07-04T18:00:00.000Z</published>
    <updated>2019-10-04T07:16:18.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="5-2-1-概述"><a href="#5-2-1-概述" class="headerlink" title="5.2.1 概述"></a>5.2.1 概述</h3><p>SVG 全称是 Scalable Vector Graphics（可缩放矢量图形），即 SVG 是矢量图。与矢量图对应的是位图，Bitmap 就是位图，它由一个个像素点组成，当图片放大到一定大小时，就会出现马赛克现象，Photoshop 就是常用的位图处理软件。而矢量图则由一个个点组成，经过数学计算利用直线和曲线绘制而成，无论如何放大，都不会出现马赛克现象，Illustrator 就是常用的矢量图绘图软件。</p><p>SVG 与 Bitmap 相比有以下好处：</p><ul><li>SVG 使用 XML 格式定义图形，可被非常多的工具读取和修改。</li><li>SVG 由点来存储，由计算机根据点信息绘图，不会失真，无须根据分辨率适配多套图标。</li><li>SVG 的占用空间明显比 Bitmap 小。如 500px X 500px 的图像，转成 SVG 后占用的空间大小是 20KB，而 PNG 图片则需要 732KB 的空间。</li><li>SVG 可以转换为 Path 路径，与 Path 动画相结合，可以形成丰富的动画。</li></ul><p>对于 Android 5.0 以下的机型，可以通过引入 com.android.support:appcompat-v7:23.4.0 及以上版本进行支持。</p><p>Android 并没有对原生的 SVG 图像语法进行支持，而是以一种简化的方式对 SVG 进行兼容，也就是通过使用它的 path 标签，几乎可以实现 SVG 中的其他所有标签。这些东西可以通过工具来完成。</p><h3 id="5-2-2-vector-标签与图像显示"><a href="#5-2-2-vector-标签与图像显示" class="headerlink" title="5.2.2 vector 标签与图像显示"></a>5.2.2 vector 标签与图像显示</h3><p>res/drawable/svg.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:width=&quot;200dp&quot;</div><div class="line">    android:height=&quot;100dp&quot;</div><div class="line">    android:viewportWidth=&quot;100&quot;</div><div class="line">    android:viewportHeight=&quot;50&quot;&gt;</div><div class="line">    &lt;path</div><div class="line">        android:name=&quot;bar&quot;</div><div class="line">        android:pathData=&quot;M50,23 L100,23&quot;</div><div class="line">        android:strokeWidth=&quot;2&quot;</div><div class="line">        android:strokeColor=&quot;@color/colorAccent&quot;/&gt;</div><div class="line">&lt;/vector&gt;</div></pre></td></tr></table></figure></p><p>效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c19a24bc41592925.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>vector 标签：指定画布大小，上图蓝框区域。</li><li>path 标签：绘制路径，对应上图中的红色线段。</li><li>width &amp; height 属性：表示该 SVG 图形的具体大小。</li><li>viewportWidth &amp; viewportHeight 属性：表示 SVG 图形划分的比例。</li></ul><p>width &amp; height 类似于指定画布的大小，而 viewportWidth &amp; viewportHeight 则是指将画布的宽、高分为多少个点，而 Path 中的点坐标都是以 viewportWidth &amp; viewportHeight 的点数为坐标的，而不是 dp 值。此处将宽度 200dp 分为 100 个点，在高度 100dp 分为 50 个点，每个点有 2dp。而 path 中字母 M 表示 moveTo，字母 L 表示 lineTo，所以，这里代表从（50, 23) 到点 (100, 23) 画了一条线段。</p><h4 id="1-path-标签"><a href="#1-path-标签" class="headerlink" title="1. path 标签"></a>1. path 标签</h4><p>1）常用属性</p><ul><li>android:name：声明一个标记，类似于 ID。</li><li>android:pathData：对 SVG 矢量图的描述。</li><li>android:strokeWidth：画笔的宽度</li><li>android:fillColor：填充颜色。</li><li>android:fillAlpha：填充颜色的透明度。</li><li>android:strokeColor：描边颜色。</li><li>android:strokeWidth：描边宽度。</li><li>android:strokeAlpha：描边透明度。</li><li>android:strokeLineJoin：用于指定折线拐角形状，取值有 miter（结合处为锐角）、round（结合处为圆弧）、bevel（结合处为直线）。</li><li>android:strokeLineCap：画出线条的终点的形状（线帽），取值有 butt（无线帽）、round（圆形线帽）、square（方形线帽）</li><li>android:strokeMiterLimit：设置斜角的上限。当 strokeLineJoin 为 “round” 或 “bevel” 时，该属性无效。</li></ul><p>2）android:trimPathStart 属性<br>该属性用于指定路径从哪里开始，取值为 0~1，表示路径开始位置的百分比。取值为 0 时，表示从头开始；取值为 1 时，整条路径不可见。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;path</div><div class="line">    android:name=&quot;bar&quot;</div><div class="line">    android:pathData=&quot;M50,23 L100,23&quot;</div><div class="line">    android:strokeWidth=&quot;2&quot;</div><div class="line">    android:trimPathStart=&quot;0.5&quot;</div><div class="line">    android:strokeColor=&quot;@color/colorAccent&quot;/&gt;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-343a12e0dc24f75c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>灰色部分代表的是被删除的部分，实际上是不会显示出来的，这里只是为了展示效果，下同。</p><p>3）android:trimPathEnd 属性<br>该属性用于指定路径的结束位置，取值为 0~1，表是路径结束位置的百分比。取值为 1 时，路径正常结束；取值为 0 时，表示从开始位置就已经结束了，即整条路径不可见。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;path</div><div class="line">    android:name=&quot;bar&quot;</div><div class="line">    android:pathData=&quot;M50,23 L100,23&quot;</div><div class="line">    android:strokeWidth=&quot;2&quot;</div><div class="line">    android:trimPathEnd=&quot;0.8&quot;</div><div class="line">    android:strokeColor=&quot;@color/colorAccent&quot;/&gt;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a913b917f9134edd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>4）android:trimPathOffset 属性<br>该属性用于指定路径的位移距离，取值 0~1。取值为 0 时，不位移；当取值 为 1 时，位移整条路径的长度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;path</div><div class="line">    android:name=&quot;bar&quot;</div><div class="line">    android:pathData=&quot;M50,23 L100,23&quot;</div><div class="line">    android:strokeWidth=&quot;2&quot;</div><div class="line">    android:trimPathStart=&quot;0.2&quot;</div><div class="line">    android:trimPathEnd=&quot;0.4&quot;</div><div class="line">    android:trimPathOffset=&quot;0.6&quot;</div><div class="line">    android:strokeColor=&quot;@color/colorAccent&quot;/&gt;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-b3fd2fce5e592895.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>5）android:pathData 属性<br>指定 SVG 图像的显示内容。</p><ul><li>M = moveTo(M X,Y)：将画笔移动到指定的坐标位置。</li><li>L = lineTo(L X,Y)：画直线到指定的坐标位置。</li><li>H = horizontal lineTo(H X)：画水平线到指定的 X 坐标位置。</li><li>V = vertical lineTo(V Y)：画垂直线到指定的 Y 坐标位置。</li><li>C = curveTo(C X1,Y1,X2,Y2,ENDX,ENDY)：三阶贝济埃曲线。</li><li>S = smooth curveTo(S X2,Y2,ENDX,ENDY)：三阶贝济埃曲线。S 指令会将上一条指令的终点作为这条指令的起始点。</li><li>Q = quadratic Bezier curve(Q X,Y,ENDX,ENDY)：二阶贝济埃曲线。</li><li>T = smooth quadratic Bezier curveTo(T ENDX,ENDY)：映射前面路径后的终点。</li><li>A = elliptical Arc(A RX,RY,XROTATION,FLAG1,FLAG2,X,Y)：弧线。</li><li>Z = closePath()：关闭路径。</li></ul><p>使用上面的指令时，需要注意的几点：</p><ul><li>坐标轴以（0,0）位中心，X轴水平向右，Y轴水平向下。</li><li>所有指令大小写均可，大写绝对定位，参照全局坐标系，小写相对定位，参照父容器坐标系。</li><li>指令和数据间的空格可以无视。</li><li>同一指令出现多次可以用一个。</li></ul><h4 id="2-group-标签"><a href="#2-group-标签" class="headerlink" title="2. group 标签"></a>2. group 标签</h4><p>group 标签用于定义一系列路径或者将 path 标签分组。具有以下常用属性。</p><ul><li>android:name：组的名称，用于与动画相关联。</li><li>android:rotation：指定该组图像的旋转度数。</li><li>android:pivotX：定义缩放和旋转该组时的 X 参考点。</li><li>android:pivotY：定义缩放和旋转该组时的 Y 参考点。</li><li>android:scaleX：指定该组 X 轴缩放大小。</li><li>android:scaleY：指定该组 Y 轴缩放大小。</li><li>android:translateX：指定该组沿 X 轴平移的距离。</li><li>android:translateY：指定该组沿 Y 轴平移的距离。</li></ul><p>示例：围绕画布中心旋转 90 度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:width=&quot;200dp&quot;</div><div class="line">    android:height=&quot;100dp&quot;</div><div class="line">    android:viewportWidth=&quot;100&quot;</div><div class="line">    android:viewportHeight=&quot;50&quot;&gt;</div><div class="line">    &lt;group</div><div class="line">        android:rotation=&quot;90&quot;</div><div class="line">        android:pivotX=&quot;50&quot;</div><div class="line">        android:pivotY=&quot;25&quot;&gt;</div><div class="line">        &lt;path</div><div class="line">            android:name=&quot;bar&quot;</div><div class="line">            android:pathData=&quot;M50,23 L100,23&quot;</div><div class="line">            android:strokeWidth=&quot;2&quot;</div><div class="line">            android:strokeColor=&quot;@color/colorAccent&quot;/&gt;</div><div class="line">    &lt;/group&gt;</div><div class="line">&lt;/vector&gt;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-574df53f3790cc98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="3-制作-SVG-图像"><a href="#3-制作-SVG-图像" class="headerlink" title="3. 制作 SVG 图像"></a>3. 制作 SVG 图像</h4><p>方法一：设计软件<br>如果有绘图基础，可以直接使用 Illustrator 或在线 SVG 工具制作 SVG 图像（如 <a href="http://editor.method.ac/），或者通过" target="_blank" rel="external">http://editor.method.ac/），或者通过</a> SVG 源文件下载网站下载后进行编辑。</p><p>方法二：Iconfont<br>有很多 Iconfont 开源网站，比如国内的阿里巴巴矢量图库，地址为 <a href="http://www.iconfont.cn/。" target="_blank" rel="external">http://www.iconfont.cn/。</a></p><h4 id="4-在-Android-中引入-SVG-图像"><a href="#4-在-Android-中引入-SVG-图像" class="headerlink" title="4. 在 Android 中引入 SVG 图像"></a>4. 在 Android 中引入 SVG 图像</h4><p>在 Android 中是不支持 SVG 图像解析的，我们必须将 SVG 图像转换为 vector 标签描述，这里同样有两种方法。</p><p>方法一：<a href="http://inloop.github.io/svg2android/" target="_blank" rel="external">在线转换</a>。<br>This tool has been deprecated. Use official <a href="https://developer.android.com/studio/write/vector-asset-studio#svg" target="_blank" rel="external"><strong>Vector Asset Studio</strong></a> instead.</p><p>方法二：Vector Asset Studio<br>Android Studio 2.0 及以上版本中支持创建 Vector 文件，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-9ff6527094fa10b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-818c4a056b161b50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h4><p>1）引入兼容包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">compile &apos;com.android.support:appcompat-v7:23.4.0&apos;</div><div class="line">// 或使用 androidx</div><div class="line">implementation &apos;androidx.appcompat:appcompat:1.0.2&apos;</div></pre></td></tr></table></figure></p><p>在项目的 build.gradle 脚本中添加对 Vector 兼容性的支持。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    defaultConfig &#123;</div><div class="line">        vectorDrawables.useSupportLibrary = true</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>2）生成 Vector 图像<br>使用前面例子中的一条横线的 Vector 图像（src/drawable/svg.xml）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:width=&quot;200dp&quot;</div><div class="line">    android:height=&quot;100dp&quot;</div><div class="line">    android:viewportWidth=&quot;100&quot;</div><div class="line">    android:viewportHeight=&quot;50&quot;&gt;</div><div class="line">    &lt;path</div><div class="line">        android:name=&quot;bar&quot;</div><div class="line">        android:pathData=&quot;M50,23 L100,23&quot;</div><div class="line">        android:strokeWidth=&quot;2&quot;</div><div class="line">        android:strokeColor=&quot;@color/colorAccent&quot;/&gt;</div><div class="line">&lt;/vector&gt;</div></pre></td></tr></table></figure></p><p>3）在 ImageView、ImageButton 中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;ImageView</div><div class="line">    android:id=&quot;@+id/iv&quot;</div><div class="line">    android:layout_width=&quot;wrap_content&quot;</div><div class="line">    android:layout_height=&quot;wrap_content&quot;</div><div class="line">    app:srcCompat=&quot;@drawable/svg&quot;/&gt;</div></pre></td></tr></table></figure></p><p>在代码中设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ImageView iv = findViewById(R.id.iv);</div><div class="line">iv.setImageResource(R.drawable.svg);</div></pre></td></tr></table></figure></p><blockquote><p>本人测试使用 android:background=”@drawable/svg” 也是正常的。测试机型 Pixel XL，Android 7.1.2。</p></blockquote><p>4）在 Button、RadioButton 中使用<br>Button 并不能直接通过 app:srcCompat 属性来使用 Vector 图像，而需要通过 selector 标签来使用（selector_svg.xml）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</div><div class="line">    &lt;item android:drawable=&quot;@drawable/svg&quot; android:state_pressed=&quot;true&quot;/&gt;</div><div class="line">    &lt;item android:drawable=&quot;@drawable/svg&quot;/&gt;</div><div class="line">&lt;/selector&gt;</div></pre></td></tr></table></figure></p><p>如果到这里并不能直接运行，需要把下面这段代码放在 Activity 的前面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line">    static &#123;</div><div class="line">        AppCompatDelegate.setCompatVectorFromResourcesEnabled(true);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>本人测试可以直接使用 android:background=”@drawable/svg” 并且不需要在 Activity 中加入上述代码 即可正常运行。测试机型 Pixel XL，Android 7.1.2。</p></blockquote><h3 id="5-2-3-动态-Vector"><a href="#5-2-3-动态-Vector" class="headerlink" title="5.2.3 动态 Vector"></a>5.2.3 动态 Vector</h3><p>实现 Vector 动画，步骤如下：<br>1）使用上述 drawable/svg.xml<br>2）创建 animator/anim_trim_start.xml 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:propertyName=&quot;trimPathStart&quot;</div><div class="line">    android:valueFrom=&quot;0&quot;</div><div class="line">    android:valueTo=&quot;1&quot;</div><div class="line">    android:duration=&quot;2000&quot;/&gt;</div></pre></td></tr></table></figure></p><p>3）关联 Vector &amp; Animator。drawable/animated_vector.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;animated-vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:drawable=&quot;@drawable/svg&quot;&gt;</div><div class="line">    &lt;target</div><div class="line">        android:animation=&quot;@animator/anim_trim_start&quot;</div><div class="line">        android:name=&quot;bar&quot;/&gt;</div><div class="line">&lt;/animated-vector&gt;</div></pre></td></tr></table></figure></p><p>4）最后在代码中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        final ImageView imageView = findViewById(R.id.iv);</div><div class="line">        AnimatedVectorDrawableCompat compat = AnimatedVectorDrawableCompat.create(</div><div class="line">                MainActivity.this, R.drawable.animated_vector);</div><div class="line">        imageView.setImageDrawable(compat);</div><div class="line"></div><div class="line"></div><div class="line">        findViewById(R.id.btn).setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                ((Animatable) imageView.getDrawable()).start();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果图如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-07e5d6f4bfb689d8.gif?imageMogr2/auto-orient/strip" alt=""></p><h3 id="5-2-4-示例：输入搜索动画"><a href="#5-2-4-示例：输入搜索动画" class="headerlink" title="5.2.4 示例：输入搜索动画"></a>5.2.4 示例：输入搜索动画</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a5ed5dd59e09fc2c.gif?imageMogr2/auto-orient/strip" alt=""></p><h4 id="1-准备-SVG-图像"><a href="#1-准备-SVG-图像" class="headerlink" title="1. 准备 SVG 图像"></a>1. 准备 SVG 图像</h4><p>res/drawable/svg.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:width=&quot;150dp&quot;</div><div class="line">    android:height=&quot;24dp&quot;</div><div class="line">    android:viewportWidth=&quot;150&quot;</div><div class="line">    android:viewportHeight=&quot;24&quot;&gt;</div><div class="line">    &lt;!-- 搜索图形 --&gt;</div><div class="line">    &lt;path</div><div class="line">        android:name=&quot;search&quot;</div><div class="line">        android:pathData=&quot;M141,17 A9,9 0 1,1 142,16 L149,23&quot;</div><div class="line">        android:strokeWidth=&quot;2&quot;</div><div class="line">        android:strokeColor=&quot;@color/colorAccent&quot;/&gt;</div><div class="line">    &lt;path</div><div class="line">        android:name=&quot;bar&quot;</div><div class="line">        android:trimPathStart=&quot;1&quot;</div><div class="line">        android:pathData=&quot;M0,23 L149,23&quot;</div><div class="line">        android:strokeWidth=&quot;2&quot;</div><div class="line">        android:strokeColor=&quot;@color/colorAccent&quot;/&gt;</div><div class="line">&lt;/vector&gt;</div></pre></td></tr></table></figure></p><h4 id="2-准备动画"><a href="#2-准备动画" class="headerlink" title="2. 准备动画"></a>2. 准备动画</h4><p>res/animator/anim_bar_trim_start.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:propertyName=&quot;trimPathStart&quot;</div><div class="line">    android:valueFrom=&quot;0&quot;</div><div class="line">    android:valueTo=&quot;1&quot;</div><div class="line">    android:valueType=&quot;floatType&quot;</div><div class="line">    android:duration=&quot;500&quot;/&gt;</div></pre></td></tr></table></figure></p><p>res/animator/anim_search_trim_start.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:propertyName=&quot;trimPathEnd&quot;</div><div class="line">    android:valueFrom=&quot;0&quot;</div><div class="line">    android:valueTo=&quot;1&quot;</div><div class="line">    android:valueType=&quot;floatType&quot;</div><div class="line">    android:duration=&quot;500&quot;/&gt;</div></pre></td></tr></table></figure></p><p>关联 Vector &amp; Animator<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;animated-vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:drawable=&quot;@drawable/svg&quot;&gt;</div><div class="line">    &lt;target</div><div class="line">        android:animation=&quot;@animator/anim_bar_trim_start&quot;</div><div class="line">        android:name=&quot;bar&quot;/&gt;</div><div class="line">    &lt;target</div><div class="line">        android:animation=&quot;@animator/anim_search_trim_start&quot;</div><div class="line">        android:name=&quot;search&quot;/&gt;</div><div class="line">&lt;/animated-vector&gt;</div></pre></td></tr></table></figure></p><h4 id="3-布局与开始动画"><a href="#3-布局与开始动画" class="headerlink" title="3. 布局与开始动画"></a>3. 布局与开始动画</h4><p>res/layout/act_main.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;FrameLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:padding=&quot;20dp&quot; &gt;</div><div class="line">    &lt;EditText</div><div class="line">        android:id=&quot;@+id/edit&quot;</div><div class="line">        android:layout_width=&quot;150dp&quot;</div><div class="line">        android:layout_height=&quot;24dp&quot;</div><div class="line">        android:hint=&quot;点击输入&quot;</div><div class="line">        android:background=&quot;@null&quot;/&gt;</div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/iv&quot;</div><div class="line">        android:layout_width=&quot;150dp&quot;</div><div class="line">        android:layout_height=&quot;24dp&quot; /&gt;</div><div class="line">&lt;/FrameLayout&gt;</div></pre></td></tr></table></figure></p><p>开始动画代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        final ImageView imageView = findViewById(R.id.iv);</div><div class="line">        // 将焦点放在 ImageView 上</div><div class="line">        imageView.setFocusable(true);</div><div class="line">        imageView.setFocusableInTouchMode(true);</div><div class="line">        imageView.requestFocus();</div><div class="line">        imageView.requestFocusFromTouch();</div><div class="line"></div><div class="line">        EditText editText = findViewById(R.id.edit);</div><div class="line">        editText.setOnFocusChangeListener(new View.OnFocusChangeListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onFocusChange(View v, boolean hasFocus) &#123;</div><div class="line">                AnimatedVectorDrawableCompat compat = AnimatedVectorDrawableCompat.create(</div><div class="line">                        MainActivity.this, R.drawable.animated_vector);</div><div class="line">                imageView.setImageDrawable(compat);</div><div class="line">                ((Animatable) imageView.getDrawable()).start();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;


&lt;h3 id=&quot;5-2-1-概述&quot;&gt;&lt;a href=&quot;#5-2-1-概述&quot; class=&quot;headerlink&quot; title=&quot;5.2.1 概述&quot;&gt;&lt;/a&gt;5.2.1 概述&lt;/h3&gt;&lt;p
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>05.1 精通自定义 View 之动画进阶——利用 PathMeasure 实现路径动画</title>
    <link href="http://yoursite.com/2019/07/05/Custom%20View/05.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%20PathMeasure%20%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2019/07/05/Custom View/05.1 精通自定义 View 之动画进阶——利用 PathMeasure 实现路径动画/</id>
    <published>2019-07-04T17:00:00.000Z</published>
    <updated>2019-10-04T07:15:04.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>PathMeasure 类似一个计算器，可以计算出指定路径的一些信息，比如路径总长、指定长度所对应的坐标等。我们可以通过 PathMeasure 可以实现复杂的动画效果。</p><h3 id="5-1-1-初始化"><a href="#5-1-1-初始化" class="headerlink" title="5.1.1 初始化"></a>5.1.1 初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 初始化方法一</div><div class="line">public PathMeasure();</div><div class="line">setPath(Path path, boolean forceClosed);</div><div class="line"></div><div class="line">// 初始化方法二</div><div class="line">public PathMeasure(Path path, boolean forceClosed);</div></pre></td></tr></table></figure><p>参数 boolean forceClosed 表示Path 最终是否需要闭合，如果为 true，则不管关联的 Path 是否是闭合的，都会被闭合。但是 forceClosed 参数对绑定的 Path 不会产生任何影响，例如一个折线段的 Path，本身是没有闭合的，当 forceClosed 设置为 true 的时候，PathMeasure 计算的 Path 是闭合的，但 Path 绘制出来的是不会闭合的。forceClosed 参数只对 PathMeasure 的测量结果有影响，例如一个折线段的 Path，本身没有闭合，当 forceClosed 设置为 true 时，PathMeasure 的计算就会包含最后一段闭合的路径，与原来的 Path 不同。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line">    private PathMeasure mPathMeasureFalse;</div><div class="line">    private PathMeasure mPathMeasureTrue;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.BLACK);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(8);</div><div class="line"></div><div class="line">        mPath = new Path();</div><div class="line">        mPath.moveTo(50, 50);</div><div class="line">        mPath.lineTo(50, 150);</div><div class="line">        mPath.lineTo(150, 150);</div><div class="line">        mPath.lineTo(150, 50);</div><div class="line"></div><div class="line">        mPathMeasureFalse = new PathMeasure(mPath, false);</div><div class="line">        mPathMeasureTrue = new PathMeasure(mPath, true);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        Log.i(&quot;xian&quot;, &quot;forceClosed=false----&gt;&quot; + mPathMeasureFalse.getLength());</div><div class="line">        Log.i(&quot;xian&quot;, &quot;forceClosed=true-----&gt;&quot; + mPathMeasureTrue.getLength());</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-adc6485f5f2929f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="path 图"></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-6c7df70a4f1b8325.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="日志输出"></p><p>从图中可以看到，我们创建的只是正方形的三条边，而日志打印结果表示：如果 forceClosed 为 false，则测量的是当前 Path 状态的长度；如果 forceClosed 为 true，则不论 Path 是否闭合，测量的都是 Path 的闭合长度。</p><h3 id="5-1-2-简单函数使用"><a href="#5-1-2-简单函数使用" class="headerlink" title="5.1.2 简单函数使用"></a>5.1.2 简单函数使用</h3><h4 id="1-getLength"><a href="#1-getLength" class="headerlink" title="1. getLength()"></a>1. getLength()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 获取一段路径的长度，不一定是整个 Path 的长度</div><div class="line">public float getLength()</div></pre></td></tr></table></figure><h4 id="2-isClosed"><a href="#2-isClosed" class="headerlink" title="2. isClosed()"></a>2. isClosed()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 判断测量 Path 时是否计算闭合，返回值是 forceClosed</div><div class="line">public boolean isClosed()</div></pre></td></tr></table></figure><h4 id="3-nextContour"><a href="#3-nextContour" class="headerlink" title="3. nextContour()"></a>3. nextContour()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public boolean nextContour()</div></pre></td></tr></table></figure><p>Path 可以由多条曲线构成，但不论是 getLength()、getSegment() 还是其他函数，都会只针对其中第一条线段进行计算。而 nextContour() 就是用于跳转到下一条曲线的函数。如果跳转成功，则返回 true；如果跳转失败，则返回 false。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath1, mPath2, mPath3;</div><div class="line">    private PathMeasure mPathMeasure;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.BLACK);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(8);</div><div class="line"></div><div class="line">        mPath1 = new Path();</div><div class="line">        mPath1.addRect(-50, -50, 50, 50, Path.Direction.CW);</div><div class="line">        mPath2 = new Path();</div><div class="line">        mPath2.addRect(-100, -100, 100, 100, Path.Direction.CW);</div><div class="line">        mPath3 = new Path();</div><div class="line">        mPath3.addRect(-120, -120, 120, 120, Path.Direction.CW);</div><div class="line">        mPathMeasure = new PathMeasure();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        canvas.translate(150, 150);</div><div class="line"></div><div class="line">        // 只绘画最大的区域</div><div class="line">        // mPath.addRect(-50, -50, 50, 50, Path.Direction.CW);</div><div class="line">        // mPath.addRect(-100, -100, 100, 100, Path.Direction.CW);</div><div class="line">        // mPath.addRect(-120, -120, 120, 120, Path.Direction.CW);</div><div class="line">        // canvas.drawPath(mPath, mPaint);</div><div class="line"></div><div class="line">        mPath1.addPath(mPath2);</div><div class="line">        mPath1.addPath(mPath3);</div><div class="line">        canvas.drawPath(mPath1, mPaint);</div><div class="line">        mPathMeasure.setPath(mPath1, false);</div><div class="line"></div><div class="line">        do &#123;</div><div class="line">            float len = mPathMeasure.getLength();</div><div class="line">            Log.i(&quot;xian&quot;, &quot;len=&quot; + len);</div><div class="line">        &#125; while (mPathMeasure.nextContour());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-fcf22a7220079a96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-aee6cf7489e70d83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="日志打印结果"></p><p>通过这个例子可以得出以下结论：</p><ul><li>nextContour() 函数得到的曲线的顺序与 Path 中添加的顺序相同。</li><li>getLength() 等函数针对的是当前线段，不是整个 Path。</li></ul><h3 id="5-1-3-getSegment-函数"><a href="#5-1-3-getSegment-函数" class="headerlink" title="5.1.3 getSegment() 函数"></a>5.1.3 getSegment() 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public boolean getSegment(float startD, float stopD, Path dst, boolean startWithMoveTo)</div></pre></td></tr></table></figure><p>用于截取整个 Path 中的某个片段，通过参数 startD 与 stopD 来控制截取的长度，并将截取后的 Path 保存并添加（不是替换）到参数 dst 中。startWithMoveTo 表示起始点是否使用 moveTo 将路径的新起点移动到结果 Path 的起始点，通常设置为 true，以保证每次截取的 Path 都是正常的、完整的；如果设置为 false，则新增的片段会从上一次 Path 终点开始计算，这样可以保证截取的 Path 片段是连续的，但不一定时正常的。</p><p>注意：</p><ul><li>如果 startD、stopD 的数值不在取值范围[0, getLength] 内，或者 startD == stopD，则返回值为 false，而且不会改变 dst 中的内容。</li><li>使用 getSegment() 函数时需要禁用硬件加速功能。 setLayerType(LAYER_TYPE_SOFTWARE, null)。</li></ul><p>示例一：用法举例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath, mDst;</div><div class="line">    private PathMeasure mPathMeasure;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.BLACK);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(8);</div><div class="line"></div><div class="line">        mPath = new Path();</div><div class="line">        mPath.addRect(-50, -50, 50, 50, Path.Direction.CW);</div><div class="line">        mDst = new Path();</div><div class="line">        mPathMeasure = new PathMeasure(mPath, false);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        canvas.translate(100, 100);</div><div class="line">        mPathMeasure.getSegment(0, 150, mDst, true);</div><div class="line">        canvas.drawPath(mDst, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-ace4ca83b064f380.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>结论一：路径截取是以路径的左上角为起始点开始的。</p></blockquote><p>示例二：逆时针<br>将生成路径的方式指定为逆时针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// mPath.addRect(-50, -50, 50, 50, Path.Direction.CW);</div><div class="line">mPath.addRect(-50, -50, 50, 50, Path.Direction.CCW);</div></pre></td></tr></table></figure></p><p>效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c571e32b3e662b87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>结论二：路径的截取方向与路径的生成方向相同。</p></blockquote><p>示例三：如果 dst 路径不为空<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mDst = new Path();</div><div class="line">mDst.lineTo(10, 100);</div><div class="line">mPathMeasure = new PathMeasure(mPath, false);</div></pre></td></tr></table></figure></p><p>效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-fb56b254e3f2b72b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>结论三：会将截取的 Path 片段添加到路径 dst 中，而不是替换 dst 中的内容。</p></blockquote><p>示例四：如果 startWithMoveTo 参数为 false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// mPathMeasure.getSegment(0, 150, mDst, true);</div><div class="line">mPathMeasure.getSegment(0, 150, mDst, false);</div></pre></td></tr></table></figure></p><p>效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-c63826461afbc1d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>结论四：如果 startWithMoveTo 为 true，则被截取出来的 Path 片段保持原状；如果 startWithMoveTo 为 false，则会截取出来的 Path 片段的起始点移动到 dst 的最后一个点，以保证 dst 路径的连续性。</p></blockquote><h4 id="示例：路径加载动画"><a href="#示例：路径加载动画" class="headerlink" title="示例：路径加载动画"></a>示例：路径加载动画</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0e3076580b729727.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mCirclePath, mDstPath;</div><div class="line">    private PathMeasure mPathMeasure;</div><div class="line">    private float mCurAnimValue;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.BLACK);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(4);</div><div class="line"></div><div class="line">        mDstPath = new Path();</div><div class="line">        mCirclePath = new Path();</div><div class="line">        mCirclePath.addCircle(100, 100, 50, Path.Direction.CW);</div><div class="line">        mPathMeasure = new PathMeasure(mCirclePath, false);</div><div class="line"></div><div class="line">        ValueAnimator animator = ValueAnimator.ofFloat(0, 1);</div><div class="line">        animator.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">                mCurAnimValue = (Float) animation.getAnimatedValue();</div><div class="line">                invalidate();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        animator.setDuration(1000);</div><div class="line">        animator.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawColor(Color.WHITE);</div><div class="line">        float stop = mPathMeasure.getLength() * mCurAnimValue;</div><div class="line">        mDstPath.reset();</div><div class="line">        mPathMeasure.getSegment(0, stop, mDstPath, true);</div><div class="line">        canvas.drawPath(mDstPath, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述示例中，在生成动画路径时，始终是从 0 位置开始的。如果我们稍微改变一下生成路径的起始点位置，就可以完成一个比较有意思的加载图动画，效果图如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-0bb7aa97dfd0d0db.gif?imageMogr2/auto-orient/strip" alt=""></p><p>修改代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line">    canvas.drawColor(Color.WHITE);</div><div class="line">    float length = mPathMeasure.getLength();</div><div class="line">    float stop = length * mCurAnimValue;</div><div class="line">    float start = (float) (stop - ((0.5 - Math.abs(mCurAnimValue - 0.5)) * length));</div><div class="line">    mDstPath.reset();</div><div class="line">    mPathMeasure.getSegment(start, stop, mDstPath, true);</div><div class="line">    canvas.drawPath(mDstPath, mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="5-1-4-getPosTan-函数"><a href="#5-1-4-getPosTan-函数" class="headerlink" title="5.1.4 getPosTan() 函数"></a>5.1.4 getPosTan() 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean getPosTan(float distance, float[] pos, float[] tan)</div></pre></td></tr></table></figure><p>用于得到路径上某一长度的位置以及该位置的正切值。参数：</p><ul><li>float distance：距离 Path 起始点的长度，取值范围 0 ≤ distance ≤ getLength。</li><li>float[] pos：该点的坐标值。pos[0] 表示 x 坐标，pos[1] 表示 y 坐标。</li><li>float[] tan：该点的正切值。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/14186083-52fa16f0ba77e7a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="半径为1的各点的坐标值"></p><p>在 Math 类中，有两个求反切值的函数，即夹角 a 的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">double atan(double d)</div><div class="line">double atan2(double x, double y)</div></pre></td></tr></table></figure></p><p>示例：飞机加载动画</p><p><img src="https://upload-images.jianshu.io/upload_images/10002669-6f7a869e08621eb2.png?imageMogr2/auto-orient/strip|imageView2/2/w/808/format/webp" alt="动画原理"></p><p>动画效果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-49a48bdececab025.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mCirclePath, mDstPath;</div><div class="line">    private PathMeasure mPathMeasure;</div><div class="line">    private float mCurAnimValue;</div><div class="line">    private Bitmap mPlaneBmp;</div><div class="line">    private Matrix mMatrix;</div><div class="line">    private ValueAnimator mValueAnimator;</div><div class="line">    private float[] pos = new float[2];</div><div class="line">    private float[] tan = new float[2];</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE, null);</div><div class="line">        mPlaneBmp = BitmapFactory.decodeResource(getResources(), R.drawable.plane);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.BLACK);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(4);</div><div class="line"></div><div class="line">        mDstPath = new Path();</div><div class="line">        mCirclePath = new Path();</div><div class="line">        mPathMeasure = new PathMeasure();</div><div class="line">        mMatrix = new Matrix();</div><div class="line"></div><div class="line">        mValueAnimator = ValueAnimator.ofFloat(0, 1);</div><div class="line">        mValueAnimator.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">        mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">                mCurAnimValue = (Float) animation.getAnimatedValue();</div><div class="line">                invalidate();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        mValueAnimator.setDuration(2000);</div><div class="line">        mValueAnimator.setInterpolator(new AccelerateDecelerateInterpolator());</div><div class="line">        mValueAnimator.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">        int width = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        int height = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">        int radius;</div><div class="line">        if (width &gt;= height) &#123;</div><div class="line">            radius = height / 2 - height / 8;</div><div class="line">        &#125; else &#123;</div><div class="line">            radius = width / 2 - width / 8;</div><div class="line">        &#125;</div><div class="line">        // 先画圆的 path，但是这个圆只是用来计算</div><div class="line">        mCirclePath.addCircle(width / 2f, height / 2f, radius, Path.Direction.CW);</div><div class="line">        //计算圆的path的长度</div><div class="line">        mPathMeasure.setPath(mCirclePath, false);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        // 绘制路径加载动画</div><div class="line">        float length = mPathMeasure.getLength();</div><div class="line">        float stop = length * mCurAnimValue;</div><div class="line">        float start = (float) (stop - ((0.5 - Math.abs(mCurAnimValue - 0.5)) * length));</div><div class="line"></div><div class="line">        mDstPath.reset();</div><div class="line">        mPathMeasure.getSegment(start, stop, mDstPath, true);</div><div class="line">        canvas.drawPath(mDstPath, mPaint);</div><div class="line"></div><div class="line">        // 旋转飞机图片并绘制</div><div class="line">        // 使用 getMatrix</div><div class="line">        // mPathMeasure.getMatrix(stop, mMatrix, PathMeasure.POSITION_MATRIX_FLAG|PathMeasure.TANGENT_MATRIX_FLAG);</div><div class="line">        // mMatrix.preTranslate(-mPlaneBmp.getWidth() / 2f,-mPlaneBmp.getHeight() / 2f);</div><div class="line"></div><div class="line">        // 使用 getPosTan</div><div class="line">        mPathMeasure.getPosTan(stop, pos, tan);</div><div class="line">        float degrees = (float) (Math.atan2(tan[1], tan[0]) * 180.0 / Math.PI);</div><div class="line">        float px = mPlaneBmp.getWidth() / 2f;</div><div class="line">        float py = mPlaneBmp.getHeight() / 2f;</div><div class="line">        mMatrix.reset();</div><div class="line">        mMatrix.postRotate(degrees, mPlaneBmp.getWidth() / 2f, mPlaneBmp.getHeight() / 2f);</div><div class="line">        mMatrix.postTranslate(pos[0] - px, pos[1] - py);</div><div class="line">        canvas.drawBitmap(mPlaneBmp, mMatrix, mPaint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDetachedFromWindow() &#123;</div><div class="line">        super.onDetachedFromWindow();</div><div class="line">        mValueAnimator.cancel();</div><div class="line">        mValueAnimator = null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="5-1-5-getMatrix-函数"><a href="#5-1-5-getMatrix-函数" class="headerlink" title="5.1.5 getMatrix() 函数"></a>5.1.5 getMatrix() 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean getMatrix(float distance, Matrix matrix, int flags)</div></pre></td></tr></table></figure><p>用于得到路径上某一长度的位置以及该位置的正切值的矩阵。</p><ul><li>distance：距离 Path 起始点的长度。</li><li>matrix：根据flags 封装好的 matrix 会根据 flags 的设置而存入不同的内容。</li><li>flags：用于指定哪些内容会存入 matrix 中。flags 值有两个：PathMeasure.POSITION_MATRIX_FLAG 表示获取位置信息；PathMeasure.TANGENT_MATRIX_FLAG 表示获取切边信息，使得图片按 Path 旋转。可以只指定一个，也可以用“|”同时指定。</li></ul><p>很明显，getMatrix() 函数只是 PathMeasure.getPosTan() 函数的另一种实现而已。如下更改飞机加载动画：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line">    // 绘制路径加载动画</div><div class="line">    float length = mPathMeasure.getLength();</div><div class="line">    float stop = length * mCurAnimValue;</div><div class="line">    float start = (float) (stop - ((0.5 - Math.abs(mCurAnimValue - 0.5)) * length));</div><div class="line"></div><div class="line">    mDstPath.reset();</div><div class="line">    mPathMeasure.getSegment(start, stop, mDstPath, true);</div><div class="line">    canvas.drawPath(mDstPath, mPaint);</div><div class="line"></div><div class="line">    // 旋转飞机图片并绘制</div><div class="line">    // 使用 getMatrix</div><div class="line">    mMatrix.reset();</div><div class="line">    mPathMeasure.getMatrix(stop, mMatrix, PathMeasure.POSITION_MATRIX_FLAG|PathMeasure.TANGENT_MATRIX_FLAG);</div><div class="line">    mMatrix.preTranslate(-mPlaneBmp.getWidth() / 2f,-mPlaneBmp.getHeight() / 2f);</div><div class="line"></div><div class="line">    // 使用 getPosTan</div><div class="line">    // mPathMeasure.getPosTan(stop, pos, tan);</div><div class="line">    // float degrees = (float) (Math.atan2(tan[1], tan[0]) * 180.0 / Math.PI);</div><div class="line">    // float px = mPlaneBmp.getWidth() / 2f;</div><div class="line">    // float py = mPlaneBmp.getHeight() / 2f;</div><div class="line">    // mMatrix.postRotate(degrees, mPlaneBmp.getWidth() / 2f, mPlaneBmp.getHeight() / 2f);</div><div class="line">    // mMatrix.postTranslate(pos[0] - px, pos[1] - py);</div><div class="line">    canvas.drawBitmap(mPlaneBmp, mMatrix, mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="5-1-6-示例：支付宝支付成功动画"><a href="#5-1-6-示例：支付宝支付成功动画" class="headerlink" title="5.1.6 示例：支付宝支付成功动画"></a>5.1.6 示例：支付宝支付成功动画</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a5fb69f068b0ad8b.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">public class TestView extends View &#123;</div><div class="line"></div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mCirclePath, mDstPath;</div><div class="line">    private PathMeasure mPathMeasure;</div><div class="line">    private float mCurAnimValue;</div><div class="line">    private ValueAnimator mValueAnimator;</div><div class="line">    private boolean mNext = false;</div><div class="line"></div><div class="line">    public TestView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.BLACK);</div><div class="line">        mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mPaint.setStrokeWidth(8);</div><div class="line"></div><div class="line">        mDstPath = new Path();</div><div class="line">        mCirclePath = new Path();</div><div class="line">        mPathMeasure = new PathMeasure();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">        mCirclePath.reset();</div><div class="line"></div><div class="line">        int width = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        int height = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">        int centerX = width / 2;</div><div class="line">        int centerY = height / 2;</div><div class="line">        int radius = Math.min(centerX, centerY) / 2;</div><div class="line"></div><div class="line">        mCirclePath.addCircle(centerX, centerY, radius, Path.Direction.CW);</div><div class="line">        mCirclePath.moveTo(centerX - radius/2f, centerY);                // 勾的起点</div><div class="line">        mCirclePath.lineTo(centerX,centerY + radius/2f);                 // 勾的拐点</div><div class="line">        mCirclePath.lineTo(centerX + radius/2f,centerY - radius/3f);  // 勾的终点</div><div class="line">        mPathMeasure.setPath(mCirclePath,false);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        if (mCurAnimValue &lt; 1) &#123;</div><div class="line">            float stop = mPathMeasure.getLength() * mCurAnimValue;</div><div class="line">            mPathMeasure.getSegment(0, stop, mDstPath, true);</div><div class="line">        &#125; else &#123;</div><div class="line">            if (!mNext) &#123;</div><div class="line">                mNext = true;</div><div class="line">                mPathMeasure.getSegment(0, mPathMeasure.getLength(), mDstPath, true);</div><div class="line">                mPathMeasure.nextContour();</div><div class="line">            &#125; else &#123;</div><div class="line">                float stop = mPathMeasure.getLength() * (mCurAnimValue - 1);</div><div class="line">                mPathMeasure.getSegment(0, stop, mDstPath, true);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        canvas.drawPath(mDstPath, mPaint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDetachedFromWindow() &#123;</div><div class="line">        super.onDetachedFromWindow();</div><div class="line">        if (mValueAnimator != null) &#123;</div><div class="line">            mValueAnimator.cancel();</div><div class="line">            mValueAnimator = null;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void startAnim() &#123;</div><div class="line">        mValueAnimator = ValueAnimator.ofFloat(0, 2);</div><div class="line">        mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">                mCurAnimValue = (Float) animation.getAnimatedValue();</div><div class="line">                invalidate();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        mValueAnimator.setDuration(2000);</div><div class="line">        mValueAnimator.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用自定义控件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        findViewById(R.id.start_btn).setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                TestView tv = findViewById(R.id.test_view);</div><div class="line">                tv.startAnim();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;


&lt;p&gt;PathMeasure 类似一个计算器，可以计算出指定路径的一些信息，比如路径总长、指定长度所对应的坐标等。我们可以通过 PathMeasure 可以实现复杂的动画效果。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>04.4 精通自定义 View 之属性动画进阶——NineOldAndroids</title>
    <link href="http://yoursite.com/2019/07/04/Custom%20View/04.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94NineOldAndroids/"/>
    <id>http://yoursite.com/2019/07/04/Custom View/04.4 精通自定义 View 之属性动画进阶——NineOldAndroids/</id>
    <published>2019-07-03T20:00:00.000Z</published>
    <updated>2019-10-04T07:13:42.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>Android 3.0 推出了全新的 Animation API，使用起来很方便，但是不能在 3.0 以下版本中使用。NineOldAndroids 是一个可以在任意 Android 版本上使用的 Animation API。</p><p>常用类有 ObjectAnimator、ValueAnimator、AnimatorSet、PropertyValuesHolder、Keyframe、ViewPropertyAnimator、ViewHelper.</p><h3 id="4-4-1-NineOldAndroids-中的-ViewPropertyAnimator"><a href="#4-4-1-NineOldAndroids-中的-ViewPropertyAnimator" class="headerlink" title="4.4.1 NineOldAndroids 中的 ViewPropertyAnimator"></a>4.4.1 NineOldAndroids 中的 ViewPropertyAnimator</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 官方 API（3.1 以上）</div><div class="line">mView.animate().setDuration(5000).rotationY(720).x(100).y(100).start();</div><div class="line"></div><div class="line">// NineOldAndroids</div><div class="line">ViewPropertyAnimator.animate(mView).setDuration(5000).rotationY(720).x(100).y(100).start();</div></pre></td></tr></table></figure><p>从对比中可以看出，唯一不同的是 animate() 函数，其他诸如链式操作、各属性对应的函数、添加监听器都与官方 API 完全相同</p><h3 id="4-4-2-NineOldAndroids-中的-ViewHelper"><a href="#4-4-2-NineOldAndroids-中的-ViewHelper" class="headerlink" title="4.4.2 NineOldAndroids 中的 ViewHelper"></a>4.4.2 NineOldAndroids 中的 ViewHelper</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>ViewHelper 提供了一系列 set/get 函数去操作 View 的各种属性，比如透明度、偏移量、旋转角度等，大大方便了我们的使用，而且无须考虑低版本的兼容性问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public static float getAlpha(View view)</div><div class="line">public static void setAlpha(View view, float alpha)</div><div class="line"></div><div class="line">public static float getPivotX(View view)</div><div class="line">public static void setPivotX(View view, float pivotX)</div><div class="line"></div><div class="line">public static float getPivotY(View view)</div><div class="line">public static void setPivotY(View view, float pivotY)</div><div class="line"></div><div class="line">public static float getRotation(View view)</div><div class="line">public static void setRotation(View view, float rotation)</div><div class="line"></div><div class="line">public static float getRotationX(View view)</div><div class="line">public static void setRotationX(View view, float rotationX)</div><div class="line"></div><div class="line">public static float getRotationY(View view)</div><div class="line">public static void setRotationY(View view, float rotationY)</div><div class="line"></div><div class="line">public static float getScaleX(View view)</div><div class="line">public static void setScaleX(View view, float scaleX)</div><div class="line"></div><div class="line">public static float getScaleY(View view)</div><div class="line">public static void setScaleY(View view, float scaleY)</div><div class="line"></div><div class="line">public static float getScrollX(View view)</div><div class="line">public static void setScrollX(View view, float scrollX)</div><div class="line"></div><div class="line">public static float getScrollY(View view)</div><div class="line">public static void setScrollY(View view, float scrollY)</div><div class="line"></div><div class="line">public static float getTranslationX(View view)</div><div class="line">public static void setTranslationX(View view, float translationX)</div><div class="line"></div><div class="line">public static float getTranslationY(View view)</div><div class="line">public static void setTranslationY(View view, float translationY)</div><div class="line"></div><div class="line">public static float getX(View view)</div><div class="line">public static void setX(View view, float x)</div><div class="line"></div><div class="line">public static float getY(View view)</div><div class="line">public static void setY(View view, float y)</div></pre></td></tr></table></figure></p><h4 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">final TextView tv = (TextView) findViewById(R.id.tv);</div><div class="line"></div><div class="line">findViewById(R.id.btn).setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">    public void onClick(View v) &#123;</div><div class="line">        ValueAnimator animator = ValueAnimator.ofFloat(0, 200);</div><div class="line">        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            public void onAnimationUpdate(ValueAnimator valueAnimator) &#123;</div><div class="line">                Float cur = (Float) valueAnimator.getAnimatedValue();</div><div class="line">                ViewHelper.setTranslationX(tv, cur);</div><div class="line">                ViewHelper.setTranslationY(tv, cur);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;Android 3.0 推出了全新的 Animation API，使用起来很方便，但是不能在 3.0 以下版本中使用。NineOldAndroids 是一个可以在任意 Android
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>04.3 精通自定义 View 之属性动画进阶——为 ViewGroup 内的组件添加动画</title>
    <link href="http://yoursite.com/2019/07/04/Custom%20View/04.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E4%B8%BA%20ViewGroup%20%E5%86%85%E7%9A%84%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2019/07/04/Custom View/04.3 精通自定义 View 之属性动画进阶——为 ViewGroup 内的组件添加动画/</id>
    <published>2019-07-03T19:00:00.000Z</published>
    <updated>2019-10-04T07:12:47.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="4-3-0-概述"><a href="#4-3-0-概述" class="headerlink" title="4.3.0 概述"></a>4.3.0 概述</h3><p>为 ViewGroup 内的组件添加动画，Android 共提供了 4 种方法。<br><strong>1. layoutAnimation 标签与 LayoutAnimationController</strong><br>第一：定义一个 layoutAnimation 的 animation 文件，如：(anim/layout_animation.xml)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;layoutAnimation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:delay=&quot;1&quot;</div><div class="line">    android:animationOrder=&quot;normal&quot;</div><div class="line">    android:animation=&quot;@anim/slide_in_left&quot;/&gt;</div></pre></td></tr></table></figure></p><p>第二步：在 viewGroup 类型的控件中，添加android:layoutAnimation=”@anim/layout_animation”，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;ListView</div><div class="line">    android:id=&quot;@+id/listview&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:layoutAnimation=&quot;@anim/layout_animation&quot; /&gt;</div></pre></td></tr></table></figure></p><p>其中 @anim/slide_in_left 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;1000&quot;&gt;</div><div class="line">    &lt;translate android:fromXDelta=&quot;-50%p&quot; android:toXDelta=&quot;0&quot;/&gt;</div><div class="line">    &lt;alpha android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot;/&gt;</div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure></p><blockquote><p>注意：android:layoutAnimation 只在 ViewGroup 创建的时候，才会对其中的 item 添加动画。在创建成功以后，再向其中添加 item 将不会再有动画。</p></blockquote><p><strong>2. gridLayoutAnimation 标签与 GridLayoutAnimationController</strong><br>gridLayoutAnimation 与 layoutAnimation 一样有缺陷：即在 GridView 初次创建的时候有入场动画，之后新添加的数据是不会有入场动画的。</p><p><a href="https://blog.csdn.net/harvic880925/article/details/50785786" target="_blank" rel="external">详情请点击前往：layoutAnimation &amp; gridLayoutAnimation</a></p><p><strong>3. animateLayoutChanges 属性</strong><br>在 API 11 之后，Android 为了支持 ViewGroup 类控件，在添加和移除其中控件时自动添加动画，为我们提供了一个非常简单的属性：android:animateLayoutChanges=[true/false]，所有派生自 ViewGroup 的控件都具有此属性，只要在 XML 中添加上这个属性，就能实现添加/删除其中控件时，带有默认动画了。</p><p><strong>4. LayoutTransition</strong><br>在 API 11 之后引入，可以实现在 ViewGroup 动态添加或删除其中的控件时指定动画。动画可以自定义。对比前三种方法，LayoutTransition 是最强大的。</p><h3 id="4-3-1-animateLayoutChanges-属性"><a href="#4-3-1-animateLayoutChanges-属性" class="headerlink" title="4.3.1 animateLayoutChanges 属性"></a>4.3.1 animateLayoutChanges 属性</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-1009a7ad10f53cab.gif?imageMogr2/auto-orient/strip" alt=""></p><p>在相应的 GroupView 子类中添加 android:animateLayoutChanges=”true”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;&gt;</div><div class="line">        &lt;Button</div><div class="line">            android:id=&quot;@+id/add_btn&quot;</div><div class="line">            android:layout_width=&quot;wrap_content&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:text=&quot;添加控件&quot;/&gt;</div><div class="line">        &lt;Button</div><div class="line">            android:id=&quot;@+id/remove_btn&quot;</div><div class="line">            android:layout_width=&quot;wrap_content&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:text=&quot;移除控件&quot;/&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line">    &lt;LinearLayout</div><div class="line">        android:id=&quot;@+id/layoutTransitionGroup&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:animateLayoutChanges=&quot;true&quot;</div><div class="line">        android:orientation=&quot;vertical&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123;</div><div class="line">    private LinearLayout layoutTransitionGroup;</div><div class="line"></div><div class="line">    private int i = 0;</div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        layoutTransitionGroup = findViewById(R.id.layoutTransitionGroup);</div><div class="line">        findViewById(R.id.add_btn).setOnClickListener(this);</div><div class="line">        findViewById(R.id.remove_btn).setOnClickListener(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void addButtonView() &#123;</div><div class="line">        i++;</div><div class="line">        Button button = new Button(this);</div><div class="line">        button.setText(&quot;button&quot; + i);</div><div class="line">        LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(</div><div class="line">                ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);</div><div class="line">        button.setLayoutParams(params);</div><div class="line">        layoutTransitionGroup.addView(button, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void removeButtonView() &#123;</div><div class="line">        if (i &gt; 0) &#123;</div><div class="line">            layoutTransitionGroup.removeViewAt(0);</div><div class="line">        &#125;</div><div class="line">        i--;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onClick(View v) &#123;</div><div class="line">        if (v.getId() == R.id.add_btn) &#123;</div><div class="line">            addButtonView();</div><div class="line">        &#125;</div><div class="line">        if (v.getId() == R.id.remove_btn) &#123;</div><div class="line">            removeButtonView();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="4-3-2-LayoutTransition"><a href="#4-3-2-LayoutTransition" class="headerlink" title="4.3.2 LayoutTransition"></a>4.3.2 LayoutTransition</h3><p>上面虽然在 ViewGroup 类控件 XML 中仅添加一行android:animateLayoutChanges=[true] 即可实现内部控件添加删除时都加上动画效果。但却只能使用默认动画效果，而无法自定义动画。</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-54c50a8ff19f0356.gif?imageMogr2/auto-orient/strip" alt=""></p><p>为了能让我们自定义动画，谷歌在 API 11 时，同时为我们引入了一个类 LayoutTransaction。要使用LayoutTransaction是非常容易的，只需要三步： </p><ol><li><p>创建实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LayoutTransaction transitioner = new LayoutTransition();</div></pre></td></tr></table></figure></li><li><p>创建动画并设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animOut = ObjectAnimator.ofFloat(null, &quot;rotation&quot;, 0f, 90f, 0f);</div><div class="line">transitioner.setAnimator(LayoutTransition.DISAPPEARING, animOut);</div></pre></td></tr></table></figure></li><li><p>将 LayoutTransaction 设置进 ViewGroup</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">linearLayout.setLayoutTransition(mTransitioner);</div></pre></td></tr></table></figure></li></ol><p>在第二步中，transitioner.setAnimator 设置动画的函数声明为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void setAnimator(int transitionType, Animator animator)</div></pre></td></tr></table></figure></p><ul><li><strong>int transitionType</strong>：表示当前应用动画的对象范围，取值有：<br>APPEARING：元素在容器中出现时所定义的动画。<br>DISAPPEARING：元素在容器中消失时所定义的动画。<br>CHANGE_APPEARING：由于容器中要显现一个新的元素，其它需要变化的元素所应用的动画。<br>CHANGE_DISAPPEARING：当容器中某个元素消失，其它需要变化的元素所应用的动画。</li><li><strong>Animator animator</strong>：表示当前所选范围的控件所使用的动画。</li></ul><h4 id="1-LayoutTransition-APPEARING-与-LayoutTransition-APPEARING"><a href="#1-LayoutTransition-APPEARING-与-LayoutTransition-APPEARING" class="headerlink" title="1. LayoutTransition.APPEARING 与 LayoutTransition.APPEARING"></a>1. LayoutTransition.APPEARING 与 LayoutTransition.APPEARING</h4><p>LayoutTransition.APPEARING 所对应的当一个控件出现时所对应的动画；LayoutTransition.DISAPPEARING 在一个控件被移除时所对应的动画。修改上一个示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">layoutTransitionGroup = findViewById(R.id.layoutTransitionGroup);</div><div class="line">findViewById(R.id.add_btn).setOnClickListener(this);</div><div class="line">findViewById(R.id.remove_btn).setOnClickListener(this);</div><div class="line"></div><div class="line">mTransitioner = new LayoutTransition();</div><div class="line">// 入场动画：view 在这个容器中出现时触发的动画</div><div class="line">ObjectAnimator animIn = ObjectAnimator.ofFloat(null, &quot;rotationY&quot;, 0f, 360f,0f);</div><div class="line">mTransitioner.setAnimator(LayoutTransition.APPEARING, animIn);</div><div class="line"></div><div class="line">// 出场动画：view 在这个容器中消失时触发的动画</div><div class="line">ObjectAnimator animOut = ObjectAnimator.ofFloat(null, &quot;rotation&quot;, 0f, 90f, 0f);</div><div class="line">mTransitioner.setAnimator(LayoutTransition.DISAPPEARING, animOut);</div><div class="line"></div><div class="line">layoutTransitionGroup.setLayoutTransition(mTransitioner);</div></pre></td></tr></table></figure></p><p>同时要删除 XML 中的 android:animateLayoutChanges=”true” 设置。</p><h4 id="2-LayoutTransition-CHANGE-APPEARING"><a href="#2-LayoutTransition-CHANGE-APPEARING" class="headerlink" title="2. LayoutTransition.CHANGE_APPEARING"></a>2. LayoutTransition.CHANGE_APPEARING</h4><p>在添加控件时，除了被添加控件本身的入场动画以外，其它需要移动位置的控件，在移动位置时，也被添加上了动画（left 点位移动画），这些除了被添加控件以外的其它需要移动位置的控件组合，所对应的动画就是 LayoutTransition.CHANGE_APPEARING。同样，在移除一个控件时，其它所有需要改变位置的控件组合所对应的动画就是 LayoutTransition.CHANGE_DISAPPEARING。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.act_main);</div><div class="line"> </div><div class="line">    layoutTransitionGroup = (LinearLayout) findViewById(R.id.layoutTransitionGroup);</div><div class="line">    findViewById(R.id.add_btn).setOnClickListener(this);</div><div class="line">    findViewById(R.id.remove_btn).setOnClickListener(this);</div><div class="line"> </div><div class="line">    mTransitioner = new LayoutTransition();</div><div class="line">    // 入场动画：view 在这个容器中出现时触发的动画</div><div class="line">    ObjectAnimator animIn = ObjectAnimator.ofFloat(null, &quot;rotationY&quot;, 0f, 360f,0f);</div><div class="line">    mTransitioner.setAnimator(LayoutTransition.APPEARING, animIn);</div><div class="line"> </div><div class="line">    // 出场动画：view 在这个容器中消失时触发的动画</div><div class="line">    ObjectAnimator animOut = ObjectAnimator.ofFloat(null, &quot;rotation&quot;, 0f, 90f, 0f);</div><div class="line">    mTransitioner.setAnimator(LayoutTransition.DISAPPEARING, animOut);</div><div class="line"> </div><div class="line">    PropertyValuesHolder pvhLeft = PropertyValuesHolder.ofInt(&quot;left&quot;,0,100,0);</div><div class="line">    PropertyValuesHolder pvhTop = PropertyValuesHolder.ofInt(&quot;top&quot;,1,1);</div><div class="line">    Animator changeAppearAnimator = ObjectAnimator.ofPropertyValuesHolder(</div><div class="line">        layoutTransitionGroup, pvhLeft,pvhBottom,pvhTop,pvhRight);</div><div class="line">    mTransitioner.setAnimator(LayoutTransition.CHANGE_APPEARING,changeAppearAnimator);</div><div class="line"> </div><div class="line">    layoutTransitionGroup.setLayoutTransition(mTransitioner);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注意：<br>1、LayoutTransition.CHANGE_APPEARING 和 LayoutTransition.CHANGE_DISAPPEARING 必须使用 PropertyValuesHolder 所构造的动画才会有效果，不然无效！也就是说使用 ObjectAnimator 构造的动画，在这里是不会有效果的！<br>2、在构造 PropertyValuesHolder 动画时，“left”、“top” 属性的变动是必写的。如果不需要变动，则直接写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PropertyValuesHolder pvhLeft = PropertyValuesHolder.ofInt(&quot;left&quot;,0,0);</div><div class="line">PropertyValuesHolder pvhTop = PropertyValuesHolder.ofInt(&quot;top&quot;,0,0);</div></pre></td></tr></table></figure></p><p>3、在构造 PropertyValuesHolder 时，所使用的 ofInt、ofFloat 中的参数值，第一个值和最后一个值必须相同，不然此属性所对应的的动画将被放弃，在此属性值上将不会有效果。<br>4、在构造 PropertyValuesHolder 时，所使用的 ofInt，ofFloat 中，如果所有参数值都相同，也将不会有动画效果。</p><h4 id="3-LayoutTransition-CHANGE-DISAPPEARING"><a href="#3-LayoutTransition-CHANGE-DISAPPEARING" class="headerlink" title="3. LayoutTransition.CHANGE_DISAPPEARING"></a>3. LayoutTransition.CHANGE_DISAPPEARING</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">PropertyValuesHolder outLeft = PropertyValuesHolder.ofInt(&quot;left&quot;,0,0);</div><div class="line">PropertyValuesHolder outTop = PropertyValuesHolder.ofInt(&quot;top&quot;,0,0);</div><div class="line"> </div><div class="line">Keyframe frame0 = Keyframe.ofFloat(0f, 0);</div><div class="line">Keyframe frame1 = Keyframe.ofFloat(0.1f, -20f);</div><div class="line">Keyframe frame2 = Keyframe.ofFloat(0.2f, 20f);</div><div class="line">Keyframe frame3 = Keyframe.ofFloat(0.3f, -20f);</div><div class="line">Keyframe frame4 = Keyframe.ofFloat(0.4f, 20f);</div><div class="line">Keyframe frame5 = Keyframe.ofFloat(0.5f, -20f);</div><div class="line">Keyframe frame6 = Keyframe.ofFloat(0.6f, 20f);</div><div class="line">Keyframe frame7 = Keyframe.ofFloat(0.7f, -20f);</div><div class="line">Keyframe frame8 = Keyframe.ofFloat(0.8f, 20f);</div><div class="line">Keyframe frame9 = Keyframe.ofFloat(0.9f, -20f);</div><div class="line">Keyframe frame10 = Keyframe.ofFloat(1, 0);</div><div class="line">PropertyValuesHolder mPropertyValuesHolder = PropertyValuesHolder.ofKeyframe(</div><div class="line">        &quot;rotation&quot;,frame0,frame1,frame2,frame3,frame4,</div><div class="line">        frame5,frame6,frame7,frame8,frame9,frame10);</div><div class="line"> </div><div class="line">ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(</div><div class="line">        this, outLeft,outTop,mPropertyValuesHolder);</div><div class="line">mTransitioner.setAnimator(LayoutTransition.CHANGE_DISAPPEARING, animator);</div></pre></td></tr></table></figure><p>第一步：由于 left、top 属性是必须的，但我们做响铃效果时，是不需要 left，top 变动的，所有给他们设置为无效值。<br>第二步：用 KeyFrame 构造 PropertyValuesHolder。<br>第三步：设置 LayoutTransition.CHANGE_DISAPPEARING 动画。</p><h3 id="4-3-3-其他函数"><a href="#4-3-3-其他函数" class="headerlink" title="4.3.3 其他函数"></a>4.3.3 其他函数</h3><h4 id="1-基本设置"><a href="#1-基本设置" class="headerlink" title="1. 基本设置"></a>1. 基本设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 设置所有动画完成所需要的时长</div><div class="line"> */</div><div class="line">public void setDuration(long duration)</div><div class="line">/**</div><div class="line"> * 针对单个type，设置动画时长；</div><div class="line"> * transitionType取值为：APPEARING、DISAPPEARING、CHANGE_APPEARING、CHANGE_DISAPPEARING</div><div class="line"> */</div><div class="line">public void setDuration(int transitionType, long duration) </div><div class="line">/**</div><div class="line"> * 针对单个type设置插值器</div><div class="line"> * transitionType取值为：APPEARING、DISAPPEARING、CHANGE_APPEARING、CHANGE_DISAPPEARING</div><div class="line"> */</div><div class="line">public void setInterpolator(int transitionType, TimeInterpolator interpolator)</div><div class="line">/**</div><div class="line"> * 针对单个type设置动画延时</div><div class="line"> * transitionType取值为：APPEARING、DISAPPEARING、CHANGE_APPEARING、CHANGE_DISAPPEARING</div><div class="line"> */</div><div class="line">public void setStartDelay(int transitionType, long delay)</div><div class="line">/**</div><div class="line"> * 针对单个type设置，每个子item动画的时间间隔</div><div class="line"> */</div><div class="line">public void setStagger(int transitionType, long duration)</div></pre></td></tr></table></figure><h4 id="2-LayoutTransition-设置监听"><a href="#2-LayoutTransition-设置监听" class="headerlink" title="2. LayoutTransition 设置监听"></a>2. LayoutTransition 设置监听</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void addTransitionListener(TransitionListener listener)</div><div class="line">public interface TransitionListener &#123;</div><div class="line">    public void startTransition(LayoutTransition transition, ViewGroup container,View view, int transitionType);</div><div class="line">    public void endTransition(LayoutTransition transition, ViewGroup container,View view, int transitionType);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 TransitionListener 中总共有四个参数：</p><ul><li>LayoutTransition transition：当前的 LayoutTransition 实例。</li><li>ViewGroup container：当前应用 LayoutTransition 的 container。</li><li>View view：当前在做动画的 View 对象。</li><li>int transitionType：当前的 LayoutTransition 类型，取值有：APPEARING、DISAPPEARING、CHANGE_APPEARING、CHANGE_DISAPPEARING。</li></ul><p>在添加控件时，先是 start 回调，再是 end 回调；APPEARING 事件所对应的 View 是控件，而 CHANGE_APPEARING 所对应的控件是容器。删除控件时，原理相同。</p><p>这是因为，在添加控件时，APPEARING 事件只针对当前被添加的控件做动画，所以返回的 View 是当前被添加的控件。而 CHANGE_APPEARING 是对容器中所有已存在的控件做动画，所以返回的 View 是容器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h3 id=&quot;4-3-0-概述&quot;&gt;&lt;a href=&quot;#4-3-0-概述&quot; class=&quot;headerlink&quot; title=&quot;4.3.0 概述&quot;&gt;&lt;/a&gt;4.3.0 概述&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>04.2 精通自定义 View 之属性动画进阶——ViewPropertyAnimator</title>
    <link href="http://yoursite.com/2019/07/04/Custom%20View/04.2%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94ViewPropertyAnimator/"/>
    <id>http://yoursite.com/2019/07/04/Custom View/04.2 精通自定义 View 之属性动画进阶——ViewPropertyAnimator/</id>
    <published>2019-07-03T18:00:00.000Z</published>
    <updated>2019-10-04T07:10:31.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="4-2-1-概述"><a href="#4-2-1-概述" class="headerlink" title="4.2.1 概述"></a>4.2.1 概述</h3><p>使用 ObjectAnimator：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(mView, &quot;alpha&quot;, 0f);</div><div class="line">animator.start();</div></pre></td></tr></table></figure></p><p>使用 ViewPropertyAnimator：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mView.animate().alpha(0f);</div></pre></td></tr></table></figure></p><p>除此之外，还可以非常容易地将多个动画结合起来。比如：将控件移动到点 (50, 100) 且完全透明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mView.animate().x(50).y(100).alpha(0f);</div></pre></td></tr></table></figure></p><p>此类事专门针对 View 对象动画而操作的类：链式调用，自动 start， 简化流程，提高效率： </p><ul><li>提供了更简洁的链式调用设置多个属性动画，这些动画可以同时进行的。</li><li>拥有更好的性能，多个属性动画是一次同时变化，只执行一次 UI 刷新（也就是只调用一次 invalidate，而 n 个 ObjectAnimator 就会进行 n 次属性变化，就有 n 次 invalidate）。</li><li>每个属性提供两种类型方法设置。如：scaleX()、scaleXBy()。</li><li>该类只能通过 View 的 animate() 获取其实例对象的引用。</li></ul><h3 id="4-2-2-常用函数"><a href="#4-2-2-常用函数" class="headerlink" title="4.2.2 常用函数"></a>4.2.2 常用函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">view.animate()                  // 获取ViewPropertyAnimator对象</div><div class="line">        // 位移</div><div class="line">        .translationX(100)</div><div class="line">        .translationXBy(100)</div><div class="line">        .translationY(100)</div><div class="line">        .translationYBy(100)</div><div class="line">        .translationZ(100)      // Z 轴移动，API 21 添加</div><div class="line">        .translationZBy(100)    // API 21 添加</div><div class="line">        // 改变坐标</div><div class="line">        .x(100)</div><div class="line">        .xBy(100)</div><div class="line">        .y(100)</div><div class="line">        .yBy(100)</div><div class="line">        // 改变透明度</div><div class="line">        .alpha(0.1f)</div><div class="line">        .alphaBy(0.1f)</div><div class="line">        // 改变透明度</div><div class="line">        .scaleX(0.1f)</div><div class="line">        .scaleXBy(0.1f)</div><div class="line">        .scaleY(0.1f)</div><div class="line">        .scaleYBy(0.1f)</div><div class="line">        // 旋转</div><div class="line">        .rotation(180)</div><div class="line">        .rotationX(180)</div><div class="line">        .rotationBy(180)</div><div class="line">        .rotationY(180)</div><div class="line">        .rotationYBy(180)</div><div class="line">        // 持续时间</div><div class="line">        .setDuration(1000)</div><div class="line">        // 动画开始时执行 runnable，API 16 添加</div><div class="line">        .withStartAction(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        // 动画结束时执行 runnable，API 16 添加</div><div class="line">        .withEndAction(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .withLayer()            // 硬件加速,API 16添加</div><div class="line">        .setStartDelay(1000)    // 执行延迟</div><div class="line">        // 设置插值器</div><div class="line">        .setInterpolator(new LinearInterpolator())</div><div class="line">        // 设置更新监听</div><div class="line">        .setUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;&#125;</div><div class="line">        &#125;)</div><div class="line">        // 动画监听</div><div class="line">        .setListener(new Animator.AnimatorListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationStart(Animator animation) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationEnd(Animator animation) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationCancel(Animator animation) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationRepeat(Animator animation) &#123;&#125;</div><div class="line">        &#125;)</div><div class="line">        .start();</div></pre></td></tr></table></figure><p>举例说明一下 xxxX() 和 xxxXBy() 函数之间的区别。如 scaleY(2f) 和 scaleYBy(2f)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private TextView tv1, tv2;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        Button startBtn = findViewById(R.id.start_btn);</div><div class="line">        tv1 = findViewById(R.id.tv1);</div><div class="line">        tv2 = findViewById(R.id.tv2);</div><div class="line"></div><div class="line">        startBtn.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                tv1.animate().scaleX(2f);</div><div class="line">                tv2.animate().scaleXBy(2f);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>原图：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-4c85d0f46e0e3cea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>第一次点击开始动画按钮，效果图如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f744e1aa04b08df1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>第二次点击开始动画按钮，效果图如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-aa7a1ac92a785e49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h3 id=&quot;4-2-1-概述&quot;&gt;&lt;a href=&quot;#4-2-1-概述&quot; class=&quot;headerlink&quot; title=&quot;4.2.1 概述&quot;&gt;&lt;/a&gt;4.2.1 概述&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>04.1 精通自定义 View 之属性动画进阶——PropertyValuesHolder 与 Keyframe</title>
    <link href="http://yoursite.com/2019/07/04/Custom%20View/04.1%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94PropertyValuesHolder%20%E4%B8%8E%20Keyframe/"/>
    <id>http://yoursite.com/2019/07/04/Custom View/04.1 精通自定义 View 之属性动画进阶——PropertyValuesHolder 与 Keyframe/</id>
    <published>2019-07-03T17:00:00.000Z</published>
    <updated>2019-10-04T07:09:42.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>ValueAnimator、ObjectAnimator 除了 ofInt()、ofFloat()、ofObject() 函数创建 Animator 实例的方法以外，都还有一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// valueAnimator 的</div><div class="line">public static ValueAnimator ofPropertyValuesHolder (</div><div class="line">    PropertyValuesHolder... values) </div><div class="line">// ObjectAnimator的</div><div class="line">public static ObjectAnimator ofPropertyValuesHolder (</div><div class="line">    Object target,PropertyValuesHolder... values)</div></pre></td></tr></table></figure></p><h3 id="4-1-1-PropertyValuesHolder"><a href="#4-1-1-PropertyValuesHolder" class="headerlink" title="4.1.1 PropertyValuesHolder"></a>4.1.1 PropertyValuesHolder</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>PropertyValuesHolder 这个类的意义就是，它其中保存了动画过程中所需要操作的属性和对应的值。我们通过 ofFloat(Object target, String propertyName, float… values) 构造的动画，ofFloat() 的内部实现其实就是将传进来的参数封装成 PropertyValuesHolder 实例来保存动画状态。在封装成 PropertyValuesHolder 实例以后，后期的各种操作也是以 PropertyValuesHolder 为主的。</p><p>PropertyValuesHolder 中有很多函数，有些函数的 api 等级是11，有些函数的 api 等级是 14 和 21，具体参考文档<a href="http://developer.android.com/reference/android/animation/PropertyValuesHolder.html" target="_blank" rel="external">《Google：PropertyValuesHolder》</a></p><p>首先，我们来看看创建实例的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static PropertyValuesHolder ofFloat(String propertyName, float... values)</div><div class="line">public static PropertyValuesHolder ofInt(String propertyName, int... values) </div><div class="line">public static PropertyValuesHolder ofObject(String propertyName, TypeEvaluator evaluator, Object... values)</div><div class="line">public static PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values)</div></pre></td></tr></table></figure></p><h4 id="2-PropertyValuesHolder-之-ofFloat-、ofInt"><a href="#2-PropertyValuesHolder-之-ofFloat-、ofInt" class="headerlink" title="2. PropertyValuesHolder 之 ofFloat()、ofInt()"></a>2. PropertyValuesHolder 之 ofFloat()、ofInt()</h4><p>1）ofFloat()、ofInt()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static PropertyValuesHolder ofFloat(String propertyName, float... values)</div><div class="line">public static PropertyValuesHolder ofInt(String propertyName, int... values)</div></pre></td></tr></table></figure></p><ul><li><strong>propertyName</strong>：表示 ObjectAnimator 需要操作的属性名。即 ObjectAnimator 需要通过反射查找对应属性的 setProperty() 函数的那个 property.</li><li><strong>values</strong>：属性所对应的参数，同样是可变长参数，可以指定多个，还记得我们在 ObjectAnimator 中讲过，如果只指定了一个，那么 ObjectAnimator 会通过查找 getProperty() 方法来获得初始值。</li></ul><p>2）ObjectAnimator.ofPropertyValuesHolder()<br>ObjectAnimator 提供了一个方法，构造 PropertyValuesHolder 来构造动画。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ObjectAnimator ofPropertyValuesHolder(Object target, </div><div class="line">        PropertyValuesHolder... values)</div></pre></td></tr></table></figure></p><ul><li><strong>target</strong>：指需要执行动画的控件。</li><li><strong>values</strong>：是一个可变长参数，可以传进去多个PropertyValuesHolder 实例，由于每个 PropertyValuesHolder 实例都会针对一个属性做动画，所以如果传进去多个 PropertyValuesHolder 实例，将会对控件的多个属性同时做动画操作。 </li></ul><p>3）示例</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f17b350f2aa6422b.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private TextView mTv;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        Button startBtn = findViewById(R.id.start_btn);</div><div class="line">        mTv = findViewById(R.id.tv);</div><div class="line"></div><div class="line">        startBtn.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                startAnim();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void startAnim() &#123;</div><div class="line">        PropertyValuesHolder rotationHolder = PropertyValuesHolder.ofFloat(&quot;rotation&quot;,</div><div class="line">                60f, -60f, 40f, -40f, 20f, -20f, 10f, -10f, 0f);</div><div class="line">        PropertyValuesHolder alphaHolder = PropertyValuesHolder.ofFloat(&quot;alpha&quot;,</div><div class="line">                0.1f, 1f, 0.1f, 1f);</div><div class="line">        ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(mTv, rotationHolder, alphaHolder);</div><div class="line">        animator.setDuration(3000);</div><div class="line">        animator.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3-PropertyValuesHolder-之-ofObject"><a href="#3-PropertyValuesHolder-之-ofObject" class="headerlink" title="3. PropertyValuesHolder 之 ofObject()"></a>3. PropertyValuesHolder 之 ofObject()</h4><p>1）概述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static PropertyValuesHolder ofObject(String propertyName, </div><div class="line">        TypeEvaluator evaluator, Object... values)</div></pre></td></tr></table></figure></p><ul><li><strong>propertyName</strong>：ObjectAnimator 动画操作的属性名。</li><li><strong>evaluator</strong>：Evaluator 实例，Evaluator 是将当前动画进度计算出当前值的类，可以使用系统自带的 IntEvaluator、FloatEvaluator 也可以自定义。</li><li><strong>values</strong>：可变长参数，表示操作动画属性的值。</li></ul><p>2）示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-db0243fadce74f39.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private TextView mTv;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        Button startBtn = findViewById(R.id.start_btn);</div><div class="line">        mTv = findViewById(R.id.tv);</div><div class="line"></div><div class="line">        startBtn.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                startAnim();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void startAnim() &#123;</div><div class="line">        PropertyValuesHolder charHolder = PropertyValuesHolder.ofObject(&quot;CharText&quot;,</div><div class="line">                new CharEvaluator(), Character.valueOf(&apos;A&apos;), Character.valueOf(&apos;Z&apos;));</div><div class="line">        ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(mTv, charHolder);</div><div class="line">        animator.setDuration(3000);</div><div class="line">        animator.setInterpolator(new AccelerateInterpolator());</div><div class="line">        animator.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>自定义 View 和 Evaluator<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class MyTextView extends AppCompatTextView &#123;</div><div class="line">    private Character charText;</div><div class="line"></div><div class="line">    public MyTextView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setCharText(Character charText) &#123;</div><div class="line">        setText(String.valueOf(charText));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class CharEvaluator implements TypeEvaluator&lt;Character&gt; &#123;</div><div class="line">    @Override</div><div class="line">    public Character evaluate(float fraction, Character startValue, Character endValue) &#123;</div><div class="line">        int startInt = (int) startValue;</div><div class="line">        int endInt = (int) endValue;</div><div class="line">        int result = (int) (startInt + fraction * (endInt - startInt));</div><div class="line">        return (char) result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="4-1-2-Keyframe"><a href="#4-1-2-Keyframe" class="headerlink" title="4.1.2 Keyframe"></a>4.1.2 Keyframe</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>如果要控制动画速率的变化，可以通过自定义插值器，也可以通过自定义 Evaluator 来实现。但需要足够的数学知识。 为了解决方便的控制动画速率的问题，谷歌为了我们定义了一个 KeyFrame 的类，KeyFrame 直译过来就是关键帧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static Keyframe ofFloat(float fraction, float value)</div></pre></td></tr></table></figure></p><ul><li><strong>fraction</strong>：表示当前的显示进度，即从加速器中 getInterpolation() 函数的返回值。</li><li><strong>value</strong>：表示当前应该在的位置。</li></ul><p>比如 Keyframe.ofFloat(0, 0) 表示动画进度为 0 时，动画所在的数值位置为 0；Keyframe.ofFloat(0.25f, -20f) 表示动画进度为 25% 时，动画所在的数值位置为 -20；Keyframe.ofFloat(1f, 0) 表示动画结束时，动画所在的数值位置为 0。</p><p>PropertyValuesHolder 是这样使用 KeyFrame 对象的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values)</div></pre></td></tr></table></figure></p><ul><li><strong>propertyName</strong>：动画所要操作的属性名。</li><li><strong>values</strong>：Keyframe 的列表，PropertyValuesHolder 会根据每个 Keyframe 的设定，定时将指定的值输出给动画。</li></ul><p>所以完整的 KeyFrame 的使用代码应该是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Keyframe frame0 = Keyframe.ofFloat(0f, 0);</div><div class="line">Keyframe frame1 = Keyframe.ofFloat(0.1f, -20f);</div><div class="line">Keyframe frame2 = Keyframe.ofFloat(1, 0);</div><div class="line">PropertyValuesHolder frameHolder = PropertyValuesHolder.ofKeyframe(</div><div class="line">        &quot;rotation&quot;,frame0,frame1,frame2);</div><div class="line">Animator animator = ObjectAnimator.ofPropertyValuesHolder(mImage,frameHolder);</div><div class="line">animator.setDuration(1000);</div><div class="line">animator.start();</div></pre></td></tr></table></figure></p><h4 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-29d2aa9f6df19102.gif?imageMogr2/auto-orient/strip" alt=""></p><p>1）布局文件 act_main.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;</div><div class="line">    android:padding=&quot;20dp&quot;&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/start_btn&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;start animation&quot;/&gt;</div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/tel_img&quot;</div><div class="line">        android:layout_width=&quot;70dp&quot;</div><div class="line">        android:layout_height=&quot;70dp&quot;</div><div class="line">        android:layout_margin=&quot;30dp&quot;</div><div class="line">        android:src=&quot;@drawable/icon_tel&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>2）MainActivity.java 核心代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Keyframe frame0 = Keyframe.ofFloat(0f, 0);</div><div class="line">Keyframe frame1 = Keyframe.ofFloat(0.1f, -20f);</div><div class="line">Keyframe frame2 = Keyframe.ofFloat(0.2f, 20f);</div><div class="line">Keyframe frame3 = Keyframe.ofFloat(0.3f, -20f);</div><div class="line">Keyframe frame4 = Keyframe.ofFloat(0.4f, 20f);</div><div class="line">Keyframe frame5 = Keyframe.ofFloat(0.5f, -20f);</div><div class="line">Keyframe frame6 = Keyframe.ofFloat(0.6f, 20f);</div><div class="line">Keyframe frame7 = Keyframe.ofFloat(0.7f, -20f);</div><div class="line">Keyframe frame8 = Keyframe.ofFloat(0.8f, 20f);</div><div class="line">Keyframe frame9 = Keyframe.ofFloat(0.9f, -20f);</div><div class="line">Keyframe frame10 = Keyframe.ofFloat(1f, 0);</div><div class="line">PropertyValuesHolder frameHolder = PropertyValuesHolder.ofKeyframe(&quot;rotation&quot;,</div><div class="line">        frame0, frame1, frame2, frame3, frame4, frame5,</div><div class="line">        frame6, frame7, frame8, frame9, frame10);</div><div class="line">Animator animator = ObjectAnimator.ofPropertyValuesHolder(mView, frameHolder);</div><div class="line">animator.setDuration(2000);</div><div class="line">animator.start();</div></pre></td></tr></table></figure></p><h4 id="3-ofInt-和-ofFloat"><a href="#3-ofInt-和-ofFloat" class="headerlink" title="3. ofInt 和 ofFloat"></a>3. ofInt 和 ofFloat</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// ofFloat</div><div class="line">public static Keyframe ofFloat(float fraction) </div><div class="line">public static Keyframe ofFloat(float fraction, float value)</div><div class="line">// ofInt</div><div class="line">public static Keyframe ofInt(float fraction)</div><div class="line">public static Keyframe ofInt(float fraction, int value)</div></pre></td></tr></table></figure><p>fraction 表示当前关键帧所在的动画进度位置，value 表示当前位置所对应的值。</p><p>Keyframe 还有一些常用函数来设置 fraction，value 和 interpolator，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 设置fraction参数，即Keyframe所对应的进度</div><div class="line">public void setFraction(float fraction) </div><div class="line">// 设置当前Keyframe所对应的值</div><div class="line">public void setValue(Object value)</div><div class="line">// 设置Keyframe动作期间所对应的插值器</div><div class="line">public void setInterpolator(TimeInterpolator interpolator)</div></pre></td></tr></table></figure></p><p>如果使用 ofFloat(float fraction) 来构造，也必须使用 setValue(Object value) 来设置这个关键帧所对应的值。</p><h4 id="4-插值器"><a href="#4-插值器" class="headerlink" title="4. 插值器"></a>4. 插值器</h4><p>如果给某个 Keyframe 设置上插值器，那么这个插值器就是从上一个 Keyframe 开始到当前设置插值器的 Keyframe 时，这个过程值的计算是利用这个插值器的，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Keyframe frame0 = Keyframe.ofFloat(0f, 0);</div><div class="line">Keyframe frame1 = Keyframe.ofFloat(0.1f, -20f);</div><div class="line">frame1.setInterpolator(new BounceInterpolator());</div><div class="line">Keyframe frame2 = Keyframe.ofFloat(1f, 20f);</div><div class="line">frame2.setInterpolator(new LinearInterpolator());</div></pre></td></tr></table></figure></p><p>在上面的代码中，我们给 frame1 设置了插值器 BounceInterpolator，那么在 frame0 到 frame1 的中间值计算过程中，就是用的就是回弹插值器；同样，我们给 frame2 设置了线性插值器 LinearInterpolator，所以在 frame1 到 frame2 的中间值计算过程中，使用的就是线性插值器。很显然，给 Keyframe.ofFloat(0f, 0) 设置插值器是无效的，因为它是第一帧。</p><h4 id="5-Keyframe-之-ofObject"><a href="#5-Keyframe-之-ofObject" class="headerlink" title="5. Keyframe 之 ofObject"></a>5. Keyframe 之 ofObject</h4><p><img src="https://upload-images.jianshu.io/upload_images/14186083-f02d1264fbae982f.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static Keyframe ofObject(float fraction)</div><div class="line">public static Keyframe ofObject(float fraction, Object value)</div></pre></td></tr></table></figure><p>同样，如果使用 ofObject(float fraction) 来构造，也必须使用 setValue(Object value) 来设置这个关键帧所对应的值。</p><p>还以 TextView 更改字母的例子来使用下 Keyframe.ofObject：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Keyframe frame0 = Keyframe.ofObject(0f, Character.valueOf(&apos;A&apos;));</div><div class="line">Keyframe frame1 = Keyframe.ofObject(0.1f, Character.valueOf(&apos;L&apos;));</div><div class="line">Keyframe frame2 = Keyframe.ofObject(1f, Character.valueOf(&apos;Z&apos;));</div><div class="line">PropertyValuesHolder frameHolder = PropertyValuesHolder.ofKeyframe(&quot;CharText&quot;,</div><div class="line">        frame0, frame1, frame2);</div><div class="line">frameHolder.setEvaluator(new CharEvaluator());</div><div class="line">Animator animator = ObjectAnimator.ofPropertyValuesHolder(mView, frameHolder);</div><div class="line">animator.setDuration(2000);</div><div class="line">animator.start();</div></pre></td></tr></table></figure></p><h4 id="6-疑问：如果没有设置进度为0或者进度为1时的关键帧，展示是怎样的？"><a href="#6-疑问：如果没有设置进度为0或者进度为1时的关键帧，展示是怎样的？" class="headerlink" title="6. 疑问：如果没有设置进度为0或者进度为1时的关键帧，展示是怎样的？"></a>6. 疑问：如果没有设置进度为0或者进度为1时的关键帧，展示是怎样的？</h4><ul><li>如果去掉第 0 帧，将以第一个关键帧为起始位置。</li><li>如果去掉结束帧，将以最后一个关键帧为结束位置。</li><li>使用 Keyframe 来构建动画，至少要有两个或两个以上帧，否则奔溃。</li></ul><h3 id="4-1-3-PropertyValuesHolder-其他函数"><a href="#4-1-3-PropertyValuesHolder-其他函数" class="headerlink" title="4.1.3 PropertyValuesHolder 其他函数"></a>4.1.3 PropertyValuesHolder 其他函数</h3><p>PropertyValuesHolder 除了上面的讲到的 ofInt、ofFloat、ofObject、ofKeyframe 以外，API 11 的还有几个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 设置动画的Evaluator</div><div class="line">public void setEvaluator(TypeEvaluator evaluator)</div><div class="line">// 用于设置ofFloat所对应的动画值列表</div><div class="line">public void setFloatValues(float... values)</div><div class="line">// 用于设置ofInt所对应的动画值列表</div><div class="line">public void setIntValues(int... values)</div><div class="line">// 用于设置ofKeyframe所对应的动画值列表</div><div class="line">public void setKeyframes(Keyframe... values)</div><div class="line">// 用于设置ofObject所对应的动画值列表</div><div class="line">public void setObjectValues(Object... values)</div><div class="line">// 设置动画属性名</div><div class="line">public void setPropertyName(String propertyName)</div></pre></td></tr></table></figure></p><h3 id="4-1-4-示例：电话响铃效果"><a href="#4-1-4-示例：电话响铃效果" class="headerlink" title="4.1.4 示例：电话响铃效果"></a>4.1.4 示例：电话响铃效果</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-81f9947638db226f.gif?imageMogr2/auto-orient/strip" alt=""></p><p>核心代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">// 左右晃动</div><div class="line">Keyframe frame0 = Keyframe.ofFloat(0f, 0);</div><div class="line">Keyframe frame1 = Keyframe.ofFloat(0.1f, -20f);</div><div class="line">Keyframe frame2 = Keyframe.ofFloat(0.2f, 20f);</div><div class="line">Keyframe frame3 = Keyframe.ofFloat(0.3f, -20f);</div><div class="line">Keyframe frame4 = Keyframe.ofFloat(0.4f, 20f);</div><div class="line">Keyframe frame5 = Keyframe.ofFloat(0.5f, -20f);</div><div class="line">Keyframe frame6 = Keyframe.ofFloat(0.6f, 20f);</div><div class="line">Keyframe frame7 = Keyframe.ofFloat(0.7f, -20f);</div><div class="line">Keyframe frame8 = Keyframe.ofFloat(0.8f, 20f);</div><div class="line">Keyframe frame9 = Keyframe.ofFloat(0.9f, -20f);</div><div class="line">Keyframe frame10 = Keyframe.ofFloat(1f, 0);</div><div class="line">PropertyValuesHolder frameHolder = PropertyValuesHolder.ofKeyframe(&quot;rotation&quot;,</div><div class="line">        frame0, frame1, frame2, frame3, frame4, frame5,</div><div class="line">        frame6, frame7, frame8, frame9, frame10);</div><div class="line">// X 轴缩放</div><div class="line">Keyframe scaleXFrame0 = Keyframe.ofFloat(0f, 1);</div><div class="line">Keyframe scaleXFrame1 = Keyframe.ofFloat(0.1f, 1.2f);</div><div class="line">Keyframe scaleXFrame9 = Keyframe.ofFloat(0.9f, 1.2f);</div><div class="line">Keyframe scaleXFrame10 = Keyframe.ofFloat(1f, 1);</div><div class="line">PropertyValuesHolder scaleXholder = PropertyValuesHolder.ofKeyframe(&quot;scaleX&quot;,</div><div class="line">        scaleXFrame0, scaleXFrame1, scaleXFrame9, scaleXFrame10);</div><div class="line">// Y 轴缩放</div><div class="line">Keyframe scaleYFrame0 = Keyframe.ofFloat(0f, 1);</div><div class="line">Keyframe scaleYFrame1 = Keyframe.ofFloat(0.1f, 1.2f);</div><div class="line">Keyframe scaleYFrame9 = Keyframe.ofFloat(0.9f, 1.2f);</div><div class="line">Keyframe scaleYFrame10 = Keyframe.ofFloat(1f, 1);</div><div class="line">PropertyValuesHolder scaleYholder = PropertyValuesHolder.ofKeyframe(&quot;scaleY&quot;,</div><div class="line">        scaleYFrame0, scaleYFrame1, scaleYFrame9, scaleYFrame10);</div><div class="line"></div><div class="line">Animator animator = ObjectAnimator.ofPropertyValuesHolder(mView,</div><div class="line">        frameHolder, scaleXholder, scaleYholder);</div><div class="line">animator.setDuration(2000);</div><div class="line">animator.start();</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;ValueAnimator、ObjectAnimator 除了 ofInt()、ofFloat()、ofObject() 函数创建 Animator 实例的方法以外，都还有一个方法：
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>03.6 精通自定义 View 之属性动画——Animator 动画的 XML 实现</title>
    <link href="http://yoursite.com/2019/07/03/Custom%20View/03.6%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94Animator%20%E5%8A%A8%E7%94%BB%E7%9A%84%20XML%20%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/07/03/Custom View/03.6 精通自定义 View 之属性动画——Animator 动画的 XML 实现/</id>
    <published>2019-07-02T22:00:00.000Z</published>
    <updated>2019-10-04T07:01:24.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>在 xml 中对应 animator 总共有三个标签，分别是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;animator /&gt;: 对应ValueAnimator</div><div class="line">&lt;objectAnimator /&gt;: 对应ObjectAnimator</div><div class="line">&lt;set /&gt;: 对应AnimatorSet</div></pre></td></tr></table></figure></p><h3 id="3-6-1-animator-标签"><a href="#3-6-1-animator-标签" class="headerlink" title="3.6.1 animator 标签"></a>3.6.1 animator 标签</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>下面是完整的 animator 所有的字段及取值范围：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;animator</div><div class="line">    android:duration=&quot;int&quot;</div><div class="line">    android:valueFrom=&quot;float | int | color&quot;</div><div class="line">    android:valueTo=&quot;float | int | color&quot;</div><div class="line">    android:startOffset=&quot;int&quot;</div><div class="line">    android:repeatCount=&quot;int&quot;</div><div class="line">    android:repeatMode=[&quot;repeat&quot; | &quot;reverse&quot;]</div><div class="line">    android:valueType=[&quot;intType&quot; | &quot;floatType&quot;]</div><div class="line">    android:interpolator=[&quot;@android:interpolator/XXX&quot;]/&gt;</div></pre></td></tr></table></figure></p><ul><li><strong>android:duration</strong>：每次动画播放的时长。</li><li><strong>android:valueFrom</strong>：初始动化值；取值范围为 float、int 和 color，如果取值为 float 对应的值样式应该为 89.0，取值为 Int 时，对应的值样式为：89；当取值为 clolor 时，对应的值样式为 #333333。</li><li><strong>android:valueTo</strong>：动画结束值；取值范围同样是 float、int 和 color 这三种类型的值。</li><li><strong>android:startOffset</strong>：动画激活延时；对应代码中的 startDelay(long delay) 函数；</li><li><strong>android:repeatCount</strong>：动画重复次数</li><li><strong>android:repeatMode</strong>：动画重复模式，取值为 repeat 和 reverse；repeat 表示正序重播，reverse 表示倒序重播</li><li><strong>android:valueType</strong>：表示参数值类型，取值为 intType 和 floatType；与 android:valueFrom、android:valueTo 相对应。如果这里的取值为 intType，那么 android:valueFrom、android:valueTo 的值也就要对应的是 int 类型的数值。如果这里的数值是 floatType，那么 android:valueFrom、android:valueTo 的值也要对应的设置为 float 类型的值。非常注意的是，如果 android:valueFrom、android:valueTo 的值设置为 color 类型的值，那么不需要设置这个参数。</li><li><strong>android:interpolator</strong>：设置加速器；有关系统加速器所对应的 xml 值对照表如下：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/14186083-cf80cc3cfd34b03a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>加载 XML 文件到程序中的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ValueAnimator valueAnimator = (ValueAnimator) AnimatorInflater.loadAnimator(</div><div class="line">    MainActivity.this,R.animator.animator);</div><div class="line">valueAnimator.start();</div></pre></td></tr></table></figure></p><h4 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;animator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">          android:valueFrom=&quot;0&quot;</div><div class="line">          android:valueTo=&quot;300&quot;</div><div class="line">          android:duration=&quot;1000&quot;</div><div class="line">          android:valueType=&quot;intType&quot;</div><div class="line">          android:interpolator=&quot;@android:anim/bounce_interpolator&quot;/&gt;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ValueAnimator valueAnimator = (ValueAnimator) AnimatorInflater.loadAnimator(</div><div class="line">        MainActivity.this, R.animator.animator);</div><div class="line">valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">   @Override</div><div class="line">   public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">       int offset = (int)animation.getAnimatedValue();</div><div class="line">       mTv1.layout(offset, offset, mTv1.getWidth() + offset,</div><div class="line">                   mTv1.getHeight() + offset);</div><div class="line">   &#125;</div><div class="line">&#125;);</div><div class="line">valueAnimator.start();</div></pre></td></tr></table></figure><h3 id="3-6-2-objectAnimator-标签"><a href="#3-6-2-objectAnimator-标签" class="headerlink" title="3.6.2 objectAnimator 标签"></a>3.6.2 objectAnimator 标签</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;objectAnimator</div><div class="line">    android:propertyName=&quot;string&quot;</div><div class="line">    android:duration=&quot;int&quot;</div><div class="line">    android:valueFrom=&quot;float | int | color&quot;</div><div class="line">    android:valueTo=&quot;float | int | color&quot;</div><div class="line">    android:startOffset=&quot;int&quot;</div><div class="line">    android:repeatCount=&quot;int&quot;</div><div class="line">    android:repeatMode=[&quot;repeat&quot; | &quot;reverse&quot;]</div><div class="line">    android:valueType=[&quot;intType&quot; | &quot;floatType&quot;]</div><div class="line">    android:interpolator=[&quot;@android:interpolator/XXX&quot;]/&gt;</div></pre></td></tr></table></figure><ul><li><strong>android:propertyName</strong>：对应属性名，即 ObjectAnimator 所需要操作的属性名。其它字段的意义与 animator 的意义与取值是一样的，下面再重新列举一下。</li></ul><h4 id="2-示例-1"><a href="#2-示例-1" class="headerlink" title="2. 示例"></a>2. 示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:propertyName=&quot;TranslationY&quot;</div><div class="line">    android:duration=&quot;2000&quot;</div><div class="line">    android:valueFrom=&quot;0.0&quot;</div><div class="line">    android:valueTo=&quot;400.0&quot;</div><div class="line">    android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;</div><div class="line">    android:valueType=&quot;floatType&quot;</div><div class="line">    android:repeatCount=&quot;1&quot;</div><div class="line">    android:repeatMode=&quot;reverse&quot;</div><div class="line">    android:startOffset=&quot;2000&quot;/&gt;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator = (ObjectAnimator) AnimatorInflater.loadAnimator(</div><div class="line">        MainActivity.this, R.animator.object_animator);</div><div class="line">animator.setTarget(mTv1);</div><div class="line">animator.start();</div></pre></td></tr></table></figure><h4 id="3-color"><a href="#3-color" class="headerlink" title="3. color"></a>3. color</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:propertyName=&quot;BackgroundColor&quot;</div><div class="line">    android:duration=&quot;5000&quot;</div><div class="line">    android:valueFrom=&quot;#ffff00ff&quot;</div><div class="line">    android:valueTo=&quot;#ffffff00&quot;/&gt;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator = (ObjectAnimator) AnimatorInflater.loadAnimator(</div><div class="line">        MainActivity.this, R.animator.color_animator);</div><div class="line">animator.setTarget(mTv1);</div><div class="line">animator.start();</div></pre></td></tr></table></figure><h3 id="3-6-3-set-标签"><a href="#3-6-3-set-标签" class="headerlink" title="3.6.3 set 标签"></a>3.6.3 set 标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;set android:ordering=[&quot;together&quot; | &quot;sequentially&quot;]&gt;</div></pre></td></tr></table></figure><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:ordering=&quot;together&quot;&gt;</div><div class="line">    &lt;objectAnimator</div><div class="line">        android:propertyName=&quot;x&quot;</div><div class="line">        android:duration=&quot;500&quot;</div><div class="line">        android:valueFrom=&quot;0&quot;</div><div class="line">        android:valueTo=&quot;400&quot;</div><div class="line">        android:valueType=&quot;floatType&quot;/&gt;</div><div class="line">    &lt;objectAnimator</div><div class="line">        android:propertyName=&quot;y&quot;</div><div class="line">        android:duration=&quot;500&quot;</div><div class="line">        android:valueFrom=&quot;0&quot;</div><div class="line">        android:valueTo=&quot;300&quot;</div><div class="line">        android:valueType=&quot;floatType&quot;/&gt;</div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure></p><p>加载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(</div><div class="line">        MainActivity.this, R.animator.set_animator);</div><div class="line">set.setTarget(mTv1);</div><div class="line">set.start();</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;在 xml 中对应 animator 总共有三个标签，分别是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>03.5 精通自定义 View 之属性动画——AnimatorSet</title>
    <link href="http://yoursite.com/2019/07/03/Custom%20View/03.5%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94AnimatorSet/"/>
    <id>http://yoursite.com/2019/07/03/Custom View/03.5 精通自定义 View 之属性动画——AnimatorSet/</id>
    <published>2019-07-02T21:00:00.000Z</published>
    <updated>2019-10-04T07:00:17.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>ValueAnimator 和 ObjectAnimator 都只能单单实现一个动画，那如果我们想要使用一个组合动画，就需要用到 AnimatorSet。</p><p>AnimatorSet 针对 ValueAnimator 和 ObjectAnimator 都是适用的，但一般而言，我们不会用到 ValueAnimator 的组合动画，所以我们这篇仅讲解 ObjectAnimator 下的组合动画实现。</p><p>在 AnimatorSet 中直接给为我们提供了两个方法 playSequentially 和 playTogether，playSequentially 表示所有动画依次播放，playTogether 表示所有动画一起开始。</p><h3 id="3-5-1-playSequentially-与-playTogether-函数"><a href="#3-5-1-playSequentially-与-playTogether-函数" class="headerlink" title="3.5.1 playSequentially() 与 playTogether() 函数"></a>3.5.1 playSequentially() 与 playTogether() 函数</h3><h4 id="1-playSequentially"><a href="#1-playSequentially" class="headerlink" title="1. playSequentially()"></a>1. playSequentially()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public void playSequentially(Animator... items);</div><div class="line">public void playSequentially(List&lt;Animator&gt; items);</div></pre></td></tr></table></figure><p>这里有两种声明，第一个是我们最常用的，它的参数是可变长参数，也就是说我们可以传进去任意多个 Animator 对象。这些对象的动画会逐个播放。第二个构造函数，是传进去一个 List&lt; Animator&gt; 的列表。原理一样，也是逐个去取 List 中的动画对象，然后逐个播放。</p><p>示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-5e9f4c01a7c476e3.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private Button mButton;</div><div class="line">    private TextView mTv1, mTv2;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        mButton =  findViewById(R.id.btn);</div><div class="line">        mTv1 =  findViewById(R.id.tv_1);</div><div class="line">        mTv2 =  findViewById(R.id.tv_2);</div><div class="line"></div><div class="line">        mButton.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                doPlaySequentiallyAnimator();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void doPlaySequentiallyAnimator() &#123;</div><div class="line">        ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1, </div><div class="line">                &quot;BackgroundColor&quot;, 0xffff00ff, 0xffffff00, 0xffff00ff);</div><div class="line">        ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1, </div><div class="line">                &quot;translationY&quot;, 0, 300, 0);</div><div class="line">        ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2, </div><div class="line">                &quot;translationY&quot;, 0, 400, 0);</div><div class="line"></div><div class="line">        AnimatorSet animatorSet = new AnimatorSet();</div><div class="line">        animatorSet.playSequentially(tv1BgAnimator, tv1TranslateY, tv2TranslateY);</div><div class="line">        animatorSet.setDuration(1000);</div><div class="line">        animatorSet.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>布局 act_main.xml：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/btn&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:padding=&quot;10dp&quot;</div><div class="line">        android:text=&quot;start anim&quot;/&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:id=&quot;@+id/tv_2&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_alignParentRight=&quot;true&quot;</div><div class="line">        android:layout_marginRight=&quot;30dp&quot;</div><div class="line">        android:background=&quot;#ff00ff&quot;</div><div class="line">        android:padding=&quot;10dp&quot;</div><div class="line">        android:text=&quot;TextView-2&quot; /&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:id=&quot;@+id/tv_1&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_toLeftOf=&quot;@id/tv_2&quot;</div><div class="line">        android:layout_marginRight=&quot;30dp&quot;</div><div class="line">        android:background=&quot;#ffff00&quot;</div><div class="line">        android:padding=&quot;10dp&quot;</div><div class="line">        android:text=&quot;TextView-1&quot; /&gt;</div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure></p><h4 id="2-playTogether"><a href="#2-playTogether" class="headerlink" title="2. playTogether()"></a>2. playTogether()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public void playTogether(Animator... items);</div><div class="line">public void playTogether(Collection&lt;Animator&gt; items);</div></pre></td></tr></table></figure><p>将上例中的代码更改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// animatorSet.playSequentially(tv1BgAnimator, tv1TranslateY, tv2TranslateY);</div><div class="line">animatorSet.playTogether(tv1BgAnimator, tv1TranslateY, tv2TranslateY);</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-75a764faeec10d66.gif?imageMogr2/auto-orient/strip" alt=""></p><p>即三个动画同时播放。</p><h4 id="3、playSequentially-和-playTogether-函数的真正意义"><a href="#3、playSequentially-和-playTogether-函数的真正意义" class="headerlink" title="3、playSequentially 和 playTogether 函数的真正意义"></a>3、playSequentially 和 playTogether 函数的真正意义</h4><p>想必大家都看到赛马，在赛马开始前，每个马都会被放在起点的小门后面，到点了，门打开，马开始一起往前跑。而假如我们把每匹马看做是一个动画，那我们的 playTogether 就相当于赛马场里每个赛道上门的意义（当比赛开始时，每个赛道上的门会打开，马就可以开始比赛了）；也就是说，playTogether 只是一个时间点上的一起开始，对于开始后，各个动画怎么操作就是他们自己的事了，至于各个动画结不结束也是他们自已的事了。所以最恰当的描述就是门只负责打开，打开之后马咋跑，门也管不着，最后，马回不回来跟门也没啥关系。门的责任只是到点就打开而已。放在动画上，就是在激活动画之后，动画开始后的操作只是动画自己来负责。至于动画结不结束，也只有动画自己知道。</p><p>而 playSequentially 的意义就是当一匹马回来以后，再放另一匹。那如果上匹马永远没回来，那下一匹马也永远不会被放出来。<br>放到动画上，就是把激活一个动画之后，动画之后的操作就是动画自己来负责了，这个动画结束之后，再激活下一个动画。如果上一个动画没有结束，那下一个动画就永远也不会被激活。</p><p>首先用 playTogether 来看个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1,</div><div class="line">        &quot;BackgroundColor&quot;, 0xffff00ff, 0xffffff00, 0xffff00ff);</div><div class="line">ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1,</div><div class="line">        &quot;translationY&quot;, 0, 300, 0);</div><div class="line">tv1TranslateY.setStartDelay(1000);</div><div class="line">tv1TranslateY.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2,</div><div class="line">        &quot;translationY&quot;, 0, 400, 0);</div><div class="line">tv2TranslateY.setStartDelay(1000);</div><div class="line"></div><div class="line">AnimatorSet animatorSet = new AnimatorSet();</div><div class="line">animatorSet.playTogether(tv1BgAnimator, tv1TranslateY, tv2TranslateY);</div><div class="line">animatorSet.setDuration(1000);</div><div class="line">animatorSet.start();</div></pre></td></tr></table></figure></p><p>在这个例子中，我们将 tv1TranslateY 开始延迟 1000 毫秒开始，并设为无限循环。tv2TranslateY 设为开始延迟 1000 毫秒。而tv1BgAnimator 则是没有任何设置，所以是默认直接开始。我们来看效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-aa0dd7dac5a3a77b.gif?imageMogr2/auto-orient/strip" alt=""></p><p>将上述例子做如下更改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// animatorSet.playTogether(tv1BgAnimator, tv1TranslateY, tv2TranslateY);</div><div class="line">animatorSet.playSequentially(tv1BgAnimator, tv1TranslateY, tv2TranslateY);</div></pre></td></tr></table></figure></p><p>使用 playSequentially 来逐个播放这三个动画，首先是tv1BgAnimator，动画结束之后，激活 tv1TranslateY。不过由于设置了延时，故 1000 毫秒再开始，而且该动画会无限循环。无限循环也就是说它永远也不会结束。那么第三个动画 tv2TranslateY 也永远不会开始。效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-a7a097fbfc347421.gif?imageMogr2/auto-orient/strip" alt=""></p><p>总结：</p><ul><li>playTogether 和 playSequentially 在激活动画后，控件的动画情况与它们无关，他们只负责定时激活控件动画。</li><li>playSequentially 只有上一个控件做完动画以后，才会激活下一个控件的动画，如果上一控件的动画是无限循环，那下一个控件就别再指望能做动画了。</li></ul><h4 id="4-实现无限循环动画"><a href="#4-实现无限循环动画" class="headerlink" title="4. 实现无限循环动画"></a>4. 实现无限循环动画</h4><p>因为 AnimatorSet 中没有设置循环次数的函数，所以得为每个动画设置了无限循环，并且只能用 playTogether() 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1,</div><div class="line">        &quot;BackgroundColor&quot;, 0xffff00ff, 0xffffff00, 0xffff00ff);</div><div class="line">tv1BgAnimator.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1,</div><div class="line">        &quot;translationY&quot;, 0, 300, 0);</div><div class="line">tv1TranslateY.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2,</div><div class="line">        &quot;translationY&quot;, 0, 400, 0);</div><div class="line">tv2TranslateY.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line"></div><div class="line">AnimatorSet animatorSet = new AnimatorSet();</div><div class="line">animatorSet.playTogether(tv1BgAnimator, tv1TranslateY, tv2TranslateY);</div><div class="line">animatorSet.setDuration(1000);</div><div class="line">animatorSet.start();</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-d38d7f24f286dbca.gif?imageMogr2/auto-orient/strip" alt=""></p><h3 id="3-5-2-AnimatorSet-Builder"><a href="#3-5-2-AnimatorSet-Builder" class="headerlink" title="3.5.2 AnimatorSet.Builder"></a>3.5.2 AnimatorSet.Builder</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>playTogether 和 playSequentially，分别能实现一起开始动画和逐个开始动画。但并不是非常自由的组合动画，比如我们有三个动画 A、B、C 我们想先播放 C 然后同时播放 A 和 B。利用 playTogether 和 playSequentially 是没办法实现的，所以为了更方便的组合动画，谷歌的开发人员另外给我们提供一个类 AnimatorSet.Builder。</p><p>我们这里使用 AnimatorSet.Builder 实现两个控件一同开始动画。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1,</div><div class="line">        &quot;BackgroundColor&quot;, 0xffff00ff, 0xffffff00, 0xffff00ff);</div><div class="line">ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1,</div><div class="line">        &quot;translationY&quot;, 0, 300, 0);</div><div class="line">ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2,</div><div class="line">        &quot;translationY&quot;, 0, 400, 0);</div><div class="line"></div><div class="line">AnimatorSet animatorSet = new AnimatorSet();</div><div class="line">AnimatorSet.Builder builder = animatorSet.play(tv1BgAnimator);</div><div class="line">builder.with(tv1TranslateY).with(tv2TranslateY);</div><div class="line">// animatorSet.playTogether(tv1BgAnimator, tv1TranslateY, tv2TranslateY);</div><div class="line">animatorSet.setDuration(1000);</div><div class="line">animatorSet.start();</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e31f09c7c1458d53.gif?imageMogr2/auto-orient/strip" alt=""></p><h4 id="2-AnimatorSet-Builder-的函数"><a href="#2-AnimatorSet-Builder-的函数" class="headerlink" title="2. AnimatorSet.Builder 的函数"></a>2. AnimatorSet.Builder 的函数</h4><p>从上面的代码中，我们可以看到 AnimatorSet.Builder 是通过 animatorSet.play(tv1BgAnimator) 生成的，这是生成AnimatorSet.Builder对象的唯一途径！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 表示要播放哪个动画</div><div class="line">public Builder play(Animator anim)</div><div class="line">// 和前面动画一起执行</div><div class="line">public Builder with(Animator anim)</div><div class="line">// 执行前面的动画后才执行该动画</div><div class="line">public Builder before(Animator anim)</div><div class="line">// 执行先执行这个动画再执行前面动画</div><div class="line">public Builder after(Animator anim)</div><div class="line">// 延迟 n 毫秒之后执行动画</div><div class="line">public Builder after(long delay)</div></pre></td></tr></table></figure></p><p>play(Animator anim) 表示当前在播放哪个动画，另外的 with(Animator anim)、before(Animator anim)、after(Animator anim) 都是以 play 中的当前所播放的动画为基准的。</p><p>比如，当 play(playAnim) 与 before(beforeAnim) 共用，则表示在播放 beforeAnim 之前，先播放 playAnim 动画；同样，当 play(playAnim) 与 after(afterAnim) 共用时，则表示在在播放 afterAnim 动画之后，再播放 playAnim 动画。</p><p>每个函数的返回值都是 Builder 对象，于是可以使用串行方式使用它们：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">animatorSet.play(tv1BgAnimator).with(tv1TranslateY).with(tv2TranslateY);</div></pre></td></tr></table></figure></p><h3 id="3-5-3-AnimatorSet-监听器"><a href="#3-5-3-AnimatorSet-监听器" class="headerlink" title="3.5.3 AnimatorSet 监听器"></a>3.5.3 AnimatorSet 监听器</h3><p>在 AnimatorSet 中也可以添加监听器，对应的监听器为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public static interface AnimatorListener &#123;</div><div class="line">    // 当AnimatorSet开始时调用</div><div class="line">    void onAnimationStart(Animator animation);</div><div class="line">    // 当AnimatorSet结束时调用</div><div class="line">    void onAnimationEnd(Animator animation);</div><div class="line">    // 当AnimatorSet被取消时调用</div><div class="line">    void onAnimationCancel(Animator animation);</div><div class="line">    /**</div><div class="line">     * 当 AnimatorSet 重复时调用，由于 AnimatorSet 没有设置 </div><div class="line">     * repeat 的函数，所以这个方法永远不会被调用。</div><div class="line">     */</div><div class="line">    void onAnimationRepeat(Animator animation);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private AnimatorSet mAnimatorSet;</div><div class="line">    private TextView mTv1, mTv2;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        mTv1 =  findViewById(R.id.tv_1);</div><div class="line">        mTv2 =  findViewById(R.id.tv_2);</div><div class="line"></div><div class="line">        findViewById(R.id.start_btn).setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                mAnimatorSet = doPlayAnimatorSet();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        findViewById(R.id.cancel_btn).setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                if (mAnimatorSet != null) &#123;</div><div class="line">                    mAnimatorSet.cancel();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private AnimatorSet doPlayAnimatorSet() &#123;</div><div class="line">        ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1,</div><div class="line">                &quot;translationY&quot;, 0, 400, 0);</div><div class="line">        ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2,</div><div class="line">                &quot;translationY&quot;, 0, 400, 0);</div><div class="line">        tv2TranslateY.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line"></div><div class="line">        AnimatorSet animatorSet = new AnimatorSet();</div><div class="line">        animatorSet.play(tv1TranslateY).with(tv2TranslateY);</div><div class="line">        animatorSet.addListener(new Animator.AnimatorListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationStart(Animator animation) &#123;</div><div class="line">                Log.e(&quot;xian&quot;, &quot;animator start&quot;);</div><div class="line">            &#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationEnd(Animator animation) &#123;</div><div class="line">                Log.e(&quot;xian&quot;, &quot;animator end&quot;);</div><div class="line">            &#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationCancel(Animator animation) &#123;</div><div class="line">                Log.e(&quot;xian&quot;, &quot;animator cancel&quot;);</div><div class="line">            &#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationRepeat(Animator animation) &#123;</div><div class="line">                Log.e(&quot;xian&quot;, &quot;animator repeat&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        animatorSet.setDuration(1000);</div><div class="line">        animatorSet.start();</div><div class="line"></div><div class="line">        return animatorSet;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-165bcafa582d0d1e.gif?imageMogr2/auto-orient/strip" alt=""></p><p>日志输出如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-41da58e3c9eab1e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>总结一下 AnimatorSet 的监听：<br>1、AnimatorSet 的监听函数也只是用来监听 AnimatorSet 的状态的，与其中的动画无关。<br>2、AnimatorSet 中没有设置循环的函数，所以 AnimatorSet 监听器中永远无法运行到 onAnimationRepeat() 中。</p></blockquote><h3 id="3-5-4-常用函数"><a href="#3-5-4-常用函数" class="headerlink" title="3.5.4 常用函数"></a>3.5.4 常用函数</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>在 AnimatorSet 中还有几个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 设置单次动画时长</div><div class="line">public AnimatorSet setDuration(long duration);</div><div class="line">// 设置加速器</div><div class="line">public void setInterpolator(TimeInterpolator interpolator)</div><div class="line">// 设置ObjectAnimator动画目标控件</div><div class="line">public void setTarget(Object target)</div></pre></td></tr></table></figure></p><p>在 AnimatorSet 中设置以后，会覆盖单个 ObjectAnimator 中的设置；即如果 AnimatorSet 中没有设置，那么就以 ObjectAnimator 中的设置为准。如果 AnimatorSet 中设置以后，ObjectAnimator 中的设置就会无效。</p><p>下面我们简单举个例子来看下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1, &quot;translationY&quot;, 0, 400, 0);</div><div class="line">tv1TranslateY.setDuration(500000000);</div><div class="line">tv1TranslateY.setInterpolator(new BounceInterpolator());</div><div class="line"></div><div class="line">ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2, &quot;translationY&quot;, 0, 400, 0);</div><div class="line">tv2TranslateY.setInterpolator(new AccelerateDecelerateInterpolator());</div><div class="line"></div><div class="line">AnimatorSet animatorSet = new AnimatorSet();</div><div class="line">animatorSet.play(tv2TranslateY).with(tv1TranslateY);</div><div class="line">animatorSet.setDuration(2000);</div><div class="line">animatorSet.start();</div></pre></td></tr></table></figure></p><p>在第这个例子中，我们通过 animatorSet.setDuration(2000); 设置为所有动画单词运动时长为 2000 毫秒，虽然我们给 tv1TranslateY 设置了单次动画时长为 tv1TranslateY.setDuration(500000000); 但由于 AnimatorSet 设置了 setDuration(2000) 这个参数以后，单个动画的时长设置将无效。所以每个动画的时长为 2000 毫秒。</p><p>但我们这里还分别给 tv1 和 tv2 设置了加速器，但并没有给 AnimatorSet 设置加速器，那么 tv1、tv2 将按各自加速器的表现形式做动画。同样，如果我们给 AnimatorSet 设置上了加速器，那么单个动画中所设置的加速器都将无效，以 AnimatorSet 中的加速器为准。</p><h4 id="2-setTarget-Object-target-函数"><a href="#2-setTarget-Object-target-函数" class="headerlink" title="2. setTarget(Object target) 函数"></a>2. setTarget(Object target) 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 设置 ObjectAnimator 动画目标控件</div><div class="line">public void setTarget(Object target)</div></pre></td></tr></table></figure><p>这个函数是用来设置目标控件的，也就是说，只要通过 AnimatorSet 的 setTartget 函数设置了目标控件，那么单个动画中的目标控件都以 AnimatorSet 设置的为准。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1, &quot;BackgroundColor&quot;, 0xffff00ff, 0xffffff00, 0xffff00ff);</div><div class="line">ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2, &quot;translationY&quot;, 0, 400, 0);</div><div class="line"></div><div class="line">AnimatorSet animatorSet = new AnimatorSet();</div><div class="line">animatorSet.playTogether(tv1BgAnimator,tv2TranslateY);</div><div class="line">animatorSet.setDuration(2000);</div><div class="line">animatorSet.setTarget(mTv2);</div><div class="line">animatorSet.start();</div></pre></td></tr></table></figure></p><p>在这段代码中，我们给 tv1 设置了改变背景色，给 tv2 设置了上下移动。但由于我们通过 animatorSet.setTarget(mTv2); 将各个动画的目标控件设置为 mTv2，所以 tv1 将不会有任何动画，所有的动画都会发生在 tv2 上。</p><h4 id="3-setStartDelay-long-startDelay-函数"><a href="#3-setStartDelay-long-startDelay-函数" class="headerlink" title="3. setStartDelay(long startDelay) 函数"></a>3. setStartDelay(long startDelay) 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 设置延时开始动画时长</div><div class="line">public void setStartDelay(long startDelay)</div></pre></td></tr></table></figure><p>上面我们讲了，当 AnimatorSet 所拥有的函数与单个动画所拥有的函数冲突时，就以 AnimatorSet 设置为准。但唯一的例外就是 setStartDelay。</p><ul><li>AnimatorSet 的延时是仅针对性的延长 AnimatorSet 激活时间的，对单个动画的延时设置没有影响。</li><li>AnimatorSet 真正激活延时 = AnimatorSet.startDelay + 第一个动画.startDelay</li><li>在 AnimatorSet 激活之后，第一个动画绝对是会开始运行的，后面的动画则根据自己是否延时自行处理。</li></ul><h3 id="3-5-5-示例：路径动画"><a href="#3-5-5-示例：路径动画" class="headerlink" title="3.5.5 示例：路径动画"></a>3.5.5 示例：路径动画</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-669df7152448f16f.gif?imageMogr2/auto-orient/strip" alt=""></p><p>代码 MainActivity.java：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private Button btn1, btn2, btn3, btn4, btn5;</div><div class="line">    private boolean mIsMenuOpen = false;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        Button menu = findViewById(R.id.menu);</div><div class="line">        btn1 = findViewById(R.id.btn1);</div><div class="line">        btn2 = findViewById(R.id.btn2);</div><div class="line">        btn3 = findViewById(R.id.btn3);</div><div class="line">        btn4 = findViewById(R.id.btn4);</div><div class="line">        btn5 = findViewById(R.id.btn5);</div><div class="line"></div><div class="line">        menu.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                if (mIsMenuOpen) &#123;</div><div class="line">                    closeMenu();</div><div class="line">                    mIsMenuOpen = false;</div><div class="line">                &#125; else &#123;</div><div class="line">                    openMenu();</div><div class="line">                    mIsMenuOpen = true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void openMenu() &#123;</div><div class="line">        doAnimateOpen(btn1, 0, 5, 600);</div><div class="line">        doAnimateOpen(btn2, 1, 5, 600);</div><div class="line">        doAnimateOpen(btn3, 2, 5, 600);</div><div class="line">        doAnimateOpen(btn4, 3, 5, 600);</div><div class="line">        doAnimateOpen(btn5, 4, 5, 600);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void closeMenu() &#123;</div><div class="line">        doAnimatColse(btn1, 0, 5, 600);</div><div class="line">        doAnimatColse(btn2, 1, 5, 600);</div><div class="line">        doAnimatColse(btn3, 2, 5, 600);</div><div class="line">        doAnimatColse(btn4, 3, 5, 600);</div><div class="line">        doAnimatColse(btn5, 4, 5, 600);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void doAnimateOpen(View view, int index, int total, int radius) &#123;</div><div class="line">        double degree = Math.toRadians(90) / (total - 1) * index;</div><div class="line">        int translationX = -(int) (Math.sin(degree) * radius);</div><div class="line">        int translationY = -(int) (Math.cos(degree) * radius);</div><div class="line">        AnimatorSet animatorSet = new AnimatorSet();</div><div class="line">        animatorSet.playTogether(</div><div class="line">                ObjectAnimator.ofFloat(view, &quot;translationX&quot;, 0, translationX),</div><div class="line">                ObjectAnimator.ofFloat(view, &quot;translationY&quot;, 0, translationY),</div><div class="line">                ObjectAnimator.ofFloat(view, &quot;scaleX&quot;, 0f, 1f),</div><div class="line">                ObjectAnimator.ofFloat(view, &quot;scaleY&quot;, 0f, 1f),</div><div class="line">                ObjectAnimator.ofFloat(view, &quot;alpha&quot;, 0f, 1f));</div><div class="line">        animatorSet.setDuration(500);</div><div class="line">        animatorSet.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void doAnimatColse(View view, int index, int total, int radius) &#123;</div><div class="line">        double degree = Math.toRadians(90) / (total - 1) * index;</div><div class="line">        int translationX = -(int) (Math.sin(degree) * radius);</div><div class="line">        int translationY = -(int) (Math.cos(degree) * radius);</div><div class="line">        AnimatorSet animatorSet = new AnimatorSet();</div><div class="line">        animatorSet.playTogether(</div><div class="line">                ObjectAnimator.ofFloat(view, &quot;translationX&quot;, translationX, 0),</div><div class="line">                ObjectAnimator.ofFloat(view, &quot;translationY&quot;, translationY, 0),</div><div class="line">                ObjectAnimator.ofFloat(view, &quot;scaleX&quot;, 1f, 0f),</div><div class="line">                ObjectAnimator.ofFloat(view, &quot;scaleY&quot;, 1f, 0f),</div><div class="line">                ObjectAnimator.ofFloat(view, &quot;alpha&quot;, 1f, 0f));</div><div class="line">        animatorSet.setDuration(500);</div><div class="line">        animatorSet.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>布局文件 act_main：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:padding=&quot;20dp&quot;&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/btn1&quot;</div><div class="line">        style=&quot;@style/MenuItemStyle&quot;</div><div class="line">        android:background=&quot;@drawable/circle1&quot;/&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/btn2&quot;</div><div class="line">        style=&quot;@style/MenuItemStyle&quot;</div><div class="line">        android:background=&quot;@drawable/circle2&quot;/&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/btn3&quot;</div><div class="line">        style=&quot;@style/MenuItemStyle&quot;</div><div class="line">        android:background=&quot;@drawable/circle3&quot;/&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/btn4&quot;</div><div class="line">        style=&quot;@style/MenuItemStyle&quot;</div><div class="line">        android:background=&quot;@drawable/circle4&quot;/&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/btn5&quot;</div><div class="line">        style=&quot;@style/MenuItemStyle&quot;</div><div class="line">        android:background=&quot;@drawable/circle5&quot;/&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/menu&quot;</div><div class="line">        style=&quot;@style/MenuStyle&quot;</div><div class="line">        android:background=&quot;@drawable/circle&quot;/&gt;</div><div class="line">&lt;/FrameLayout&gt;</div></pre></td></tr></table></figure></p><p>引用资源 circle.xml：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:shape=&quot;oval&quot;&gt;</div><div class="line">    &lt;solid android:color=&quot;@color/colorAccent&quot;/&gt;</div><div class="line">    &lt;solid android:color=&quot;#983B90&quot;/&gt;</div><div class="line">    &lt;solid android:color=&quot;#785B90&quot;/&gt;</div><div class="line">    &lt;solid android:color=&quot;#587BA0&quot;/&gt;</div><div class="line">    &lt;solid android:color=&quot;#389BF0&quot;/&gt;</div><div class="line">    &lt;solid android:color=&quot;#18DB00&quot;/&gt;</div><div class="line">&lt;/shape&gt;</div></pre></td></tr></table></figure></p><p>主题样式 style.xml：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;resources&gt;</div><div class="line">    ...</div><div class="line">    &lt;style name=&quot;MenuStyle&quot; &gt;</div><div class="line">        &lt;item name=&quot;android:layout_width&quot;&gt;50dp&lt;/item&gt;</div><div class="line">        &lt;item name=&quot;android:layout_height&quot;&gt;50dp&lt;/item&gt;</div><div class="line">        &lt;item name=&quot;android:layout_gravity&quot;&gt;right|bottom&lt;/item&gt;</div><div class="line">    &lt;/style&gt;</div><div class="line">    &lt;style name=&quot;MenuItemStyle&quot; &gt;</div><div class="line">        &lt;item name=&quot;android:layout_width&quot;&gt;40dp&lt;/item&gt;</div><div class="line">        &lt;item name=&quot;android:layout_height&quot;&gt;40dp&lt;/item&gt;</div><div class="line">        &lt;item name=&quot;android:layout_margin&quot;&gt;5dp&lt;/item&gt;</div><div class="line">        &lt;item name=&quot;android:layout_gravity&quot;&gt;right|bottom&lt;/item&gt;</div><div class="line">    &lt;/style&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;ValueAnimator 和 ObjectAnimator 都只能单单实现一个动画，那如果我们想要使用一个组合动画，就需要用到 AnimatorSet。&lt;/p&gt;
&lt;p&gt;Animat
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>03.4 精通自定义 View 之属性动画——ObjectAnimator</title>
    <link href="http://yoursite.com/2019/07/03/Custom%20View/03.4%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ObjectAnimator/"/>
    <id>http://yoursite.com/2019/07/03/Custom View/03.4 精通自定义 View 之属性动画——ObjectAnimator/</id>
    <published>2019-07-02T20:00:00.000Z</published>
    <updated>2019-10-04T06:58:43.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="3-4-1-概述"><a href="#3-4-1-概述" class="headerlink" title="3.4.1 概述"></a>3.4.1 概述</h3><h4 id="1-引入"><a href="#1-引入" class="headerlink" title="1. 引入"></a>1. 引入</h4><p>ObjectAnimator 派生自 ValueAnimator，所以 ValueAnimator 能用的方法，ObjectAnimator 都能用，ObjectAnimator 是 ValueAnimator 的子类。</p><p>ObjectAnimator 重载了几个方法，例如 ofInt()，ofFloat() 等，这里我以 ofFloat() 做个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(mView, &quot;alpha&quot;, 1, 0, 1);</div><div class="line">animator.setDuration(2000);</div><div class="line">animator.start();</div></pre></td></tr></table></figure></p><p>其构造函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static ObjectAnimator ofFloat(Object target, String propertyName,  float... values)</div></pre></td></tr></table></figure></p><ul><li>第一个参数用于指定这个动画要操作的是哪个控件。</li><li>第二个参数用于指定这个动画要操作这个控件的哪个属性。</li><li>第三个参数是可变长参数，是指这个属性值如何变化。</li></ul><h4 id="2-set-函数"><a href="#2-set-函数" class="headerlink" title="2. set 函数"></a>2. set 函数</h4><p>ObjectAnimator 做动画，是通过指定属性所对应的 set 方法来改变的。比如，我们上面指定的改变 alpha 的属性值，ObjectAnimator 在做动画时就会到指定控件（TextView）中去找对应的 setAlpha() 方法来改变控件中对应的值。在 View 中有关动画，总共有下面几组 set 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 1. 透明度：alpha  </div><div class="line">public void setAlpha(float alpha)  </div><div class="line">  </div><div class="line">// 2. 旋转度数：rotation、rotationX、rotationY  </div><div class="line">public void setRotation(float rotation)  </div><div class="line">public void setRotationX(float rotationX)  </div><div class="line">public void setRotationY(float rotationY)  </div><div class="line">  </div><div class="line">// 3. 平移：translationX、translationY  </div><div class="line">public void setTranslationX(float translationX)   </div><div class="line">public void setTranslationY(float translationY)  </div><div class="line">  </div><div class="line">// 4. 缩放：scaleX、scaleY  </div><div class="line">public void setScaleX(float scaleX)  </div><div class="line">public void setScaleY(float scaleY)</div></pre></td></tr></table></figure></p><p>注意：</p><ul><li>要使用 ObjectAnimator 来构造对画，要操作的控件中，必须存在对应的属性的 set 方法，而且参数类型必须与构造所使用的ofFloat() 或者 ofInt() 函数一致。</li><li>set 方法的命名必须以骆驼拼写法命名，即 set 后每个单词首字母大写，其余字母小写，即类似于 setPropertyName 所对应的属性为propertyName。</li></ul><p>1）改变旋转度数 rotation、rotationX、rotationY</p><ul><li>float rotationX：表示围绕 X 轴旋转，rotationX 表示旋转度数</li><li>float rotationY：表示围绕 Y 轴旋转，rotationY 表示旋转度数</li><li>float rotation：表示围绕 Z 轴（垂直于屏幕）旋转，rotation 表示旋转度数</li></ul><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(mView, &quot;rotationX&quot;, 0, 270, 0);</div><div class="line">// ObjectAnimator animator = ObjectAnimator.ofFloat(mView, &quot;rotationY&quot;, 0, 180, 0);</div><div class="line">// ObjectAnimator animator = ObjectAnimator.ofFloat(mView, &quot;rotation&quot;, 0, 270, 0);</div><div class="line">animator.setDuration(2000);</div><div class="line">animator.start();</div></pre></td></tr></table></figure></p><p>2）移动 translationX、translationY</p><ul><li>float translationX：表示在 X 轴上的平移距离，以当前控件为原点，向右为正方向，参数 translationX 表示移动的距离。</li><li>float translationY：表示在 Y 轴上的平移距离，以当前控件为原点，向下为正方向，参数 translationY 表示移动的距离。</li></ul><p>3）缩放 scaleX、scaleY</p><ul><li>float scaleX：在 X 轴上缩放，scaleX 表示缩放倍数</li><li>float scaleY：在 Y 轴上缩放，scaleY 表示缩放倍数</li></ul><p>4）改变透明度 alpha</p><ul><li>float alpha：改变透明度</li></ul><h3 id="3-4-2-ObjectAnimator-动画原理"><a href="#3-4-2-ObjectAnimator-动画原理" class="headerlink" title="3.4.2 ObjectAnimator 动画原理"></a>3.4.2 ObjectAnimator 动画原理</h3><p><img src="https://upload-images.jianshu.io/upload_images/3983615-03594160fc705404?imageMogr2/auto-orient/strip|imageView2/2/w/1187/format/webp" alt=""></p><p>与 ValueAnimator 不同的是最后一步，在 ValueAnimator 中，我们要通过添加监听器来监听当前数字值。而在 ObjectAnimator 中，则是先根据属性值拼装成对应的 set 函数的名字，比如这里的 scaleY 的拼装方法就是将属性的第一个字母强制大写后，与 set 拼接，所以就是 setScaleY 。然后通过反射找到对应控件的 setScaleY(float scaleY) 函数，将当前数字值做为 setScaleY(float scale) 的参数将其传入。</p><p>如果我们要自定义 ObjectAnimator 属性就要注意以下几个点：</p><ul><li>在命名时 set 之后的名字就是属性的名字。同时属性名字第一个字母不区分大小写，后面的名字必须与属性的名字相同。</li><li>在知道参数类型后我们才能确定我们是调用 ofFloat 还是 ofInt，这个参数是根据 setXXX 方法中的参数类型决定的。例如：setAlpha(float alpha) 其中参数类型是 float 所以上面我们使用的是 ofFloat，当然 ObjectAnimator 继承 ValueAnimatior 也有。ofObject()支持任意类型，不过和前面我们讲到的一样这里我们就要自定义自己的估值器了。</li></ul><h3 id="3-4-3-自定义-ObjectAnimator-属性"><a href="#3-4-3-自定义-ObjectAnimator-属性" class="headerlink" title="3.4.3 自定义 ObjectAnimator 属性"></a>3.4.3 自定义 ObjectAnimator 属性</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7e772b9076b48c45.gif?imageMogr2/auto-orient/strip" alt=""></p><p>自定义 FallingBallImageView 和 Evaluator<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class FallingBallImageView extends AppCompatImageView &#123;</div><div class="line">    public FallingBallImageView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setFallingPos(Point pos) &#123;</div><div class="line">        layout(pos.x, pos.y, pos.x + getWidth(), pos.y + getHeight());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static class FallingBallEvaluator implements TypeEvaluator&lt;Point&gt; &#123;</div><div class="line">        private Point point = new Point();</div><div class="line">        @Override</div><div class="line">        public Point evaluate(float fraction, Point startValue, Point endValue) &#123;</div><div class="line">            point.x = (int)(startValue.x + fraction * (endValue.x - startValue.x));</div><div class="line">            if (fraction * 2 &lt; 1) &#123;</div><div class="line">                point.y = (int) (startValue.y + fraction * 2 * (endValue.y - startValue.y));</div><div class="line">            &#125; else &#123;</div><div class="line">                point.y = endValue.y;</div><div class="line">            &#125;</div><div class="line">            return point;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在代码中，开始动画：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.act_main);</div><div class="line"></div><div class="line">        final FallingBallImageView view = findViewById(R.id.ball_img);</div><div class="line">        findViewById(R.id.start_btn).setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                ObjectAnimator animator = ObjectAnimator.ofObject(view, &quot;fallingPos&quot;,</div><div class="line">                        new FallingBallImageView.FallingBallEvaluator(),</div><div class="line">                        new Point(0, 0), new Point(500, 500));</div><div class="line">                animator.setDuration(2000);</div><div class="line">                animator.start();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>布局文件 act_main.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:layout_gravity=&quot;center_horizontal&quot;</div><div class="line">    android:orientation=&quot;horizontal&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.xxt.xtest.FallingBallImageView</div><div class="line">        android:id=&quot;@+id/ball_img&quot;</div><div class="line">        android:layout_width=&quot;50dp&quot;</div><div class="line">        android:layout_height=&quot;50dp&quot;</div><div class="line">        android:src=&quot;@drawable/circle&quot;/&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/start_btn&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_marginLeft=&quot;30dp&quot;</div><div class="line">        android:text=&quot;开启动画&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>其中，drawable/circle.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;shape</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:shape=&quot;oval&quot;&gt;</div><div class="line">    &lt;solid android:color=&quot;#FF0000&quot;/&gt;</div><div class="line">&lt;/shape&gt;</div></pre></td></tr></table></figure></p><h3 id="3-4-4-何时需要实现对应的-get-函数"><a href="#3-4-4-何时需要实现对应的-get-函数" class="headerlink" title="3.4.4 何时需要实现对应的 get 函数"></a>3.4.4 何时需要实现对应的 get 函数</h3><p>ObjectAnimator 有三个构造函数：ofInt()、ofFloat() 和 ofObject()，它们的最后一个参数都是可变长参数，用于指定动画值的变化区间。如果我们只定义一个值，如上例中改成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator = ObjectAnimator.ofObject(view, &quot;fallingPos&quot;,</div><div class="line">                        new FallingBallImageView.FallingBallEvaluator(),</div><div class="line">                        new Point(500, 500));</div></pre></td></tr></table></figure></p><p>则会发生异常，信息如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14186083-e4d89fda63bedd35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>当且仅当我们只给动画一个值时，程序才会调用属性对应的 get 函数来得到动画初始值。如果没有初始值，就会使用系统默认值。比如 ofInt() 函数中使用的参数类型是 int 类型，而 int 类型的默认值是 0，动画就会从 0 开始。所以上述自定义控件 FallingBallImageView 设置 get 函数，那么将会以 get 函数的返回值作为初始值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class FallingBallImageView extends AppCompatImageView &#123;</div><div class="line">    ...</div><div class="line">    public Point getFallingPos() &#123;</div><div class="line">        return new Point(0, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>总结：当且仅当动画只有一个过渡值时，系统才会调用属性对应的 get 函数来得到动画的初始值。当不存在 get 函数时，则会去动画参数类型的默认值作为初始值；当无法取得动画参数类型的默认值时，则会直接奔溃。</p></blockquote><h3 id="3-4-5-常用函数"><a href="#3-4-5-常用函数" class="headerlink" title="3.4.5 常用函数"></a>3.4.5 常用函数</h3><p>用法和效果与 ValueAnimator 的函数是完全一样的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h3 id=&quot;3-4-1-概述&quot;&gt;&lt;a href=&quot;#3-4-1-概述&quot; class=&quot;headerlink&quot; title=&quot;3.4.1 概述&quot;&gt;&lt;/a&gt;3.4.1 概述&lt;/h3&gt;&lt;h4
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>03.3 精通自定义 View 之属性动画——ofObject</title>
    <link href="http://yoursite.com/2019/07/03/Custom%20View/03.3%20%E7%B2%BE%E9%80%9A%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94ofObject/"/>
    <id>http://yoursite.com/2019/07/03/Custom View/03.3 精通自定义 View 之属性动画——ofObject/</id>
    <published>2019-07-02T19:00:00.000Z</published>
    <updated>2019-10-04T07:03:41.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static ValueAnimator ofObject(TypeEvaluator evaluator, Object... values)</div></pre></td></tr></table></figure><h3 id="3-3-1-示例：字母从-A-变化到-Z"><a href="#3-3-1-示例：字母从-A-变化到-Z" class="headerlink" title="3.3.1 示例：字母从 A 变化到 Z"></a>3.3.1 示例：字母从 A 变化到 Z</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-7be4c63a0f016955.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">private void startAnim() &#123;</div><div class="line">    ValueAnimator animator = ValueAnimator.ofObject(new CharEvaluator(),</div><div class="line">            Character.valueOf(&apos;A&apos;), Character.valueOf(&apos;Z&apos;));</div><div class="line">    animator.setDuration(3000);</div><div class="line">    animator.setInterpolator(new AccelerateInterpolator());</div><div class="line">    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">            char text = (Character) animation.getAnimatedValue();</div><div class="line">            mView.setText(String.valueOf(text));</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    animator.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class CharEvaluator implements TypeEvaluator&lt;Character&gt; &#123;</div><div class="line">    @Override</div><div class="line">    public Character evaluate(float fraction, Character startValue, Character endValue) &#123;</div><div class="line">        int startInt = (int) startValue;</div><div class="line">        int endInt = (int) endValue;</div><div class="line">        int value = (int) (startInt + fraction * (endInt - startInt));</div><div class="line">        return (char) value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-3-2-示例：抛物动画"><a href="#3-3-2-示例：抛物动画" class="headerlink" title="3.3.2 示例：抛物动画"></a>3.3.2 示例：抛物动画</h3><p><img src="https://upload-images.jianshu.io/upload_images/14186083-3e1482dc4d082b7f.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">private void startAnim() &#123;</div><div class="line">    ValueAnimator animator = ValueAnimator.ofObject(new FallingBallEvaluator(),</div><div class="line">            new Point(0, mTop), new Point(500, 500));</div><div class="line">    animator.setDuration(3000);</div><div class="line">    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">            Point p = (Point) animation.getAnimatedValue();</div><div class="line">            mView.layout(p.x, p.y, p.x + mView.getWidth(), p.y + mView.getHeight());</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    animator.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class FallingBallEvaluator implements TypeEvaluator&lt;Point&gt; &#123;</div><div class="line">    private Point point = new Point();</div><div class="line">    @Override</div><div class="line">    public Point evaluate(float fraction, Point startValue, Point endValue) &#123;</div><div class="line">        point.x = (int)(startValue.x + fraction * (endValue.x - startValue.x));</div><div class="line">        if (fraction * 2 &lt; 1) &#123;</div><div class="line">            point.y = (int) (startValue.y + fraction * 2 * (endValue.y - startValue.y));</div><div class="line">        &#125; else &#123;</div><div class="line">            point.y = endValue.y;</div><div class="line">        &#125;</div><div class="line">        return point;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;


&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;
      
    
    </summary>
    
    
      <category term="Custom View" scheme="http://yoursite.com/categories/Custom-View/"/>
    
    
      <category term="Custom View" scheme="http://yoursite.com/tags/Custom-View/"/>
    
  </entry>
  
</feed>
